onWait is "inserted" into the empty endpoint.
    We now have a real, live connection

   Disconnect From Client - DeviceCancelIo

   Disconnect From disconn command - DeviceCloseEndpoint?, DeviceCancelIo?

   Reconnect - DeviceCancelIo, DeviceClose, DeviceOpen, DeviceOpenEndpoint

    Once the user has fully logged onto a new connected WinStation, a
    DeviceCancelIo and then a DeviceClose is issued to release the
    new logged on WinStation from the connection. While this connection
    remains up, a new DeviceOpen and DeviceOpenEndpoint is done to
    connect this connection to the users previously disconnected WinStation.

NTSTATUS DeviceOpen( PTD, PSD_OPEN );

   Open and initialize private data structures. Calls the TdiDeviceOpen(), but
   this is a no-op.


NTSTATUS DeviceClose( PTD, PSD_CLOSE );

   Close the transport driver. If its an address endpoint,
   it will destroy it. If its a connection endpoint, it
   DOES not destroy it. 

   If the connection endpoint is destroyed, disconnect/reconnect
   will be broken.

   Calls TdiDeviceClose(), which is another no-op.


NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );

   Creates and Address endpoint that can be used for listening.

   This does not create any connection endpoints.

NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );

   Takes an existing connection endpoint handle, and makes
   an "endpoint" out of it.

   This is used by disconnect/reconnect.


NTSTATUS DeviceCloseEndpoint( PTD );

   This closes the endpoint.

   If its a connection endpoint, it is destroyed.


NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );

   This waits for connections to come in, and returns connected
   endpoints in the pIcaEndpoint structure.


NTSTATUS DeviceCancelIo( PTD );

   This asks for all I/O on the given endpoint to be canceled.

   With TDI, we can not actually cancel I/O, but must hold IRP's
   until indication handlers tell us to submit. This is because canceling
   I/O on a TDI connection causes the TDI provider to kill the connection.

NTSTATUS DeviceConnectionSend( PTD );

    This names sounds like send TD specific data to the host.

    This does not actually send anything, but fills in
    a structure for the upper level who may actually send it
    at some time.


NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );

    This is used by shadow to act as a network client and
    initiate a connection. This is obsolete and not used since
    a named pipe TD will handle all shadow traffic.

NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
*/


/*
 * Context used for connect accept
 */
typedef struct _ACCEPT_CONTEXT {
    PTD_ENDPOINT pAddressEndpoint;
    PTD_ENDPOINT pConnectionEndpoint;

    TDI_CONNECTION_INFORMATION RequestInfo;
    TDI_CONNECTION_INFORMATION ReturnInfo;
} ACCEPT_CONTEXT, *PACCEPT_CONTEXT;

/*=============================================================================
==   External Functions Defined
=============================================================================*/

// These are the functions our TD supplies to ICADD
NTSTATUS DeviceOpen( PTD, PSD_OPEN );
NTSTATUS DeviceClose( PTD, PSD_CLOSE );
NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS DeviceCloseEndpoint( PTD );
NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );
NTSTATUS DeviceConnectionSend( PTD );
NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceCancelIo( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
NTSTATUS DeviceQueryRemoteAddress( PTD, PVOID, ULONG, PVOID, ULONG, PULONG );


/*=============================================================================
==   External Functions Referenced
=============================================================================*/

// These functions are provided by the protocol specific TD module
NTSTATUS TdiDeviceOpen( PTD, PSD_OPEN );
NTSTATUS TdiDeviceClose( PTD, PSD_CLOSE );
NTSTATUS TdiDeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS TdiDeviceBuildTransportNameAndAddress( PTD, PICA_STACK_ADDRESS,
                                                PUNICODE_STRING,
                                                PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceBuildWildcardAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceWaitForDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT,
                                             PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceCompleteDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS TdiDeviceConnectionSend( PTD );
NTSTATUS TdiDeviceReadComplete( PTD, PUCHAR, PULONG );

// These are functions in our support libraries

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );

// Tdilib functions

PIRP
_TdiAllocateIrp(
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL
    );

NTSTATUS
_TdiCreateAddress (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           TdiAddress,
    IN ULONG           TdiAddressLength,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    );

NTSTATUS
_TdiOpenConnection (
    IN PUNICODE_STRING pTransportName,
    IN PVOID           ConnectionContext,
    OUT PHANDLE        pHandle,
    OUT PFILE_OBJECT   *ppFileObject,
    OUT PDEVICE_OBJECT *ppDeviceObject
    );

NTSTATUS
_TdiListen(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    );

NTSTATUS
_TdiConnect(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PLARGE_INTEGER pTimeout OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject,
    IN ULONG              RemoteTransportAddressLength,
    IN PTRANSPORT_ADDRESS pRemoteTransportAddress
    );

NTSTATUS
_TdiAssociateAddress(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN HANDLE         AddressHandle,
    IN PDEVICE_OBJECT AddressDeviceObject
    );

NTSTATUS
_TdiDisconnect(
    IN PTD pTd,
    IN PFILE_OBJECT   ConnectionFileObject,
    IN PDEVICE_OBJECT ConnectionDeviceObject
    );

NTSTATUS
_TdiSetEventHandler (
    IN PTD pTd,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
_TdiQueryAddressInfo(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTDI_ADDRESS_INFO pAddressInfo,
    IN ULONG AddressInfoLength
    );

NTSTATUS
_TdCancelReceiveQueue(
    PTD          pTd,
    PTD_ENDPOINT pEndpoint,
    NTSTATUS     CancelStatus
    );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TdCreateEndpointStruct( PTD, PUNICODE_STRING, PTD_ENDPOINT *, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS _TdCloseEndpoint( PTD, PTD_ENDPOINT );

NTSTATUS
_TdConnectHandler(
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

NTSTATUS
_TdDisconnectHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
_TdReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
_TdAcceptComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
_TdCreateConnectionObject(
    IN  PTD pTd,
    IN  PUNICODE_STRING pTransportName,
    OUT PTD_ENDPOINT *ppEndpoint,
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG TransportAddressLength
    );

NTSTATUS
_TdWaitForDatagramConnection(
    IN PTD pTd,
    IN PTD_ENDPOINT pAddressEndpoint,
    OUT PTD_ENDPOINT *ppConnectionEndpoint
    );

/*
 * Global Data
 */

extern USHORT TdiDeviceEndpointType; // Datagram or stream set by TD
extern USHORT TdiDeviceAddressType;  // TDI address format by TD
extern USHORT TdiDeviceInBufHeader;  // Bytes of header set by TD (0 for stream)


/*******************************************************************************
 * DeviceOpen
 *
 * Allocate and initialize private data structures
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 ******************************************************************************/
NTSTATUS DeviceOpen(PTD pTd, PSD_OPEN pSdOpen)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;

    DBGENTER(("DeviceOpen: PTD 0x%x\n",pTd));

    /*
     *  Set protocol driver class
     */
    pTd->SdClass = SdNetwork;
    pTd->InBufHeader = TdiDeviceInBufHeader; // For packet oriented protocols

    /*
     *  Return size of header and trailer
     */
    pSdOpen->SdOutBufHeader  = 0;
    pSdOpen->SdOutBufTrailer = 0;

    /*
     *  Allocate TDI TD data structure
     */
    Status = MemoryAllocate( sizeof(*pTdTdi), &pTdTdi );
    if ( !NT_SUCCESS(Status) ) 
        goto badalloc;

    ASSERT( pTd->pAfd == NULL );

    pTd->pAfd = pTdTdi;

    /*
     *  Initialize TDTDI data structure
     */
    RtlZeroMemory( pTdTdi, sizeof(*pTdTdi) );

    /*
     * Some protocols will make decisions on lower level
     * flow control depending on this value.
     */
    pTdTdi->OutBufDelay = pSdOpen->PdConfig.Create.OutBufDelay;

    /*
     *  Open device
     */
    Status = TdiDeviceOpen( pTd, pSdOpen );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    TRACE0(("DeviceOpen: Context 0x%x\n",pTd->pAfd));

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  open failed
     */
badopen:
    MemoryFree( pTd->pAfd );
    pTd->pAfd = NULL;

    /*
     *  allocate failed
     */
badalloc:
    return Status;
}


/*******************************************************************************
 * DeviceClose
 *
 * Close transport driver
 * NOTE: this must not close the current connection endpoint
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 ******************************************************************************/
NTSTATUS DeviceClose(PTD pTd, PSD_CLOSE pSdClose)
{
    PTDTDI pTdTdi;
    PTD_ENDPOINT pEndpoint;

    DBGENTER(("DeviceClose: PTD 0x%x Context 0x%x\n",pTd,pTd->pAfd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * Close address endpoint if we have one
     */
    if (pTdTdi != NULL) {
        if ( pEndpoint = pTdTdi->pAddressEndpoint ) {
            TRACE0(("DeviceClose: Closing AddressEndpoint 0x%x\n",pTdTdi->pAddressEndpoint));
            pTdTdi->pAddressEndpoint = NULL;
            _TdCloseEndpoint( pTd, pEndpoint );
        }
    
    #if DBG
        if( pEndpoint = pTdTdi->pConnectionEndpoint ) {
            ASSERT( IsListEmpty( &pEndpoint->ReceiveQueue) );
            TRACE0(("DeviceClose: Connection Endpoint 0x%x idled\n",pEndpoint));
        }
    #endif
    }

    /*
     *  Close device
     */
    (void)TdiDeviceClose(pTd, pSdClose);

    // TdUnload in td\common will free pTd->pAfd

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceCreateEndpoint
 *
 *  Create a TDI address object. Do not wait for, or make any connections.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLocalAddress (input)
 *       Pointer to local address (or null)
 *    pReturnedAddress (input)
 *       Pointer to location to save returned (created) address (or null)
 ******************************************************************************/
NTSTATUS DeviceCreateEndpoint(
        PTD pTd,
        PICA_STACK_ADDRESS pLocalAddress,
        PICA_STACK_ADDRESS pReturnedAddress)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    UNICODE_STRING TransportName;
    ULONG TransportAddressLength;
    PTD_ENDPOINT pEndpoint = NULL;
    PTRANSPORT_ADDRESS pTransportAddress = NULL;

    DBGENTER(("DeviceCreateEndpoint: PTD 0x%x\n",pTd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * Build transport device name and address. This is in the TD.
     */
    Status = TdiDeviceBuildTransportNameAndAddress( pTd, pLocalAddress,
                                                    &TransportName,
                                                    &pTransportAddress,
                                                    &TransportAddressLength );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceCreateEndpoint: Error building address 0x%x\n",Status));
        goto badaddress;
    }

    /*
     * Create the Endpoint structure.
     */
    Status = _TdCreateEndpointStruct(
                 pTd,
                 &TransportName,
                 &pEndpoint,
                 pTransportAddress,
                 TransportAddressLength
                );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceCreateEndpoint: Error creating endpointstruct 0x%x\n",Status));
        goto badcreate;
    }

    pEndpoint->EndpointType = TdiAddressObject;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create the TDI address object.
     */
    Status = _TdiCreateAddress(
                 &pEndpoint->TransportName,
                 pEndpoint->pTransportAddress,
                 pEndpoint->TransportAddressLength,
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceCreateEndpoint: Error creating TDI address object 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pEndpoint );
        goto badcreate;
    }

    if ( pReturnedAddress ) {
        DBGPRINT(("DeviceCreateEndpoint: Address returned Type 0x%x\n",pTransportAddress->Address[0].AddressType));
        RtlCopyMemory( pReturnedAddress,
                       &pTransportAddress->Address[0].AddressType,
                       min( sizeof( *pReturnedAddress ),
                            pEndpoint->TransportAddressLength ) );
    }
    
    /*
     * Save a pointer to the address endpoint
     */
    pTdTdi->pAddressEndpoint = pEndpoint;

    /*
     * Free transport name and address buffers
     */
    MemoryFree( TransportName.Buffer );
    MemoryFree( pTransportAddress );
    
    TRACE0(("DeviceCreateEndPoint: AddressEndpoint 0x%x Created, FO 0x%x DO 0x%x, Handle 0x%x\n",pEndpoint,pEndpoint->pFileObject,pEndpoint->pDeviceObject,pEndpoint->TransportHandle));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badcreate:
    if ( TransportName.Buffer )
        MemoryFree( TransportName.Buffer );
    if ( pTransportAddress )
        MemoryFree( pTransportAddress );

badaddress:
    return( Status );
}


/*******************************************************************************
 * DeviceOpenEndpoint
 *
 *  Causes an existing end point to copy its data into a new one.
 *  The handle is passed in from TermSrv, and was returned to it at one time
 *  from DeviceConnectionWait().
 *  NOTE: TermSrv can call this multiple times with the same handle for
 *        multiple connects/disconnects.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 ******************************************************************************/
NTSTATUS DeviceOpenEndpoint(
        PTD pTd,
        PVOID pIcaEndpoint,
        ULONG IcaEndpointLength)
{
    PTDTDI pTdTdi;
    PTD_STACK_ENDPOINT pStackEndpoint;
    PVOID Handle;
    ULONG Length;
    NTSTATUS Status;

    DBGENTER(("DeviceOpenEndpoint: PTD 0x%x\n",pTd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    TRACE(( pTd->pContext, TC_TD, TT_API2, 
        "TDTDI: DeviceOpenEndpoint, copying existing endpoint\n" ));

    if( IcaEndpointLength < sizeof(PVOID) ) {
        DBGPRINT(("DeviceOpenEndpoint: IcaEndpointLength to small %d\n",IcaEndpointLength));
        Status = STATUS_INVALID_HANDLE;
        goto done;
    }

    /*
     * Capture the parameter
     */
    try {
        ProbeForRead( pIcaEndpoint, sizeof(PVOID), 1 );
        Handle = (*((PVOID *)pIcaEndpoint));
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        DBGPRINT(("DeviceOpenEndpoint: Exception 0x%x\n",Status));
        goto done;
    }

    TRACE0(("DeviceOpenEndpoint: Fetching Handle 0x%x\n",Handle));

    /*
     * See if ICADD knows about the handle
     */
    Status = IcaReturnHandle( Handle, &pStackEndpoint, &Length );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceOpenEndpoint: ICADD handle 0x%x no good 0x%x\n",Handle,Status));
        Status = STATUS_INVALID_HANDLE;
        goto done;
    }

    if( Length != sizeof(TD_STACK_ENDPOINT) ) {
#if DBG
        DBGPRINT(("DeviceOpenEndpoint: Bad TD_STACK_ENDPOINT length %d, sb %d\n",Length,sizeof(TD_STACK_ENDPOINT)));
        DbgBreakPoint(); // Internal corruption
#endif
        Status = STATUS_INVALID_HANDLE;
        goto done;
    }

    ASSERT( pStackEndpoint->AddressType == TdiDeviceAddressType );
    ASSERT( pStackEndpoint->pEndpoint->hIcaHandle == Handle );

    /*
     * Save endpoint as the current connection endpoint
     */
    pTdTdi->pConnectionEndpoint = pStackEndpoint->pEndpoint;

    ASSERT( IsListEmpty( &pTdTdi->pConnectionEndpoint->ReceiveQueue) );

    TRACE0(("DeviceOpenEndpoint: Returned Endpoint 0x%x\n",pStackEndpoint->pEndpoint));

    /*
     * Save the file/device objects used for I/O in the TD structure
     */
    pTd->pFileObject = pTdTdi->pConnectionEndpoint->pFileObject;
    pTd->pDeviceObject = pTdTdi->pConnectionEndpoint->pDeviceObject;

    TRACE0(("DeviceOpenEndpoint: Connection Endpoint 0x%x opened on Context 0x%x\n",pTdTdi->pConnectionEndpoint,pTd->pAfd));
    TRACE0(("FO 0x%x, DO 0x%x, Handle 0x%x\n",pTdTdi->pConnectionEndpoint->pFileObject,pTdTdi->pConnectionEndpoint->pDeviceObject,pTdTdi->pConnectionEndpoint->TransportHandle));

    Status = STATUS_SUCCESS;

    if ( NT_SUCCESS(Status) ) {
        Status = TdiDeviceOpenEndpoint( pTd, pIcaEndpoint, IcaEndpointLength );
    }

done:
    return( Status );
}


/*******************************************************************************
 * DeviceCloseEndpoint
 ******************************************************************************/
NTSTATUS DeviceCloseEndpoint(PTD pTd)
{
    ULONG Length;
    KIRQL OldIrql;
    PTDTDI pTdTdi;
    NTSTATUS Status;
    PTD_ENDPOINT pEndpoint;
    PTD_STACK_ENDPOINT pStackEndpoint;

    DBGENTER(("DeviceCloseEndpoint: PTD 0x%x, Context 0x%x\n",pTd,pTd->pAfd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * Close connection endpoint if we have one
     * NOTE: The address endpoint, if there is one,
     *       gets closed in the DeviceClose routine.
     */
    if ( pEndpoint = pTdTdi->pConnectionEndpoint ) {

        TRACE0(("DeviceCloseEndpoint: Closing Connection Endpoint 0x%x, on Context 0x%x\n",pEndpoint,pTd->pAfd));
        ASSERT( pEndpoint->EndpointType != TdiAddressObject );

        ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );

        pEndpoint->Disconnected = TRUE;

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        /*
         * Cancel any pended receives
         */
        _TdCancelReceiveQueue(pTd, pEndpoint, STATUS_LOCAL_DISCONNECT );

        pTd->pFileObject = NULL;
        pTd->pDeviceObject = NULL;
        pTdTdi->pConnectionEndpoint = NULL;

        // If a handle registered with ICADD, close it
        if( pEndpoint->hIcaHandle ) {
            Status = IcaCloseHandle( pEndpoint->hIcaHandle, &pStackEndpoint, &Length );
            if( NT_SUCCESS(Status) ) {
                ASSERT( pStackEndpoint->pEndpoint == pEndpoint );
                /*
                 * Release our context memory
                 */
                MemoryFree( pStackEndpoint );
            }
            else {
                DBGPRINT(("DeviceCloseEndpoint: hIcaDevice 0x%x Invalid!\n",pEndpoint->hIcaHandle));
#if DBG
                DbgBreakPoint();
#endif
            }
        }

        _TdCloseEndpoint( pTd, pEndpoint );
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 * DeviceConnectionWait
 *
 *  This function is called in a loop from the upper level. We must create
 *  a connection object, associate it with the address object, listen on it,
 *  and return a single connection to our caller. We are called again for
 *  more connections.
 *  NOTE: The endpoint structure is an opaque, variable length data 
 *        structure whose length and contents are determined by the 
 *        transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Points to the actual number of bytes written to pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionWait(
        PTD pTd, 
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    KIRQL OldIrql;
    PLIST_ENTRY  pEntry;
    PVOID Handle;
    PTD_ENDPOINT pAddressEndpoint;
    PTD_ENDPOINT pConnectionEndpoint = NULL;
    PTD_STACK_ENDPOINT pStackEndpoint = NULL;

    DBGENTER(("DeviceConnectionWait: PTD 0x%x\n",pTd));

    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    if (pTd->fClosing) {
        return STATUS_DEVICE_NOT_READY;
    }

    /*
     * Initialize return buffer size
     */
    *BytesReturned = sizeof(TD_STACK_ENDPOINT);

    /*
     * Verify output endpoint buffer is large enough
     */
    if ( Length < sizeof(TD_STACK_ENDPOINT) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        DBGPRINT(("DeviceConnectionWait: Output buffer to small\n"));        
        goto done;
    }

    /*
     * Ensure we have a TDI address endpoint already
     */
    if ( (pAddressEndpoint = pTdTdi->pAddressEndpoint) == NULL ) {
        Status = STATUS_DEVICE_NOT_READY;
        DBGPRINT(("DeviceConnectionWait: No TDI address object\n"));        
        goto done;
    }

    /*
     * Different handling for datagram connections
     */
    if (TdiDeviceEndpointType == TdiConnectionDatagram) {
        Status = _TdWaitForDatagramConnection(
                pTd,
                pAddressEndpoint,
                &pConnectionEndpoint);

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("DeviceConnectionWait: Error Status 0x%x from "
                    "_TdWaitForDatagramConnection\n", Status));
            return Status;
        }

        goto ConnectAccepted;
    }

    ExAcquireSpinLock(&pAddressEndpoint->Spinlock, &OldIrql);

    /*
     * Data receive indication must be registered on the
     * address endpoint before any data endpoints are created.
     *
     * This is because we can not set receive indication on a
     * dataendpoint, it can only be inherited from its
     * address endpoint.
     */
    if (!pAddressEndpoint->RecvIndicationRegistered) {
        pAddressEndpoint->RecvIndicationRegistered = TRUE;
        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

        /*
         * Register the receive event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_RECEIVE,
                    (PVOID)_TdReceiveHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );

        pAddressEndpoint->DisconnectIndicationRegistered = TRUE;

            /*
         * Register the disconnect event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_DISCONNECT,
                    (PVOID)_TdDisconnectHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );
    }

    /*
     * Everytime into this function, we attempt to create more
     * Connection object's util we have reached TDTDI_LISTEN_QUEUE_DEPTH.
     *
     * These connection objects are linked off of our address endpoint.
     *
     * This is because we can only create connection objects
     * at call level, not at indication level. The indication level
     * will grab connection objects off of the address endpoint,
     * and accept them. It will then set the accept event on the
     * address object. This is optimized for only (1) thread
     * accepting connections, which is the current TD design.
     * Otherwise, thundering herd could occur on the accept event.
     *
     * This function then returns with the accepted connection
     * object. The upper level listen thread will then call
     * this function again to retrieve another connection.
     *
     * This prevents the refusing of connections due to not
     * having any outstanding listen's available when a WinFrame
     * client connect request comes in.
     */

    while (pAddressEndpoint->ConnectionQueueSize <= TDTDI_LISTEN_QUEUE_DEPTH) {

        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

        Status = _TdCreateConnectionObject(
                     pTd,
                     &pAddressEndpoint->TransportName,
                     &pConnectionEndpoint,
                     pAddressEndpoint->pTransportAddress,
                     pAddressEndpoint->TransportAddressLength
                     );

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );

        if( !NT_SUCCESS(Status) ) {
            DBGPRINT(("DeviceConnectionWait: Error 0x%x Creating ConnectionObject\n",Status));        
            break;
        }
        ASSERT( pConnectionEndpoint->Connected == FALSE );
        InsertTailList( &pAddressEndpoint->ConnectionQueue, &pConnectionEndpoint->ConnectionLink );
        pAddressEndpoint->ConnectionQueueSize++;
    }

    /*
     * If we have not registered our Connect Indication handler
     * yet, do it now. We had to delay it until connection objects
     * were created and ready.
     */
    if (!pAddressEndpoint->ConnectIndicationRegistered) {
        pTdTdi->pAddressEndpoint->ConnectIndicationRegistered = TRUE;
        ASSERT( !IsListEmpty( &pAddressEndpoint->ConnectionQueue ) );
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

        /*
         * Register to receive connect indications
         *
         * *** Note that Connect events can be delivered IMMEDIATELY upon
         *     completion of this request!
         */
        Status = _TdiSetEventHandler(
                     pTd,
                     pAddressEndpoint->pDeviceObject,
                     pAddressEndpoint->pFileObject,
                     TDI_EVENT_CONNECT,
                     (PVOID)_TdConnectHandler,
                     (PVOID)pAddressEndpoint   // Context
                     );

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("DeviceConnectionWait: Error 0x%x Setting TdiConnectHandler\n",Status));        
            ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );
            pTdTdi->pAddressEndpoint->ConnectIndicationRegistered = FALSE;
            ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
            goto done;
        }

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );
    }

    /*
     * While holding the spinlock, see if any connected objects
     * are on the connected queue.
     */
    while (IsListEmpty( &pAddressEndpoint->ConnectedQueue)) {
        KeResetEvent( &pAddressEndpoint->AcceptEvent );
        ASSERT( pAddressEndpoint->Waiter == FALSE );
        pAddressEndpoint->Waiter = TRUE;
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

        Status = IcaWaitForSingleObject(
                     pTd->pContext,
                     &pAddressEndpoint->AcceptEvent,
                     (-1) // No timeout
                     );

        ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );

        ASSERT( pAddressEndpoint->Waiter == TRUE );
        pAddressEndpoint->Waiter = FALSE;

        /*
         * Wait failure, could be due to thread receiving APC.
         */
        if( Status != STATUS_SUCCESS ) {
            DBGPRINT(("DeviceConnectionWait: Thread wait interrupted! Status 0x%x\n",Status));
            ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
            return( Status );
        }

        if( pTd->fClosing ) {
            DBGPRINT(("DeviceConnectionWait: TD is Closing!\n"));
            ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
            return( STATUS_CTX_CLOSE_PENDING );
        }

        // Should only be (1) accept thread in the TD.
        ASSERT( !IsListEmpty(&pAddressEndpoint->ConnectedQueue) );
    }

    /*
     * Dequeue the connected connection object
     */
    pEntry = RemoveHeadList( &pAddressEndpoint->ConnectedQueue );
    pAddressEndpoint->ConnectionQueueSize--;
    pConnectionEndpoint = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );

    ASSERT( pConnectionEndpoint->Connected == TRUE );

    /*
     * There could have been a final phase accept error, or
     * the remote side dropped the connection right away.
     *
     * In this case, we must tear down the errored connection.
     */
    if (!NT_SUCCESS(pConnectionEndpoint->Status)) {
        Status = pConnectionEndpoint->Status;
        DBGPRINT(("DeviceConnectionWait: Accept indication failed, Status 0x%x\n",Status));        
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );

ConnectAccepted:
    /*
     * Allocate a context structure and register our endpoint as
     * a handle with ICADD. The handle returned by ICADD will then
     * be placed into the user mode callers buffer as the endpoint
     * handle.
     *
     * A later call to DeviceOpenEndpoint() will validate this handle,
     * retreive the context, and allow use of the endpoint.
     */
    Status = MemoryAllocate( sizeof(TD_STACK_ENDPOINT), &pStackEndpoint );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionWait: Could not allocate memory 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    pStackEndpoint->AddressType = TdiDeviceAddressType;
    pStackEndpoint->pEndpoint = pConnectionEndpoint;

    Status = IcaCreateHandle( (PVOID)pStackEndpoint, sizeof(TD_STACK_ENDPOINT), &Handle );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionWait: Error creating ICADD handle 0x%x\n",Status));
        MemoryFree( pStackEndpoint );
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    Status = STATUS_SUCCESS;

    /*
     * Fill in the stack endpoint structure to be returned
     */
    try {
        ProbeForWrite( pIcaEndpoint, sizeof(PVOID), 1 );
        *((PVOID *)pIcaEndpoint) = Handle;
        *BytesReturned = sizeof(PVOID);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DBGPRINT(("DeviceConnectionWait: Exception returning result 0x%x\n",Status));
    }

    // Exception
    if( !NT_SUCCESS(Status) ) {
        ULONG Length;
        NTSTATUS Status2;

        DBGPRINT(("DeviceConnectionWait: Exception returning result 0x%x\n",Status));

        Status2 = IcaCloseHandle( Handle, &pStackEndpoint, &Length );
        if( NT_SUCCESS(Status2) ) {
            MemoryFree( pStackEndpoint );
        }
        _TdCloseEndpoint( pTd, pConnectionEndpoint );
        return( Status );
    }

    pConnectionEndpoint->hIcaHandle = Handle;

    TRACE0(("DeviceConnectionWait: New Connection Endpoint 0x%x Returned on Context 0x%x, AddressEndpoint 0x%x\n",pConnectionEndpoint,pTd->pAfd,pAddressEndpoint));
    TRACE0(("FO 0x%x, DO 0x%x, Handle 0x%x\n",pConnectionEndpoint->pFileObject,pConnectionEndpoint->pDeviceObject,pConnectionEndpoint->TransportHandle));

done:
    return Status;
}


/*******************************************************************************
 * DeviceConnectionSend
 *
 * Initialize host module data structure, which gets sent to the client.
 ******************************************************************************/
NTSTATUS DeviceConnectionSend(PTD pTd)
{
    return TdiDeviceConnectionSend(pTd);
}


/*******************************************************************************
 * DeviceConnectionRequest
 *
 *  Initiate a connection to the specified remote address
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pRemoteAddress (input)
 *       Pointer to remote address to connect to
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Pointer to location to return length of pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionRequest(
        PTD pTd,
        PICA_STACK_ADDRESS pRemoteAddress,
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    KIRQL OldIrql;
    PLIST_ENTRY  pEntry;
    PVOID Handle;
    PTD_ENDPOINT pAddressEndpoint;
    PTD_ENDPOINT pConnectionEndpoint = NULL;
    PTD_STACK_ENDPOINT pStackEndpoint = NULL;

    ICA_STACK_ADDRESS LocalAddress;    
    PICA_STACK_ADDRESS pLocalAddress = &LocalAddress;    

    UNICODE_STRING TransportName;
    ULONG TransportAddressLength;
    PTD_ENDPOINT pEndpoint = NULL;
    PTRANSPORT_ADDRESS pTransportAddress = NULL;

    UNICODE_STRING RemoteTransportName;
    ULONG RemoteTransportAddressLength;
    PTRANSPORT_ADDRESS pRemoteTransportAddress = NULL;

    ULONG timeout;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;

    PTDI_ADDRESS_IP pTdiAddress;

#if DBG
    PTDI_ADDRESS_INFO pTdiLocalAddressInfo;
    ULONG LocalAddressInfoLength;
#endif

    DBGENTER(("DeviceConnectionRequest: PTD 0x%x\n",pTd));

    //
    // This part is from the above DeviceConnectionwait:
    //

    if (pRemoteAddress == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }
    /*
     *  Get pointer to TDI parameters
     */
    pTdTdi = (PTDTDI) pTd->pAfd;

    if (pTd->fClosing) {
        return STATUS_DEVICE_NOT_READY;
    }

    /*
     * Initialize return buffer size
     */
    *BytesReturned = sizeof(TD_STACK_ENDPOINT);

    /*
     * Verify output endpoint buffer is large enough
     */
    if ( Length < sizeof(TD_STACK_ENDPOINT) ) {
        Status = STATUS_BUFFER_TOO_SMALL;
        DBGPRINT(("DeviceConnectionRequest: Output buffer to small\n"));        
        goto done;
    }

    /*
     * Different handling for datagram connections
     */
    if (TdiDeviceEndpointType == TdiConnectionDatagram) {
        Status = STATUS_NOT_SUPPORTED;
        goto done;
    }

    //
    // Extract timeout value and reset to NULL, will require adding timeout
    // into ICA_STACK_ADDRESS, too riskly for Whistler.
    //
    pTdiAddress = (PTDI_ADDRESS_IP) ((PCHAR)pRemoteAddress + 2);
    RtlCopyMemory( &timeout, &pTdiAddress->sin_zero[0], sizeof(timeout) );
    RtlZeroMemory( &pTdiAddress->sin_zero[0], sizeof(timeout) );


    //
    // Build the remote address
    //
    DBGPRINT(("TDTCP:DeviceConnectionRequest: building REMOTE address ...\n"));
    DBGPRINT(("TDTCP:DeviceConnectionRequest: Timeout %d\n", timeout));
    Status = TdiDeviceBuildTransportNameAndAddress( pTd, pRemoteAddress,
                                                    &RemoteTransportName,
                                                    &pRemoteTransportAddress,
                                                    &RemoteTransportAddressLength );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceConnectionRequest: Error building address 0x%x\n",Status));
        goto badaddress;
    }

    MemoryFree( RemoteTransportName.Buffer ); // not used, should make it optional in the call above
    RemoteTransportName.Buffer = NULL;

    /*
     * Build transport device name and address. This is in the TD.
     */

    DBGPRINT(("TDTCP:DeviceConnectionRequest: building LOCAL address ...\n"));

    //
    // We build a wild card local address let tcpip driver pick up port and NIC card.
    //
    RtlZeroMemory(pLocalAddress, sizeof(LocalAddress));
    *(PUSHORT)pLocalAddress = TDI_ADDRESS_TYPE_IP;
   
    Status = TdiDeviceBuildTransportNameAndAddress( pTd, pLocalAddress,
                                                    &TransportName,
                                                    &pTransportAddress,
                                                    &TransportAddressLength );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceConnectionRequest: Error building address 0x%x\n",Status));
        goto badaddress;
    }

    /*
     * Create the Endpoint structure.
     */
    Status = _TdCreateEndpointStruct(
                 pTd,
                 &TransportName,
                 &pEndpoint,
                 pTransportAddress,
                 TransportAddressLength
                );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("DeviceConnectionRequest: Error creating endpointstruct 0x%x\n",Status));
        goto badcreate;
    }

    pEndpoint->EndpointType = TdiAddressObject;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create the TDI address object.
     */
    Status = _TdiCreateAddress(
                 &pEndpoint->TransportName,
                 pEndpoint->pTransportAddress,
                 pEndpoint->TransportAddressLength,
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: Error creating TDI address object 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pEndpoint );
        goto badcreate;
    }

    /*
     * Save a pointer to the address endpoint
     */
    pTdTdi->pAddressEndpoint = pEndpoint;
    pAddressEndpoint = pTdTdi->pAddressEndpoint;
    /*
     * Free transport name and address buffers
     */
    MemoryFree( TransportName.Buffer );
    TransportName.Buffer = NULL;
    MemoryFree( pTransportAddress );
    pTransportAddress = NULL;
    
    //*************************************************************

    ExAcquireSpinLock(&pAddressEndpoint->Spinlock, &OldIrql);

    /*
     * Data receive indication must be registered on the
     * address endpoint before any data endpoints are created.
     *
     * This is because we can not set receive indication on a
     * dataendpoint, it can only be inherited from its
     * address endpoint.
     */
    if (!pAddressEndpoint->RecvIndicationRegistered) {
        pAddressEndpoint->RecvIndicationRegistered = TRUE;

        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

        /*
         * Register the receive event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_RECEIVE,
                    (PVOID)_TdReceiveHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );
        if( !NT_SUCCESS(Status) )
        {
            // Already released the spin lock
            DBGPRINT(("DeviceConnectionRequest: failed to _TdiSetEventHandler on TDI_EVENT_RECEIVE 0x%x\n",Status));        
            goto badconnect1;
        }

        pAddressEndpoint->DisconnectIndicationRegistered = TRUE;

        /*
         * Register the disconnect event handler
         */
        Status = _TdiSetEventHandler(
                    pTd,
                    pAddressEndpoint->pDeviceObject,
                    pAddressEndpoint->pFileObject,
                    TDI_EVENT_DISCONNECT,
                    (PVOID)_TdDisconnectHandler,
                    (PVOID)pAddressEndpoint   // Context
                    );

        ASSERT( NT_SUCCESS(Status) );
        if( !NT_SUCCESS(Status) )
        {
            // Already released the spin lock
            DBGPRINT(("DeviceConnectionRequest: failed to _TdiSetEventHandler on TDI_EVENT_DISCONNECT 0x%x\n",Status));        
            goto badconnect1;
        }
    }
    else {
        ExReleaseSpinLock( &pAddressEndpoint->Spinlock, OldIrql );
    }


    // now create a TDI connection object
    Status = _TdCreateConnectionObject(
                 pTd,
                 &pAddressEndpoint->TransportName,
                 &pConnectionEndpoint,
                 pAddressEndpoint->pTransportAddress,
                 pAddressEndpoint->TransportAddressLength
                 );

    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: failed to create ConnectionObject 0x%x\n",Status));        
        goto badconnect1;
    }

    if( 0 != timeout ) {
        WaitTimeout = RtlEnlargedIntegerMultiply( timeout * 1000, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    pTdTdi->pConnectionEndpoint = pConnectionEndpoint;

    Status = _TdiConnect( pTd,
                          NULL, // will allocate the IRP internally
                          pWaitTimeout,
                          pConnectionEndpoint->pFileObject, 
                          pConnectionEndpoint->pDeviceObject,
                          RemoteTransportAddressLength,
                          pRemoteTransportAddress
                          );

    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: failed to connect 0x%x\n",Status));        
        goto badconnect;
    }

    //
    // signal accept event, connect logic don't depend on it.
    //
    KeSetEvent( &pAddressEndpoint->AcceptEvent, IO_NETWORK_INCREMENT, FALSE );

    MemoryFree( pRemoteTransportAddress );
    pRemoteTransportAddress = NULL;

#if DBG
    //
    // Query local address use to connect.
    //
    LocalAddressInfoLength = pAddressEndpoint->TransportAddressLength+4;
    Status = MemoryAllocate( LocalAddressInfoLength, &pTdiLocalAddressInfo );
    if ( NT_SUCCESS( Status ) ) {
        Status = _TdiQueryAddressInfo(
                                pTd,
                                NULL,
                                pConnectionEndpoint->pFileObject,
                                pConnectionEndpoint->pDeviceObject,
                                pTdiLocalAddressInfo,
                                LocalAddressInfoLength
                            );

        if( NT_SUCCESS(Status) )
        {
            int i;
            TA_ADDRESS* pTdAddress;
            TDI_ADDRESS_IP* pTdiAddressIp;

            pTdAddress = &pTdiLocalAddressInfo->Address.Address[0];

            DBGPRINT( ("number of local address %d\n", pTdiLocalAddressInfo->Address.TAAddressCount) );

            for( i=0; i < pTdiLocalAddressInfo->Address.TAAddressCount; i++ )
            {
                DBGPRINT( (" Address Type %d\n", pTdAddress->AddressType) );
                if( TDI_ADDRESS_TYPE_IP == pTdAddress->AddressType )
                {
                    pTdiAddressIp = (TDI_ADDRESS_IP *)&pTdAddress->Address[0];
                    DBGPRINT(("  Port %x\n", pTdiAddressIp->sin_port) );        
                    DBGPRINT(("  IP %u.%u.%u.%u\n", 
                                 (pTdiAddressIp->in_addr & 0xff000000) >> 24,
                                 (pTdiAddressIp->in_addr & 0x00ff0000) >> 16,
                                 (pTdiAddressIp->in_addr & 0x0000ff00) >> 8,
                                 (pTdiAddressIp->in_addr & 0x000000ff) ));
                }

                pTdAddress++;
            }
        }

        MemoryFree( pTdiLocalAddressInfo );
    }
#endif

    //**********************************************************************************
    /*
     * Allocate a context structure and register our endpoint as
     * a handle with ICADD. The handle returned by ICADD will then
     * be placed into the user mode callers buffer as the endpoint
     * handle.
     */
    Status = MemoryAllocate( sizeof(TD_STACK_ENDPOINT), &pStackEndpoint );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: Could not allocate memory 0x%x\n",Status));
        goto badconnect;
    }

    pStackEndpoint->AddressType = TdiDeviceAddressType;
    pStackEndpoint->pEndpoint = pConnectionEndpoint;

    Status = IcaCreateHandle( (PVOID)pStackEndpoint, sizeof(TD_STACK_ENDPOINT), &Handle );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("DeviceConnectionRequest: Error creating ICADD handle 0x%x\n",Status));
        MemoryFree( pStackEndpoint );
        goto badconnect;
    }

    Status = STATUS_SUCCESS;

    /*
     * Fill in the stack endpoint structure to be returned
     */
    try {
        ProbeForWrite( pIcaEndpoint, sizeof(PVOID), 1 );
        *((PVOID *)pIcaEndpoint) = Handle;
        *BytesReturned = sizeof(PVOID);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DBGPRINT(("DeviceConnectionRequest: Exception returning result 0x%x\n",Status));
    }

    // Exception
    if( !NT_SUCCESS(Status) ) {
        goto badsetup;
    }

    pConnectionEndpoint->hIcaHandle = Handle;

    /*
     * Save the file/device objects used for I/O in the TD structure
     */
    pTd->pFileObject = pTdTdi->pConnectionEndpoint->pFileObject;
    pTd->pDeviceObject = pTdTdi->pConnectionEndpoint->pDeviceObject;

    TRACE0(("DeviceConnectionRequest: New Connection Endpoint 0x%x Returned on Context 0x%x, AddressEndpoint 0x%x\n",pConnectionEndpoint,pTd->pAfd,pAddressEndpoint));
    TRACE0(("FO 0x%x, DO 0x%x, Handle 0x%x\n",pConnectionEndpoint->pFileObject,pConnectionEndpoint->pDeviceObject,pConnectionEndpoint->TransportHandle));

    //**********************************************************************************

    // should be a success
    return Status;
    
/*=============================================================================
==   Error returns
=============================================================================*/
badsetup:
    {
        ULONG Length;
        NTSTATUS Status2;

        DBGPRINT(("DeviceConnectionRequest: Exception returning result 0x%x\n",Status));

        Status2 = IcaCloseHandle( Handle, &pStackEndpoint, &Length );
        if( NT_SUCCESS(Status2) ) {
            MemoryFree( pStackEndpoint );
        }
    }

badconnect:
    _TdCloseEndpoint(pTd, pConnectionEndpoint);
    pTdTdi->pConnectionEndpoint = NULL;

badconnect1:
    //
    // It is imperative that we do not close address end point, 
    // We will close address end point on next IOCTL call which triggle 
    // Closing of address end point, if we do it here, we will end up
    // double free and bug check.
    // _TdCloseEndpoint(pTd, pAddressEndpoint);

badcreate:
    if ( TransportName.Buffer )
        MemoryFree( TransportName.Buffer );
    if ( pTransportAddress )
        MemoryFree( pTransportAddress );

    if ( RemoteTransportName.Buffer )
        MemoryFree( RemoteTransportName.Buffer );
    if ( pRemoteTransportAddress )
        MemoryFree( pRemoteTransportAddress );
badaddress:
done:
    return Status;
}


/*******************************************************************************
 * DeviceIoctl
 *
 *  Query/Set configuration information for the td.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdIoctl (input/output)
 *       Points to the parameter structure SD_IOCTL
 ******************************************************************************/
NTSTATUS DeviceIoctl(PTD pTd, PSD_IOCTL pSdIoctl)
{
    DBGENTER(("DeviceIoctl: PTD 0x%x\n",pTd));
    return STATUS_NOT_SUPPORTED;
}


/*******************************************************************************
 * DeviceInitializeRead
 *
 * Setup the IRP for a TDI read.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 ******************************************************************************/
NTSTATUS DeviceInitializeRead(PTD pTd, PINBUF pInBuf)
{
    PIRP Irp;
    PTDTDI pTdTdi;
    PIO_STACK_LOCATION _IRPSP;

    pTdTdi = (PTDTDI) pTd->pAfd;

    ASSERT( pTdTdi != NULL );
    ASSERT( pTdTdi->pConnectionEndpoint != NULL );

    ASSERT( pTd );
    ASSERT( pTd->pDeviceObject );
    ASSERT( !(pTd->pDeviceObject->Flags & DO_BUFFERED_IO) );

    Irp = pInBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation( Irp );

    ASSERT( Irp->MdlAddress == NULL );

    /*
     * TDI interfaces always use an MDL regardless of the driver I/O type.
     */
    MmInitializeMdl( pInBuf->pMdl, pInBuf->pBuffer, pTd->InBufHeader + pTd->OutBufLength );
    MmBuildMdlForNonPagedPool( pInBuf->pMdl );
    Irp->MdlAddress = pInBuf->pMdl;

    if( pTdTdi->pConnectionEndpoint->EndpointType == TdiConnectionStream ) {
        PTDI_REQUEST_KERNEL_RECEIVE p;
        KIRQL OldIrql;
        NTSTATUS Status;
        PTD_ENDPOINT pEndpoint = pTdTdi->pConnectionEndpoint;

        ASSERT( TdiDeviceEndpointType == TdiConnectionStream );

        /* 
         * Most TDI users use the macro TdiBuildReceive(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */

        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_RECEIVE;

        ASSERT( _IRPSP->DeviceObject == pTd->pDeviceObject );
        ASSERT( _IRPSP->FileObject == pTd->pFileObject );
        ASSERT( Irp->MdlAddress );

        // Cast the generic parameters field to the TDI structure needed
        p = (PTDI_REQUEST_KERNEL_RECEIVE)&_IRPSP->Parameters;
        p->ReceiveFlags = 0;
        p->ReceiveLength = pTd->InBufHeader + pTd->OutBufLength;

        return( STATUS_SUCCESS );
    }
    else if( pTdTdi->pConnectionEndpoint->EndpointType == TdiConnectionDatagram ) {
        PTDI_REQUEST_KERNEL_RECEIVEDG p;

        ASSERT( TdiDeviceEndpointType == TdiConnectionDatagram );

        /* 
         * Most TDI users use the macro TdiBuildReceiveDatagram(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */
    
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_RECEIVE_DATAGRAM;

        ASSERT( _IRPSP->DeviceObject );
        ASSERT( _IRPSP->FileObject );
        ASSERT( Irp->MdlAddress );

        // Cast the generic parameters field to the TDI structure needed
        p = (PTDI_REQUEST_KERNEL_RECEIVEDG)&_IRPSP->Parameters;
        p->ReceiveFlags = 0;
        p->ReceiveLength = pTd->InBufHeader + pTd->OutBufLength;

        p->ReceiveDatagramInformation = NULL;
        p->ReturnDatagramInformation = NULL;

        return( STATUS_SUCCESS );
    }
    else {
        DBGPRINT(("DeviceInitializeRead: Bad EndpointType 0x%x\n",pTdTdi->pConnectionEndpoint->EndpointType));
        return( STATUS_INVALID_HANDLE );
    }
    // NOTREACHED
}


/*******************************************************************************
 * DeviceSubmitRead
 *
 * Submit the read IRP to the driver.
 ******************************************************************************/
NTSTATUS DeviceSubmitRead(PTD pTd, PINBUF pInBuf)
{
    NTSTATUS Status;
    PIRP Irp;
    PTDTDI pTdTdi;
    KIRQL OldIrql;
    PLIST_ENTRY  pEntry;
    PTD_ENDPOINT pEndpoint;
    PIO_STACK_LOCATION _IRPSP;
    PTDI_REQUEST_KERNEL_RECEIVE p;

    Irp = pInBuf->pIrp;

    /*
     * Datagram endpoints do not use a receive indication handler.
     */
    if( TdiDeviceEndpointType == TdiConnectionDatagram ) {
        Status = IoCallDriver( pTd->pDeviceObject, Irp );
        return( Status );
    }

    pTdTdi = (PTDTDI) pTd->pAfd;
    ASSERT( pTdTdi != NULL );
    ASSERT( pTdTdi->pConnectionEndpoint != NULL );

    pEndpoint = pTdTdi->pConnectionEndpoint;

    ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );

    // The other end may have disconnected
    if( pEndpoint->Disconnected ) {
        TRACE0(("DeviceSubmitRead: Connection disconnecting! pEndpoint 0x%x\n",pEndpoint));
        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        Irp->IoStatus.Status = STATUS_REMOTE_DISCONNECT;
        Irp->IoStatus.Information = 0;

        // Since the IRP has not been submitted with IoCallDriver() yet,
        // we must simulate.
        IoSetNextIrpStackLocation( Irp );

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return STATUS_REMOTE_DISCONNECT;
    }

    /*
     * We queue the receive IRP onto the connection
     * endpoint so that the indication handler can
     * submit it. Because we could have received an
     * indication while processing the previous receive,
     * the indication will set the indicated byte count
     * in RecvBytesReady that the call side can submit the IRP.
     *
     * The ReceiveQueue is designed to allow our caller to submit
     * multiple read IRP's in case we need to handle a TDI
     * provider that drops data when no receives are ready.
     */
    InsertTailList( &pEndpoint->ReceiveQueue, &Irp->Tail.Overlay.ListEntry );

    /*
     * Connection oriented endpoints disconnect the connection when
     * a submitted I/O is canceled. This breaks the Citrix disconnect
     * reconnect sequence that occurs on a new connection since the
     * reader thread must be killed on one winstation, and the
     * connection passed to another reader thread for a different
     * winstation.
     *
     * This problem is solved by using a receive indication handler
     * and only submitting IRP's when we know we will not block.
     * This allows us to "cancel" I/O within our driver, and not
     * have to do a IoCancelIrp() onto the TDI provider.
     */
    if( pEndpoint->RecvBytesReady ) {

        //
        // Indication came in without IRP ready, or more bytes indicated than
        // ICA outbuf IRP can handle.
        //
        // We subtract the number of bytes we can receive from the indication
        // bytes. We do not need to handle the IRP cancel case, since the TDI
        // will nuke the connection anyway.
        //

        ASSERT( !IsListEmpty( &pEndpoint->ReceiveQueue ) );

        pEntry = RemoveHeadList( &pEndpoint->ReceiveQueue );
        Irp = CONTAINING_RECORD( pEntry, IRP, Tail.Overlay.ListEntry );

        _IRPSP = IoGetNextIrpStackLocation( Irp );
        p = (PTDI_REQUEST_KERNEL_RECEIVE)&_IRPSP->Parameters;

        if( p->ReceiveLength > pEndpoint->RecvBytesReady ) {
            pEndpoint->RecvBytesReady = 0;
        }
        else {
            pEndpoint->RecvBytesReady -= p->ReceiveLength;
        }
        TRACE1(("DeviceSubmitRead: RecvBytesReady, Calling Driver with IRP 0x%x\n",Irp));
        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
        Status = IoCallDriver( pTd->pDeviceObject, Irp );
        return( Status );
    }
    else {

        // In this case we let the indication handler submit it.
        TRACE1(("DeviceSubmitRead: Letting indication handler submit. Irp 0x%x\n",Irp));

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
        return( STATUS_SUCCESS );
    }
}


/*******************************************************************************
 * DeviceWaitForRead
 ******************************************************************************/
NTSTATUS DeviceWaitForRead(PTD pTd)
{
    /*
     * Just wait on the input event and return the wait status
     */
    return IcaWaitForSingleObject(pTd->pContext, &pTd->InputEvent, -1);
}


/*******************************************************************************
 * DeviceReadComplete
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location to return byte count read
 ******************************************************************************/
NTSTATUS DeviceReadComplete(PTD pTd, PUCHAR pBuffer, PULONG pByteCount)
{
    /*
     * Do any protocol specific read complete processing
     */
    return TdiDeviceReadComplete(pTd, pBuffer, pByteCount);
}


/*******************************************************************************
 * DeviceInitializeWrite
 ******************************************************************************/
NTSTATUS DeviceInitializeWrite(PTD pTd, POUTBUF pOutBuf)
{
    PIRP Irp;
    PTDTDI pTdTdi;
    ULONG WriteLength;
    PIO_STACK_LOCATION _IRPSP;

    pTdTdi = (PTDTDI) pTd->pAfd;

    ASSERT( pTdTdi != NULL );
    ASSERT( pTdTdi->pConnectionEndpoint != NULL );

    ASSERT( pTd );
    ASSERT( pTd->pDeviceObject );

    Irp = pOutBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation(Irp);

    ASSERT(Irp->MdlAddress == NULL);

    /*
     * TDI interfaces always use an MDL regardless of the driver I/O type.
     */
    MmInitializeMdl(pOutBuf->pMdl, pOutBuf->pBuffer, pOutBuf->ByteCount);
    MmBuildMdlForNonPagedPool(pOutBuf->pMdl);
    Irp->MdlAddress = pOutBuf->pMdl;

    if (pTdTdi->pConnectionEndpoint->EndpointType == TdiConnectionStream) {
        PTDI_REQUEST_KERNEL_SEND p;

        /* 
         * Most TDI users use the macro TdiBuildSend(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */
        ASSERT( TdiDeviceEndpointType == TdiConnectionStream );

        /*
         * Now write in the reformatted parameters for a TDI SEND
         */
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_SEND;

        ASSERT( _IRPSP->DeviceObject == pTd->pDeviceObject );
        ASSERT( _IRPSP->FileObject == pTd->pFileObject );
        ASSERT( Irp->MdlAddress );

        p = (PTDI_REQUEST_KERNEL_SEND)&_IRPSP->Parameters;
        p->SendFlags = 0;
        p->SendLength = pOutBuf->ByteCount;

        return STATUS_SUCCESS;
    }
    else if (pTdTdi->pConnectionEndpoint->EndpointType ==
            TdiConnectionDatagram) {
        PTDI_REQUEST_KERNEL_SENDDG p;

        /* 
         * Most TDI users use the macro TdiBuildSendDatagram(), but since
         * our caller has already fiddled with the IrpStackLocation,
         * we must do it inline.
         */
        ASSERT( TdiDeviceEndpointType == TdiConnectionDatagram );

        /*
         * Now write in the reformatted parameters for a TDI SEND
         */
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        _IRPSP->MinorFunction = TDI_SEND_DATAGRAM;

        ASSERT( _IRPSP->DeviceObject );
        ASSERT( _IRPSP->FileObject );
        ASSERT( Irp->MdlAddress );

        p = (PTDI_REQUEST_KERNEL_SENDDG)&_IRPSP->Parameters;
        p->SendLength = pOutBuf->ByteCount;

        // Include the remote address with every datagram send
        p->SendDatagramInformation = &pTdTdi->pConnectionEndpoint->SendInfo;

        return STATUS_SUCCESS;
    }
    else {
        DBGPRINT(("DeviceInitializeWrite: Bad EndpointType 0x%x\n",
                pTdTdi->pConnectionEndpoint->EndpointType));
        ASSERT(FALSE);  // Catch this
        return STATUS_INVALID_HANDLE;
    }
}


/*******************************************************************************
 * DeviceWaitForStatus
 *
 *  Wait for device status to change (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceWaitForStatus(PTD pTd)
{
    DBGENTER(("DeviceWaitForStatus: PTD 0x%x\n",pTd));
    return STATUS_INVALID_DEVICE_REQUEST;
}


/*******************************************************************************
 * DeviceCancelIo
 *
 *  cancel all current and future i/o
 ******************************************************************************/
NTSTATUS DeviceCancelIo(PTD pTd)
{
    KIRQL  OldIrql;
    PTDTDI pTdTdi;
    PIRP   Irp;
    PLIST_ENTRY pEntry;
    PTD_ENDPOINT pEndpoint;
    POUTBUF pOutBuf;

    DBGENTER(("DeviceCancelIo: PTD 0x%x\n", pTd));
    pTdTdi = (PTDTDI)pTd->pAfd;
    ASSERT(pTdTdi != NULL);

    
    if ((pEndpoint = pTdTdi->pConnectionEndpoint) != NULL ) {
        DBGPRINT(("DeviceCancelIo [%p]: Endpoint 0x%p\n", pTd, pEndpoint));

        
//      DbgPrint("DeviceCancelIo [0x%p]: Endpoint 0x%p, connected = %ld, disconnected = %ld\n", 
//               pTd, pEndpoint, pEndpoint->Connected, pEndpoint->Disconnected);
        
        /* 
         * Disconnect the endpoint first to make all the I/O activity stop!
         */
        if (pEndpoint->Connected) {
            NTSTATUS Status;

            Status = _TdiDisconnect(pTd, 
                                    pEndpoint->pFileObject, 
                                    pEndpoint->pDeviceObject);
            pEndpoint->Connected = FALSE;

        }
        
        /*
         * Cancel any pended receives
         */
        _TdCancelReceiveQueue(pTd, pEndpoint, STATUS_LOCAL_DISCONNECT);

        /*
         * We now check to see if we have send IRP's on the
         * outgoing queue that have been submitted to the TDI.
         * When we register a disconnect indication handler, the TDI
         * provider will not cancel IRP's when the connection drops.
         * They will hang waiting to send on a connection that no longer
         * is taking data.
         *
         * NOTE: We should be protected by the stack driver lock
         *       while we walk this chain.
         */

        pEntry = pTd->IoBusyOutBuf.Flink;
        while (pEntry != &pTd->IoBusyOutBuf) {
            pOutBuf = CONTAINING_RECORD(pEntry, OUTBUF, Links);
            ASSERT(pOutBuf->pIrp != NULL);

            // We must not cancel IRPs that have already completed.
            if (!pOutBuf->fIrpCompleted) {
                TRACE0(("DeviceCancelIo: Canceling Write IRP 0x%p Endpoint 0x%p\n",
                        pOutBuf->pIrp, pEndpoint));
                
                IoCancelIrp(pOutBuf->pIrp);
            }

            pEntry = pEntry->Flink;
        }
    }
    else
        DBGPRINT(("DeviceCancelIo [0x%p]: Endpoint is NULL\n", pTd));

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceSetParams
 *
 * Set device pararameters (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceSetParams(PTD pTd)
{
    DBGENTER(("DeviceSetParams: PTD 0x%x\n", pTd));
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceGetLastError
 *
 *  This routine returns the last transport error code and message
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLastError (output)
 *       address to return information on last transport error
 ******************************************************************************/
NTSTATUS DeviceGetLastError(PTD pTd, PICA_STACK_LAST_ERROR pLastError)
{
    DBGENTER(("DeviceGetLastError: PTD 0x%x\n",pTd));
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdCreateEndpointStruct
 *
 *  Create and initialize a new Endpoint structure. Does not create any
 *  TDI objects.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pTransportName (input)
 *       Pointer to UNICODE_STRING containing transport device name
 *    ppEndpoint (output)
 *       Pointer to location to return TD_ENDPOINT pointer
 ******************************************************************************/
NTSTATUS _TdCreateEndpointStruct(
        IN  PTD pTd,
        IN  PUNICODE_STRING pTransportName,
        OUT PTD_ENDPOINT *ppEndpoint,
        IN  PTRANSPORT_ADDRESS pTransportAddress,
        IN  ULONG TransportAddressLength)
{
    NTSTATUS Status;
    ULONG    Length;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status2;
    PVOID pContext;
    ULONG ContextLength;


    /*
     * Allocate an endpoint object and room for the transport name
     */
    Length = sizeof(*pEndpoint) + pTransportName->MaximumLength;
    Status = MemoryAllocate(Length, &pEndpoint);
    if (NT_SUCCESS(Status)) {
        RtlZeroMemory(pEndpoint, Length);
        Status = IcaCreateHandle( (PVOID)pEndpoint, sizeof(TD_ENDPOINT), &pEndpoint->hConnectionEndPointIcaHandle );
        if (!NT_SUCCESS(Status)) {
            MemoryFree(pEndpoint);
            return Status;
        }
    } else {
        return Status;
    }

    KeInitializeSpinLock( &pEndpoint->Spinlock );
    KeInitializeEvent( &pEndpoint->AcceptEvent, NotificationEvent, FALSE );
    InitializeListHead( &pEndpoint->ConnectionQueue );
    InitializeListHead( &pEndpoint->ConnectedQueue );
    InitializeListHead( &pEndpoint->AcceptQueue );
    InitializeListHead( &pEndpoint->ReceiveQueue );

    /*
     * Build the transport name UNICODE_STRING and copy it
     */
    pEndpoint->TransportName.Length = pTransportName->Length;
    pEndpoint->TransportName.MaximumLength = pTransportName->MaximumLength;
    pEndpoint->TransportName.Buffer = (PWCHAR)(pEndpoint + 1);
    RtlCopyMemory( pEndpoint->TransportName.Buffer, pTransportName->Buffer,
                   pTransportName->MaximumLength );

    /*
     * If a transport address is supplied, copy it in.
     */
    if (pTransportAddress && TransportAddressLength) {
        /*
         * Allocate and copy the transport address
         */
        Status = MemoryAllocate(TransportAddressLength,
                &pEndpoint->pTransportAddress);
        if (NT_SUCCESS(Status)) {
            Status = IcaCreateHandle( (PVOID)pEndpoint->pTransportAddress, sizeof(TRANSPORT_ADDRESS), &pEndpoint->hTransportAddressIcaHandle );

            if (!NT_SUCCESS(Status)) {
                Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
                MemoryFree(pEndpoint->pTransportAddress);
                MemoryFree(pEndpoint);
                return Status;
            }

            RtlCopyMemory(pEndpoint->pTransportAddress, pTransportAddress,
                    TransportAddressLength);
            pEndpoint->TransportAddressLength = TransportAddressLength;
        }
        else {
            Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
            MemoryFree(pEndpoint);
            return Status;
        }
    }

    *ppEndpoint = pEndpoint;
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdCloseEndpoint
 *
 *  Close a TDI endpoint object
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer TD_ENDPOINT object
 ******************************************************************************/
NTSTATUS _TdCloseEndpoint(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    KIRQL OldIrql;
    NTSTATUS Status;
    PTDTDI pAfd;
    PVOID pContext;
    ULONG  ContextLength ;
    NTSTATUS Status2;


    TRACE0(("_TdCloseEndpoint: pEndpoint 0x%x Context 0x%x Type 0x%x FO 0x%x, "
            "DO 0x%x, Handle 0x%x\n", pEndpoint,pTd->pAfd,
            pEndpoint->EndpointType, pEndpoint->pFileObject,
            pEndpoint->pDeviceObject, pEndpoint->TransportHandle));

    /*
     * If this is an address endpoint, we could have
     * a thread waiting for a connection.
     *
     * NOTE: Closing an address endpoint causes TDI to nuke all of the
     *       open connections that were created from it. Our upper
     *       level caller code understands this.
     */
    if (pEndpoint->EndpointType == TdiAddressObject) {
        PTD_ENDPOINT p;
        PLIST_ENTRY pEntry;

        ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);

        while (pEndpoint->Waiter) {
            TRACE0(("_TdCloseEndpoint: Closing AddressEndpoint, Cleaning up listen thread...\n"));
            KeSetEvent( &pEndpoint->AcceptEvent, IO_NETWORK_INCREMENT, FALSE );
            ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );
            IcaSleep( pTd->pContext, 100 );
            ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );
        }

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        /*
         * Cancel the accept indication handler if necessary
         * (FileObject may not be present if DeviceCreateEndpoint fails).
         */
        if (( TdiDeviceEndpointType != TdiConnectionDatagram ) &&
            (pEndpoint->pFileObject)) {
            Status = _TdiSetEventHandler(
                         pTd,
                         pEndpoint->pDeviceObject,
                         pEndpoint->pFileObject,
                         TDI_EVENT_CONNECT,
                         (PVOID)NULL,  // Handler
                         (PVOID)NULL   // Context
                         );

            ASSERT( NT_SUCCESS(Status) );
        }

        /*
         * Free the connection object queues.
         *
         * NOTE: We no longer need the spinlock since we have
         *       cancelled the connect indication handler from TDI,
         *       and the upper level protects calls to teardown an
         *       address endpoint.
         */

        /*
         * Cleanup connected, but not returned objects
         */
        while( !IsListEmpty( &pEndpoint->ConnectedQueue ) ) {
            pEntry = pEndpoint->ConnectedQueue.Flink;
            RemoveEntryList( pEntry );
            p = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );
            ASSERT( p->EndpointType != TdiAddressObject );
            _TdCloseEndpoint( pTd, p );
        }

        /*
         * Cleanup queue of wait for Accept complete connections
         */
        while( !IsListEmpty( &pEndpoint->AcceptQueue ) ) {
            pEntry = pEndpoint->AcceptQueue.Flink;
            RemoveEntryList( pEntry );
            p = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );
            ASSERT( p->EndpointType != TdiAddressObject );
            _TdCloseEndpoint( pTd, p );
        }

        /*
         * Cleanup queue of empty connections
         */
        while( !IsListEmpty( &pEndpoint->ConnectionQueue ) ) {
            pEntry = pEndpoint->ConnectionQueue.Flink;
            RemoveEntryList( pEntry );
            p = CONTAINING_RECORD( pEntry, TD_ENDPOINT, ConnectionLink );
            ASSERT( p->EndpointType != TdiAddressObject );
            _TdCloseEndpoint( pTd, p );
        }
    }

    /*
     * If this endpoint has ever been connected,
     * then tell the transport driver we are closing down.
     */
    if (pEndpoint->Connected) {
        (VOID) _TdiDisconnect(pTd,
                pEndpoint->pFileObject,
                pEndpoint->pDeviceObject);
    }
    pEndpoint->pDeviceObject = NULL;

    /*
     * If a file object, dereference it
     */
    if (pEndpoint->pFileObject) {
        ObDereferenceObject( pEndpoint->pFileObject );
        pEndpoint->pFileObject = NULL;
    }

    /*
     * If a file handle, close it
     */
    if (pEndpoint->TransportHandle) {
        ASSERT( pEndpoint->TransportHandleProcess == IoGetCurrentProcess() );
        ZwClose( pEndpoint->TransportHandle );
        pEndpoint->TransportHandleProcess = NULL;
        pEndpoint->TransportHandle = NULL;
    }

    /*
     * If an IRP, free it
     *
     * NOTE: This must be *AFTER* the close since the
     *       IRP is in the bowels of the TCP driver!
     */
    if( pEndpoint->AcceptIrp ) {
        IoFreeIrp( pEndpoint->AcceptIrp );
        pEndpoint->AcceptIrp = NULL;
    }

    /*
     * If a transport address, free it, and Also close it handle if there is one.
     */
    if (pEndpoint->hTransportAddressIcaHandle != NULL) {
        Status2 = IcaCloseHandle( pEndpoint->hTransportAddressIcaHandle , &pContext, &ContextLength );
    }
    if ( pEndpoint->pTransportAddress ) {
        MemoryFree( pEndpoint->pTransportAddress );
        pEndpoint->pTransportAddress = NULL;
    }

    /*
     * If a remote address, free it
     */
    if ( pEndpoint->pRemoteAddress ) {
        MemoryFree( pEndpoint->pRemoteAddress );
        pEndpoint->pRemoteAddress = NULL;
    }

    if (pEndpoint->hConnectionEndPointIcaHandle != NULL) {
        Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
    }
    DBGPRINT(("_TdCloseEndpoint [%p]: 0x%p\n", pTd, pEndpoint));
    MemoryFree(pEndpoint);
    return STATUS_SUCCESS;
}


/****************************************************************************/
// _TdConnectHandler
//
// This is the transport connect event handler for the server.  It is
// specified as the connect handler for all endpoints opened by the
// server.  It attempts to dequeue a free connection from a list
// anchored in the address endpoint.  If successful, it returns the
// connection to the transport.  Otherwise, the connection is rejected.
/****************************************************************************/
NTSTATUS _TdConnectHandler(
        IN PVOID TdiEventContext,
        IN int RemoteAddressLength,
        IN PVOID RemoteAddress,
        IN int UserDataLength,
        IN PVOID UserData,
        IN int OptionsLength,
        IN PVOID Options,
        OUT CONNECTION_CONTEXT *ConnectionContext,
        OUT PIRP *AcceptIrp)
{
    KIRQL OldIrql;
    NTSTATUS Status;
    PLIST_ENTRY pEntry;
    PTD_ENDPOINT pConnection;
    PTD_ENDPOINT pAddressEndpoint;
    PACCEPT_CONTEXT Context;

    UserDataLength, UserData;               // avoid compiler warnings
    OptionsLength, Options;

    pAddressEndpoint = (PTD_ENDPOINT)TdiEventContext;

    TRACE0(("_TdConnectHandler: Connect event! Context 0x%x\n",pAddressEndpoint));

    /*
     * First try and get memory. If error, the TDI transport provider
     * will drop the connect request.
     */
    Status = MemoryAllocate(sizeof(ACCEPT_CONTEXT), &Context);
    if (NT_SUCCESS(Status)) {
        memset(Context, 0, sizeof(ACCEPT_CONTEXT));
    }
    else {
        DBGPRINT(("_TdConnectHandler: No memory for context\n"));
        return Status;
    }

    /*
     * Get the spinlock to synchronize with the call side
     */
    ExAcquireSpinLock(&pAddressEndpoint->Spinlock, &OldIrql);

    /*
     * Get the connection object on the front of the list
     */
    if (!IsListEmpty(&pAddressEndpoint->ConnectionQueue))  {
        pEntry = RemoveHeadList(&pAddressEndpoint->ConnectionQueue);
        pConnection = CONTAINING_RECORD(pEntry, TD_ENDPOINT, ConnectionLink);

        // Put it on the end of the accept list
        InsertTailList(&pAddressEndpoint->AcceptQueue,
                &pConnection->ConnectionLink);
    }
    else {
        DBGPRINT(("_TdConnectHandler: Empty ConnectionQueue! 0x%x\n",
                pAddressEndpoint));
        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);
        MemoryFree(Context);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Context->pAddressEndpoint = pAddressEndpoint;
    Context->pConnectionEndpoint = pConnection;
    ASSERT(pConnection->AcceptIrp != NULL);

    //
    //  remember the remote address in the connection endpoint
    //
    if ( NULL != RemoteAddress )
    {
        ASSERT( NULL == pConnection->pRemoteAddress );
        ASSERT( 0 != RemoteAddressLength );
        if ( NT_SUCCESS( MemoryAllocate( RemoteAddressLength, &pConnection->pRemoteAddress )))
        {
            RtlCopyMemory( pConnection->pRemoteAddress, RemoteAddress, RemoteAddressLength );
            pConnection->RemoteAddressLength = RemoteAddressLength;
        }
    }

    TdiBuildAccept(
            pConnection->AcceptIrp,
            pConnection->pDeviceObject,
            pConnection->pFileObject,
            _TdAcceptComplete,        // Completion routine
            Context,                  // Context
            &Context->RequestInfo,
            &Context->ReturnInfo);

    /*
     * Make the next stack location current.  Normally IoCallDriver would
     * do this, but since we're bypassing that, we do it directly.
     */
    IoSetNextIrpStackLocation(pConnection->AcceptIrp);

    /*
     * Return the connection context (the connection address) to the
     * transport.  Return a pointer to the Accept IRP.  Indicate that
     * the Connect event has been handled. This must be the same
     * context specified when the connection object was created.
     */
    *ConnectionContext = pConnection;
    *AcceptIrp = pConnection->AcceptIrp;
    ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS _TdAcceptComplete(
        IN PDEVICE_OBJECT DeviceObject,
        IN PIRP Irp,
        IN PVOID Ctx)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PACCEPT_CONTEXT Context;
    PTD_ENDPOINT pConnection;
    PTD_ENDPOINT pAddressEndpoint;

    Context = (PACCEPT_CONTEXT)Ctx;

    pConnection = Context->pConnectionEndpoint;
    pAddressEndpoint = Context->pAddressEndpoint;

    ASSERT( pConnection != NULL );
    ASSERT( pAddressEndpoint != NULL );
    ASSERT( pConnection->EndpointType == TdiConnectionStream );
    ASSERT( pAddressEndpoint->EndpointType == TdiAddressObject );    

    TRACE0(("_TdAcceptComplete: Status 0x%x, Endpoint 0x%x\n",Irp->IoStatus.Status,pConnection));

    /*
     * Get the spinlock to synchronize with the call side
     */
    ExAcquireSpinLock( &pAddressEndpoint->Spinlock, &OldIrql );

    if (IsListEmpty( &pAddressEndpoint->AcceptQueue))  {
        DBGPRINT(("_TdAcceptComplete: Empty Accept Queue! 0x%x\n",
                pAddressEndpoint));
        ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

        /*
         * Release the context memory
         */

        MemoryFree(Context);

        // Let it drop
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        pEntry = RemoveHeadList(&pAddressEndpoint->AcceptQueue);
        pConnection = CONTAINING_RECORD(pEntry, TD_ENDPOINT, ConnectionLink);
        /*
         * Put it on the end of the connect list
         */
        InsertTailList(&pAddressEndpoint->ConnectedQueue,
                &pConnection->ConnectionLink);
    }

    /*
     * If the accept failed, the caller will check this status
     * and tear down the connection, causing a RST to be sent
     * to the other side.
     */
    pConnection->Status = Irp->IoStatus.Status;

    /*
     * Signal that it is connected (Could be in error)
     */
    pConnection->Connected = TRUE;

    /*
     * Set the event on the address object
     */
    KeSetEvent(&Context->pAddressEndpoint->AcceptEvent, IO_NETWORK_INCREMENT, FALSE);

    ExReleaseSpinLock(&pAddressEndpoint->Spinlock, OldIrql);

    /*
     * Release the context memory
     */
    MemoryFree(Context);

    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*****************************************************************************
 *  _TdReceiveHandler
 *
 *   This function is called by the TDI when receive data is available
 *   on the connection. This is done so we do not submit the IRP until
 *   data is available. The disconnect-reconnect logic in ICA causes an
 *   IoCancelIrp() to be sent on the input thread, and TDI providers drop the
 *   connection on a read or write I/O cancel.
 *
 *   WARNING: This critical behavior is only needed for a reconnect
 *            sequence. For normal ICA I/O, it is OK to block the reader
 *            thread in the TDI driver.
 *
 *   TdiEventContext (input)
 *       Context registered with event handler on address object.
 *       (address endpoint)
 *
 *   ConnectionContext (input)
 *       Connection context registered with the connection
 *       create.
 ****************************************************************************/
NTSTATUS _TdReceiveHandler(
        IN PVOID TdiEventContext,
        IN CONNECTION_CONTEXT ConnectionContext,
        IN ULONG ReceiveFlags,
        IN ULONG BytesIndicated,
        IN ULONG BytesAvailable,
        OUT ULONG *BytesTaken,
        IN PVOID Tsdu,
        OUT PIRP *IoRequestPacket)
{
    KIRQL OldIrql;
    PIRP  Irp;
    PLIST_ENTRY pEntry;
    PIO_STACK_LOCATION _IRPSP;
    PTDI_REQUEST_KERNEL_RECEIVE p;
    PTD_ENDPOINT pEndpoint = (PTD_ENDPOINT)ConnectionContext;

    /*
     * Only stream transports use a receive indication handler.
     */
    ASSERT( TdiDeviceEndpointType != TdiConnectionDatagram );

    ASSERT( pEndpoint != NULL );
    ASSERT( pEndpoint->EndpointType == TdiConnectionStream );

    TRACE1(("_TdReceiveHandler: ReceiveDataIndication! pEndpoint 0x%x\n",pEndpoint));

    ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);

    *BytesTaken = 0;

    /*
     * Submit an IRP at indication time if we have one on
     * the queue.
     */
    if (!IsListEmpty( &pEndpoint->ReceiveQueue)) {
        pEntry = RemoveHeadList(&pEndpoint->ReceiveQueue);
        Irp = CONTAINING_RECORD(pEntry, IRP, Tail.Overlay.ListEntry);

        TRACE1(("_TdReceiveHandler: Passing IRP for Receive Indication %d bytes\n",
                BytesAvailable));

        _IRPSP = IoGetNextIrpStackLocation(Irp);
        p = (PTDI_REQUEST_KERNEL_RECEIVE)&_IRPSP->Parameters;
        if (p->ReceiveLength < BytesAvailable) {
            pEndpoint->RecvBytesReady += (BytesAvailable - p->ReceiveLength);
            TRACE1(("_TdReceiveHandler: Excess Bytes %d Added to RecvBytesReady, now %d\n",
                    (BytesAvailable - p->ReceiveLength),
                    pEndpoint->RecvBytesReady));
        }

        ExReleaseSpinLock(&pEndpoint->Spinlock, OldIrql);
        *IoRequestPacket = Irp;
        IoSetNextIrpStackLocation(Irp);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // No RecvIrp, So we can not take any data. Let the callside get it.
    TRACE1(("_TdReceiveHandler: No RecvIrp, Adding To RecvBytesReady. %d Bytes\n",BytesAvailable));

    pEndpoint->RecvBytesReady += BytesAvailable;
    ExReleaseSpinLock(&pEndpoint->Spinlock, OldIrql);
    return STATUS_DATA_NOT_ACCEPTED;
}


/*****************************************************************************
 *  _TdDisconnectHandler
 *
 *   This function is called by the TDI when a disconnect occurs
 *   on the connection.
 *
 *   TdiEventContext (input)
 *       Context registered with event handler on address object.
 *       (address endpoint)
 *
 *   ConnectionContext (input)
 *       Connection context registered with the connection
 *       create.
 ****************************************************************************/
NTSTATUS _TdDisconnectHandler(
        IN PVOID TdiEventContext,
        IN CONNECTION_CONTEXT ConnectionContext,
        IN int DisconnectDataLength,
        IN PVOID DisconnectData,
        IN int DisconnectInformationLength,
        IN PVOID DisconnectInformation,
        IN ULONG DisconnectFlags)
{
    KIRQL OldIrql;
    PIRP  Irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY pEntry;
    PTD_ENDPOINT pEndpoint = (PTD_ENDPOINT)ConnectionContext;

    /*
     * Only stream transports use a disconnect indication handler.
     */
    ASSERT( TdiDeviceEndpointType != TdiConnectionDatagram );
    ASSERT( pEndpoint != NULL );
    ASSERT( pEndpoint->EndpointType == TdiConnectionStream );

//  DbgPrint("\n");
//  DbgPrint("_TdDisconnectHandler : pEndpoint = 0x%p\n", pEndpoint);

    ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );
    pEndpoint->Disconnected = TRUE;
    ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

    _TdCancelReceiveQueue(NULL, pEndpoint, STATUS_REMOTE_DISCONNECT );
    return STATUS_SUCCESS;
}


/****************************************************************************/
// Create an idle connection object associated with an address object.
// This must be called from call (thread) level, and not from indication
// time (DPC level).
/****************************************************************************/
NTSTATUS _TdCreateConnectionObject(
        IN  PTD pTd,
        IN  PUNICODE_STRING pTransportName,
        OUT PTD_ENDPOINT *ppEndpoint,
        IN  PTRANSPORT_ADDRESS pTransportAddress,
        IN  ULONG TransportAddressLength)
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    PTD_ENDPOINT pEndpoint;

    pTdTdi = (PTDTDI)pTd->pAfd;

    // Create and init structure and spinlock
    Status = _TdCreateEndpointStruct(
                 pTd,
                 pTransportName,
                 ppEndpoint,
                 pTransportAddress,
                 TransportAddressLength
                 );
    if (NT_SUCCESS(Status)) {
        pEndpoint = *ppEndpoint;
    }
    else {
        return Status;
    }

    // The TD sets whether data gram, or stream
    pEndpoint->EndpointType = TdiDeviceEndpointType;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create a TDI connection object
     */
    Status = _TdiOpenConnection(
                 &pEndpoint->TransportName,
                 (PVOID)pEndpoint,  // Context
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdCreateConnectionObject: _TdiOpenConnection failed, Status 0x%x\n",Status));
        _TdCloseEndpoint( pTd, pEndpoint );
        return Status;
    }

    // Allocate an IRP for connect/disconnect handling
    // This is needed since we use the connect indication hander.
    pEndpoint->AcceptIrp = _TdiAllocateIrp(pEndpoint->pFileObject,
            pEndpoint->pDeviceObject);
    if (pEndpoint->AcceptIrp == NULL) {
        DBGPRINT(("_TdCreateConnectionObject: Could not allocate IRP\n"));
        _TdCloseEndpoint(pTd, pEndpoint);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Associate the connection object with its address object
    Status = _TdiAssociateAddress(
                 pTd,
                 pEndpoint->AcceptIrp,
                 pEndpoint->pFileObject,
                 pTdTdi->pAddressEndpoint->TransportHandle,
                 pTdTdi->pAddressEndpoint->pDeviceObject
                 );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdCreateConnectionObject: _TdiAssociateAddress failed, Status 0x%x\n",Status));
        _TdCloseEndpoint(pTd, pEndpoint);
        return Status;
    }

    return Status;
}


/*******************************************************************************
 * _TdWaitForDatagramConnection
 *
 *  For for an incoming datagram connection request and accept it.
 *
 *  Datagram endpoints listen on a TDI address object bound to the local
 *  (netcard) and well known ICA socket number. Packets then received on
 *  the ICA socket number are checked for ICA request connection, and then
 *  a new TDI address object is bound with the wild-card local address
 *  (0). This causes a new, unused socket number to be assigned to this
 *  address object. This new TDI address object is used for further
 *  communication to the now "connected" IPX ICA client.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pAddressEndpoint (input)
 *       Pointer Address endpoint object
 *    ppConnectionEndpoint (output)
 *       Pointer to location to return Connection endpoint pointer
 ******************************************************************************/
NTSTATUS _TdWaitForDatagramConnection(
        IN PTD pTd,
        IN PTD_ENDPOINT pAddressEndpoint,
        OUT PTD_ENDPOINT *ppConnectionEndpoint)
{
    NTSTATUS Status;
    PTRANSPORT_ADDRESS pLocalAddress;
    ULONG LocalAddressLength;
    ULONG AddressInfoLength;
    ULONG RemoteAddressLength = 0;
    PTD_ENDPOINT pEndpoint = NULL;
    PTRANSPORT_ADDRESS pRemoteAddress = NULL;
    PTDI_ADDRESS_INFO pAddressInfo = NULL;

    /*
     * Get a copy of the local transport address.
     *
     * Clear the TDI address part of the structure so that we can
     * use it to bind the connection endpoint to a wild-card address.
     *
     * This wildcard address (0), will cause the packet level TDI
     * provider to assign us a unique socket when the TDI address
     * object is created.
     */
    Status = MemoryAllocate(pAddressEndpoint->TransportAddressLength,
            &pLocalAddress);
    if (NT_SUCCESS(Status)) {
        RtlCopyMemory(pLocalAddress, pAddressEndpoint->pTransportAddress,
                pAddressEndpoint->TransportAddressLength);
        RtlZeroMemory(pLocalAddress->Address[0].Address,
                pLocalAddress->Address[0].AddressLength);
    }
    else {
        goto badmalloc;
    }

    LocalAddressLength = pAddressEndpoint->TransportAddressLength;

    /*
     * Call protocol specific routine to wait for
     * a datagram connection request to arrive.
     *
     * This returns when a valid ICA connect datagram comes in
     * from a remote address. No reply has been sent.
     */
    Status = TdiDeviceWaitForDatagramConnection(pTd,
            pAddressEndpoint->pFileObject,
            pAddressEndpoint->pDeviceObject,
            &pRemoteAddress,
            &RemoteAddressLength);
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in TdiDeviceWaitForDatagramConnction\n",Status));
        goto badwait;
    }

    ASSERT( pRemoteAddress != NULL );

    /*
     * Create a new address endpoint bound to the wildcard local address.
     * A unique "socket" will be created for us. This will become
     * our datagram "connection".
     */
    Status = _TdCreateEndpointStruct(
                 pTd,
                 &pAddressEndpoint->TransportName,
                 &pEndpoint,
                 pLocalAddress,
                 LocalAddressLength
                 );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in _TdCreateEndpointStruct\n",Status));
        goto badopen;
    }

    pEndpoint->EndpointType = TdiConnectionDatagram;
    pEndpoint->TransportHandleProcess = IoGetCurrentProcess();

    /*
     * Create the TDI address object.
     */
    Status = _TdiCreateAddress(
                 &pEndpoint->TransportName,
                 pEndpoint->pTransportAddress,
                 pEndpoint->TransportAddressLength,
                 &pEndpoint->TransportHandle,
                 &pEndpoint->pFileObject,
                 &pEndpoint->pDeviceObject
                 );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in _TdiCreateAddress\n",Status));
        goto badbind;
    }

    /*
     * Allocate a work buffer for querying the transport address
     */
    AddressInfoLength = pEndpoint->TransportAddressLength+4;
    Status = MemoryAllocate( AddressInfoLength, &pAddressInfo );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x Allocating Memory %d bytes\n",Status,AddressInfoLength));
        goto badbind;
    }

    /*
     * Now query the unique socket address that the TDI assigned for us.
     */
    Status = _TdiQueryAddressInfo(
                 pTd,
                 NULL,   // Irp
                 pEndpoint->pFileObject,
                 pEndpoint->pDeviceObject,
                 pAddressInfo,
                 AddressInfoLength
                 );
    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in _TdiQueryAddressInfo\n",Status));
        goto badbind;
    }

    /*
     * Update the callers transport address buffer
     */
    RtlCopyMemory( pEndpoint->pTransportAddress,
                   &pAddressInfo->Address,
                   pEndpoint->TransportAddressLength );

    /*
     * Save the remote address in the connection endpoint
     * structure so that we can send to it with our datagram sends.
     */
    ASSERT( pEndpoint->pRemoteAddress == NULL );
    pEndpoint->pRemoteAddress = pRemoteAddress;
    pEndpoint->RemoteAddressLength = RemoteAddressLength;

    pEndpoint->SendInfo.RemoteAddress = pRemoteAddress;
    pEndpoint->SendInfo.RemoteAddressLength = RemoteAddressLength;

    /*
     * Call protocol specific routine to complete the datagram connection.
     *
     * This sends the ICA connect reply datagram.
     */
    Status = TdiDeviceCompleteDatagramConnection(
                 pTd,
                 pEndpoint->pFileObject,
                 pEndpoint->pDeviceObject,
                 pEndpoint->SendInfo.RemoteAddress,
                 pEndpoint->SendInfo.RemoteAddressLength
                 );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("_TdWaitForDatagramConnection: Error 0x%x in TdiDeviceCompleteDatagramConnection\n",Status));
        goto badcomplete;
    }

    *ppConnectionEndpoint = pEndpoint;
    MemoryFree(pLocalAddress);
    MemoryFree(pAddressInfo);

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

badcomplete:
badbind:
    if (pEndpoint)
        _TdCloseEndpoint(pTd, pEndpoint);

badopen:
    if (pAddressInfo)
        MemoryFree(pAddressInfo);
    if (pRemoteAddress)
        MemoryFree(pRemoteAddress);

badwait:
    MemoryFree(pLocalAddress);

badmalloc:
    return Status;
}


/*****************************************************************************
 *
 *  returns the remote address
 *
 ****************************************************************************/
NTSTATUS DeviceQueryRemoteAddress( 
    PTD pTd, 
    PVOID pIcaEndpoint, 
    ULONG EndpointSize, 
    PVOID pOutputAddress, 
    ULONG OutputAddressSize, 
    PULONG BytesReturned)
{
    NTSTATUS status = STATUS_NOT_SUPPORTED;
    PTD_STACK_ENDPOINT pStackEndpoint;
    PTRANSPORT_ADDRESS pRemoteAddress;
    PTA_ADDRESS     pRemoteIP;
    PVOID    Handle;
    ULONG    Length;
    struct   {
        USHORT  sa_family;
        CHAR    sa_data[1];
    } *pOutput;

    *BytesReturned = 0;

    if ( sizeof(PVOID) != EndpointSize )
    {
        status = STATUS_INVALID_PARAMETER_4;
        goto exitpt;
    }

    pOutput = pOutputAddress;
    if ( NULL == pOutput )
    {
        status = STATUS_INVALID_PARAMETER_5;
        goto exitpt;
    }

    try {
        RtlZeroMemory( pOutput, OutputAddressSize );
    } except ( EXCEPTION_EXECUTE_HANDLER )
    {
        status = GetExceptionCode();
        DBGPRINT(("DeviceQueryRemoteAddress: Exception 0x%x\n", status));
        goto exitpt;
    }

    /*
     * Capture the parameter
     */
    try {
        ProbeForRead( pIcaEndpoint, sizeof(PVOID), 1 );
        Handle = (*((PVOID *)pIcaEndpoint));
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = GetExceptionCode();
        DBGPRINT(("DeviceQueryRemoteAddress: Exception 0x%x\n", status));
        goto exitpt;
    }

    TRACE0(("DeviceOpenEndpoint: Fetching Handle 0x%x\n", Handle));

    /*
     * See if TERMDD knows about the handle
     */
    status = IcaReturnHandle( Handle, &pStackEndpoint, &Length );
    if( !NT_SUCCESS(status) ) {
        DBGPRINT(("DeviceQueryRemoteAddress: TERMDD handle 0x%x no good 0x%x\n", Handle, status));
        status = STATUS_INVALID_PARAMETER_3;
        goto exitpt;
    }

    if ( TDI_ADDRESS_TYPE_IP != pStackEndpoint->AddressType &&
         TDI_ADDRESS_TYPE_IP6 != pStackEndpoint->AddressType )
    {
        status = STATUS_NOT_SUPPORTED;
        goto exitpt;
    }

    if ( NULL == pStackEndpoint->pEndpoint )
    {
        status = STATUS_INVALID_PARAMETER_3;    // remote address wasn't recorded
        goto exitpt;
    }


    pRemoteAddress = pStackEndpoint->pEndpoint->pRemoteAddress;

    ASSERT( 1 == pRemoteAddress->TAAddressCount );
    pRemoteIP = pRemoteAddress->Address;

    //
    //  check the size of the output including the protocol family
    //
    if ( pRemoteIP->AddressLength + sizeof( USHORT ) > OutputAddressSize )
    {
        status = STATUS_BUFFER_TOO_SMALL;
        goto exitpt;
    }

    ASSERT( sizeof( TDI_ADDRESS_IP )  == pRemoteIP->AddressLength || 
            sizeof( TDI_ADDRESS_IP6 ) == pRemoteIP->AddressLength );
    ASSERT( TDI_ADDRESS_TYPE_IP  == pRemoteIP->AddressType ||
            TDI_ADDRESS_TYPE_IP6 == pRemoteIP->AddressType );

    pOutput->sa_family = pRemoteIP->AddressType;
    RtlCopyMemory( &pOutput->sa_data, &(pRemoteIP->Address), pRemoteIP->AddressLength );
    *BytesReturned = sizeof( *pOutput );

    status = STATUS_SUCCESS;
exitpt:
    return status;
}

/*****************************************************************************
 * _TdCancelReceiveQueue
 *
 * Cancel all of the I/O in the current Receive Queue
 ****************************************************************************/
NTSTATUS _TdCancelReceiveQueue(PTD pTd, PTD_ENDPOINT pEndpoint, NTSTATUS CancelStatus)
{
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;

    DBGPRINT(("_TdCancelReceiveQueue [%p]: Endpoint 0x%p\n", pTd, pEndpoint));

    ExAcquireSpinLock( &pEndpoint->Spinlock, &OldIrql );

    /*
     * If we have any Receive Irp's, we are waiting for the
     * indication handler to submit the I/O. Since the IRP
     * is not submitted yet, we must cancel the IRP's.
     */
    while (!IsListEmpty(&pEndpoint->ReceiveQueue)) {
        pEntry = RemoveHeadList( &pEndpoint->ReceiveQueue );
        Irp = CONTAINING_RECORD( pEntry, IRP, Tail.Overlay.ListEntry );

        TRACE0(("_TdCancelReceiveQueue: Cancel Receive Irp 0x%x on pEndpoint 0x%x\n",Irp,pEndpoint));

        ExReleaseSpinLock( &pEndpoint->Spinlock, OldIrql );

        Irp->IoStatus.Status = CancelStatus;
        Irp->IoStatus.Information = 0;

        // Since the IRP has not been submitted with IoCallDriver() yet,
        // we must simulate.
        IoSetNextIrpStackLocation(Irp);

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        ExAcquireSpinLock(&pEndpoint->Spinlock, &OldIrql);
    }

    ExReleaseSpinLock(&pEndpoint->Spinlock, OldIrql);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdipx\ignore.c ===
/*************************************************************************
*
* ignore.c
*
* Ignore duplicate (retry) connections for IPX
*
* Copyright 1998, Microsoft
*  
*************************************************************************/

#include <ntddk.h>
#include <tdi.h>
/*
 * The following defines are necessary since they are referenced in
 * afd.h but defined in sdk/inc/winsock2.h, which we can't include here.
 */
#define SG_UNCONSTRAINED_GROUP   0x01
#define SG_CONSTRAINED_GROUP     0x02
#include <afd.h>

#include <isnkrnl.h>
#include <ndis.h>
#include <wsnwlink.h>

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <icaipx.h>
//#include <cxstatus.h>
#include <sdapi.h>
#include <td.h>

#include "tdipx.h"


/*=============================================================================
==   External Functions Defined
=============================================================================*/

BOOLEAN IsOnIgnoreList( PTD, PLIST_ENTRY, PTRANSPORT_ADDRESS, ULONG );
VOID AddToIgnoreList( PTD, PLIST_ENTRY, PTRANSPORT_ADDRESS, ULONG );
VOID CleanupIgnoreList( PTD, PLIST_ENTRY );


/*=============================================================================
==   Functions Used
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


#define IGNORE_TIMEOUT 15   // 15 seconds

/*
 * List of addresses
 */
typedef struct _IGNOREADDRESS {
    LIST_ENTRY Links;
    LARGE_INTEGER TimeOut;
    PTRANSPORT_ADDRESS pRemoteAddress;
    ULONG RemoteAddressLength;
} IGNOREADDRESS, *PIGNOREADDRESS;


/*******************************************************************************
 *
 *  IsOnIgnoreList
 *
 *  Is this address on the list of recently received addresses?
 *  This occurs when a client retries a connection packet.
 *
 * ENTRY:
 *    pTd (input)
 *       pointer to TD data structure
 *    pIgnoreList (input)
 *       Pointer to address ignore list
 *    pRemoteAddress (input)
 *       Pointer to IPX address received
 *    RemoteAddressLength (input)
 *       Length in bytes of pRemoteAddress
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

BOOLEAN
IsOnIgnoreList(
    PTD pTd,
    PLIST_ENTRY pIgnoreList,
    PTRANSPORT_ADDRESS pRemoteAddress,
    ULONG RemoteAddressLength
    )
{
    PLIST_ENTRY Next;
    PLIST_ENTRY Head;
    PIGNOREADDRESS pIgnoreAddress;
    LARGE_INTEGER CurrentTime;

    KeQuerySystemTime( &CurrentTime ); // 100 nanoseconds

    TRACE(( pTd->pContext, TC_TD, TT_API3, "TDIPX: searching for %02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x\n",
        pRemoteAddress->Address[0].Address[0],
        pRemoteAddress->Address[0].Address[1],
        pRemoteAddress->Address[0].Address[2],
        pRemoteAddress->Address[0].Address[3],
        pRemoteAddress->Address[0].Address[4],
        pRemoteAddress->Address[0].Address[5],
        pRemoteAddress->Address[0].Address[6],
        pRemoteAddress->Address[0].Address[7],
        pRemoteAddress->Address[0].Address[8],
        pRemoteAddress->Address[0].Address[9] ));
        
    /*
     * Scan the list of addresses for this one, pruning old addresses.
     */
    Head = pIgnoreList;
    Next = Head->Flink;
    while ( Next != Head ) {
        pIgnoreAddress = CONTAINING_RECORD( Next, IGNOREADDRESS, Links );

	if ( RtlLargeIntegerLessThan( CurrentTime, pIgnoreAddress->TimeOut ) ) {
            if ( RemoteAddressLength == pIgnoreAddress->RemoteAddressLength &&
	         !memcmp( pRemoteAddress, pIgnoreAddress->pRemoteAddress, 
	                  RemoteAddressLength ) ) {
                TRACE(( pTd->pContext, TC_TD, TT_API3, "TDIPX: matched %x\n", Next ));
                return TRUE;
            }
            Next = Next->Flink;
	} else {
            TRACE(( pTd->pContext, TC_TD, TT_API3, "TDIPX: removing %x\n", Next ));
	    RemoveEntryList( Next );
            Next = Next->Flink;
	    InitializeListHead( &pIgnoreAddress->Links );
	    MemoryFree( pIgnoreAddress );
	}
    }

    TRACE(( pTd->pContext, TC_TD, TT_API3, "TDIPX: no matches\n" ));
    return FALSE;
}


/*******************************************************************************
 *
 *  AddToIgnoreList
 *
 *  Add this address to the list of recently received connection packets.
 *  This list should be cleared frequently.
 *
 * ENTRY:
 *    pTd (input)
 *       pointer to TD data structure
 *    pIgnoreList (input)
 *       Pointer to address ignore list
 *    pRemoteAddress (input)
 *       Pointer to IPX address
 *    RemoteAddressLength (input)
 *       Length in bytes of pRemoteAddress
 *
 * EXIT:
 *    none
 *
 ******************************************************************************/

VOID
AddToIgnoreList(
    PTD pTd,
    PLIST_ENTRY pIgnoreList,
    PTRANSPORT_ADDRESS pRemoteAddress,
    ULONG RemoteAddressLength )
{
    NTSTATUS Status;
    PIGNOREADDRESS pIgnoreAddress;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeOut;

    Status = MemoryAllocate( sizeof( IGNOREADDRESS ) + RemoteAddressLength,
                             &pIgnoreAddress );
    if ( !NT_SUCCESS( Status ) ) {
        return;
    }

    pIgnoreAddress->pRemoteAddress = (PTRANSPORT_ADDRESS)(pIgnoreAddress + 1);
    pIgnoreAddress->RemoteAddressLength = RemoteAddressLength;

    KeQuerySystemTime( &CurrentTime ); // 100 nanoseconds
    TimeOut = RtlEnlargedIntegerMultiply( 10000, IGNORE_TIMEOUT * 1000 );
    pIgnoreAddress->TimeOut = RtlLargeIntegerAdd( CurrentTime, TimeOut );

    memcpy( pIgnoreAddress->pRemoteAddress, pRemoteAddress, RemoteAddressLength );

    InsertHeadList( pIgnoreList, &pIgnoreAddress->Links );
    TRACE(( pTd->pContext, TC_PD, TT_API3, "TDIPX: adding %x\n", &pIgnoreAddress->Links ));
}


/*******************************************************************************
 *
 *  CleanupIgnoreList
 *
 *  Delete all entries on the list
 *
 * ENTRY:
 *    pTd (input)
 *       pointer to TD data structure
 *    pIgnoreList (input)
 *       Pointer to address ignore list
 *
 * EXIT:
 *    none
 *
 ******************************************************************************/
VOID
CleanupIgnoreList( PTD pTd, PLIST_ENTRY pIgnoreList )
{
    PIGNOREADDRESS pIgnoreAddress;

    while ( !IsListEmpty( pIgnoreList ) ) {
        pIgnoreAddress = CONTAINING_RECORD( pIgnoreList->Flink,
	                                    IGNOREADDRESS, Links );
        RemoveEntryList( &pIgnoreAddress->Links );
	InitializeListHead( &pIgnoreAddress->Links );
	MemoryFree( pIgnoreAddress );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdipx\tdipx.h ===
/***************************************************************************
*
* tdipx.h
*
* This module contains private Transport Driver defines and structures
*
* Copyright 1998, Microsoft
*  
****************************************************************************/


#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))


/*
 * Well known Citrix IPX socket
 */
#define CITRIX_IPX_SOCKET 0xBB85


#define DD_IPX_DEVICE_NAME L"\\Device\\NwlnkIpx"
#define DD_SPX_DEVICE_NAME L"\\Device\\NwlnkSpx"


//
// IPX_PACKET - format of packet submitted to IPX for sending. The maximum
// size of an IPX packet is 576 bytes, 30 bytes header, 546 bytes data
//
typedef struct {
    BYTE Net[4];                        // hi-lo
    BYTE Node[6];                       // hi-lo
    USHORT Socket;                      // hi-lo
} NETWARE_ADDRESS ;

typedef struct {
    USHORT Checksum;                    // always set to 0xFFFF
    USHORT Length;                      // set by IPX - header + data
    BYTE TransportControl;              // set by IPX to 0. Used by routers

    //
    // for IPX, PacketType is 0 (Unknown Packet Type) or 4 (Packet Exchange
    // Packet)
    //

    BYTE PacketType;
    NETWARE_ADDRESS Destination;
    NETWARE_ADDRESS Source;
    BYTE Data[];                        // 546 bytes max.
} IPX_PACKET ;

typedef IPX_PACKET UNALIGNED *LPIPX_PACKET;

#define IPX_HEADER_LENGTH           sizeof(IPX_PACKET)
#define MAXIMUM_IPX_PACKET_LENGTH   576
#define MAXIMUM_IPX_DATA_LENGTH     (MAXIMUM_IPX_PACKET_LENGTH - IPX_HEADER_LENGTH)


/*
 *  IPX TD structure
 */
typedef struct _TDIPX {

    LIST_ENTRY IgnoreList;      // list of ipx addresses to ignore 
    ULONG AliveTime;            // keep alive time (msec)
    PVOID pAliveTimer;          // watchdog timer handle
    ULONG AlivePoll;
    ULONG fClientAlive : 1;    

} TDIPX, * PTDIPX;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdipx\tdipx.c ===
/*************************************************************************
 *
 * tdipx.c
 *
 * IPX transport specific routines for TDI based TD's
 *
 * Copyright 1998, Microsoft
 *  
 *************************************************************************/

#include <ntddk.h>
#include <tdi.h>

#include <isnkrnl.h>
#include <ndis.h>
#include <wsnwlink.h>

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <icaipx.h>
//#include <cxstatus.h>
#include <sdapi.h>
#include <td.h>

#include "tdtdi.h"
#include "tdipx.h"

#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdipx";
#endif

#define REG_IPX_Linkage \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NwlnkIpx\\Linkage"


#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif



/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS TdiDeviceOpen( PTD, PSD_OPEN );
NTSTATUS TdiDeviceClose( PTD, PSD_CLOSE );
NTSTATUS TdiDeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS TdiDeviceBuildTransportNameAndAddress( PTD, PICA_STACK_ADDRESS,
                                                PUNICODE_STRING,
                                                PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceBuildWildcardAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceWaitForDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT,
                                             PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceCompleteDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS TdiDeviceConnectionSend( PTD );
NTSTATUS TdiDeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS _OpenRegKey(PHANDLE, PWCHAR);
NTSTATUS _GetRegStringValue( HANDLE,PWCHAR,PKEY_VALUE_PARTIAL_INFORMATION *,PUSHORT);
NTSTATUS _GetRegDWORDValue( HANDLE, PWCHAR, PULONG );
NTSTATUS _GetRegMultiSZValue(HANDLE ,PWCHAR,PUNICODE_STRING );
VOID     GetGUID(OUT PUNICODE_STRING, IN  int);





/*=============================================================================
==   External Functions Referenced
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );
BOOLEAN  IsOnIgnoreList( PTD, PLIST_ENTRY, PTRANSPORT_ADDRESS, ULONG );
VOID     AddToIgnoreList( PTD, PLIST_ENTRY, PTRANSPORT_ADDRESS, ULONG );
VOID     CleanupIgnoreList( PTD, PLIST_ENTRY );
NTSTATUS InitializeWatchDog( PTD );

NTSTATUS
_TdiReceiveDatagram(
    IN PTD  pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    IN ULONG RecvFlags,
    IN PVOID pBuffer,
    IN ULONG BufferLength,
    OUT PULONG ReturnBufferLength
    );

NTSTATUS
_TdiSendDatagram(
    IN PTD  pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    IN PVOID pBuffer,
    IN ULONG BufferLength
    );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _IpxGetTransportAddress( PTD, int, PULONG, PUCHAR );
NTSTATUS _DoTdiAction( PFILE_OBJECT, ULONG, PCHAR, ULONG );
NTSTATUS _IPXGetAdapterNumber( int Lana, int * AdpNum );
    
       


#if DBG
VOID
DumpIpxAddress(
    PTRANSPORT_ADDRESS p,
    ULONG Len
    );
#endif

/*=============================================================================
==   Global variables
=============================================================================*/

/*
 * Define variables used by tdi common code
 */
USHORT TdiDeviceEndpointType = TdiConnectionDatagram;
USHORT TdiDeviceAddressType = TDI_ADDRESS_TYPE_IPX;
ULONG  TdiDeviceInBufHeader = IPX_HEADER_LENGTH;

ULONG TdiDeviceMaxTransportAddressLength = sizeof(TA_IPX_ADDRESS);

/*******************************************************************************
 *
 * TdiDeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpen( PTD pTd, PSD_OPEN pSdOpen )
{
    PTDIPX pTdIpx;
    NTSTATUS Status;

    /*
     * TDIPX uses multiple input buffers since the
     * underlying IPX driver does not do any buffering.
     */
    pTd->InBufCount = 2;

    /*
     *  Allocate IPX TD data structure
     */
    Status = MemoryAllocate( sizeof(*pTdIpx), &pTdIpx );
    if ( !NT_SUCCESS(Status) ) 
        goto badalloc;

    //ASSERT( pTd->pPrivate == NULL );
    pTd->pPrivate = pTdIpx;

    /*
     *  Initialize TDIPX data structure
     */
    RtlZeroMemory( pTdIpx, sizeof(*pTdIpx) );

    InitializeListHead( &pTdIpx->IgnoreList );

    /*
     *  Watchdog time in registry is seconds
     *     time = (seconds * 1000) / 2 
     */
    pTdIpx->AliveTime = pSdOpen->PdConfig.Create.KeepAliveTimeout * 500;

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  allocate failed
     */
badalloc:
    return( Status );
}



/*******************************************************************************
 *
 * TdiDeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the current connection endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceClose( PTD pTd, PSD_CLOSE pSdClose )
{
    PTDIPX pTdIpx;

    /*
     *  Get pointer to IPX structure
     */
    pTdIpx = (PTDIPX) pTd->pPrivate;

    /*
     *  Free ignore list memory
     */
    CleanupIgnoreList( pTd, &pTdIpx->IgnoreList );

    /* 
     *  Stop and close watchdog timer
     */
    if ( pTdIpx->pAliveTimer )
        IcaTimerClose( pTdIpx->pAliveTimer );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpenEndpoint(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG IcaEndpointLength
    )
{
    /*
     * For IPX, we bump the error threshold so that a single
     * network I/O error does not cause a disconnect.
     */
    pTd->ReadErrorThreshold = 5;
    pTd->WriteErrorThreshold = 5;

    /*
     *  Arm watch dog
     */
    (VOID) InitializeWatchDog( pTd );

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildTransportNameAndAddress
 *
 *  Build the Transport Name and Address given an optional ICA_STACK_ADDRESS,
 *  or the Lana value from the pTd->Params structure.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pLocalAddress (input)
 *     pointer to local address to use (OPTIONAL)
 *   pTransportName (output)
 *     pointer to UNICODE_STRING to return transport name
 *     NOTE: the buffer pointed to be pTransportName.Buffer must
 *           be free'd by the caller
 *   ppTransportAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pTransportAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildTransportNameAndAddress(
    PTD pTd,
    PICA_STACK_ADDRESS pLocalAddress,
    PUNICODE_STRING pTransportName,
    PTRANSPORT_ADDRESS *ppTransportAddress,
    PULONG pTransportAddressLength
    )
{
    PTDI_ADDRESS_IPX pIpxAddress;
    int Lana;
    NTSTATUS Status;

    /*
     * For IPX, the transport device name is fixed,
     * so just allocate and initialize the transport name string here.
     */
    Status = MemoryAllocate( sizeof(DD_IPX_DEVICE_NAME), &pTransportName->Buffer );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc1;
    wcscpy( pTransportName->Buffer, DD_IPX_DEVICE_NAME );
    pTransportName->Length = sizeof(DD_IPX_DEVICE_NAME) - sizeof(UNICODE_NULL);
    pTransportName->MaximumLength = pTransportName->Length + sizeof(UNICODE_NULL);

    /*
     * Allocate a transport address structure
     */
    *pTransportAddressLength = sizeof(TA_IPX_ADDRESS);
    Status = MemoryAllocate( *pTransportAddressLength, ppTransportAddress );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc2;

    /*
     * Initialize the static part of the transport address
     */
    (*ppTransportAddress)->TAAddressCount = 1;
    (*ppTransportAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    (*ppTransportAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    pIpxAddress = (PTDI_ADDRESS_IPX)(*ppTransportAddress)->Address[0].Address;
    pIpxAddress->Socket = htons( CITRIX_IPX_SOCKET );

    /*
     * If a local address is specified, then use it.
     */
    if ( pLocalAddress ) {

        /*
         * Skip over the address family(type) data (bytes 0&1) of the
         * local address struct, and copy the remainder of the address
         * directly to the Address field of the TransportAddress struct.
         */
        ASSERT( *(PUSHORT)pLocalAddress == TDI_ADDRESS_TYPE_IPX );
        RtlCopyMemory( pIpxAddress, &((PCHAR)pLocalAddress)[2], sizeof(TDI_ADDRESS_IPX) );

    /*
     * There was no local address specified.
     * In this case, we use the LanAdapter value from the PDPARAMS
     * structure to lookup the corresponding IPX address.
     */
    } else if ( (Lana = pTd->Params.Network.LanAdapter) ) {

        /*
         * Get Local Address Information
         */

        Status = _IpxGetTransportAddress( pTd, Lana,
                                          &pIpxAddress->NetworkAddress,
                                          pIpxAddress->NodeAddress );
        if ( !NT_SUCCESS( Status ) )
            goto badadapterdata;
    
    /*
     * No LanAdapter value was specified, so use the wildcard address (zero)
     */
    } else {
        pIpxAddress->NetworkAddress = 0;
        RtlZeroMemory( pIpxAddress->NodeAddress,
                       sizeof(pIpxAddress->NodeAddress) );
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badadapterdata:
    MemoryFree( *ppTransportAddress );

badmalloc2:
    MemoryFree( pTransportName->Buffer );

badmalloc1:
    return( Status );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildWildcardAddress
 *
 *  Build a wildcard Address for this protocol.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   ppWildcardAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pWildcardAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildWildcardAddress(
    PTD pTd,
    PTRANSPORT_ADDRESS *ppWildcardAddress,
    PULONG pWildcardAddressLength
    )
{
    PTDI_ADDRESS_IPX pIpxAddress;
    NTSTATUS Status;

    /*
     * Allocate a transport address structure
     */
    *pWildcardAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IPX);
    Status = MemoryAllocate( *pWildcardAddressLength, ppWildcardAddress );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Initialize the static part of the transport address
     */
    (*ppWildcardAddress)->TAAddressCount = 1;
    (*ppWildcardAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    (*ppWildcardAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    pIpxAddress = (PTDI_ADDRESS_IPX)(*ppWildcardAddress)->Address[0].Address;
    pIpxAddress->NetworkAddress = 0;
    RtlZeroMemory( pIpxAddress->NodeAddress,
                   sizeof(pIpxAddress->NodeAddress) );
    pIpxAddress->Socket = 0;

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceWaitForDatagramConnection
 *
 *  Wait for a datagram connection request, validate it,
 *  and return the remote transport address of the connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object to wait for a connection on
 *   ppRemoteAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pRemoteAddressLength (output)
 *     pointer to location to return RemoteAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceWaitForDatagramConnection(
    PTD pTd,
    PFILE_OBJECT   pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS *ppRemoteAddress,
    PULONG pRemoteAddressLength
    )
{
    char *pReceiveBuffer;
    PTRANSPORT_ADDRESS pRemoteAddress;
    ULONG RemoteAddressLength;
    NTSTATUS Status;
    PTDIPX pTdIpx;
    ULONG  BufferLength, ReturnLength;

    /*
     *  Get pointer to IPX structure
     */
    pTdIpx = (PTDIPX) pTd->pPrivate;

    /*
     * Allocate a receive data buffer as well as
     * a buffer to hold the remote transport address.
     */
    BufferLength = CALL_BUFFER_SIZE;

    Status = MemoryAllocate( BufferLength, &pReceiveBuffer );
    if ( !NT_SUCCESS( Status ) ) {
        goto badmalloc;
    }

    RemoteAddressLength = TdiDeviceMaxTransportAddressLength;
    Status = MemoryAllocate( RemoteAddressLength, &pRemoteAddress );
    if ( !NT_SUCCESS( Status ) ) {
        goto badmalloc2;
    }

    /*
     * Initialize the receive info buffer
     */
    for ( ; ; ) {

	RemoteAddressLength = TdiDeviceMaxTransportAddressLength;
    
        TRACE0(("IPX: TdiWaitForDatagramConnection: Waiting for datagram request RemoteAddressLength %d\n",RemoteAddressLength));

	/*
         * Wait for data to arrive
         */
        Status = _TdiReceiveDatagram(
                     pTd,
	             NULL,      // Irp
		     pFileObject,
		     pDeviceObject,
		     (PTRANSPORT_ADDRESS)pRemoteAddress,
		     RemoteAddressLength,
                     TDI_RECEIVE_NORMAL,   // TDI ReceiveFlags
		     pReceiveBuffer,
		     BufferLength,
		     &ReturnLength
		     );

        if ( !NT_SUCCESS( Status ) ) {
            DBGPRINT(("TdiDeviceWaitForDatagramConnection: Error 0x%x from _TdiReceiveDatagram\n",Status));
	    goto badrecv;
        }

        TRACEBUF(( pTd->pContext, TC_TD, TT_IRAW, pReceiveBuffer, ReturnLength ));
    
        /*
         * See if the received buffer is the correct size
         */
        if ( ReturnLength != CALL_BUFFER_SIZE ) {
            TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TDIPX: Invalid IPX connect packet length\n" ));
            TRACE0(("TDIPX: Invalid IPX connect packet length 0x%x\n",ReturnLength));
            continue;
        }

        /*
         * See if it matches our expected connection string
         */
        if ( memcmp( pReceiveBuffer, CONNECTION_STRING, sizeof(CONNECTION_STRING) ) ){
            TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TDIPX: Invalid IPX connect packet data\n" ));
            TRACE0(("TDIPX: Invalid IPX connect packet data\n"));
            continue;
        }

#if DBG
        TRACE0(("TdiDeviceWaitForDatagramConnection: Connect Request From Client Address:\n"));
        DumpIpxAddress( pRemoteAddress, RemoteAddressLength );
#endif

	/*
         * Fix up the remote transport address
         */
#ifdef notdef
	pRemoteAddress->TAAddressCount = 1;
        pRemoteAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
	pRemoteAddress->Address[0].AddressLength = (USHORT)RemoteAddressLength;
	RemoteAddressLength += FIELD_OFFSET( TRANSPORT_ADDRESS, Address[0].Address[0] );
#endif

        /*
         *  Validation complete - seems to be a valid ipx connection packet
         */
        if ( IsOnIgnoreList( pTd, &pTdIpx->IgnoreList, pRemoteAddress, RemoteAddressLength ) ) {
            TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TDIPX: TdiDeviceWaitForDatagramConnection ignored dup IPX connect\n"));
            TRACE0(("TDIPX: TdiDeviceWaitForDatagramConnection ignored dup IPX connect\n"));
            continue;
        }

        break;
    }

    AddToIgnoreList( pTd, &pTdIpx->IgnoreList, pRemoteAddress, RemoteAddressLength );

    MemoryFree( pReceiveBuffer );

    *ppRemoteAddress = pRemoteAddress;
    *pRemoteAddressLength = RemoteAddressLength;

    TRACE(( pTd->pContext, TC_TD, TT_API2, "TDIPX: TdiDeviceWaitForDatagramConnection: %u bytes, success\n",
            ReturnLength ));
    TRACE0(("TDIPX: TdiDeviceWaitForDatagramConnection: %u bytes, success\n",ReturnLength));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badrecv:
    MemoryFree( pRemoteAddress );

badmalloc2:
    MemoryFree( pReceiveBuffer );

badmalloc:
    TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
            "TDIPX: TdiDeviceWaitForDatagramConnection ERROR, Status=0x%x\n", Status ));
    TRACE0(("TDIPX: TdiDeviceWaitForDatagramConnection ERROR, Status=0x%x\n", Status));
    return( Status );
}


/*****************************************************************************
 *
 *  TdiDeviceCompleteDatagramConnection
 *
 *  Do any final work to complete a datagram connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object for this connection
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceCompleteDatagramConnection(
    PTD pTd, 
    PFILE_OBJECT   pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS pRemoteAddress,
    ULONG RemoteAddressLength
    )
{
    CHAR ptype;
    NTSTATUS Status;
    BYTE ReplyBuffer[CALL_BUFFER_SIZE];

    /*
     *  Create reply packet with reply string
     */
    memset( ReplyBuffer, 0, CALL_BUFFER_SIZE );
    memcpy( ReplyBuffer, CONNECTION_STRING_REPLY, sizeof(CONNECTION_STRING_REPLY) );

    /*
     *  Add ICA 3.0 and not sequenced to reply packet
     */
    ReplyBuffer[CALL_HOST_IPX_VERSION] = ICA_3_IPX_VERSION;
    ReplyBuffer[CALL_HOST_SEQUENCE_ENABLE] = 0x00;

    TRACEBUF(( pTd->pContext, TC_TD, TT_ORAW, ReplyBuffer, CALL_BUFFER_SIZE ));

#if DBG
    TRACE0(("TdiDeviceCompleteDatagramConnection: Sending Connect Reply to Client Address:\n"));
    DumpIpxAddress( pRemoteAddress, RemoteAddressLength );
#endif

    /*
     *  Write data to the network
     */
    Status = _TdiSendDatagram(
                 pTd,
		 NULL,   // Irp
		 pFileObject,
		 pDeviceObject,
                 pRemoteAddress,
		 RemoteAddressLength,
		 ReplyBuffer,
		 CALL_BUFFER_SIZE
		 );

    ASSERT( Status == STATUS_SUCCESS );

    /*
     * Set up the default packet send type to be data
     */
    ptype = IPX_TYPE_DATA;
    Status = _DoTdiAction( pFileObject, MIPX_SETSENDPTYPE, &ptype, 1 );
    ASSERT( Status == STATUS_SUCCESS );
    if ( !NT_SUCCESS( Status ) )
        goto badtdiaction;

    /*
     * Indicate we want the IPX header included in send/receive data
     */
    Status = _DoTdiAction( pFileObject, MIPX_SENDHEADER, NULL, 0 );
    ASSERT( Status == STATUS_SUCCESS );
    if ( !NT_SUCCESS( Status ) )
        goto badtdiaction;

    TRACE(( pTd->pContext, TC_TD, TT_API2, "TDIPX: TdiDeviceCompleteDatagramConnection: %u bytes, success\n" ,
            CALL_BUFFER_SIZE ));
    TRACE0(("TDIPX: TdiDeviceCompleteDatagramConnection: %u bytes, success\n",CALL_BUFFER_SIZE));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badtdiaction:

    TRACE(( pTd->pContext, TC_TD, TT_ERROR, 
            "TDIPX: TdiDeviceCompleteDatagramConnection ERROR, Status=0x%x\n", Status ));
    TRACE0(("TDIPX: TdiDeviceCompleteDatagramConnection ERROR, Status=0x%x\n",Status));

    return( Status );
}


/*******************************************************************************
 *
 *  TdiDeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceConnectionSend( PTD pTd )
{
    PCLIENTMODULES pClient;

    /*
     *  Get pointer to client structure
     */
    pClient = pTd->pClient;

    /*
     *  Initialize Td host module structure
     */
    pClient->TdVersionL = VERSION_HOSTL_TDIPX; 
    pClient->TdVersionH = VERSION_HOSTH_TDIPX; 
    pClient->TdVersion  = VERSION_HOSTH_TDIPX; 

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  TdiDeviceReadComplete
 *
 *  Do any read complete processing
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location containing byte count read
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceReadComplete( PTD pTd, PUCHAR pBuffer, PULONG pByteCount )
{
    IPX_PACKET * pIpxHeader;
    PUCHAR pByte;
    NTSTATUS Status;
    PTDIPX pTdIpx;

    /*
     *  Get pointer to IPX structure
     */
    pTdIpx = (PTDIPX) pTd->pPrivate;

    /*
     *  Check for at least IPX_PACKET bytes
     */
    if ( *pByteCount < IPX_HEADER_LENGTH ) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TDIPX: recv failed, less than ipx header bytes\n" ));
        return( STATUS_CTX_TD_ERROR );
    }

    /*
     *  Address ipx header
     */
    pIpxHeader = (IPX_PACKET *) pBuffer;

    /*
     *  Check for control packet
     */
    if ( pIpxHeader->PacketType == IPX_TYPE_CONTROL ) {

        /*
         *  Get first data byte
         */
        pByte = (PUCHAR) pBuffer + IPX_HEADER_LENGTH;

        /*
         *  What type of packet
         */
        switch ( *pByte ) {

            /*
             *  Keep alive response
             */
            case IPX_CTRL_PACKET_PING_RESP :

                pTdIpx->fClientAlive = TRUE;
                pTdIpx->AlivePoll    = 0;
                pTd->pStatus->Input.Bytes++;
                TRACE(( pTd->pContext, TC_TD, TT_API2, "TDIPX: Watchdog Response Control Packet\n" ));
                break;

            /*
             *  Client disconnect packet
             */
            case IPX_CTRL_PACKET_HANGUP :

                TRACE(( pTd->pContext, TC_TD, TT_API2, "TDIPX: Hangup Control Packet\n" ));
                pTd->pStatus->Input.Bytes++;
                // drop error threshold so returned error isn't ignored
                pTd->ReadErrorThreshold = 0;
                return( STATUS_IO_TIMEOUT ); 
                break;

            /*
             *  Unknown packet
             */
            default :

                TRACE(( pTd->pContext, TC_TD, TT_API2, "TDIPX: Unknown Control Packet, type %u\n", *pByte ));
                break;
        }

        /*
         *  Indicate to caller that we ate all the data
         */
        *pByteCount = 0;
        return( STATUS_SUCCESS );
    }

    /*
     *  Got a valid non-control packet
     */
    pTdIpx->fClientAlive = TRUE;
    pTdIpx->AlivePoll    = 0;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  TransportAddress
 *
 *  Get IPX transport address for a given LanAdapter number
 *
 *
 *  ENTRY:
 *     pTd (input)
 *        pointer to TD data structure
 *     Lana (input)
 *        Lan Adapter number
 *     pNetworkAddress (output)
 *        pointer to location to return NetworkAddress
 *     pNodeAddress (output)
 *        pointer to location to return NodeAddress
 *
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_IpxGetTransportAddress(
    PTD pTd,
    int Lana,
    PULONG pNetworkAddress,
    PUCHAR pNodeAddress
    )
{
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING nameString;
    HANDLE IPXHandle;
    ULONG tdiBufferLength;
    PSTREAMS_TDI_ACTION tdiBuffer;
    ULONG cmd;
    PIPX_ADDRESS_DATA pIpxAddressData;
    PFILE_OBJECT pFileObject;
    NTSTATUS Status;
    int IpxAdapterNum = 0;

    /*
     * Open a Handle to the IPX driver.
     */
    RtlInitUnicodeString( &nameString, DD_IPX_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    Status = ZwCreateFile( &IPXHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &objectAttributes,
                           &ioStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0
                           );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Allocate a TDI buffer to do the IOCTL.
     */
    tdiBufferLength = sizeof(STREAMS_TDI_ACTION) + sizeof(ULONG) +
                      sizeof(IPX_ADDRESS_DATA);
    Status = MemoryAllocate( tdiBufferLength, &tdiBuffer );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( IPXHandle );
        return( Status );
    }     
    

    /*
     * Fill in the tdiBuffer header
     */
    RtlMoveMemory( &tdiBuffer->Header.TransportId, "MISN", 4 );
    // use the following since we opened a control channel above
    tdiBuffer->DatagramOption = NWLINK_OPTION_CONTROL;

    // Get IPX Adapter Num from winstation Lana ID

    
    Status = _IPXGetAdapterNumber( Lana, &IpxAdapterNum);

    DbgPrint("IpxAdapterNum: %d\n", IpxAdapterNum);
    
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( IPXHandle );
        return( Status );
    } 

    
    /**
       Fill out the buffer, the buffer looks like this:

       ULONG cmd
       data passed.
    **/

    cmd = MIPX_GETCARDINFO;
    memcpy( tdiBuffer->Buffer, &cmd, sizeof(ULONG));

    tdiBuffer->BufferLength = sizeof(ULONG) + sizeof(IPX_ADDRESS_DATA);

    pIpxAddressData = (PIPX_ADDRESS_DATA)(tdiBuffer->Buffer + sizeof(ULONG));
    pIpxAddressData->adapternum = IpxAdapterNum ;



    Status = ObReferenceObjectByHandle( IPXHandle,
                                        0,
                                        NULL,
                                        KernelMode,
                                        (PVOID *)&pFileObject,
                                        NULL
                                        );
    ASSERT( Status == STATUS_SUCCESS );

    Status = CtxDeviceIoControlFile( pFileObject,
                                     IOCTL_TDI_ACTION,
                                     NULL,
                                     0,
                                     tdiBuffer,
                                     tdiBufferLength,
                                     FALSE,
                                     NULL,
                                     NULL,
                                     NULL
                                     );
    ObDereferenceObject( pFileObject );

    ZwClose( IPXHandle );

    if ( Status == STATUS_SUCCESS ) {
        RtlCopyMemory( pNetworkAddress, pIpxAddressData->netnum, 
                       sizeof(pIpxAddressData->netnum) );
        RtlCopyMemory( pNodeAddress, pIpxAddressData->nodenum, 
                       sizeof(pIpxAddressData->nodenum) );
        DbgPrint("pNetworkAddress: %x, pNodeAddress %s\n", *pNetworkAddress, *pNodeAddress);
    }

    MemoryFree( tdiBuffer );
    
    return( Status );
}

/*****************************************************************************
 *
 *  _DoTdiAction
 *
 *   Perform special IOCTL on IPX TDI.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
_DoTdiAction(
    PFILE_OBJECT pFileObject,
    ULONG cmd,
    PCHAR optbuf,
    ULONG optlen
    )
{
    ULONG tdiBufferLength;
    PSTREAMS_TDI_ACTION tdiBuffer;
    NTSTATUS Status;

    /*
     * Allocate a TDI buffer to do the IOCTL.
     */
    tdiBufferLength = sizeof(STREAMS_TDI_ACTION) + sizeof(ULONG) + optlen;
    Status = MemoryAllocate( tdiBufferLength, &tdiBuffer );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Fill in the tdiBuffer header
     */
    RtlMoveMemory( &tdiBuffer->Header.TransportId, "MISN", 4 );
    tdiBuffer->DatagramOption = 1; // Action is on an address on ISN

    /**
       Fill out the buffer, the buffer looks like this:

       ULONG cmd
       data passed.
    **/

    memcpy( tdiBuffer->Buffer, &cmd, sizeof(ULONG));

    tdiBuffer->BufferLength = sizeof(ULONG) + sizeof(CHAR);

    RtlMoveMemory( tdiBuffer->Buffer + sizeof(ULONG), optbuf, optlen );

    Status = CtxDeviceIoControlFile( pFileObject,
                                     IOCTL_TDI_ACTION,
                                     NULL,
                                     0,
                                     tdiBuffer,
                                     tdiBufferLength,
                                     FALSE,
                                     NULL,
                                     NULL,
                                     NULL
                                     );

    /*
     * Copy return data back to optbuf if needed
     */
    if ( NT_SUCCESS( Status ) && optlen ) {
        RtlMoveMemory( optbuf, tdiBuffer->Buffer + sizeof(ULONG), optlen );
    }

    MemoryFree( tdiBuffer );

    return( Status );
}

#if DBG
VOID
DumpIpxAddress(
    PTRANSPORT_ADDRESS p,
    ULONG Len
    )
{
    ULONG j;
    LONG i;
    PTDI_ADDRESS_IPX Ipx;

    DbgPrint("TAAddressCount %d, TotalLen %d\n",p->TAAddressCount,Len);

    for( i=0; i < p->TAAddressCount; i++ ) {

        DbgPrint("AddressLength %d, AddressType %d\n",p->Address[i].AddressLength,p->Address[i].AddressType);

        Ipx = (PTDI_ADDRESS_IPX)&p->Address[i].Address[0];

	DbgPrint("Network 0x%x Socket 0x%x\n",Ipx->NetworkAddress,Ipx->Socket);

	for( j=0; j < 6; j++ ) {
            DbgPrint("%x:",Ipx->NodeAddress[j]);
        }
        DbgPrint("\n\n");
    }
}
#endif


NTSTATUS
_IPXGetAdapterNumber(
    int Lana,
    int * AdpNum 
    )
/*++
Routine Description:

    Get the IPX Lan Adapter number using the instation Lana ID index
    
Arguments:
    
    Lana   - IN the winstation Lana ID index
    AdpNum - OUT the IPX Lana Adapter num

Return Value:

    return nt status

--*/
{

    NTSTATUS Status;
    int  AdapterNum;
    UNICODE_STRING RouteString;
    UNICODE_STRING NameString;
    
    HANDLE KeyHandle = NULL;        
    PWSTR  RouteStr, Str;
    unsigned RouteLen, Len;
    


     /* 
     * Convert winstation Lana_ID to Network Adapter number
     */    

    
    RtlInitUnicodeString( &RouteString , NULL );
    GetGUID( &RouteString , Lana );
    RouteLen = RouteString.Length;    
    RouteStr = RouteString.Buffer;
    AdapterNum =0;
    
#if DBG
    KdPrint( ( "TDIPX: _TcpGetTransportAddress Length = %d GUID = %ws\n" , RouteLen, RouteStr ) );
#endif

    if (RouteLen < (2 * sizeof(UNICODE_NULL))) {        
        return( STATUS_DEVICE_DOES_NOT_EXIST );
    }


    RtlInitUnicodeString( &NameString, REG_IPX_Linkage );

    Status = _OpenRegKey( &KeyHandle, REG_IPX_Linkage );
    if ( !NT_SUCCESS( Status ) )
        return Status;

    
    NameString.Length = 0;
    NameString.MaximumLength = 0;
    NameString.Buffer = NULL;
    Status = _GetRegMultiSZValue( KeyHandle, L"Route", &NameString );
    ZwClose( KeyHandle );

    if ( !NT_SUCCESS( Status ) )
        return Status;

    if (NameString.Length < (2 * sizeof(WCHAR))) {
        return(STATUS_DEVICE_DOES_NOT_EXIST);       
    }

    Len = NameString.Length;
    Str = NameString.Buffer;
    Status = STATUS_DEVICE_DOES_NOT_EXIST;
    AdapterNum = 0;

    for (;;) {
        // Check current string to see if it's a GUID (it must start with an
        // open brace after initial double-quote).
        if (Str[1] == L'{') {
     KdPrint( ( "TDIPX: _TcpGetTransportAddress, Str: %ws\n", &Str[1]));
            if ( wcsncmp( (PWSTR) &Str[1],RouteStr, wcslen(&Str[1])-2) == 0) {
     KdPrint( ( "TDIPX: _TcpGetTransportAddress, adapter number %i \n\n",AdapterNum) );
                Status = STATUS_SUCCESS;
                break;
            }
            else {
      KdPrint( ( "TDIPX: _TcpGetTransportAddress, No this lana Adapter = %i\n",AdapterNum ) );//      KdPrint( ( "TDIPX: _TcpGetTransportAddress, No this lana Adapter = %i\n",AdapterNum ) );
                AdapterNum ++;
            }

        }
        // Skip through current string past NULL.
        while (Len >= sizeof(WCHAR)) {
            Len -= sizeof(WCHAR);
            if (*Str++ == UNICODE_NULL)
                break;
        }
        // Check for index out of range.
        if (Len < (2 * sizeof(UNICODE_NULL))) {
            break;                    
            }
    }

    if ( !NT_SUCCESS( Status ) )
         return Status;

    *AdpNum = AdapterNum;
    return STATUS_SUCCESS;    
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdipx\watchdog.c ===
/*************************************************************************
 *
 *  watchdog.c
 *
 *  IPX Transport Driver - Watch Dog Rouines
 *
 * Copyright 1998, Microsoft
 *
 *************************************************************************/

#include <ntddk.h>
#include <tdi.h>

/*
 * The following defines are necessary since they are referenced in
 * afd.h but defined in sdk/inc/winsock2.h, which we can't include here.
 */
#define SG_UNCONSTRAINED_GROUP   0x01
#define SG_CONSTRAINED_GROUP     0x02
#include <afd.h>

#include <isnkrnl.h>
#include <ndis.h>
#include <wsnwlink.h>

#include <winstaw.h>
#define  _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <icaipx.h>
//#include <cxstatus.h>
#include <sdapi.h>
#include <td.h>

#include "tdtdi.h"
#include "tdipx.h"


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS InitializeWatchDog( PTD );
VOID     WatchDogTimer( PTD, PVOID );


/*=============================================================================
==   Internel Functions Defined
=============================================================================*/

VOID _GetTimeoutValue( PTD, ULONG, PULONG );


/*=============================================================================
==   External Functions used
=============================================================================*/

NTSTATUS _DoTdiAction( PFILE_OBJECT, ULONG, PCHAR, ULONG );

NTSTATUS
_TdiSendDatagram(
    IN PTD pTd,
    IN PIRP Irp OPTIONAL,
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    IN PVOID pBuffer,
    IN ULONG BufferLength
    );


/*******************************************************************************
 *
 *  InitializeWatchDog
 *
 *  Initialize watch dog
 *
 *  ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 *  EXIT:
 *    STATUS_SUCCESS        - no error, non-error match found
 *
 ******************************************************************************/

NTSTATUS
InitializeWatchDog( PTD pTd )
{
    ULONG Timeout;
    NTSTATUS Status;
    PTDIPX pTdIpx;

    TRACE(( pTd->pContext, TC_TD, TT_API1, "TDIPX: InitializeWatchDog\n" ));

    /*
     *  Get pointer to IPX structure
     */
    pTdIpx = (PTDIPX) pTd->pPrivate;

    /*
     *  If we really want a timer.
     */
    if ( !pTdIpx->AliveTime )
        return( STATUS_SUCCESS );

    /*
     *  Create watch dog
     */
    ASSERT( pTdIpx->pAliveTimer == NULL );
    Status = IcaTimerCreate( pTd->pContext, &pTdIpx->pAliveTimer );
    if ( !NT_SUCCESS(Status) )
        goto badtimer;

    /*
     *  Arm timer
     */
    _GetTimeoutValue( pTd, pTdIpx->AliveTime, &Timeout );
    IcaTimerStart( pTdIpx->pAliveTimer,
                   WatchDogTimer,
                   NULL,
                   Timeout,
                   ICALOCK_DRIVER );

badtimer:
    TRACE(( pTd->pContext, TC_TD, TT_API1, "TDIPX: InitializeWatchDog %u, Status=0x%x\n", Timeout, Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  _GetTimeoutValue
 *
 *  algorithm to calculate the poll timeout value
 *
 *
 * ENTRY:
 *    pTd (input)
 *       pointer to TD data structure
 *    PollTime (input)
 *       time gap between two pollings (msec)
 *    pTimeOut (output)
 *       timeout value for next poll (msec)
 *
 ******************************************************************************/

VOID
_GetTimeoutValue( PTD pTd, ULONG PollTime, PULONG pTimeOut )
{

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER Ticks;
    ULONG Time;
    ULONG Remain;

    KeQuerySystemTime( &CurrentTime );

    /* The currentTime is in 100nsec units and need convert to msec units. */

    Ticks = RtlExtendedLargeIntegerDivide( CurrentTime, 10000, &Remain );

    RtlExtendedLargeIntegerDivide( Ticks, PollTime, &Remain );

    *pTimeOut = PollTime - Remain;

    TRACE(( pTd->pContext, TC_TD, TT_API3, "TDIPX: _GetTimeoutValue %u -> %u\n",
             PollTime, *pTimeOut));
}


/*******************************************************************************
 *
 *  WatchDogTimer
 *
 *
 * ENTRY:
 *    pTd (input)
 *       pointer to TD data structure
 *    pParam (input)
 *       not used
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
WatchDogTimer( PTD pTd, PVOID pParam )
{
    ICA_CHANNEL_COMMAND Command;
    CHAR ptype;
    ULONG Timeout;
    BYTE  Buffer[1];
    NTSTATUS Status;
    PTDIPX pTdIpx;
    PTDTDI pTdTdi;
    PTD_ENDPOINT pEndpoint;

    /*
     * Get the connection endpoint for the remote system.
     * If there is none, then the endpoint must have been closed
     * so there is nothing to do.
     */
    pTdTdi = (PTDTDI)pTd->pAfd;
    if ( (pEndpoint = pTdTdi->pConnectionEndpoint) == NULL )
        return;
    ASSERT( pEndpoint->EndpointType == TdiConnectionDatagram );

    /*
     *  Get pointer to IPX structure
     */
    pTdIpx = (PTDIPX) pTd->pPrivate;
    ASSERT( pTdIpx );

    TRACE(( pTd->pContext, TC_TD, TT_API4, "TDIPX: WatchDogTimer\n" ));

    /*
     *  Get time for next watchdog event
     */
    _GetTimeoutValue( pTd, pTdIpx->AliveTime, &Timeout );

    /*
     *  Check if client has sent data recently
     */
    if ( pTdIpx->fClientAlive )
        goto clientok;

    /*
     *  Check the poll count
     */
    if ( pTdIpx->AlivePoll ) {

        TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TDIPX: no response for %u pings\n",
                pTdIpx->AlivePoll ));

        /*
         *  Check timeout retry count
         */
        if ( pTdIpx->AlivePoll > 6 ) {

            TRACE(( pTd->pContext, TC_TD, TT_ERROR, "TDIPX: client declared dead\n" ));

            /*
             *  Report broken connection
             */
            Command.Header.Command          = ICA_COMMAND_BROKEN_CONNECTION;
            Command.BrokenConnection.Reason = Broken_Unexpected;
    	    (void) IcaChannelInput( pTd->pContext,
    	                            Channel_Command,
    		                    0,
    		                    NULL,
                                    (PCHAR) &Command,
                                    sizeof(Command) );

            /*
             *  Do not re-arm timer
             */
            return;
        }

        /*
         *  Make timeout 10 seconds
         */
        Timeout = 10 * 1000;
    }

    /*
     *  Check for valid file object
     */
    if ( pTd->pFileObject == NULL )
        goto badopen;

    ObReferenceObject(pTd->pFileObject);        //Fix 416142

    /*
     * Set up the default packet send type to be control
     */
    ptype = IPX_TYPE_CONTROL;
    Status = _DoTdiAction( pTd->pFileObject, MIPX_SETSENDPTYPE, &ptype, 1 );
    ASSERT( Status == STATUS_SUCCESS );
    if ( !NT_SUCCESS( Status ) )
        goto badtype;

    /*
     *  Write ping to network
     */
    Buffer[0] = IPX_CTRL_PACKET_PING;

    Status = _TdiSendDatagram(
                 pTd,
		 NULL,   // Irp
		 pTd->pFileObject,
		 pTd->pDeviceObject,
                 pEndpoint->SendInfo.RemoteAddress,
		 pEndpoint->SendInfo.RemoteAddressLength,
		 Buffer,
		 1
		 );
    ASSERT( Status == STATUS_SUCCESS || Status == STATUS_CTX_CLOSE_PENDING );

    TRACEBUF(( pTd->pContext, TC_TD, TT_ORAW, Buffer, 1 ));

    /*
     *  Reset address endpoint to send data packets
     */
    ptype = IPX_TYPE_DATA;
    Status = _DoTdiAction( pTd->pFileObject, MIPX_SETSENDPTYPE, &ptype, 1 );
    ASSERT( Status == STATUS_SUCCESS );

    /*
     * Dereference the TDI file object and close the handle
     */

    ObDereferenceObject(pTd->pFileObject);        //Fix 416142

badtype:

    /*
     *  Increment counter
     */
    pTdIpx->AlivePoll++;

    /*
     *  Increment number of byte written
     */
    pTd->pStatus->Output.Bytes++;

    /*
     *  Reset alive bit
     */
clientok:
    pTdIpx->fClientAlive = FALSE;

    /*
     *  Re-arm timer
     */
badopen:
    IcaTimerStart( pTdIpx->pAliveTimer,
                   WatchDogTimer,
                   NULL,
                   Timeout,
                   ICALOCK_DRIVER );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdicom\tdtdi.h ===
/***************************************************************************
*
* tdtdi.h
*
* This module contains internal defines and structures for TDI based TDs.
*
* Copyright 1998 Microsoft
*  
*  
****************************************************************************/

typedef enum _ENDPOINT_TYPE {
    TdiAddressObject,
    TdiConnectionStream,
    TdiConnectionDatagram
} ENDPOINT_TYPE;

/*
 * TD stack endpoint structure.
 *
 * This is registered with ICADD.SYS to create a "handle" that can be returned
 * to ICASRV to represent a connection in a secure manner.
 */
typedef struct _TD_STACK_ENDPOINT {
    ULONG AddressType;              // Address type (family) for this endpoint
    struct _TD_ENDPOINT *pEndpoint; // Pointer to real endpoint structure
} TD_STACK_ENDPOINT, *PTD_STACK_ENDPOINT;

/*
 * TD endpoint structure
 *
 * This structure contains all information about an endpoint.
 * An endpoint may be either an address endpoint or a connection endpoint.
 */
typedef struct _TD_ENDPOINT {

    NTSTATUS Status;


    HANDLE TransportHandle;
    PEPROCESS TransportHandleProcess;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    UNICODE_STRING TransportName;
    PTRANSPORT_ADDRESS pTransportAddress;
    ULONG TransportAddressLength;
    PTRANSPORT_ADDRESS pRemoteAddress;
    ULONG RemoteAddressLength;
    ENDPOINT_TYPE EndpointType;

    // This protects the following fields
    KSPIN_LOCK Spinlock;

    // These fields are only used on Address endpoints
    LIST_ENTRY ConnectedQueue;
    LIST_ENTRY AcceptQueue;
    LIST_ENTRY ConnectionQueue;
    ULONG      ConnectionQueueSize;
    BOOLEAN    ConnectIndicationRegistered;
    BOOLEAN    DisconnectIndicationRegistered;
    BOOLEAN    RecvIndicationRegistered;
    KEVENT     AcceptEvent;
    BOOLEAN    Waiter;

    // This is used on Connection endpoints
    HANDLE hIcaHandle;      // Handle for TD_STACK_ENDPOINT
    BOOLEAN    Connected;
    BOOLEAN    Disconnected;
    PIRP       AcceptIrp;
    LIST_ENTRY ReceiveQueue;
    LIST_ENTRY ConnectionLink;
    TDI_CONNECTION_INFORMATION SendInfo;
    ULONG      RecvBytesReady;
    HANDLE hConnectionEndPointIcaHandle;  // handle for TD_ENDPOINT (this structure)
    HANDLE hTransportAddressIcaHandle;    // handle for TRANSPORT_ADDRESS

} TD_ENDPOINT, *PTD_ENDPOINT;


/*
 *  TDI TD structure
 */
typedef struct _TDTDI {

    PTD_ENDPOINT pAddressEndpoint;

    PTD_ENDPOINT pConnectionEndpoint;

     ULONG       OutBufDelay;  // Outbuf delay for connection

} TDTDI, * PTDTDI;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdnetb\tdnetb.h ===
/***************************************************************************
*
* tdnetb.h
*
* This module contains private Transport Driver defines and structures
*
* Copyright 1998, Microsoft
*  
****************************************************************************/

#define NETBIOS_KEY \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Netbios\\Linkage"

#define VOLATILE_COMPUTERNAME \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
#define NON_VOLATILE_COMPUTERNAME \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"

#define COMPUTERNAME_VALUE L"ComputerName"


typedef struct _LANA_MAP {
    BOOLEAN Enum;
    UCHAR Lana;
} LANA_MAP, *PLANA_MAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdspx\nwlana.c ===
#include "../tdipx/nwlana.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdnetb\tdnetb.c ===
/*************************************************************************
*
* tdnetb.c
*
* NETBIOS transport specific routines for TDI interface.
*
* Copyright 1998, Microsoft
*
*************************************************************************/

#include <ntddk.h>
#include <tdi.h>

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>
#include <td.h>

#include "tdtdi.h"
#include "tdnetb.h"

#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdnetb";
#endif


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS TdiDeviceOpen( PTD, PSD_OPEN );
NTSTATUS TdiDeviceClose( PTD, PSD_CLOSE );
NTSTATUS TdiDeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS TdiDeviceBuildTransportNameAndAddress( PTD, PICA_STACK_ADDRESS,
                                                PUNICODE_STRING,
                                                PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceBuildWildcardAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceWaitForDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT,
                                             PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceCompleteDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS TdiDeviceConnectionSend( PTD );
NTSTATUS TdiDeviceReadComplete( PTD, PUCHAR, PULONG );


/*=============================================================================
==   External Functions Referenced
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _NetBiosGetTransportName( PTD, LONG, PUNICODE_STRING );
NTSTATUS _GetComputerName( PTD, PUNICODE_STRING );
VOID GetGUID( PUNICODE_STRING ,int);

NTSTATUS
_OpenRegKey(
    PHANDLE HandlePtr,
    PWCHAR KeyName
    );

NTSTATUS
_GetRegDWORDValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PULONG ValueData
    );

NTSTATUS
_GetRegStringValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT ValueSize
    );

NTSTATUS
_GetRegMultiSZValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PUNICODE_STRING ValueData
    );

NTSTATUS
_GetRegSZValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PUNICODE_STRING ValueData,
    PULONG ValueType
    );

PWCHAR
_EnumRegMultiSz(
    PWCHAR MszString,
    ULONG MszStringLength,
    ULONG StringIndex
    );



/*=============================================================================
==   Global variables
=============================================================================*/

/*
 * Define variables used by tdicommon code
 */
USHORT TdiDeviceEndpointType = TdiConnectionStream;
USHORT TdiDeviceAddressType = TDI_ADDRESS_TYPE_NETBIOS;
USHORT TdiDeviceInBufHeader = 0;
// ULONG TdiDeviceMaxTransportAddressLength = sizeof(TA_NETBIOS_ADDRESS);


/*******************************************************************************
 *
 * TdiDeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpen( PTD pTd, PSD_OPEN pSdOpen )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the current connection endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceClose( PTD pTd, PSD_CLOSE pSdClose )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpenEndpoint(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG IcaEndpointLength
    )
{
    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildTransportNameAndAddress
 *
 *  Build the Transport Name and Address given an optional ICA_STACK_ADDRESS,
 *  or the Lana value from the pTd->Params structure.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pLocalAddress (input)
 *     pointer to local address to use (OPTIONAL)
 *   pTransportName (output)
 *     pointer to UNICODE_STRING to return transport name
 *     NOTE: the buffer pointed to be pTransportName->Buffer must
 *           be free'd by the caller
 *   ppTransportAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pTransportAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildTransportNameAndAddress(
    PTD pTd,
    PICA_STACK_ADDRESS pLocalAddress,
    PUNICODE_STRING pTransportName,
    PTRANSPORT_ADDRESS *ppTransportAddress,
    PULONG pTransportAddressLength
    )
{
    PTDI_ADDRESS_NETBIOS pNetbiosAddress;
    PWCHAR pComputerName;
    NTSTATUS Status;

    /*
     * For NetBios, the transport device name is determined from
     * the specified LanAdapter (Lana) number.
     */
    Status = _NetBiosGetTransportName( pTd, pTd->Params.Network.LanAdapter,
                                       pTransportName );
    if ( !NT_SUCCESS( Status ) )
        goto badtransportname;

    /*
     * Allocate a transport address structure
     */
    *pTransportAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_NETBIOS);
    Status = MemoryAllocate( *pTransportAddressLength, ppTransportAddress );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc;

    /*
     * Initialize the static part of the transport address
     */
    (*ppTransportAddress)->TAAddressCount = 1;
    (*ppTransportAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    (*ppTransportAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)(*ppTransportAddress)->Address[0].Address;

    /*
     * If a local address is specified, then use it.
     */
    if ( pLocalAddress ) {

        /*
         * Skip over the address family(type) data (bytes 0&1) of the
         * local address struct, and copy the remainder of the address
         * directly to the Address field of the TransportAddress struct.
         */
        ASSERT( *(PUSHORT)pLocalAddress == TDI_ADDRESS_TYPE_NETBIOS );
        RtlCopyMemory( pNetbiosAddress, &((PCHAR)pLocalAddress)[2], sizeof(TDI_ADDRESS_NETBIOS) );

    /*
     * There was no local address specified.
     * Use the local ComputerName to build the NetBios name.
     */
    } else {
        ANSI_STRING ansiString;
        UNICODE_STRING unicodeString;

        Status = _GetComputerName( pTd, &unicodeString );
        if ( !NT_SUCCESS( Status ) )
            goto badcomputername;
        pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        /*
         * Now convert ComputerName from unicode to ansi and
         * store it in the NetBios name field of the transport address.
         */
        ansiString.Length = 0;
        ansiString.MaximumLength = sizeof(pNetbiosAddress->NetbiosName);
        ansiString.Buffer = pNetbiosAddress->NetbiosName;
        RtlUnicodeStringToAnsiString( &ansiString, &unicodeString, FALSE );
        RtlFillMemory( &pNetbiosAddress->NetbiosName[ansiString.Length],
                       sizeof(pNetbiosAddress->NetbiosName) - ansiString.Length,
                       '.' );
        pNetbiosAddress->NetbiosName[15] = '\0';
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badcomputername:
    MemoryFree( *ppTransportAddress );

badmalloc:
    MemoryFree( pTransportName->Buffer );

badtransportname:
    return( Status );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildWildcardAddress
 *
 *  Build a wildcard Address for this protocol.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   ppWildcardAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pWildcardAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildWildcardAddress(
    PTD pTd,
    PTRANSPORT_ADDRESS *ppWildcardAddress,
    PULONG pWildcardAddressLength
    )
{
    PTDI_ADDRESS_NETBIOS pNetbiosAddress;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    PWCHAR pComputerName;
    NTSTATUS Status;

    /*
     * Allocate a transport address structure
     */
    *pWildcardAddressLength = sizeof(TRANSPORT_ADDRESS) +
                              sizeof(TDI_ADDRESS_NETBIOS);
    Status = MemoryAllocate( *pWildcardAddressLength, ppWildcardAddress );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Initialize the static part of the transport address
     */
    (*ppWildcardAddress)->TAAddressCount = 1;
    (*ppWildcardAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    (*ppWildcardAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_NETBIOS;
    pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)(*ppWildcardAddress)->Address[0].Address;
    pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_GROUP;
    RtlZeroMemory( pNetbiosAddress->NetbiosName,
                   sizeof(pNetbiosAddress->NetbiosName) );

    Status = _GetComputerName( pTd, &unicodeString );
    if ( !NT_SUCCESS( Status ) ) {
        MemoryFree( *ppWildcardAddress );
        return( Status );
    }

    /*
     * Now convert ComputerName from unicode to ansi and
     * store it in the NetBios name field of the transport address.
     */
    ansiString.Length = 0;
    ansiString.MaximumLength = sizeof(pNetbiosAddress->NetbiosName);
    ansiString.Buffer = pNetbiosAddress->NetbiosName;
    RtlUnicodeStringToAnsiString( &ansiString, &unicodeString, FALSE );
#ifdef notdef
    RtlFillMemory( &pNetbiosAddress->NetbiosName[ansiString.Length],
                   sizeof(pNetbiosAddress->NetbiosName) - ansiString.Length,
                   '.' );
    pNetbiosAddress->NetbiosName[15] = '\0';
#endif

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceWaitForDatagramConnection
 *
 *  Wait for a datagram connection request, validate it,
 *  and return the remote transport address of the connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object to wait for a connection on
 *   ppRemoteAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pRemoteAddressLength (output)
 *     pointer to location to return RemoteAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceWaitForDatagramConnection(
    PTD pTd,
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS *ppRemoteAddress,
    PULONG pRemoteAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*****************************************************************************
 *
 *  TdiDeviceCompleteDatagramConnection
 *
 *  Do any final work to complete a datagram connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object for this connection
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceCompleteDatagramConnection(
    PTD pTd,
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS pTransportAddress,
    ULONG TransportAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*******************************************************************************
 *
 *  TdiDeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceConnectionSend( PTD pTd )
{
    PCLIENTMODULES pClient;

    /*
     *  Get pointer to client structure
     */
    pClient = pTd->pClient;

    /*
     *  Initialize Td host module structure
     */
    pClient->TdVersionL = VERSION_HOSTL_TDNETB;
    pClient->TdVersionH = VERSION_HOSTH_TDNETB;
    pClient->TdVersion  = VERSION_HOSTH_TDNETB;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  TdiDeviceReadComplete
 *
 *  Do any read complete processing
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location containing byte count read
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceReadComplete( PTD pTd, PUCHAR pBuffer, PULONG pByteCount )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _NetBiosGetTransportName
 *
 *  Read netbios registry entries to find the transport device name
 *  for the specified LanAdapter number.
 *
 *  ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    Lana (input)
 *       Lan Adapter number
 *    pTransportName (output)
 *       pointer to UNICODE_STRING to return transport name
 *       NOTE: the buffer pointed to be pTransportName->Buffer must
 *             be free'd by the caller
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

#if 0
NTSTATUS
_NetBiosGetTransportName(
    PTD pTd,
    LONG Lana,
    PUNICODE_STRING pTransportName
    )
{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE netbiosKey = NULL;
    ULONG providerListLength;
    PKEY_VALUE_PARTIAL_INFORMATION pProviderNameInfo = NULL;
    ULONG lanaMapLength;
    PKEY_VALUE_PARTIAL_INFORMATION pLanaMapInfo = NULL;
    PLANA_MAP pLanaMap;
    int ProviderCount;
    int i;
    PWSTR currentProviderName;
    NTSTATUS Status;

    //
    // Read the registry for information on all Netbios providers,
    // including Lana numbers, protocol numbers, and provider device
    // names.  First, open the Netbios key in the registry.
    //
    RtlInitUnicodeString( &nameString, NETBIOS_KEY );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    Status = ZwOpenKey( &netbiosKey, KEY_READ, &objectAttributes );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    //
    // Determine the size of the provider names.  We need this so
    // that we can allocate enough memory to hold it.
    //
    providerListLength = 0;
    RtlInitUnicodeString( &nameString, L"Bind" );
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              NULL,
                              0,
                              &providerListLength
                              );
    if ( Status != STATUS_BUFFER_TOO_SMALL )
        return( Status );

    //
    // Allocate enough memory to hold the mapping.
    //
    Status = MemoryAllocate( providerListLength, &pProviderNameInfo );
    if ( !NT_SUCCESS( Status ) )
        goto error_exit;

    //
    // Get the list of transports from the registry.
    //
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              pProviderNameInfo,
                              providerListLength,
                              &providerListLength
                              );
    if ( !NT_SUCCESS( Status ) ) {
        MemoryFree( pProviderNameInfo );
        return( Status );
    }


    //
    // Determine the size of the Lana map.  We need this so that we
    // can allocate enough memory to hold it.
    //
    lanaMapLength = 0;
    RtlInitUnicodeString( &nameString, L"LanaMap" );
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              NULL,
                              0,
                              &lanaMapLength
                              );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        MemoryFree( pProviderNameInfo );
        return( Status );
    }

    //
    // Allocate enough memory to hold the Lana map.
    //
    Status = MemoryAllocate( lanaMapLength, &pLanaMapInfo );
    if ( !NT_SUCCESS( Status ) )
        goto error_exit;

    //
    // Get the list of transports from the registry.
    //
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              pLanaMapInfo,
                              lanaMapLength,
                              &lanaMapLength
                              );
    if ( !NT_SUCCESS( Status ) ) {
        MemoryFree( pLanaMapInfo );
        MemoryFree( pProviderNameInfo );
        return( Status );
    }

    //
    // Determine the number of Netbios providers loaded on the system.
    //
    ProviderCount = (int) (lanaMapLength / sizeof(LANA_MAP));

    //
    // Fill in the array of provider information.
    //
    Status = STATUS_DEVICE_DOES_NOT_EXIST;
    pLanaMap = (PLANA_MAP)pLanaMapInfo->Data;
    for ( currentProviderName = (PWSTR)pProviderNameInfo->Data, i = 0;
          *currentProviderName != UNICODE_NULL && i < ProviderCount;
          currentProviderName += wcslen( currentProviderName ) + 1, i++ ) {

        if ( pLanaMap[i].Lana == Lana && pLanaMap[i].Enum ) {
            pTransportName->Length = wcslen( currentProviderName ) *
                                     sizeof(UNICODE_NULL);
            pTransportName->MaximumLength = pTransportName->Length +
                                            sizeof(UNICODE_NULL);
            Status = MemoryAllocate( pTransportName->MaximumLength,
                                     &pTransportName->Buffer );
            if ( !NT_SUCCESS( Status ) )
                break;
            wcscpy( pTransportName->Buffer, currentProviderName );
            Status = STATUS_SUCCESS;
            break;
        }
    }

    MemoryFree( pLanaMapInfo );

    MemoryFree( pProviderNameInfo );

    ZwClose( netbiosKey );

    return( Status );

/*=============================================================================
==   Error returns
=============================================================================*/

error_exit:

    if ( netbiosKey != NULL ) {
        ZwClose( netbiosKey );
    }

    if ( pProviderNameInfo != NULL ) {
        MemoryFree( pProviderNameInfo );
    }

    if ( pLanaMapInfo != NULL ) {
        MemoryFree( pLanaMapInfo );
    }

    return( Status );
}
#endif

NTSTATUS
_NetBiosGetTransportName(
    PTD pTd,
    LONG Lana,
    PUNICODE_STRING pTransportName
    )
{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE netbiosKey = NULL;
    ULONG providerListLength;
    PKEY_VALUE_PARTIAL_INFORMATION pProviderNameInfo = NULL;
    int ProviderCount;
    ULONG lanaMapLength;
    PKEY_VALUE_PARTIAL_INFORMATION pLanaMapInfo = NULL;
    PLANA_MAP pLanaMap;
    int i;
    USHORT Len;
    PWSTR currentProviderName;
    NTSTATUS Status;

    UNICODE_STRING RouteString;
    PWCHAR GUIDStr;

    RtlInitUnicodeString( &RouteString , NULL );

    GetGUID( &RouteString , Lana );

    Len = RouteString.Length;
    GUIDStr = RouteString.Buffer;

    if (Len < (2 * sizeof(UNICODE_NULL))) 
    {
        // The GUID not present - That means the device no longer exists

        Status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto error_exit;
    }

    //
    // Read the registry for information on all Netbios providers,
    // including Lana numbers, protocol numbers, and provider device
    // names.  First, open the Netbios key in the registry.
    //
    RtlInitUnicodeString( &nameString, NETBIOS_KEY );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    Status = ZwOpenKey( &netbiosKey, KEY_READ, &objectAttributes );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    //
    // Determine the size of the provider names.  We need this so
    // that we can allocate enough memory to hold it.
    //
    providerListLength = 0;
    RtlInitUnicodeString( &nameString, L"Bind" );
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              NULL,
                              0,
                              &providerListLength
                              );
    if ( Status != STATUS_BUFFER_TOO_SMALL )
        return( Status );

    //
    // Allocate enough memory to hold the mapping.
    //
    Status = MemoryAllocate( providerListLength, &pProviderNameInfo );
    if ( !NT_SUCCESS( Status ) )
        goto error_exit;

    //
    // Get the list of transports from the registry.
    //
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              pProviderNameInfo,
                              providerListLength,
                              &providerListLength
                              );
    if ( !NT_SUCCESS( Status ) ) {
        MemoryFree( pProviderNameInfo );
        return( Status );
    }

    //
    // Determine the size of the Lana map.  We need this so that we
    // can allocate enough memory to hold it.
    //
    lanaMapLength = 0;
    RtlInitUnicodeString( &nameString, L"LanaMap" );
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              NULL,
                              0,
                              &lanaMapLength
                              );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        MemoryFree( pProviderNameInfo );
        return( Status );
    }

    //
    // Allocate enough memory to hold the Lana map.
    //
    Status = MemoryAllocate( lanaMapLength, &pLanaMapInfo );
    if ( !NT_SUCCESS( Status ) )
        goto error_exit;

    //
    // Get the list of transports from the registry.
    //
    Status = ZwQueryValueKey( netbiosKey,
                              &nameString,
                              KeyValuePartialInformation,
                              pLanaMapInfo,
                              lanaMapLength,
                              &lanaMapLength
                              );
    if ( !NT_SUCCESS( Status ) ) {
        MemoryFree( pLanaMapInfo );
        MemoryFree( pProviderNameInfo );
        return( Status );
    }

    //
    // Determine the number of Netbios providers loaded on the system.
    //
    ProviderCount = (int) (lanaMapLength / sizeof(LANA_MAP));

    //
    // Fill in the array of provider information.
    //
    Status = STATUS_DEVICE_DOES_NOT_EXIST;
    pLanaMap = (PLANA_MAP)pLanaMapInfo->Data;

    Len = Len/sizeof(WCHAR);  // convert length from bytes to WCHARs

#if 0
    DbgPrint("GUIDStr=%ws, Len=%d\n",GUIDStr, Len);
#endif

    for ( currentProviderName = (PWSTR)pProviderNameInfo->Data, i = 0;
          *currentProviderName != UNICODE_NULL && i < ProviderCount;
          currentProviderName += wcslen( currentProviderName ) + 1, i++ ) {

#if 0
        DbgPrint("currentProviderName: %ws\n",currentProviderName);
        DbgPrint("i=%d, pLanaMap.Enum=%d\n", i, pLanaMap[i].Enum);
        DbgPrint("wcscmp str=%ws\n",currentProviderName+wcslen(currentProviderName)-Len);
#endif
        if ((pLanaMap[i].Enum) && 
            (Len <=wcslen(currentProviderName)) && 
            (!wcsncmp((currentProviderName+wcslen(currentProviderName)-Len), GUIDStr, Len))) 
        {
            pTransportName->Length = wcslen( currentProviderName ) *
                                     sizeof(UNICODE_NULL);
            pTransportName->MaximumLength = pTransportName->Length +
                                            sizeof(UNICODE_NULL);
            Status = MemoryAllocate( pTransportName->MaximumLength,
                                     &pTransportName->Buffer );
            if ( !NT_SUCCESS( Status ) )
                break;
            wcscpy( pTransportName->Buffer, currentProviderName );
            Status = STATUS_SUCCESS;
            break;
        }
    }

    MemoryFree( pLanaMapInfo );

    MemoryFree( pProviderNameInfo );

    ZwClose( netbiosKey );

    return( Status );

/*=============================================================================
==   Error returns
=============================================================================*/

error_exit:

    if ( netbiosKey != NULL ) {
        ZwClose( netbiosKey );
    }

    if ( pProviderNameInfo != NULL ) {
        MemoryFree( pProviderNameInfo );
    }

    if ( pLanaMapInfo != NULL ) {
        MemoryFree( pLanaMapInfo );
    }

    return( Status );
}



/*******************************************************************************
 *
 *  _GetComputerName
 *
 *  Read computer name from the registry
 *
 *  ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pComputerName (output)
 *       pointer to UNICODE_STRING to return computer name
 *       NOTE: the buffer pointed to be pComputerName->Buffer must
 *             be free'd by the caller
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_GetComputerName(
    PTD pTd,
    PUNICODE_STRING pComputerName
    )
{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hKey;
    WCHAR ComputerNameBuffer[256];
    PKEY_VALUE_PARTIAL_INFORMATION pComputerNameInfo;
    ULONG returnLength;
    NTSTATUS Status;

    /*
     * Try to open the ActiveComputerName key.
     * If this fails, attempt to open the static key.
     */
    RtlInitUnicodeString( &nameString, VOLATILE_COMPUTERNAME );
    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );
    Status = ZwOpenKey( &hKey, KEY_READ, &objectAttributes );
    if ( !NT_SUCCESS( Status ) ) {
        RtlInitUnicodeString( &nameString, NON_VOLATILE_COMPUTERNAME );
        InitializeObjectAttributes( &objectAttributes,
                                    &nameString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );
        Status = ZwOpenKey( &hKey, KEY_READ, &objectAttributes );
    }
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Now get the ComputerName value
     */
    RtlInitUnicodeString( &nameString, COMPUTERNAME_VALUE );
    Status = ZwQueryValueKey( hKey,
                              &nameString,
                              KeyValuePartialInformation,
                              ComputerNameBuffer,
                              sizeof(ComputerNameBuffer),
                              &returnLength
                              );
    ZwClose( hKey );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Allocate a buffer to return the ComputerName string,
     * initialize the return unicode string, and copy the computer name.
     */
    pComputerNameInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ComputerNameBuffer;
    Status = MemoryAllocate( pComputerNameInfo->DataLength,
                             &pComputerName->Buffer );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    RtlCopyMemory( pComputerName->Buffer, pComputerNameInfo->Data,
                   pComputerNameInfo->DataLength );
    pComputerName->Length =
        pComputerName->MaximumLength =
            (USHORT)(pComputerNameInfo->DataLength - sizeof(UNICODE_NULL));

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdspx\tdspx.h ===
/***************************************************************************
*
* tdspx.h
*
* This module contains private Transport Driver defines and structures
*
* Copyright 1998, Microsoft
*  
****************************************************************************/


#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))


/*
 * Well known Citrix SPX socket
 */
// #define CITRIX_SPX_SOCKET 0x85BA    // registered Novell socket number
#define CITRIX_SPX_SOCKET 0x1090    // old winview socket


#define DD_IPX_DEVICE_NAME L"\\Device\\NwlnkIpx"
#define DD_SPX_DEVICE_NAME L"\\Device\\NwlnkSpx\\SpxStream"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdpipe\tdpipe.h ===
/***************************************************************************
*
* tdpipe.h
*
* This module contains internal defines and structures for the named pipe TD.
*
* Copyright 1998, Microsoft
*  
****************************************************************************/


/*
 * TD stack endpoint structure
 *
 * This structure is passed on the stack
 */
typedef struct _TD_STACK_ENDPOINT {
//  ULONG AddressType;              // Address type (family) for this endpoint
    struct _TD_ENDPOINT *pEndpoint; // Pointer to real endpoint structure
} TD_STACK_ENDPOINT, *PTD_STACK_ENDPOINT;


/*
 * TD endpoint structure
 *
 * This structure contains all information about an endpoint.
 * An endpoint may be either an address endpoint or a connection endpoint.
 */
typedef struct _TD_ENDPOINT {

    HANDLE PipeHandle;
    PEPROCESS PipeHandleProcess;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    UNICODE_STRING PipeName;
    HANDLE hConnectionEndPointIcaHandle;  // handle for TD_ENDPOINT (this structure)

} TD_ENDPOINT, *PTD_ENDPOINT;


/*
 *  PIPE TD structure
 */
typedef struct _TDPIPE {

    PTD_ENDPOINT pAddressEndpoint;

    PTD_ENDPOINT pConnectionEndpoint;

    IO_STATUS_BLOCK IoStatus;

} TDPIPE, * PTDPIPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdspx\tdspx.c ===
/*************************************************************************
*
* tdspx.c
*
* Copyright 1998, Microsoft
*  
*************************************************************************/

#include <ntddk.h>
#include <tdi.h>

#include <isnkrnl.h>
#include <ndis.h>
#include <wsnwlink.h>

#include <winstaw.h>
#define _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>
#include <td.h>

#include "tdtdi.h"
#include "tdspx.h"

#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdspx";
#endif

#define REG_IPX_Linkage \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NwlnkIpx\\Linkage"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS TdiDeviceOpen( PTD, PSD_OPEN );
NTSTATUS TdiDeviceClose( PTD, PSD_CLOSE );
NTSTATUS TdiDeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS TdiDeviceBuildTransportNameAndAddress( PTD, PICA_STACK_ADDRESS,
                                                PUNICODE_STRING,
                                                PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceBuildWildcardAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceWaitForDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT,
                                             PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceCompleteDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS TdiDeviceConnectionSend( PTD );
NTSTATUS TdiDeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS _OpenRegKey(PHANDLE, PWCHAR);
NTSTATUS _GetRegMultiSZValue(HANDLE ,PWCHAR,PUNICODE_STRING );
VOID     GetGUID(OUT PUNICODE_STRING, IN  int);


/*=============================================================================
==   External Functions Referenced
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _IpxGetTransportAddress( PTD, int, PULONG, PUCHAR );
NTSTATUS _IPXGetAdapterNumber( int Lana, int * AdpNum );

#if DBG
VOID
DumpIpxAddress(
    PTRANSPORT_ADDRESS p,
    ULONG Len
    );
#endif

/*=============================================================================
==   Global variables
=============================================================================*/

/*
 * Define variables used by afdcommon code
 */
USHORT TdiDeviceEndpointType = TdiConnectionStream;
USHORT TdiDeviceAddressType = TDI_ADDRESS_TYPE_IPX;
USHORT TdiDeviceInBufHeader = 0;
// ULONG TdiDeviceMaxTransportAddressLength = sizeof(TA_IPX_ADDRESS);


/*******************************************************************************
 *
 * TdiDeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpen( PTD pTd, PSD_OPEN pSdOpen )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the current connection endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceClose( PTD pTd, PSD_CLOSE pSdClose )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpenEndpoint(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG IcaEndpointLength
    )
{
    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildTransportNameAndAddress
 *
 *  Build the Transport Name and Address given an optional ICA_STACK_ADDRESS,
 *  or the Lana value from the pTd->Params structure.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pLocalAddress (input)
 *     pointer to local address to use (OPTIONAL)
 *   pTransportName (output)
 *     pointer to UNICODE_STRING to return transport name
 *     NOTE: the buffer pointed to be pTransportName.Buffer must
 *           be free'd by the caller
 *   ppTransportAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pTransportAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildTransportNameAndAddress(
    PTD pTd,
    PICA_STACK_ADDRESS pLocalAddress,
    PUNICODE_STRING pTransportName,
    PTRANSPORT_ADDRESS *ppTransportAddress,
    PULONG pTransportAddressLength
    )
{
    PTDI_ADDRESS_IPX pIpxAddress;
    int Lana;
    NTSTATUS Status;

    /*
     * For SPX, the transport device name is fixed,
     * so just allocate and initialize the transport name string here.
     */
    Status = MemoryAllocate( sizeof(DD_SPX_DEVICE_NAME), &pTransportName->Buffer );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("TdiDeviceBuildTransportNameAndAddress: SPX Could not allocate memory\n"));
	goto badmalloc1;
    }
    wcscpy( pTransportName->Buffer, DD_SPX_DEVICE_NAME );
    pTransportName->Length = sizeof(DD_SPX_DEVICE_NAME) - sizeof(UNICODE_NULL);
    pTransportName->MaximumLength = pTransportName->Length + sizeof(UNICODE_NULL);

    /*
     * Allocate a transport address structure
     */
    *pTransportAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IPX);
    Status = MemoryAllocate( *pTransportAddressLength, ppTransportAddress );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("TdiDeviceBuildTransportNameAndAddress: SPX Could not allocate memory\n"));
        goto badmalloc2;
    }

    /*
     * Initialize the static part of the transport address
     */
    (*ppTransportAddress)->TAAddressCount = 1;
    (*ppTransportAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    (*ppTransportAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    pIpxAddress = (PTDI_ADDRESS_IPX)(*ppTransportAddress)->Address[0].Address;
    pIpxAddress->Socket = htons( CITRIX_SPX_SOCKET );

    /*
     * If a local address is specified, then use it.
     */
    if ( pLocalAddress ) {

        /*
         * Skip over the address family(type) data (bytes 0&1) of the
         * local address struct, and copy the remainder of the address
         * directly to the Address field of the TransportAddress struct.
         */
        ASSERT( *(PUSHORT)pLocalAddress == TDI_ADDRESS_TYPE_IPX );
        RtlCopyMemory( pIpxAddress, &((PCHAR)pLocalAddress)[2], sizeof(TDI_ADDRESS_IPX) );

	TRACE1(("TDSPX: TdiDeviceBuildTransportAddress: Local address:\n"));

    /*
     * There was no local address specified.
     * In this case, we use the LanAdapter value from the PDPARAMS
     * structure to lookup the corresponding IPX address.
     */
    } else if ( (Lana = pTd->Params.Network.LanAdapter) ) {

        /*
         * Get Local Address Information
         */
        Status = _IpxGetTransportAddress( pTd, Lana,
                                          &pIpxAddress->NetworkAddress,
                                          pIpxAddress->NodeAddress );
        if ( !NT_SUCCESS( Status ) ) {
	    DBGPRINT(("TDSPX: TdiDeviceBuildTransportAddress: Bad Lana 0x%x\n",Lana));
	    goto badadapterdata;
        }

	TRACE1(("TDSPX: TdiDeviceBuildTransportAddress: Found address for Lana 0x%x\n",Lana));

    /*
     * No LanAdapter value was specified, so use the wildcard address (zero)
     */
    } else {
	DBGPRINT(("TDSPX: TdiDeviceBuildTransportAddress: Wildcard address"));
        pIpxAddress->NetworkAddress = 0;
        RtlZeroMemory( pIpxAddress->NodeAddress,
                       sizeof(pIpxAddress->NodeAddress) );
    }

#if DBGTRACE
    DumpIpxAddress( *ppTransportAddress, *pTransportAddressLength );
#endif

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badadapterdata:
    MemoryFree( *ppTransportAddress );

badmalloc2:
    MemoryFree( pTransportName->Buffer );

badmalloc1:
    return( Status );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildWildcardAddress
 *
 *  Build a wildcard Address for this protocol.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   ppWildcardAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pWildcardAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildWildcardAddress(
    PTD pTd,
    PTRANSPORT_ADDRESS *ppWildcardAddress,
    PULONG pWildcardAddressLength
    )
{
    PTDI_ADDRESS_IPX pIpxAddress;
    NTSTATUS Status;

    /*
     * Allocate a transport address structure
     */
    *pWildcardAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IPX);
    Status = MemoryAllocate( *pWildcardAddressLength, ppWildcardAddress );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Initialize the static part of the transport address
     */
    (*ppWildcardAddress)->TAAddressCount = 1;
    (*ppWildcardAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IPX);
    (*ppWildcardAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IPX;
    pIpxAddress = (PTDI_ADDRESS_IPX)(*ppWildcardAddress)->Address[0].Address;
    pIpxAddress->NetworkAddress = 0;
    RtlZeroMemory( pIpxAddress->NodeAddress,
                   sizeof(pIpxAddress->NodeAddress) );
    pIpxAddress->Socket = 0;

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceWaitForDatagramConnection
 *
 *  Wait for a datagram connection request, validate it,
 *  and return the remote transport address of the connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object to wait for a connection on
 *   ppRemoteAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pRemoteAddressLength (output)
 *     pointer to location to return RemoteAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceWaitForDatagramConnection(
    PTD pTd,
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS *ppRemoteAddress,
    PULONG pRemoteAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*****************************************************************************
 *
 *  TdiDeviceCompleteDatagramConnection
 *
 *  Do any final work to complete a datagram connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object for this connection
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceCompleteDatagramConnection(
    PTD pTd, 
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS pTransportAddress,
    ULONG TransportAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*******************************************************************************
 *
 *  TdiDeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceConnectionSend( PTD pTd )
{
    PCLIENTMODULES pClient;

    /*
     *  Get pointer to client structure
     */
    pClient = pTd->pClient;

    /*
     *  Initialize Td host module structure
     */
    pClient->TdVersionL = VERSION_HOSTL_TDSPX;
    pClient->TdVersionH = VERSION_HOSTH_TDSPX;
    pClient->TdVersion  = VERSION_HOSTH_TDSPX;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  TdiDeviceReadComplete
 *
 *  Do any read complete processing
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location containing byte count read
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceReadComplete( PTD pTd, PUCHAR pBuffer, PULONG pByteCount )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _IpxGetTransportAddress
 *
 *  Get IPX transport address for a given LanAdapter number
 *
 *
 *  ENTRY:
 *     pTd (input)
 *        pointer to TD data structure
 *     Lana (input)
 *        Lan Adapter number
 *     pNetworkAddress (output)
 *        pointer to location to return NetworkAddress
 *     pNodeAddress (output)
 *        pointer to location to return NodeAddress
 *
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_IpxGetTransportAddress(
    PTD pTd,
    int Lana,
    PULONG pNetworkAddress,
    PUCHAR pNodeAddress
    )
{
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    UNICODE_STRING nameString;
    HANDLE IPXHandle;
    ULONG tdiBufferLength;
    PSTREAMS_TDI_ACTION tdiBuffer;
    ULONG cmd;
    PIPX_ADDRESS_DATA pIpxAddressData;
    PFILE_OBJECT pFileObject;
    NTSTATUS Status;
    int IpxAdapterNum = 0;
    /*
     * Open a Handle to the IPX driver.
     */
    RtlInitUnicodeString( &nameString, DD_IPX_DEVICE_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    Status = ZwCreateFile( &IPXHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &objectAttributes,
                           &ioStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0
                           );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Allocate a TDI buffer to do the IOCTL.
     */
    tdiBufferLength = sizeof(STREAMS_TDI_ACTION) + sizeof(ULONG) +
                      sizeof(IPX_ADDRESS_DATA);
    Status = MemoryAllocate( tdiBufferLength, &tdiBuffer );
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( IPXHandle );
        return( Status );
    }

    // Get IPX Adapter Num from winstation Lana ID

    
    Status = _IPXGetAdapterNumber( Lana, &IpxAdapterNum);
    if ( !NT_SUCCESS( Status ) ) {
        ZwClose( IPXHandle );
        return( Status );
    } 

    /*
     * Fill in the tdiBuffer header
     */
    RtlMoveMemory( &tdiBuffer->Header.TransportId, "MISN", 4 );
    // use the following since we opened a control channel above
    tdiBuffer->DatagramOption = NWLINK_OPTION_CONTROL;

    /**
       Fill out the buffer, the buffer looks like this:

       ULONG cmd
       data passed.
    **/

    cmd = MIPX_GETCARDINFO;
    memcpy( tdiBuffer->Buffer, &cmd, sizeof(ULONG));


    tdiBuffer->BufferLength = sizeof(ULONG) + sizeof(IPX_ADDRESS_DATA);

    pIpxAddressData = (PIPX_ADDRESS_DATA)(tdiBuffer->Buffer + sizeof(ULONG));
    pIpxAddressData->adapternum = IpxAdapterNum;

    Status = ObReferenceObjectByHandle( IPXHandle,
                                        0,
                                        NULL,
                                        KernelMode,
                                        (PVOID *)&pFileObject,
                                        NULL
                                        );
    ASSERT( Status == STATUS_SUCCESS );

    Status = CtxDeviceIoControlFile( pFileObject,
                                     IOCTL_TDI_ACTION,
                                     NULL,
                                     0,
                                     tdiBuffer,
                                     tdiBufferLength,
                                     FALSE,
                                     NULL,
                                     &ioStatusBlock,
                                     NULL
                                     );
    ObDereferenceObject( pFileObject );

    ZwClose( IPXHandle );

    if ( Status == STATUS_SUCCESS ) {
        RtlCopyMemory( pNetworkAddress, pIpxAddressData->netnum, 
                       sizeof(pIpxAddressData->netnum) );
        RtlCopyMemory( pNodeAddress, pIpxAddressData->nodenum, 
                       sizeof(pIpxAddressData->nodenum) );
    }
    
    return( Status );
}

#if DBG
VOID
DumpIpxAddress(
    PTRANSPORT_ADDRESS p,
    ULONG Len
    )
{
    ULONG j;
    LONG i;
    PTDI_ADDRESS_IPX Ipx;

    DbgPrint("TAAddressCount %d, TotalLen %d\n",p->TAAddressCount,Len);

    for( i=0; i < p->TAAddressCount; i++ ) {

        DbgPrint("AddressLength %d, AddressType %d\n",p->Address[i].AddressLength,p->Address[i].AddressType);

        Ipx = (PTDI_ADDRESS_IPX)&p->Address[i].Address[0];

	DbgPrint("Network 0x%x Socket 0x%x\n",Ipx->NetworkAddress,Ipx->Socket);

	for( j=0; j < 6; j++ ) {
            DbgPrint("%x:",Ipx->NodeAddress[j]);
        }
        DbgPrint("\n\n");
    }
}
#endif



NTSTATUS
_IPXGetAdapterNumber(
    int Lana,
    int * AdpNum 
    )
/*++
Routine Description:

    Get the IPX Lan Adapter number using the instation Lana ID index
    
Arguments:
    
    Lana   - IN the winstation Lana ID index
    AdpNum - OUT the IPX Lana Adapter num

Return Value:

    return nt status

--*/
{

    NTSTATUS Status;
    int  AdapterNum;
    UNICODE_STRING RouteString;
    UNICODE_STRING NameString;
    
    HANDLE KeyHandle = NULL;        
    PWSTR  RouteStr, Str;
    unsigned RouteLen, Len;
    


    /* 
     * Convert winstation Lana_ID to Network Adapter number
     */    

    
    RtlInitUnicodeString( &RouteString , NULL );
    GetGUID( &RouteString , Lana );
    RouteLen = RouteString.Length;    
    RouteStr = RouteString.Buffer;
    AdapterNum =0;
    
#if DBG
    KdPrint( ( "TDIPX: _TcpGetTransportAddress Length = %d GUID = %ws\n" , RouteLen, RouteStr ) );
#endif

    if (RouteLen < (2 * sizeof(UNICODE_NULL))) {        
        return( STATUS_DEVICE_DOES_NOT_EXIST );
    }


    RtlInitUnicodeString( &NameString, NULL );

    Status = _OpenRegKey( &KeyHandle, REG_IPX_Linkage );
    if ( !NT_SUCCESS( Status ) )
        return Status;

    
    NameString.Length = 0;
    NameString.MaximumLength = 0;
    NameString.Buffer = NULL;
    Status = _GetRegMultiSZValue( KeyHandle, L"Route", &NameString );
    ZwClose( KeyHandle );

    if ( !NT_SUCCESS( Status ) )
        return Status;

    if (NameString.Length < (2 * sizeof(WCHAR))) {
        return(STATUS_DEVICE_DOES_NOT_EXIST);       
    }

    Len = NameString.Length;
    Str = NameString.Buffer;
    Status = STATUS_DEVICE_DOES_NOT_EXIST;
    AdapterNum = 0;

    for (;;) {
        // Check current string to see if it's a GUID (it must start with an
        // open brace after initial double-quote).
        if (Str[1] == L'{') {
            if ( wcsncmp( (PWSTR) &Str[1],RouteStr, wcslen(RouteStr)-1) == 0) {
#if DBG
            KdPrint( ( "TDIPX: _TcpGetTransportAddress: Get Lan Adapter Number = %i\n",AdapterNum ) );
#endif
                Status = STATUS_SUCCESS;
                break;
            }
            else {
//      KdPrint( ( "TDIPX: _TcpGetTransportAddress, No this lana Adapter = %i\n",AdapterNum ) );
                AdapterNum ++;
            }

        }
        // Skip through current string past NULL.
        while (Len >= sizeof(WCHAR)) {
            Len -= sizeof(WCHAR);
            if (*Str++ == UNICODE_NULL)
                break;
        }
        // Check for index out of range.
        if (Len < (2 * sizeof(UNICODE_NULL))) {
            break;                    
            }
    }

    if ( !NT_SUCCESS( Status ) )
         return Status;

    *AdpNum = AdapterNum;
    return STATUS_SUCCESS;    
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdtcp\tdtcp.c ===
/****************************************************************************/
// tdtcp.c
//
// TDI based TCP transport specific routines.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <ntddk.h>
#include <tdi.h>

#include <ntddtcp.h>

#include <tdiinfo.h>
#include <tdistat.h>
#include <ipinfo.h>

#include <winstaw.h>
#define  _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>
#include <td.h>

#include "tdtdi.h"
#include "tdtcp.h"

#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdtcp";
#endif

#define REGISTRY_SERVICES \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define REGISTRY_TCP_LINKAGE \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Linkage"
#define REGISTRY_TCP_INTERFACES \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"


// \nt\private\inc\tcpinfo.h
#define TCP_SOCKET_NODELAY 1

#define TL_INSTANCE        0

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*=============================================================================
==   External Functions Defined
=============================================================================*/

// These are called by TDICOM
NTSTATUS TdiDeviceOpen( PTD, PSD_OPEN );
NTSTATUS TdiDeviceClose( PTD, PSD_CLOSE );
NTSTATUS TdiDeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS TdiDeviceBuildTransportNameAndAddress( PTD, PICA_STACK_ADDRESS,
                                                PUNICODE_STRING,
                                                PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceBuildWildcardAddress( PTD, PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceWaitForDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT,
                                             PTRANSPORT_ADDRESS *, PULONG );
NTSTATUS TdiDeviceCompleteDatagramConnection( PTD, PFILE_OBJECT, PDEVICE_OBJECT, PTRANSPORT_ADDRESS, ULONG );
NTSTATUS TdiDeviceConnectionSend( PTD );
NTSTATUS TdiDeviceReadComplete( PTD, PUCHAR, PULONG );


/*=============================================================================
==   External Functions Referenced
=============================================================================*/

NTSTATUS MemoryAllocate( ULONG, PVOID * );
VOID     MemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TcpGetTransportAddress( PTD, int, PULONG );

VOID
_UnicodeToAnsi(
    CHAR * pAnsiString,
    ULONG lAnsiMax,
    WCHAR * pUnicodeString
    );

unsigned long
_inet_addr(
    IN const char *cp
    );

NTSTATUS
_TcpSetNagle(
    IN PFILE_OBJECT   pFileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN        Flag
    );

NTSTATUS
_TdiTcpSetInformation (
    IN PFILE_OBJECT   FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Entity,
    IN ULONG Class,
    IN ULONG Type,
    IN ULONG Id,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN BOOLEAN WaitForCompletion
    );

NTSTATUS
_OpenRegKey(
    PHANDLE HandlePtr,
    PWCHAR KeyName
    );

NTSTATUS
_GetRegDWORDValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PULONG ValueData
    );

NTSTATUS
_GetRegStringValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PKEY_VALUE_PARTIAL_INFORMATION *ValueData,
    PUSHORT ValueSize
    );

NTSTATUS
_GetRegMultiSZValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PUNICODE_STRING ValueData
    );

NTSTATUS
_GetRegSZValue(
    HANDLE KeyHandle,
    PWCHAR ValueName,
    PUNICODE_STRING ValueData,
    PULONG ValueType
    );

PWCHAR
_EnumRegMultiSz(
    PWCHAR MszString,
    ULONG MszStringLength,
    ULONG StringIndex
    );

VOID
GetGUID(
    OUT PUNICODE_STRING szGuid ,
    IN  int Lana
    );



/*=============================================================================
==   Global variables
=============================================================================*/

USHORT TdiDeviceEndpointType = TdiConnectionStream; // tdicom\tdtdi.h
USHORT TdiDeviceAddressType = TDI_ADDRESS_TYPE_IP;  // TDI address type
USHORT TdiDeviceInBufHeader = 0;  // For packet oriented protocols

/*******************************************************************************
 *
 * TdiDeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpen( PTD pTd, PSD_OPEN pSdOpen )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the current connection endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdClose (input/output)
 *       Points to the parameter structure SD_CLOSE.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceClose( PTD pTd, PSD_CLOSE pSdClose )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 * TdiDeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
TdiDeviceOpenEndpoint(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG IcaEndpointLength
    )
{
    PTDTDI pTdTdi;
    NTSTATUS Status;
    BOOLEAN Flag;

    pTdTdi = (PTDTDI) pTd->pAfd;

    /*
     * JohnR: Adaptive TCP flow control. 03/02/97
     *
     *        If the OutBufDelay is 0, there is no OutBuf timer,
     *        and no Nagles. This setting is for the most response time
     *        sensitive networks with the side effect of sending smaller
     *        segments.
     *
     *        If the OutBufDelay is greater than 1, the standard CITRIX
     *        ICA timer is used to determine at the WD level when to
     *        send a segment. No nagling is enabled since the extra
     *        delay would not be benefitial.
     *
     *        The new OutBufDelay == 1, means that the WD will treat the
     *        OutBufDelay as if it were 0, but the TCP code will enable
     *        the "Nagle" algorithum. This algorithum will send data
     *        immediately if no un-acknowledged segments are outstanding,
     *        OR if half of the send window is filled. If not, data is
     *        stored locally until either a segment acknowledge comes in,
     *        or more data is sent causing half the send window to fill.
     *        This has the advantage of dynamically sizing our "outbuf timer"
     *        to be the round trip time of the network, and not some
     *        arbritrary fixed value.
     */
    if( pTdTdi->OutBufDelay == 1 ) {
        /*
         * OutBufDelay == 1 means NAGLE only.
         */
        Flag = TRUE;
    }
    else {
        /*
         * Turn off nagling for any OutBufDelay timer value, or 0
         */
        Flag = FALSE;
    }

    Status = _TcpSetNagle(
                 pTd->pFileObject,
                 pTd->pDeviceObject,
                 Flag
                 );

    DBGPRINT(("TdiDeviceOpenEndpoint: SetNagle 0x%x Result 0x%x\n",Flag,Status));

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildTransportNameAndAddress
 *
 *  Build the Transport Name and Address given an optional ICA_STACK_ADDRESS,
 *  or the Lana value from the pTd->Params structure.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pLocalAddress (input)
 *     pointer to local address to use (OPTIONAL)
 *   pTransportName (output)
 *     pointer to UNICODE_STRING to return transport name
 *     NOTE: the buffer pointed to be pTransportName.Buffer must
 *           be free'd by the caller
 *   ppTransportAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pTransportAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildTransportNameAndAddress(
    PTD pTd,
    PICA_STACK_ADDRESS pLocalAddress,
    PUNICODE_STRING pTransportName,
    PTRANSPORT_ADDRESS *ppTransportAddress,
    PULONG pTransportAddressLength
    )
{
    PTDI_ADDRESS_IP pIpAddress;
    int Lana;
    NTSTATUS Status;

    /*
     * For TCP, the transport device name is fixed,
     * so just allocate and initialize the transport name string here.
     */
    Status = MemoryAllocate( sizeof(DD_TCP_DEVICE_NAME), &pTransportName->Buffer );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc1;
    wcscpy( pTransportName->Buffer, DD_TCP_DEVICE_NAME );
    pTransportName->Length = sizeof(DD_TCP_DEVICE_NAME) - sizeof(UNICODE_NULL);
    pTransportName->MaximumLength = pTransportName->Length + sizeof(UNICODE_NULL);

    /*
     * Allocate a transport address structure
     */
    *pTransportAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IP);
    Status = MemoryAllocate( *pTransportAddressLength, ppTransportAddress );
    if ( !NT_SUCCESS( Status ) )
        goto badmalloc2;

    /*
     * Initialize the static part of the transport address
     */
    (*ppTransportAddress)->TAAddressCount = 1;
    (*ppTransportAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    (*ppTransportAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pIpAddress = (PTDI_ADDRESS_IP)(*ppTransportAddress)->Address[0].Address;
    pIpAddress->sin_port = htons( (USHORT)pTd->PortNumber );
    RtlZeroMemory( pIpAddress->sin_zero, sizeof(pIpAddress->sin_zero) );

    /*
     * If a local address is specified, then use it.
     */
    if ( pLocalAddress ) {

        /*
         * Skip over the address family(type) data (bytes 0&1) of the
         * local address struct, and copy the remainder of the address
         * directly to the Address field of the TransportAddress struct.
         */
        ASSERT( *(PUSHORT)pLocalAddress == TDI_ADDRESS_TYPE_IP );
        RtlCopyMemory( pIpAddress, &((PCHAR)pLocalAddress)[2], sizeof(TDI_ADDRESS_IP) );

    /*
     * There was no local address specified.
     * In this case, we use the LanAdapter value from the PDPARAMS
     * structure to lookup the corresponding IP address.
     */
    } else if ( (Lana = pTd->Params.Network.LanAdapter) ) {
        ULONG in_addr;

        /*
         * Get Local Address Information
         */
        Status = _TcpGetTransportAddress( pTd, Lana, &in_addr );
        if ( !NT_SUCCESS( Status ) )
            goto badadapterdata;
        pIpAddress->in_addr = in_addr;
    
    /*
     * No LanAdapter value was specified, so use the wildcard address (zero)
     */
    } else {
        pIpAddress->in_addr = 0;
    }

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badadapterdata:
    MemoryFree( *ppTransportAddress );

badmalloc2:
    MemoryFree( pTransportName->Buffer );

badmalloc1:
    return( Status );
}


/*****************************************************************************
 *
 *  TdiDeviceBuildWildcardAddress
 *
 *  Build a wildcard Address for this protocol.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   ppWildcardAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pWildcardAddressLength (output)
 *     pointer to location to return TransportAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceBuildWildcardAddress(
    PTD pTd,
    PTRANSPORT_ADDRESS *ppWildcardAddress,
    PULONG pWildcardAddressLength
    )
{
    PTDI_ADDRESS_IP pIpAddress;
    NTSTATUS Status;

    /*
     * Allocate a transport address structure
     */
    *pWildcardAddressLength = sizeof(TRANSPORT_ADDRESS) +
                               sizeof(TDI_ADDRESS_IP);
    Status = MemoryAllocate( *pWildcardAddressLength, ppWildcardAddress );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    /*
     * Initialize the static part of the transport address
     */
    (*ppWildcardAddress)->TAAddressCount = 1;
    (*ppWildcardAddress)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    (*ppWildcardAddress)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pIpAddress = (PTDI_ADDRESS_IP)(*ppWildcardAddress)->Address[0].Address;
    pIpAddress->sin_port = 0;
    pIpAddress->in_addr = 0;
    RtlZeroMemory( pIpAddress->sin_zero, sizeof(pIpAddress->sin_zero) );

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  TdiDeviceWaitForDatagramConnection
 *
 *  Wait for a datagram connection request, validate it,
 *  and return the remote transport address of the connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object to wait for a connection on
 *   ppRemoteAddress (output)
 *     pointer to location to return TRANSPORT_ADDRESS structure
 *     NOTE: the transport address buffer must be free'd by the caller
 *   pRemoteAddressLength (output)
 *     pointer to location to return RemoteAddress length
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceWaitForDatagramConnection(
    PTD pTd,
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS *ppRemoteAddress,
    PULONG pRemoteAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*****************************************************************************
 *
 *  TdiDeviceCompleteDatagramConnection
 *
 *  Do any final work to complete a datagram connection.
 *
 * ENTRY:
 *
 *   pTd (input)
 *     pointer to TD data structure
 *   pFileObject (input)
 *     pointer to file object for this connection
 *
 * EXIT:
 *  STATUS_SUCCESS - Success
 *
 ****************************************************************************/

NTSTATUS
TdiDeviceCompleteDatagramConnection(
    PTD pTd, 
    PFILE_OBJECT pFileObject,
    PDEVICE_OBJECT pDeviceObject,
    PTRANSPORT_ADDRESS pRemoteAddress,
    ULONG RemoteAddressLength
    )
{
    return( STATUS_NOT_SUPPORTED );
}


/*******************************************************************************
 *
 *  TdiDeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceConnectionSend( PTD pTd )
{
    PCLIENTMODULES pClient;

    /*
     *  Get pointer to client structure
     */
    pClient = pTd->pClient;

    /*
     *  Initialize Td host module structure
     */
    pClient->TdVersionL = VERSION_HOSTL_TDTCP;
    pClient->TdVersionH = VERSION_HOSTH_TDTCP;
    pClient->TdVersion  = VERSION_HOSTH_TDTCP;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  TdiDeviceReadComplete
 *
 *  Do any read complete processing
 *
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to td data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location containing byte count read
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
TdiDeviceReadComplete( PTD pTd, PUCHAR pBuffer, PULONG pByteCount )
{
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _TcpGetTransportAddress
 *
 *  Get TCP transport address for a given LanAdapter number
 *
 *
 *  ENTRY:
 *     pTd (input)
 *        pointer to TD data structure
 *     Lana (input)
 *        Lan Adapter number, 1-based based on the tscc.msc UI ordering.
 *     pIpAddr (output)
 *        address to return IP address
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

#if 0 // replacement below

NTSTATUS _TcpGetTransportAddress(PTD pTd, int Lana, PULONG pIpAddr)
{
    HANDLE KeyHandle;
    UNICODE_STRING RouteString;
    PWCHAR pInterfaceGuid;
    NTSTATUS Status;
    unsigned Len;
    PWCHAR Str;

    /*
     * Open the Tcp Linkage key
     */
    Status = _OpenRegKey( &KeyHandle, REGISTRY_TCP_LINKAGE );
    if ( !NT_SUCCESS( Status ) )
        goto badopen;

    /*
     * Alloc and read in the linkage route multi-string.
     *
     * This is of the form (including the double quotes):
     * "{<guid>}"\0"{<guid>}"\0"NdisWanIp"\0\0
     *
     * Each of the GUIDs is a link to the adapter interface keys
     * stored at HKLM\System\CCS\Services\tcpip\Parameters\Interfaces,
     * inside of which is the IP address information.
     */
    RouteString.Length = 0;
    RouteString.MaximumLength = 0;
    RouteString.Buffer = NULL;
    Status = _GetRegMultiSZValue( KeyHandle, L"Route", &RouteString );
    ZwClose( KeyHandle );
    if ( !NT_SUCCESS( Status ) )
        goto badvalue;

    /*
     * Find the interface GUID that corresponds to the specified UI LANA
     * index. The LANA index corresponds to the registry ordering of the
     * interfaces, skipping the PPP interface(s). From the way the
     * registry looks PPP interfaces do not have GUIDs specified in
     * the Linkage key, so we skip the non-GUID entries.
     */
    if (RouteString.Length < (2 * sizeof(WCHAR))) {
        Status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto PostAllocRouteString;
    }
    Len = RouteString.Length;
    Str = RouteString.Buffer;
    for (;;) {
        // Check current string to see if it's a GUID (it must start with an
        // open brace after initial double-quote).
        if (Str[1] == L'{') {
            // Have we found it?
            if (Lana == 1)
                break;
            Lana--;
        }

        // Skip through current string past NULL.
        while (Len >= sizeof(WCHAR)) {
            Len -= sizeof(WCHAR);
            if (*Str++ == UNICODE_NULL)
                break;
        }

        // Check for index out of range.
        if (Len < (2 * sizeof(UNICODE_NULL))) {
            Status = STATUS_DEVICE_DOES_NOT_EXIST;
            goto PostAllocRouteString;
        }
    }
    if (Len >= (2 * sizeof(UNICODE_NULL))) {
        ULONG DhcpEnabled;
        UNICODE_STRING IpAddrString;
        UNICODE_STRING KeyString;
        WCHAR KeyName[256];
        char AnsiBuf[256];

        // Skip the initial double quote, and change the ending quote to a
        // NULL.
        Str++;
        pInterfaceGuid = Str;
        while (*Str != L'\"')
            Str++;
        *Str = L'\0';

        /*
         * Use the GUID to look up the interface IP info.
         */

        // We open HKLM\System\CCS\Services\tcpip\Parameters\Interfaces\<GUID>
        // to get to the DHCP and IP address information.
        KeyString.Length = 0;
        KeyString.MaximumLength = sizeof(KeyName);
        KeyString.Buffer = KeyName;
        RtlAppendUnicodeToString(&KeyString, REGISTRY_TCP_INTERFACES);
        RtlAppendUnicodeToString(&KeyString, pInterfaceGuid);
        Status = _OpenRegKey(&KeyHandle, KeyName);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Query the "EnableDHCP" value.
        Status = _GetRegDWORDValue(KeyHandle, L"EnableDHCP", &DhcpEnabled);
        if (!NT_SUCCESS(Status)) {
            ZwClose(KeyHandle);
            goto PostAllocRouteString;
        }

        IpAddrString.Length = 0;
        IpAddrString.MaximumLength = 0;
        IpAddrString.Buffer = NULL;
        if (DhcpEnabled) {
            ULONG ValueType;

            // If DHCP is enabled for this device, then we query the current
            // IP address from the "DhcpIPAddress" value.
            Status = _GetRegSZValue(KeyHandle, L"DhcpIPAddress",
                    &IpAddrString, &ValueType);
        }
        else {
            // DHCP is not enabled for this device, so we query the
            // IP address from the "IPAddress" value.
            Status = _GetRegMultiSZValue(KeyHandle, L"IPAddress",
                    &IpAddrString);
        }
        ZwClose(KeyHandle);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Convert IP address from Unicode to ansi to a ULONG.
        _UnicodeToAnsi(AnsiBuf, sizeof(AnsiBuf) - 1, IpAddrString.Buffer);

        *pIpAddr = _inet_addr(AnsiBuf);

        MemoryFree(IpAddrString.Buffer);
    }
    else {
        Status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto PostAllocRouteString;
    }

PostAllocRouteString:
    MemoryFree(RouteString.Buffer);

badvalue:
badopen:
    return Status;
}
#endif

/*******************************************************************************
 *
 *  _TcpGetTransportAddress(2)
 *
 *  Get TCP transport address for a given LanAdapter number
 *
 *
 *  ENTRY:
 *     pTd (input)
 *        pointer to TD data structure
 *     Lana (input)
 *        Lan Adapter number, 1-based based on the tscc.msc UI ordering.
 *     pIpAddr (output)
 *        address to return IP address
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS _TcpGetTransportAddress(PTD pTd, int Lana, PULONG pIpAddr)
{
    HANDLE KeyHandle;
    UNICODE_STRING RouteString;
    PWCHAR pInterfaceGuid;
    NTSTATUS Status;
    unsigned Len;
    PWCHAR Str;

    
    RtlInitUnicodeString( &RouteString , NULL );

    GetGUID( &RouteString , Lana );

    Len = RouteString.Length;    
    Str = RouteString.Buffer;

    KdPrint( ( "TDTCP: _TcpGetTransportAddress Length = %d GUID = %ws\n" , Len , Str ) );

    if( Str == NULL )
    {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    if (Len >= (2 * sizeof(UNICODE_NULL))) {
        ULONG DhcpEnabled;
        UNICODE_STRING IpAddrString;
        UNICODE_STRING KeyString;
        WCHAR KeyName[256];
        char AnsiBuf[256];

        pInterfaceGuid = Str;

        // Skip the initial double quote, and change the ending quote to a
        // NULL.
        /*
        Str++;
        pInterfaceGuid = Str;
        while (*Str != L'\"')
            Str++;
        *Str = L'\0';
        */

        /*
         * Use the GUID to look up the interface IP info.
         */

        // We open HKLM\System\CCS\Services\tcpip\Parameters\Interfaces\<GUID>
        // to get to the DHCP and IP address information.
        KeyString.Length = 0;
        KeyString.MaximumLength = sizeof(KeyName);
        KeyString.Buffer = KeyName;
        RtlAppendUnicodeToString(&KeyString, REGISTRY_TCP_INTERFACES);
        RtlAppendUnicodeToString(&KeyString, pInterfaceGuid);
        Status = _OpenRegKey(&KeyHandle, KeyName);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Query the "EnableDHCP" value.
        Status = _GetRegDWORDValue(KeyHandle, L"EnableDHCP", &DhcpEnabled);
        if (!NT_SUCCESS(Status)) {
            ZwClose(KeyHandle);
            goto PostAllocRouteString;
        }

        IpAddrString.Length = 0;
        IpAddrString.MaximumLength = 0;
        IpAddrString.Buffer = NULL;
        if (DhcpEnabled) {
            ULONG ValueType;

            // If DHCP is enabled for this device, then we query the current
            // IP address from the "DhcpIPAddress" value.
            Status = _GetRegSZValue(KeyHandle, L"DhcpIPAddress",
                    &IpAddrString, &ValueType);
        }
        else {
            // DHCP is not enabled for this device, so we query the
            // IP address from the "IPAddress" value.
            Status = _GetRegMultiSZValue(KeyHandle, L"IPAddress",
                    &IpAddrString);
        }
        ZwClose(KeyHandle);
        if (!NT_SUCCESS(Status))
            goto PostAllocRouteString;

        // Convert IP address from Unicode to ansi to a ULONG.
        _UnicodeToAnsi(AnsiBuf, sizeof(AnsiBuf) - 1, IpAddrString.Buffer);

        *pIpAddr = _inet_addr(AnsiBuf);

        MemoryFree(IpAddrString.Buffer);
    }
    else {
        Status = STATUS_DEVICE_DOES_NOT_EXIST;
        goto PostAllocRouteString;
    }

PostAllocRouteString:

    if( RouteString.Buffer != NULL )
    {
        MemoryFree(RouteString.Buffer);
    }

    return Status;
}

/*******************************************************************************
 *
 *  _UnicodeToAnsi
 *
 *     convert a UNICODE (WCHAR) string into an ANSI (CHAR) string
 *
 * ENTRY:
 *
 *    pAnsiString (output)
 *       buffer to place ANSI string into
 *    lAnsiMax (input)
 *       maximum number of characters to write into pAnsiString
 *    pUnicodeString (input)
 *       UNICODE string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
_UnicodeToAnsi(
    CHAR * pAnsiString,
    ULONG lAnsiMax,
    WCHAR * pUnicodeString )
{
    ULONG ByteCount;

NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString);

    RtlUnicodeToMultiByteN( pAnsiString, lAnsiMax, &ByteCount,
                            pUnicodeString,
                            ((wcslen(pUnicodeString) + 1) << 1) );
}


/*
 * Internet address interpretation routine.
 * All the network library routines call this
 * routine to interpret entries in the data bases
 * which are expected to be an address.
 * The value returned is in network order.
 */
unsigned long
_inet_addr(
    IN const char *cp
    )

/*++

Routine Description:

    This function interprets the character string specified by the cp
    parameter.  This string represents a numeric Internet address
    expressed in the Internet standard ".'' notation.  The value
    returned is a number suitable for use as an Internet address.  All
    Internet addresses are returned in network order (bytes ordered from
    left to right).

    Internet Addresses

    Values specified using the "." notation take one of the following
    forms:

    a.b.c.d   a.b.c     a.b  a

    When four parts are specified, each is interpreted as a byte of data
    and assigned, from left to right, to the four bytes of an Internet
    address.  Note that when an Internet address is viewed as a 32-bit
    integer quantity on the Intel architecture, the bytes referred to
    above appear as "d.c.b.a''.  That is, the bytes on an Intel
    processor are ordered from right to left.

    Note: The following notations are only used by Berkeley, and nowhere
    else on the Internet.  In the interests of compatibility with their
    software, they are supported as specified.

    When a three part address is specified, the last part is interpreted
    as a 16-bit quantity and placed in the right most two bytes of the
    network address.  This makes the three part address format
    convenient for specifying Class B network addresses as
    "128.net.host''.

    When a two part address is specified, the last part is interpreted
    as a 24-bit quantity and placed in the right most three bytes of the
    network address.  This makes the two part address format convenient
    for specifying Class A network addresses as "net.host''.

    When only one part is given, the value is stored directly in the
    network address without any byte rearrangement.

Arguments:

    cp - A character string representing a number expressed in the
        Internet standard "." notation.

Return Value:

    If no error occurs, inet_addr() returns an in_addr structure
    containing a suitable binary representation of the Internet address
    given.  Otherwise, it returns the value INADDR_NONE.

--*/

{
        register unsigned long val, base, n;
        register char c;
        unsigned long parts[4], *pp = parts;
#define INADDR_NONE 0xffffffff
#define htonl(x) ((((x) >> 24) & 0x000000FFL) | \
                 (((x) >>  8) & 0x0000FF00L) | \
                 (((x) <<  8) & 0x00FF0000L) | \
                 (((x) << 24) & 0xFF000000L))

again:
        /*
         * Collect number up to ``.''.
         * Values are specified as for C:
         * 0x=hex, 0=octal, other=decimal.
         */
        val = 0; base = 10;
        if (*cp == '0') {
                base = 8, cp++;
                if (*cp == 'x' || *cp == 'X')
                        base = 16, cp++;
        }
        
        while (c = *cp) {
                if (isdigit(c)) {
                        val = (val * base) + (c - '0');
                        cp++;
                        continue;
                }
                if (base == 16 && isxdigit(c)) {
                        val = (val << 4) + (c + 10 - (islower(c) ? 'a' : 'A'));
                        cp++;
                        continue;
                }
                break;
        }
        if (*cp == '.') {
                /*
                 * Internet format:
                 *      a.b.c.d
                 *      a.b.c   (with c treated as 16-bits)
                 *      a.b     (with b treated as 24 bits)
                 */
                /* GSS - next line was corrected on 8/5/89, was 'parts + 4' */
                if (pp >= parts + 3) {
                        return ((unsigned long) -1);
                }
                *pp++ = val, cp++;
                goto again;
        }

        /*
         * Check for trailing characters.
         */
        if (*cp && !isspace(*cp)) {
                return (INADDR_NONE);
        }
        *pp++ = val;

        /*
         * Concoct the address according to
         * the number of parts specified.
         */
        n = (unsigned long)(pp - parts);
        switch ((int) n) {

        case 1:                         /* a -- 32 bits */
                val = parts[0];
                break;

        case 2:                         /* a.b -- 8.24 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xffffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | (parts[1] & 0xffffff);
                break;

        case 3:                         /* a.b.c -- 8.8.16 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xffff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                        (parts[2] & 0xffff);
                break;

        case 4:                         /* a.b.c.d -- 8.8.8.8 bits */
                if ((parts[0] > 0xff) || (parts[1] > 0xff) ||
                    (parts[2] > 0xff) || (parts[3] > 0xff)) {
                    return(INADDR_NONE);
                }
                val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
                      ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
                break;

        default:
                return (INADDR_NONE);
        }
        val = htonl(val);
        return (val);
}


/*****************************************************************************
 *
 *  _TcpSetNagle
 *
 *   This function turns on, or off the NAGLE algorithum.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
_TcpSetNagle(
    IN PFILE_OBJECT   pFileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN        Flag
    )
{
    NTSTATUS Status;
    ULONG    Value;

    if( Flag ) {
        Value = FALSE;
    }
    else {
        Value = TRUE;
    }

    Status = _TdiTcpSetInformation(
                 pFileObject,
                 DeviceObject,
                 CO_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_CONNECTION,
                 TCP_SOCKET_NODELAY,
                 &Value,
                 sizeof(Value),
                 TRUE
                 );

    DBGPRINT(("_TcpSetNagle: Flag 0x%x, Result 0x%x\n",Flag,Status));

    return( Status );
}


NTSTATUS
_TdiTcpSetInformation (
        IN PFILE_OBJECT   pFileObject,
        IN PDEVICE_OBJECT DeviceObject,
        IN ULONG Entity,
        IN ULONG Class,
        IN ULONG Type,
        IN ULONG Id,
        IN PVOID Value,
        IN ULONG ValueLength,
        IN BOOLEAN WaitForCompletion)

/*++

NOTE: This is a modified routine from WSHTCPIP.C

Routine Description:

    Performs a TDI action to the TCP/IP driver.  A TDI action translates
    into a streams T_OPTMGMT_REQ.

Arguments:

    TdiConnectionObjectHandle - a TDI connection object on which to perform
        the TDI action.

    Entity - value to put in the tei_entity field of the TDIObjectID
        structure.

    Class - value to put in the toi_class field of the TDIObjectID
        structure.

    Type - value to put in the toi_type field of the TDIObjectID
        structure.

    Id - value to put in the toi_id field of the TDIObjectID structure.

    Value - a pointer to a buffer to set as the information.

    ValueLength - the length of the buffer.

Return Value:

    NTSTATUS code
--*/

{
    NTSTATUS status;
    PTCP_REQUEST_SET_INFORMATION_EX pSetInfoEx;
    PIO_STATUS_BLOCK pIOSB;

    // Allocate space to hold the TDI set information buffers and the IO
    // status block. Note the IOSB is a required field for the lower
    // layers despite the OPTIONAL label in CtxDeviceIoControlFile.
    status = MemoryAllocate(sizeof(*pSetInfoEx) + ValueLength +
            sizeof(IO_STATUS_BLOCK), &pIOSB);
    if (status == STATUS_SUCCESS) {
        // The SetInfoEx is after the I/O status block in this alloc.
        pSetInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)(pIOSB + 1);

        // Initialize the TDI information buffers.
        pSetInfoEx->ID.toi_entity.tei_entity = Entity;
        pSetInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
        pSetInfoEx->ID.toi_class = Class;
        pSetInfoEx->ID.toi_type = Type;
        pSetInfoEx->ID.toi_id = Id;

        RtlCopyMemory(pSetInfoEx->Buffer, Value, ValueLength);
        pSetInfoEx->BufferSize = ValueLength;

        // Make the actual TDI action call. The Streams TDI mapper will
        // translate this into a TPI option management request for us and
        // give it to TCP/IP.
        status = CtxDeviceIoControlFile(pFileObject,
                IOCTL_TCP_SET_INFORMATION_EX, pSetInfoEx,
                sizeof(*pSetInfoEx) + ValueLength, NULL, 0, FALSE, NULL,
                pIOSB, NULL);

        MemoryFree(pIOSB);
    }

#if DBG
    if (!NT_SUCCESS(status)) {
        DBGPRINT(("_TdiTcpSetInformation: Error 0x%x\n",status));
    }
#endif

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdpipe\tdpipe.c ===
/****************************************************************************/
// tdpipe.c
//
// TS named pipe transport driver.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <ntosp.h>

#include <winstaw.h>
#define  _DEFCHARINFO_
#include <icadd.h>
#include <ctxdd.h>
#include <sdapi.h>
#include <td.h>

#include "tdpipe.h"


#ifdef _HYDRA_
// This becomes the device name
PWCHAR ModuleName = L"tdpipe";
#endif


#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS DeviceOpen( PTD, PSD_OPEN );
NTSTATUS DeviceClose( PTD, PSD_CLOSE );
NTSTATUS DeviceCreateEndpoint( PTD, PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS DeviceOpenEndpoint( PTD, PVOID, ULONG );
NTSTATUS DeviceCloseEndpoint( PTD );
NTSTATUS DeviceConnectionWait( PTD, PVOID, ULONG, PULONG );
NTSTATUS DeviceConnectionSend( PTD );
NTSTATUS DeviceConnectionRequest( PTD, PICA_STACK_ADDRESS, PVOID, ULONG, PULONG );
NTSTATUS DeviceIoctl( PTD, PSD_IOCTL );
NTSTATUS DeviceInitializeRead( PTD, PINBUF );
NTSTATUS DeviceSubmitRead( PTD, PINBUF );
NTSTATUS DeviceWaitForRead( PTD );
NTSTATUS DeviceReadComplete( PTD, PUCHAR, PULONG );
NTSTATUS DeviceInitializeWrite( PTD, POUTBUF );
NTSTATUS DeviceWaitForStatus( PTD );
NTSTATUS DeviceCancelIo( PTD );
NTSTATUS DeviceSetParams( PTD );
NTSTATUS DeviceGetLastError( PTD, PICA_STACK_LAST_ERROR );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/

NTSTATUS _TdOpenEndpoint( PTD, PICA_STACK_ADDRESS, PTD_ENDPOINT * );
NTSTATUS _TdCloseEndpoint( PTD, PTD_ENDPOINT );
NTSTATUS _TdStartListen( PTD, PTD_ENDPOINT );
NTSTATUS _TdWaitForListen( PTD, PTD_ENDPOINT );
NTSTATUS _TdConnectRequest( PTD, PTD_ENDPOINT );


/*=============================================================================
==   External Functions Referenced
=============================================================================*/

NTSTATUS
ZwClose(
    IN HANDLE Handle
    );

NTSTATUS
ZwFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );


NTSTATUS
ZwCreateNamedPipeFile(
         OUT PHANDLE FileHandle,
         IN ULONG DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes,
         OUT PIO_STATUS_BLOCK IoStatusBlock,
         IN ULONG ShareAccess,
         IN ULONG CreateDisposition,
         IN ULONG CreateOptions,
         IN ULONG NamedPipeType,
         IN ULONG ReadMode,
         IN ULONG CompletionMode,
         IN ULONG MaximumInstances,
         IN ULONG InboundQuota,
         IN ULONG OutboundQuota,
         IN PLARGE_INTEGER DefaultTimeout OPTIONAL)

/*++
    Creates and opens the server end handle of the first instance of a
    specific named pipe or another instance of an existing named pipe.

Arguments:
    FileHandle - Supplies a handle to the file on which the service is being
        performed.
    DesiredAccess - Supplies the types of access that the caller would like to
        the file.
    ObjectAttributes - Supplies the attributes to be used for file object
        (name, SECURITY_DESCRIPTOR, etc.)
    IoStatusBlock - Address of the caller's I/O status block.
    ShareAccess - Supplies the types of share access that the caller would
        like to the file.
    CreateDisposition - Supplies the method for handling the create/open.
    CreateOptions - Caller options for how to perform the create/open.
    NamedPipeType - Type of named pipe to create (Bitstream or message).
    ReadMode - Mode in which to read the pipe (Bitstream or message).
    CompletionMode - Specifies how the operation is to be completed.
    MaximumInstances - Maximum number of simultaneous instances of the named
        pipe.
    InboundQuota - Specifies the pool quota that is reserved for writes to the
        inbound side of the named pipe.
    OutboundQuota - Specifies the pool quota that is reserved for writes to
        the inbound side of the named pipe.
    DefaultTimeout - Optional pointer to a timeout value that is used if a
        timeout value is not specified when waiting for an instance of a named
        pipe.

Return Value:
    The function value is the final status of the create/open operation.
--*/

{
    NAMED_PIPE_CREATE_PARAMETERS namedPipeCreateParameters;
    NTSTATUS status;

    // Check whether or not the DefaultTimeout parameter was specified.  If
    // so, then capture it in the named pipe create parameter structure.
    if (ARGUMENT_PRESENT( DefaultTimeout )) {
        // Indicate that a default timeout period was specified.
        namedPipeCreateParameters.TimeoutSpecified = TRUE;
        namedPipeCreateParameters.DefaultTimeout = *DefaultTimeout;

        // A default timeout parameter was specified.  Check to see whether
        // the caller's mode is kernel and if not capture the parameter inside
        // of a try...except clause.
    } else {
        // Indicate that no default timeout period was specified.
        namedPipeCreateParameters.TimeoutSpecified = FALSE;
        namedPipeCreateParameters.DefaultTimeout.QuadPart = 0;
    }

    // Store the remainder of the named pipe-specific parameters in the
    // structure for use in the call to the common create file routine.
    namedPipeCreateParameters.NamedPipeType = NamedPipeType;
    namedPipeCreateParameters.ReadMode = ReadMode;
    namedPipeCreateParameters.CompletionMode = CompletionMode;
    namedPipeCreateParameters.MaximumInstances = MaximumInstances;
    namedPipeCreateParameters.InboundQuota = InboundQuota;
    namedPipeCreateParameters.OutboundQuota = OutboundQuota;

    status = IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         (PVOID) NULL,
                         0L,
                         CreateFileTypeNamedPipe,
                         &namedPipeCreateParameters,
                         IO_NO_PARAMETER_CHECKING);

    return status;
}


NTSTATUS
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

extern POBJECT_TYPE *IoFileObjectType;
extern PDEVICE_OBJECT DrvDeviceObject;


/*******************************************************************************
 * DeviceOpen
 *
 *  Allocate and initialize private data structures
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdOpen (input/output)
 *       Points to the parameter structure SD_OPEN.
 ******************************************************************************/
NTSTATUS DeviceOpen(PTD pTd, PSD_OPEN pSdOpen)
{
    PTDPIPE pTdPipe;
    NTSTATUS Status;

    /*
     * Hideous HACK alert!  NULL out the unload routine for TDPIPE since
     * the timing is hosed and we sometimes unload before the IO completion
     * routine has issued a return statement. BARF!
     */
    // see correction of the hack below...
    //DrvDeviceObject->DriverObject->DriverUnload = NULL;

    // correction of the above hack: a pointer to the device object of the current
    // driver is stored in the TD struct. When an IRP is initialized, the function
    // IoSetCompletionRoutineEx will be used and this function will set a parent
    // completion routine which references and dereferences the device object
    // around the call of the normal completion routine in order to maintain the 
    // driver in memory.
    // DO NOT USE THIS POINTER AFTER THE DeviceClose !!!
    pTd->pSelfDeviceObject = pSdOpen->DeviceObject;

    /*
     *  Set protocol driver class
     */
    pTd->SdClass = SdNetwork;           // until we have SdPipe defined

    /*
     *  Return size of header and trailer
     */
    pSdOpen->SdOutBufHeader  = 0;
    pSdOpen->SdOutBufTrailer = 0;

    /*
     *  Allocate PIPE TD data structure
     */
    pTdPipe = IcaStackAllocatePoolWithTag(NonPagedPool, sizeof(*pTdPipe), 'ipDT');
    if (pTdPipe != NULL) {
        /*
         *  Initialize TDPIPE data structure
         */
        RtlZeroMemory(pTdPipe, sizeof(*pTdPipe));
        pTd->pPrivate = pTdPipe;
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


/*******************************************************************************
 * DeviceClose
 *
 *  Close transport driver
 *
 *  NOTE: this must not close the current connection endpoint
 ******************************************************************************/
NTSTATUS DeviceClose(PTD pTd, PSD_CLOSE pSdClose)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pEndpoint;

    pTd->pSelfDeviceObject = NULL;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Close address endpoint if we have one
     */
    if (pEndpoint = pTdPipe->pAddressEndpoint) {
        pTdPipe->pAddressEndpoint = NULL;
        _TdCloseEndpoint(pTd, pEndpoint);
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceCreateEndpoint
 *
 * Create a new endpoint
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLocalAddress (input)
 *       Pointer to local address (or null)
 *    pReturnedAddress (input)
 *       Pointer to location to save returned (created) address (or null)
 ******************************************************************************/
NTSTATUS DeviceCreateEndpoint(
        PTD pTd,
        PICA_STACK_ADDRESS pLocalAddress,
        PICA_STACK_ADDRESS pReturnedAddress)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Create an endpoint which ConnectionWait will use to listen on.
     */
    Status = _TdOpenEndpoint(pTd, pLocalAddress, &pEndpoint);
    if (NT_SUCCESS(Status)) {
        /*
         * Prepare to listen on the new address endpoint.
         */
        Status = _TdStartListen(pTd, pEndpoint);
        if (NT_SUCCESS(Status)) {
            /*
             * Save a pointer to the address endpoint
             */
            pTdPipe->pAddressEndpoint = pEndpoint;
            Status = STATUS_SUCCESS;
        }
        else {
            _TdCloseEndpoint(pTd, pEndpoint);
        }
    }

    return Status;
}


/*******************************************************************************
 * DeviceOpenEndpoint
 *
 *  Open an existing endpoint
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (input)
 *       Pointer to ICA endpoint structure
 *    IcaEndpointLength (input)
 *       length of endpoint data
 ******************************************************************************/
NTSTATUS DeviceOpenEndpoint(
        PTD pTd,
        PVOID pIcaEndpoint,
        ULONG IcaEndpointLength)
{
    PTDPIPE pTdPipe;
    PTD_STACK_ENDPOINT pStackEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    TRACE((pTd->pContext, TC_TD, TT_API2,
            "TDPIPE: DeviceOpenEndpoint, copying existing endpoint\n"));

    try {
        /*
         * Verify the stack endpoint data looks valid
         */
        pStackEndpoint = (PTD_STACK_ENDPOINT) pIcaEndpoint;
        if (IcaEndpointLength == sizeof(TD_STACK_ENDPOINT) &&
                //pStackEndpoint->pEndpoint >= MM_LOWEST_NONPAGED_SYSTEM_START &&
                //pStackEndpoint->pEndpoint <= MM_NONPAGED_POOL_END &&
                MmIsNonPagedSystemAddressValid(pStackEndpoint->pEndpoint)) {
            /*
             * Save endpoint as the current connection endpoint
             */
            pTdPipe->pConnectionEndpoint = pStackEndpoint->pEndpoint;

            /*
             * Save the file/device objects used for I/O in the TD structure
             */
            pTd->pFileObject = pTdPipe->pConnectionEndpoint->pFileObject;
            pTd->pDeviceObject = pTdPipe->pConnectionEndpoint->pDeviceObject;

            Status = STATUS_SUCCESS;
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
    }

    return Status;
}


/*******************************************************************************
 * DeviceCloseEndpoint
 ******************************************************************************/
NTSTATUS DeviceCloseEndpoint(PTD pTd)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Close connection endpoint if we have one
     * NOTE: The address endpoint, if there is one,
     *       gets closed in the DeviceClose routine.
     */
    if (pEndpoint = pTdPipe->pConnectionEndpoint) {
        pTd->pFileObject = NULL;
        pTd->pDeviceObject = NULL;
        pTdPipe->pConnectionEndpoint = NULL;
        _TdCloseEndpoint(pTd, pEndpoint);
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceConnectionWait
 *
 *  NOTE: The endpoint structure is an opaque, variable length data
 *        structure whose length and contents are determined by the
 *        transport driver.
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Points to the actual number of bytes written to pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionWait(
        PTD pTd,
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDPIPE pTdPipe;
    PTD_STACK_ENDPOINT pStackEndpoint;
    NTSTATUS Status;

    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Initialize return buffer size
     */
    *BytesReturned = sizeof(TD_STACK_ENDPOINT);

    /*
     * Verify output endpoint buffer is large enough
     */
    if (Length >= sizeof(TD_STACK_ENDPOINT)) {
        /*
         * Ensure we have an address endpoint already
         */
        if (pTdPipe->pAddressEndpoint != NULL) {
            /*
             * Wait for a new virtual circuit connection.
             */
            Status = _TdWaitForListen(pTd, pTdPipe->pAddressEndpoint);
            if (NT_SUCCESS(Status)) {
                /*
                 * The listen was successful.
                 * Return the existing address endpoint as the connection endpoint
                 * and forget that we have an address endpoint anymore.
                 */
                pStackEndpoint = (PTD_STACK_ENDPOINT) pIcaEndpoint;
                pStackEndpoint->pEndpoint = pTdPipe->pAddressEndpoint;
                pTdPipe->pAddressEndpoint = NULL;
            }
            else {
                goto done;
            }
        }
        else {
            Status = STATUS_DEVICE_NOT_READY;
            goto done;
        }
    }
    else {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto done;
    }

done:
    return Status;
}


/*******************************************************************************
 * DeviceConnectionSend
 *
 *  Initialize host module data structure
 *  -- this structure gets sent to the client
 ******************************************************************************/
NTSTATUS DeviceConnectionSend(PTD pTd)
{
    return STATUS_NOT_SUPPORTED;
}


/*******************************************************************************
 * DeviceConnectionRequest
 *
 *  Initiate a connection to the specified remote address
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pRemoteAddress (input)
 *       Pointer to remote address to connect to
 *    pIcaEndpoint (output)
 *       Points to a buffer to receive the current endpoint
 *    Length (input)
 *       Length of the buffer pointed to by pIcaEndpoint
 *    BytesReturned (output)
 *       Pointer to location to return length of pIcaEndpoint
 *
 * EXIT:
 *    STATUS_SUCCESS          - no error
 *    STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small
 ******************************************************************************/
NTSTATUS DeviceConnectionRequest(
        PTD pTd,
        PICA_STACK_ADDRESS pRemoteAddress,
        PVOID pIcaEndpoint,
        ULONG Length,
        PULONG BytesReturned)
{
    PTDPIPE pTdPipe;
    PTD_ENDPOINT pConnectionEndpoint;
    PTD_STACK_ENDPOINT pStackEndpoint;
    NTSTATUS Status;

    ASSERT( pRemoteAddress );
    if (pRemoteAddress != NULL) {
        /*
         * Initialize return buffer size
         */
        *BytesReturned = sizeof(TD_STACK_ENDPOINT);

        /*
         * Verify output endpoint buffer is large enough
         */
        if (Length >= sizeof(TD_STACK_ENDPOINT)) {
            pTdPipe = (PTDPIPE) pTd->pPrivate;

            /*
             * Create an endpoint which we will use to connect with
             */
            Status = _TdOpenEndpoint(pTd, pRemoteAddress, &pConnectionEndpoint);
            if (NT_SUCCESS(Status)) {
                /*
                 * Attempt to connect to the specified remote address
                 */
                Status = _TdConnectRequest(pTd, pConnectionEndpoint);
                if (NT_SUCCESS(Status)) {
                    /*
                     * Fill in the stack endpoint structure to be returned
                     */
                    pStackEndpoint = (PTD_STACK_ENDPOINT) pIcaEndpoint;
                    pStackEndpoint->pEndpoint = pConnectionEndpoint;

                    /*
                     * Save a pointer to the connection endpoint
                     */
                    pTdPipe->pConnectionEndpoint = pConnectionEndpoint;

                    /*
                     * Save the file/device objects for I/O in the TD structure
                     */
                    pTd->pFileObject = pConnectionEndpoint->pFileObject;
                    pTd->pDeviceObject = pConnectionEndpoint->pDeviceObject;

                    return STATUS_SUCCESS;
                }
                else {
                    goto badconnect;
                }
            }
            else {
                goto badcreate;
            }
        }
        else {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto buftoosmall;
        }
    }
    else {
        return STATUS_INVALID_PARAMETER;
    }


/*=============================================================================
==   Error returns
=============================================================================*/

badconnect:
    _TdCloseEndpoint(pTd, pConnectionEndpoint);

badcreate:
buftoosmall:
    return Status;
}


/*******************************************************************************
 * DeviceIoctl
 *
 *  Query/Set configuration information for the td.
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pSdIoctl (input/output)
 *       Points to the parameter structure SD_IOCTL
 ******************************************************************************/
NTSTATUS DeviceIoctl(PTD pTd, PSD_IOCTL pSdIoctl)
{
    return STATUS_NOT_SUPPORTED;
}


/*******************************************************************************
 * DeviceInitializeRead
 ******************************************************************************/
NTSTATUS DeviceInitializeRead(PTD pTd, PINBUF pInBuf)
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    irp = pInBuf->pIrp;
    irpSp = IoGetNextIrpStackLocation(irp);

    /*
     * Set the major function code and read parameters.
     */
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->Parameters.Read.Length = pTd->InBufHeader + pTd->OutBufLength;

    ASSERT(irp->MdlAddress == NULL);

    /*
     * Determine whether the target device performs direct or buffered I/O.
     */
    if (pTd->pDeviceObject->Flags & DO_BUFFERED_IO) {
        /*
         * The target device supports buffered I/O operations.  Since our
         * input buffer is allocated from NonPagedPool memory, we can just
         * point the SystemBuffer to our input buffer.  No buffer copying
         * will be required.
         */
        irp->AssociatedIrp.SystemBuffer = pInBuf->pBuffer;
        irp->UserBuffer = pInBuf->pBuffer;
        irp->Flags |= IRP_BUFFERED_IO;
    } else if ( pTd->pDeviceObject->Flags & DO_DIRECT_IO ) {
        /*
         * The target device supports direct I/O operations.
         * A MDL is preallocated in the PTD and never freed by the
         * Device level TD.  So just initialize it here.
         */
        MmInitializeMdl( pInBuf->pMdl, pInBuf->pBuffer, pTd->InBufHeader+pTd->OutBufLength );
        MmBuildMdlForNonPagedPool( pInBuf->pMdl );
        irp->MdlAddress = pInBuf->pMdl;
    } else {
        /*
         * The operation is neither buffered nor direct.  Simply pass the
         * address of the buffer in the packet to the driver.
         */
        irp->UserBuffer = pInBuf->pBuffer;
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceSubmitRead
 *
 * Submit the read IRP to the driver.
 ******************************************************************************/
NTSTATUS DeviceSubmitRead(PTD pTd, PINBUF pInBuf)
{
    return IoCallDriver(pTd->pDeviceObject, pInBuf->pIrp);
}


/*******************************************************************************
 * DeviceWaitForRead
 ******************************************************************************/
NTSTATUS DeviceWaitForRead(PTD pTd)
{
    /*
     * Just wait on the input event and return the wait status
     */
    return IcaWaitForSingleObject(pTd->pContext, &pTd->InputEvent, -1);
}


/*******************************************************************************
 * DeviceReadComplete
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pBuffer (input)
 *       Pointer to input buffer
 *    pByteCount (input/output)
 *       Pointer to location to return byte count read
 ******************************************************************************/
NTSTATUS DeviceReadComplete(PTD pTd, PUCHAR pBuffer, PULONG pByteCount)
{
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceInitializeWrite
 ******************************************************************************/
NTSTATUS DeviceInitializeWrite(PTD pTd, POUTBUF pOutBuf)
{
    PIRP Irp;
    PIO_STACK_LOCATION _IRPSP;

    TRACE(( pTd->pContext, TC_TD, TT_API1,
            "TDPIPE: DeviceInitializeWrite Entry\n" ));

    Irp = pOutBuf->pIrp;
    _IRPSP = IoGetNextIrpStackLocation(Irp);

    /*
     * Setup a WRITE IRP
     */
    _IRPSP->MajorFunction = IRP_MJ_WRITE;
    _IRPSP->Parameters.Write.Length = pOutBuf->ByteCount;

    ASSERT(Irp->MdlAddress == NULL);

    /*
     * Determine whether the target device performs direct or buffered I/O.
     */
    if (pTd->pDeviceObject->Flags & DO_BUFFERED_IO) {
        /*
         * The target device supports buffered I/O operations.  Since our
         * output buffer is allocated from NonPagedPool memory, we can just
         * point the SystemBuffer to the output buffer.  No buffer copying
         * will be required.
         */
        Irp->AssociatedIrp.SystemBuffer = pOutBuf->pBuffer;
        Irp->UserBuffer = pOutBuf->pBuffer;
        Irp->Flags |= IRP_BUFFERED_IO;
    } else if ( pTd->pDeviceObject->Flags & DO_DIRECT_IO ) {
        /*
         * The target device supports direct I/O operations.
         * Initialize the MDL and point to it from the IRP.
         *
         * This MDL is allocated for every OUTBUF, and free'd with it.
         */
        MmInitializeMdl( pOutBuf->pMdl, pOutBuf->pBuffer, pOutBuf->ByteCount );
        MmBuildMdlForNonPagedPool( pOutBuf->pMdl );
        Irp->MdlAddress = pOutBuf->pMdl;
    } else {
        /*
         * The operation is neither buffered nor direct.  Simply pass the
         * address of the buffer in the packet to the driver.
         */
        Irp->UserBuffer = pOutBuf->pBuffer;
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceWaitForStatus
 *
 *  Wait for device status to change (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceWaitForStatus(PTD pTd)
{
    return STATUS_INVALID_DEVICE_REQUEST;
}


/*******************************************************************************
 * DeviceCancelIo
 *
 *  cancel all current and future i/o
 ******************************************************************************/
NTSTATUS DeviceCancelIo(PTD pTd)
{
    return STATUS_SUCCESS;
}

/*******************************************************************************
 *  DeviceQueryRemoteAddress
 *
 *   not supported for Pipe transport
 ******************************************************************************/
NTSTATUS
DeviceQueryRemoteAddress(
    PTD pTd,
    PVOID pIcaEndpoint,
    ULONG EndpointSize,
    PVOID pOutputAddress,
    ULONG OutputAddressSize,
    PULONG BytesReturned)
{
    //
    //  unsupported for Async
    //
    return STATUS_NOT_SUPPORTED;
}

/*******************************************************************************
 * DeviceSetParams
 *
 *  Set device pararameters (unused for network TDs)
 ******************************************************************************/
NTSTATUS DeviceSetParams(PTD pTd)
{
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * DeviceGetLastError
 *
 *  This routine returns the last transport error code and message
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pLastError (output)
 *       address to return information on last transport error
 ******************************************************************************/
NTSTATUS DeviceGetLastError(PTD pTd, PICA_STACK_LAST_ERROR pLastError)
{
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdOpenEndpoint
 *
 *  Open a new endpoint object
 *
 * ENTRY:
 *    pTd (input)
 *       Pointer to TD data structure
 *    pPipeName (input)
 *       Pointer to ICA_STACK_ADDRESS containing pipe name
 *    ppEndpoint (output)
 *       Pointer to location to return TD_ENDPOINT pointer
 ******************************************************************************/
NTSTATUS _TdOpenEndpoint(
        IN PTD pTd,
        IN PICA_STACK_ADDRESS pPipeName,
        OUT PTD_ENDPOINT *ppEndpoint)
{
    ULONG Length;
    PTD_ENDPOINT pEndpoint;
    NTSTATUS Status;
    

    /*
     * Allocate an endpoint object and room for the pipe name
     */
    if (pPipeName == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    Length = wcslen( (PWSTR)pPipeName ) * sizeof( WCHAR );
    pEndpoint = IcaStackAllocatePoolWithTag(
                    NonPagedPool,
                    sizeof(*pEndpoint) + Length + sizeof(UNICODE_NULL),
                    'ipDT' );
    if (pEndpoint != NULL) {
        RtlZeroMemory(pEndpoint, sizeof(*pEndpoint));
        Status = IcaCreateHandle( (PVOID)pEndpoint, sizeof(*pEndpoint) + Length + sizeof(UNICODE_NULL), &pEndpoint->hConnectionEndPointIcaHandle );
        if (!NT_SUCCESS(Status)) {
            IcaStackFreePool(pEndpoint);
            return Status;
        }

        /*
         * Build the pipe name UNICODE_STRING and copy it
         */
        pEndpoint->PipeName.Length = (USHORT)Length;
        pEndpoint->PipeName.MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        pEndpoint->PipeName.Buffer = (PWCHAR)(pEndpoint + 1);
        RtlCopyMemory( pEndpoint->PipeName.Buffer, pPipeName, Length );

        *ppEndpoint = pEndpoint;
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


/*******************************************************************************
 * _TdCloseEndpoint
 *
 *  Close an endpoint object
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer TD_ENDPOINT object
 ******************************************************************************/
NTSTATUS _TdCloseEndpoint(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS Status;
    NTSTATUS Status2;
    PVOID pContext;
    ULONG ContextLength;

    /*
     * If we have a file object, then dereference it and
     * close the corresponding file handle.
     */
    if ( pEndpoint->pFileObject ) {
        ASSERT( pEndpoint->pDeviceObject );

        /* This ZwFsControlFile and following lines were taken out because
           in npfs.sys the FSCTL_PIPE_DISCONNECT causes data in the pipe's internal
           buffers to be thrown out.  This means if the shadower end of the pipe (the
           passthru stack) has sent out a partial packet to his client, he will never
           get the rest of it, which is BAD!
        */
#ifdef notdef
        Status = ZwFsControlFile(
                    pEndpoint->PipeHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    FSCTL_PIPE_DISCONNECT,
                    NULL,
                    0,
                    NULL,
                    0 );
        if ( Status == STATUS_PENDING ) {
            Status = IcaWaitForSingleObject( pTd->pContext,
                                             &pEndpoint->pFileObject->Event,
                                             -1 );
            if ( NT_SUCCESS( Status ) ) {
                Status = IoStatus.Status;
            }
        }
        /*
         * Status should be either SUCCESS,
         * PIPE_DISCONNECTED if the server end is already disconnected,
         * or ILLEGAL_FUNCTION if this is the client end of the pipe.
         */
        ASSERT( Status == STATUS_SUCCESS ||
                Status == STATUS_PIPE_DISCONNECTED ||
                Status == STATUS_ILLEGAL_FUNCTION ||
                Status == STATUS_CTX_CLOSE_PENDING );
#endif

        ObDereferenceObject( pEndpoint->pFileObject );
        pEndpoint->pFileObject = NULL;
        pEndpoint->pDeviceObject = NULL;

        ASSERT( pEndpoint->PipeHandle );
        ASSERT( pEndpoint->PipeHandleProcess == IoGetCurrentProcess() );
        ZwClose( pEndpoint->PipeHandle );
        pEndpoint->PipeHandle = NULL;
        pEndpoint->PipeHandleProcess = NULL;
    }

    /*
     * If the Enpoint has a handle, close it.
     */

    if (pEndpoint->hConnectionEndPointIcaHandle != NULL) {
        Status2 = IcaCloseHandle( pEndpoint->hConnectionEndPointIcaHandle , &pContext, &ContextLength );
    }

    /*
     * Free the endpoint object (this also free's the pipe name string)
     */
    IcaStackFreePool(pEndpoint);
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * _TdStartListen
 *
 *  Initialize an endpoint for listening
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer TD_ENDPOINT object
 ******************************************************************************/
NTSTATUS _TdStartListen(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    OBJECT_ATTRIBUTES Obja;
    LARGE_INTEGER Timeout;
    IO_STATUS_BLOCK IoStatus;
    HANDLE pipeHandle;
    PFILE_OBJECT pipeFileObject;
    NTSTATUS Status;

    InitializeObjectAttributes(
            &Obja,
            &pEndpoint->PipeName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    Timeout.QuadPart = -10 * 1000 * 5000;   // 5 seconds

    /*
     * Create the server side of the pipe
     */
    Status = ZwCreateNamedPipeFile(
            &pipeHandle,
            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
            &Obja,
            &IoStatus,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_CREATE,
            0,
            FILE_PIPE_MESSAGE_TYPE,
            FILE_PIPE_MESSAGE_MODE,
            FILE_PIPE_QUEUE_OPERATION,
            1,
            1024,        /* inbound  */
            1024 * 20,   /* outbound */
            &Timeout);
    if (NT_SUCCESS(Status)) {
        /*
         * Get a pointer reference to the pipe object
         */
        Status = ObReferenceObjectByHandle(
                pipeHandle,
                0L,                         // DesiredAccess
                NULL,
                KernelMode,
                (PVOID *)&pipeFileObject,
                NULL);
        ASSERT(NT_SUCCESS(Status));

        /*
         * Initialize the endpoint object and return a pointer to it
         */
        pEndpoint->PipeHandle = pipeHandle;
        pEndpoint->PipeHandleProcess = IoGetCurrentProcess();
        pEndpoint->pFileObject = pipeFileObject;
        pEndpoint->pDeviceObject = IoGetRelatedDeviceObject(pipeFileObject);

        Status = STATUS_SUCCESS;
    }
    else {
        TRACE((pTd->pContext, TC_TD, TT_ERROR,
                "TDPIPE: _TdStartListen failed (lx)\n", Status));
    }

    return Status;
}


/*******************************************************************************
 * _TdWaitForListen
 *
 *  For for an incoming connection request and accept it
 *
 *    pTd (input)
 *       Pointer to TD data structure
 *    pEndpoint (input)
 *       Pointer to Address endpoint object
 ******************************************************************************/
NTSTATUS _TdWaitForListen(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    PTDPIPE pTdPipe;
    PFILE_OBJECT pFileObject;
    NTSTATUS Status;

    /*
     *  Get pointer to PIPE parameters
     */
    pTdPipe = (PTDPIPE) pTd->pPrivate;

    /*
     * Wait for a connection attempt to arrive.
     */
    Status = ZwFsControlFile(
            pEndpoint->PipeHandle,
            NULL,
            NULL,
            NULL,
            &pTdPipe->IoStatus,
            FSCTL_PIPE_LISTEN,
            NULL,
            0,
            NULL,
            0);
    if (Status == STATUS_PENDING) {
        /*
         * Increment the pointer reference count so the file
         * doesn't go away while we're waiting below.
         */
        pFileObject = pEndpoint->pFileObject;
        Status = ObReferenceObjectByPointer( pEndpoint->pFileObject,
                                             SYNCHRONIZE,
                                             *IoFileObjectType,
                                             KernelMode );
        ASSERT( Status == STATUS_SUCCESS );

        Status = IcaWaitForSingleObject( pTd->pContext,
                                         &pFileObject->Event,
                                         10000 );

        ObDereferenceObject( pFileObject );
        if ( Status == STATUS_TIMEOUT ) {
            ZwFsControlFile( pEndpoint->PipeHandle,
                             NULL,
                             NULL,
                             NULL,
                             &pTdPipe->IoStatus,
                             FSCTL_PIPE_DISCONNECT,
                             NULL,
                             0,
                             NULL,
                             0 );
            Status = STATUS_IO_TIMEOUT;
        } else if ( NT_SUCCESS( Status ) ) {
            Status = pTdPipe->IoStatus.Status;
        }
    }

    // Let pipe connected go thru since it means the client beat us to the pipe
    else {
        if (!NT_SUCCESS( Status ) && (Status != STATUS_PIPE_CONNECTED))
            goto badlisten;
    }

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

badlisten:
    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
        TRACE(( pTd->pContext, TC_TD, TT_ERROR,
                "TDPIPE: _TdWaitForListen failed(lx)\n", Status));
    }
    return Status;
}


/*******************************************************************************
 * _TdConnectRequest
 *
 *  Attempt to connect to a remote address
 ******************************************************************************/
NTSTATUS _TdConnectRequest(IN PTD pTd, IN PTD_ENDPOINT pEndpoint)
{
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatus;
    HANDLE pipeHandle;
    PFILE_OBJECT pipeFileObject;
    NTSTATUS Status;

    InitializeObjectAttributes(
            &Obja,
            &pEndpoint->PipeName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    /*
     * Open the client end of the pipe
     */
    Status = ZwCreateFile(
            &pipeHandle,
            GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
            &Obja,
            &IoStatus,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE,
            NULL,
            0 );
    if (NT_SUCCESS(Status)) {
        /*
         * Get a pointer reference to the pipe object
         */
        Status = ObReferenceObjectByHandle(
                pipeHandle,
                0L,                         // DesiredAccess
                NULL,
                KernelMode,
                (PVOID *)&pipeFileObject,
                NULL);
        ASSERT(NT_SUCCESS(Status));

        /*
         * Initialize the endpoint object and return a pointer to it
         */
        pEndpoint->PipeHandle = pipeHandle;
        pEndpoint->PipeHandleProcess = IoGetCurrentProcess();
        pEndpoint->pFileObject = pipeFileObject;
        pEndpoint->pDeviceObject = IoGetRelatedDeviceObject( pipeFileObject );

        Status = STATUS_SUCCESS;
    }
    else {
        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {
            TRACE((pTd->pContext, TC_TD, TT_ERROR,
                    "TDPIPE: _TdConnectRequest failed (lx)\n", Status));
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\beep.c ===
/*************************************************************************
*
* beep.c
*
* This module contains routines for managing the Termdd beep channel.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddbeep.h>


NTSTATUS
IcaDeviceControlBeep(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    SD_IOCTL SdIoctl;
    NTSTATUS Status;

    SdIoctl.IoControlCode      = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    SdIoctl.InputBuffer        = Irp->AssociatedIrp.SystemBuffer;
    SdIoctl.InputBufferLength  = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    SdIoctl.OutputBuffer       = Irp->UserBuffer;
    SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\td\tdtcp\tdtcp.h ===
/***************************************************************************
*
* tdtcp.h
*
* This module contains private Transport Driver defines and structures
*
* Copyright 1998, Microsoft
*
*  
****************************************************************************/


#define htons(x)        ((((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00))

// it seems that ntohs is the same as above since ntohs(htons(x)) = x  and htnos(htons(x)) = x
#define ntohs(x)        htons(x)


#define CITRIX_TCP_PORT  1494  // Offical IANA assigned ICA Port number
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\buffer.c ===
/****************************************************************************/
// buffer.c
//
// TermDD default OutBuf management.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop


/*
 * Define default stack size for IRP allocation.
 * (This size will be checked by the TdRawWrite routine.)
 */
#define OUTBUF_STACK_SIZE 4
#define OUTBUF_TIMEOUT 60000   // 1 minute


#if DBG
extern PICA_DISPATCH IcaStackDispatchTable[];
#endif


/****************************************************************************/
// IcaBufferGetUsableSpace
//
// Used by the protocol stack drivers to determine the number of usable bytes
// in a TermDD-created OutBuf, given the total size of the OutBuf. This allows
// a stack driver to target a particular OutBuf size and pack data up to the
// edges of the internal OutBuf headers. The returned size can be used as an
// allocation size request that will return an OutBuf of the right size.
/****************************************************************************/
unsigned IcaBufferGetUsableSpace(unsigned OutBufTotalSize)
{
    unsigned IrpSize;
    unsigned MdlSize;
    unsigned MaxOutBufOverhead;

    // Use the same overhead calculations used in IcaBufferAllocInternal()
    // below, plus a 4-byte offset to cover the extra 1-byte difference
    // required in the requesting size to reach a target buffer size.
    IrpSize = IoSizeOfIrp(OUTBUF_STACK_SIZE) + 8;

    if (OutBufTotalSize <= MaxOutBufAlloc)
        MdlSize = MaxOutBufMdlOverhead;
    else
        MdlSize = (unsigned)MmSizeOfMdl((PVOID)(PAGE_SIZE - 1),
                OutBufTotalSize);

    MaxOutBufOverhead = ((sizeof(OUTBUF) + 7) & ~7) + IrpSize + MdlSize;
    return OutBufTotalSize - MaxOutBufOverhead - 4;
}


/*******************************************************************************
 *  IcaBufferAlloc
 *
 *    pContext (input)
 *       pointer to SDCONTEXT of caller
 *    fWait (input)
 *       wait for buffer
 *    fControl (input)
 *       control buffer flag
 *    ByteCount (input)
 *       size of buffer to allocate (zero - use default size)
 *    pOutBufOrig (input)
 *       pointer to original OUTBUF (or null)
 *    pOutBuf (output)
 *       address to return pointer to OUTBUF structure
 ******************************************************************************/
NTSTATUS IcaBufferAlloc(
        IN PSDCONTEXT pContext,
        IN BOOLEAN fWait,
        IN BOOLEAN fControl,
        IN ULONG ByteCount,
        IN POUTBUF pOutBufOrig,
        OUT POUTBUF *ppOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);
    ASSERT(ExIsResourceAcquiredExclusiveLite( &pStack->Resource));

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a BufferAlloc callup routine.  If we find one, then call the
     * driver BufferAlloc routine to let it handle the call.
     */
    while ((pSdLink = IcaGetPreviousSdLink(pSdLink)) != NULL) {
        ASSERT( pSdLink->pStack == pStack );
        if (pSdLink->SdContext.pCallup->pSdBufferAlloc) {
            IcaReferenceSdLink(pSdLink);
            Status = (pSdLink->SdContext.pCallup->pSdBufferAlloc)(
                    pSdLink->SdContext.pContext,
                    fWait,
                    fControl,
                    ByteCount,
                    pOutBufOrig,
                    ppOutBuf);
            IcaDereferenceSdLink(pSdLink);
            return Status;
        }
    }

    /*
     * We didn't find a callup routine to handle the request,
     * so we'll process it here.
     */
    Status = IcaBufferAllocInternal(pContext, fWait, fControl, ByteCount,
            pOutBufOrig, ppOutBuf);

    TRACESTACK((pStack, TC_ICADD, TT_API3,
            "TermDD: IcaBufferAlloc: 0x%08x, Status=0x%x\n", *ppOutBuf,
            Status));

    return Status;
}


NTSTATUS IcaBufferAllocInternal(
        IN PSDCONTEXT pContext,
        IN BOOLEAN fWait,
        IN BOOLEAN fControl,
        IN ULONG ByteCount,
        IN POUTBUF pOutBufOrig,
        OUT POUTBUF *ppOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    int PoolIndex;
    ULONG irpSize;
    ULONG mdlSize;
    ULONG AllocationSize;
    KIRQL oldIrql;
    PLIST_ENTRY Head;
    POUTBUF pOutBuf;
    NTSTATUS Status;
    unsigned MaxOutBufOverhead;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    /*
     *  If original buffer is specified use it's flags
     */
    if (pOutBufOrig) {
        fWait    = (BOOLEAN) pOutBufOrig->fWait;
        fControl = (BOOLEAN) pOutBufOrig->fControl;
    }

    /*
     *  Check if we already have our maximum number of buffers allocated
     */
    while (!fControl && (pStack->OutBufAllocCount >= pStack->OutBufCount)) {
        /*
         *  increment performance counter 
         */
        pStack->ProtocolStatus.Output.WaitForOutBuf++;

        /*
         *  Return if it's not ok to wait
         */
        if (!fWait)
            return(STATUS_IO_TIMEOUT);

        /*
         *  We hit the high watermark
         */
        pStack->fWaitForOutBuf = TRUE;

        /*
         *  Only wait for non-control requests
         */
        KeClearEvent(&pStack->OutBufEvent);
        Status = IcaWaitForSingleObject(pContext, &pStack->OutBufEvent,
                OUTBUF_TIMEOUT);
        if (NT_SUCCESS(Status)) {
            if (Status != STATUS_WAIT_0)
                return STATUS_IO_TIMEOUT;
        }
        else {
            return Status;
        }
    }

    /*
     * If the caller did not specify a byte count
     * then use the standard outbuf size for this stack.
     */
    if (ByteCount == 0)
        ByteCount = pStack->OutBufLength;

    // Note MaxOutBufOverhead is the max for the default max allocation.
    // It will be recalculated if the requested alloc size is greater
    // than can be handled by the default.
    irpSize = IoSizeOfIrp(OUTBUF_STACK_SIZE) + 8;
    mdlSize = MaxOutBufMdlOverhead;
    MaxOutBufOverhead = ((sizeof(OUTBUF) + 7) & ~7) + irpSize + mdlSize;

    /*
     * Determine which buffer pool to use, if any,
     * and the OutBuf length to allocate, if necessary.
     * Note that the max requested ByteCount that will hit the buffer pool
     * is (MaxOutBufAlloc - 1 - MaxOutBufOverhead).
     */
    if ((ByteCount + MaxOutBufOverhead) < MaxOutBufAlloc) {

        ASSERT(((ByteCount + MaxOutBufOverhead) / MinOutBufAlloc) <
                (1 << NumAllocSigBits));
        PoolIndex = OutBufPoolMapping[(ByteCount + MaxOutBufOverhead) /
                MinOutBufAlloc];

        IcaAcquireSpinLock(&IcaSpinLock, &oldIrql);
        if (!IsListEmpty(&IcaFreeOutBufHead[PoolIndex])) {
            Head = RemoveHeadList(&IcaFreeOutBufHead[PoolIndex]);
            IcaReleaseSpinLock(&IcaSpinLock, oldIrql);
            pOutBuf = CONTAINING_RECORD(Head, OUTBUF, Links);
            ASSERT(pOutBuf->PoolIndex == PoolIndex);
        }
        else {
            IcaReleaseSpinLock(&IcaSpinLock, oldIrql);
            AllocationSize = OutBufPoolAllocSizes[PoolIndex];
            pOutBuf = ICA_ALLOCATE_POOL(NonPagedPool, AllocationSize);
            if (pOutBuf == NULL)
                return STATUS_NO_MEMORY;

            // Prevent leaking control OutBufs on OutBuf free.
            if (fControl)
                PoolIndex = FreeThisOutBuf;
        }
    }
    else {
        PoolIndex = FreeThisOutBuf;

        /*
         * Determine the sizes of the various components of an OUTBUF.
         * Note that these are all worst-case calculations --
         * actual size of the MDL may be smaller.
         */
        mdlSize = (ULONG)MmSizeOfMdl((PVOID)(PAGE_SIZE - 1), ByteCount);

        /*
         * Add up the component sizes of an OUTBUF to determine
         * the total size that is needed to allocate.
         */
        AllocationSize = ((sizeof(OUTBUF) + 7) & ~7) + irpSize + mdlSize +
                ((ByteCount + 3) & ~3);

        pOutBuf = ICA_ALLOCATE_POOL(NonPagedPool, AllocationSize);
        if (pOutBuf == NULL)
            return STATUS_NO_MEMORY;
    }

    /*
     * Initialize the IRP pointer and the IRP itself.
     */
    pOutBuf->pIrp = (PIRP)((BYTE *)pOutBuf + ((sizeof(OUTBUF) + 7) & ~7));
    IoInitializeIrp(pOutBuf->pIrp, (USHORT)irpSize, OUTBUF_STACK_SIZE);

    /*
     * Set up the MDL pointer but don't build it yet.
     * It will be built by the TD write code if needed.
     */
    pOutBuf->pMdl = (PMDL)((PCHAR)pOutBuf->pIrp + irpSize);

    /*
     * Set up the address buffer pointer.
     */
    pOutBuf->pBuffer = (PUCHAR)pOutBuf->pMdl + mdlSize +
            pStack->SdOutBufHeader;

    /*
     *  Initialize the rest of output buffer
     */
    InitializeListHead(&pOutBuf->Links);
    pOutBuf->OutBufLength = ByteCount;
    pOutBuf->PoolIndex = PoolIndex;
    pOutBuf->MaxByteCount = ByteCount - (pStack->SdOutBufHeader +
            pStack->SdOutBufTrailer);
    pOutBuf->ByteCount = 0;
    pOutBuf->fIrpCompleted = FALSE;

    /*
     *  Copy inherited fields 
     */
    if (pOutBufOrig == NULL) {
        pOutBuf->fWait       = fWait;      // wait for outbuf allocation
        pOutBuf->fControl    = fControl;   // control buffer (ack/nak)
        pOutBuf->fRetransmit = FALSE;      // not a retransmit
        pOutBuf->fCompress   = TRUE;       // compress data 
        pOutBuf->StartTime   = 0;          // time stamp
        pOutBuf->Sequence    = 0;          // zero sequence number
        pOutBuf->Fragment    = 0;          // zero fragment number
    }
    else {
        pOutBuf->fWait       = pOutBufOrig->fWait;
        pOutBuf->fControl    = pOutBufOrig->fControl;
        pOutBuf->fRetransmit = pOutBufOrig->fRetransmit;
        pOutBuf->fCompress   = pOutBufOrig->fCompress;
        pOutBuf->StartTime   = pOutBufOrig->StartTime;
        pOutBuf->Sequence    = pOutBufOrig->Sequence;
        pOutBuf->Fragment    = pOutBufOrig->Fragment++;
    }

    /*
     *  Increment allocated buffer count
     */
    pStack->OutBufAllocCount++;

    /*
     *  Return buffer to caller
     */
    *ppOutBuf = pOutBuf;

    /*
     *  Return buffer to caller
     */
    return STATUS_SUCCESS;
}


/*******************************************************************************
 * IcaBufferFree
 *
 *    pContext (input)
 *       pointer to SDCONTEXT of caller
 *    pOutBuf (input)
 *       pointer to OUTBUF structure
 ******************************************************************************/
void IcaBufferFree(IN PSDCONTEXT pContext, IN POUTBUF pOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);
    ASSERT(ExIsResourceAcquiredExclusiveLite( &pStack->Resource));

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a BufferFree callup routine.  If we find one, then call the
     * driver BufferFree routine to let it handle the call.
     */
    while ((pSdLink = IcaGetPreviousSdLink(pSdLink)) != NULL) {
        ASSERT(pSdLink->pStack == pStack);
        if (pSdLink->SdContext.pCallup->pSdBufferFree) {
            IcaReferenceSdLink(pSdLink);
            (pSdLink->SdContext.pCallup->pSdBufferFree)(
                    pSdLink->SdContext.pContext,
                    pOutBuf);
            IcaDereferenceSdLink(pSdLink);
            return;
        }
    }

    IcaBufferFreeInternal(pContext, pOutBuf);

    TRACESTACK((pStack, TC_ICADD, TT_API3,
            "TermDD: IcaBufferFree: 0x%08x\n", pOutBuf));
}


/*******************************************************************************
 * IcaBufferError
 *
 *    pContext (input)
 *       pointer to SDCONTEXT of caller
 *    pOutBuf (input)
 *       pointer to OUTBUF structure
 ******************************************************************************/
void IcaBufferError(IN PSDCONTEXT pContext, IN POUTBUF pOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);
    ASSERT(ExIsResourceAcquiredExclusiveLite( &pStack->Resource));

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a BufferError callup routine.  If we find one, then call the
     * driver BufferError routine to let it handle the call.
     */
    while ((pSdLink = IcaGetPreviousSdLink(pSdLink)) != NULL) {
        ASSERT(pSdLink->pStack == pStack);
        if (pSdLink->SdContext.pCallup->pSdBufferError) {
            IcaReferenceSdLink(pSdLink);
            (pSdLink->SdContext.pCallup->pSdBufferError)(
                    pSdLink->SdContext.pContext,
                    pOutBuf);
            IcaDereferenceSdLink(pSdLink);
            return;
        }
    }

    IcaBufferFreeInternal(pContext, pOutBuf);

    TRACESTACK((pStack, TC_ICADD, TT_API3,
            "TermDD: IcaBufferError: 0x%08x\n", pOutBuf));
}


void IcaBufferFreeInternal(IN PSDCONTEXT pContext, IN POUTBUF pOutBuf)
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    KIRQL oldIrql;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);
    pStack = pSdLink->pStack;
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);

    /*
     * If the buffer came from a free pool, return it to the pool,
     * otherwise free it. Note that pOutBuf->OutBufLength is actually the
     * pool index to use.
     */
    if (pOutBuf->PoolIndex != FreeThisOutBuf) {
        ASSERT(pOutBuf->PoolIndex >= 0 &&
                pOutBuf->PoolIndex < NumOutBufPools);
        IcaAcquireSpinLock(&IcaSpinLock, &oldIrql);
        InsertHeadList(&IcaFreeOutBufHead[pOutBuf->PoolIndex],
                &pOutBuf->Links);
        IcaReleaseSpinLock(&IcaSpinLock, oldIrql);
    }
    else {
        ICA_FREE_POOL(pOutBuf);
    }

    /*
     *  Decrement allocated buffer count
     */
    pStack->OutBufAllocCount--;
    ASSERT((LONG)pStack->OutBufAllocCount >= 0);

    /*
    * If we hit the high watermark then we should wait until the low
    * watermark is hit before signaling the allocator to continue.
    * This should prevent excessive task switching.
    */
    if (pStack->fWaitForOutBuf) {
        if (pStack->OutBufAllocCount <= pStack->OutBufLowWaterMark) {
            pStack->fWaitForOutBuf = FALSE;

        /*
        *  Signal outbuf event (buffer is now available)
        */
        (void) KeSetEvent(&pStack->OutBufEvent, EVENT_INCREMENT, FALSE);
        }
    }
}


/*******************************************************************************
* IcaGetLowWaterMark
*
*   Description : Gets the low water mark that the stack specified
*
*   pContext (input)
*       pointer to SDCONTEXT of caller
******************************************************************************/
ULONG IcaGetLowWaterMark(IN PSDCONTEXT pContext)
{
    ULONG ulRet = 0;
    PICA_STACK pStack;
    PSDLINK pSdLink = CONTAINING_RECORD(pContext, SDLINK, SdContext);

    ASSERT(pSdLink);
    
    ASSERT(pSdLink->pStack->Header.Type == IcaType_Stack);
    
    ASSERT(pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable);

    ASSERT(ExIsResourceAcquiredExclusive( &pSdLink->pStack->Resource));
    
    if (NULL != pSdLink) {
        pStack = pSdLink->pStack;
        ulRet = pStack->OutBufLowWaterMark;
    }
    return ulRet;
}

/*******************************************************************************
* IcaGetSizeForNoLowWaterMark
*
*   Description : Finds if the stack specified a no low water mark
*				  If so, returns the size needed to bypass ring
*                 returns zero if the stack does not specify a PD_NO_LOWWATERMARK
*   pContext (input)
*       pointer to SDCONTEXT of caller
******************************************************************************/
ULONG IcaGetSizeForNoLowWaterMark(IN PSDCONTEXT pContext)
{
	ULONG retVal = 0;
    ULONG ulLowWm = IcaGetLowWaterMark(pContext);

	if ( MAX_LOW_WATERMARK == ulLowWm ) {
		retVal = MaxOutBufAlloc;
	}
	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\channel.c ===
/****************************************************************************/
// channel.c
//
// Terminal Server channel handling.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop
#include <ntddkbd.h>
#include <ntddmou.h>

#include "ptdrvcom.h"


#define min(a,b)            (((a) < (b)) ? (a) : (b))


NTSTATUS
IcaExceptionFilter( 
    IN PWSTR OutputString,
    IN PEXCEPTION_POINTERS pexi
    );

NTSTATUS
IcaReadChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaWriteChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaDeviceControlChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaFlushChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanupChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCloseChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
IcaFreeAllVcBind(
    IN PICA_CONNECTION pConnect
    );

NTSTATUS 
IcaCancelReadChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Local procedure prototypes
 */
NTSTATUS
_IcaReadChannelComplete(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS _IcaQueueReadChannelRequest(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
_IcaCopyDataToUserBuffer(
    IN PIRP Irp,
    IN PUCHAR pBuffer,
    IN ULONG ByteCount
    );

VOID
_IcaReadChannelCancelIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID _IcaProcessIrpList(
    IN PICA_CHANNEL pChannel
    );

PICA_CHANNEL
_IcaAllocateChannel(
    IN PICA_CONNECTION pConnect,
    IN CHANNELCLASS ChannelClass,
    IN PVIRTUALCHANNELNAME pVirtualName
    );

void _IcaFreeChannel(IN PICA_CHANNEL);

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaCallStackNoLock(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaRegisterVcBind(
    IN PICA_CONNECTION pConnect,
    IN PVIRTUALCHANNELNAME pVirtualName,
    IN VIRTUALCHANNELCLASS VirtualClass,
    IN ULONG Flags
    );

VIRTUALCHANNELCLASS
_IcaFindVcBind(
    IN PICA_CONNECTION pConnect,
    IN PVIRTUALCHANNELNAME pVirtualName,
    OUT PULONG pFlags
    );

VOID
_IcaBindChannel(
    IN PICA_CHANNEL pChannel,
    IN CHANNELCLASS ChannelClass,
    IN VIRTUALCHANNELCLASS VirtualClass,
    IN ULONG Flags
    );



/*
 * Dispatch table for ICA channel objects
 */
PICA_DISPATCH IcaChannelDispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1] = {
    NULL,                       // IRP_MJ_CREATE
    NULL,                       // IRP_MJ_CREATE_NAMED_PIPE
    IcaCloseChannel,            // IRP_MJ_CLOSE
    IcaReadChannel,             // IRP_MJ_READ
    IcaWriteChannel,            // IRP_MJ_WRITE
    NULL,                       // IRP_MJ_QUERY_INFORMATION
    NULL,                       // IRP_MJ_SET_INFORMATION
    NULL,                       // IRP_MJ_QUERY_EA
    NULL,                       // IRP_MJ_SET_EA
    IcaFlushChannel,            // IRP_MJ_FLUSH_BUFFERS
    NULL,                       // IRP_MJ_QUERY_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_SET_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_DIRECTORY_CONTROL
    NULL,                       // IRP_MJ_FILE_SYSTEM_CONTROL
    IcaDeviceControlChannel,    // IRP_MJ_DEVICE_CONTROL
    NULL,                       // IRP_MJ_INTERNAL_DEVICE_CONTROL
    NULL,                       // IRP_MJ_SHUTDOWN
    NULL,                       // IRP_MJ_LOCK_CONTROL
    IcaCleanupChannel,          // IRP_MJ_CLEANUP
    NULL,                       // IRP_MJ_CREATE_MAILSLOT
    NULL,                       // IRP_MJ_QUERY_SECURITY
    NULL,                       // IRP_MJ_SET_SECURITY
    NULL,                       // IRP_MJ_SET_POWER
    NULL,                       // IRP_MJ_QUERY_POWER
};

#if DBG
extern PICA_DISPATCH IcaStackDispatchTable[];
#endif


NTSTATUS IcaCreateChannel(
        IN PICA_CONNECTION pConnect,
        IN PICA_OPEN_PACKET openPacket,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)

/*++

Routine Description:

    This routine is called to create a new ICA_CHANNEL object.
    - the reference count is incremented by one

Arguments:

    pConnect -- pointer to ICA_CONNECTION object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_CHANNEL pChannel;
    CHANNELCLASS ChannelClass;
    NTSTATUS Status;

    /*
     * Validate ChannelClass
     */
    ChannelClass = openPacket->TypeInfo.ChannelClass;
    if ( !(ChannelClass >= Channel_Keyboard && ChannelClass <= Channel_Virtual) )
        return( STATUS_INVALID_PARAMETER );

    /*
     * Ensure VirtualName has a trailing NULL
     */
    if ( !memchr( openPacket->TypeInfo.VirtualName,
                  '\0',
                  sizeof( openPacket->TypeInfo.VirtualName ) ) )
        return( STATUS_INVALID_PARAMETER );


    /*
     * Must lock connection object to create new channel.
     */
    IcaLockConnection( pConnect );

    TRACE(( pConnect, TC_ICADD, TT_API2, "TermDD: IcaCreateChannel: cc %u, vn %s\n",
            ChannelClass, openPacket->TypeInfo.VirtualName ));

    /*
     *  Locate channel object
     */
    pChannel = IcaFindChannelByName(pConnect,
            ChannelClass,
            openPacket->TypeInfo.VirtualName);

    /*
     * See if this channel has already been created.
     * If not, then create/initialize it now.
     */
    if ( pChannel == NULL ) {
        /*
         * Allocate a new ICA channel object
         */
        pChannel = _IcaAllocateChannel(pConnect,
                ChannelClass,
                openPacket->TypeInfo.VirtualName);
        if (pChannel == NULL) {
            IcaUnlockConnection(pConnect);
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }

    /*
     * Increment open count for this channel
     */
    if (InterlockedIncrement(&pChannel->OpenCount) <= 0) {
        ASSERT( FALSE );
    }

    /*
     * If the CHANNEL_CLOSING flag is set, then we are re-referenceing
     * a channel object that was just closed by a previous caller,
     * but has not yet been completely dereferenced.
     * This can happen if this create call comes in between the
     * calls to IcaCleanupChannel and IcaCloseChannel which happen
     * when a channel handle is closed.
     */
    if ( pChannel->Flags & CHANNEL_CLOSING ) {
        /*
         * Lock channel while we clear out the CHANNEL_CLOSING flag.
         */
        IcaLockChannel(pChannel);
        pChannel->Flags &= ~CHANNEL_CLOSING;
        IcaUnlockChannel(pChannel);
    }

    IcaUnlockConnection(pConnect);

    /*
     * Save a pointer to the channel in the file object
     * so that we can find it in future calls.
     * - leave the reference on the channel object
     */
    IrpSp->FileObject->FsContext = pChannel;

    /*
     *  Exit with the channel reference count incremented by one
     */
    return STATUS_SUCCESS;
}


NTSTATUS IcaReadChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)

/*++

Routine Description:

    This is the read routine for ICA channels.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    KIRQL cancelIrql;
    NTSTATUS Status = STATUS_PENDING;
    ULONG bChannelAlreadyLocked;


    /*
     * Determine the channel type to see if read is supported.
     * Also do read size verification for keyboard/mouse.
     */
    switch ( pChannel->ChannelClass ) {
        /*
         * Make sure input size is a multiple of KEYBOARD_INPUT_DATA
         */
        case Channel_Keyboard :
            if ( IrpSp->Parameters.Read.Length % sizeof(KEYBOARD_INPUT_DATA) )
                Status = STATUS_BUFFER_TOO_SMALL;
            break;

        /*
         * Make sure input size is a multiple of MOUSE_INPUT_DATA
         */
        case Channel_Mouse :
            if ( IrpSp->Parameters.Read.Length % sizeof(MOUSE_INPUT_DATA) )
                Status = STATUS_BUFFER_TOO_SMALL;
            break;

        /*
         * Nothing required for Command/Virtual channels
         */
        case Channel_Command :
        case Channel_Virtual :
            break;

        /*
         * Read not supported for the following channels
         */
        case Channel_Video :
        case Channel_Beep :
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            ASSERTMSG( "TermDD: Invalid Channel Class", FALSE );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    /*
     * If read length is 0, or an error is being returned, return now.
     */
    if (Status == STATUS_PENDING && IrpSp->Parameters.Read.Length == 0)
        Status = STATUS_SUCCESS;
    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IcaPriorityBoost);
        TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR,
                "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                pChannel->ChannelClass, pChannel->VirtualClass, Status ));
        return Status;
    }

    /*
     * Verify user's buffer is valid
     */
    if (Irp->RequestorMode != KernelMode) {
        try {
            ProbeForWrite(Irp->UserBuffer, IrpSp->Parameters.Read.Length, sizeof(BYTE));
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Status = GetExceptionCode();
            Irp->IoStatus.Status = Status;
            IoCompleteRequest(Irp, IcaPriorityBoost);
            TRACECHANNEL((pChannel, TC_ICADD, TT_ERROR,
                    "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                    pChannel->ChannelClass, pChannel->VirtualClass, Status));
            return Status;
        }
    }

    /*
     * Lock the channel while we determine how to handle this read request.
     * One of the following will be true:
     *   1) Input data is available; copy it to user buffer and complete IRP,
     *   2) No data available, IRP cancel is requested; cancel/complete IRP,
     *   3) No data; add IRP to pending read list, return STATUS_PENDING.
     */
    if (ExIsResourceAcquiredExclusiveLite(&(pChannel->Resource))) {
        bChannelAlreadyLocked = TRUE;
        IcaReferenceChannel(pChannel); 
    }
    else {
        bChannelAlreadyLocked = FALSE;
        IcaLockChannel(pChannel);
    }

    /*
     * If the channel is being closed,
     * then don't allow any further read requests.
     */
    if (pChannel->Flags & CHANNEL_CLOSING) {
        Status = STATUS_FILE_CLOSED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IcaPriorityBoost);
        TRACECHANNEL((pChannel, TC_ICADD, TT_ERROR,
                "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                pChannel->ChannelClass, pChannel->VirtualClass, Status));
        IcaUnlockChannel(pChannel);
        return Status;
    }

    /*
     * If the Winstation is terminating and Reads are cancelled
     * then don't allow any further read requests.
     */
    if (pChannel->Flags & CHANNEL_CANCEL_READS) {
        Status = STATUS_FILE_CLOSED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IcaPriorityBoost);
        TRACECHANNEL((pChannel, TC_ICADD, TT_ERROR,
                "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                pChannel->ChannelClass, pChannel->VirtualClass, Status));
        IcaUnlockChannel(pChannel);
        return Status;
    }



    if (InterlockedCompareExchange(&(pChannel->CompletionRoutineCount), 1, 0) == 0) {
    
        /*
         * If there is already input data available,
         * then use it to satisfy the caller's read request.
         */
        if ( !IsListEmpty( &pChannel->InputBufHead ) ) {
            _IcaProcessIrpList(pChannel);

            if (!IsListEmpty( &pChannel->InputBufHead )) {
                Status = _IcaReadChannelComplete( pChannel, Irp, IrpSp );

                TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3, "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                       pChannel->ChannelClass, pChannel->VirtualClass, Status ));

                _IcaProcessIrpList(pChannel);                        
            }
            else {
                Status = _IcaQueueReadChannelRequest(pChannel, Irp, IrpSp);    
            }            
        }
        else {
            Status = _IcaQueueReadChannelRequest(pChannel, Irp, IrpSp);    
        }
        
        InterlockedDecrement(&(pChannel->CompletionRoutineCount));
        ASSERT(pChannel->CompletionRoutineCount == 0);                                    
    }
    else {
        Status = _IcaQueueReadChannelRequest(pChannel, Irp, IrpSp);            
    }
    
    /*
     * Unlock channel now
     */
    if (bChannelAlreadyLocked) {
        IcaDereferenceChannel( pChannel ); 
    }
    else {
        IcaUnlockChannel(pChannel);
    }
    return Status;
}

void _IcaProcessIrpList(
        IN PICA_CHANNEL pChannel)
{
    KIRQL cancelIrql;
    PIRP irpFromQueue;
    PIO_STACK_LOCATION irpSpFromQueue;
    PLIST_ENTRY irpQueueHead;
    NTSTATUS irpStatus;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pChannel->Resource ) );

    /*
     * Acquire IoCancel spinlock while checking InputIrp list
     */
    IoAcquireCancelSpinLock( &cancelIrql );

    /*
     * If there is a pending read IRP, then remove it from the
     * list and try to complete it now.
     */
    
    while (!IsListEmpty( &pChannel->InputIrpHead ) && 
            !IsListEmpty( &pChannel->InputBufHead )) {

        irpQueueHead = RemoveHeadList( &pChannel->InputIrpHead );
        irpFromQueue = CONTAINING_RECORD( irpQueueHead, IRP, Tail.Overlay.ListEntry );
        irpSpFromQueue = IoGetCurrentIrpStackLocation( irpFromQueue );

        /*
         * Clear the cancel routine for this IRP
         */
        IoSetCancelRoutine( irpFromQueue, NULL );

        IoReleaseCancelSpinLock( cancelIrql );

        irpStatus = _IcaReadChannelComplete( pChannel, irpFromQueue, irpSpFromQueue );

        TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3, "TermDD: IcaReadChannel, cc %u, vc %d, 0x%x\n",
                       pChannel->ChannelClass, pChannel->VirtualClass, irpStatus ));

        /*
         * Acquire IoCancel spinlock while checking InputIrp list
         */
        IoAcquireCancelSpinLock( &cancelIrql );                                        
    }

    IoReleaseCancelSpinLock( cancelIrql );                       
}

NTSTATUS _IcaQueueReadChannelRequest(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    NTSTATUS Status = STATUS_PENDING;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pChannel->Resource ) );

    /*
     * Acquire the IoCancel spinlock.
     * We use this spinlock to protect access to the InputIrp list.
     */
    IoAcquireCancelSpinLock(&cancelIrql);

    /*
     * No input data is available.
     * Add the Irp to the pending Irp list for this channel.
     */
    InsertTailList(&pChannel->InputIrpHead, &Irp->Tail.Overlay.ListEntry);
    IoMarkIrpPending(Irp);
    /*
     * If this IRP is being cancelled, then cancel it now.
     * Otherwise, set the cancel routine for this request.
     */
    if (Irp->Cancel) {
        Irp->CancelIrql = cancelIrql;
        _IcaReadChannelCancelIrp(IrpSp->DeviceObject, Irp);
        TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3,
                "TermDD: _IcaQueueReadChannelRequest, cc %u, vc %d (canceled)\n",
                pChannel->ChannelClass, pChannel->VirtualClass));
        return STATUS_CANCELLED;
    }

    IoSetCancelRoutine(Irp, _IcaReadChannelCancelIrp);
    IoReleaseCancelSpinLock(cancelIrql);

    TRACECHANNEL((pChannel, TC_ICADD, TT_IN3,
            "TermDD: _IcaQueueReadChannelRequest, cc %u, vc %d (pending)\n",
            pChannel->ChannelClass, pChannel->VirtualClass));
    
    return STATUS_PENDING;

}

NTSTATUS _IcaReadChannelComplete(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PINBUF pInBuf;
    PVOID pBuffer;
    ULONG CopyCount;
    NTSTATUS Status;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pChannel->Resource ) );

    TRACECHANNEL(( pChannel, TC_ICADD, TT_IN4, "TermDD: _IcaReadChannelComplete, cc %u, vc %d\n",
                   pChannel->ChannelClass, pChannel->VirtualClass ));

    /*
     * Get pointer to first input buffer
     */
    ASSERT( !IsListEmpty( &pChannel->InputBufHead ) );
    Head = pChannel->InputBufHead.Flink;
    pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
     
    /*
     * Clear the cancel routine for this IRP,
     * since one way or the other it will be completed.
     */
    IoAcquireCancelSpinLock( &cancelIrql );
    IoSetCancelRoutine( Irp, NULL );
    IoReleaseCancelSpinLock( cancelIrql );

    /*
     * If this is a message mode channel, all data from a single input
     * buffer must fit in the user buffer, otherwise we return an error.
     */
    if (IrpSp->Parameters.Read.Length < pInBuf->ByteCount &&
            (pChannel->Flags & CHANNEL_MESSAGE_MODE)) {
        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR,
                       "TermDD: _IcaReadChannelComplete: cc %u, vc %d (buffer too small)\n",
                       pChannel->ChannelClass, pChannel->VirtualClass ));
        return STATUS_BUFFER_TOO_SMALL;
    }

    /*
     * Determine amount of data to copy to user's buffer.
     */
    CopyCount = min(IrpSp->Parameters.Read.Length, pInBuf->ByteCount);

    /*
     * Copy input data to user's buffer
     */
    Status = _IcaCopyDataToUserBuffer(Irp, pInBuf->pBuffer, CopyCount);

    
    /*
     * Update ICA buffer pointer and bytes remaining.
     * If no bytes remain, then unlink the input buffer and free it.
     */
    if ( Status == STATUS_SUCCESS ) {
        pChannel->InputBufCurSize -= CopyCount;
        pInBuf->pBuffer += CopyCount;
        pInBuf->ByteCount -= CopyCount;
        if ( pInBuf->ByteCount == 0 ) {
            RemoveEntryList( &pInBuf->Links );
            ICA_FREE_POOL( pInBuf );
        }
    }

    /*
     * Mark the Irp complete
     */
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, IcaPriorityBoost );
    TRACECHANNEL(( pChannel, TC_ICADD, TT_IN3,
                   "TermDD: _IcaReadChannelComplete: cc %u, vc %d, bc %u, 0x%x\n",
                   pChannel->ChannelClass, pChannel->VirtualClass, CopyCount, Status ));    
    
    return Status;
}


NTSTATUS _IcaCopyDataToUserBuffer(
        IN PIRP Irp,
        IN PUCHAR pBuffer,
        IN ULONG ByteCount)
{
    NTSTATUS Status;

    /*
     * If we are in the context of the original caller's process,
     * then just copy the data into the user's buffer directly.
     */
    if ( IoGetRequestorProcess( Irp ) == IoGetCurrentProcess() ) {
        try {
            Status = STATUS_SUCCESS;
            RtlCopyMemory( Irp->UserBuffer, pBuffer, ByteCount );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = GetExceptionCode();
        }

    /*
     * If there is a MDL allocated for this IRP, then copy the data
     * directly to the users buffer via the MDL.
     */
    } else if ( Irp->MdlAddress ) {
        PVOID UserBuffer;

        UserBuffer = MmGetSystemAddressForMdl( Irp->MdlAddress );
        try {
            if (UserBuffer != NULL) {
                Status = STATUS_SUCCESS;
                RtlCopyMemory( UserBuffer, pBuffer, ByteCount );
            }else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = GetExceptionCode();
        }

    /*
     * There is no MDL for this request.  We must allocate a secondary
     * buffer, copy the data to it, and indicate this is a buffered I/O
     * request in the IRP.  The I/O completion routine will copy the
     * data to the user's buffer.
     */
    } else {
        ASSERT( Irp->AssociatedIrp.SystemBuffer == NULL );
        Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( PagedPool,
                                                                 ByteCount,
                                                                 ICA_POOL_TAG );
        if ( Irp->AssociatedIrp.SystemBuffer == NULL )
            return( STATUS_INSUFFICIENT_RESOURCES );
        RtlCopyMemory( Irp->AssociatedIrp.SystemBuffer, pBuffer, ByteCount );
        Irp->Flags |= (IRP_BUFFERED_IO |
                       IRP_DEALLOCATE_BUFFER |
                       IRP_INPUT_OPERATION);
        Status = STATUS_SUCCESS;
    }

    if ( Status == STATUS_SUCCESS )
        Irp->IoStatus.Information = ByteCount;

    return Status;
}


VOID _IcaReadChannelCancelIrp(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    PIO_STACK_LOCATION IrpSp;
    PICA_CHANNEL pChannel;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    pChannel = IrpSp->FileObject->FsContext;

    /*
     * Remove IRP from channel pending IRP list and release cancel spinlock
     */
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    /*
     * Complete the IRP with a cancellation status code.
     */
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IcaPriorityBoost);
}


NTSTATUS IcaWriteChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)

/*++

Routine Description:

    This is the write routine for ICA channels.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet.  Flags, specific to this
    driver, can be specified as a pointer to a ULONG flags value.  
    The pointer to this value is the first element in the 
    IRP.Tail.Overlay.DriverContext field.  
    
    Currently, only CHANNEL_WRITE_LOWPRIO is supported.  Write IRP's with
    this flag set will take lower priority than Write IRP's without this
    flag set.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    SD_CHANNELWRITE SdWrite;
    NTSTATUS Status = STATUS_PENDING;

    /*
     * Determine the channel type to see if write is supported.
     */
    switch ( pChannel->ChannelClass ) {

        case Channel_Virtual :
            if ( pChannel->VirtualClass == UNBOUND_CHANNEL ) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

        /*
         * Write not supported for the following channels
         */
        case Channel_Command :
        case Channel_Keyboard :
        case Channel_Mouse :
        case Channel_Video :
        case Channel_Beep :
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            ASSERTMSG( "ICA.SYS: Invalid Channel Class", FALSE );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    /*
     * If the channel is being closed,
     * then don't allow any further write requests.
     */
    if ( pChannel->Flags & CHANNEL_CLOSING )
        Status = STATUS_FILE_CLOSED;

    /*
     * If write length is 0, or an error is being returned, return now.
     */
    if ( Status == STATUS_PENDING && IrpSp->Parameters.Write.Length == 0 )
        Status = STATUS_SUCCESS;
    if ( Status != STATUS_PENDING ) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "TermDD: IcaWriteChannel, cc %u, vc %d, 0x%x\n",
                       pChannel->ChannelClass, pChannel->VirtualClass, Status ));
        return( Status );
    }

    /*
     * Verify user's buffer is valid
     */
    if ( Irp->RequestorMode != KernelMode ) {
        try {
            ProbeForRead( Irp->UserBuffer, IrpSp->Parameters.Write.Length, sizeof(BYTE) );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = GetExceptionCode();
            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, IcaPriorityBoost );
            TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "TermDD: IcaWriteChannel, cc %u, vc %d, 0x%x\n",
                           pChannel->ChannelClass, pChannel->VirtualClass, Status ));
            return( Status );
        }
    }

    /*
     * Call the top level stack driver to handle the write
     */
    SdWrite.ChannelClass = pChannel->ChannelClass;
    SdWrite.VirtualClass = pChannel->VirtualClass;
    SdWrite.pBuffer = Irp->UserBuffer;
    SdWrite.ByteCount = IrpSp->Parameters.Write.Length;
    SdWrite.fScreenData = (BOOLEAN)(pChannel->Flags & CHANNEL_SCREENDATA);
    SdWrite.fFlags = 0;

    /*
     * See if the low prio write flag is set in the IRP.
     *
	 * The flags field is passed to termdd.sys via an IRP_MJ_WRITE 
	 * Irp, as a ULONG pointer in the Irp->Tail.Overlay.DriverContext[0] field.     
     */
    if (Irp->Tail.Overlay.DriverContext[0] != NULL) {
        ULONG flags = *((ULONG *)Irp->Tail.Overlay.DriverContext[0]);
        if (flags & CHANNEL_WRITE_LOWPRIO) {
            SdWrite.fFlags |= SD_CHANNELWRITE_LOWPRIO;
        }
    }

    Status = IcaCallDriver( pChannel, SD$CHANNELWRITE, &SdWrite );

    /*
     * Complete the IRP now since all channel writes are synchronous
     * (the user data is captured by the stack driver before returning).
     */
    Irp->IoStatus.Status = Status;
    if ( Status == STATUS_SUCCESS )
        Irp->IoStatus.Information = IrpSp->Parameters.Write.Length;
    IoCompleteRequest( Irp, IcaPriorityBoost );

    TRACECHANNEL(( pChannel, TC_ICADD, TT_OUT3, "TermDD: IcaWriteChannel, cc %u, vc %d, bc %u, 0x%x\n",
                   pChannel->ChannelClass, pChannel->VirtualClass, SdWrite.ByteCount, Status ));

    return Status;
}


NTSTATUS IcaDeviceControlChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    ULONG code;
    PICA_TRACE_BUFFER pTraceBuffer;
    NTSTATUS Status;


    /*
     * If the channel is being closed,
     * then don't allow any further requests.
     */
    if ( pChannel->Flags & CHANNEL_CLOSING )
        return( STATUS_FILE_CLOSED );

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;


#if DBG
    if ( code != IOCTL_ICA_CHANNEL_TRACE ) {
        TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "TermDD: IcaDeviceControlChannel, fc %d, ref %u (enter)\n",
                       (code & 0x3fff) >> 2, pChannel->RefCount ));
    }
#endif
    

    /*
     *  Process generic channel ioctl requests
     */
    try {
        switch ( code ) {

            case IOCTL_ICA_CHANNEL_TRACE :

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)(FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0])) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) )
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                }

                pTraceBuffer = (PICA_TRACE_BUFFER)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                IcaLockConnection( pChannel->pConnect );
                IcaTraceFormat( &pChannel->pConnect->TraceInfo,
                                pTraceBuffer->TraceClass,
                                pTraceBuffer->TraceEnable,
                                pTraceBuffer->Data );
                IcaUnlockConnection( pChannel->pConnect );

                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO:

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags |= CHANNEL_SESSION_DISABLEIO;
                Status = IcaFlushChannel( pChannel, Irp, IrpSp );
                IcaUnlockConnection( pChannel->pConnect );
                break;

            case IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO:

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags &= ~CHANNEL_SESSION_DISABLEIO;
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL : 
                
                IcaLockConnection( pChannel->pConnect );
                Status = IcaCancelReadChannel(pChannel, Irp, IrpSp);                
                IcaUnlockConnection( pChannel->pConnect );
                break;

            case IOCTL_ICA_CHANNEL_ENABLE_SHADOW :

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags |= CHANNEL_SHADOW_IO;
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_DISABLE_SHADOW :

                IcaLockConnection( pChannel->pConnect );
                pChannel->Flags &= ~CHANNEL_SHADOW_IO;
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_CHANNEL_END_SHADOW : 
            {
                PLIST_ENTRY Head, Next;
                PICA_STACK pStack;
                BOOLEAN bShadowEnded = FALSE;
                PICA_CHANNEL_END_SHADOW_DATA pData;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(ICA_CHANNEL_END_SHADOW_DATA) ) {
                    Status = STATUS_INVALID_BUFFER_SIZE;
                    break;
                }
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                }

                pData = (PICA_CHANNEL_END_SHADOW_DATA)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                /*
                 * Lock the connection object.
                 * This will serialize all channel calls for this connection.
                 */
                IcaLockConnection( pChannel->pConnect );
                if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                    IcaUnlockConnection( pChannel->pConnect );
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }

                /*
                 * Look for shadow stack(s).
                 */
                Head = &pChannel->pConnect->StackHead;
                for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
                    pStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

                    /*
                     * If this is a shadow stack, end it.
                     */
                    if ( pStack->StackClass == Stack_Shadow ) {
                        if ( pStack->pBrokenEventObject ) {
                            KeSetEvent( pStack->pBrokenEventObject, 0, FALSE );
                            bShadowEnded = TRUE;
                        }
                    }
                }

                /*
                 * Unlock the connection object now.
                 */
                IcaUnlockConnection( pChannel->pConnect );
                Status = STATUS_SUCCESS;

                if (bShadowEnded && pData->bLogError) {
                    IcaLogError(NULL, pData->StatusCode, NULL, 0, NULL, 0);
                }
                break;
            }

            // This IOCTL is not supported by RDP or ICA driver
            case IOCTL_VIDEO_ENUM_MONITOR_PDO:

                Status = STATUS_DEVICE_NOT_READY;
                break;
    

            default :

                /*
                 * Call the appropriate worker routine based on channel type
                 */
                switch ( pChannel->ChannelClass ) {

                    case Channel_Keyboard :
                        Status = IcaDeviceControlKeyboard( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Mouse :
                        Status = IcaDeviceControlMouse( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Video :
                        Status = IcaDeviceControlVideo( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Beep :
                        Status = IcaDeviceControlBeep( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Virtual :
                        Status = IcaDeviceControlVirtual( pChannel, Irp, IrpSp );
                        break;

                    case Channel_Command :
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        break;

                    default:
                        ASSERTMSG( "ICA.SYS: Invalid Channel Class", FALSE );
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        break;
                }
        }
    } except( IcaExceptionFilter( L"IcaDeviceControlChannel TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        Status = GetExceptionCode();
    }

#if DBG
    if ( code != IOCTL_ICA_CHANNEL_TRACE ) {
        TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "TermDD: IcaDeviceControlChannel, fc %d, ref %u, 0x%x\n",
                       (code & 0x3fff) >> 2, pChannel->RefCount, Status ));
    }
#endif
    

    return Status;
}


NTSTATUS IcaFlushChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PINBUF pInBuf;

    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaFlushChannel, cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Lock channel while we flush any input buffers.
     */
    IcaLockChannel(pChannel);

    while (!IsListEmpty( &pChannel->InputBufHead)) {
        Head = RemoveHeadList(&pChannel->InputBufHead);
        pInBuf = CONTAINING_RECORD(Head, INBUF, Links);
        ICA_FREE_POOL(pInBuf);
    }

    IcaUnlockChannel(pChannel);

    return STATUS_SUCCESS;
}


NTSTATUS IcaCleanupChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PIRP ReadIrp;
    PINBUF pInBuf;

    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaCleanupChannel, cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Decrement the open count; if it is 0, perform channel cleanup now.
     */
    ASSERT(pChannel->OpenCount > 0);
    if (InterlockedDecrement( &pChannel->OpenCount) == 0) {

        /*
         * Lock channel while we clear out any
         * pending read IRPs and/or input buffers.
         */
        IcaLockChannel(pChannel);

        /*
         * Indicate this channel is being closed
         */
        pChannel->Flags |= CHANNEL_CLOSING;

        IoAcquireCancelSpinLock( &cancelIrql );
        while ( !IsListEmpty( &pChannel->InputIrpHead ) ) {
            Head = pChannel->InputIrpHead.Flink;
            ReadIrp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
            ReadIrp->CancelIrql = cancelIrql;
            IoSetCancelRoutine( ReadIrp, NULL );
            _IcaReadChannelCancelIrp( IrpSp->DeviceObject, ReadIrp );
            IoAcquireCancelSpinLock( &cancelIrql );
        }
        IoReleaseCancelSpinLock( cancelIrql );

        while ( !IsListEmpty( &pChannel->InputBufHead ) ) {
            Head = RemoveHeadList( &pChannel->InputBufHead );
            pInBuf = CONTAINING_RECORD( Head, INBUF, Links );
            ICA_FREE_POOL( pInBuf );
        }

        IcaUnlockChannel(pChannel);
    }

    return STATUS_SUCCESS;
}


NTSTATUS IcaCloseChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    PICA_CONNECTION pConnect;

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API2, "TermDD: IcaCloseChannel, cc %u, vc %d, vn %s\n",
                   pChannel->ChannelClass, pChannel->VirtualClass, pChannel->VirtualName ));

    pConnect = pChannel->pConnect;

    /*
     * Remove the file object reference for this channel.
     */
    IcaDereferenceChannel(pChannel);

    return STATUS_SUCCESS;
}


NTSTATUS IcaChannelInput(
        IN PSDCONTEXT pContext,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN PINBUF pInBuf OPTIONAL,
        IN PUCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount)

/*++

Routine Description:

    This is the input (stack callup) routine for ICA channel input.

Arguments:

    pContext - Pointer to SDCONTEXT for this Stack Driver

    ChannelClass - Channel number for input

    VirtualClass - Virtual channel number for input

    pInBuf - Pointer to INBUF containing data

    pBuffer - Pointer to input data

        NOTE: Either pInBuf OR pBuffer must be specified, but not both.

    ByteCount - length of data in pBuffer

Return Value:

    NTSTATUS -- Indicates whether the request was handled successfully.

--*/

{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;   // save stack pointer for use below
    pConnect = IcaGetConnectionForStack( pStack );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: IcaChannelInput, bc=%u (enter)\n", ByteCount ));

    /*
     * Only the stack object should be locked during input.
     */
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a ChannelInput callup routine.  If we find one, then call the
     * driver ChannelInput routine to let it handle the call.
     */
    while ( (pSdLink = IcaGetPreviousSdLink( pSdLink )) != NULL ) {
        ASSERT( pSdLink->pStack == pStack );
        if ( pSdLink->SdContext.pCallup->pSdChannelInput ) {
            IcaReferenceSdLink( pSdLink );
            Status = (pSdLink->SdContext.pCallup->pSdChannelInput)(
                        pSdLink->SdContext.pContext,
                        ChannelClass,
                        VirtualClass,
                        pInBuf,
                        pBuffer,
                        ByteCount );
            IcaDereferenceSdLink( pSdLink );
            return Status;
        }
    }

    return IcaChannelInputInternal(pStack, ChannelClass, VirtualClass,
            pInBuf, pBuffer, ByteCount);
}


NTSTATUS IcaChannelInputInternal(
        IN PICA_STACK pStack,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN PINBUF pInBuf OPTIONAL,
        IN PCHAR pBuffer OPTIONAL,
        IN ULONG ByteCount)
{
    PICA_COMMAND_HEADER pHeader;
    PICA_CONNECTION pConnect;
    PICA_CHANNEL pChannel;
    PLIST_ENTRY Head;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    KIRQL cancelIrql;
    ULONG CopyCount;
    NTSTATUS Status;
    SD_IOCTL SdIoctl;

    TRACESTACK(( pStack, TC_ICADD, TT_API2,
                 "TermDD: IcaChannelInputInternal: cc %u, vc %d, bc %u\n",
                 ChannelClass, VirtualClass, ByteCount ));

    /*
     *  Check for channel command
     */
    switch ( ChannelClass ) {

        case Channel_Keyboard :
        case Channel_Mouse :
            KeQuerySystemTime( &pStack->LastInputTime );
            break;

        case Channel_Command :

            if ( ByteCount < sizeof(ICA_COMMAND_HEADER) ) {
                TRACESTACK(( pStack, TC_ICADD, TT_ERROR,
                             "TermDD: IcaChannelInputInternal: Channel_command bad bytecount\n" ));
                break;
            }

            pHeader = (PICA_COMMAND_HEADER) pBuffer;

            switch ( pHeader->Command ) {
                case ICA_COMMAND_BROKEN_CONNECTION :
                    TRACESTACK(( pStack, TC_ICADD, TT_API1,
                                 "TermDD: IcaChannelInputInternal, Broken Connection\n" ));

                    /* set closing flag */
                    pStack->fClosing = TRUE;

                    /*
                     *  Send cancel i/o to stack drivers
                     *  - fClosing flag must be set before issuing cancel i/o
                     */
                    SdIoctl.IoControlCode = IOCTL_ICA_STACK_CANCEL_IO;
                    (void) _IcaCallStackNoLock( pStack, SD$IOCTL, &SdIoctl );

                    /*
                     * If a broken event has been registered for this stack,
                     * then signal the event now.
                     * NOTE: In this case we exit without forwarding the
                     *       broken notification to the channel.
                     */
                    if ( pStack->pBrokenEventObject ) {
                        KeSetEvent( pStack->pBrokenEventObject, 0, FALSE );
                        ObDereferenceObject( pStack->pBrokenEventObject );
                        pStack->pBrokenEventObject = NULL;
                        if ( pInBuf )
                            ICA_FREE_POOL( pInBuf );
                        return( STATUS_SUCCESS );
                    }
                    break;
            }
            break;
    }

    /*
     * Get the specified channel for this input packet.
     * If not found, we have no choice but to bit-bucket the data.
     */
    pConnect = IcaGetConnectionForStack(pStack);
    pChannel = IcaFindChannel(pConnect, ChannelClass, VirtualClass);
    if (pChannel == NULL) {
        if (pInBuf)
            ICA_FREE_POOL(pInBuf);
        TRACESTACK((pStack, TC_ICADD, TT_ERROR,
                "TermDD: IcaChannelInputInternal: channel not found\n" ));
        return STATUS_SUCCESS;
    }

    /*
     * Lock channel while processing I/O
     */
    IcaLockChannel(pChannel);

    /*
     * If input is from a shadow stack and this channel should not
     * process shadow I/O then bit bucket the data.
     * Do the same if the channel is closing or IO are disabled.
     */
    if ( (pChannel->Flags & (CHANNEL_SESSION_DISABLEIO | CHANNEL_CLOSING)) ||
         (pStack->StackClass == Stack_Shadow &&
           !(pChannel->Flags & CHANNEL_SHADOW_IO)) ) {

        IcaUnlockChannel(pChannel);
        IcaDereferenceChannel(pChannel);
        if (pInBuf)
            ICA_FREE_POOL(pInBuf);
        TRACESTACK((pStack, TC_ICADD, TT_API2,
                "TermDD: IcaChannelInputInternal: shadow or closing channel input\n"));
        return STATUS_SUCCESS;
    }

    /*
     * If input is from an INBUF, initialize pBuffer and ByteCount
     * with values from the buffer header.
     */
    if (pInBuf) {
        pBuffer = pInBuf->pBuffer;
        ByteCount = pInBuf->ByteCount;
    }

    /*
     * If there is a channel filter loaded for this channel,
     * then pass the input data through it before going on.
     */
    if (pChannel->pFilter) {
        PINBUF pFilterBuf;

        pChannel->pFilter->InputFilter(pChannel->pFilter, pBuffer, ByteCount,
                &pFilterBuf);
        if (pInBuf)
            ICA_FREE_POOL(pInBuf);

        /*
         * Refresh INBUF pointer, buffer pointer, and byte count.
         */
        pInBuf = pFilterBuf;
        pBuffer = pInBuf->pBuffer;
        ByteCount = pInBuf->ByteCount;
    }


    /*
     * Process the input data
     */
    while ( ByteCount != 0 ) {

        /*
         * If this is a shadow stack, see if the stack we're shadowing is
         * for a console session
         */
        if (pStack->StackClass == Stack_Shadow)
        {
            PICA_STACK  pTopStack;
            PLIST_ENTRY Head, Next;

            Head = &pConnect->StackHead;
            Next = Head->Flink;

            pTopStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

            if (pTopStack->StackClass == Stack_Console)
            {
                /*
                 * It is the console, so put on our keyboard/mouse port
                 * driver hat and inject the input that way
                 */
                if (ChannelClass == Channel_Mouse)
                {
                    MOUSE_INPUT_DATA *pmInputData;
                    ULONG count;

                    pmInputData = (MOUSE_INPUT_DATA *)pBuffer;
                    count = ByteCount / sizeof(MOUSE_INPUT_DATA);

                    /*
                     * This function will always consume all the data
                     */
                    PtSendCurrentMouseInput(MouDeviceObject, pmInputData, count);
                    ByteCount = 0;
                    continue;
                }
                else if (ChannelClass == Channel_Keyboard)
                {
                    KEYBOARD_INPUT_DATA *pkInputData;
                    ULONG count;

                    pkInputData = (KEYBOARD_INPUT_DATA *)pBuffer;
                    count = ByteCount / sizeof(KEYBOARD_INPUT_DATA);

                    /*
                     * This function will always consume all the data
                     */
                    PtSendCurrentKeyboardInput(KbdDeviceObject, pkInputData, count);
                    ByteCount = 0;
                    continue;
                }
            }
        }
        /*
         * Acquire IoCancel spinlock while checking InputIrp list
         */
        IoAcquireCancelSpinLock( &cancelIrql );

        /*
         * If there is a pending read IRP, then remove it from the
         * list and try to complete it now.
         */
        if ( !IsListEmpty( &pChannel->InputIrpHead ) ) {

            Head = RemoveHeadList( &pChannel->InputIrpHead );
            Irp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            /*
             * Clear the cancel routine for this IRP
             */
            IoSetCancelRoutine( Irp, NULL );
            IoReleaseCancelSpinLock( cancelIrql );

            /*
             * If this is a message mode channel, all data from a single input
             * buffer must fit in the user buffer, otherwise we return an error.
             */
            if ( IrpSp->Parameters.Read.Length < ByteCount &&
                 (pChannel->Flags & CHANNEL_MESSAGE_MODE) ) {
                Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                IoCompleteRequest( Irp, IcaPriorityBoost );
                TRACECHANNEL(( pChannel, TC_ICADD, TT_API2,
                               "TermDD: IcaChannelInputInternal: cc %u, vc %d, (too small)\n",
                               ChannelClass, VirtualClass ));
                continue;
            }

            /*
             * Determine amount of data to copy to user's buffer.
             */
            CopyCount = min( IrpSp->Parameters.Read.Length, ByteCount );

            /*
             * Copy input data to user's buffer
             */
            Status = _IcaCopyDataToUserBuffer( Irp, pBuffer, CopyCount );

            /*
             * Mark the Irp complete and return success
             */
            Irp->IoStatus.Status = Status;
            IoCompleteRequest( Irp, IcaPriorityBoost );
            TRACECHANNEL(( pChannel, TC_ICADD, TT_API2,
                           "TermDD: IcaChannelInputInternal: cc %u, vc %d, bc %u, 0x%x\n",
                           ChannelClass, VirtualClass, CopyCount, Status ));

            /*
             * Update input data pointer and count remaining.
             * Note no need to update pChannel->InputBufCurSize since we never
             * stored this data.
             */
            if ( Status == STATUS_SUCCESS ) {
                pBuffer += CopyCount;
                ByteCount -= CopyCount;
                if ( pInBuf ) {
                    pInBuf->pBuffer += CopyCount;
                    pInBuf->ByteCount -= CopyCount;
                }
            }

        /*
         * There are no pending IRPs for this channel, so just queue the data.
         */
        } else {

            IoReleaseCancelSpinLock( cancelIrql );

            /*
             * Check to see if we need to discard the data (too much data
             * backed up). This policy only takes effect when the max size
             * is nonzero, which is currently only the case for mouse and
             * keyboard inputs which can withstand being dropped.
             * Note that the read IRPs sent for channels that can have
             * data dropped must request in integral numbers of input
             * blocks -- e.g. a mouse read IRP must have a read buffer size
             * that is a multiple of sizeof(MOUSE_INPUT_DATA). If this is
             * not the case the immediate-copy block above may copy
             * partial input blocks before arriving here.
             */
            if (pChannel->InputBufMaxSize == 0 ||
                    (pChannel->InputBufCurSize + ByteCount) <=
                    pChannel->InputBufMaxSize) {
                /*
                 * If necessary, allocate an input buffer and copy the data
                 */
                if (pInBuf == NULL) {
                    /*
                     * Get input buffer and copy the data
                     * If this fails, we have no choice but to bail out.
                     */
                    pInBuf = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(INBUF) +
                            ByteCount);
                    if (pInBuf != NULL) {
                        pInBuf->ByteCount = ByteCount;
                        pInBuf->MaxByteCount = ByteCount;
                        pInBuf->pBuffer = (PUCHAR)(pInBuf + 1);
                        RtlCopyMemory(pInBuf->pBuffer, pBuffer, ByteCount);
                    }
                    else {
                        break;
                    }
                }

                /*
                 * Add buffer to tail of input list and clear pInBuf
                 * to indicate we have no buffer to free when done.
                 */
                InsertTailList( &pChannel->InputBufHead, &pInBuf->Links );
                pChannel->InputBufCurSize += ByteCount;
                pInBuf = NULL;

                /*
                 * If any read(s) were posted while we allocated the input
                 * buffer, then try to complete as many as possible.
                 */
                IoAcquireCancelSpinLock( &cancelIrql );
                while ( !IsListEmpty( &pChannel->InputIrpHead ) &&
                        !IsListEmpty( &pChannel->InputBufHead ) ) {

                    Head = RemoveHeadList( &pChannel->InputIrpHead );
                    Irp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
                    IoSetCancelRoutine( Irp, NULL );
                    IoReleaseCancelSpinLock( cancelIrql );

                    IrpSp = IoGetCurrentIrpStackLocation( Irp );

                    Status = _IcaReadChannelComplete( pChannel, Irp, IrpSp );
                    IoAcquireCancelSpinLock( &cancelIrql );
                }
                IoReleaseCancelSpinLock( cancelIrql );
            }
            else {
                TRACESTACK(( pStack, TC_ICADD, TT_ERROR,
                        "TermDD: IcaChannelInputInternal: Dropped %u bytes "
                        "on channelclass %u\n", ByteCount, ChannelClass));
            }

            break;
        }
    }

    /*
     * Unlock channel now
     */
    IcaUnlockChannel(pChannel);

    /*
     * If we still have an INBUF, free it now.
     */
    if (pInBuf)
        ICA_FREE_POOL(pInBuf);

    /*
     * Decrement channel refcount and return
     */
    IcaDereferenceChannel(pChannel);

    return STATUS_SUCCESS;
}


/****************************************************************************/
// IcaFindChannel
// IcaFindChannelByName
//
// Searches for a given channel in the connection channel list, and returns
// a pointer to it (with an added reference). Returns NULL if not found.
/****************************************************************************/
PICA_CHANNEL IcaFindChannel(
        IN PICA_CONNECTION pConnect,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass)
{
    PICA_CHANNEL pChannel;
    KIRQL oldIrql;
    NTSTATUS Status;

    /*
     * Ensure we're not looking for an invalid virtual channel number
     */
    ASSERT( ChannelClass != Channel_Virtual ||
            (VirtualClass >= 0 && VirtualClass < VIRTUAL_MAXIMUM) );

    /*
     * If channel does not exist, return NULL.
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock); 

    pChannel = pConnect->pChannel[ ChannelClass + VirtualClass ];

    if (pChannel == NULL) {
        TRACE(( pConnect, TC_ICADD, TT_API3,
                "TermDD: IcaFindChannel, cc %u, vc %d (not found)\n",
                ChannelClass, VirtualClass ));
        IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
        return NULL;
    }

    IcaReferenceChannel(pChannel);

    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  

    TRACE((pConnect, TC_ICADD, TT_API3,
            "TermDD: IcaFindChannel, cc %u, vc %d -> %s\n",
            ChannelClass, VirtualClass, pChannel->VirtualName));

    return pChannel;
}


PICA_CHANNEL IcaFindChannelByName(
        IN PICA_CONNECTION pConnect,
        IN CHANNELCLASS ChannelClass,
        IN PVIRTUALCHANNELNAME pVirtualName)
{
    PICA_CHANNEL pChannel;
    PLIST_ENTRY Head, Next;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     *  If this is not a virtual channel use channel class only
     */
    if (ChannelClass != Channel_Virtual) {
        return IcaFindChannel( pConnect, ChannelClass, 0);
    }

    /*
     * Search the existing channel structures to locate virtual channel name
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock); 

    Head = &pConnect->ChannelHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pChannel = CONTAINING_RECORD( Next, ICA_CHANNEL, Links );
        if ( (pChannel->ChannelClass == Channel_Virtual) &&
             !_stricmp( pChannel->VirtualName, pVirtualName ) ) {
            break;
        }
    }

    /*
     * If name does not exist, return unbound
     */
    if (Next == Head) {
        TRACE((pConnect, TC_ICADD, TT_API2,
                "TermDD: IcaFindChannelByName: vn %s (not found)\n", pVirtualName));
        IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
        return(NULL);
    }

    IcaReferenceChannel(pChannel);

    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
    TRACE((pConnect, TC_ICADD, TT_API2,
            "TermDD: IcaFindChannelByName: vn %s, vc %d, ref %u\n",
            pVirtualName, pChannel->VirtualClass,
            (pChannel != NULL ? pChannel->RefCount : 0)));

    return pChannel;
}


VOID IcaReferenceChannel(IN PICA_CHANNEL pChannel)
{
    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaReferenceChannel: cc %u, vc %d, ref %u\n",
            pChannel->ChannelClass, pChannel->VirtualClass, pChannel->RefCount));

    ASSERT(pChannel->RefCount >= 0);

    /*
     * Increment the reference count
     */
    if (InterlockedIncrement( &pChannel->RefCount) <= 0) {
        ASSERT(FALSE);
    }
}


VOID IcaDereferenceChannel(
        IN PICA_CHANNEL pChannel)
{
    BOOLEAN bNeedLock = FALSE;
    BOOLEAN bChannelFreed = FALSE;
    PERESOURCE pResource = pChannel->pChannelTableLock;
    PICA_CONNECTION pConnect = pChannel->pConnect;
    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaDefeferenceChannel: cc %u, vc %d, ref %u\n",
            pChannel->ChannelClass, pChannel->VirtualClass,
            pChannel->RefCount));

    ASSERT(pChannel->RefCount > 0);

    /*
     * Lock the channel table since a reference going to Zero would cause
     * to change table entry.
     */
    if (pChannel->RefCount == 1) {
        bNeedLock = TRUE;
        IcaLockChannelTable(pResource);
    }

    /*
     * Decrement the reference count; if it is 0, free the channel.
     */
    if (InterlockedDecrement(&pChannel->RefCount) == 0){
        ASSERT(bNeedLock);
        _IcaFreeChannel(pChannel);
        bChannelFreed = TRUE;
    }

    if (bNeedLock) {
        IcaUnlockChannelTable(pResource);  
    }

    /*
     * Remove the reference to the Connection object for this channel.
     * moved this here from _IcaFreeChannel because we need to be sure
     * the connection object can't go away before the call to IcaUnlockChannelTable
     * because the connection object is where the channel table locck live.
     */
    if (bChannelFreed) {
        IcaDereferenceConnection(pConnect);
    }
}


NTSTATUS IcaBindVirtualChannels(IN PICA_STACK pStack)
{
    PICA_CONNECTION pConnect;
    PSD_VCBIND pSdVcBind = NULL;
    SD_VCBIND aSdVcBind[ VIRTUAL_MAXIMUM ];
    ULONG SdVcBindCount;
    VIRTUALCHANNELCLASS VirtualClass;
    PICA_CHANNEL pChannel;
    NTSTATUS Status;
    ULONG i, Flags;
    SD_IOCTL SdIoctl;

    pConnect = IcaLockConnectionForStack(pStack);

    SdIoctl.IoControlCode = IOCTL_ICA_VIRTUAL_QUERY_BINDINGS;
    SdIoctl.InputBuffer = NULL;
    SdIoctl.InputBufferLength = 0;
    SdIoctl.OutputBuffer = aSdVcBind;
    SdIoctl.OutputBufferLength = sizeof(aSdVcBind);
    Status = _IcaCallStack(pStack, SD$IOCTL, &SdIoctl);
    if (NT_SUCCESS(Status)) {
        pSdVcBind = &aSdVcBind[0];
        SdVcBindCount = SdIoctl.BytesReturned / sizeof(SD_VCBIND);

        for (i = 0; i < SdVcBindCount; i++, pSdVcBind++) {
            TRACE((pConnect, TC_ICADD, TT_API2,
                    "TermDD: IcaBindVirtualChannels: %s -> %d Flags=%x\n",
                    pSdVcBind->VirtualName, pSdVcBind->VirtualClass, pSdVcBind->Flags));

            /*
             *  Locate virtual class binding
             */
            VirtualClass = _IcaFindVcBind(pConnect, pSdVcBind->VirtualName, &Flags);

            /*
             *  If virtual class binding does not exist, create one
             */
            if (VirtualClass == UNBOUND_CHANNEL) {
                /*
                 * Allocate a new virtual bind object
                 */
                Status = _IcaRegisterVcBind(pConnect, pSdVcBind->VirtualName,
                        pSdVcBind->VirtualClass, pSdVcBind->Flags );
                if (!NT_SUCCESS(Status))
                    goto PostLockConnection;
            } 

            /*
             *  Locate channel object
             */
            pChannel = IcaFindChannelByName(pConnect, Channel_Virtual,
                    pSdVcBind->VirtualName);

            /*
             *  If we found an existing channel object - update it
             */
            if (pChannel != NULL) {
                IcaLockChannel(pChannel);
                _IcaBindChannel(pChannel, Channel_Virtual, pSdVcBind->VirtualClass, pSdVcBind->Flags);
                IcaUnlockChannel(pChannel);
                IcaDereferenceChannel(pChannel);
            }
        }
    }

PostLockConnection:
    IcaUnlockConnection(pConnect);
    return Status;
}


VOID IcaRebindVirtualChannels(IN PICA_CONNECTION pConnect)
{
    PLIST_ENTRY Head, Next;
    PICA_VCBIND pVcBind;
    PICA_CHANNEL pChannel;

    Head = &pConnect->VcBindHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pVcBind = CONTAINING_RECORD(Next, ICA_VCBIND, Links);

        /*
         *  Locate channel object
         */
        pChannel = IcaFindChannelByName(pConnect, Channel_Virtual,
                pVcBind->VirtualName);

        /*
         *  If we found an existing channel object - update it
         */
        if (pChannel != NULL) {
            IcaLockChannel(pChannel);
            _IcaBindChannel(pChannel, Channel_Virtual, pVcBind->VirtualClass, pVcBind->Flags);
            IcaUnlockChannel(pChannel);
            IcaDereferenceChannel(pChannel);
        }
    }
}


VOID IcaUnbindVirtualChannels(IN PICA_CONNECTION pConnect)
{
    PLIST_ENTRY Head, Next;
    PICA_CHANNEL pChannel;
    KIRQL oldIrql;

    /*
     * Loop through the channel list and clear the virtual class
     * for all virtual channels.  Also remove the channel pointer
     * from the channel pointers array in the connection object.
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock);  
    Head = &pConnect->ChannelHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pChannel = CONTAINING_RECORD(Next, ICA_CHANNEL, Links);
        if (pChannel->ChannelClass == Channel_Virtual &&
                pChannel->VirtualClass != UNBOUND_CHANNEL) {
            pConnect->pChannel[pChannel->ChannelClass +
                    pChannel->VirtualClass] = NULL;
            pChannel->VirtualClass = UNBOUND_CHANNEL;
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
}


NTSTATUS IcaUnbindVirtualChannel(
        IN PICA_CONNECTION pConnect,
        IN PVIRTUALCHANNELNAME pVirtualName)
{
    PLIST_ENTRY Head, Next;
    PICA_CHANNEL pChannel;
    PICA_VCBIND pVcBind;
    KIRQL oldIrql;

    /*
     * Loop through the channel list and clear the virtual class
     * for the matching virtual channel.  Also remove the channel pointer
     * from the channel pointers array in the connection object.
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock);  
    Head = &pConnect->ChannelHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pChannel = CONTAINING_RECORD(Next, ICA_CHANNEL, Links);
        if (pChannel->ChannelClass == Channel_Virtual &&
                pChannel->VirtualClass != UNBOUND_CHANNEL &&
                !_stricmp( pChannel->VirtualName, pVirtualName)) {
            pConnect->pChannel[pChannel->ChannelClass +
                    pChannel->VirtualClass] = NULL;
            pChannel->VirtualClass = UNBOUND_CHANNEL;
            break;
        }
    }

    Head = &pConnect->VcBindHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pVcBind = CONTAINING_RECORD( Next, ICA_VCBIND, Links );
        if (!_stricmp(pVcBind->VirtualName, pVirtualName)) {
            RemoveEntryList( &pVcBind->Links );
            ICA_FREE_POOL(pVcBind);
            IcaUnlockChannelTable(&pConnect->ChannelTableLock);  
            return STATUS_SUCCESS;
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);  

    return STATUS_OBJECT_NAME_NOT_FOUND;
}


PICA_CHANNEL _IcaAllocateChannel(
        IN PICA_CONNECTION pConnect,
        IN CHANNELCLASS ChannelClass,
        IN PVIRTUALCHANNELNAME pVirtualName)
{
    PICA_CHANNEL pChannel;
    VIRTUALCHANNELCLASS VirtualClass;
    KIRQL oldIrql;
    NTSTATUS Status;
    ULONG Flags;

    ASSERT(ExIsResourceAcquiredExclusiveLite(&pConnect->Resource));

    pChannel = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(*pChannel));
    if (pChannel == NULL)
        return( NULL );

    TRACE((pConnect, TC_ICADD, TT_API2,
            "TermDD: _IcaAllocateChannel: cc %u, vn %s, %x\n",
            ChannelClass, pVirtualName, pChannel));

    RtlZeroMemory(pChannel, sizeof(*pChannel));


    /*
     * Reference the connection object this channel belongs to
     */
    IcaReferenceConnection(pConnect);
    pChannel->pConnect = pConnect;
    pChannel->pChannelTableLock = &pConnect->ChannelTableLock;


    /*
     * Initialize channel reference count to 1;
     *   for the file object reference that will be made by the caller.
     */
    pChannel->RefCount = 1;
    pChannel->CompletionRoutineCount = 0;

    /*
     * Initialize the rest of the channel object for non-zero values.
     */
    pChannel->Header.Type = IcaType_Channel;
    pChannel->Header.pDispatchTable = IcaChannelDispatchTable;

    ExInitializeResourceLite(&pChannel->Resource);
    InitializeListHead(&pChannel->InputIrpHead);
    InitializeListHead(&pChannel->InputBufHead);

    IcaLockChannel(pChannel);

    if (ChannelClass == Channel_Virtual) {
        strncpy(pChannel->VirtualName, pVirtualName, VIRTUALCHANNELNAME_LENGTH);
        VirtualClass = _IcaFindVcBind(pConnect, pVirtualName, &Flags);
    } else {
        VirtualClass = 0;
        Flags = 0;
    }

    _IcaBindChannel(pChannel, ChannelClass, VirtualClass, Flags);

    /*
     *  Link channel object to connect object
     */

    IcaLockChannelTable(&pConnect->ChannelTableLock); 

    InsertHeadList(&pConnect->ChannelHead, &pChannel->Links);

    IcaUnlockChannelTable(&pConnect->ChannelTableLock); 

    /*
     * Set channel type specific flags/fields
     * (i.e. shadow I/O is implicitly enabled for the video, beep,
     *  and command channels; the command and all virtual channels
     *  are message mode channels)
     * Also sets throttling values taken from registry (if appropriate,
     * plus remember a zeromem done to channel struct above).
     */
    switch (ChannelClass) {
        case Channel_Keyboard:
            pChannel->InputBufMaxSize = SysParams.KeyboardThrottleSize;
            break;

        case Channel_Mouse :
            pChannel->InputBufMaxSize = SysParams.MouseThrottleSize;
            break;

        case Channel_Video :
        case Channel_Beep :
            pChannel->Flags |= CHANNEL_SHADOW_IO;
            break;

        case Channel_Command :
            pChannel->Flags |= CHANNEL_SHADOW_IO;
            /* fall through */

        case Channel_Virtual :
            pChannel->Flags |= CHANNEL_MESSAGE_MODE;
            if (!_stricmp( pVirtualName, VIRTUAL_THINWIRE)) {
                pChannel->Flags |= CHANNEL_SCREENDATA;
            }
            break;
    }

    // Per above assert, this function is assumed to be called while the
    // connection lock is held.
    IcaUnlockChannel(pChannel);

    return pChannel;
}


void _IcaFreeChannel(IN PICA_CHANNEL pChannel)
{
    KIRQL oldIrql;

    ASSERT(pChannel->RefCount == 0);
    ASSERT(IsListEmpty(&pChannel->InputIrpHead));
    ASSERT(IsListEmpty(&pChannel->InputBufHead));
    ASSERT(!ExIsResourceAcquiredExclusiveLite(&pChannel->Resource));

    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: _IcaFreeChannel: cc %u, vn %s, \n",
            pChannel->ChannelClass, pChannel->VirtualName));



    /*
     * Unlink this channel from the channel list for this connection.
     * this routine must be called with channel table lock held.
     */

    RemoveEntryList(&pChannel->Links);

    if (pChannel->VirtualClass != UNBOUND_CHANNEL) {
        pChannel->pConnect->pChannel[pChannel->ChannelClass + pChannel->VirtualClass] = NULL;
    }


    ExDeleteResourceLite(&pChannel->Resource);

    ICA_FREE_POOL(pChannel);
}


NTSTATUS _IcaRegisterVcBind(
        IN PICA_CONNECTION pConnect,
        IN PVIRTUALCHANNELNAME pVirtualName,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN ULONG Flags)
{
    PICA_VCBIND pVcBind;
    NTSTATUS Status;

    ASSERT(ExIsResourceAcquiredExclusiveLite(&pConnect->Resource));

    TRACE((pConnect, TC_ICADD, TT_API2,
            "TermDD: _IcaRegisterVcBind: %s -> %d\n",
            pVirtualName, VirtualClass));

    /*
     *  Allocate bind structure
     */
    pVcBind = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pVcBind) );
    if (pVcBind != NULL) {
        /*
         *  Initialize structure
         */
        RtlZeroMemory(pVcBind, sizeof(*pVcBind));
        strncpy(pVcBind->VirtualName, pVirtualName, VIRTUALCHANNELNAME_LENGTH);
        pVcBind->VirtualClass = VirtualClass;
        pVcBind->Flags = Flags;

        /*
         *  Link bind structure to connect object
         */
        InsertHeadList(&pConnect->VcBindHead, &pVcBind->Links);

        return STATUS_SUCCESS;
    }
    else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}


VOID IcaFreeAllVcBind(IN PICA_CONNECTION pConnect)
{
    PICA_VCBIND pVcBind;
    PLIST_ENTRY Head;

    TRACE(( pConnect, TC_ICADD, TT_API2, "TermDD: IcaFreeAllVcBind\n" ));

    /*
     *  Free all bind structures
     */
    while ( !IsListEmpty( &pConnect->VcBindHead ) ) {
        Head = RemoveHeadList( &pConnect->VcBindHead );
        pVcBind = CONTAINING_RECORD( Head, ICA_VCBIND, Links );
        ICA_FREE_POOL( pVcBind );
    }

}


VIRTUALCHANNELCLASS _IcaFindVcBind(
        IN PICA_CONNECTION pConnect,
        IN PVIRTUALCHANNELNAME pVirtualName,
        OUT PULONG pFlags)
{
    PICA_VCBIND pVcBind;
    PLIST_ENTRY Head, Next;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     * Search the existing VC bind structures to locate virtual channel name
     */
    Head = &pConnect->VcBindHead;
    for (Next = Head->Flink; Next != Head; Next = Next->Flink) {
        pVcBind = CONTAINING_RECORD(Next, ICA_VCBIND, Links);
        if (!_stricmp(pVcBind->VirtualName, pVirtualName)) {
            TRACE((pConnect, TC_ICADD, TT_API2,
                    "TermDD: _IcaFindVcBind: vn %s -> vc %d\n",
                    pVirtualName, pVcBind->VirtualClass));
            *pFlags = pVcBind->Flags;
            return pVcBind->VirtualClass;
        }
    }

    /*
     * If name does not exist, return UNBOUND_CHANNEL
     */
    TRACE(( pConnect, TC_ICADD, TT_API2,
            "TermDD: _IcaFindVcBind: vn %s (not found)\n", pVirtualName ));
    return UNBOUND_CHANNEL;
}


VOID _IcaBindChannel(
        IN PICA_CHANNEL pChannel,
        IN CHANNELCLASS ChannelClass,
        IN VIRTUALCHANNELCLASS VirtualClass,
        IN ULONG Flags)
{
    KIRQL oldIrql;

    ASSERT(ExIsResourceAcquiredExclusiveLite(&pChannel->Resource));

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API2,
            "TermDD: _IcaBindChannel: cc %u, vn %s vc %d\n",
            ChannelClass, pChannel->VirtualName, VirtualClass ));

    pChannel->ChannelClass = ChannelClass;
    pChannel->VirtualClass = VirtualClass;
    IcaLockChannelTable(pChannel->pChannelTableLock);  

    if (Flags & SD_CHANNEL_FLAG_SHADOW_PERSISTENT)
        pChannel->Flags |= CHANNEL_SHADOW_PERSISTENT;

    if (VirtualClass != UNBOUND_CHANNEL) {
        ASSERT(pChannel->pConnect->pChannel[ChannelClass + VirtualClass] == NULL);
        pChannel->pConnect->pChannel[ChannelClass + VirtualClass] = pChannel;
    }
    IcaUnlockChannelTable(pChannel->pChannelTableLock);  
}



BOOLEAN IcaLockChannelTable(PERESOURCE pResource)
{
    KIRQL oldIrql;
    BOOLEAN Result;


    /*
     *  lock the channel  object
     */
    KeEnterCriticalRegion();    // Disable APC calls when holding a resource.
    Result = ExAcquireResourceExclusiveLite( pResource, TRUE );

    return Result;
}


void IcaUnlockChannelTable(PERESOURCE pResource)
{

    ExReleaseResourceLite(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

}

NTSTATUS IcaCancelReadChannel(
        IN PICA_CHANNEL pChannel,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp)
{
    KIRQL cancelIrql;
    PLIST_ENTRY Head;
    PIRP ReadIrp;
    PINBUF pInBuf;


    TRACECHANNEL((pChannel, TC_ICADD, TT_API2,
            "TermDD: IcaCancelReadChannel, cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Lock channel while we clear out any
     * pending read IRPs and/or input buffers.
     */
    IcaLockChannel(pChannel);

    /*
     * Indicate that Reads are cancelled to this channel
     */
    pChannel->Flags |= CHANNEL_CANCEL_READS;

    IoAcquireCancelSpinLock( &cancelIrql );
    while ( !IsListEmpty( &pChannel->InputIrpHead ) ) {
        Head = pChannel->InputIrpHead.Flink;
        ReadIrp = CONTAINING_RECORD( Head, IRP, Tail.Overlay.ListEntry );
        ReadIrp->CancelIrql = cancelIrql;
        IoSetCancelRoutine( ReadIrp, NULL );
        _IcaReadChannelCancelIrp( IrpSp->DeviceObject, ReadIrp );
        IoAcquireCancelSpinLock( &cancelIrql );
    }
    IoReleaseCancelSpinLock( cancelIrql );


    IcaUnlockChannel(pChannel);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\icadata.h ===
/*************************************************************************
*
* icadata.h
*
* This module declares global data for the Termdd driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

extern PDEVICE_OBJECT IcaDeviceObject;
extern PDEVICE_OBJECT MouDeviceObject;
extern PDEVICE_OBJECT KbdDeviceObject;

extern BOOLEAN PortDriverInitialized;

extern KSPIN_LOCK IcaSpinLock;
extern KSPIN_LOCK IcaTraceSpinLock;
extern KSPIN_LOCK IcaStackListSpinLock;

extern PERESOURCE IcaReconnectResource;

extern PERESOURCE IcaSdLoadResource;
extern LIST_ENTRY IcaSdLoadListHead;
extern LIST_ENTRY IcaStackListHead;
extern PLIST_ENTRY IcaNextStack;
extern ULONG IcaTotalNumOfStacks;
extern PKEVENT pIcaKeepAliveEvent;
extern PKTHREAD pKeepAliveThreadObject;

// NOTE: Changes to these sizes will require changes to the mapping tables.
#define MinOutBufAlloc  512
#define MaxOutBufAlloc  8192

// Defines the bit range size to look at to map from Min to MaxOutBufAlloc.
#define NumAllocSigBits 4

#define NumOutBufPools  5
#define FreeThisOutBuf  -1

extern unsigned MaxOutBufMdlOverhead;
extern const unsigned char OutBufPoolMapping[1 << NumAllocSigBits];
extern const unsigned OutBufPoolAllocSizes[NumOutBufPools];


extern LIST_ENTRY IcaFreeOutBufHead[];

extern FAST_IO_DISPATCH IcaFastIoDispatch;

extern PEPROCESS IcaSystemProcess;

extern CCHAR IcaIrpStackSize;
#define ICA_DEFAULT_IRP_STACK_SIZE 1

extern CCHAR IcaPriorityBoost;
#define ICA_DEFAULT_PRIORITY_BOOST 2

extern TERMSRV_SYSTEM_PARAMS SysParams;


/*
 * The following are exported kernel variables
 */
extern POBJECT_TYPE *IoFileObjectType;
extern POBJECT_TYPE *ExEventObjectType;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\dispatch.c ===
/*************************************************************************
*
* dispatch.c
*
* This module contains the dispatch routines for the TERMDD driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

NTSTATUS
IcaDeviceControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaRead (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaWrite (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaWriteSync (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for ICA.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION irpSp;
    KIRQL saveIrql;
    NTSTATUS Status;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    /*
     * Fan out the IRPs based on device type
     */
    if (*((ULONG *)(DeviceObject->DeviceExtension)) != DEV_TYPE_TERMDD)
    {
        /*
         * This is for the port driver part of TermDD
         */
        switch ( irpSp->MajorFunction ) {

            case IRP_MJ_CREATE:
                return PtCreate(DeviceObject, Irp);

            case IRP_MJ_CLOSE:
                return PtClose(DeviceObject, Irp);

            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
                return PtInternalDeviceControl(DeviceObject, Irp);

            case IRP_MJ_DEVICE_CONTROL:
                return PtDeviceControl(DeviceObject, Irp);

            case IRP_MJ_FLUSH_BUFFERS:
                return STATUS_NOT_IMPLEMENTED;

            case IRP_MJ_PNP:
                return PtPnP(DeviceObject, Irp);

            case IRP_MJ_POWER:
                return PtPower(DeviceObject, Irp);

            case IRP_MJ_SYSTEM_CONTROL:
                return PtSystemControl(DeviceObject, Irp);

            default:
                KdPrint(( "IcaDispatch: Invalid major function FOR PORT DRIVER %lx\n",
                          irpSp->MajorFunction ));
                Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return STATUS_NOT_IMPLEMENTED;
        }
    }
    else
    {
        switch ( irpSp->MajorFunction ) {

            case IRP_MJ_WRITE:

                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Length ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Key ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );

                saveIrql = KeGetCurrentIrql();

                irpSp->Parameters.Write.Key = 0;

                Status = IcaWrite( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == saveIrql );

                return Status;

            case IRP_MJ_READ:

                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Length ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
                ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Key ) ==
                        FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );

                saveIrql = KeGetCurrentIrql();

                irpSp->Parameters.Read.Key = 0;

                Status = IcaRead( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == saveIrql );

                return Status;

            case IRP_MJ_DEVICE_CONTROL:

                saveIrql = KeGetCurrentIrql();

                Status = IcaDeviceControl( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == saveIrql );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return( Status );

            case IRP_MJ_CREATE:

                Status = IcaCreate( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return Status;

            case IRP_MJ_FLUSH_BUFFERS :

                Status = IcaWriteSync( Irp, irpSp );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return Status;

            case IRP_MJ_CLEANUP:

                Status = IcaCleanup( Irp, irpSp );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                return Status;

            case IRP_MJ_CLOSE:

                Status = IcaClose( Irp, irpSp );

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

                return Status;

            case IRP_MJ_QUERY_SECURITY:

                Status = STATUS_INVALID_DEVICE_REQUEST;

                Irp->IoStatus.Status = Status;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return Status;

            default:
                Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                IoCompleteRequest( Irp, IcaPriorityBoost );

                return STATUS_NOT_IMPLEMENTED;
        }
    }
}

BOOLEAN
IcaIsSystemProcessRequest (
    PIRP Irp,
    PIO_STACK_LOCATION IrpSp)
{
    PACCESS_STATE accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PACCESS_TOKEN accessToken;
    PTOKEN_USER userId = NULL;
    BOOLEAN result = FALSE;
    NTSTATUS status = STATUS_SUCCESS;
    PSID systemSid;


    ASSERT(Irp != NULL);
    
    ASSERT(IrpSp != NULL);

    securityContext = IrpSp->Parameters.Create.SecurityContext;

    ASSERT(securityContext != NULL);

    //
    //  Get the well-known system SID.
    //
    systemSid = ExAllocatePoolWithTag(
                            PagedPool,
                            RtlLengthRequiredSid(1),
                            ICA_POOL_TAG
                            );
    if (systemSid) {
        SID_IDENTIFIER_AUTHORITY identifierAuthority = SECURITY_NT_AUTHORITY;
        *(RtlSubAuthoritySid(systemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        status = RtlInitializeSid(systemSid, &identifierAuthority, (UCHAR)1);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Get the non-impersonated, primary token for the IRP request.
    //
    accessState = securityContext->AccessState;
    accessToken = accessState->SubjectSecurityContext.PrimaryToken;

    //
    // We got the system SID. Now compare the caller's SID.
    //
    if (NT_SUCCESS(status) && accessToken){
        //
        //  Get the user ID associated with the primary token for the process
        //  that generated the IRP.
        //
        status = SeQueryInformationToken(
            accessToken,
            TokenUser,
            &userId
        );

        //
        //  Do the comparison.
        //  
        if (NT_SUCCESS(status)) {
            result = RtlEqualSid(systemSid, userId->User.Sid);
            ExFreePool(userId);
        }
    }
  
    if (systemSid) {
        ExFreePool(systemSid);
    }

    return result;
}


NTSTATUS
IcaCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Create IRPs in ICA.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_OPEN_PACKET openPacket;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    PFILE_OBJECT pConnectFileObject;
    PICA_CONNECTION pConnect;
    NTSTATUS Status;

    PAGED_CODE( );

    // Save result in FsContext2: if the requestor is system process or not
    IrpSp->FileObject->FsContext2 = (VOID*) IcaIsSystemProcessRequest(Irp, IrpSp);

    /*
     * Find the open packet from the EA buffer in the system buffer of
     * the associated IRP.  If no EA buffer was specified, then this
     * is a request to open a new ICA connection.
     */
    eaBuffer = Irp->AssociatedIrp.SystemBuffer;
    if ( eaBuffer == NULL ) {
        return( IcaCreateConnection( Irp, IrpSp ) );
    }

    if (eaBuffer->EaValueLength < sizeof(ICA_OPEN_PACKET)) {
       ASSERT(FALSE);
       return STATUS_INVALID_PARAMETER;
    }



    openPacket = (PICA_OPEN_PACKET)(eaBuffer->EaName + eaBuffer->EaNameLength + 1);

    /*
     * Validate parameters in the open packet.
     */
    if ( openPacket->OpenType != IcaOpen_Stack &&
         openPacket->OpenType != IcaOpen_Channel ) {
        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;
    }

    /*
     * Use the specified ICA connection handle to get a pointer to
     * the connection object.
     */
    Status = ObReferenceObjectByHandle(
                 openPacket->IcaHandle,
                 STANDARD_RIGHTS_READ,                         // DesiredAccess
                 *IoFileObjectType,
                 Irp->RequestorMode,
                 (PVOID *)&pConnectFileObject,
                 NULL
                 );
    if ( !NT_SUCCESS(Status) )
        return( Status );

    /*
     * Ensure what we have is a connection object
     */

    if (pConnectFileObject->DeviceObject != IcaDeviceObject) {
        ASSERT(FALSE);
        ObDereferenceObject( pConnectFileObject );
        return STATUS_INVALID_PARAMETER;
    }
    pConnect = pConnectFileObject->FsContext;
    ASSERT( pConnect->Header.Type == IcaType_Connection );
    if ( pConnect->Header.Type != IcaType_Connection ) {
        ObDereferenceObject( pConnectFileObject );
        return( STATUS_INVALID_CONNECTION );
    }

    /*
     * Create a new stack or new channel
     */
    IcaReferenceConnection( pConnect );

    switch ( openPacket->OpenType ) {
        case IcaOpen_Stack :
            Status = IcaCreateStack( pConnect, openPacket, Irp, IrpSp );
            break;

        case IcaOpen_Channel :
            Status = IcaCreateChannel( pConnect, openPacket, Irp, IrpSp );
            break;
    }

    IcaDereferenceConnection( pConnect );
    ObDereferenceObject( pConnectFileObject );

    return( Status );
}


NTSTATUS
IcaRead (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the read routine for ICA.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a read routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_READ] == NULL ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        return( Status );
    }

    /*
     * Call the read routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_READ])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaWrite (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the write routine for ICA.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a write routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_WRITE] == NULL ) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IcaPriorityBoost );
        return( Status );
    }

    /*
     * Call the write routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_WRITE])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaWriteSync (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the flush routine for ICA.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a flush routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_FLUSH_BUFFERS] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    /*
     * Call the flush routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_FLUSH_BUFFERS])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaDeviceControl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the dispatch routine for ICA IOCTLs.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a device control routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_DEVICE_CONTROL] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    /*
     * Call the device control routine for this ICA object.
     */
    Status = (pIcaHeader->pDispatchTable[IRP_MJ_DEVICE_CONTROL])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Cleanup IRPs in ICA.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS --

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    /*
     * Get pointer to ICA object header.
     * If a cleanup routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_CLEANUP] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    Status = (pIcaHeader->pDispatchTable[IRP_MJ_CLEANUP])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}


NTSTATUS
IcaClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Close IRPs in ICA.  It
    dereferences the endpoint specified in the IRP, which will result in
    the endpoint being freed when all other references go away.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_HEADER pIcaHeader;
    NTSTATUS Status;

    PAGED_CODE( );

    /*
     * Get pointer to ICA object header.
     * If a close routine is not defined, return an error.
     */
    pIcaHeader = IrpSp->FileObject->FsContext;
    if ( pIcaHeader->pDispatchTable[IRP_MJ_CLOSE] == NULL )
        return( STATUS_INVALID_DEVICE_REQUEST );

    Status = (pIcaHeader->pDispatchTable[IRP_MJ_CLOSE])(
                pIcaHeader, Irp, IrpSp );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\icadata.c ===
/*************************************************************************
* icadata.c
*
* This module declares global data for Termdd
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop


PDEVICE_OBJECT IcaDeviceObject;
PDEVICE_OBJECT MouDeviceObject = NULL;
PDEVICE_OBJECT KbdDeviceObject = NULL;

BOOLEAN PortDriverInitialized;

KSPIN_LOCK IcaSpinLock;
KSPIN_LOCK IcaTraceSpinLock;
KSPIN_LOCK IcaStackListSpinLock;

PERESOURCE IcaReconnectResource;
PERESOURCE IcaTraceResource;

PERESOURCE IcaSdLoadResource;
LIST_ENTRY IcaSdLoadListHead;

LIST_ENTRY IcaTdHandleList;

LIST_ENTRY IcaFreeOutBufHead[NumOutBufPools];

LIST_ENTRY IcaStackListHead;
ULONG      IcaTotalNumOfStacks;
PLIST_ENTRY IcaNextStack;
PKEVENT    pIcaKeepAliveEvent;
PKTHREAD   pKeepAliveThreadObject;

HANDLE     g_TermServProcessID=NULL;

unsigned MaxOutBufMdlOverhead;

// Used by OutBuf alloc code to map a bit range from the alloc size
// (requested alloc size + header sizes) into a particular buffer pool.
// We use a 512-byte granularity, but alloc sizes that are various multiples
// of 512 bytes, to correspond with various protocol typical allocation sizes.
const unsigned char OutBufPoolMapping[1 << NumAllocSigBits] =
{
         // Index  Binary   AllocRange   Pool  PoolAllocSize
    0,   //   0     0000       0..511      0        1024
    0,   //   1     0001     512..1023     0        1024
    1,   //   2     0010    1024..1535     1        1536
    2,   //   3     0011    1536..2047     2        2048
    3,   //   4     0100    2048..2559     3        2560
    4,   //   5     0101    2560..3071     4        8192
    4,   //   6     0110    3072..3583     4        8192
    4,   //   7     0111    3584..4095     4        8192
    4,   //   8     1000    4096..4607     4        8192
    4,   //   9     1001    4608..5119     4        8192
    4,   //  10     1010    5120..5631     4        8192
    4,   //  11     1011    5632..6143     4        8192
    4,   //  12     1100    6144..6655     4        8192
    4,   //  13     1101    6656..7167     4        8192
    4,   //  14     1110    7168..7679     4        8192
    4,   //  15     1111    7680..8191     4        8192
};

// After mapping we have a pool number and need to know the size to alloc.
const unsigned OutBufPoolAllocSizes[NumOutBufPools] =
{
    1024, 1536, 2048, 2560, 8192
};


FAST_IO_DISPATCH IcaFastIoDispatch;

PEPROCESS IcaSystemProcess;

CCHAR IcaIrpStackSize = ICA_DEFAULT_IRP_STACK_SIZE;

CCHAR IcaPriorityBoost = ICA_DEFAULT_PRIORITY_BOOST;

TERMSRV_SYSTEM_PARAMS SysParams =
{
    DEFAULT_MOUSE_THROTTLE_SIZE,
    DEFAULT_KEYBOARD_THROTTLE_SIZE,
};


#ifdef notdef
FAST_IO_DISPATCH IcaFastIoDispatch =
{
    11,                        // SizeOfFastIoDispatch
    NULL,                      // FastIoCheckIfPossible
    IcaFastIoRead,             // FastIoRead
    IcaFastIoWrite,            // FastIoWrite
    NULL,                      // FastIoQueryBasicInfo
    NULL,                      // FastIoQueryStandardInfo
    NULL,                      // FastIoLock
    NULL,                      // FastIoUnlockSingle
    NULL,                      // FastIoUnlockAll
    NULL,                      // FastIoUnlockAllByKey
    IcaFastIoDeviceControl     // FastIoDeviceControl
};
#endif

#if DBG
ULONG IcaLocksAcquired = 0;
#endif


BOOLEAN
IcaInitializeData (
    VOID
    )
{
    int i, j;

    PAGED_CODE( );

#if DBG
    IcaInitializeDebugData( );
#endif

    //
    // Initialize global lists.
    //
    InitializeListHead( &IcaSdLoadListHead );
    InitializeListHead( &IcaStackListHead );

    IcaTotalNumOfStacks = 0;
    IcaNextStack = &IcaStackListHead;

    pKeepAliveThreadObject = NULL;

    for ( i = 0; i < NumOutBufPools; i++ )
        InitializeListHead( &IcaFreeOutBufHead[i] );
    //
    // Initialize global spin locks and resources used by ICA.
    //
    KeInitializeSpinLock( &IcaSpinLock );
    KeInitializeSpinLock( &IcaTraceSpinLock );
    KeInitializeSpinLock( &IcaStackListSpinLock );


    IcaInitializeHandleTable();

    IcaReconnectResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*IcaReconnectResource) );
    if ( IcaReconnectResource == NULL ) {
        return FALSE;
    }
    ExInitializeResourceLite( IcaReconnectResource );

    IcaSdLoadResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*IcaSdLoadResource) );
    if ( IcaSdLoadResource == NULL ) {
        return FALSE;
    }
    ExInitializeResourceLite( IcaSdLoadResource );

    IcaTraceResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*IcaTraceResource) );
    if ( IcaTraceResource == NULL ) {
        return FALSE;
    }
    ExInitializeResourceLite( IcaTraceResource );


    pIcaKeepAliveEvent = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(KEVENT));
    if ( pIcaKeepAliveEvent != NULL ) {
        KeInitializeEvent(pIcaKeepAliveEvent, NotificationEvent, FALSE);
    }
    else {
        return FALSE;
    }


    // Used by OutBuf alloc code for determining max overhead of OutBuf info
    // for the default max size allocation.
    MaxOutBufMdlOverhead = (unsigned)MmSizeOfMdl((PVOID)(PAGE_SIZE - 1),
            MaxOutBufAlloc);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\connect.c ===
/*************************************************************************
*
* connect.c
*
* This module contains routines for managing TerminalServer connections.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
IcaDeviceControlConnection (
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanupConnection (
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCloseConnection (
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaStartStopTrace(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PICA_TRACE pTrace
    );

NTSTATUS
IcaUnbindVirtualChannel(
    IN PICA_CONNECTION pConnect,
    IN PVIRTUALCHANNELNAME pVirtualName
    );

/*
 * Local procedure prototypes
 */
PICA_CONNECTION _IcaAllocateConnection( VOID );
VOID _IcaFreeConnection( PICA_CONNECTION );


/*
 * Dispatch table for ICA connection objects
 */
PICA_DISPATCH IcaConnectionDispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1] = {
    NULL,                       // IRP_MJ_CREATE                   
    NULL,                       // IRP_MJ_CREATE_NAMED_PIPE        
    IcaCloseConnection,         // IRP_MJ_CLOSE                    
    NULL,                       // IRP_MJ_READ                     
    NULL,                       // IRP_MJ_WRITE                    
    NULL,                       // IRP_MJ_QUERY_INFORMATION        
    NULL,                       // IRP_MJ_SET_INFORMATION          
    NULL,                       // IRP_MJ_QUERY_EA                 
    NULL,                       // IRP_MJ_SET_EA                   
    NULL,                       // IRP_MJ_FLUSH_BUFFERS            
    NULL,                       // IRP_MJ_QUERY_VOLUME_INFORMATION 
    NULL,                       // IRP_MJ_SET_VOLUME_INFORMATION   
    NULL,                       // IRP_MJ_DIRECTORY_CONTROL        
    NULL,                       // IRP_MJ_FILE_SYSTEM_CONTROL      
    IcaDeviceControlConnection, // IRP_MJ_DEVICE_CONTROL           
    NULL,                       // IRP_MJ_INTERNAL_DEVICE_CONTROL  
    NULL,                       // IRP_MJ_SHUTDOWN                 
    NULL,                       // IRP_MJ_LOCK_CONTROL             
    IcaCleanupConnection,       // IRP_MJ_CLEANUP                  
    NULL,                       // IRP_MJ_CREATE_MAILSLOT          
    NULL,                       // IRP_MJ_QUERY_SECURITY           
    NULL,                       // IRP_MJ_SET_SECURITY             
    NULL,                       // IRP_MJ_SET_POWER                
    NULL,                       // IRP_MJ_QUERY_POWER              
};

extern PERESOURCE IcaTraceResource;

// resource used to protect access to the code that start/stops the keep alive thread
PERESOURCE   g_pKeepAliveResource;

extern NTSTATUS _IcaKeepAlive( 
        IN BOOLEAN  startKeepAliveThread,
        IN ULONG    interval );

NTSTATUS
IcaCreateConnection (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to create a new ICA_CONNECTION object.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PICA_CONNECTION pConnect;

    /*
     * Allocate a new ICA connect object
     */
    pConnect = _IcaAllocateConnection();
    if ( pConnect == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Save a pointer to the connection in the file object
     * so that we can find it in future calls.
     */
    IrpSp->FileObject->FsContext = pConnect;

    IcaDereferenceConnection( pConnect );

    return( STATUS_SUCCESS );
}


NTSTATUS
IcaDeviceControlConnection(
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    ICA_TRACE LocalTrace;
    PICA_TRACE_BUFFER pTraceBuffer;
    ULONG code;
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    BOOLEAN bConnectionLocked = FALSE;
    BYTE *Buffer = NULL;
    PICA_KEEP_ALIVE     pKeepAlive;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

#if DBG
    if ( code != IOCTL_ICA_SYSTEM_TRACE && code != IOCTL_ICA_TRACE ) {
        TRACE(( pConnect, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlConnection, fc %d (enter)\n",
                (code & 0x3fff) >> 2 ));
    }
#endif

    try {
        switch ( code ) {
    
            case IOCTL_ICA_SET_SYSTEM_TRACE :

                // This IOCTL should only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_TRACE) ) 
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, sizeof(ICA_TRACE), sizeof(BYTE) );
                }
                LocalTrace = *(PICA_TRACE)(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite( IcaTraceResource, TRUE );

                try {

                  Status = IcaStartStopTrace( &G_TraceInfo, &LocalTrace );

                } finally {

                  ExReleaseResourceLite( IcaTraceResource );
                  KeLeaveCriticalRegion();
                }
                break;
    
            case IOCTL_ICA_SET_TRACE :
                
                // This IOCTL should only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_TRACE) ) 
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, IrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof(BYTE) );
                }
                LocalTrace = *(PICA_TRACE)(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                IcaLockConnection( pConnect );
				bConnectionLocked = TRUE;

                Status = IcaStartStopTrace( &pConnect->TraceInfo, &LocalTrace );

                
                if ( !IsListEmpty(&pConnect->StackHead)) {
                    PICA_STACK pStack;
                    pStack = CONTAINING_RECORD( pConnect->StackHead.Flink,
                                                ICA_STACK, StackEntry );
                    SdIoctl.IoControlCode = code;
                    SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                    SdIoctl.OutputBuffer = NULL;
                    SdIoctl.OutputBufferLength = 0;
                    _IcaCallStack(pStack, SD$IOCTL, &SdIoctl);
                }            
                
                IcaUnlockConnection( pConnect );
                break;
    
            case IOCTL_ICA_SYSTEM_TRACE :
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)(FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0])) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) ) 
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, IrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof(BYTE) );
                }

                pTraceBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                KeEnterCriticalRegion();
                ExAcquireResourceExclusiveLite( IcaTraceResource, TRUE );

                try {

                   IcaTraceFormat( &G_TraceInfo,
                                   pTraceBuffer->TraceClass,
                                   pTraceBuffer->TraceEnable,
                                   pTraceBuffer->Data );

                } finally {

                  ExReleaseResourceLite( IcaTraceResource );
                  KeLeaveCriticalRegion();
                }

                Status = STATUS_SUCCESS;
                break;
    
            case IOCTL_ICA_TRACE :
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)(FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0])) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) ) 
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, IrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof(BYTE) );
                }

                pTraceBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                IcaLockConnection( pConnect );
				bConnectionLocked=TRUE;
                IcaTraceFormat( &pConnect->TraceInfo,
                                pTraceBuffer->TraceClass,
                                pTraceBuffer->TraceEnable,
                                pTraceBuffer->Data );
                IcaUnlockConnection( pConnect );
                Status = STATUS_SUCCESS;
                break;
    
            case IOCTL_ICA_UNBIND_VIRTUAL_CHANNEL :
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(VIRTUALCHANNELNAME) ) 
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, sizeof(VIRTUALCHANNELNAME), sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                IcaLockConnection( pConnect );
                bConnectionLocked = TRUE;
                Status = IcaUnbindVirtualChannel( pConnect, (PVIRTUALCHANNELNAME)Buffer );
                IcaUnlockConnection( pConnect );

                break;
    
            case IOCTL_ICA_SET_SYSTEM_PARAMETERS:
                // Settings coming from TermSrv, copy to global variable.
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                        sizeof(TERMSRV_SYSTEM_PARAMS))
                    return(STATUS_BUFFER_TOO_SMALL);
                if (Irp->RequestorMode != KernelMode)
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.
                            Type3InputBuffer, sizeof(TERMSRV_SYSTEM_PARAMS),
                            sizeof(BYTE));
                SysParams = *(PTERMSRV_SYSTEM_PARAMS)(IrpSp->Parameters.
                        DeviceIoControl.Type3InputBuffer);
                        Status = STATUS_SUCCESS;
                break;

        case IOCTL_ICA_SYSTEM_KEEP_ALIVE:

                // This should  only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_KEEP_ALIVE ) ) 
                    return( STATUS_BUFFER_TOO_SMALL );

                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer, sizeof(ICA_KEEP_ALIVE ), sizeof(BYTE) );
                }
                
                pKeepAlive = (PICA_KEEP_ALIVE)(IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                KeEnterCriticalRegion();
                ExAcquireResourceExclusive( g_pKeepAliveResource, TRUE );

                try {

                  Status = _IcaKeepAlive( pKeepAlive->start, pKeepAlive->interval  );

                } finally {

                  ExReleaseResource(  g_pKeepAliveResource );
                  KeLeaveCriticalRegion();
                }

            break;

            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
        }
    } except(EXCEPTION_EXECUTE_HANDLER){
       Status = GetExceptionCode();
	   if (bConnectionLocked) {
		   IcaUnlockConnection( pConnect );
	   }       
    }

    if (Buffer) {
        ICA_FREE_POOL(Buffer);
        Buffer = NULL;
    }

#if DBG
    if ( code != IOCTL_ICA_SYSTEM_TRACE && code != IOCTL_ICA_TRACE ) {
        TRACE(( pConnect, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlConnection, fc %d, 0x%x\n",
                (code & 0x3fff) >> 2, Status ));
    }
#endif

    return( Status );
}


NTSTATUS
IcaCleanupConnection(
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    return( STATUS_SUCCESS );
}


NTSTATUS
IcaCloseConnection(
    IN PICA_CONNECTION pConnect,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{

    /*
     * Remove the file object reference for this connection.
     * This will cause the connection to be deleted when all other
     * references (including stack/channel references) are gone.
     */
    IcaDereferenceConnection( pConnect );

    return( STATUS_SUCCESS );
}


VOID
IcaReferenceConnection(
    IN PICA_CONNECTION pConnect
    )
{

    ASSERT( pConnect->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement(&pConnect->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
IcaDereferenceConnection(
    IN PICA_CONNECTION pConnect
    )
{

    ASSERT( pConnect->RefCount > 0 );

    /*
     * Decrement the reference count; if it is 0, free the connection.
     */
    if ( InterlockedDecrement( &pConnect->RefCount) == 0 ) {
        _IcaFreeConnection( pConnect );
    }
}


PICA_CONNECTION
_IcaAllocateConnection( VOID )
{
    PICA_CONNECTION pConnect;
    NTSTATUS Status;

    pConnect = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pConnect) );
    if ( pConnect == NULL )
        return NULL;

    RtlZeroMemory( pConnect, sizeof(*pConnect) );

    /*
     * Initialize the reference count to 2,
     * one for the caller's reference, one for the file object reference.
     */
    pConnect->RefCount = 2;

    /*
     * Initialize the rest of the connect object
     */
    pConnect->Header.Type = IcaType_Connection;
    pConnect->Header.pDispatchTable = IcaConnectionDispatchTable;
    ExInitializeResourceLite( &pConnect->Resource );
    ExInitializeResourceLite( &pConnect->ChannelTableLock );
    InitializeListHead( &pConnect->StackHead );
    InitializeListHead( &pConnect->ChannelHead );
    InitializeListHead( &pConnect->VcBindHead );


    return( pConnect );
}


VOID
_IcaFreeConnection( PICA_CONNECTION pConnect )
{
    ICA_TRACE TraceControl;
    PICA_CHANNEL pChannel;
    PLIST_ENTRY Head;

    ASSERT( pConnect->RefCount == 0 );
    ASSERT( IsListEmpty( &pConnect->StackHead ) );
    ASSERT( IsListEmpty( &pConnect->ChannelHead ) );
    ASSERT( IsListEmpty( &pConnect->VcBindHead ) );
    ASSERT( !ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    TRACE(( pConnect, TC_ICADD, TT_API2, "ICADD: _IcaFreeConnection: %x\n",  pConnect ));

    /*
     * Close trace file, if any
     */
    RtlZeroMemory( &TraceControl, sizeof(TraceControl) );
    (void) IcaStartStopTrace( &pConnect->TraceInfo, &TraceControl );

    ExDeleteResourceLite( &pConnect->Resource );
    ExDeleteResourceLite( &pConnect->ChannelTableLock );

    ICA_FREE_POOL( pConnect );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\icaprocs.h ===
/*************************************************************************
*
* icap.h
*
* This module contains routine prototypes for the ICA driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

BOOLEAN
IcaInitializeData (
    VOID
    );

VOID _cdecl
IcaTrace(
    IN ULONG TraceClass, 
    IN ULONG TraceEnable, 
    IN CHAR * Format, 
    IN ... );

VOID 
IcaTraceBuffer(
    IN ULONG TraceClass, 
    IN ULONG TraceEnable,
    IN PVOID pBuffer,
    IN ULONG ByteCount );

VOID
IcaTraceFormat( 
    IN PICA_TRACE_INFO pTraceInfo,
    IN ULONG TraceClass,
    IN ULONG TraceEnable,
    IN PCHAR pData );

NTSTATUS
IcaDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IcaCreateConnection (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCreateStack (
    IN PICA_CONNECTION pConnect,
    IN PICA_OPEN_PACKET openPacket,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCreateChannel (
    IN PICA_CONNECTION pConnect,
    IN PICA_OPEN_PACKET openPacket,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Channel IO dispatch routines
 */
NTSTATUS
IcaDeviceControlKeyboard (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlMouse (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlVideo (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlBeep (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlConsole (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
IcaDeviceControlVirtual (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Stack Driver (SD) call routine
 */
NTSTATUS
IcaCallDriver(
    IN PICA_CHANNEL pChannel,
    IN ULONG ProcIndex,
    IN PVOID pParms
    );


/*
 * Miscellaneous worker routines
 */
VOID
IcaReferenceConnection(
    IN PICA_CONNECTION pConnect
    );

VOID
IcaDereferenceConnection(
    IN PICA_CONNECTION pConnect
    );

PICA_CHANNEL
IcaFindChannelByName(
    IN PICA_CONNECTION pConnect,
    IN CHANNELCLASS ChannelClass,
    IN PVIRTUALCHANNELNAME pVirtualName
    );

PICA_CHANNEL
IcaFindChannel(
    IN PICA_CONNECTION pConnect,
    IN CHANNELCLASS ChannelClass,
    IN VIRTUALCHANNELCLASS VirtualClass
    );

VOID
IcaReferenceChannel(
    IN PICA_CHANNEL pChannel
    );

VOID IcaDereferenceChannel(IN PICA_CHANNEL);



BOOLEAN IcaLockChannelTable(
    PERESOURCE pResource);

void IcaUnlockChannelTable(
    PERESOURCE pResource);


VOID
IcaReferenceStack(
    IN PICA_STACK pStack
    );

VOID
IcaDereferenceStack(
    IN PICA_STACK pStack
    );

VOID
IcaReferenceSdLink(
    IN PSDLINK pSdLink
    );

VOID
IcaDereferenceSdLink(
    IN PSDLINK pSdLink
    );

PSDLINK
IcaGetNextSdLink(
    IN PSDLINK pSdLink
    );

PSDLINK
IcaGetPreviousSdLink(
    IN PSDLINK pSdLink
    );


VOID
IcaKeepAliveThread(
    IN PVOID pData
    );

/*
 * Internal versions of Stack Driver helper routines
 */
NTSTATUS
IcaBufferAllocInternal(
    IN PSDCONTEXT pContext,
    IN BOOLEAN bWait,
    IN BOOLEAN bControl,
    IN ULONG ByteCount,
    IN POUTBUF pOutBufOrig,
    OUT POUTBUF *ppOutBuf
    );

VOID
IcaBufferFreeInternal(
    IN PSDCONTEXT pContext,
    IN POUTBUF pOutBuf
    );

NTSTATUS
IcaRawInputInternal(
    IN PICA_STACK pStack,
    IN PINBUF pInBuf OPTIONAL,
    IN PCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    );

NTSTATUS
IcaChannelInputInternal(
    IN PICA_STACK pStack,
    IN CHANNELCLASS ChannelClass,
    IN VIRTUALCHANNELCLASS VirtualClass,
    IN PINBUF pInBuf OPTIONAL,
    IN PCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    );

void
IcaInitializeHandleTable(
    void
);
void
IcaCleanupHandleTable(
    void
);

/*
 * Routines to handle fast IO.
 */
#ifdef notdef
BOOLEAN
IcaFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
IcaFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
IcaFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\icap.h ===
/****************************************************************************/
// icap.h
//
// TermDD private header.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/


#define ICA_POOL_TAG ' acI'


/*
 * Enumerated ICA object types
 */
typedef enum _ICA_TYPE {
    IcaType_Connection,
    IcaType_Stack,
    IcaType_Channel
} ICA_TYPE;


/*
 * ICA dispatch prototype
 */
typedef NTSTATUS (*PICA_DISPATCH) (
        IN PVOID IcaObject,
        IN PIRP Irp,
        IN PIO_STACK_LOCATION IrpSp);


/*
 * Deferred trace structure
 */
#pragma warning(disable : 4200)  // for Buffer[] nonstandard extension.
typedef struct _DEFERRED_TRACE {
    struct _DEFERRED_TRACE *Next;
    ULONG Length;
    WCHAR Buffer[];
} DEFERRED_TRACE, *PDEFERRED_TRACE;
#pragma warning(default : 4200)

/*
 * Trace Information structure
 */
typedef struct _ICA_TRACE_INFO {
    ULONG TraceClass;                 // trace - enabled trace classes (TC_?)
    ULONG TraceEnable;                // trace - enabled trace types (TT_?)
    BOOLEAN fTraceDebugger;           // trace - send trace messages to the debugger
    BOOLEAN fTraceTimestamp;          // trace - time stamp trace messages
    PWCHAR pTraceFileName;
    PFILE_OBJECT pTraceFileObject;
    PDEFERRED_TRACE pDeferredTrace;
} ICA_TRACE_INFO, *PICA_TRACE_INFO;


/*
 * Common header for all ICA objects
 */
typedef struct _ICA_HEADER {
    ICA_TYPE Type;
    PICA_DISPATCH *pDispatchTable;
} ICA_HEADER, *PICA_HEADER;


/*
 * ICA connection object
 */
typedef struct _ICA_CONNECTION {
    ICA_HEADER  Header;         // WARNING: This field MUST ALWAYS be first
    LONG        RefCount;       // Reference count for this connection
    ERESOURCE   Resource;       // Resource protecting access to this object
    BOOLEAN     fPassthruEnabled;
    LIST_ENTRY  StackHead;      // List of stack objects for this connection
    LIST_ENTRY  ChannelHead;    // List of channel objects for this connection
    LIST_ENTRY  VcBindHead;     // List of vcbind objects for this connection
    ICA_TRACE_INFO TraceInfo;   // trace information

    /*
     * Channel pointers array.  This array should be indexed using the
     * channel number plus the virtual channel number.  This allows a
     * fast lookup of any bound channel given the channel/virtual number.
     */
    struct _ICA_CHANNEL *pChannel[CHANNEL_COUNT+VIRTUAL_MAXIMUM];
    ERESOURCE ChannelTableLock;
} ICA_CONNECTION, *PICA_CONNECTION;


//
// define the Maximum Low Water Mark setting to resume transmission
//
#define MAX_LOW_WATERMARK				((ULONG)((ULONG_PTR)-1))
/*
 * ICA stack object
 */
typedef struct _ICA_STACK {
    ICA_HEADER  Header;             // WARNING: This field MUST ALWAYS be first
    LONG        RefCount;           // Reference count for this stack
    ERESOURCE   Resource;           // Resource protecting access to this object
    STACKCLASS  StackClass;         // Stack type (primary/shadow)
    LIST_ENTRY  StackEntry;         // Links for connection object stack list
    LIST_ENTRY  SdLinkHead;         // Head of SDLINK list for this stack
    struct _ICA_STACK *pPassthru;   // Pointer to passthru stack
    BOOLEAN fIoDisabled;
    BOOLEAN fClosing;
    BOOLEAN fDoingInput;
    BOOLEAN fDisablingIo;
    KEVENT  IoEndEvent;
    LARGE_INTEGER LastInputTime;    // last time of keyboard/mouse input 
    PVOID pBrokenEventObject;

    /*
     * Pointer to connection object.
     * Note this is typed as PUCHAR instead of PICA_CONNECTION to prevent use
     * of it directly.  All references to the connection object a stack is
     * attached to should be made by calling IcaGetConnectionForStack() if
     * the stack is already locked, or IcaLockConnectionForStack() otherwise.
     * This is required because this is a dynamic pointer, which can be
     * modified during stack reconnect.
     */
    PUCHAR pConnect;                // Pointer to connection object

    BOOLEAN fWaitForOutBuf;         // outbuf - did we hit the high watermark
    ULONG OutBufLength;             // outbuf - length of output buffer
    ULONG OutBufCount;              // outbuf - maximum number of outbufs
    ULONG OutBufAllocCount;         // outbuf - number of outbufs allocated
    KEVENT OutBufEvent;             // outbuf - allocate event
    ULONG SdOutBufHeader;           // reserved output buffer header bytes
    ULONG SdOutBufTrailer;          // reserved output buffer trailer bytes 

    CLIENTMODULES ClientModules;    // stack driver client module data
    PROTOCOLSTATUS ProtocolStatus;  // stack driver protocol status

    LIST_ENTRY StackNode;           // for linking all stacks together
    LARGE_INTEGER  LastKeepAliveTime;       // Time last keepalive packet sent
    ULONG OutBufLowWaterMark;           // low water mark to resume transmission
} ICA_STACK, *PICA_STACK;


/*
 * Channel Filter Input/Output procedure prototype
 */
typedef NTSTATUS
(_stdcall * PFILTERPROC)( PVOID, PCHAR, ULONG, PINBUF * );

/*
 * ICA channel filter object
 */
typedef struct _ICA_FILTER {
    PFILTERPROC InputFilter;    // Input filter procedure
    PFILTERPROC OutputFilter;   // Output filter procedure
} ICA_FILTER, *PICA_FILTER;


/*
 * ICA virtual class bind structure
 */
typedef struct _ICA_VCBIND {
    VIRTUALCHANNELNAME  VirtualName;   // Virtual channel name
    VIRTUALCHANNELCLASS VirtualClass;  // Virtual channel number (0-31, -1 unbound)
    ULONG Flags;
    LIST_ENTRY   Links;         // Links for vcbind structure list
} ICA_VCBIND, *PICA_VCBIND;


/*
 * ICA channel object
 */
typedef struct _ICA_CHANNEL {
    ICA_HEADER   Header;        // WARNING: This field MUST ALWAYS be first
    LONG         RefCount;      // Reference count for this channel
    ERESOURCE    Resource;      // Resource protecting access to this object
    ULONG        Flags;         // Channel flags (see CHANNEL_xxx below)
    LONG         OpenCount;     // Count of opens on this object
    PICA_CONNECTION pConnect;   // Pointer to connection object
    PICA_FILTER  pFilter;       // Pointer to filter object for this channel
    CHANNELCLASS ChannelClass;  // Channel type
    VIRTUALCHANNELNAME  VirtualName;   // Virtual channel name
    VIRTUALCHANNELCLASS VirtualClass;  // Virtual channel number (0-31, -1 unbound)
    LIST_ENTRY   Links;         // Links for channel structure list
    LIST_ENTRY   InputIrpHead;  // Head of pending IRP list
    LIST_ENTRY   InputBufHead;  // Head of input buffer list
    unsigned     InputBufCurSize;  // Bytes held in input buffers.
    unsigned     InputBufMaxSize;  // High watermark for input buffers.
    PERESOURCE pChannelTableLock;
    ULONG        CompletionRoutineCount;
} ICA_CHANNEL, *PICA_CHANNEL;

/*
 *  VirtualClass - virtual channel is not yet bound to a virtual class number
 */
#define UNBOUND_CHANNEL -1
 
/*
 * Channel Flags
 */
#define CHANNEL_MESSAGE_MODE      0x00000001  // This is a message mode channel
#define CHANNEL_SHADOW_IO         0x00000002  // Pass shadow data
#define CHANNEL_SCREENDATA        0x00000004  // This is a screen data channel
#define CHANNEL_CLOSING           0x00000008  // This channel is being closed
#define CHANNEL_SHADOW_PERSISTENT 0x00000010  // Used for virtual channels: still up during shadow
#define CHANNEL_SESSION_DISABLEIO 0x00000020  // Used disable IO for help session while not in shadow mode
#define CHANNEL_CANCEL_READS      0x00000040  // To cancel reads to CommandChannel on Winstation termination


/*
 * Stack Driver load structure
 * There exists exactly one of these structures for
 * each Stack Driver (WD/PD/TD) loaded in the system.
 */
typedef struct _SDLOAD {
    WDNAMEW     SdName;         // Name of this SD
    LONG        RefCount;       // Reference count
    LIST_ENTRY  Links;          // Links for SDLOAD list
    PVOID       ImageHandle;    // Image handle for this driver
    PVOID       ImageBase;      // Image base for this driver
    PSDLOADPROC DriverLoad;     // Pointer to driver load routine
    PFILE_OBJECT FileObject;    // Reference to underlying driver
    PVOID       pUnloadWorkItem;// Pointer to workitem for delayed unload
    PDEVICE_OBJECT DeviceObject;// Pointer device object to use the unload safe completion routine
} SDLOAD, *PSDLOAD;


/*
 * Stack Driver link structure
 * There exists one of these structures for each WD/PD/TD in a stack.
 */
typedef struct _SDLINK {
    PICA_STACK  pStack;         // Pointer to ICA_STACK object for this driver
    PSDLOAD     pSdLoad;        // Pointer to SDLOAD object for this driver
    LIST_ENTRY  Links;          // Links for SDLINK list
    LONG        RefCount;   
    SDCONTEXT   SdContext;      // Contains SD proc table, context value, callup table
    ERESOURCE   Resource;
} SDLINK, * PSDLINK;


/*
 * Lock/Unlock macros
 */
#if DBG

/*
 *
 * NOTE: Under DBG builds, the following routines will validate
 *       that the correct locking order is not violated.
 *       The correct order is:
 *          1) Connection
 *          2) Stack
 *          3) Channel
 */
BOOLEAN IcaLockConnection(PICA_CONNECTION);
void    IcaUnlockConnection(PICA_CONNECTION);

BOOLEAN IcaLockStack(PICA_STACK);
void    IcaUnlockStack(PICA_STACK);

BOOLEAN IcaLockChannel(PICA_CHANNEL);
void    IcaUnlockChannel(PICA_CHANNEL);

#else // DBG

#define IcaLockConnection(p) { \
        IcaReferenceConnection( p ); \
        KeEnterCriticalRegion(); /* Disable APC calls */ \
        ExAcquireResourceExclusiveLite( &p->Resource, TRUE ); \
    }
#define IcaUnlockConnection(p) { \
        ExReleaseResourceLite( &p->Resource ); \
        KeLeaveCriticalRegion(); /* Re-enable APC calls */ \
        IcaDereferenceConnection( p ); \
    }

#define IcaLockStack(p) { \
        IcaReferenceStack( p ); \
        KeEnterCriticalRegion(); /* Disable APC calls */ \
        ExAcquireResourceExclusiveLite( &p->Resource, TRUE ); \
    }
#define IcaUnlockStack(p) { \
        ExReleaseResourceLite( &p->Resource ); \
        KeLeaveCriticalRegion(); /* Re-enable APC calls */ \
        IcaDereferenceStack( p ); \
    }

#define IcaLockChannel(p) { \
        IcaReferenceChannel( p ); \
        KeEnterCriticalRegion(); /* Disable APC calls */ \
        ExAcquireResourceExclusiveLite( &p->Resource, TRUE ); \
    }
#define IcaUnlockChannel(p) { \
        ExReleaseResourceLite( &p->Resource ); \
        KeLeaveCriticalRegion(); /* Re-enable APC calls */ \
        IcaDereferenceChannel(p); \
    }


#endif // DBG

PICA_CONNECTION IcaGetConnectionForStack(PICA_STACK);

PICA_CONNECTION IcaLockConnectionForStack(PICA_STACK);

void IcaUnlockConnectionForStack(PICA_STACK);


/*
 * Memory alloc/free macros
 */
#if DBG

PVOID IcaAllocatePool(IN POOL_TYPE, IN ULONG, PCHAR, ULONG, BOOLEAN);

#define ICA_ALLOCATE_POOL(a,b) IcaAllocatePool(a, b, __FILE__, __LINE__, FALSE)
#define ICA_ALLOCATE_POOL_WITH_QUOTA(a,b) IcaAllocatePool(a, b, __FILE__, __LINE__, TRUE)

void IcaFreePool (IN PVOID);

#define ICA_FREE_POOL(a) IcaFreePool(a)

#else // DBG

#define ICA_ALLOCATE_POOL(a,b) ExAllocatePoolWithTag(a,b,ICA_POOL_TAG)
#define ICA_ALLOCATE_POOL_WITH_QUOTA(a,b) ExAllocatePoolWithQuotaTag(a,b,ICA_POOL_TAG)
#define ICA_FREE_POOL(a) ExFreePool(a)

#endif // DBG


/*
 * Spinlock acquire/release macros
 */
#if DBG

extern ULONG IcaLocksAcquired;

#define IcaAcquireSpinLock(a,b) KeAcquireSpinLock((a),(b)); IcaLocksAcquired++

#define IcaReleaseSpinLock(a,b) IcaLocksAcquired--; KeReleaseSpinLock((a),(b))

void IcaInitializeDebugData(void);

#else // DBG

#define IcaAcquireSpinLock(a,b) KeAcquireSpinLock((a),(b))
#define IcaReleaseSpinLock(a,b) KeReleaseSpinLock((a),(b))

#endif // DBG


/*
 *  Trace
 */
extern ICA_TRACE_INFO G_TraceInfo;

#undef TRACE
#undef TRACESTACK
#undef TRACESTACKBUF
#undef TRACECHANNEL

#if DBG
VOID _cdecl _IcaTrace( PICA_CONNECTION, ULONG, ULONG, CHAR *, ... );
VOID _cdecl _IcaStackTrace( PICA_STACK, ULONG, ULONG, CHAR *, ... );
VOID        _IcaStackTraceBuffer( PICA_STACK, ULONG, ULONG, PVOID, ULONG );
VOID _cdecl _IcaChannelTrace( PICA_CHANNEL, ULONG, ULONG, CHAR *, ... );

#define TRACE(_arg)         _IcaTrace _arg
#define TRACESTACK(_arg)    _IcaStackTrace _arg
#define TRACESTACKBUF(_arg) _IcaStackTraceBuffer _arg
#define TRACECHANNEL(_arg)  _IcaChannelTrace _arg

#else

#define TRACE(_arg)         
#define TRACESTACK(_arg)    
#define TRACESTACKBUF(_arg) 
#define TRACECHANNEL(_arg)  

#endif


/*
 *  Need to define these to have MP save driver ( proper locked operation will generated for x86)-Bug# 209464
 */

 #define _NTSRV_
 #define _NTDDK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\kbdmou.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kbdmou.h

Abstract:

    These are the structures and defines that are used in the
    keyboard class driver, mouse class driver, and keyboard/mouse port
    driver.

Author:

    lees

Revision History:

--*/

#ifndef _KBDMOU_
#define _KBDMOU_

#include <ntddkbd.h>
#include <ntddmou.h>

//
// Define the keyboard/mouse port device name strings.
//

#define DD_KEYBOARD_PORT_DEVICE_NAME    "\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_DEVICE_NAME_U L"\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_BASE_NAME_U   L"KeyboardPort"
#define DD_POINTER_PORT_DEVICE_NAME     "\\Device\\PointerPort"
#define DD_POINTER_PORT_DEVICE_NAME_U  L"\\Device\\PointerPort"
#define DD_POINTER_PORT_BASE_NAME_U    L"PointerPort"

//
// Define the keyboard/mouse class device name strings.
//

#define DD_KEYBOARD_CLASS_BASE_NAME_U   L"KeyboardClass"
#define DD_POINTER_CLASS_BASE_NAME_U    L"PointerClass"

//
// Define the keyboard/mouse resource class names.
//

#define DD_KEYBOARD_RESOURCE_CLASS_NAME_U             L"Keyboard"
#define DD_POINTER_RESOURCE_CLASS_NAME_U              L"Pointer"
#define DD_KEYBOARD_MOUSE_COMBO_RESOURCE_CLASS_NAME_U L"Keyboard/Pointer"

//
// Define the maximum number of pointer/keyboard port names the port driver
// will use in an attempt to IoCreateDevice.
//

#define POINTER_PORTS_MAXIMUM  8
#define KEYBOARD_PORTS_MAXIMUM 8

//
// Define the port connection data structure.
//

typedef struct _CONNECT_DATA {
    IN PDEVICE_OBJECT ClassDeviceObject;
    IN PVOID ClassService;
} CONNECT_DATA, *PCONNECT_DATA;

//
// Define the service callback routine's structure.
//

typedef
VOID
(*PSERVICE_CALLBACK_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN OUT PVOID SystemArgument3
    );

//
// WMI structures returned by port drivers
//

#define KEYBOARD_PORT_WMI_STD_DATA_GUID {0x4731F89A, 0x71CB, 0x11d1, 0xA5, 0x2C, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}
typedef struct _KEYBOARD_PORT_WMI_STD_DATA {
    //
    // Connector types
    //
#define KEYBOARD_PORT_WMI_STD_I8042 0
#define KEYBOARD_PORT_WMI_STD_SERIAL 1
#define KEYBOARD_PORT_WMI_STD_USB 2
    ULONG   ConnectorType;

    //
    // Size of data queue (number of entries)
    //
    ULONG   DataQueueSize;

    //
    // The error Count
    //
    ULONG   ErrorCount;

    //
    // Number of Function keys on the device.
    //
    ULONG   FunctionKeys;

    //
    // Number of Indicators on the device.
    //
    ULONG   Indicators;

} KEYBOARD_PORT_WMI_STD_DATA, * PKEYBOARD_PORT_WMI_STD_DATA;

#define POINTER_PORT_WMI_STD_DATA_GUID  {0x4731F89C, 0x71CB, 0x11d1, 0xA5, 0x2C, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}
typedef struct _POINTER_PORT_WMI_STD_DATA {
    //
    // Connector types
    //
#define POINTER_PORT_WMI_STD_I8042 0
#define POINTER_PORT_WMI_STD_SERIAL 1
#define POINTER_PORT_WMI_STD_USB 2
    ULONG   ConnectorType;

    //
    // Size of data queue (number of entries)
    //
    ULONG   DataQueueSize;

    //
    // The error Count
    //
    ULONG   ErrorCount;

    //
    // Number of Buttons on the pointer device
    //
    ULONG   Buttons;

    //
    // Hardware Types
    //
#define POINTER_PORT_WMI_STD_MOUSE        0
#define POINTER_PORT_WMI_STD_POINTER      1
#define POINTER_PORT_WMI_ABSOLUTE_POINTER 2
#define POINTER_PORT_WMI_TABLET           3
#define POINTER_PORT_WMI_TOUCH_SCRENE     4
#define POINTER_PORT_WMI_PEN              5
#define POINTER_PORT_WMI_TRACK_BALL       6
#define POINTER_PORT_WMI_OTHER            0x100
    ULONG   HardwareType;

} POINTER_PORT_WMI_STD_DATA, * PPOINTER_PORT_WMI_STD_DATA;

//
// NtDeviceIoControlFile internal IoControlCode values for keyboard device.
//

#define IOCTL_INTERNAL_KEYBOARD_CONNECT CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISCONNECT CTL_CODE(FILE_DEVICE_KEYBOARD,0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_ENABLE  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISABLE CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile internal IoControlCode values for mouse device.
//


#define IOCTL_INTERNAL_MOUSE_CONNECT    CTL_CODE(FILE_DEVICE_MOUSE, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISCONNECT CTL_CODE(FILE_DEVICE_MOUSE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_ENABLE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISABLE    CTL_CODE(FILE_DEVICE_MOUSE, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Error log definitions (specific to the keyboard/mouse) for DumpData[0]
// in the IO_ERROR_LOG_PACKET.
//
//     DumpData[1] <= hardware port/register
//     DumpData[2] <= {command byte || expected response byte}
//     DumpData[3] <= {command's parameter byte || actual response byte}
//
//

#define KBDMOU_COULD_NOT_SEND_COMMAND  0x0000
#define KBDMOU_COULD_NOT_SEND_PARAM    0x0001
#define KBDMOU_NO_RESPONSE             0x0002
#define KBDMOU_INCORRECT_RESPONSE      0x0004

//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define I8042_ERROR_VALUE_BASE        1000
#define INPORT_ERROR_VALUE_BASE       2000
#define SERIAL_MOUSE_ERROR_VALUE_BASE 3000

#endif // _KBDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\khandle.c ===
/*************************************************************************
*
* khandle.c
*
* Manage kernel mode handles for transport drivers.
*
* Copyright 1998, Microsoft.
*  
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

ULONG gHandleTableSize;                           

#ifdef TERMDD_NO_USE_TABLE_PACKAGE

typedef struct _TDHANDLE_ENTRY {
    LIST_ENTRY Link;
    PVOID      Context;
    ULONG      ContextSize;
} TDHANDLE_ENTRY, *PTDHANDLE_ENTRY;

/*
 * Global Data
 */
LIST_ENTRY IcaTdHandleList;

/*
 * These set of routines allows TD's to create a handle that will survive
 * across them being unloaded and re-loaded. This allows a handle to be
 * passed back to ICASRV in a secure manner.
 *
 * NOTE: We do not deal with ICASRV leaking these handles. It never exits.
 *       If it does, we will need to have ICADD return a real NT handle, or
 *       destroy all handles for a TD when it unloads.
 */


/*****************************************************************************
 *
 *  IcaCreateHandle
 *
 *   Create a handle entry for the context and length.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCreateHandle(
    PVOID Context,
    ULONG ContextSize,
    PVOID *ppHandle
)
{
    KIRQL OldIrql;
    PTDHANDLE_ENTRY p;

    p = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(TDHANDLE_ENTRY) );
    if( p == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    RtlZeroMemory( p, sizeof(TDHANDLE_ENTRY) );
    p->Context = Context;
    p->ContextSize = ContextSize;

    *ppHandle = (PVOID)p;

    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );
    InsertHeadList( &IcaTdHandleList, &p->Link );
    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
    InterlockedIncrement(&gHandleTableSize);

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  IcaReturnHandle
 *
 *   Return the context and length for the handle.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaReturnHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;

    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );

    pEntry = IcaTdHandleList.Flink;

    while( pEntry != &IcaTdHandleList ) {

        p = CONTAINING_RECORD( pEntry, TDHANDLE_ENTRY, Link );

        if( (PVOID)p == Handle ) {
            *ppContext = p->Context;
            *pContextSize = p->ContextSize;
            IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
            return( STATUS_SUCCESS );
        }

        pEntry = pEntry->Flink;
    }

    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );

    return( STATUS_INVALID_HANDLE );
}

/*****************************************************************************
 *
 *  IcaCloseHandle
 *
 *   Return the context and length for the handle. Delete the
 *   handle entry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCloseHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;

    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );

    pEntry = IcaTdHandleList.Flink;

    while( pEntry != &IcaTdHandleList ) {

        p = CONTAINING_RECORD( pEntry, TDHANDLE_ENTRY, Link );

        if( (PVOID)p == Handle ) {
            RemoveEntryList( &p->Link );
            IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
            InterlockedDecrement(&gHandleTableSize);
            *ppContext = p->Context;
            *pContextSize = p->ContextSize;
            ICA_FREE_POOL( p );
            return( STATUS_SUCCESS );
        }

        pEntry = pEntry->Flink;
    }

    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );

    return( STATUS_INVALID_HANDLE );
}


/*****************************************************************************
 *
 *  IcaInitializeHandleTable
 *
 *   Initializes handle table at driver load.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/
void
IcaInitializeHandleTable(
    void
)
{
    InitializeListHead( &IcaTdHandleList );
}
/*****************************************************************************
 *
 *  IcaCleanupHandleTable
 *
 *   Cleans up handle table at driver unload.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/

void
IcaCleanupHandleTable(
    void
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;



    KdPrint(("TermDD: IcaCleanupHandleTable table size is %d\n",gHandleTableSize));

    for (pEntry = IcaTdHandleList.Flink; pEntry != &IcaTdHandleList; pEntry = IcaTdHandleList.Flink) {
        p = CONTAINING_RECORD( pEntry, TDHANDLE_ENTRY, Link );
        RemoveEntryList(&p->Links);
        ICA_FREE_POOL( p->Context );
        ICA_FREE_POOL( p );
    }
}

#else


typedef struct _TDHANDLE_ENTRY {
    PVOID      Context;
    ULONG      ContextSize;
} TDHANDLE_ENTRY, *PTDHANDLE_ENTRY;

RTL_GENERIC_TABLE IcaHandleReferenceTable;



RTL_GENERIC_COMPARE_RESULTS
NTAPI
IcaCompareHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
);


PVOID
IcaAllocateHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
);


VOID
IcaFreeHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
);

/*****************************************************************************
 *
 *  IcaInitializeHandleTable
 *
 *   Initializes handle table at driver load.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/
void
IcaInitializeHandleTable(
    void
)
{
    RtlInitializeGenericTable(  &IcaHandleReferenceTable,
                                IcaCompareHandleTableEntry,
                                IcaAllocateHandleTableEntry,
                                IcaFreeHandleTableEntry,
                                NULL);
}


/*****************************************************************************
 *
 *  IcaCleanupHandleTable
 *
 *   Cleanup handle table at driver unload.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   None
 *
 ****************************************************************************/

void
IcaCleanupHandleTable(
    void
)
{
    KIRQL OldIrql;
    PLIST_ENTRY pEntry;
    PTDHANDLE_ENTRY p;
    PVOID pContext;
    TDHANDLE_ENTRY key;

    KdPrint(("TermDD: IcaCleanupHandleTable table size is %d\n",gHandleTableSize));

    while (p = RtlEnumerateGenericTable(&IcaHandleReferenceTable,TRUE)) {
        key.Context = p->Context;
        RtlDeleteElementGenericTable(&IcaHandleReferenceTable, &key);
        ICA_FREE_POOL(key.Context);
    }

}


/*****************************************************************************
 *
 *  IcaCreateHandle
 *
 *   Create a handle entry for the context and length.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCreateHandle(
    PVOID Context,
    ULONG ContextSize,
    PVOID *ppHandle
)
{
    KIRQL OldIrql;
    TDHANDLE_ENTRY key;
    BOOLEAN bNewElement;


    key.Context = Context;
    key.ContextSize = ContextSize;
    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );
    if (!RtlInsertElementGenericTable(&IcaHandleReferenceTable,(PVOID) &key, sizeof(TDHANDLE_ENTRY), &bNewElement )) {
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return STATUS_NO_MEMORY;
    }
    IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
    ASSERT(bNewElement);
    if (!bNewElement) {
        return STATUS_INVALID_PARAMETER;
    }

    InterlockedIncrement(&gHandleTableSize);

    *ppHandle = Context;


    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  IcaReturnHandle
 *
 *   Return the context and length for the handle.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaReturnHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PTDHANDLE_ENTRY p;
    TDHANDLE_ENTRY key;

    key.Context = Handle;
    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );

    p = RtlLookupElementGenericTable(&IcaHandleReferenceTable, &key);
    if (p != NULL) {
        *ppContext = p->Context;
        *pContextSize = p->ContextSize;
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return STATUS_SUCCESS;
    } else {
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return STATUS_INVALID_HANDLE; 
    }

}


/*****************************************************************************
 *
 *  IcaCloseHandle
 *
 *   Return the context and length for the handle. Delete the
 *   handle entry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
IcaCloseHandle(
    PVOID  Handle,
    PVOID  *ppContext,
    PULONG pContextSize
)
{
    KIRQL OldIrql;
    PTDHANDLE_ENTRY p;
    TDHANDLE_ENTRY key;

    key.Context = Handle;
    IcaAcquireSpinLock( &IcaSpinLock, &OldIrql );


    p = RtlLookupElementGenericTable(&IcaHandleReferenceTable, &key);
    if (p != NULL) {
        *ppContext = p->Context;
        *pContextSize = p->ContextSize;
        RtlDeleteElementGenericTable(&IcaHandleReferenceTable, &key);
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        InterlockedDecrement(&gHandleTableSize);
        return STATUS_SUCCESS;
    } else {
        IcaReleaseSpinLock( &IcaSpinLock, OldIrql );
        return  STATUS_INVALID_HANDLE;
    }

}


/*****************************************************************************
 *
 *  IcaCompareHandleTableEntry
 *
 *   Generic table support.Compare two handles table entry instances
 *
 *
 ****************************************************************************/

RTL_GENERIC_COMPARE_RESULTS
NTAPI
IcaCompareHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
)
{
    ULONG_PTR FirstHandle = (ULONG_PTR)((PTDHANDLE_ENTRY)FirstInstance)->Context;
    ULONG_PTR SecondHandle = (ULONG_PTR)((PTDHANDLE_ENTRY)SecondInstance)->Context;

    if (FirstHandle < SecondHandle ) {
        return GenericLessThan;
    }

    if (FirstHandle > SecondHandle ) {
        return GenericGreaterThan;
    }
    return GenericEqual;
}


/*****************************************************************************
 *
 *  IcaAllocateHandleTableEntry
 *
 *   Generic table support. Allocates a new table entry
 *
 *
 ****************************************************************************/

PVOID
IcaAllocateHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    )
{

    return ICA_ALLOCATE_POOL( NonPagedPool, ByteSize );
}


/*****************************************************************************
 *
 *  IcaFreeHandleTableEntry
 *
 *   Generic table support. frees a new table entry
 *
 *
 ****************************************************************************/

VOID
IcaFreeHandleTableEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
    )
{

    ICA_FREE_POOL(Buffer);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\init.c ===
/*************************************************************************
*
* init.c
*
* This module performs initialization for the ICA device driver.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop


ULONG
IcaReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

NTSTATUS
IcaOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    );

VOID
IcaReadRegistry (
    VOID
    );

BOOLEAN
IsPtDrvInstalled(
    IN PUNICODE_STRING RegistryPath
    );

VOID
IcaUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, IcaUnload )
#endif


extern PERESOURCE IcaTraceResource;
extern PERESOURCE g_pKeepAliveResource;

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the ICA device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    CLONG i;
    BOOLEAN success;
    HANDLE ThreadHandle;

    PAGED_CODE( );

    //
    // Initialize global data.
    //
    success = IcaInitializeData( );
    if ( !success ) {
        IcaUnload(DriverObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    g_pKeepAliveResource = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(* g_pKeepAliveResource) );
    if (  g_pKeepAliveResource == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    ExInitializeResource( g_pKeepAliveResource );

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // !!! Apply an ACL to the device object.
    //
    RtlInitUnicodeString( &deviceName, ICA_DEVICE_NAME );

    /*
     * The device extension stores the device type, which is used
     *  to fan out received IRPs in IcaDispatch.
     */
    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 sizeof(ULONG),                  // DeviceExtension
                 &deviceName,                    // DeviceName
                 FILE_DEVICE_TERMSRV,            // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &IcaDeviceObject                // DeviceObject
                 );


    if ( !NT_SUCCESS(status) ) {
        IcaUnload(DriverObject);
        KdPrint(( "ICA DriverEntry: unable to create device object: %X\n", status ));
        return status;
    }

    //
    // Set up the device type
    //
    *((ULONG *)(IcaDeviceObject->DeviceExtension)) = DEV_TYPE_TERMDD;

    //IcaDeviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the driver object for this file system driver.
    //
    DriverObject->DriverUnload   = IcaUnload;
    DriverObject->FastIoDispatch = NULL;

    //
    // We handle all possible IRPs in IcaDispatch and then fan them out
    // to the Port Driver or ICA components based on the device type stored
    // as the first ULONG's worth of the device extension
    //
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = IcaDispatch;
    }

#ifdef notdef
    //
    // Read registry information.
    //
    IcaReadRegistry( );
#endif

    //
    // Initialize our device object.
    //
    IcaDeviceObject->StackSize = IcaIrpStackSize;

    //
    // Remember a pointer to the system process.  We'll use this pointer
    // for KeAttachProcess() calls so that we can open handles in the
    // context of the system process.
    //
    IcaSystemProcess = IoGetCurrentProcess( );

    //
    // Tell MM that it can page all of ICA it is desires.
    //
    //MmPageEntireDriver( DriverEntry );

    //
    // Now see if the port driver component has been installed.
    // Initialise it if so.
    //
    if ( NT_SUCCESS(status) ) {
        if (IsPtDrvInstalled(RegistryPath)) {
            //
            // Initialise the mouse/keyboard port driver component.
            //
            Print(DBG_PNP_TRACE, ( "TermDD DriverEntry: calling PtEntry\n" ));

            status = PtEntry(DriverObject, RegistryPath);

            if ( NT_SUCCESS(status) ) {
                //
                // Set up the port driver's plug and play entry points.
                //
                Print(DBG_PNP_TRACE, ( "TermDD DriverEntry: PtEntry succeeded Status=%#x\n", status ));
                DriverObject->DriverStartIo = PtStartIo;
                DriverObject->DriverExtension->AddDevice = PtAddDevice;
                PortDriverInitialized = TRUE;
            } else {
                //
                // This means that remote input will not be available when
                // shadowing the console session - but that's no reason to
                // fail the rest of the initialisation
                //
                Print(DBG_PNP_ERROR, ( "TermDD DriverEntry: PtEntry failed Status=%#x\n", status ));
                status = STATUS_SUCCESS;
            }
        } else {
            Print(DBG_PNP_INFO | DBG_PNP_TRACE, ( "TermDD DriverEntry: Port driver not installed\n" ));
        }
    }
    if (!NT_SUCCESS(status)) {
        IcaUnload(DriverObject);
    }

    return (status);
}


VOID
IcaUnload (
    IN PDRIVER_OBJECT DriverObject
    )
{
    DriverObject;

    PAGED_CODE( );

    KdPrint(( "IcaUnload called for termdd.sys.\n" ));

    // Set IcaKeepAliveEvent to wake up KeepAlive thread
    if (pIcaKeepAliveEvent != NULL ) {
        KeSetEvent(pIcaKeepAliveEvent, 0, FALSE);

    }

    // Wait for the thread to exit
    if (pKeepAliveThreadObject != NULL ) {
        KeWaitForSingleObject(pKeepAliveThreadObject, Executive, KernelMode, TRUE, NULL);
        // Deference the thread object
        ObDereferenceObject(pKeepAliveThreadObject);
        pKeepAliveThreadObject = NULL;
    }

    // Now we can free the KeepAlive Event
    if (pIcaKeepAliveEvent != NULL) {
        ICA_FREE_POOL(pIcaKeepAliveEvent);
        pIcaKeepAliveEvent = NULL;
    }

    // Call onto the port driver component, if it was ever initialised.
    if (PortDriverInitialized) {
        Print(DBG_PNP_TRACE, ( "TermDD IcaUnload: calling RemotePrt PtUnload\n" ));
        PtUnload(DriverObject);
        PortDriverInitialized = FALSE;
        Print(DBG_PNP_TRACE, ( "TermDD IcaUnload: RemotePrt PtUnload done\n" ));
    }

    // Free resources 

    if (IcaReconnectResource != NULL) {
        ExDeleteResourceLite(IcaReconnectResource );
        ICA_FREE_POOL(IcaReconnectResource);
        IcaReconnectResource = NULL;
    }


    if (IcaSdLoadResource != NULL) {
        ExDeleteResourceLite(IcaSdLoadResource );
        ICA_FREE_POOL(IcaSdLoadResource);
        IcaSdLoadResource = NULL;
    }

    if (IcaTraceResource != NULL) {
        ExDeleteResourceLite(IcaTraceResource );
        ICA_FREE_POOL(IcaTraceResource);
        IcaTraceResource = NULL;
    }


    if (g_pKeepAliveResource != NULL) {
        ExDeleteResource(g_pKeepAliveResource );
        ICA_FREE_POOL(g_pKeepAliveResource);
        g_pKeepAliveResource = NULL;
    }


    //
    // Delete the main device object.
    //
    if (IcaDeviceObject != NULL) {
        IoDeleteDevice (IcaDeviceObject);
        IcaDeviceObject = NULL;
    }

    //
    // Cleanup handle table, if necessary.
    //
    IcaCleanupHandleTable();

    KdPrint(("Finish TermDD.sys unload\n"));
    return;
}

BOOLEAN
IsPtDrvInstalled(
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS status;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG value = 0;
    ULONG defaultValue = 0;
    BOOLEAN rc = FALSE;

    PAGED_CODE( );

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"PortDriverEnable";
    paramTable[0].EntryContext  = &value;       // where to put the result
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &defaultValue;
    paramTable[0].DefaultLength = sizeof(ULONG);

    //
    // The second (blank) entry in paramTable signals the end of the table.
    //

    status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     RegistryPath->Buffer,
                                     &paramTable[0],
                                     NULL,
                                     NULL );
    if (!NT_SUCCESS(status)) {
        value = defaultValue;
    }

    if (value != 0) {
        rc = TRUE;
    }

    return(rc);
}


#ifdef notdef
VOID
IcaReadRegistry (
    VOID
    )

/*++

Routine Description:

    Reads the ICA section of the registry.  Any values listed in the
    registry override defaults.

Arguments:

    None.

Return Value:

    None -- if anything fails, the default value is used.

--*/
{
    HANDLE parametersHandle;
    NTSTATUS status;
    ULONG stackSize;
    ULONG priorityBoost;
    ULONG ignorePushBit;
    UNICODE_STRING registryPath;
    CLONG i;

    PAGED_CODE( );

    RtlInitUnicodeString( &registryPath, REGISTRY_ICA_INFORMATION );

    status = IcaOpenRegistry( &registryPath, &parametersHandle );

    if (status != STATUS_SUCCESS) {
        return;
    }

    //
    // Read the stack size and priority boost values from the registry.
    //

    stackSize = IcaReadSingleParameter(
                    parametersHandle,
                    REGISTRY_IRP_STACK_SIZE,
                    (ULONG)IcaIrpStackSize
                    );

    if ( stackSize > 255 ) {
        stackSize = 255;
    }

    IcaIrpStackSize = (CCHAR)stackSize;

    priorityBoost = IcaReadSingleParameter(
                        parametersHandle,
                        REGISTRY_PRIORITY_BOOST,
                        (ULONG)IcaPriorityBoost
                        );

    if ( priorityBoost > 16 ) {
        priorityBoost = ICA_DEFAULT_PRIORITY_BOOST;
    }

    IcaPriorityBoost = (CCHAR)priorityBoost;

    //
    // Read other config variables from the registry.
    //

    for ( i = 0; i < ICA_CONFIG_VAR_COUNT; i++ ) {

        *IcaConfigInfo[i].Variable =
            IcaReadSingleParameter(
                parametersHandle,
                IcaConfigInfo[i].RegistryValueName,
                *IcaConfigInfo[i].Variable
                );
    }

    ignorePushBit = IcaReadSingleParameter(
                        parametersHandle,
                        REGISTRY_IGNORE_PUSH_BIT,
                        (ULONG)IcaIgnorePushBitOnReceives
                        );

    IcaIgnorePushBitOnReceives = (BOOLEAN)( ignorePushBit != 0 );

    ZwClose( parametersHandle );

    return;
}


NTSTATUS
IcaOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by ICA to open the registry. If the registry
    tree exists, then it opens it and returns an error. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns STATUS_SUCCESS.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE( );

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ZwCreateKey(
                 &configHandle,
                 KEY_WRITE,
                 &objectAttributes,
                 0,                 // title index
                 NULL,              // class
                 0,                 // create options
                 &disposition       // disposition
                 );

    if (!NT_SUCCESS(status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString (&parametersKeyName, parametersString);

    InitializeObjectAttributes(
        &objectAttributes,
        &parametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        configHandle,               // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 ParametersHandle,
                 KEY_READ,
                 &objectAttributes
                 );
    if (!NT_SUCCESS(status)) {

        ZwClose( configHandle );
        return status;
    }

    //
    // All keys successfully opened or created.
    //

    ZwClose( configHandle );
    return STATUS_SUCCESS;
}


ULONG
IcaReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by ICA to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    static ULONG informationBuffer[32];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION information =
        (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;

    PAGED_CODE( );

    RtlInitUnicodeString( &valueKeyName, ValueName );

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValueFullInformation,
                 (PVOID)information,
                 sizeof (informationBuffer),
                 &informationLength
                 );

    if ((status == STATUS_SUCCESS) && (information->DataLength == sizeof(ULONG))) {

        RtlMoveMemory(
            (PVOID)&returnValue,
            ((PUCHAR)information) + information->DataOffset,
            sizeof(ULONG)
            );

        if (returnValue < 0) {

            returnValue = DefaultValue;

        }

    } else {

        returnValue = DefaultValue;
    }

    return returnValue;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\keyboard.c ===
/*************************************************************************
*
* keyboard.c
*
* This module contains routines for managing the ICA keyboard channel.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddkbd.h>


NTSTATUS
IcaDeviceControlKeyboard(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the device control routine for the ICA keyboard channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    SD_IOCTL SdIoctl;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlKeyboard, fc %d, ref %u (enter)\n",
                   (code & 0x3fff) >> 2, pChannel->RefCount ));
    switch ( code ) {

#if 0 // no longer used
        /*
         * Special IOCTL to allow keyboard input data to be fed
         * into the keyboard channel.
         */
        case IOCTL_KEYBOARD_ICA_INPUT :

            /*
             * Make sure the input data is the correct size.
             */
            if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength %
                 sizeof(KEYBOARD_INPUT_DATA) )
                return( STATUS_BUFFER_TOO_SMALL );

            /*
             * We need a stack object to pass to IcaChannelInputInternal.
             * Any one will do so we grab the head of the stack list.
             * (There MUST be one for this IOCTL to succeed.)
             */
            IcaLockConnection( pChannel->pConnect );
            if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                IcaUnlockConnection( pChannel->pConnect );
                return( STATUS_INVALID_DEVICE_REQUEST );
            }
            pStack = CONTAINING_RECORD( pChannel->pConnect->StackHead.Flink,
                                        ICA_STACK, StackEntry );
            IcaReferenceStack( pStack );
            IcaUnlockConnection( pChannel->pConnect );

            /*
             * Send keyboard input
             */
            IcaChannelInputInternal( pStack, Channel_Keyboard, 0, NULL,
                                     (PCHAR)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                     IrpSp->Parameters.DeviceIoControl.InputBufferLength );

            IcaDereferenceStack( pStack );
            Status = STATUS_SUCCESS;
            break;
#endif


        /*
         * The following keyboard ioctls use METHOD_NEITHER so get the
         * input buffer from the DeviceIoControl parameters.
         */
        case IOCTL_KEYBOARD_ICA_LAYOUT :
        case IOCTL_KEYBOARD_ICA_SCANMAP :
        case IOCTL_KEYBOARD_ICA_TYPE :
            if ( Irp->RequestorMode != KernelMode ) {
                ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                              IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                              TYPE_ALIGNMENT(BYTE) );
                ProbeForWrite( Irp->UserBuffer,
                               IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                               TYPE_ALIGNMENT(BYTE) );
            }
    
            SdIoctl.IoControlCode = code;
            SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
            SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            SdIoctl.OutputBuffer = Irp->UserBuffer;
            SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );
            break;


        /*
         * All other keyboard ioctls use METHOD_BUFFERED so get the
         * input buffer from the AssociatedIrp.SystemBuffer field.
         */
        default:
            SdIoctl.IoControlCode = code;
            SdIoctl.InputBuffer = Irp->AssociatedIrp.SystemBuffer;
            SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            SdIoctl.OutputBuffer = SdIoctl.InputBuffer;
            SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );

            if (Status == STATUS_SUCCESS ) 
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

            break;
    }

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlKeyboard, fc %d, ref %u, 0x%x\n",
                   (code & 0x3fff) >> 2, pChannel->RefCount, Status ));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

/*
 *  Need to define these to have MP save driver ( proper locked operation will generated for x86)-Bug# 209464
 */


#include <ntosp.h>

#include <zwapi.h>
#include <winstaw.h>
#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <icadd.h>
#include <sdapi.h>
#include "icap.h"
#include "icadata.h"
#include "icaprocs.h"

#include "stdarg.h"
#include "stdio.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\misc.c ===
/****************************************************************************/
// misc.c
//
// Miscellaneous TermDD routines.
//
// Copyright (C) 1998-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop


#if DBG

LIST_ENTRY IcaGlobalPoolListHead;
ULONG IcaTotalAllocations = 0;
ULONG IcaTotalFrees = 0;
ULONG IcaTotalBytesAllocated = 0;
KSPIN_LOCK IcaDebugSpinLock;

typedef struct _ICA_POOL_HEADER {
    LIST_ENTRY GlobalPoolListEntry;
    PCHAR FileName;
    ULONG LineNumber;
    ULONG Size;
    ULONG InUse;
} ICA_POOL_HEADER, *PICA_POOL_HEADER;

typedef struct _ICA_POOL_TRAILER {
    ULONG Size;
    ULONG_PTR CheckSum;
} ICA_POOL_TRAILER, *PICA_POOL_TRAILER;


void IcaInitializeDebugData(void)
{
    KeInitializeSpinLock(&IcaDebugSpinLock);
    InitializeListHead(&IcaGlobalPoolListHead);
}


BOOLEAN IcaLockConnection(PICA_CONNECTION pConnect)
{
    PERESOURCE pResource = &pConnect->Resource;
    PLIST_ENTRY Head, Next;
    PICA_STACK pStack;
    KIRQL oldIrql;
    ULONG i;
    BOOLEAN Result;

    TRACE((pConnect, TC_ICADD, TT_SEM,
            "TermDD: IcaLockConnection: 0x%x\n", pResource));



    /*
     * Ensure we don't already have the connection locked
     */
    ASSERT( !ExIsResourceAcquiredExclusiveLite( pResource ) );

    /*
     * Reference and lock the connection object
     */
    IcaReferenceConnection( pConnect );
    KeEnterCriticalRegion();    // Disable APC calls when holding a resource.
    Result = ExAcquireResourceExclusive( pResource, TRUE );

    /*
     * Ensure we don't own any stack locks
     */
    Head = &pConnect->StackHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );
        ASSERT( !ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );
    }

    /*
     * Ensure we don't own any channel locks
     */
    IcaLockChannelTable(&pConnect->ChannelTableLock);

    for ( i = 0; i < sizeof(pConnect->pChannel) / sizeof(*pConnect->pChannel); i++ ) {
        if (pConnect->pChannel[i]) {
            ASSERT(!ExIsResourceAcquiredExclusiveLite(&pConnect->pChannel[i]->Resource));
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);

    return Result;
}


void IcaUnlockConnection(PICA_CONNECTION pConnect)
{
    PERESOURCE pResource = &pConnect->Resource;

    TRACE((pConnect, TC_ICADD, TT_SEM,
            "TermDD: IcaUnlockConnection: 0x%x\n", pResource));

    /*
     * Ensure we already have the connection locked
     */
    ASSERT(ExIsResourceAcquiredExclusiveLite(pResource));

    ExReleaseResource(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

    IcaDereferenceConnection(pConnect);
}


BOOLEAN IcaLockStack(PICA_STACK pStack)
{
    PERESOURCE pResource = &pStack->Resource;
    PICA_CONNECTION pConnect;
    PLIST_ENTRY Head, Next;
    PICA_STACK pNextStack;
    KIRQL oldIrql;
    ULONG i;
    BOOLEAN Result;

    /*
     * Ensure we don't already have the stack locked
     */
    ASSERT( !ExIsResourceAcquiredExclusiveLite( pResource ) );

    /*
     * Reference and lock the stack object
     */
    IcaReferenceStack( pStack );
    KeEnterCriticalRegion();    // Disable APC calls when holding a resource.
    Result = ExAcquireResourceExclusive( pResource, TRUE );

    TRACESTACK((pStack, TC_ICADD, TT_SEM,
            "TermDD: IcaLockStack: 0x%x\n", pStack));

    /*
     * Ensure we don't own any other stack locks
     */
    pConnect = IcaGetConnectionForStack( pStack );
    Head = &pConnect->StackHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pNextStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );
        if ( pNextStack != pStack ) {
            ASSERT( !ExIsResourceAcquiredExclusiveLite( &pNextStack->Resource ) );
        }
    }

    /*
     * Ensure we don't own any channel locks
     */
    IcaLockChannelTable(&pConnect->ChannelTableLock);
    for ( i = 0; i < sizeof(pConnect->pChannel) / sizeof(*pConnect->pChannel); i++ ) {
        if ( pConnect->pChannel[i] ) {
            ASSERT( !ExIsResourceAcquiredExclusiveLite( &pConnect->pChannel[i]->Resource ) );
        }
    }
    IcaUnlockChannelTable(&pConnect->ChannelTableLock);

    return Result;
}


void IcaUnlockStack(PICA_STACK pStack)
{
    PERESOURCE pResource = &pStack->Resource;

    TRACESTACK((pStack, TC_ICADD, TT_SEM,
            "TermDD: IcaUnlockStack: 0x%x\n", pStack));

    /*
     * Ensure we already have the stack locked
     */
    ASSERT(ExIsResourceAcquiredExclusiveLite(pResource));

    ExReleaseResource(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

    IcaDereferenceStack(pStack);
}


BOOLEAN IcaLockChannel(PICA_CHANNEL pChannel)
{
    PERESOURCE pResource = &pChannel->Resource;

    TRACECHANNEL((pChannel, TC_ICADD, TT_SEM,
            "TermDD: IcaLockChannel: cc %u, vc %d\n",
            pChannel->ChannelClass, pChannel->VirtualClass));

    IcaReferenceChannel(pChannel);

    // Need to disable APC calls when holding a resource.
    KeEnterCriticalRegion();
    return ExAcquireResourceExclusive(pResource, TRUE);
}


void IcaUnlockChannel(IN PICA_CHANNEL pChannel)
{
    PERESOURCE pResource = &pChannel->Resource;

    TRACECHANNEL((pChannel, TC_ICADD, TT_SEM,
            "TermDD: IcaUnlockChannel: cc %u, vc %d\n", 
            pChannel->ChannelClass, pChannel->VirtualClass));

    /*
     * Ensure we already have the channel locked
     */
    ASSERT(ExIsResourceAcquiredExclusiveLite(pResource));

    ExReleaseResource(pResource);
    KeLeaveCriticalRegion();  // Resume APC calls after releasing resource.

    IcaDereferenceChannel(pChannel);
}


PVOID IcaAllocatePool(
        IN POOL_TYPE PoolType,
        IN ULONG NumberOfBytes,
        IN PCHAR FileName,
        IN ULONG LineNumber,
        IN BOOLEAN WithQuota)
{
    PICA_POOL_HEADER header;
    PICA_POOL_TRAILER trailer;
    KIRQL oldIrql;

    ASSERT( PoolType == NonPagedPool || PoolType == NonPagedPoolMustSucceed );

    // make sure number of bytes are 64bit aligned
    NumberOfBytes = (NumberOfBytes + 7) & ~7;

    if (WithQuota) {
        try {
            header = ExAllocatePoolWithQuotaTag(
                         PoolType,
                         NumberOfBytes + sizeof(*header) + sizeof(*trailer),
                         ICA_POOL_TAG
                         );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            return NULL;
        }
    } else {
        header = ExAllocatePoolWithTag(
                     PoolType,
                     NumberOfBytes + sizeof(*header) + sizeof(*trailer),
                     ICA_POOL_TAG
                     );
    }

    if (header == NULL) {
        return NULL;
    }

    header->FileName = FileName;
    header->LineNumber = LineNumber;
    header->Size = NumberOfBytes;
    header->InUse = 1;

    trailer = (PICA_POOL_TRAILER)((PCHAR)(header + 1) + NumberOfBytes);
    trailer->Size = NumberOfBytes;
    trailer->CheckSum = (ULONG_PTR)header + (ULONG_PTR)FileName + LineNumber +
            NumberOfBytes;

    InterlockedIncrement(
        &IcaTotalAllocations
        );

    ExInterlockedAddUlong(
        &IcaTotalBytesAllocated,
        header->Size,
        &IcaDebugSpinLock
        );

    ExInterlockedInsertTailList( &IcaGlobalPoolListHead,
                                 &header->GlobalPoolListEntry,
                                 &IcaDebugSpinLock );

    return (PVOID)(header + 1);
}


void IcaFreePool(IN PVOID Pointer)
{
    KIRQL oldIrql;
    PICA_POOL_HEADER header = (PICA_POOL_HEADER)Pointer - 1;
    PICA_POOL_TRAILER trailer;

    trailer = (PICA_POOL_TRAILER)((PCHAR)(header + 1) + header->Size);
    ASSERT( header->Size == trailer->Size );
    ASSERT( trailer->CheckSum = (ULONG_PTR)header + (ULONG_PTR)header->FileName +
                                header->LineNumber + header->Size );

    InterlockedIncrement(
        &IcaTotalFrees
        );

    ExInterlockedAddUlong(
        &IcaTotalBytesAllocated,
        -1*header->Size,
        &IcaDebugSpinLock
        );

    KeAcquireSpinLock( &IcaDebugSpinLock, &oldIrql );
    RemoveEntryList( &header->GlobalPoolListEntry );
    KeReleaseSpinLock( &IcaDebugSpinLock, oldIrql );

    header->GlobalPoolListEntry.Flink = (PLIST_ENTRY)(-1);
    header->GlobalPoolListEntry.Blink = (PLIST_ENTRY)(-1);
    header->InUse = 0;

    if (header->Size == trailer->Size)
        RtlFillMemory(Pointer, header->Size, 0xff);

    ExFreePool((PVOID)header);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ntload.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

   ntload.c

   This module contains support for loading and unloading WD/PD/TD's as
   standard NT drivers.

--*/

#include <precomp.h>
#pragma hdrstop


#if DBG
#define DBGPRINT(x) DbgPrint x
#else
#define DBGPRINT(x)
#endif

#define DEVICE_NAME_PREFIX L"\\Device\\"

#define SERVICE_PATH L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"


NTSTATUS
_IcaLoadSdWorker(
    IN PDLLNAME SdName,
    OUT PSDLOAD *ppSdLoad
    )

/*++

Routine Description:

    Replacement routine for Citrix _IcaLoadSdWorker that uses
    standard NT driver loading.

Arguments:

    SdName - Name of the stack driver to load

    ppSdLoad - Pointer to return stack driver structure in.

Return Value:

    NTSTATUS code.

Environment:

    Kernel mode, DDK
--*/

{
    PIRP Irp;
    PKEVENT pEvent;
    NTSTATUS Status;
    PSDLOAD pSdLoad;
    UNICODE_STRING DriverName;
    UNICODE_STRING DeviceName;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    IO_STATUS_BLOCK Iosb;
    PSD_MODULE_INIT pmi;
    PIO_STACK_LOCATION IrpSp;
    PWCHAR pDriverPath;
    PWCHAR pDeviceName;
    ULONG  szDriverPath;
    ULONG  szDeviceName;

    ASSERT( ExIsResourceAcquiredExclusiveLite( IcaSdLoadResource ) );

    //
    // Allocate a SDLOAD struct
    //
    pSdLoad = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pSdLoad) );
    if ( pSdLoad == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    pEvent = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(KEVENT) );
    if( pEvent == NULL ) {
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    pmi = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(SD_MODULE_INIT) );
    if( pmi == NULL ) {
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    szDeviceName = sizeof(DEVICE_NAME_PREFIX) + sizeof(pSdLoad->SdName) + sizeof(WCHAR);
    pDeviceName = ICA_ALLOCATE_POOL( NonPagedPool, szDeviceName );
    if( pDeviceName == NULL ) {
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlZeroMemory( pmi, sizeof(*pmi) );

    pSdLoad->RefCount = 1;
    RtlCopyMemory( pSdLoad->SdName, SdName, sizeof( pSdLoad->SdName ) );

    szDriverPath = sizeof(SERVICE_PATH) + sizeof(pSdLoad->SdName) + sizeof(WCHAR);
    pDriverPath = ICA_ALLOCATE_POOL( NonPagedPool, szDriverPath );
    if( pDriverPath == NULL ) {
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    wcscpy(pDriverPath, SERVICE_PATH);
    wcscat(pDriverPath, pSdLoad->SdName);

    RtlInitUnicodeString( &DriverName, pDriverPath );

    wcscpy(pDeviceName, DEVICE_NAME_PREFIX);
    wcscat(pDeviceName, pSdLoad->SdName);
    pSdLoad->pUnloadWorkItem = NULL;

    RtlInitUnicodeString( &DeviceName, pDeviceName );

    KeInitializeEvent( pEvent, NotificationEvent, FALSE );

    // Load the NT driver
    Status = ZwLoadDriver( &DriverName );
    if ( !NT_SUCCESS( Status ) && (Status != STATUS_IMAGE_ALREADY_LOADED)) {
        DBGPRINT(("TermDD: ZwLoadDriver %wZ failed, 0x%x, 0x%x\n", &DriverName, Status, &DriverName ));
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pDriverPath );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( Status );
    }

    //
    // Now open the driver and get our stack driver pointers
    //

    Status = IoGetDeviceObjectPointer(
                 &DeviceName,  // Device name is module name IE: \Device\TDTCP
                 GENERIC_ALL,
                 &FileObject,
                 &DeviceObject
                 );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TermDD: IoGetDeviceObjectPointer %wZ failed, 0x%x\n", &DeviceName, Status ));
        ZwUnloadDriver( &DriverName );
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pDriverPath );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        return( Status );
    }

    //
    // Send the internal IOCTL_SD_MODULE_INIT to the device to
    // get its stack interface pointers.
    //
    Irp = IoBuildDeviceIoControlRequest(
              IOCTL_SD_MODULE_INIT,
              DeviceObject,
              NULL,         // InputBuffer
              0,            // InputBufferLength
              (PVOID)pmi,   // OutputBuffer
              sizeof(*pmi), // OutputBufferLength
              TRUE,         // Use IRP_MJ_INTERNAL_DEVICE_CONTROL
              pEvent,
              &Iosb
              );

    if( Irp == NULL ) {
        ObDereferenceObject( FileObject );
        ZwUnloadDriver( &DriverName );
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pDriverPath );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pSdLoad );
        DBGPRINT(( "TermDD: Could not allocate IRP %S failed\n", SdName ));
        return( Status );
    }

    ObReferenceObject( FileObject );
    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    IrpSp = IoGetNextIrpStackLocation( Irp );
    IrpSp->FileObject = FileObject;
    Irp->Flags |= IRP_SYNCHRONOUS_API;

    // Call the driver
    Status = IoCallDriver( DeviceObject, Irp );
    if( Status == STATUS_PENDING ) {
        Status = KeWaitForSingleObject( pEvent, UserRequest, KernelMode, FALSE, NULL );
    }

    // Get the result from the actual I/O operation
    if( Status == STATUS_SUCCESS ) {
        Status = Iosb.Status;
    }

    if( NT_SUCCESS(Status) ) {
        ASSERT( Iosb.Information == sizeof(*pmi) );
        pSdLoad->DriverLoad = pmi->SdLoadProc;
        pSdLoad->FileObject = FileObject;
        pSdLoad->DeviceObject = DeviceObject;
        InsertHeadList( &IcaSdLoadListHead, &pSdLoad->Links );
        *ppSdLoad = pSdLoad;
    }
    else {
        DBGPRINT(("TermDD: Error getting module pointers 0x%x\n",Status));
#if DBG
DbgBreakPoint();
#endif
        ObDereferenceObject( FileObject );
        ZwUnloadDriver( &DriverName );
        ICA_FREE_POOL( pSdLoad );
        ICA_FREE_POOL( pDeviceName );
        ICA_FREE_POOL( pmi );
        ICA_FREE_POOL( pEvent );
        ICA_FREE_POOL( pDriverPath );
        return( Status );
    }

    // Cleanup

    ICA_FREE_POOL( pDeviceName );
    ICA_FREE_POOL( pDriverPath );
    ICA_FREE_POOL( pmi );
    ICA_FREE_POOL( pEvent );

    return( Status );
}

NTSTATUS
_IcaUnloadSdWorker(
    IN PSDLOAD pSdLoad
    )

/*++

    Replacement routine for Citrix _IcaUnloadSdWorker that uses
    standard NT driver unloading.

Arguments:
    SdName - Name of the stack driver to load
    ppSdLoad - Pointer to return stack driver structure in.

Environment:
    Kernel mode, DDK
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DriverName;
    WCHAR DriverPath[sizeof(SERVICE_PATH) + 
                     sizeof(pSdLoad->SdName) + 
                     sizeof(WCHAR)];
    PSDLOAD pSdLoadInList;
    PLIST_ENTRY Head, Next;


    /*
     * free the workitem
     */

    ASSERT(pSdLoad->pUnloadWorkItem != NULL);
    ICA_FREE_POOL(pSdLoad->pUnloadWorkItem);
    pSdLoad->pUnloadWorkItem = NULL;
    
    wcscpy(DriverPath, SERVICE_PATH);
    wcscat(DriverPath, pSdLoad->SdName);
    RtlInitUnicodeString(&DriverName, DriverPath);


    /*
     * Lock the ICA Resource exclusively to search the SdLoad list.
     * Note when holding a resource we need to prevent APC calls, so
     * use KeEnterCriticalRegion().
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );

    /*
     * Look for the requested SD.  If found, and refcount is still 0, then
     * unload it. If refcount is not zero then someone has referenced it since
     * we have posted the workitem and we do not want to unload it anymore.
     *
     */
    Head = &IcaSdLoadListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pSdLoadInList = CONTAINING_RECORD( Next, SDLOAD, Links );
        if ( !wcscmp( pSdLoad->SdName, pSdLoadInList->SdName ) ) {
            ASSERT(pSdLoad == pSdLoadInList);
            if (--pSdLoad->RefCount != 0) {
                break;
            }
            
            /*
             * We found the driver and Refcount is Zero let unload it
             */
            Status = ZwUnloadDriver(&DriverName);

            if (Status != STATUS_INVALID_DEVICE_REQUEST) {
                RemoveEntryList(&pSdLoad->Links);
                ObDereferenceObject (pSdLoad->FileObject);
                ICA_FREE_POOL(pSdLoad);
            }
            else {
                // If the driver unloading fails because of invalid request,
                // we keep this pSdLoad around.  It will get cleaned up
                // either unload succeeds or the driver exits.
                // TODO: termdd currently not cleanup all the memory it allocates
                // It does not have unload correctly implemented.  So, we didn't put
                // cleanup for this in the unload function.  That needs to be looked
                // at it once unload function is hooked up.
                DBGPRINT(("TermDD: ZwUnLoadDriver %wZ failed, 0x%x, 0x%x\n", &DriverName, Status, &DriverName ));
            }

            break;

        }
    }

    /*
     * We should always find the driver in the list
     */

    ASSERT(Next != Head);
    ExReleaseResourceLite( IcaSdLoadResource);
    KeLeaveCriticalRegion();

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\mouse.c ===
/*************************************************************************
*
* mouse.c
*
* This module contains routines for managing the ICA mouse channel.
*
* Copyright 1998, Microsoft.
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddmou.h>


NTSTATUS
IcaDeviceControlMouse(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the DeviceControl routine for the ICA mouse channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    SD_IOCTL SdIoctl;
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    switch ( code ) {

#if 0 // no longer used
        /*
         * Special IOCTL to allow mouse input data to be fed
         * into the mouse channel.
         */
        case IOCTL_MOUSE_ICA_INPUT :

            /*
             * Make sure the input data is the correct size.
             */
            if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength %
                 sizeof(MOUSE_INPUT_DATA) )
                return( STATUS_BUFFER_TOO_SMALL );

            /*
             * We need a stack object to pass to IcaChannelInputInternal.
             * Any one will do so we grab the head of the stack list.
             * (There MUST be one for this IOCTL to succeed.)
             */
            IcaLockConnection( pChannel->pConnect );
            if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                IcaUnlockConnection( pChannel->pConnect );
                return( STATUS_INVALID_DEVICE_REQUEST );
            }
            pStack = CONTAINING_RECORD( pChannel->pConnect->StackHead.Flink,
                                        ICA_STACK, StackEntry );
            IcaReferenceStack( pStack );
            IcaUnlockConnection( pChannel->pConnect );

            /*
             * Send mouse input
             */
            IcaChannelInputInternal( pStack, Channel_Mouse, 0, NULL,
                                     (PCHAR)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                     IrpSp->Parameters.DeviceIoControl.InputBufferLength );

            IcaDereferenceStack( pStack );
            Status = STATUS_SUCCESS;
            break;
#endif

        default:
            SdIoctl.IoControlCode = code;
            SdIoctl.InputBuffer = Irp->AssociatedIrp.SystemBuffer;
            SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
            SdIoctl.OutputBuffer = Irp->UserBuffer;
            SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );
            break;
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ptdrvkbd.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvkbd.c

Abstract:

    Keyboard specific parts of the RDP remote port driver.

Environment:

    Kernel mode only.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/
#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtKeyboardConfiguration)
#pragma alloc_text(PAGE, PtKeyboardStartDevice)
#pragma alloc_text(PAGE, PtKeyboardRemoveDevice)
#endif


VOID
PtSendCurrentKeyboardInput(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA pInput,
    IN ULONG ulEntries
    )
/*++

Routine Description:

    This routine calls the keyboard class driver until all the data has been
    queued.

Arguments:

    DeviceObject - Pointer to the device object

Return Value:

    None

--*/
{
    PPORT_KEYBOARD_EXTENSION deviceExtension;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;
    PUCHAR pEnd;

    Print(DBG_DPC_NOISE, ("PtSendCurrentKeyboardInput: enter\n"));

    if (DeviceObject != NULL) {
        deviceExtension = DeviceObject->DeviceExtension;

        if (deviceExtension->EnableCount) {
            PVOID classService;
            PVOID classDeviceObject;
            ULONG dataNotConsumed = 0;
            ULONG inputDataConsumed = 0;

            //
            // Call the connected class driver's callback ISR
            //
            classDeviceObject = deviceExtension->ConnectData.ClassDeviceObject;
            classService      = deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            Print(DBG_DPC_NOISE,
                  ("PtSendCurrentKeyboardInput: calling class callback (%p, %ld)\n",
                  pInput, ulEntries));

            dataNotConsumed = ulEntries;
            pEnd = (PUCHAR)pInput + (ulEntries * sizeof(KEYBOARD_INPUT_DATA));
            while (dataNotConsumed)
            {
                KIRQL oldIrql;

                inputDataConsumed = 0;

                //
                // Class Service Callback routines need to be execusted at
                // DISPATCH_LEVEL, so raise IRQL before calling the callback.
                //

                KeRaiseIrql( DISPATCH_LEVEL, &oldIrql);

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      pInput,
                      pEnd,
                      &inputDataConsumed);

                //
                // reset the IRQL.
                //

                KeLowerIrql( oldIrql );

                dataNotConsumed = ((ULONG)(pEnd - (PUCHAR)pInput)
                                   /sizeof(KEYBOARD_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("PtSendCurrentKeyboardInput: Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed));

                if (dataNotConsumed)
                {
                    //
                    // update the input pointer
                    //
                    pInput = (PKEYBOARD_INPUT_DATA)((PUCHAR)pInput +
                                    inputDataConsumed * sizeof(KEYBOARD_INPUT_DATA));

                    //
                    // sleep for 1 ms
                    //
                    SleepTime = RtlEnlargedIntegerMultiply( 1, -10000 );
                    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );
                }
            }
        }

    } else {
        Print(DBG_DPC_ERROR, ("PtSendCurrentKeyboardInput called with NULL Keyboard Device Object\n"));
    }

    Print(DBG_DPC_NOISE, ("PtSendCurrentKeyboardInput: exit\n"));
}


NTSTATUS
PtKeyboardConfiguration(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    This routine retrieves the configuration information for the keyboard.

Arguments:

    KeyboardExtension - Keyboard extension

    ResourceList - Translated resource list give to us via the start IRP

Return Value:

    STATUS_SUCCESS if all the resources required are presented

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PCM_PARTIAL_RESOURCE_LIST           partialResList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     firstResDesc = NULL,
                                        currentResDesc = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResDesc = NULL;
    PI8042_CONFIGURATION_INFORMATION    configuration;

    PKEYBOARD_ID                        keyboardId;

    ULONG                               count,
                                        i;

    PAGED_CODE();

    if (ResourceList) {
        fullResDesc = ResourceList->List;
        if (!fullResDesc) {
            //
            // this should never happen
            //
            ASSERT(fullResDesc != NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        configuration = &Globals.ControllerData->Configuration;

        partialResList = &fullResDesc->PartialResourceList;
        currentResDesc = firstResDesc = partialResList->PartialDescriptors;
        count = partialResList->Count;

        for (i = 0; i < count; i++, currentResDesc++) {
            switch (currentResDesc->Type) {
            case CmResourceTypePort:
                //
                // Copy the port information.  We will sort the port list
                // into ascending order based on the starting port address
                // later (note that we *know* there are a max of two port
                // ranges for the i8042).
                //
                Print(DBG_SS_NOISE,
                      ("port is %s\n",
                      currentResDesc->Flags == CM_RESOURCE_PORT_MEMORY ?
                         "memory" :
                         "an io port"
                      ));

                if (configuration->PortListCount < MaximumPortCount) {
                    configuration->PortList[configuration->PortListCount] =
                        *currentResDesc;
                    configuration->PortListCount += 1;
                }
                else {
                    Print(DBG_SS_INFO | DBG_SS_ERROR,
                          ("KB::PortListCount already at max (%d)\n",
                           configuration->PortListCount
                          )
                         );
                }
                break;

            default:
                Print(DBG_ALWAYS,
                      ("resource type 0x%x unhandled...\n",
                      (LONG) currentResDesc->Type
                      ));
                break;
            }
        }

    }
    else
        Print(DBG_SS_INFO | DBG_SS_TRACE, ("keyboard with null resources\n"));

    return status;
}

NTSTATUS
PtKeyboardStartDevice(
    IN OUT PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    )
/*++

Routine Description:

    Configures the keyboard's device extension (ie allocation of pool,
    initialization of DPCs, etc).  If the keyboard is the last device to start,
    it will also initialize the hardware and connect all the interrupts.

Arguments:

    KeyboardExtension - Keyboard extesnion

    ResourceList - Translated resource list for this device

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    ULONG                               dumpData[1];
    NTSTATUS                            status = STATUS_SUCCESS;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("PtKeyboardStartDevice, enter\n"));

    //
    // Check to see if kb has been started.  If so, fail this start
    //
    if (KEYBOARD_INITIALIZED()) {
        Print(DBG_SS_ERROR, ("too many kbs!\n"));

        //
        // This is not really necessary because the value won't ever be checked
        // in the context of seeing if all the keyboards were bogus, but it is
        // done so that Globals.AddedKeyboards == # of actual started keyboards
        //
        InterlockedDecrement(&Globals.AddedKeyboards);

        status = STATUS_NO_SUCH_DEVICE;
        goto PtKeyboardStartDeviceExit;
    }
    else if (KeyboardExtension->ConnectData.ClassService == NULL) {
        //
        // We are never really going to get here because if we don't have the
        // class driver on top of us, extension->IsKeyboard will be false and
        // we will think that the device is a mouse, but for completeness

        //
        // No class driver on top of us == BAD BAD BAD
        //
        // Fail the start of this device in the hope that there is another stack
        // that is correctly formed.  Another side affect of having no class
        // driver is that the AddedKeyboards count is not incremented for this
        // device
        //

        Print(DBG_SS_ERROR, ("Keyboard started with out a service cb!\n"));
        return STATUS_INVALID_DEVICE_STATE;
    }

    status = PtKeyboardConfiguration(KeyboardExtension,
                                      ResourceList
                                      );

    if (!NT_SUCCESS(status)) {
        goto PtKeyboardStartDeviceExit;
    }

    ASSERT( KEYBOARD_PRESENT() );

    Globals.KeyboardExtension = KeyboardExtension;

    PtInitWmi(GET_COMMON_DATA(KeyboardExtension));

    KeyboardExtension->Initialized = TRUE;

PtKeyboardStartDeviceExit:
    Print(DBG_SS_INFO,
          ("PtKeyboardStartDevice %s\n",
          NT_SUCCESS(status) ? "successful" : "unsuccessful"
          ));

    Print(DBG_SS_TRACE, ("PtKeyboardStartDevice exit (0x%x)\n", status));

    return status;
}

VOID
PtKeyboardRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Removes the device.  This will only occur if the device removed itself.
    Disconnects the interrupt, removes the synchronization flag for the mouse if
    present, and frees any memory associated with the device.

Arguments:

    DeviceObject - The device object for the keyboard

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    PPORT_KEYBOARD_EXTENSION keyboardExtension = DeviceObject->DeviceExtension;
    PIRP irp;

    Print(DBG_PNP_INFO, ("PtKeyboardRemoveDevice enter\n"));

    PAGED_CODE();

    if (Globals.KeyboardExtension == keyboardExtension && keyboardExtension) {
        Globals.KeyboardExtension = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ptdrvmou.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvmou.c

Abstract:

    Mouse specific parts of the RDP remote port driver.

Environment:

    Kernel mode only.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtMouseConfiguration)
#pragma alloc_text(PAGE, PtMouseStartDevice)
#endif

NTSTATUS
PtMouseConfiguration(
    IN PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST     ResourceList
    )
/*++

Routine Description:

    This routine retrieves the configuration information for the mouse.

Arguments:

    MouseExtension - Mouse extension

    ResourceList   - Translated resource list give to us via the start IRP

Return Value:

    STATUS_SUCCESS if all the resources required are presented

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PCM_PARTIAL_RESOURCE_LIST           partialResList = NULL;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     firstResDesc   = NULL,
                                        currentResDesc = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR        fullResDesc    = NULL;
    PI8042_CONFIGURATION_INFORMATION    configuration;

    ULONG                               count,
                                        i;

    PAGED_CODE();

    if (ResourceList) {
        fullResDesc = ResourceList->List;

        if (!fullResDesc) {
            //
            // this should never happen
            //
            ASSERT(fullResDesc != NULL);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);
        configuration = &Globals.ControllerData->Configuration;

        partialResList = &fullResDesc->PartialResourceList;
        currentResDesc = firstResDesc = partialResList->PartialDescriptors;
        count = partialResList->Count;

        //
        // NOTE:  not all of the resources associated with the i8042 may be given at
        //        this time.  From empirical tests, the mouse is only associated with its
        //        interrupt, while the keyboard will receive the ports along with its
        //        interrupt
        //
        for (i = 0; i < count; i++, currentResDesc++) {
            switch (currentResDesc->Type) {
            case CmResourceTypePort:
                //
                // Copy the port information.  We will sort the port list
                // into ascending order based on the starting port address
                // later (note that we *know* there are a max of two port
                // ranges for the i8042).
                //
                Print(DBG_SS_NOISE, ("io flags are 0x%x\n", currentResDesc->Flags));

                if (configuration->PortListCount < MaximumPortCount) {
                    configuration->PortList[configuration->PortListCount] = *currentResDesc;
                    configuration->PortListCount += 1;
                }
                else {
                    Print(DBG_SS_INFO | DBG_SS_ERROR,
                          ("Mouse::PortListCount already at max (%d)",
                          configuration->PortListCount
                          ));
                }
                break;

            default:
                Print(DBG_ALWAYS,
                      ("resource type 0x%x unhandled...\n",
                      (LONG) currentResDesc->Type
                      ));
                break;

            }
        }
    }
    else {
        Print(DBG_SS_INFO | DBG_SS_TRACE, ("mouse with null resources\n"));
    }

    if (NT_SUCCESS(status)) {
        Globals.ControllerData->HardwarePresent |= MOUSE_HARDWARE_INITIALIZED;
    }
    return status;
}

VOID
PtSendCurrentMouseInput(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PMOUSE_INPUT_DATA pInput,
    IN ULONG             ulEntries
    )
/*++

Routine Description:

    This routine calls the mouse class driver until all the data has been
    queued.

Arguments:

    DeviceObject - Pointer to the device object

Return Value:

    None

--*/
{
    PPORT_MOUSE_EXTENSION deviceExtension;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;
    PUCHAR pEnd;

    Print(DBG_DPC_NOISE, ("PtSendCurrentMouseInput: enter\n"));

    if (DeviceObject != NULL) {

        deviceExtension = DeviceObject->DeviceExtension;

        if (deviceExtension->EnableCount) {
            PVOID classService;
            PVOID classDeviceObject;
            ULONG dataNotConsumed = 0;
            ULONG inputDataConsumed = 0;

            //
            // Call the connected class driver's callback ISR with the supplied data
            //
            classDeviceObject = deviceExtension->ConnectData.ClassDeviceObject;
            classService      = deviceExtension->ConnectData.ClassService;
            ASSERT(classService != NULL);

            Print(DBG_DPC_NOISE,
                  ("PtSendCurrentMouseInput: calling class callback (%p, %ld)\n",
                  pInput, ulEntries));

            dataNotConsumed = ulEntries;
            pEnd = (PUCHAR)pInput + (ulEntries * sizeof(MOUSE_INPUT_DATA));
            while (dataNotConsumed)
            {
                KIRQL oldIrql;

                inputDataConsumed = 0;

                //
                // Class Service Callback routines need to be execusted at
                // DISPATCH_LEVEL, so raise IRQL before calling the callback.
                //

                KeRaiseIrql( DISPATCH_LEVEL, &oldIrql);

                (*(PSERVICE_CALLBACK_ROUTINE) classService)(
                      classDeviceObject,
                      pInput,
                      pEnd,
                      &inputDataConsumed);

                //
                // reset the IRQL.
                //

                KeLowerIrql( oldIrql );

                dataNotConsumed = ((ULONG)(pEnd - (PUCHAR)pInput)
                                   /sizeof(MOUSE_INPUT_DATA)) - inputDataConsumed;

                Print(DBG_DPC_INFO,
                      ("PtSendCurrentMouseInput: Call callback consumed %d items, left %d\n",
                      inputDataConsumed,
                      dataNotConsumed));

                if (dataNotConsumed)
                {
                    //
                    // update the input pointer
                    //
                    pInput = (PMOUSE_INPUT_DATA)((PUCHAR)pInput +
                                    inputDataConsumed * sizeof(MOUSE_INPUT_DATA));

                    //
                    // sleep for 1 ms
                    //
                    SleepTime = RtlEnlargedIntegerMultiply( 1, -10000 );
                    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );
                }
            }
        }

    } else {
        Print(DBG_DPC_ERROR, ("PtSendCurrentMouseInput called with NULL Mouse Device Object\n"));
    }

    Print(DBG_DPC_NOISE, ("PtSendCurrentMouseInput: exit\n"));
}


NTSTATUS
PtMouseStartDevice(
    PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST  ResourceList
    )
/*++

Routine Description:

    Configures the mouse's device extension (ie allocation of pool,
    initialization of DPCs, etc).  If the mouse is the last device to start,
    it will also initialize the hardware and connect all the interrupts.

Arguments:

    MouseExtension - Mouse extesnion

    ResourceList - Translated resource list for this device

Return Value:

    STATUS_SUCCESSFUL if successful,

--*/
{
    NTSTATUS                            status = STATUS_SUCCESS;

    PAGED_CODE();

    Print(DBG_SS_TRACE, ("PtMouseStartDevice, enter\n"));

    //
    // Check to see if a mouse has been started. If so, fail this start.
    //
    if (MOUSE_INITIALIZED()) {
        Print(DBG_SS_ERROR, ("too many mice!\n"));

        //
        // This is not really necessary because the value won't ever be checked
        // in the context of seeing if all the mice were bogus, but it is
        // done so that Globals.AddedMice == # of actual started mice
        //
        InterlockedDecrement(&Globals.AddedMice);

        status =  STATUS_NO_SUCH_DEVICE;
        goto PtMouseStartDeviceExit;
    }
    else if (MouseExtension->ConnectData.ClassService == NULL) {
        //
        // No class driver on top of us == BAD BAD BAD
        //
        // Fail the start of this device in the hope that there is another stack
        // that is correctly formed.  Another side affect of having no class
        // driver is that the AddedMice count is not incremented for this
        // device
        //
        Print(DBG_SS_ERROR, ("Mouse started with out a service cb!\n"));
        status = STATUS_INVALID_DEVICE_STATE;
        goto PtMouseStartDeviceExit;
    }

    //
    // Parse and store all of the resources associated with the mouse
    //
    status = PtMouseConfiguration(MouseExtension,
                                  ResourceList
                                  );
    if (!NT_SUCCESS(status)) {
        PtManuallyRemoveDevice(GET_COMMON_DATA(MouseExtension));
        goto PtMouseStartDeviceExit;
    }

    ASSERT( MOUSE_PRESENT() );

    Globals.MouseExtension = MouseExtension;

    PtInitWmi(GET_COMMON_DATA(MouseExtension));

    MouseExtension->Initialized = TRUE;

PtMouseStartDeviceExit:
    Print(DBG_SS_INFO,
          ("PtMouseStartDevice %s\n",
          NT_SUCCESS(status) ? "successful" : "unsuccessful"
          ));

    Print(DBG_SS_TRACE, ("PtMouseStartDevice exit (0x%x)\n", status));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ptdrvcom.h ===
/*

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvprt.h

Abstract:

    Structures and defines used the RDP remote port driver.

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#ifndef _PTDRVCOM_
#define _PTDRVCOM_

#include <ntddk.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntdd8042.h>
#include <kbdmou.h>
#include <wmilib.h>

#include "ptdrvstr.h"


//
// Define the device types for the first field in the device extensions
//

#define DEV_TYPE_TERMDD 1
#define DEV_TYPE_PORT   2

#define REMOTE_PORT_POOL_TAG (ULONG) 'PMER'
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, REMOTE_PORT_POOL_TAG)

//
// Set up some debug options
//
#ifdef PAGED_CODE
#undef PAGED_CODE
#endif

#if DBG
#define PTDRV_VERBOSE 1

#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "RemotePrt: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        DbgBreakPoint(); \
        }
#else
#define PAGED_CODE()
#endif

//
// Define device name for our driver
//

#define RDP_CONSOLE_BASE_NAME0 L"\\Device\\RDP_CONSOLE0"
#define RDP_CONSOLE_BASE_NAME1 L"\\Device\\RDP_CONSOLE1"

//
// Custom resource type used when pruning the fdo's resource lists
//
#define PD_REMOVE_RESOURCE 0xef

//
// Mouse reset IOCTL
//
#define IOCTL_INTERNAL_MOUSE_RESET  \
            CTL_CODE(FILE_DEVICE_MOUSE, 0x0FFF, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Default number of function keys, number of LED indicators, and total
// number of keys
//
#define KEYBOARD_NUM_FUNCTION_KEYS         12
#define KEYBOARD_NUM_INDICATORS             3
#define KEYBOARD_NUM_KEYS_TOTAL           101

//
// Default values for keyboard typematic rate and delay.
//
#define KEYBOARD_TYPEMATIC_RATE_DEFAULT    30
#define KEYBOARD_TYPEMATIC_DELAY_DEFAULT  250

//
// Default info for the mouse
//
#define MOUSE_IDENTIFIER MOUSE_I8042_HARDWARE
#define MOUSE_NUM_BUTTONS                   2
#define MOUSE_SAMPLE_RATE                  60
#define MOUSE_INPUT_QLEN                    0

//
// Defines and macros for Globals.ControllerData->HardwarePresent.
//
#define KEYBOARD_HARDWARE_PRESENT               0x001
#define MOUSE_HARDWARE_PRESENT                  0x002
#define WHEELMOUSE_HARDWARE_PRESENT             0x008
#define DUP_KEYBOARD_HARDWARE_PRESENT           0x010
#define DUP_MOUSE_HARDWARE_PRESENT              0x020
#define KEYBOARD_HARDWARE_INITIALIZED           0x100
#define MOUSE_HARDWARE_INITIALIZED              0x200

#define TEST_HARDWARE_PRESENT(bits) \
                ((Globals.ControllerData->HardwarePresent & (bits)) == (bits))
#define CLEAR_HW_FLAGS(bits) (Globals.ControllerData->HardwarePresent &= ~(bits))
#define SET_HW_FLAGS(bits)   (Globals.ControllerData->HardwarePresent |= (bits))

#define KEYBOARD_PRESENT()     TEST_HARDWARE_PRESENT(KEYBOARD_HARDWARE_PRESENT)
#define MOUSE_PRESENT()        TEST_HARDWARE_PRESENT(MOUSE_HARDWARE_PRESENT)
#define KEYBOARD_INITIALIZED() TEST_HARDWARE_PRESENT(KEYBOARD_HARDWARE_INITIALIZED)
#define MOUSE_INITIALIZED()    TEST_HARDWARE_PRESENT(MOUSE_HARDWARE_INITIALIZED)

#define CLEAR_MOUSE_PRESENT()    CLEAR_HW_FLAGS(MOUSE_HARDWARE_INITIALIZED | MOUSE_HARDWARE_PRESENT | WHEELMOUSE_HARDWARE_PRESENT)
#define CLEAR_KEYBOARD_PRESENT() CLEAR_HW_FLAGS(KEYBOARD_HARDWARE_INITIALIZED | KEYBOARD_HARDWARE_PRESENT)

#define KBD_POWERED_UP_STARTED      0x0001
#define MOU_POWERED_UP_STARTED      0x0010
#define MOU_POWERED_UP_SUCCESS      0x0100
#define MOU_POWERED_UP_FAILURE      0x0200
#define KBD_POWERED_UP_SUCCESS      0x1000
#define KBD_POWERED_UP_FAILURE      0x2000

#define CLEAR_POWERUP_FLAGS()   (Globals.PowerUpFlags = 0x0)
#define SET_PWR_FLAGS(bits)     (Globals.PowerUpFlags |= (bits))
#define KEYBOARD_POWERED_UP_STARTED()       SET_PWR_FLAGS(KBD_POWERED_UP_STARTED)
#define MOUSE_POWERED_UP_STARTED()          SET_PWR_FLAGS(MOU_POWERED_UP_STARTED)

#define KEYBOARD_POWERED_UP_SUCCESSFULLY()  SET_PWR_FLAGS(KBD_POWERED_UP_SUCCESS)
#define MOUSE_POWERED_UP_SUCCESSFULLY()     SET_PWR_FLAGS(MOU_POWERED_UP_SUCCESS)

#define KEYBOARD_POWERED_UP_FAILED()  SET_PWR_FLAGS(KBD_POWERED_UP_FAILURE)
#define MOUSE_POWERED_UP_FAILED()     SET_PWR_FLAGS(MOU_POWERED_UP_FAILURE)

//
// Define the i8042 controller input/output ports.
//
typedef enum _I8042_IO_PORT_TYPE {
    DataPort = 0,
    CommandPort,
    MaximumPortCount

} I8042_IO_PORT_TYPE;

//
// Intel i8042 configuration information.
//
typedef struct _I8042_CONFIGURATION_INFORMATION {

    //
    // The port/register resources used by this device.
    //
    CM_PARTIAL_RESOURCE_DESCRIPTOR PortList[MaximumPortCount];
    ULONG PortListCount;

} I8042_CONFIGURATION_INFORMATION, *PI8042_CONFIGURATION_INFORMATION;

//
// Define the common portion of the keyboard/mouse device extension.
//
typedef struct COMMON_DATA {
    //
    // Device type field
    //
    ULONG deviceType;

    //
    // Pointer back to the this extension's device object.
    //
    PDEVICE_OBJECT Self;

    //
    // The top of the stack before this filter was added.  AKA the location
    // to which all IRPS should be directed.
    //
    PDEVICE_OBJECT TopOfStack;

    //
    // "THE PDO"  (ejected by root)
    //
    PDEVICE_OBJECT PDO;

    //
    // Current power state that the device is in
    //
    DEVICE_POWER_STATE PowerState;
    POWER_ACTION ShutdownType; 

    //
    // Reference count for number of keyboard enables.
    //
    LONG EnableCount;

    //
    // Class connection data.
    //
    CONNECT_DATA ConnectData;

    //
    // WMI Information
    //
    WMILIB_CONTEXT WmiLibInfo;

    BOOLEAN Initialized;

    BOOLEAN IsKeyboard;

    UNICODE_STRING DeviceName;

    //
    // Has it been started?
    // Has the device been manually removed?
    //
    BOOLEAN Started;
    BOOLEAN ManuallyRemoved;

} *PCOMMON_DATA;

#define GET_COMMON_DATA(ext) ((PCOMMON_DATA) ext)

//
// Define the keyboard portion of the port device extension.
//
typedef struct _PORT_KEYBOARD_EXTENSION {

    //
    // Data in common with the mouse extension;
    //
    struct COMMON_DATA;

} PORT_KEYBOARD_EXTENSION, *PPORT_KEYBOARD_EXTENSION;

//
// Define the mouse portion of the port device extension.
//
typedef struct _PORT_MOUSE_EXTENSION {

    //
    // Data in common with the keyboard extension;
    //
    struct COMMON_DATA;

} PORT_MOUSE_EXTENSION, *PPORT_MOUSE_EXTENSION;

//
// controller specific data used by both devices
//
typedef struct _CONTROLLER_DATA {

    //
    // Indicate which hardware is actually present (keyboard and/or mouse).
    //
    ULONG HardwarePresent;

    //
    // IOCTL synchronization object
    //
    PCONTROLLER_OBJECT ControllerObject;

    //
    // Port configuration information.
    //
    I8042_CONFIGURATION_INFORMATION Configuration;

    //
    // Spin lock to guard powering the devices back up
    //
    KSPIN_LOCK PowerUpSpinLock;

} CONTROLLER_DATA, *PCONTROLLER_DATA;

typedef struct _GLOBALS {

#if PTDRV_VERBOSE
    //
    // Flags:  Bit field for enabling debugging print statements
    // Level:  Legacy way of controllign debugging statements
    //
    ULONG DebugFlags;
#endif

    //
    // Pointer to controller specific data that both extensions may access it
    //
    PCONTROLLER_DATA ControllerData;

    //
    // The two possible extensions that can be created
    //
    PPORT_MOUSE_EXTENSION    MouseExtension;
    PPORT_KEYBOARD_EXTENSION KeyboardExtension;

    //
    // Path to the driver's entry in the registry
    //
    UNICODE_STRING RegistryPath;

    //
    // Keep track of the number of AddDevice and StartDevice calls.  Want to
    // postpone h/w initialization until the last StartDevice is received
    // (due to some h/w which freezes if initialized more than once)
    //
    LONG  AddedKeyboards;
    LONG  AddedMice;
    ULONG ulDeviceNumber;

    USHORT PowerUpFlags;
    

    //
    // Provide mutual exclusion during dispatch functions
    //
    FAST_MUTEX DispatchMutex;

} GLOBALS;

extern GLOBALS Globals;

//
// Statically allocate the (known) scancode-to-indicator-light mapping.
// This information is returned by the
// IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION device control request.
//

#define KEYBOARD_NUMBER_OF_INDICATORS 3

static const INDICATOR_LIST IndicatorList[KEYBOARD_NUMBER_OF_INDICATORS] = {
        {0x3A, KEYBOARD_CAPS_LOCK_ON},
        {0x45, KEYBOARD_NUM_LOCK_ON},
        {0x46, KEYBOARD_SCROLL_LOCK_ON}};

//
// Function prototypes.
//

NTSTATUS
PtEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#if PTDRV_VERBOSE
VOID
PtServiceParameters(
    IN PUNICODE_STRING RegistryPath
    );
#endif

VOID
PtSendCurrentKeyboardInput(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKEYBOARD_INPUT_DATA pInput,
    IN ULONG ulEntries
    );

VOID
PtSendCurrentMouseInput(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMOUSE_INPUT_DATA pInput,
    IN ULONG ulEntries
    );

NTSTATUS
PtClose (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtCreate (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PtInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PtStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PtKeyboardConfiguration(
    IN PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

VOID
PtKeyboardRemoveDevice(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
PtKeyboardStartDevice(
    IN OUT PPORT_KEYBOARD_EXTENSION KeyboardExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PtMouseConfiguration(
    IN PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PtMouseStartDevice(
    PPORT_MOUSE_EXTENSION MouseExtension,
    IN PCM_RESOURCE_LIST ResourceList
    );

NTSTATUS
PtAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    );

VOID
PtFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PtFindPortCallout(
    IN PVOID                        Context,
    IN PUNICODE_STRING              PathName,
    IN INTERFACE_TYPE               BusType,
    IN ULONG                        BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE           ControllerType,
    IN ULONG                        ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE           PeripheralType,
    IN ULONG                        PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

LONG
PtManuallyRemoveDevice(
    PCOMMON_DATA CommonData
    );

NTSTATUS
PtPnP (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtPnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

NTSTATUS
PtPower (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtPowerUpToD0Complete (
	IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
PtRemovePort(
    IN PIO_RESOURCE_DESCRIPTOR ResDesc
    );

NTSTATUS
PtSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
PtUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
PtSystemControl (
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    );

NTSTATUS
PtInitWmi(
    PCOMMON_DATA CommonData
    );

NTSTATUS
PtSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
PtSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
PtKeyboardQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            BufferAvail,
    OUT PUCHAR          Buffer
    );

NTSTATUS
PtMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            BufferAvail,
    OUT PUCHAR          Buffer
    );

NTSTATUS
PtQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    );


extern WMIGUIDREGINFO KbWmiGuidList[1];
extern WMIGUIDREGINFO MouWmiGuidList[1];

#if DBG
#define DEFAULT_DEBUG_FLAGS 0x8cc88888
#else
#define DEFAULT_DEBUG_FLAGS 0x0
#endif


#if PTDRV_VERBOSE
//
//Debug messaging and breakpoint macros
//
#define DBG_ALWAYS                 0x00000000

#define DBG_STARTUP_SHUTDOWN_MASK  0x0000000F
#define DBG_SS_NOISE               0x00000001
#define DBG_SS_TRACE               0x00000002
#define DBG_SS_INFO                0x00000004
#define DBG_SS_ERROR               0x00000008

#define DBG_IOCTL_MASK             0x00000F00
#define DBG_IOCTL_NOISE            0x00000100
#define DBG_IOCTL_TRACE            0x00000200
#define DBG_IOCTL_INFO             0x00000400
#define DBG_IOCTL_ERROR            0x00000800

#define DBG_DPC_MASK               0x0000F000
#define DBG_DPC_NOISE              0x00001000
#define DBG_DPC_TRACE              0x00002000
#define DBG_DPC_INFO               0x00004000
#define DBG_DPC_ERROR              0x00008000

#define DBG_POWER_MASK             0x00F00000
#define DBG_POWER_NOISE            0x00100000
#define DBG_POWER_TRACE            0x00200000
#define DBG_POWER_INFO             0x00400000
#define DBG_POWER_ERROR            0x00800000

#define DBG_PNP_MASK               0x0F000000
#define DBG_PNP_NOISE              0x01000000
#define DBG_PNP_TRACE              0x02000000
#define DBG_PNP_INFO               0x04000000
#define DBG_PNP_ERROR              0x08000000

#define Print(_flags_, _x_) \
            if (Globals.DebugFlags & (_flags_) || !(_flags_)) { \
                DbgPrint (pDriverName); \
                DbgPrint _x_; \
            }
#define TRAP() DbgBreakPoint()

#else

#define Print(_l_,_x_)
#define TRAP()

#endif  // PTDRV_VERBOSE

#endif // _PTDRVCOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ptdrvstr.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvstr.c

Abstract:

    These are the string constants used in the RDP Remote Port Driver.
    Using pointers to these string allows for better memory
    utilization and more readable code

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#include <precomp.h>
#pragma hdrstop

#include "ptdrvstr.h"

//
// Define some of the constant strings used for the debugger
//
const   PSTR    pDriverName                 = PTDRV_DRIVER_NAME_A;
const   PSTR    pFncServiceParameters       = PTDRV_FNC_SERVICE_PARAMETERS_A;

//
// Define some Constant strings that the drivers uses
//
const   PWSTR   pwDebugFlags                = PTDRV_DEBUGFLAGS_W;
const   PWSTR   pwParameters                = PTDRV_PARAMETERS_W;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ptdrvcom.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvcom.c

Abstract:

    Code for the RDP remote port driver which is common to the mouse and keyboard

Environment:

    Kernel mode only.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#include <precomp.h>
#pragma hdrstop

#include <poclass.h>

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtCreate)
#pragma alloc_text(PAGE, PtDeviceControl)
#pragma alloc_text(INIT, PtEntry)
#pragma alloc_text(PAGE, PtUnload)
#if PTDRV_VERBOSE
#pragma alloc_text(INIT, PtServiceParameters)
#endif
#endif // ALLOC_PRAGMA

GLOBALS Globals;

NTSTATUS
PtCreate (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for create/open requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PCOMMON_DATA        commonData = NULL;

    Print(DBG_IOCTL_TRACE, ("Create enter\n"));

    PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    if (NULL == commonData->ConnectData.ClassService) {
        //
        // No Connection yet.  How can we be enabled?
        //
        Print(DBG_IOCTL_ERROR,
              ("ERROR: enable before connect!\n"));
        status = STATUS_INVALID_DEVICE_STATE;
    }
    else if (commonData->ManuallyRemoved) {
        status = STATUS_NO_SUCH_DEVICE;
    }
    else if (1 >= InterlockedIncrement(&commonData->EnableCount)) {
        Print(DBG_IOCTL_INFO,
             ("Enabling %s (%d)\n",
             commonData->IsKeyboard ? "Keyboard" : "Mouse",
             commonData->EnableCount
             ));
    }

    //
    // No need to call the lower driver (the root bus) because it only handles
    // Power and PnP Irps
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    Print(DBG_IOCTL_TRACE, ("Create (%x)\n", status));

    return status;
}

NTSTATUS
PtClose (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP           Irp
   )
/*++

Routine Description:

    This is the dispatch routine for close requests.  This request
    completes successfully.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    NT status code.

--*/
{
    PCOMMON_DATA        commonData;

    PAGED_CODE();

    Print(DBG_IOCTL_TRACE, ("Close\n"));

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    ASSERT(0 < commonData->EnableCount);

    if (0 >= InterlockedDecrement(&commonData->EnableCount)) {
        Print(DBG_IOCTL_INFO,
              ("Disabling %s (%d)\n",
              commonData->IsKeyboard ? "Keyboard" : "Mouse",
              commonData->EnableCount
              ));
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

NTSTATUS
PtDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPORT_KEYBOARD_EXTENSION    kbExtension;
    PIO_STACK_LOCATION          stack;
    NTSTATUS                    status = STATUS_INVALID_DEVICE_REQUEST;

    PAGED_CODE();

    //
    // Get a pointer to the device extension.
    //
    kbExtension = (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension;

    if (!kbExtension->Started || !kbExtension->IsKeyboard ||
        kbExtension->ManuallyRemoved) {
        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    else {
        stack = IoGetCurrentIrpStackLocation(Irp);
        switch (stack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_GET_SYS_BUTTON_CAPS:
            //
            // We don't support any system buttons
            //
            if (stack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {
                Print(DBG_IOCTL_ERROR, ("get caps, buffer too small\n"));
                status = STATUS_INVALID_BUFFER_SIZE;
            }
            else {
                Print(DBG_IOCTL_INFO, ("Returned sys btn caps of 0x0\n"));
                *(PULONG) Irp->AssociatedIrp.SystemBuffer = 0x0;
                status = STATUS_SUCCESS;
            }

            Irp->IoStatus.Information = sizeof(ULONG);
            break;

        default:
            Print(DBG_IOCTL_ERROR, ("Invalid request 0x%x\n",
                stack->Parameters.DeviceIoControl.IoControlCode));
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
PtInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for internal device control requests.
    This routine cannot be paged because the class drivers send down internal
    IOCTLs at DISPATCH_LEVEL.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION                  irpSp;
    PPORT_MOUSE_EXTENSION               mouseExtension = DeviceObject->DeviceExtension;
    PPORT_KEYBOARD_EXTENSION            kbExtension = DeviceObject->DeviceExtension;
    NTSTATUS                            status;
    ULONG                               sizeOfTranslation;
    PDEVICE_OBJECT                      topOfStack;

    Print(DBG_IOCTL_TRACE, ("IOCTL: enter\n"));

    Irp->IoStatus.Information = 0;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Case on the device control subfunction that is being performed by the
    // requestor.
    //
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Connect a keyboard class device driver to the port driver.
    //

    case IOCTL_INTERNAL_KEYBOARD_CONNECT:
        //
        // This really isn't something to worry about overall, but it is worthy
        // enough to be noted and recorded.  The multiple starts will be handled in
        // PtPnp and PtKeyboardStartDevice routines
        //

        if (KEYBOARD_PRESENT()) {
            Print(DBG_ALWAYS, ("Received 1+ kb connects!\n"));
            SET_HW_FLAGS(DUP_KEYBOARD_HARDWARE_PRESENT);
        }

        InterlockedIncrement(&Globals.AddedKeyboards);

        kbExtension->IsKeyboard = TRUE;

        SET_HW_FLAGS(KEYBOARD_HARDWARE_PRESENT);

        Print(DBG_IOCTL_INFO, ("IOCTL: keyboard connect\n"));

        //
        // Save away the keyboard device object - we'll need it later
        //
        KbdDeviceObject = DeviceObject;

        //
        // Only allow a connection if the keyboard hardware is present.
        // Also, only allow one connection.
        //
        if (kbExtension->ConnectData.ClassService != NULL) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - already connected\n"));
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - invalid buffer length\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //

        kbExtension->ConnectData =
            *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

        status = STATUS_SUCCESS;
        break;

    //
    // Disconnect a keyboard class device driver from the port driver.
    //
    // NOTE: Not implemented.
    //
    case IOCTL_INTERNAL_KEYBOARD_DISCONNECT:

        Print(DBG_IOCTL_INFO, ("IOCTL: keyboard disconnect\n"));

        status = STATUS_NOT_IMPLEMENTED;
        break;

    //
    // Connect a mouse class device driver to the port driver.
    //
    case IOCTL_INTERNAL_MOUSE_CONNECT:

        //
        // This really isn't something to worry about overall, but it is worthy
        // enough to be noted and recorded.  The multiple starts will be handled in
        // PtPnp and PtMouseStartDevice routines
        //
        if (MOUSE_PRESENT()) {
            Print(DBG_ALWAYS, ("Received 1+ mouse connects!\n"));
            SET_HW_FLAGS(DUP_MOUSE_HARDWARE_PRESENT);
        }

        InterlockedIncrement(&Globals.AddedMice);

        mouseExtension->IsKeyboard = FALSE;

        SET_HW_FLAGS(MOUSE_HARDWARE_PRESENT);

        Print(DBG_IOCTL_INFO, ("IOCTL: mouse connect\n"));

        //
        // Save away the mouse device object - we'll need it later
        //
        MouDeviceObject = DeviceObject;

        //
        // Only allow a connection if the mouse hardware is present.
        // Also, only allow one connection.
        //
        if (mouseExtension->ConnectData.ClassService != NULL) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - already connected\n"));
            status = STATUS_SHARING_VIOLATION;
            break;
        }
        else if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(CONNECT_DATA)) {

            Print(DBG_IOCTL_ERROR, ("IOCTL: error - invalid buffer length\n"));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        // Copy the connection parameters to the device extension.
        //
        mouseExtension->ConnectData =
            *((PCONNECT_DATA) (irpSp->Parameters.DeviceIoControl.Type3InputBuffer));

        status = STATUS_SUCCESS;
        break;

    //
    // Disconnect a mouse class device driver from the port driver.
    //
    // NOTE: Not implemented.
    //
    case IOCTL_INTERNAL_MOUSE_DISCONNECT:

        Print(DBG_IOCTL_INFO, ("IOCTL: mouse disconnect\n"));

        status = STATUS_NOT_IMPLEMENTED;
        break;

    //
    // Query the keyboard attributes.  First check for adequate buffer
    // length.  Then, copy the keyboard attributes from the device
    // extension to the output buffer.
    //
    case IOCTL_KEYBOARD_QUERY_ATTRIBUTES:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query attributes\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_ATTRIBUTES)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the attributes from the DeviceExtension to the
            // buffer.
            //
            PKEYBOARD_ATTRIBUTES pKBA =
                (PKEYBOARD_ATTRIBUTES)Irp->AssociatedIrp.SystemBuffer;

            pKBA->KeyboardIdentifier.Type    = 0x51;
            pKBA->KeyboardIdentifier.Subtype = 0;

            pKBA->KeyboardMode         = 1;
            pKBA->NumberOfFunctionKeys = KEYBOARD_NUM_FUNCTION_KEYS;
            pKBA->NumberOfIndicators   = KEYBOARD_NUM_INDICATORS;
            pKBA->NumberOfKeysTotal    = KEYBOARD_NUM_KEYS_TOTAL;
            pKBA->InputDataQueueLength = 100;

            pKBA->KeyRepeatMinimum.UnitId    = 0;
            pKBA->KeyRepeatMinimum.Rate      = 2;
            pKBA->KeyRepeatMinimum.Delay     = 250;

            pKBA->KeyRepeatMaximum.UnitId    = 0;
            pKBA->KeyRepeatMaximum.Rate      = 30;
            pKBA->KeyRepeatMaximum.Delay     = 1000;

            Irp->IoStatus.Information = sizeof(KEYBOARD_ATTRIBUTES);
            status = STATUS_SUCCESS;

        }

        break;

    //
    // Query the scan code to indicator-light mapping. Validate the
    // parameters, and copy the indicator mapping information from
    // the port device extension to the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION: {

        PKEYBOARD_INDICATOR_TRANSLATION translation;

        ASSERT(kbExtension->IsKeyboard);

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query indicator translation\n"));

        sizeOfTranslation = sizeof(KEYBOARD_INDICATOR_TRANSLATION)
            + (sizeof(INDICATOR_LIST)
            * (KEYBOARD_NUM_INDICATORS - 1));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeOfTranslation) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the indicator mapping information to the system
            // buffer.
            //

            translation = (PKEYBOARD_INDICATOR_TRANSLATION)
                Irp->AssociatedIrp.SystemBuffer;
            translation->NumberOfIndicatorKeys = KEYBOARD_NUM_INDICATORS;

            RtlMoveMemory(
                translation->IndicatorList,
                (PCHAR) IndicatorList,
                sizeof(INDICATOR_LIST) * translation->NumberOfIndicatorKeys
                );

            Irp->IoStatus.Information = sizeOfTranslation;
            status = STATUS_SUCCESS;
        }

        break;
    }

    //
    // Query the keyboard indicators.  Validate the parameters, and
    // copy the indicator information from the port device extension to
    // the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_INDICATORS:

        ASSERT(kbExtension->IsKeyboard);

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query indicators\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_INDICATOR_PARAMETERS)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Just say they're all off
            //
            ((PKEYBOARD_INDICATOR_PARAMETERS)Irp->AssociatedIrp.SystemBuffer)->LedFlags = 0;
            Irp->IoStatus.Information = sizeof(KEYBOARD_INDICATOR_PARAMETERS);
            status = STATUS_SUCCESS;
        }

        break;

    //
    // Set the keyboard indicators
    //
    case IOCTL_KEYBOARD_SET_INDICATORS:

        // Just return success
        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard set indicators\n"));
        status = STATUS_SUCCESS;

        break;

    //
    // Query the current keyboard typematic rate and delay.  Validate
    // the parameters, and copy the typematic information from the port
    // device extension to the SystemBuffer.
    //
    case IOCTL_KEYBOARD_QUERY_TYPEMATIC:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard query typematic\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(KEYBOARD_TYPEMATIC_PARAMETERS)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // just return our default info
            //
            PKEYBOARD_TYPEMATIC_PARAMETERS pKTP =
                (PKEYBOARD_TYPEMATIC_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;

            pKTP->Rate  = KEYBOARD_TYPEMATIC_RATE_DEFAULT;
            pKTP->Delay = KEYBOARD_TYPEMATIC_DELAY_DEFAULT;

            Irp->IoStatus.Information = sizeof(KEYBOARD_TYPEMATIC_PARAMETERS);
            status = STATUS_SUCCESS;
        }

        break;

    //
    // Sets the keyboard typematic rate and delay
    // We just say 'fine'
    //
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
        {
            status = STATUS_SUCCESS;
        }
        break;

    case IOCTL_KEYBOARD_SET_IME_STATUS:

        Print(DBG_IOCTL_NOISE, ("IOCTL: keyboard set ime status\n"));
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    //
    // Query the mouse attributes.  First check for adequate buffer
    // length.  Then, copy the mouse attributes from the device
    // extension to the output buffer.
    //
    case IOCTL_MOUSE_QUERY_ATTRIBUTES:

        Print(DBG_IOCTL_NOISE, ("IOCTL: mouse query attributes\n"));

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(MOUSE_ATTRIBUTES)) {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        else {
            //
            // Copy the attributes from the DeviceExtension to the
            // buffer.
            //
            PMOUSE_ATTRIBUTES pMA = (PMOUSE_ATTRIBUTES)
                                              Irp->AssociatedIrp.SystemBuffer;
            pMA->MouseIdentifier      = MOUSE_IDENTIFIER;
            pMA->NumberOfButtons      = MOUSE_NUM_BUTTONS;
            pMA->SampleRate           = MOUSE_SAMPLE_RATE;
            pMA->InputDataQueueLength = MOUSE_INPUT_QLEN;

            Irp->IoStatus.Information = sizeof(MOUSE_ATTRIBUTES);
            status = STATUS_SUCCESS;
        }

        break;

    case IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER:
    case IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER:
        Print(DBG_IOCTL_NOISE, ("IOCTL: mouse send buffer\n"));
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    case IOCTL_INTERNAL_I8042_CONTROLLER_WRITE_BUFFER:
        status = STATUS_NOT_SUPPORTED;
        break;

    default:

        Print(DBG_IOCTL_ERROR, ("IOCTL: INVALID REQUEST\n"));

        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    Irp->IoStatus.Status = status;
    if (status == STATUS_PENDING) {
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject,
                      Irp,
                      (PULONG) NULL,
                      NULL
                      );
    }
    else {
        IoCompleteRequest(Irp,
                          IO_NO_INCREMENT
                          );
    }

    Print(DBG_IOCTL_TRACE, ("IOCTL: exit (0x%x)\n", status));

    return status;
}


VOID
PtStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine starts an I/O operation for the device which is further
    controlled by the controller object

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    None.

--*/
{
    KIRQL                     cancelIrql;
    PIO_STACK_LOCATION        irpSp;

    Print(DBG_IOCTL_TRACE, ("PtStartIo: enter\n"));

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    switch(irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KEYBOARD_SET_INDICATORS:
    case IOCTL_KEYBOARD_SET_TYPEMATIC:
    case IOCTL_KEYBOARD_SET_IME_STATUS:
    case IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER:
    case IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER:
    case IOCTL_INTERNAL_MOUSE_RESET:
    default:

        Print(DBG_IOCTL_ERROR, ("PtStartIo: INVALID REQUEST\n"));

        IoAcquireCancelSpinLock(&cancelIrql);
        IoSetCancelRoutine(Irp, NULL);
        IoReleaseCancelSpinLock(cancelIrql);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceObject, FALSE);
    }

    Print(DBG_IOCTL_TRACE, ("PtStartIo: exit\n"));
}

NTSTATUS
PtEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    NTSTATUS                    status = STATUS_SUCCESS;
    UNICODE_STRING              parametersPath;
    PWSTR                       path;

    UNICODE_STRING              deviceName;
    PDEVICE_OBJECT              newDeviceObject;

    RtlZeroMemory(&Globals,
                  sizeof(GLOBALS)
                  );

    Globals.ControllerData = (PCONTROLLER_DATA) ExAllocatePool(
        NonPagedPool,
        sizeof(CONTROLLER_DATA)
        );

    if (!Globals.ControllerData) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    RtlZeroMemory(Globals.ControllerData,
                  sizeof(CONTROLLER_DATA)
                  );

    Globals.ControllerData->ControllerObject = IoCreateController(0);

    if (!Globals.ControllerData->ControllerObject) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    Globals.RegistryPath.MaximumLength = RegistryPath->Length +
                                          sizeof(UNICODE_NULL);
    Globals.RegistryPath.Length = RegistryPath->Length;
    Globals.RegistryPath.Buffer = ExAllocatePool(
                                       NonPagedPool,
                                       Globals.RegistryPath.MaximumLength
                                       );

    if (!Globals.RegistryPath.Buffer) {

        Print (DBG_SS_ERROR,
               ("Initialize: Couldn't allocate pool for registry path."));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntryError;
    }

    RtlZeroMemory (Globals.RegistryPath.Buffer,
                   Globals.RegistryPath.MaximumLength);

    RtlMoveMemory (Globals.RegistryPath.Buffer,
                   RegistryPath->Buffer,
                   RegistryPath->Length);

#if PTDRV_VERBOSE
    PtServiceParameters(RegistryPath);
#endif

    ExInitializeFastMutex(&Globals.DispatchMutex);
    KeInitializeSpinLock(&Globals.ControllerData->PowerUpSpinLock);

    Print(DBG_SS_TRACE, ("PortDriverEntry (0x%x) \n", status));

    return status;

DriverEntryError:

    //
    // Clean after something has gone wrong
    //
    if (Globals.ControllerData) {
        if (Globals.ControllerData->ControllerObject) {
            IoDeleteController(Globals.ControllerData->ControllerObject);
        }

        ExFreePool(Globals.ControllerData);
    }

    if (Globals.RegistryPath.Buffer) {
        ExFreePool(Globals.RegistryPath.Buffer);
    }

    Print(DBG_SS_ERROR, ("PortDriverEntry (0x%x) \n", status));
    return status;
}

VOID
PtUnload(
   IN PDRIVER_OBJECT Driver
   )
/*++

Routine Description:

   Free all the allocated resources associated with this driver.

Arguments:

   DriverObject - Pointer to the driver object.

Return Value:

   None.

--*/

{
    ULONG i;

    PAGED_CODE();

    ASSERT(NULL == Driver->DeviceObject);

    Print(DBG_SS_TRACE, ("Unload \n"));

    //
    // Free resources in Globals
    //
    ExFreePool(Globals.RegistryPath.Buffer);
    if (Globals.ControllerData->ControllerObject) {
        IoDeleteController(Globals.ControllerData->ControllerObject);
    }
    ExFreePool(Globals.ControllerData);

    return;
}


#if PTDRV_VERBOSE
VOID
PtServiceParameters(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine retrieves this driver's service parameters information
    from the registry.

Arguments:

    RegistryPath - Pointer to the null-terminated Unicode name of the
        registry path for this driver.

Return Value:

    None.  As a side-effect, sets fields in DeviceExtension->Configuration.

--*/

{
    NTSTATUS                            status = STATUS_SUCCESS;
    PI8042_CONFIGURATION_INFORMATION    configuration;
    PRTL_QUERY_REGISTRY_TABLE           parameters = NULL;
    PWSTR                               path = NULL;
    ULONG                               defaultDebugFlags = DEFAULT_DEBUG_FLAGS;
    ULONG                               i = 0;
    UNICODE_STRING                      parametersPath;
    USHORT                              queries = 2;

    configuration = &(Globals.ControllerData->Configuration);
    parametersPath.Buffer = NULL;

    Globals.DebugFlags = DEFAULT_DEBUG_FLAGS;
    //
    // Registry path is already null-terminated, so just use it.
    //
    path = RegistryPath->Buffer;

    if (NT_SUCCESS(status)) {

        //
        // Allocate the Rtl query table.
        //
        parameters = ExAllocatePool(
            PagedPool,
            sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
            );

        if (!parameters) {

            Print(DBG_SS_ERROR,
                 ("%s: couldn't allocate table for Rtl query to %ws for %ws\n",
                 pFncServiceParameters,
                 pwParameters,
                 path
                 ));
            status = STATUS_UNSUCCESSFUL;

        } else {

            RtlZeroMemory(
                parameters,
                sizeof(RTL_QUERY_REGISTRY_TABLE) * (queries + 1)
                );

            //
            // Form a path to this driver's Parameters subkey.
            //
            RtlInitUnicodeString( &parametersPath, NULL );
            parametersPath.MaximumLength = RegistryPath->Length +
                (wcslen(pwParameters) * sizeof(WCHAR) ) + sizeof(UNICODE_NULL);

            parametersPath.Buffer = ExAllocatePool(
                PagedPool,
                parametersPath.MaximumLength
                );

            if (!parametersPath.Buffer) {

                Print(DBG_SS_ERROR,
                     ("%s: Couldn't allocate string for path to %ws for %ws\n",
                     pFncServiceParameters,
                     pwParameters,
                     path
                     ));
                status = STATUS_UNSUCCESSFUL;

            }
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // Form the parameters path.
        //

        RtlZeroMemory(
            parametersPath.Buffer,
            parametersPath.MaximumLength
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            path
            );
        RtlAppendUnicodeToString(
            &parametersPath,
            pwParameters
            );

        Print(DBG_SS_INFO,
             ("%s: %ws path is %ws\n",
             pFncServiceParameters,
             pwParameters,
             parametersPath.Buffer
             ));

        parameters[i].Flags = RTL_QUERY_REGISTRY_DIRECT;
        parameters[i].Name = pwDebugFlags;
        parameters[i].EntryContext = &Globals.DebugFlags;
        parameters[i].DefaultType = REG_DWORD;
        parameters[i].DefaultData = &defaultDebugFlags;
        parameters[i].DefaultLength = sizeof(ULONG);

        status = RtlQueryRegistryValues(
            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
            parametersPath.Buffer,
            parameters,
            NULL,
            NULL
            );

        if (!NT_SUCCESS(status)) {

            Print(DBG_SS_INFO,
                 ("%s: RtlQueryRegistryValues failed with 0x%x\n",
                 pFncServiceParameters,
                 status
                 ));
        }
    }

    Print(DBG_SS_NOISE, ("PtServiceParameters results..\n"));

    Print(DBG_SS_NOISE,
          ("\tDebug flags are 0x%x\n",
          Globals.DebugFlags
          ));

    //
    // Free the allocated memory before returning.
    //

    if (parametersPath.Buffer)
        ExFreePool(parametersPath.Buffer);
    if (parameters)
        ExFreePool(parameters);

}
#endif // PTDRV_VERBOSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ptdrvpnp.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvpnp.c

Abstract:

    This module contains general PnP code for the RDP remote port driver.

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/
#include <precomp.h>
#pragma hdrstop

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtAddDevice)
#pragma alloc_text(PAGE, PtManuallyRemoveDevice)
#pragma alloc_text(PAGE, PtPnP)
//#pragma alloc_text(PAGE, PtPower)
#pragma alloc_text(PAGE, PtSendIrpSynchronously)
#endif

NTSTATUS
PtAddDevice (
    IN PDRIVER_OBJECT   Driver,
    IN PDEVICE_OBJECT   PDO
    )
/*++

Routine Description:

    Adds a device to the stack and sets up the appropriate flags and
    device extension for the newly created device.

Arguments:

    Driver - The driver object
    PDO    - the device that we are attaching ourselves on top of

Return Value:

    NTSTATUS result code.

--*/
{
    PCOMMON_DATA             commonData;
    IO_ERROR_LOG_PACKET      errorLogEntry;
    PDEVICE_OBJECT           device;
    NTSTATUS                 status = STATUS_SUCCESS;
    ULONG                    maxSize;
    UNICODE_STRING           fullRDPName;
    UNICODE_STRING           baseRDPName;
    UNICODE_STRING           deviceNameSuffix;


    PAGED_CODE();

    Print(DBG_PNP_TRACE, ("enter Add Device: %ld \n", Globals.ulDeviceNumber));

    //
    // Initialize the various unicode structures for forming the device name.
    //
    if (Globals.ulDeviceNumber == 0)
        RtlInitUnicodeString(&fullRDPName, RDP_CONSOLE_BASE_NAME0);
    else
        RtlInitUnicodeString(&fullRDPName, RDP_CONSOLE_BASE_NAME1);

    maxSize = sizeof(PORT_KEYBOARD_EXTENSION) > sizeof(PORT_MOUSE_EXTENSION) ?
              sizeof(PORT_KEYBOARD_EXTENSION) :
              sizeof(PORT_MOUSE_EXTENSION);

    status = IoCreateDevice(Driver,                 // driver
                            maxSize,                // size of extension
                            &fullRDPName,           // device name
                            FILE_DEVICE_8042_PORT,  // device type  ?? unknown at this time!!!
                            0,                      // device characteristics
                            FALSE,                  // exclusive
                            &device                 // new device
                            );

    if (!NT_SUCCESS(status)) {
        Print(DBG_SS_TRACE, ("Add Device failed! (0x%x) \n", status));
        return status;
    }

    Globals.ulDeviceNumber++;

    RtlZeroMemory(device->DeviceExtension, maxSize);

    //
    // Set up the device type
    //
    *((ULONG *)(device->DeviceExtension)) = DEV_TYPE_PORT;

    commonData = GET_COMMON_DATA(device->DeviceExtension);
    RtlInitUnicodeString(&commonData->DeviceName, fullRDPName.Buffer);

    commonData->TopOfStack = IoAttachDeviceToDeviceStack(device, PDO);

    ASSERT(commonData->TopOfStack);

    commonData->Self =       device;
    commonData->PDO =        PDO;

    device->Flags |= DO_BUFFERED_IO;
    device->Flags &= ~DO_DEVICE_INITIALIZING;

    Print(DBG_PNP_TRACE, ("Add Device (0x%x)\n", status));

    return status;
}

NTSTATUS
PtSendIrpSynchronously (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Generic routine to send an irp DeviceObject and wait for its return up the
    device stack.

Arguments:

    DeviceObject - The device object to which we want to send the Irp

    Irp - The Irp we want to send

Return Value:

    return code from the Irp
--*/
{
    KEVENT   event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE
                      );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           PtPnPComplete,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );

    status = IoCallDriver(DeviceObject, Irp);

    //
    // Wait for lower drivers to be done with the Irp
    //
    if (status == STATUS_PENDING) {
       KeWaitForSingleObject(&event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL
                             );
       status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PtPnPComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
/*++

Routine Description:

    Completion routine for all PnP IRPs

Arguments:

    DeviceObject - Pointer to the DeviceObject

    Irp - Pointer to the request packet

    Event - The event to set once processing is complete

Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER (DeviceObject);

    status = STATUS_SUCCESS;
    stack = IoGetCurrentIrpStackLocation(Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    KeSetEvent(Event, 0, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PtPnP (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for PnP requests
Arguments:

    DeviceObject - Pointer to the device object

    Irp - Pointer to the request packet


Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PPORT_KEYBOARD_EXTENSION   kbExtension;
    PPORT_MOUSE_EXTENSION      mouseExtension;
    PCOMMON_DATA               commonData;
    PIO_STACK_LOCATION         stack;
    NTSTATUS                   status = STATUS_SUCCESS;
    KIRQL                      oldIrql;

    PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);
    stack = IoGetCurrentIrpStackLocation(Irp);

    Print(DBG_PNP_TRACE,
          ("PtPnP (%s),  enter (min func=0x%x)\n",
          commonData->IsKeyboard ? "kb" : "mou",
          (ULONG) stack->MinorFunction
          ));

    switch (stack->MinorFunction) {
    case IRP_MN_START_DEVICE:

        //
        // The device is starting.
        //
        // We cannot touch the device (send it any non pnp irps) until a
        // start device has been passed down to the lower drivers.
        //
        status = PtSendIrpSynchronously(commonData->TopOfStack, Irp);

        if (NT_SUCCESS(status) && NT_SUCCESS(Irp->IoStatus.Status)) {
            //
            // As we are successfully now back from our start device
            // we can do work.

            ExAcquireFastMutexUnsafe(&Globals.DispatchMutex);

            if (commonData->Started) {
                Print(DBG_PNP_ERROR,
                      ("received 1+ starts on %s\n",
                      commonData->IsKeyboard ? "kb" : "mouse"
                      ));
            }
            else {
                //
                // commonData->IsKeyboard is set during
                //  IOCTL_INTERNAL_KEYBOARD_CONNECT to TRUE and
                //  IOCTL_INTERNAL_MOUSE_CONNECT to FALSE
                //
                if (commonData->IsKeyboard) {
                    status = PtKeyboardStartDevice(
                      (PPORT_KEYBOARD_EXTENSION) DeviceObject->DeviceExtension,
                      stack->Parameters.StartDevice.AllocatedResourcesTranslated
                      );
                }
                else {
                    status = PtMouseStartDevice(
                      (PPORT_MOUSE_EXTENSION) DeviceObject->DeviceExtension,
                      stack->Parameters.StartDevice.AllocatedResourcesTranslated
                      );
                }

                if (NT_SUCCESS(status)) {
                    commonData->Started = TRUE;
                }
            }

            ExReleaseFastMutexUnsafe(&Globals.DispatchMutex);
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_QUERY_PNP_DEVICE_STATE:

        status = PtSendIrpSynchronously(commonData->TopOfStack, Irp);

        //
        // If the lower filter does not support this Irp, this is
        // OK, we can ignore this error
        //
        if (status == STATUS_NOT_SUPPORTED ||
            status == STATUS_INVALID_DEVICE_REQUEST) {
            status = STATUS_SUCCESS;
        }

        //
        // do stuff here...
        //
        if (NT_SUCCESS(status)) {
            if (commonData->ManuallyRemoved &&
                !(commonData->IsKeyboard ? KEYBOARD_PRESENT():MOUSE_PRESENT())) {

                commonData->Started = FALSE;
                (PNP_DEVICE_STATE) Irp->IoStatus.Information |=
                    (PNP_DEVICE_REMOVED | PNP_DEVICE_DONT_DISPLAY_IN_UI);
            }

            //
            // In all cases this device must be disableable
            //
            (PNP_DEVICE_STATE) Irp->IoStatus.Information &= ~PNP_DEVICE_NOT_DISABLEABLE;

            //
            // Don't show it in the device manager
            //
            (PNP_DEVICE_STATE) Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;


        } else {
           Print(DBG_PNP_ERROR,
                 ("error pending query pnp device state event (0x%x)\n",
                 status
                 ));
        }

        //
        // Irp->IoStatus.Information will contain the new i/o resource
        // requirements list so leave it alone
        //
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    //
    // Don't let either of the requests succeed, otherwise the kb/mouse
    // might be rendered useless.
    //
    //  NOTE: this behavior is particular to i8042prt.  Any other driver,
    //        especially any other keyboard or port driver, should
    //        succeed the query remove or stop.  i8042prt has this different
    //        behavior because of the shared I/O ports but independent interrupts.
    //
    //        FURTHERMORE, if you allow the query to succeed, it should be sent
    //        down the stack (see sermouse.sys for an example of how to do this)
    //
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
        status = (commonData->ManuallyRemoved ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    //
    // PnP rules dictate we send the IRP down to the PDO first
    //
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        status = PtSendIrpSynchronously(commonData->TopOfStack, Irp);

        //
        // If the lower filter does not support this Irp, this is
        // OK, we can ignore this error
        //
        if (status == STATUS_NOT_SUPPORTED ||
            status == STATUS_INVALID_DEVICE_REQUEST) {
            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        break;

    case IRP_MN_REMOVE_DEVICE:

        Print(DBG_PNP_TRACE, ("remove device\n"));

        if (commonData->Started && !commonData->ManuallyRemoved) {
            //
            // This should never happen.  The only way we can get a remove is if
            // a start has failed.
            //
            //  NOTE:  Again, this should never happen for i8042prt, but any
            //         other input port driver should allow itself to be removed
            //         (see sermouse.sys on how to do this correctly)
            //
            Print(DBG_PNP_ERROR, ("Cannot remove a started device!!!\n"));
            ASSERT(FALSE);
        }

        if (commonData->Initialized) {
            IoWMIRegistrationControl(commonData->Self,
                                     WMIREG_ACTION_DEREGISTER
                                     );
        }

        ExAcquireFastMutexUnsafe(&Globals.DispatchMutex);
        if (commonData->IsKeyboard) {
            PtKeyboardRemoveDevice(DeviceObject);
        }
        ExReleaseFastMutexUnsafe(&Globals.DispatchMutex);

        //
        // Nothing has been allocated or connected
        //
        IoSkipCurrentIrpStackLocation(Irp);

        IoCallDriver(commonData->TopOfStack, Irp);

        IoDetachDevice(commonData->TopOfStack);
        IoDeleteDevice(DeviceObject);

        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
    case IRP_MN_QUERY_DEVICE_RELATIONS:
    case IRP_MN_QUERY_INTERFACE:
    case IRP_MN_QUERY_CAPABILITIES:
    case IRP_MN_QUERY_DEVICE_TEXT:
    case IRP_MN_QUERY_RESOURCES:
    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG:
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_ID:
    default:
        //
        // Here the driver below i8042prt might modify the behavior of these IRPS
        // Please see PlugPlay documentation for use of these IRPs.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);

        break;
    }

    Print(DBG_PNP_TRACE,
          ("PtPnP (%s) exit (status=0x%x)\n",
          commonData->IsKeyboard ? "kb" : "mou",
          status
          ));

    return status;
}

LONG
PtManuallyRemoveDevice(
    PCOMMON_DATA CommonData
    )
/*++

Routine Description:

    Invalidates CommonData->PDO's device state and sets the manually removed
    flag

Arguments:

    CommonData - represent either the keyboard or mouse

Return Value:

    new device count for that particular type of device

--*/
{
    LONG deviceCount;

    PAGED_CODE();

    if (CommonData->IsKeyboard) {

        deviceCount = InterlockedDecrement(&Globals.AddedKeyboards);
        if (deviceCount < 1) {
            Print(DBG_PNP_INFO, ("clear kb (manually remove)\n"));
            CLEAR_KEYBOARD_PRESENT();
        }

    } else {

        deviceCount = InterlockedDecrement(&Globals.AddedMice);
        if (deviceCount < 1) {
            Print(DBG_PNP_INFO, ("clear mou (manually remove)\n"));
            CLEAR_MOUSE_PRESENT();
        }

    }

    CommonData->ManuallyRemoved = TRUE;
    IoInvalidateDeviceState(CommonData->PDO);

    return deviceCount;
}


NTSTATUS
PtPower (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to the device object.

    Irp - Pointer to the request packet.

Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    PCOMMON_DATA        commonData;
    PIO_STACK_LOCATION  stack;
    NTSTATUS            status = STATUS_SUCCESS;

    //PAGED_CODE();

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    stack = IoGetCurrentIrpStackLocation(Irp);

    Print(DBG_POWER_TRACE,
          ("Power (%s), enter\n",
          commonData->IsKeyboard ? "keyboard" :
                                   "mouse"
          ));

    switch(stack->MinorFunction) {
    case IRP_MN_WAIT_WAKE:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_WAIT_WAKE\n" ));
        break;

    case IRP_MN_POWER_SEQUENCE:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_POWER_SEQUENCE\n" ));
        break;

    case IRP_MN_SET_POWER:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_SET_POWER\n" ));

        //
        // Don't handle anything but DevicePowerState changes
        //
        if (stack->Parameters.Power.Type != DevicePowerState) {
            Print(DBG_POWER_TRACE, ("not a device power irp\n"));
            break;
        }

        //
        // Check for no change in state, and if none, do nothing
        //
        if (stack->Parameters.Power.State.DeviceState ==
            commonData->PowerState) {
            Print(DBG_POWER_INFO,
                  ("no change in state (PowerDeviceD%d)\n",
                  commonData->PowerState-1
                  ));
            break;
        }

        switch (stack->Parameters.Power.State.DeviceState) {
        case PowerDeviceD0:
            Print(DBG_POWER_TRACE, ("Powering up to PowerDeviceD0\n"));

            commonData->IsKeyboard ? KEYBOARD_POWERED_UP_STARTED()
                                   : MOUSE_POWERED_UP_STARTED();

            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   PtPowerUpToD0Complete,
                                   NULL,
                                   TRUE,                // on success
                                   TRUE,                // on error
                                   TRUE                 // on cancel
                                   );

            //
            // PoStartNextPowerIrp() gets called when the irp gets completed
            //
            IoMarkIrpPending(Irp);
            PoCallDriver(commonData->TopOfStack, Irp);

            return STATUS_PENDING;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            Print(DBG_POWER_TRACE,
                  ("Powering down to PowerDeviceD%d\n",
                  stack->Parameters.Power.State.DeviceState-1
                  ));

            PoSetPowerState(DeviceObject,
                            stack->Parameters.Power.Type,
                            stack->Parameters.Power.State
                            );

            commonData->PowerState = stack->Parameters.Power.State.DeviceState;
            commonData->ShutdownType = stack->Parameters.Power.ShutdownType;

            //
            // For what we are doing, we don't need a completion routine
            // since we don't race on the power requests.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCopyCurrentIrpStackLocationToNext(Irp);  // skip ?

            PoStartNextPowerIrp(Irp);
            return  PoCallDriver(commonData->TopOfStack, Irp);

        default:
            Print(DBG_POWER_INFO, ("unknown state\n"));
            break;
        }
        break;

    case IRP_MN_QUERY_POWER:
        Print(DBG_POWER_NOISE, ("Got IRP_MN_QUERY_POWER\n" ));
        break;

    default:
        Print(DBG_POWER_NOISE,
              ("Got unhandled minor function (%d)\n",
              stack->MinorFunction
              ));
        break;
    }

    Print(DBG_POWER_TRACE, ("Power, exit\n"));

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(commonData->TopOfStack, Irp);
}

NTSTATUS
PtPowerUpToD0Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Reinitializes the i8042 haardware after any type of hibernation/sleep.

Arguments:

    DeviceObject - Pointer to the device object

    Irp - Pointer to the request

    Context - Context passed in from the funciton that set the completion
              routine. UNUSED.


Return Value:

    STATUS_SUCCESSFUL if successful,
    an valid NTSTATUS error code otherwise

--*/
{
    NTSTATUS            status;
    PCOMMON_DATA        commonData;
    PIO_STACK_LOCATION  stack;
    KIRQL               irql;

    UNREFERENCED_PARAMETER(Context);

    commonData = GET_COMMON_DATA(DeviceObject->DeviceExtension);

    Print(DBG_POWER_TRACE,
          ("PowerUpToD0Complete (%s), Enter\n",
          commonData->IsKeyboard ? "kb" : "mouse"
          ));

    KeAcquireSpinLock(&Globals.ControllerData->PowerUpSpinLock, &irql);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        commonData->IsKeyboard ? KEYBOARD_POWERED_UP_SUCCESSFULLY()
                               : MOUSE_POWERED_UP_SUCCESSFULLY();

        status = STATUS_MORE_PROCESSING_REQUIRED;

    }
    else {
        commonData->IsKeyboard ? KEYBOARD_POWERED_UP_FAILED()
                               : MOUSE_POWERED_UP_FAILED();

        status = Irp->IoStatus.Status;

#if DBG
        if (commonData->IsKeyboard) {
            ASSERT(MOUSE_POWERED_UP_FAILED());
        }
        else {
            ASSERT(KEYBOARD_POWERED_UP_FAILED());
        }
#endif // DBG
    }

    KeReleaseSpinLock(&Globals.ControllerData->PowerUpSpinLock, irql);


    if (NT_SUCCESS(status)) {

        Print(DBG_SS_NOISE, ("reinit, status == 0x%x\n", status));

        stack = IoGetCurrentIrpStackLocation(Irp);

        ASSERT(stack->Parameters.Power.State.DeviceState == PowerDeviceD0);
        commonData->PowerState = stack->Parameters.Power.State.DeviceState;
        commonData->ShutdownType = PowerActionNone;

        PoSetPowerState(commonData->Self,
                        stack->Parameters.Power.Type,
                        stack->Parameters.Power.State
                        );
    }

    //
    // Complete the irp
    //
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Reset PoweredDevices so that we can keep track of the powered device
    //  the next time the machine is power managed off.
    //
    CLEAR_POWERUP_FLAGS();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\ptdrvstr.h ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    ptdrvstr.h

Abstract:

    These are the string constants used in the RDP Remote Port driver.
    Using pointers to these string allows for better memory
    utilization and more readable code

Environment:

    Kernel mode.

Revision History:

    02/12/99 - Initial Revision based on pnpi8042 driver

--*/

#ifndef _PTDRVSTR_H_
#define _PTDRVSTR_H_

//
// Nmes used in debug print statements
//
#define PTDRV_DRIVER_NAME_A                          "RemotePrt: "
#define PTDRV_FNC_SERVICE_PARAMETERS_A               "PtServiceParameters"

//
// Some strings used frequently by the driver
//
#define PTDRV_DEBUGFLAGS_W                          L"DebugFlags"
#define PTDRV_PARAMETERS_W                          L"\\Parameters"

//
// Make these variables globally visible
//
extern  const   PSTR    pDriverName;
extern  const   PSTR    pFncServiceParameters;

extern  const   PWSTR   pwDebugFlags;
extern  const   PWSTR   pwParameters;

#endif // _PTDRVSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\stack.c ===
/****************************************************************************/
// stack.c
//
// Routines for managing Terminal Server driver stacks.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <precomp.h>
#pragma hdrstop
#include <ntimage.h>

#include <minmax.h>
#include <regapi.h>

/*
 * Prototypes for procedures
 */

NTSTATUS
IcaDeviceControlStack (
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCleanupStack (
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaCloseStack (
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


/*
 * Local procedure prototypes
 */
NTSTATUS
_LogError(
    IN PDEVICE_OBJECT pDeviceObject,
    IN NTSTATUS Status,
    IN LPWSTR * pArgStrings,
    IN ULONG ArgStringCount,
    IN PVOID pRawData,
    IN ULONG RawDataLength
    );

NTSTATUS
_IcaDriverThread(
    IN PVOID pData
    );

PICA_STACK
_IcaAllocateStack(
    VOID
    );

VOID
_IcaFreeStack(
    PICA_STACK pStack
    );

NTSTATUS
_IcaPushStack(
    IN PICA_STACK pStack,
    IN PICA_STACK_PUSH pStackPush
    );

NTSTATUS
_IcaPopStack(
    IN PICA_STACK pStack
    );

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaCallStackNoLock(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
_IcaLoadSd(
    IN PDLLNAME SdName,
    OUT PSDLINK *ppSdLink
    );

NTSTATUS
_IcaUnloadSd(
    IN PSDLINK pSdLink
    );

NTSTATUS
_IcaCallSd(
    IN PSDLINK pSdLink,
    IN ULONG ProcIndex,
    IN PVOID pParms
    );

VOID
_IcaReferenceSdLoad(
    IN PSDLOAD pSdLoad
    );

VOID
_IcaDereferenceSdLoad(
    IN PSDLOAD pSdLoad
    );

NTSTATUS
_IcaLoadSdWorker(
    IN PDLLNAME SdName,
    OUT PSDLOAD *ppSdLoad
    );

NTSTATUS
_IcaUnloadSdWorker(
    IN PSDLOAD pSdLoad
    );

NTSTATUS
IcaExceptionFilter(
    IN PWSTR OutputString,
    IN PEXCEPTION_POINTERS pexi
    );

NTSTATUS
_RegisterBrokenEvent(
    IN PICA_STACK pStack,
    IN PICA_STACK_BROKEN pStackBroken
    );

NTSTATUS
_EnablePassthru( PICA_STACK pStack );

NTSTATUS
_DisablePassthru( PICA_STACK pStack );

NTSTATUS
_ReconnectStack( PICA_STACK pStack, HANDLE hIca );



NTSTATUS
IcaBindVirtualChannels(
    IN PICA_STACK pStack
    );

VOID
IcaRebindVirtualChannels(
    IN PICA_CONNECTION pConnect
    );

VOID
IcaUnbindVirtualChannels(
    IN PICA_CONNECTION pConnect
    );

VOID
IcaFreeAllVcBind(
    IN PICA_CONNECTION pConnect
    );

/*
 * Buffer Allocation counters.
 */

ULONG gAllocSucceed;
ULONG gAllocFailed;
ULONG gAllocFreed;

extern HANDLE   g_TermServProcessID;
ULONG   g_KeepAliveInterval=0;
/*
 * Dispatch table for stack objects
 */
PICA_DISPATCH IcaStackDispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1] = {
    NULL,                       // IRP_MJ_CREATE
    NULL,                       // IRP_MJ_CREATE_NAMED_PIPE
    IcaCloseStack,              // IRP_MJ_CLOSE
    NULL,                       // IRP_MJ_READ
    NULL,                       // IRP_MJ_WRITE
    NULL,                       // IRP_MJ_QUERY_INFORMATION
    NULL,                       // IRP_MJ_SET_INFORMATION
    NULL,                       // IRP_MJ_QUERY_EA
    NULL,                       // IRP_MJ_SET_EA
    NULL,                       // IRP_MJ_FLUSH_BUFFERS
    NULL,                       // IRP_MJ_QUERY_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_SET_VOLUME_INFORMATION
    NULL,                       // IRP_MJ_DIRECTORY_CONTROL
    NULL,                       // IRP_MJ_FILE_SYSTEM_CONTROL
    IcaDeviceControlStack,      // IRP_MJ_DEVICE_CONTROL
    NULL,                       // IRP_MJ_INTERNAL_DEVICE_CONTROL
    NULL,                       // IRP_MJ_SHUTDOWN
    NULL,                       // IRP_MJ_LOCK_CONTROL
    IcaCleanupStack,            // IRP_MJ_CLEANUP
    NULL,                       // IRP_MJ_CREATE_MAILSLOT
    NULL,                       // IRP_MJ_QUERY_SECURITY
    NULL,                       // IRP_MJ_SET_SECURITY
    NULL,                       // IRP_MJ_SET_POWER
    NULL,                       // IRP_MJ_QUERY_POWER
};


NTSTATUS
IcaCreateStack (
    IN PICA_CONNECTION pConnect,
    IN PICA_OPEN_PACKET openPacket,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine is called to create a new ICA_STACK objecte.

Arguments:

    pConnect -- pointer to ICA_CONNECTION object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PLIST_ENTRY Head, Next;
    PICA_STACK pStack;
    KIRQL OldIrql;
    LONG PrimaryCount, ShadowCount, PassthruCount, ConsoleCount;
    NTSTATUS Status;

    /*
     * Allocate a new ICA stack object
     */
    pStack = _IcaAllocateStack();
    if ( pStack == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );

    /*
     * Finish initializing the stack object
     * (non-primary stacks are initialized with the fIoDisabled
     *  flag set to TRUE, i.e. they must be manually enabled)
     */
    pStack->StackClass = openPacket->TypeInfo.StackClass;
    pStack->fIoDisabled = ((pStack->StackClass != Stack_Primary) &&
                           (pStack->StackClass != Stack_Console));

    /*
     * Lock connection object while creating new stack
     */
    IcaLockConnection( pConnect );

    /*
     * Reference the connection object this stack belongs to.
     */
    IcaReferenceConnection( pConnect );
    pStack->pConnect = (PUCHAR)pConnect;

    /*
     * Search the existing stacks to check for invalid combinations.
     * 1) there can be only 1 primary stack per connection,
     * 2) there can be multiple shadow stacks per connection,
     *    but ONLY if there is no passthru stack,
     * 3) there can be only 1 passthru stack per connection,
     *    but only if there is an existing primary stack AND no shadow stacks.
     * 4) there can be only 1 console stack
     */
    Head = &pConnect->StackHead;
    PrimaryCount = ShadowCount = PassthruCount = ConsoleCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        PICA_STACK pCurrentStack;

        pCurrentStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

        switch ( pCurrentStack->StackClass ) {
            case Stack_Primary :
                PrimaryCount++;
                break;

            case Stack_Shadow :
                ShadowCount++;
                break;

            case Stack_Passthru :
                PassthruCount++;
                break;

            case Stack_Console :
                ConsoleCount++;
                break;
        }
    }

    Status = STATUS_SUCCESS;
    switch ( pStack->StackClass ) {
        case Stack_Primary :
            if ( PrimaryCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            break;

        case Stack_Shadow :
            if ( PassthruCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            break;

        case Stack_Passthru :
            if ( PrimaryCount != 1 || ShadowCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            break;

        case Stack_Console :
            if ( ConsoleCount != 0 )
                Status = STATUS_INVALID_PARAMETER;
            break;
    }

    if ( Status != STATUS_SUCCESS ) {
        IcaUnlockConnection( pConnect );
        pStack->RefCount = 0;
        _IcaFreeStack( pStack );
        TRACE(( pConnect, TC_ICADD, TT_ERROR, "TermDD: IcaCreateStack failed, 0x%x\n", Status ));
        return( Status );
    }

    /*
     * Link this stack into the connection object stack list.
     */
    if (( pStack->StackClass == Stack_Primary ) ||
        ( pStack->StackClass == Stack_Console )) {
        InsertHeadList( &pConnect->StackHead, &pStack->StackEntry );
    } else {
        InsertTailList( &pConnect->StackHead, &pStack->StackEntry );
    }

    /*
     * Unlock connection object now
     */
    IcaUnlockConnection( pConnect );

    /*
     * Initialize the LastKeepAliveTime field to current system time
     */
    KeQuerySystemTime(&pStack->LastKeepAliveTime);

    /*
     * Lock the stack list for updating
     */
    IcaAcquireSpinLock(&IcaStackListSpinLock, &OldIrql);

    /*
     * Insert the stack to the stack list, increment total number of stacks
     */
    InsertTailList(IcaNextStack, &pStack->StackNode);
    IcaTotalNumOfStacks++;

    /*
     * Unlock the stack list now
     */
    IcaReleaseSpinLock(&IcaStackListSpinLock, OldIrql);

    /*
     * Save a pointer to the stack in the file object
     * so that we can find it in future calls.
     */
    IrpSp->FileObject->FsContext = pStack;

    IcaDereferenceStack( pStack );

    TRACE(( pConnect, TC_ICADD, TT_API1, "TermDD: IcaCreateStack, success\n" ));
    return( STATUS_SUCCESS );
}


NTSTATUS
IcaDeviceControlStack(
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PICA_CONNECTION pConnect;
    PICA_TRACE_BUFFER pTraceBuffer;
    PICA_STACK_RECONNECT pStackReconnect;
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    ULONG code;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    BYTE *Buffer = NULL;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

#if DBG
    if ( code != IOCTL_ICA_STACK_TRACE ) {
        IcaLockStack( pStack );
        TRACESTACK(( pStack, TC_ICADD, TT_API2, "TermDD: IcaDeviceControlStack, fc %d (enter)\n",
                     (code & 0x3fff) >> 2 ));
        IcaUnlockStack( pStack );
    }
#endif

    try {
        switch ( code ) {

            case IOCTL_ICA_STACK_PUSH :
            {
                ICA_STACK_PUSH StackPush;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_PUSH) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_PUSH),
                                  sizeof(BYTE) );
                }

                // This IOCTL should only be invoked if we are called from system process
                // If not, we deny the request
                if (!((BOOLEAN)IrpSp->FileObject->FsContext2)) {
                    return (STATUS_ACCESS_DENIED);
                }

                memcpy(&StackPush, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                       sizeof(ICA_STACK_PUSH));

                Status = _IcaPushStack( pStack, &StackPush );
                break;
            }
            case IOCTL_ICA_STACK_POP :
                IcaLockConnectionForStack( pStack );
                Status = _IcaPopStack( pStack );
                IcaUnlockConnectionForStack( pStack );
                break;

            case IOCTL_ICA_STACK_QUERY_STATUS :
                if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(pStack->ProtocolStatus) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   sizeof(pStack->ProtocolStatus),
                                   sizeof(BYTE) );
                }

                RtlCopyMemory( Irp->UserBuffer,
                               &pStack->ProtocolStatus,
                               sizeof(pStack->ProtocolStatus) );
                Irp->IoStatus.Information = sizeof(pStack->ProtocolStatus);
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_STACK_QUERY_CLIENT :
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;
                break;

            case IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED :
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;
                break;

            case IOCTL_ICA_STACK_QUERY_AUTORECONNECT :
                if ( Irp->RequestorMode != KernelMode ) {

                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );

                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }
    
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;
                break;

            case IOCTL_ICA_STACK_QUERY_MODULE_DATA :
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }
                
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Buffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                /* this is so IoStatus.Information gets returned to the caller */
                if (Status == STATUS_BUFFER_TOO_SMALL)
                    Status = STATUS_BUFFER_OVERFLOW;
                
                break;

            case IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME :
                if ( IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ICA_STACK_LAST_INPUT_TIME) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForWrite( Irp->UserBuffer,
                                   sizeof(ICA_STACK_LAST_INPUT_TIME),
                                   sizeof(BYTE) );
                }

                ((PICA_STACK_LAST_INPUT_TIME)Irp->UserBuffer)->LastInputTime = pStack->LastInputTime;
                Irp->IoStatus.Information = sizeof(ICA_STACK_LAST_INPUT_TIME);
                Status = STATUS_SUCCESS;
                break;

            case IOCTL_ICA_STACK_TRACE :
            {
           
                unsigned DataLen = 0;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < (ULONG)FIELD_OFFSET(ICA_TRACE_BUFFER,Data[0]) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength > sizeof(ICA_TRACE_BUFFER) )
                    return( STATUS_INVALID_BUFFER_SIZE );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                pTraceBuffer = (PICA_TRACE_BUFFER)Buffer;

                // Make sure the trace buffer is NULL terminated
                DataLen = IrpSp->Parameters.DeviceIoControl.InputBufferLength -
                        FIELD_OFFSET(ICA_TRACE_BUFFER, Data);
                if (pTraceBuffer->Data[DataLen - 1] == 0) {
                    pConnect = IcaLockConnectionForStack( pStack );
                    IcaTraceFormat( &pConnect->TraceInfo,
                                    pTraceBuffer->TraceClass,
                                    pTraceBuffer->TraceEnable,
                                    pTraceBuffer->Data );
                    IcaUnlockConnectionForStack( pStack );
                    Status = STATUS_SUCCESS;
                }
                else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }

                break;
            }

            case IOCTL_ICA_STACK_REGISTER_BROKEN :
            {
                ICA_STACK_BROKEN BrokenEvent;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_BROKEN) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_BROKEN),
                                  sizeof(BYTE) );
                }

                memcpy(&BrokenEvent, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                       sizeof(ICA_STACK_BROKEN));

                Status = _RegisterBrokenEvent( pStack,
                                               &BrokenEvent );
                break;
            }

            case IOCTL_ICA_STACK_ENABLE_IO :
                pStack->fIoDisabled = FALSE;
                /* If enabling the passthru stack, then enable passthru mode */
                if ( pStack->StackClass == Stack_Passthru ) {
                    Status = _EnablePassthru( pStack );
                } else {
                    Status = STATUS_SUCCESS;
                }
                break;

            case IOCTL_ICA_STACK_DISABLE_IO :
                pStack->fIoDisabled = TRUE;
                /* If disabling the passthru stack, then disable passthru mode */
                if ( pStack->StackClass == Stack_Passthru ) {

                    Status = _DisablePassthru( pStack );

                    IcaLockStack( pStack );
                    // Now wait for any input still in progress to end.
                    if ( pStack->fDoingInput ) {
                        NTSTATUS WaitStatus;

                        pStack->fDisablingIo = TRUE;
                        KeClearEvent( &pStack->IoEndEvent );
                        IcaUnlockStack( pStack );

                        //
                        // Convert the timeout to a relative system time value and wait.
                        //
                        WaitTimeout = RtlEnlargedIntegerMultiply( 60000, -10000 );
                        pWaitTimeout = &WaitTimeout;

                        WaitStatus = KeWaitForSingleObject( &pStack->IoEndEvent,
                                        UserRequest, UserMode, FALSE, pWaitTimeout );

#if DBG
                        if ( WaitStatus != STATUS_SUCCESS ) {
                            DbgPrint("TermDD: IOCTL_ICA_STACK_DISABLE_IO: WaitStatus=%x\n", WaitStatus);
                            ASSERT(WaitStatus == STATUS_SUCCESS);
                        }
#endif

                        IcaLockStack( pStack );

                        pStack->fDisablingIo = FALSE;
                    }
                    IcaUnlockStack( pStack );

                } else {
                    Status = STATUS_SUCCESS;
                }
                break;

            case IOCTL_ICA_STACK_DISCONNECT :
            {
                HANDLE hIca;

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_RECONNECT) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_RECONNECT),
                                  sizeof(BYTE) );
                }
                pStackReconnect = (PICA_STACK_RECONNECT)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                hIca = pStackReconnect->hIca;

                /*
                 * Notify stack drivers of disconnect
                 */
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = NULL;
                SdIoctl.OutputBufferLength = 0;
                (void)_IcaCallStack( pStack, SD$IOCTL, &SdIoctl );

                /*
                 * Disconnect stack
                 */
                Status = _ReconnectStack( pStack, hIca );
                break;
            }

            case IOCTL_ICA_STACK_RECONNECT :
            {
                ICA_STACK_RECONNECT StackReconnect;
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ICA_STACK_RECONNECT) )
                    return( STATUS_BUFFER_TOO_SMALL );
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  sizeof(ICA_STACK_RECONNECT),
                                  sizeof(BYTE) );
                }

                /*
                 * Reconnect stack
                 */
                memcpy(&StackReconnect, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                       sizeof(ICA_STACK_RECONNECT));

                Status = _ReconnectStack( pStack, StackReconnect.hIca );

                /*
                 * Notify stack drivers of reconnect
                 */
                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = &StackReconnect;
                SdIoctl.InputBufferLength = sizeof(ICA_STACK_RECONNECT);
                SdIoctl.OutputBuffer = NULL;
                SdIoctl.OutputBufferLength = 0;
                (void)_IcaCallStack( pStack, SD$IOCTL, &SdIoctl );

                break;
            }

            case IOCTL_ICA_STACK_WAIT_FOR_ICA:
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Buffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                if ( NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: IcaDeviceControlStack: Binding vchannels\n"));
                    Status = IcaBindVirtualChannels( pStack );
                }

                break;

            case IOCTL_ICA_STACK_CONSOLE_CONNECT:
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
                    Buffer = ICA_ALLOCATE_POOL( NonPagedPool, 
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);
                    if (Buffer) {
                        memcpy(Buffer, IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength);                    
                    }
                    else {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = Buffer;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: IcaDeviceControlStack: console connect\n"));
                if ( NT_SUCCESS(Status) ) {
                    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: IcaDeviceControlStack: Binding vchannels\n"));
                    Status = IcaBindVirtualChannels( pStack );
                }

                break;

            case IOCTL_ICA_STACK_CANCEL_IO :
                pStack->fClosing = TRUE;
                /* fall through */


            default:
                if ( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead( IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                  IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                  sizeof(BYTE) );
                    ProbeForWrite( Irp->UserBuffer,
                                   IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                   sizeof(BYTE) );
                }

                SdIoctl.IoControlCode = code;
                SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                SdIoctl.OutputBuffer = Irp->UserBuffer;
                SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                Irp->IoStatus.Information = SdIoctl.BytesReturned;

                /* initialize virtual channel name bindings */
                if ( NT_SUCCESS(Status) && (code == IOCTL_ICA_STACK_CONNECTION_QUERY) ) {
                    Status = IcaBindVirtualChannels( pStack );
                    if ( Status == STATUS_SUCCESS ) {

                        ICA_STACK_QUERY_BUFFER icaSQB;
                        NTSTATUS QueryStatus;

                        SdIoctl.IoControlCode =  IOCTL_ICA_STACK_QUERY_BUFFER;
                        SdIoctl.InputBuffer = NULL;
                        SdIoctl.InputBufferLength = 0;
                        SdIoctl.OutputBuffer = &icaSQB;
                        SdIoctl.OutputBufferLength = sizeof(icaSQB);
                        QueryStatus = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
                        if ( NT_SUCCESS(QueryStatus) ) {
                            pStack->OutBufCount  = icaSQB.WdBufferCount;
                            pStack->OutBufLength = icaSQB.TdBufferSize;
                        }
                    }
                }

                /* this is so IoStatus.Information gets returned to the caller */
                if ( Status == STATUS_BUFFER_TOO_SMALL )
                    Status = STATUS_BUFFER_OVERFLOW;
                break;
        }
    } except( IcaExceptionFilter( L"IcaDeviceControlStack TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        
        Status = GetExceptionCode();
    }

    if (Buffer) {
        ICA_FREE_POOL(Buffer);
        Buffer = NULL;
    }

#if DBG
    if ( code != IOCTL_ICA_STACK_TRACE ) {
        IcaLockStack( pStack );
        TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: IcaDeviceControlStack, fc %d, 0x%x\n",
                     (code & 0x3fff) >> 2, Status ));
        IcaUnlockStack( pStack );
    }
#endif
    return( Status );
}


NTSTATUS
IcaCleanupStack(
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    return( STATUS_SUCCESS );
}


NTSTATUS
IcaCloseStack(
    IN PICA_STACK pStack,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    SD_IOCTL SdIoctl;
    PICA_CONNECTION pConnect;
    KIRQL OldIrql;

#if DBG
    IcaLockStack( pStack );
    TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: IcaCloseStack (enter)\n" ));
    IcaUnlockStack( pStack );
#endif

    /*
     * If passthru mode is enabled, disable it now.
     */
    if ( pStack->pPassthru ) {
        _DisablePassthru( pStack );
    }

    /*
     *  Send cancel i/o to stack drivers
     */
    SdIoctl.IoControlCode = IOCTL_ICA_STACK_CANCEL_IO;
    (void) _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );

    /*
     * Make sure all Stack Drivers are unloaded.
     */
    pConnect = IcaLockConnectionForStack( pStack );
    while ( _IcaPopStack( pStack ) == STATUS_SUCCESS )
        ;
    IcaUnlockConnection( pConnect );

    /*
     * Dereference the broken event if we have one
     */
    if ( pStack->pBrokenEventObject ) {
        KeSetEvent( pStack->pBrokenEventObject, 0, FALSE );
        ObDereferenceObject( pStack->pBrokenEventObject );
        pStack->pBrokenEventObject = NULL;
    }

    /*
     * If closing the primary stack, unbind the virtual channels.
     * Unlink this stack from the stack list for this connection.
     */
    pConnect = IcaLockConnectionForStack( pStack );
    if ( pStack->StackClass == Stack_Primary || pStack->StackClass == Stack_Console ) {
        IcaUnbindVirtualChannels( pConnect );
        IcaFreeAllVcBind( pConnect );
    }
    RemoveEntryList( &pStack->StackEntry );
    IcaUnlockConnection( pConnect );

    /*
     * Lock the stack list for update
     */
    IcaAcquireSpinLock(&IcaStackListSpinLock, &OldIrql);

    /*
     * Remove the stack from the stack list. Before doing so, check if IcaNextStack
     * is pointing to this stack, if so, move IcaNextStack to the next stack
     * in the list.  Also, decrement total number of stacks
     */
    if (&pStack->StackNode == IcaNextStack) {
        IcaNextStack = pStack->StackNode.Flink;
    }
    RemoveEntryList(&pStack->StackNode);

    if (IcaTotalNumOfStacks != 0) {
        IcaTotalNumOfStacks--;
    }

    /*
     * Unlock the stack list now
     */
    IcaReleaseSpinLock(&IcaStackListSpinLock, OldIrql);

    /*
     * Remove the file object reference for this stack.
     * This will cause the stack to be deleted when all other
     * references are gone.
     */
    IcaDereferenceStack( pStack );

    return( STATUS_SUCCESS );
}


VOID
IcaReferenceStack(
    IN PICA_STACK pStack
    )
{

    ASSERT( pStack->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement( &pStack->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
IcaDereferenceStack(
    IN PICA_STACK pStack
    )
{

    ASSERT( pStack->RefCount > 0 );

    /*
     * Decrement the reference count; if it is 0, free the stack.
     */
    if ( InterlockedDecrement( &pStack->RefCount) == 0 ) {
        _IcaFreeStack( pStack );
    }
}


PICA_CONNECTION
IcaGetConnectionForStack(
    IN PICA_STACK pStack
    )
{

    /*
     * As long as the stack object is locked, it's safe for us
     * to pick up the pConnect pointer and return it.
     * WARNING: Once the caller unlocks the stack object, the pointer
     *          returned below must not be referenced anymore and may
     *          no longer be valid.
     */
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );

    return( (PICA_CONNECTION)pStack->pConnect );
}


PICA_CONNECTION
IcaLockConnectionForStack(
    IN PICA_STACK pStack
    )
{
    PICA_CONNECTION pConnect;

    /*
     * Acquire the Reconnect resource lock so that the pConnect
     * pointer cannot change before we get the connection locked.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite( IcaReconnectResource, TRUE );
    pConnect = (PICA_CONNECTION)pStack->pConnect;
    IcaLockConnection( pConnect );
    ExReleaseResourceLite( IcaReconnectResource );
    KeLeaveCriticalRegion();

    return( pConnect );
}


VOID
IcaUnlockConnectionForStack(
    IN PICA_STACK pStack
    )
{
    PICA_CONNECTION pConnect;

    /*
     * As long as the connection object is locked, it's safe for us
     * to pick up the pConnect pointer from the stack and use it.
     */
    pConnect = (PICA_CONNECTION)pStack->pConnect;

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    IcaUnlockConnection( pConnect );
}


/*******************************************************************************
 *
 *  IcaCallDriver
 *
 *    Call the topmost stack driver
 *
 *    This is the main interface routine that all channels use
 *    to call the stack driver(s).
 *
 * ENTRY:
 *    pChannel (input)
 *       pointer to channel object this call is from
 *    ProcIndex (input)
 *       index of driver proc to call
 *    pParms (input)
 *       pointer to driver parms
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaCallDriver(
    IN PICA_CHANNEL pChannel,
    IN ULONG ProcIndex,
    IN PVOID pParms
    )
{
    PLIST_ENTRY Head, Next;
    PICA_STACK pStack;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API4, "TermDD: IcaCallDriver, ProcIndex=%u (enter)\n", ProcIndex ));

    // Open/Close should never be called from a channel!
    ASSERT( ProcIndex != SD$OPEN && ProcIndex != SD$CLOSE );

    /*
     * Lock the connection object.
     * This will serialize all channel calls for this connection.
     */
    IcaLockConnection( pChannel->pConnect );

    /*
     * Send this call down to the stack(s).
     * If Passthru mode is enabled, then we bit bucket all channel I/O.
     * However if this channel is flagged as shadow persistent, let
     * the data go through.
     */
    if ( !pChannel->pConnect->fPassthruEnabled ||
         (pChannel->Flags & CHANNEL_SHADOW_PERSISTENT) ) {

        Head = &pChannel->pConnect->StackHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pStack = CONTAINING_RECORD( Next, ICA_STACK, StackEntry );

            /*
             * If I/O is disabled for this stack, or if this is a
             * shadow stack and this call is from a channel that does
             * not process shadow I/O, or if it's a PassThru stack
             * and the channel is shadow persistent, then skip this stack.
             */
            if ( !(pStack->fIoDisabled ||
                 pStack->StackClass == Stack_Shadow &&
                 !(pChannel->Flags & CHANNEL_SHADOW_IO) ||
                 (pChannel->pConnect->fPassthruEnabled && 
                  pStack->StackClass == Stack_Passthru)) ) {
                Status = _IcaCallStack( pStack, ProcIndex, pParms );
            }
        }
    }

    /*
     * Unlock the connection object now.
     */
    IcaUnlockConnection( pChannel->pConnect );

    return( Status );
}


NTSTATUS
IcaCallNextDriver(
    IN PSDCONTEXT pContext,
    IN ULONG ProcIndex,
    IN PVOID pParms
    )
{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    NTSTATUS Status;

    ASSERT( ProcIndex != SD$OPEN && ProcIndex != SD$CLOSE );

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API4, "TermDD: IcaCallNextDriver, ProcIndex=%u (enter)\n", ProcIndex ));

    /*
     * Call the next driver if there is one
     */
    if ( (pSdLink = IcaGetNextSdLink( pSdLink )) == NULL )
        return( STATUS_INVALID_PARAMETER );

    ASSERT( pSdLink->pStack == pStack );

    Status = _IcaCallSd( pSdLink, ProcIndex, pParms );

    return( Status );
}


NTSTATUS
IcaRawInput (
    IN PSDCONTEXT pContext,
    IN PINBUF pInBuf OPTIONAL,
    IN PUCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This is the input (stack callup) routine for ICA raw input.

Arguments:

    pContext - Pointer to SDCONTEXT for this Stack Driver

    pInBuf - Pointer to INBUF containing data

    pBuffer - Pointer to input data

        NOTE: Either pInBuf OR pBuffer must be specified, but not both.

    ByteCount - length of data in pBuffer

Return Value:

    NTSTATUS -- Indicates whether the request was handled successfully.

--*/

{
    PSDLINK pSdLink;
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the stack object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    pStack = pSdLink->pStack;   // save stack pointer for use below
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pStack, TC_ICADD, TT_API2, "TermDD: IcaRawInput, bc=%u (enter)\n", ByteCount ));

    /*
     * Only the stack object should be locked during input.
     */
    ASSERT( ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );
    ASSERT( (pConnect = IcaGetConnectionForStack( pStack )) &&
            !ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     * Walk up the SDLINK list looking for a driver which has specified
     * a RawInput callup routine.  If we find one, then call the
     * driver RawInput routine to let it handle the call.
     */
    while ( (pSdLink = IcaGetPreviousSdLink( pSdLink )) != NULL ) {
        ASSERT( pSdLink->pStack == pStack );
        if ( pSdLink->SdContext.pCallup->pSdRawInput ) {
            IcaReferenceSdLink( pSdLink );
            Status = (pSdLink->SdContext.pCallup->pSdRawInput)(
                        pSdLink->SdContext.pContext,
                        pInBuf,
                        pBuffer,
                        ByteCount );
            IcaDereferenceSdLink( pSdLink );
            return( Status );
        }
    }

    return( IcaRawInputInternal( pStack, pInBuf, pBuffer, ByteCount ) );
}


NTSTATUS
IcaRawInputInternal(
    IN PICA_STACK pStack,
    IN PINBUF pInBuf OPTIONAL,
    IN PCHAR pBuffer OPTIONAL,
    IN ULONG ByteCount
    )
{
    SD_RAWWRITE SdRawWrite;
    NTSTATUS Status;

    /*
     * See if passthru mode is enabled.
     * If so, then we simply turn around and write the input data
     * directly to the passthru stack.
     */
    if ( pStack->pPassthru ) {
        PICA_STACK pPassthru;

        if ( pInBuf ) {
            SdRawWrite.pOutBuf = NULL;
            SdRawWrite.pBuffer = pInBuf->pBuffer;
            SdRawWrite.ByteCount = pInBuf->ByteCount;
        } else {
            SdRawWrite.pOutBuf = NULL;
            SdRawWrite.pBuffer = pBuffer;
            SdRawWrite.ByteCount = ByteCount;
        }

        // Grab a copy of pPassthru onto our local stack before we release
        // the local stack lock. This has been a problem (NT bug #328433)
        // where we release the local stack lock and pStack->pPassthru
        // becomes NULL in _DisablePassthru() before we take out the
        // passthrough stack lock inside of _IcaCallStack().
        pPassthru = pStack->pPassthru;

        // Take a reference on the passthrough stack to make sure it does
        // not go away before we get to it in the call below.
        IcaReferenceStack(pPassthru);

        // Unlock our current stack while in call to passthrough stack.
        pStack->fDoingInput = TRUE;
        IcaUnlockStack(pStack);
        Status = _IcaCallStack(pPassthru, SD$RAWWRITE, &SdRawWrite);
        IcaLockStack(pStack);

        if ( pStack->fDisablingIo ) {
            KeSetEvent( &pStack->IoEndEvent, 0, FALSE );
        }

        pStack->fDoingInput = FALSE;

        // Mirror the refrence above.
        IcaDereferenceStack(pPassthru);

    /*
     * Passthru is not enabled.
     * We have no choice but to drop the input data.
     */
    } else {
        Status = STATUS_SUCCESS;
    }

    return( Status );
}


NTSTATUS
IcaSleep(
    IN PSDCONTEXT pContext,
    IN ULONG Duration
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaSleep %d msec (enter)\n", Duration ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Convert the sleep duration to a relative system time value and sleep.
     */
    SleepTime = RtlEnlargedIntegerMultiply( Duration, -10000 );
    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: Sleep, ERROR 0x%x\n", Status ));
    }
#endif

    return( Status );
}


NTSTATUS
IcaWaitForSingleObject(
    IN PSDCONTEXT pContext,
    IN PVOID pObject,
    IN LONG Timeout
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API2, "TermDD: IcaWaitForSingleObject, %d (enter)\n", Timeout ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Convert the timeout to a relative system time value and wait.
     */
    if ( Timeout != -1 ) {
        ASSERT( Timeout >= 0 );
        WaitTimeout = RtlEnlargedIntegerMultiply( Timeout, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    Status = KeWaitForSingleObject( pObject, UserRequest, UserMode, FALSE,
                                    pWaitTimeout );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        if ( Status == STATUS_TIMEOUT ) {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, TIMEOUT\n" ));
        } else {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, ERROR 0x%x\n", Status ));
        }
    }
#endif

    return( Status );
}


/*
 * Same as IcaSleep() except it is assumed that the connection lock is
 * held.  This is used by the VD flow control routines.
 */
NTSTATUS
IcaFlowControlSleep(
    IN PSDCONTEXT pContext,
    IN ULONG Duration
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER SleepTime;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaSleep %d msec (enter)\n", Duration ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Unlock the connection lock
     */
    IcaUnlockConnectionForStack( pSdLink->pStack );

    /*
     * Convert the sleep duration to a relative system time value and sleep.
     */
    SleepTime = RtlEnlargedIntegerMultiply( Duration, -10000 );
    Status = KeDelayExecutionThread( KernelMode, TRUE, &SleepTime );

    /*
     * Relock the connection lock
     */
    IcaLockConnectionForStack( pSdLink->pStack );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: Sleep, ERROR 0x%x\n", Status ));
    }
#endif

    return( Status );
}


/*
 * Same as IcaWaitForSingleObject() except it is assumed that the connection lock is
 * held.  This is used by the VD flow control routines.
 */
NTSTATUS
IcaFlowControlWait(
    IN PSDCONTEXT pContext,
    IN PVOID pObject,
    IN LONG Timeout
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API2, "TermDD: IcaWaitForSingleObject, %d (enter)\n", Timeout ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Unlock the connection lock
     */
    IcaUnlockConnectionForStack( pSdLink->pStack );

    /*
     * Convert the timeout to a relative system time value and wait.
     */
    if ( Timeout != -1 ) {
        ASSERT( Timeout >= 0 );
        WaitTimeout = RtlEnlargedIntegerMultiply( Timeout, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    Status = KeWaitForSingleObject( pObject, UserRequest, KernelMode, TRUE,
                                    pWaitTimeout );

    /*
     * Relock the connection lock
     */
    IcaLockConnectionForStack( pSdLink->pStack );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        if ( Status == STATUS_TIMEOUT ) {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, TIMEOUT\n" ));
        } else {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForSingleObject, ERROR 0x%x\n", Status ));
        }
    }
#endif

    return( Status );
}


NTSTATUS
IcaWaitForMultipleObjects(
    IN PSDCONTEXT pContext,
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN LONG Timeout
    )
{
    PSDLINK pSdLink;
    BOOLEAN LockStack = FALSE;
    LARGE_INTEGER WaitTimeout;
    PLARGE_INTEGER pWaitTimeout = NULL;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForMultipleObjects, %d (enter)\n", Timeout ));

    /*
     * Release stack lock if held
     */
    if ( ExIsResourceAcquiredExclusiveLite( &pSdLink->pStack->Resource ) ) {
        LockStack = TRUE;
        IcaUnlockStack( pSdLink->pStack );
    }

    /*
     * Convert the timeout to a relative system time value and wait.
     */
    if ( Timeout != -1 ) {
        ASSERT( Timeout >= 0 );
        WaitTimeout = RtlEnlargedIntegerMultiply( Timeout, -10000 );
        pWaitTimeout = &WaitTimeout;
    }

    Status = KeWaitForMultipleObjects( Count, Object, WaitType, UserRequest,
                                       KernelMode, TRUE, pWaitTimeout, NULL );

    /*
     * Reacquire stack lock if held on entry
     */
    if ( LockStack ) {
        IcaLockStack( pSdLink->pStack );
    }

    /*
     * If stack is being closed and we are returning success,
     * then change return value to indicate stack is being closed.
     */
    if ( pSdLink->pStack->fClosing && Status == STATUS_SUCCESS )
        Status = STATUS_CTX_CLOSE_PENDING;

#if DBG
    if ( Status != STATUS_SUCCESS ) {
        if ( Status == STATUS_TIMEOUT ) {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForMultipleObjects, TIMEOUT\n" ));
        } else {
            TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaWaitForMultipleObjects, ERROR 0x%x\n", Status ));
        }
    }
#endif

    return( Status );
}


NTSTATUS
IcaLogError(
    IN PSDCONTEXT pContext,
    IN NTSTATUS Status,
    IN LPWSTR * pArgStrings,
    IN ULONG ArgStringCount,
    IN PVOID pRawData,
    IN ULONG RawDataLength
    )
{
    return( _LogError( IcaDeviceObject, Status, pArgStrings, ArgStringCount, pRawData, RawDataLength ) );
}

NTSTATUS
_LogError(
    IN PDEVICE_OBJECT pDeviceObject,
    IN NTSTATUS Status,
    IN LPWSTR * pArgStrings,
    IN ULONG ArgStringCount,
    IN PVOID pRawData,
    IN ULONG RawDataLength
    )
{
    LPWSTR *TmpPtr;
    PUCHAR ptrToString;
    ULONG Tmp, StringSize, TotalStringSize;
    PIO_ERROR_LOG_PACKET errorLogEntry;

    // Get the bytes needed for strings storage
    Tmp = ArgStringCount;
    TmpPtr = pArgStrings;
    TotalStringSize = 0;

    while( Tmp ) {

        TotalStringSize += ((wcslen(*TmpPtr)+1)*sizeof(WCHAR));
        Tmp--;
        TmpPtr++;
    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        pDeviceObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                RawDataLength +
                                TotalStringSize)
                        );

    if ( errorLogEntry != NULL ) {

        errorLogEntry->ErrorCode = Status;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = Status;
        errorLogEntry->DumpDataSize = (USHORT)RawDataLength;

        // Copy raw data
        if (RawDataLength) {

            RtlCopyMemory(
                &errorLogEntry->DumpData[0],
                pRawData,
                RawDataLength
                );

            ptrToString =
                ((PUCHAR)&errorLogEntry->DumpData[0])+RawDataLength;

        } else {
            ptrToString = (PUCHAR)&errorLogEntry->DumpData[0];
        }

        // round up to next word boundary
        // it's ok to add 1 byte because we allocated more bytes than we needed:
        // the number of extra bytes is the size of DumpData which is ULONG.
        ptrToString = (PUCHAR)((ULONG_PTR)(ptrToString + sizeof(WCHAR) - 1) & ~(ULONG_PTR)(sizeof(WCHAR) - 1));

        // Copy strings following raw data
        errorLogEntry->NumberOfStrings = (USHORT)ArgStringCount;

        if( ArgStringCount ) {
            errorLogEntry->StringOffset = (USHORT)(ptrToString -
                                                (PUCHAR)errorLogEntry);
        }
        else {
            errorLogEntry->StringOffset = 0;
        }

        while( ArgStringCount ) {

            StringSize = (wcslen(*pArgStrings)+1)*sizeof(WCHAR);

            RtlCopyMemory(
                ptrToString,
                *pArgStrings,
                StringSize
            );

            ptrToString += StringSize;
            ArgStringCount--;
            pArgStrings++;

        }

        IoWriteErrorLogEntry(errorLogEntry);
        return STATUS_SUCCESS;
    }
    else {
        return STATUS_NO_MEMORY;
    }
}

#define KEEP_ALIVE_MIN_INTERVAL  50000000     // 5 sec in terms of 100 nanosecs

VOID
IcaCheckStackAlive( )
{
    NTSTATUS status;
    KIRQL OldIrql;
    PICA_STACK pStack;
    SD_IOCTL SdIoctl;
    LARGE_INTEGER SleepTime;
    LARGE_INTEGER CurrentTime;
    LONGLONG    KeepAliveInterval;

    while (TRUE) {
        KeepAliveInterval = g_KeepAliveInterval * 600000000 ;   // in 100 nanosecs
        pStack = NULL;

        // Lock the stack list for reading
        IcaAcquireSpinLock(&IcaStackListSpinLock, &OldIrql);

        //KdPrint(("Total number of stacks: %d\n", IcaTotalNumOfStacks));

        // determine new sleep time for the keepalive thread
        // it is the keepalive interval for a stack divided by total
        // number of stacks
        // the low threshold for sleep time is 5 sec.  Since relative
        // sleeptime is a negative value, we use min instead of max
        if (IcaTotalNumOfStacks > 1) {
            SleepTime.QuadPart = min(0 - KEEP_ALIVE_MIN_INTERVAL,
                    0 - (KeepAliveInterval / IcaTotalNumOfStacks));
        }
        else {
            SleepTime.QuadPart = min(0 - KEEP_ALIVE_MIN_INTERVAL,
                    0 - KeepAliveInterval);
        }

        // If the stack list is not empty, get the stack for keepalive
        // checking and move the IcaNextStack pointer to the next stack
        if (IcaNextStack != &IcaStackListHead) {
            pStack = CONTAINING_RECORD(IcaNextStack, ICA_STACK, StackNode);

            // Reference the stack so that the stack won't be deleted while we
            // are accessing it
            IcaReferenceStack(pStack);

            IcaNextStack = IcaNextStack->Flink;
        }
        else {
            if (IcaNextStack->Flink != &IcaStackListHead) {
                pStack = CONTAINING_RECORD(IcaNextStack->Flink, ICA_STACK, StackNode);

                // Reference the stack so that the stack won't be deleted while we
                // are accessing it
                IcaReferenceStack(pStack);

                IcaNextStack = IcaNextStack->Flink->Flink;
            }
        }

        // Unlock the stack list now
        IcaReleaseSpinLock(&IcaStackListSpinLock, OldIrql);

        // If the stack pointer is invalid or LastInputTime on the stack is 0,
        // the stack is not in the active state, so we don't need to send
        // keepalive pkt on that stack.
        if (pStack != NULL && pStack->LastInputTime.QuadPart != 0) {
            // Get the current system time
            KeQuerySystemTime(&CurrentTime);

            // Check if it is time to send a keepalive packet depends on
            // the keepalive timestamp and lastinput timestamp
            if (CurrentTime.QuadPart - pStack->LastKeepAliveTime.QuadPart >= KeepAliveInterval &&
                    CurrentTime.QuadPart - pStack->LastInputTime.QuadPart >= KeepAliveInterval) {

                // Initialize the IOCTL struct
                SdIoctl.IoControlCode = IOCTL_ICA_STACK_SEND_KEEPALIVE_PDU;
                SdIoctl.InputBuffer = NULL;
                SdIoctl.InputBufferLength = 0;
                SdIoctl.OutputBuffer = NULL;
                SdIoctl.OutputBufferLength = 0;

                //KdPrint(("In IcaCheckStackAlive: To call WD, pStack=%p\n", pStack));

                // Send an IOCTL to the stack requesting to send a keepalive packet
                _IcaCallStack(pStack, SD$IOCTL, &SdIoctl);

                // Update the LastKeepAlive timestamp for the stack
                KeQuerySystemTime(&pStack->LastKeepAliveTime);
            }
#if DBG
            else {
                if (CurrentTime.QuadPart - pStack->LastKeepAliveTime.QuadPart < KeepAliveInterval) {
                    //KdPrint(("Not time to do keep alive yet, pstack=%p\n", pStack));
                }
                if (CurrentTime.QuadPart - pStack->LastInputTime.QuadPart < KeepAliveInterval) {
                    //KdPrint(("- Last Input Time is less than KeepAliveInterval, pstack=%p\n", pStack));
                }
            }
#endif
        }
#if DBG
        else{
            if (pStack != NULL) {
                //KdPrint(("No need to send KeepAlive PDU on pstack=%p\n", pStack));
            }
        }
#endif
        // Decrement the reference to the stack so that it can be deleted
        if (pStack != NULL) {
            IcaDereferenceStack(pStack);
        }

        // Start sleep timer again
        // We would return if the unload module signal the IcaKeepAliveEvent
        // to stop this keepalive thread
        status = KeWaitForSingleObject(pIcaKeepAliveEvent, Executive, KernelMode, TRUE, &SleepTime);

        if (status == STATUS_SUCCESS) {
            return;
        }
    }
}


VOID
IcaKeepAliveThread(
    IN PVOID pData)
{
    IcaCheckStackAlive();
}

#ifdef notdef
VOID
IcaAcquireIoLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaLockConnectionForStack( pSdLink->pStack );
}


VOID
IcaReleaseIoLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaUnlockConnectionForStack( pSdLink->pStack );
}


VOID
IcaAcquireDriverLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaLockStack( pSdLink->pStack );
}


VOID
IcaReleaseDriverLock(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaUnlockStack( pSdLink->pStack );
}


VOID
IcaIncrementDriverReference(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaReferenceSdLink( pSdLink );
}


VOID
IcaDecrementDriverReference(
    IN PSDCONTEXT pContext
    )
{
    PSDLINK pSdLink;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    IcaDereferenceSdLink( pSdLink );
}
#endif


typedef NTSTATUS (*PTHREAD_ROUTINE) ( PVOID );

typedef struct _ICACREATETHREADINFO {
    PTHREAD_ROUTINE pProc;
    PVOID pParm;
    PSDLINK pSdLink;
    ULONG LockFlags;
} ICACREATETHREADINFO, *PICACREATETHREADINFO;


NTSTATUS
IcaCreateThread(
    IN PSDCONTEXT pContext,
    IN PVOID pProc,
    IN PVOID pParm,
    IN ULONG LockFlags,
    OUT PHANDLE pThreadHandle
    )
{
    PSDLINK pSdLink;
    PICACREATETHREADINFO pThreadInfo;
    NTSTATUS Status;

    /*
     * Use SD passed context to get the SDLINK object pointer.
     */
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    TRACESTACK(( pSdLink->pStack, TC_ICADD, TT_API1, "TermDD: IcaCreateThread (enter)\n" ));

    pThreadInfo = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pThreadInfo) );
    if ( pThreadInfo == NULL )
        return( STATUS_NO_MEMORY );

    pThreadInfo->pProc = pProc;
    pThreadInfo->pParm = pParm;
    pThreadInfo->pSdLink = pSdLink;
    pThreadInfo->LockFlags = LockFlags;

    /*
     * Reference the SDLINK object on behalf of the new thread.
     */
    IcaReferenceSdLink( pSdLink );

    Status = PsCreateSystemThread( pThreadHandle,
                                   THREAD_ALL_ACCESS,
                                   NULL,
                                   NtCurrentProcess(),
                                   NULL,
                                   _IcaDriverThread,
                                   (PVOID) pThreadInfo );
    if ( !NT_SUCCESS( Status ) ) {
        IcaDereferenceSdLink( pSdLink );
        ICA_FREE_POOL( pThreadInfo );
        return( Status );
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
_IcaDriverThread(
    IN PVOID pData
    )
{
    PICACREATETHREADINFO pThreadInfo = (PICACREATETHREADINFO)pData;
    PTHREAD_ROUTINE pProc;
    PVOID pParm;
    PSDLINK pSdLink;
    PICA_STACK pStack;
    ULONG LockFlags;
    NTSTATUS Status;

    pProc = pThreadInfo->pProc;
    pParm = pThreadInfo->pParm;
    pSdLink = pThreadInfo->pSdLink;
    LockFlags = pThreadInfo->LockFlags;
    ICA_FREE_POOL( pThreadInfo );
    pStack = pSdLink->pStack;

    /*
     * Obtain any required locks before calling the worker routine.
     */
    ASSERT( !(LockFlags & ICALOCK_IO) );
    if ( LockFlags & ICALOCK_DRIVER )
        IcaLockStack( pStack );

    /*
     * Call the thread routine
     */
#if DBG
    try {
#endif
        /*
         * If stack is being closed, then indicate this to caller.
         */
        if ( !pStack->fClosing )
            Status = (pProc)( pParm );
        else
            Status = STATUS_CTX_CLOSE_PENDING;
#if DBG
    } except( IcaExceptionFilter( L"_IcaDriverThread TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        Status = GetExceptionCode();
    }
#endif

    /*
     * Release any locks acquired above.
     */
    if ( LockFlags & ICALOCK_DRIVER )
        IcaUnlockStack( pStack );

    /*
     * Dereference the SDLINK object now.
     * This undoes the reference that was made on our behalf in
     * the IcaCreateThread routine when this thread was created.
     */
    IcaDereferenceSdLink( pSdLink );

    return( Status );
}

PICA_STACK
_IcaAllocateStack( VOID )
{
    PICA_STACK pStack;
    NTSTATUS Status;

    /*
     *  Allocate and initialize stack structure
     */
    pStack = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pStack) );
    if ( pStack == NULL )
        return NULL;
    RtlZeroMemory( pStack, sizeof(*pStack) );

    /*
     * Initialize the reference count to 2,
     * one for the caller's reference, one for the file object reference.
     */
    pStack->RefCount = 2;

    /*
     * Initialize the rest of the stack object
     */
    pStack->Header.Type = IcaType_Stack;
    pStack->Header.pDispatchTable = IcaStackDispatchTable;
    ExInitializeResourceLite( &pStack->Resource );
    InitializeListHead( &pStack->SdLinkHead );
    KeInitializeEvent( &pStack->OutBufEvent, NotificationEvent, FALSE );
    KeInitializeEvent( &pStack->IoEndEvent, NotificationEvent, FALSE );

    return( pStack );
}


VOID
_IcaFreeStack( PICA_STACK pStack )
{
    PICA_CONNECTION pConnect;

    ASSERT( pStack->RefCount == 0 );
    ASSERT( IsListEmpty( &pStack->SdLinkHead ) );
    ASSERT( !ExIsResourceAcquiredExclusiveLite( &pStack->Resource ) );

    /*
     * Remove the reference to the Connection object for this stack.
     */
    pConnect = (PICA_CONNECTION)pStack->pConnect;
    IcaDereferenceConnection( pConnect );

    ExDeleteResourceLite( &pStack->Resource );

    ICA_FREE_POOL( pStack );
}


NTSTATUS
_IcaPushStack(
    IN PICA_STACK pStack,
    IN PICA_STACK_PUSH pStackPush
    )
{
    SD_OPEN SdOpen;
    PSDLINK pSdLink;
    NTSTATUS Status;

    if ( g_TermServProcessID == NULL)
    {
        g_TermServProcessID = IoGetCurrentProcess();
    }

    /*
     * Serialize all stack push/pop/call operations
     */
    IcaLockStack( pStack );

    TRACESTACK(( pStack, TC_ICADD, TT_API1, "TermDD: _IcaPushStack, type %u, name %S (enter)\n",
                 pStackPush->StackModuleType, pStackPush->StackModuleName ));

    /*
     * If stack is being closed, then indicate this to caller
     */
    if ( pStack->fClosing ) {
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }

    /*
     * Load an instance of the requested stack driver
     */
    Status = _IcaLoadSd( pStackPush->StackModuleName, &pSdLink );
    if ( !NT_SUCCESS( Status ) )
        goto done;

    /*
     * If this is the first stack driver loaded, then initialize
     * some of the stack data from the ICA_STACK_PUSH parameters.
     * NOTE: Since we're testing for an empty list we must make
     *       this check before the InsertHeadList below.
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        pStack->OutBufLength = pStackPush->PdConfig.Create.OutBufLength;
        pStack->OutBufCount = pStackPush->PdConfig.Create.OutBufCount;
        
        
        //
        //Set the low water mark using the PD config
        //
        if ( !(pStackPush->PdConfig.Create.PdFlag & PD_NOLOW_WATERMARK) ) {
            //
            //set to default
            //
            pStack->OutBufLowWaterMark = (pStackPush->PdConfig.Create.OutBufCount/ 3) + 1;
        }
        else {
            pStack->OutBufLowWaterMark = MAX_LOW_WATERMARK;
        }
    }

    /*
     * Increment the stack ref count for this SD,
     * and push the new SD on the stack.
     */
    IcaReferenceStack( pStack );
    InsertHeadList( &pStack->SdLinkHead, &pSdLink->Links );
    pSdLink->pStack = pStack;

    /*
     * Initialize the SD open parameters
     */
    SdOpen.StackClass        = pStack->StackClass;
    SdOpen.pStatus           = &pStack->ProtocolStatus;
    SdOpen.pClient           = &pStack->ClientModules;
    SdOpen.WdConfig          = pStackPush->WdConfig;
    SdOpen.PdConfig          = pStackPush->PdConfig;
    SdOpen.OutBufHeader      = pStack->SdOutBufHeader;
    SdOpen.OutBufTrailer     = pStack->SdOutBufTrailer;

    SdOpen.DeviceObject      = pSdLink->pSdLoad->DeviceObject;

    RtlCopyMemory( SdOpen.OEMId, pStackPush->OEMId, sizeof(SdOpen.OEMId) );
    RtlCopyMemory( SdOpen.WinStationRegName, pStackPush->WinStationRegName,
                   sizeof(SdOpen.WinStationRegName) );

    /*
     * Call the SD open procedure
     */
    Status = _IcaCallSd( pSdLink, SD$OPEN, &SdOpen );
    if ( !NT_SUCCESS( Status ) ) {
        RemoveEntryList( &pSdLink->Links );
        pSdLink->Links.Flink = pSdLink->Links.Blink = NULL;
        IcaDereferenceSdLink( pSdLink );
        goto done;
    }

    /*
     *  Increment number of reserved output buffer bytes
     */
    pStack->SdOutBufHeader  += SdOpen.SdOutBufHeader;
    pStack->SdOutBufTrailer += SdOpen.SdOutBufTrailer;

done:
    IcaUnlockStack( pStack );

    return( Status );
}


NTSTATUS
_IcaPopStack(
    IN PICA_STACK pStack
    )
{
    PICA_CONNECTION pConnect;
    SD_CLOSE SdClose;
    PSDLINK pSdLink;
    NTSTATUS Status;

    /*
     * Serialize all stack push/pop/call operations
     */
    IcaLockStack( pStack );

    ASSERT( (pConnect = IcaGetConnectionForStack( pStack )) &&
            ExIsResourceAcquiredExclusiveLite( &pConnect->Resource ) );

    /*
     * If no SDs remain, then return error
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        Status = STATUS_NO_MORE_ENTRIES;
        goto done;
    }

    /*
     * Call the SD close procedure for the topmost SD
     */
    pSdLink = CONTAINING_RECORD( pStack->SdLinkHead.Flink, SDLINK, Links );
    ASSERT( pSdLink->pStack == pStack );
    Status = _IcaCallSd( pSdLink, SD$CLOSE, &SdClose );

    /*
     *  Decrement number of reserved output buffer bytes
     */
    pStack->SdOutBufHeader  -= SdClose.SdOutBufHeader;
    pStack->SdOutBufTrailer -= SdClose.SdOutBufTrailer;

    /*
     * Remove the SdLink from the top of the list,
     * and dereference the SDLINK object.
     */
    RemoveEntryList( &pSdLink->Links );
    pSdLink->Links.Flink = pSdLink->Links.Blink = NULL;
    IcaDereferenceSdLink( pSdLink );

done:
    IcaUnlockStack( pStack );

    return( Status );
}


NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    )
{
    PLIST_ENTRY Head;
    PSDLINK pSdLink;
    NTSTATUS Status;

    /*
     * Serialize all stack push/pop/call operations
     */
    IcaLockStack( pStack );

    /*
     * Call the topmost Stack Driver, if there is one
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        IcaUnlockStack( pStack );
        return( STATUS_INVALID_PARAMETER );
    }

    Head = pStack->SdLinkHead.Flink;
    pSdLink = CONTAINING_RECORD( Head, SDLINK, Links );
    ASSERT( pSdLink->pStack == pStack );
    Status = _IcaCallSd( pSdLink, ProcIndex, pParms );

    IcaUnlockStack( pStack );

    return( Status );
}


NTSTATUS
_IcaCallStackNoLock(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    )
{
    PLIST_ENTRY Head;
    PSDLINK pSdLink;
    NTSTATUS Status;

    /*
     * Call the topmost Stack Driver, if there is one
     */
    if ( IsListEmpty( &pStack->SdLinkHead ) ) {
        return( STATUS_INVALID_PARAMETER );
    }

    Head = pStack->SdLinkHead.Flink;
    pSdLink = CONTAINING_RECORD( Head, SDLINK, Links );
    ASSERT( pSdLink->pStack == pStack );
    Status = _IcaCallSd( pSdLink, ProcIndex, pParms );

    return( Status );
}


NTSTATUS
_IcaLoadSd(
    IN PDLLNAME SdName,
    OUT PSDLINK *ppSdLink
    )
{
    PSDLINK pSdLink;
    PSDLOAD pSdLoad;
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;

    /*
     * Allocate a SDLINK struct
     */
    pSdLink = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pSdLink) );
    if ( pSdLink == NULL )
        return( STATUS_INSUFFICIENT_RESOURCES );
    RtlZeroMemory( pSdLink, sizeof(*pSdLink) );

    /*
     * Initialize reference count
     */
    pSdLink->RefCount = 1;
#if DBG
    ExInitializeResourceLite( &pSdLink->Resource );
#endif

    /*
     * Lock the ICA Resource exclusively to search the SdLoad list.
     * Note when holding a resource we need to prevent APC calls, so
     * use KeEnterCriticalRegion().
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );

    /*
     * Look for the requested SD.  If found, increment the ref count for it.
     */
    Head = &IcaSdLoadListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pSdLoad = CONTAINING_RECORD( Next, SDLOAD, Links );
        if ( !wcscmp( pSdLoad->SdName, SdName ) ) {
            _IcaReferenceSdLoad( pSdLoad );
            break;
        }
    }

    /*
     * If the requested SD was not found, then load it now.
     */
    if ( Next == Head ) {
        Status = _IcaLoadSdWorker( SdName, &pSdLoad );
        if ( !NT_SUCCESS( Status ) ) {
            ExReleaseResourceLite( IcaSdLoadResource );
            KeLeaveCriticalRegion();
#if DBG
            ExDeleteResourceLite( &pSdLink->Resource);
#endif
            ICA_FREE_POOL( pSdLink );
            return( Status );
        }
    }

    ExReleaseResourceLite( IcaSdLoadResource );
    KeLeaveCriticalRegion();

    pSdLink->pSdLoad = pSdLoad;

    /*
     * Call the driver load procedure.
     * The driver will fill in the fields in the SDCONTEXT structure.
     */
    Status = (pSdLoad->DriverLoad)( &pSdLink->SdContext, TRUE );
    if ( !NT_SUCCESS( Status ) ) {
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );
        _IcaDereferenceSdLoad( pSdLink->pSdLoad );
        ExReleaseResourceLite( IcaSdLoadResource );
        KeLeaveCriticalRegion();
#if DBG
        ExDeleteResourceLite( &pSdLink->Resource );
#endif
        ICA_FREE_POOL( pSdLink );
        return( Status );
    }

    *ppSdLink = pSdLink;

    return( Status );
}


NTSTATUS
_IcaUnloadSd(
    IN PSDLINK pSdLink
    )
{
    KIRQL oldIrql;
    NTSTATUS Status;

    ASSERT( pSdLink->RefCount == 0 );
    ASSERT( pSdLink->Links.Flink == NULL );

    /*
     * Inform driver of unload
     */
    Status = (pSdLink->pSdLoad->DriverLoad)( &pSdLink->SdContext, FALSE );

    /*
     * Decrement ref count on SdLoad object.
     * This will cause it to be unloaded if the ref count goes to 0.
     * Note that while holding a resource we need to disable APC calls,
     * hence the CriticalRegion calls.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( IcaSdLoadResource, TRUE );
    _IcaDereferenceSdLoad( pSdLink->pSdLoad );
    ExReleaseResourceLite( IcaSdLoadResource );
    KeLeaveCriticalRegion();

    /*
     * Remove reference this SDLINK object had on the stack.
     */
    IcaDereferenceStack( pSdLink->pStack );

#if DBG
    ExDeleteResourceLite( &pSdLink->Resource );
#endif

    ICA_FREE_POOL( pSdLink );

    return( Status );
}


NTSTATUS
_IcaCallSd(
    IN PSDLINK pSdLink,
    IN ULONG ProcIndex,
    IN PVOID pParms
    )
{
    PSDPROCEDURE pSdProcedure;
    NTSTATUS Status;

    /*
     * If there is no procedure call table, return success.
     * This should only happen during load/unload and should not be a problem.
     */
    if ( pSdLink->SdContext.pProcedures == NULL )
        return( STATUS_SUCCESS );

    /*
     * Get a pointer to the SD proc based on specified ProcIndex.
     * If NULL, then this ProcIndex is not supported by this driver.
     */
    pSdProcedure = ((PSDPROCEDURE *)pSdLink->SdContext.pProcedures)[ ProcIndex ];
    if ( pSdProcedure == NULL )
        return( STATUS_NOT_SUPPORTED );

    IcaReferenceSdLink( pSdLink );


    Status = (pSdProcedure)( pSdLink->SdContext.pContext, pParms );

    IcaDereferenceSdLink( pSdLink );

    return( Status );
}


VOID
IcaReferenceSdLink(
    IN PSDLINK pSdLink
    )
{

    ASSERT( pSdLink->RefCount >= 0 );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement( &pSdLink->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
IcaDereferenceSdLink(
    IN PSDLINK pSdLink
    )
{

    ASSERT( pSdLink->RefCount > 0 );
    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );

    /*
     * Decrement the reference count; if it is 0, unload the SD.
     */
    if ( InterlockedDecrement( &pSdLink->RefCount) == 0 ) {
        _IcaUnloadSd( pSdLink );
    }
}


PSDLINK
IcaGetNextSdLink(
    IN PSDLINK pSdLink
    )
{
    PLIST_ENTRY Next;
    PSDLINK pNextSdLink;

    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );
    ASSERT( pSdLink->RefCount > 0 || pSdLink->Links.Flink == NULL );
    ASSERT( pSdLink->SdContext.pProcedures );
    ASSERT( pSdLink->SdContext.pContext );

    if ( pSdLink->Links.Flink == NULL )
        return( NULL );

    Next = pSdLink->Links.Flink;
    if ( Next == &pSdLink->pStack->SdLinkHead )
        return( NULL );

    pNextSdLink = CONTAINING_RECORD( Next, SDLINK, Links );
    ASSERT( pNextSdLink->pStack == pSdLink->pStack );
    ASSERT( pNextSdLink->RefCount > 0 );
    ASSERT( pNextSdLink->SdContext.pProcedures );
    ASSERT( pNextSdLink->SdContext.pContext );

    return( pNextSdLink );
}


PSDLINK
IcaGetPreviousSdLink(
    IN PSDLINK pSdLink
    )
{
    PLIST_ENTRY Prev;
    PSDLINK pPrevSdLink;

    ASSERT( pSdLink->pStack->Header.Type == IcaType_Stack );
    ASSERT( pSdLink->pStack->Header.pDispatchTable == IcaStackDispatchTable );
    ASSERT( pSdLink->RefCount > 0 || pSdLink->Links.Flink == NULL );
    ASSERT( pSdLink->SdContext.pProcedures );
    ASSERT( pSdLink->SdContext.pContext );

    if ( pSdLink->Links.Blink == NULL )
        return( NULL );

    Prev = pSdLink->Links.Blink;
    if ( Prev == &pSdLink->pStack->SdLinkHead )
        return( NULL );

    pPrevSdLink = CONTAINING_RECORD( Prev, SDLINK, Links );
    ASSERT( pPrevSdLink->pStack == pSdLink->pStack );
    ASSERT( pPrevSdLink->RefCount > 0 );
    ASSERT( pPrevSdLink->SdContext.pProcedures );
    ASSERT( pPrevSdLink->SdContext.pContext );

    return( pPrevSdLink );
}


VOID
_IcaReferenceSdLoad(
    IN PSDLOAD pSdLoad
    )
{

    ASSERT( ExIsResourceAcquiredExclusiveLite( IcaSdLoadResource ) );
    ASSERT( pSdLoad->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    ++pSdLoad->RefCount;
    ASSERT( pSdLoad->RefCount > 0 );
}


VOID
_IcaDereferenceSdLoad(
    IN PSDLOAD pSdLoad
    )
{

    ASSERT( ExIsResourceAcquiredExclusiveLite( IcaSdLoadResource ) );
    ASSERT( pSdLoad->RefCount > 0 );

    /*
     * Decrement the reference count; if it is 0, unload the SD by queuing
     * a passive level DPC. We must do this to prevent continuing to hold
     * ObpInitKillMutant in the loader -- the driver unload can cause RPC
     * calls which deadlock on that object.
     */
    if ( pSdLoad->RefCount == 1 ) {
        PWORK_QUEUE_ITEM pItem;

        pItem = ICA_ALLOCATE_POOL(NonPagedPool, sizeof(WORK_QUEUE_ITEM));
        if (pItem != NULL) {
            ExInitializeWorkItem(pItem, _IcaUnloadSdWorker, pSdLoad);
            pSdLoad->pUnloadWorkItem = pItem;
            ExQueueWorkItem(pItem, DelayedWorkQueue);
        }
        /* If we cannot allocate workitem do not unload here. It is
         * better to temporarly leak one driver than deadlocking the
         * system.
         */
    }else{
        pSdLoad->RefCount--;
    }
}


NTSTATUS IcaExceptionFilter(PWSTR OutputString, PEXCEPTION_POINTERS pexi)
{
    DbgPrint( "TermDD: %S\n", OutputString );
    DbgPrint( "TermDD: ExceptionRecord=%p ContextRecord=%p\n",
              pexi->ExceptionRecord, pexi->ContextRecord );
#ifdef i386
    DbgPrint( "TermDD: Exception code=%08x, flags=%08x, addr=%p, IP=%p\n",
              pexi->ExceptionRecord->ExceptionCode,
              pexi->ExceptionRecord->ExceptionFlags,
              pexi->ExceptionRecord->ExceptionAddress,
              pexi->ContextRecord->Eip );

    DbgPrint( "TermDD: esp=%p ebp=%p\n",
              pexi->ContextRecord->Esp, pexi->ContextRecord->Ebp );
#else
    DbgPrint( "TermDD: Exception code=%08x, flags=%08x, addr=%p\n",
              pexi->ExceptionRecord->ExceptionCode,
              pexi->ExceptionRecord->ExceptionFlags,
              pexi->ExceptionRecord->ExceptionAddress );
#endif

    {
        SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
        NTSTATUS Status;

        Status = ZwQuerySystemInformation(SystemKernelDebuggerInformation,
                &KernelDebuggerInfo, sizeof(KernelDebuggerInfo), NULL);
        if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)
             DbgBreakPoint();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}


//
// Helper routine to break if there is a debugger attached
//
//
VOID
IcaBreakOnDebugger( )
{
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
    NTSTATUS Status;

    Status = ZwQuerySystemInformation(SystemKernelDebuggerInformation,
            &KernelDebuggerInfo, sizeof(KernelDebuggerInfo), NULL);
    if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled)
         DbgBreakPoint();
}


/*******************************************************************************
 *
 *  _RegisterBrokenEvent
 *
 *    Register an event to be signaled when the stack is broken
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to stack structure
 *    pStackBroken (input)
 *       pointer to buffer containing event info
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_RegisterBrokenEvent(
    IN PICA_STACK pStack,
    IN PICA_STACK_BROKEN pStackBroken
    )
{
    NTSTATUS Status;

    /*
     * There should not already be any event registered
     */
    if ( pStack->pBrokenEventObject ) {
        ASSERT( FALSE );
        return( STATUS_OBJECT_NAME_COLLISION );
    }

    /*
     * Reference the event and save a pointer to the object
     */
    Status = ObReferenceObjectByHandle( pStackBroken->BrokenEvent,
                                        0L,
                                        *ExEventObjectType,
                                        KernelMode,
                                        (PVOID *)&pStack->pBrokenEventObject,
                                        NULL
                                        );

    return( Status );
}


/*******************************************************************************
 *
 *  _EnablePassthru
 *
 *    Enable passthru mode for this connection
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to passthru stack structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_EnablePassthru( PICA_STACK pStack )
{
    PICA_CONNECTION pConnect;
    PLIST_ENTRY Prev;
    PICA_STACK pPrimaryStack;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    ASSERT( pStack->pPassthru == NULL );
    ASSERT( !IsListEmpty( &pStack->StackEntry ) );

    /*
     * Lock connection object and get a pointer to it.
     */
    pConnect = IcaLockConnectionForStack( pStack );

    /*
     * Get pointer to previous stack for this connection.
     * If there is one (i.e. prev does not point to the stack head),
     * then it must be the primary stack which we will connect to.
     */
    Prev = pStack->StackEntry.Blink;
    if ( Prev != &pConnect->StackHead ) {
        pPrimaryStack = CONTAINING_RECORD( Prev, ICA_STACK, StackEntry );
        ASSERT( pPrimaryStack->StackClass == Stack_Primary );

        /*
         * Connect the primary and passthru stacks
         */
        pPrimaryStack->pPassthru = pStack;
        pStack->pPassthru = pPrimaryStack;
        pConnect->fPassthruEnabled = TRUE;
        Status = STATUS_SUCCESS;
    }

    IcaUnlockConnection( pConnect );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _DisablePassthru
 *
 *    Disable passthru mode for this connection
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to passthru stack structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_DisablePassthru(PICA_STACK pStack)
{
    PICA_CONNECTION pConnect;

    pConnect = IcaLockConnectionForStack(pStack);

    if (pStack->pPassthru) {
        // Lock each stack while clearing the pPassthru pointer.
        // This synchronizes references through the pPassthru pointer
        // within the function IcaRawInputInternal().
        // NOTE: We assume that we have ZERO locks on entry to this function.
        // We then take only one lock at a time so we cannot deadlock.
        IcaLockStack(pStack->pPassthru);
        pStack->pPassthru->pPassthru = NULL;
        IcaUnlockStack(pStack->pPassthru);

        IcaLockStack(pStack);
        pStack->pPassthru = NULL;
        IcaUnlockStack(pStack);

        pConnect->fPassthruEnabled = FALSE;
    }

    IcaUnlockConnection(pConnect);

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *
 *  _ReconnectStack
 *
 *    Reconnect the stack to a new connection object.
 *
 * ENTRY:
 *    pStack (input)
 *       pointer to stack structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_ReconnectStack(PICA_STACK pStack, HANDLE hIca)
{
    PFILE_OBJECT pNewConnectFileObject;
    PICA_CONNECTION pNewConnect;
    PICA_CONNECTION pOldConnect;
    PLIST_ENTRY pSaveVcBind;
    NTSTATUS Status;

    /*
     * Only allow a reconnect on a Primary stack.
     */
    if ( pStack->StackClass != Stack_Primary )
        return( STATUS_NOT_SUPPORTED );

    /*
     * If passthru mode is enabled, disable it now.
     */
    if ( pStack->pPassthru ) {
        _DisablePassthru( pStack );
    }

    /*
     * Open the file object for the new connection we will attach to.
     */
    Status = ObReferenceObjectByHandle(
                 hIca,
                 0L,                         // DesiredAccess
                 *IoFileObjectType,
                 KernelMode,
                 (PVOID *)&pNewConnectFileObject,
                 NULL
                 );
    if (!NT_SUCCESS(Status))
        return(Status);

    /*
     * Get a pointer to the new connection object and reference it.
     */
    pNewConnect = pNewConnectFileObject->FsContext;
    IcaReferenceConnection(pNewConnect);

    /*
     * Obtain the necessary locks to perform the stack reconnect.
     *
     * First, we acquire the global resource lock.
     *
     * Next lock the connection this stack is currently attached to
     * as well as the new connection the stack will be moved to.
     * NOTE: Because of the use of the global resource lock,
     *       there is no possiblility of deadlock even though we
     *       are attempting to lock two connection objects at the
     *       same time.
     * NOTE: While holding a resource we need to disable APC calls
     *       with the CriticalRegion calls.
     *
     * Finally, lock the stack object itself.
     */
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(IcaReconnectResource, TRUE);

    pOldConnect = IcaLockConnectionForStack(pStack);
    if (pOldConnect == pNewConnect) {
        Status = STATUS_UNSUCCESSFUL;
        goto badoldconnect;
    }

    IcaLockConnection(pNewConnect);
    if (!IsListEmpty(&pNewConnect->VcBindHead)) {
        Status = STATUS_UNSUCCESSFUL;
        goto badnewconnect;
    }
    if (!IsListEmpty(&pNewConnect->StackHead)) {
        PICA_STACK pHeadStack;
        pHeadStack = CONTAINING_RECORD(pStack->StackEntry.Flink, ICA_STACK, StackEntry);
        if (pHeadStack->StackClass == Stack_Primary) {
            Status = STATUS_UNSUCCESSFUL;
            goto badnewconnect;
        }
    }

    IcaLockStack(pStack);

    /*
     * Unbind the virtual channels,
     * and unlink the VcBind list and save a pointer to it
     * (but only if the list is non-empty).
     */
    IcaUnbindVirtualChannels( pOldConnect );
    if ( !IsListEmpty( &pOldConnect->VcBindHead ) ) {
        pSaveVcBind = pOldConnect->VcBindHead.Flink;
        RemoveEntryList( &pOldConnect->VcBindHead );
        InitializeListHead( &pOldConnect->VcBindHead );
    } else {
        pSaveVcBind = NULL;
    }

    /*
     * Unlink this stack from the stack list for this connection,
     * and remove the reference to the Connection object.
     */
    RemoveEntryList( &pStack->StackEntry );
    IcaDereferenceConnection( pOldConnect );

    /*
     * We're done with the old connection object so unlock it now.
     */
    IcaUnlockConnection( pOldConnect );

    /*
     * Restore the VcBind list and Rebind the virtual channels.
     */
    if ( pSaveVcBind ) {
        InsertTailList( pSaveVcBind, &pNewConnect->VcBindHead );
        IcaRebindVirtualChannels( pNewConnect );
    }

    /*
     * Insert this stack in the stack list for this connection,
     * and save the new Connection object pointer for this stack.
     */
    InsertHeadList( &pNewConnect->StackHead, &pStack->StackEntry );
    pStack->pConnect = (PUCHAR)pNewConnect;

    /*
     * Release stack/connection objects and global resource
     */
    IcaUnlockStack( pStack );
    IcaUnlockConnection( pNewConnect );
    ExReleaseResourceLite( IcaReconnectResource );
    KeLeaveCriticalRegion();

    /*
     * The stack requires a connection object reference,
     * so leave the one made above, but dereference the file object.
     */
    //IcaDereferenceConnection( pNewConnect );
    ObDereferenceObject( pNewConnectFileObject );

    return( STATUS_SUCCESS );

badnewconnect:
    IcaUnlockConnection( pNewConnect );

badoldconnect:
    IcaUnlockConnection( pOldConnect );
    ExReleaseResourceLite( IcaReconnectResource );
    KeLeaveCriticalRegion();
    IcaDereferenceConnection( pNewConnect );
    ObDereferenceObject( pNewConnectFileObject );

    return( Status );
}



PVOID IcaStackAllocatePoolWithTag(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes,
        IN ULONG Tag )
{
    PVOID pBuffer;


    pBuffer = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
    if (pBuffer != NULL) {
        gAllocSucceed++;
    } else {
        gAllocFailed++;
    }
    return pBuffer;  
}

PVOID IcaStackAllocatePool(
        IN POOL_TYPE PoolType,
        IN SIZE_T NumberOfBytes)
{

    PVOID pBuffer;

    pBuffer = ExAllocatePool(PoolType, NumberOfBytes);
    if (pBuffer != NULL) {
        gAllocSucceed++;
    } else {
        gAllocFailed++;
    }
    return pBuffer;  
}


void IcaStackFreePool(IN PVOID Pointer)
{

    ExFreePool(Pointer);
    gAllocFreed++;
}



NTSTATUS _IcaKeepAlive( 
        IN BOOLEAN  enableKeepAlive,
        IN ULONG    interval )
{

    NTSTATUS    status = STATUS_SUCCESS;
    HANDLE      ThreadHandle;

    if ( enableKeepAlive  )
    {
        // a request has come to start the keep alive thread

        if (pKeepAliveThreadObject == NULL ) // if we have no thread object, thread is not running
        {
            // keep alive thread uses this interval.
            g_KeepAliveInterval = interval;

            // Create a new thread to handle keep alive
            status = PsCreateSystemThread( &ThreadHandle,
                                           THREAD_ALL_ACCESS,
                                           NULL,
                                           NtCurrentProcess(),
                                           NULL,
                                           IcaKeepAliveThread,
                                           NULL );
        
            if (status == STATUS_SUCCESS) {
                // Reference the thread handle by object
                status = ObReferenceObjectByHandle(ThreadHandle, THREAD_ALL_ACCESS, NULL,
                        KernelMode,  (PVOID *)&pKeepAliveThreadObject, NULL);
        
                if (status == STATUS_SUCCESS) 
                {
                    // KdPrint(("In TermDD: KeepAlive thread created successfully\n"));
                }
                else 
                {
                    KdPrint(("TermDD: Unable to reference object by thread handle: %d\n", status));
                }
        
                ZwClose(ThreadHandle);
            }
            else 
            {
                KdPrint(("In TermDD: Unable to create KeepAlive thread.\n"));
            }
        }
        else
        {
            // otherwise, keep alive thread is running, but we might have to change the interval to some new value

            // set the new value so that next time around the while loop, it will be picked up.
            g_KeepAliveInterval = interval;
            // KdPrint(("In TermDD: KeepAliveInterval was changes to %d \n",g_KeepAliveInterval  ));
        }
    }
    else
    {
        // we don't need the keep alive thread

        if (pKeepAliveThreadObject != NULL ) 
        {
            // Set IcaKeepAliveEvent to wake up KeepAlive thread
            if (pIcaKeepAliveEvent != NULL ) 
            {
                KeSetEvent(pIcaKeepAliveEvent, 0, FALSE);
            }

            // Wait for the thread to exit
            KeWaitForSingleObject(pKeepAliveThreadObject, Executive, KernelMode, TRUE, NULL);

            // Deference the thread object
            ObDereferenceObject(pKeepAliveThreadObject);
            pKeepAliveThreadObject = NULL;

            // KdPrint(("In TermDD: KeepAlive thread was terminated successfully \n"));

            status = STATUS_SUCCESS;
        }
    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\video.c ===
/*************************************************************************
*
* video.c
*
* This module contains routines for managing the ICA video channel.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop


NTSTATUS
IcaDeviceControlVideo(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the DeviceControl routine for the ICA video channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    SD_IOCTL SdIoctl;
    NTSTATUS Status;

    SdIoctl.BytesReturned      = 0;
    SdIoctl.IoControlCode      = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    SdIoctl.InputBuffer        = Irp->AssociatedIrp.SystemBuffer;
    SdIoctl.InputBufferLength  = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    SdIoctl.OutputBuffer       = Irp->AssociatedIrp.SystemBuffer;
    SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );

    Irp->IoStatus.Information = SdIoctl.BytesReturned;

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\trace.c ===
/*******************************************************************************
*
* TRACE.C
*    This module implements the trace functions
*
* Copyright 1998, Microsoft.
*
*
******************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

#include <ctxdd.h>


/*=============================================================================
==   External Functions Defined
=============================================================================*/

NTSTATUS    IcaStartStopTrace( PICA_TRACE_INFO, PICA_TRACE );

VOID _cdecl IcaSystemTrace( ULONG, ULONG, CHAR *, ... );
VOID        IcaSystemTraceBuffer( ULONG, ULONG, PVOID, ULONG );

VOID _cdecl IcaStackTrace( PSDCONTEXT, ULONG, ULONG, CHAR *, ... );
VOID        IcaStackTraceBuffer( PSDCONTEXT, ULONG, ULONG, PVOID, ULONG );

VOID        IcaTraceFormat( PICA_TRACE_INFO, ULONG, ULONG, CHAR * );

VOID _cdecl _IcaTrace( PICA_CONNECTION, ULONG, ULONG, CHAR *, ... );
VOID _cdecl _IcaStackTrace( PICA_STACK, ULONG, ULONG, CHAR *, ... );
VOID        _IcaStackTraceBuffer( PICA_STACK, ULONG, ULONG, PVOID, ULONG );
VOID _cdecl _IcaChannelTrace( PICA_CHANNEL, ULONG, ULONG, CHAR *, ... );


/*=============================================================================
==   Internal functions
=============================================================================*/

NTSTATUS _IcaOpenTraceFile( PICA_TRACE_INFO, PWCHAR );
VOID _IcaCloseTraceFile( PICA_TRACE_INFO );
VOID _IcaTraceWrite( PICA_TRACE_INFO, PVOID );
VOID _IcaFlushDeferredTrace( PICA_TRACE_INFO );
int _FormatTime( CHAR *, ULONG );
int _FormatThreadId( CHAR *, ULONG );
VOID _WriteHexData( PICA_TRACE_INFO, PVOID, ULONG );


/*=============================================================================
==   Global variables
=============================================================================*/

/*
 *  Trace info
 */
ICA_TRACE_INFO G_TraceInfo = { 0, 0, FALSE, FALSE, NULL, NULL, NULL };


/*******************************************************************************
 *
 *  IcaStartStopTrace
 *
 *  Start/stop tracing
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     pTrace (input)
 *        pointer to ICA_TRACE (IOCTL) trace settings
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaStartStopTrace(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PICA_TRACE pTrace
    )
{
    NTSTATUS Status;

    /*
     * If a trace file was specified,
     * then open it and save a pointer to the file object.
     */
    if ( pTrace->TraceFile[0] ) {
        /*
         * Force a null termination for file name.
         */
        pTrace->TraceFile[255] = (WCHAR)0;
        Status = _IcaOpenTraceFile( pTraceInfo, pTrace->TraceFile );
        if ( !NT_SUCCESS( Status ) )
            return( Status );

    /*
     * If no trace file specified, then close any existing trace file
     */
    } else if ( pTraceInfo->pTraceFileName ) {
        _IcaCloseTraceFile( pTraceInfo );
    }

    /*
     *  Set trace flags
     */
    pTraceInfo->fTraceDebugger  = pTrace->fDebugger;
    pTraceInfo->fTraceTimestamp = pTrace->fTimestamp;
    pTraceInfo->TraceClass      = pTrace->TraceClass;
    pTraceInfo->TraceEnable     = pTrace->TraceEnable;


    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  IcaSystemTrace
 *
 *  This routine conditional writes a trace record to the system trace file
 *
 *  ENTRY:
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
IcaSystemTrace( IN ULONG TraceClass,
                IN ULONG TraceEnable,
                IN CHAR * Format,
                IN ... )
{
    va_list arg_marker;
    char Buffer[256];

    va_start( arg_marker, Format );

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & G_TraceInfo.TraceClass) || !(TraceEnable & G_TraceInfo.TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );

    /*
     *  Write trace data
     */
    IcaTraceFormat( &G_TraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  IcaSystemTraceBuffer
 *
 *  This routine conditional writes a data buffer to the system trace file
 *
 *  ENTRY:
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pBuffer (input)
 *        pointer to data buffer
 *     ByteCount (input)
 *        length of buffer
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
IcaSystemTraceBuffer( IN ULONG TraceClass,
                      IN ULONG TraceEnable,
                      IN PVOID pBuffer,
                      IN ULONG ByteCount )
{
    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & G_TraceInfo.TraceClass) ||
         !(TraceEnable & G_TraceInfo.TraceEnable) )
        return;

    /*
     *  Write trace data
     */
    _WriteHexData( &G_TraceInfo, pBuffer, ByteCount );
}


/*******************************************************************************
 *
 *  IcaStackTrace
 *
 *  This routine conditional writes a trace record depending on the trace mask
 *
 *  ENTRY:
 *     pContext (input)
 *        pointer to stack driver context
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
IcaStackTrace( IN PSDCONTEXT pContext,
               IN ULONG TraceClass,
               IN ULONG TraceEnable,
               IN CHAR * Format,
               IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;
    PICA_TRACE_INFO pTraceInfo;

    va_start( arg_marker, Format );

    /*
     * Use SD passed context to get the STACK object pointer.
     */
    pStack = (CONTAINING_RECORD( pContext, SDLINK, SdContext ))->pStack;
    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  IcaStackTraceBuffer
 *
 *  This routine conditional writes a data buffer to the trace file
 *
 *  ENTRY:
 *     pContext (input)
 *        pointer to stack driver context
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pBuffer (input)
 *        pointer to data buffer
 *     ByteCount (input)
 *        length of buffer
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
IcaStackTraceBuffer( IN PSDCONTEXT pContext,
                     IN ULONG TraceClass,
                     IN ULONG TraceEnable,
                     IN PVOID pBuffer,
                     IN ULONG ByteCount )
{
    PICA_TRACE_INFO pTraceInfo;
    PICA_STACK pStack;
    PICA_CONNECTION pConnect;

    /*
     * Use SD passed context to get the STACK object pointer.
     */
    pStack = (CONTAINING_RECORD( pContext, SDLINK, SdContext ))->pStack;
    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Write trace data
     */
    _WriteHexData( pTraceInfo, pBuffer, ByteCount );
}


/*******************************************************************************
 *
 *  IcaTraceFormat
 *
 *  This routine conditional writes trace data depending on the trace mask
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pData (input)
 *        pointer to null terminated trace data
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
IcaTraceFormat( IN PICA_TRACE_INFO pTraceInfo,
                IN ULONG TraceClass,
                IN ULONG TraceEnable,
                IN CHAR * pData )
{
    char Buffer[256];
    char * pBuf;
    int len = 0;
    int i;

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & pTraceInfo->TraceClass) || !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    pBuf = Buffer;

    /*
     *  Append time stamp
     */
    if ( pTraceInfo->fTraceTimestamp ) {
        len = _FormatTime( pBuf, sizeof(Buffer) );
        pBuf += len;
    }

    /*
     *  Append thread id
     */
    i = _FormatThreadId( pBuf, sizeof(Buffer) - len );
    len += i;
    pBuf += i;

    /*
     *  Append trace data
     */
    _snprintf( pBuf, sizeof(Buffer) - len, pData );

    /*
     *  Write trace data
     */
    _IcaTraceWrite( pTraceInfo, Buffer );
}


/*******************************************************************************
 *
 *  _IcaTrace
 *
 *  Write a trace record to the winstation trace file
 *
 *  ENTRY:
 *     pConnect (input)
 *        pointer to connection structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
_IcaTrace( IN PICA_CONNECTION pConnect,
           IN ULONG TraceClass,
           IN ULONG TraceEnable,
           IN CHAR * Format,
           IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pConnect->Header.Type == IcaType_Connection );

    va_start( arg_marker, Format );

    pTraceInfo = &pConnect->TraceInfo;

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & pTraceInfo->TraceClass) || !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  _IcaStackTrace
 *
 *  Write a trace record to the winstation trace file
 *
 *  ENTRY:
 *     pStack (input)
 *        pointer to stack structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
_IcaStackTrace( IN PICA_STACK pStack,
                IN ULONG TraceClass,
                IN ULONG TraceEnable,
                IN CHAR * Format,
                IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_CONNECTION pConnect;
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pStack->Header.Type == IcaType_Stack );

    va_start( arg_marker, Format );

    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  _IcaStackTraceBuffer
 *
 *  This routine conditional writes a data buffer to the trace file
 *
 *  ENTRY:
 *     pStack (input)
 *        pointer to stack structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     pBuffer (input)
 *        pointer to data buffer
 *     ByteCount (input)
 *        length of buffer
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaStackTraceBuffer( IN PICA_STACK pStack,
                      IN ULONG TraceClass,
                      IN ULONG TraceEnable,
                      IN PVOID pBuffer,
                      IN ULONG ByteCount )
{
    PICA_CONNECTION pConnect;
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pStack->Header.Type == IcaType_Stack );

    pConnect = IcaGetConnectionForStack( pStack );

    /*
     *  Check if this trace record should be output
     */
    pTraceInfo = &pConnect->TraceInfo;
    if ( !(TraceClass & pTraceInfo->TraceClass) ||
         !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Write trace data
     */
    _WriteHexData( pTraceInfo, pBuffer, ByteCount );
}


/*******************************************************************************
 *
 *  _IcaChannelTrace
 *
 *  Write a trace record to the winstation trace file
 *
 *  ENTRY:
 *     pChannel (input)
 *        pointer to Channel structure
 *     TraceClass (input)
 *        trace class bit mask
 *     TraceEnable (input)
 *        trace type bit mask
 *     Format (input)
 *        format string
 *     ...  (input)
 *        enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID _cdecl
_IcaChannelTrace( IN PICA_CHANNEL pChannel,
                  IN ULONG TraceClass,
                  IN ULONG TraceEnable,
                  IN CHAR * Format,
                  IN ... )
{
    va_list arg_marker;
    char Buffer[256];
    PICA_TRACE_INFO pTraceInfo;

    ASSERT( pChannel->Header.Type == IcaType_Channel );

    va_start( arg_marker, Format );

    pTraceInfo = &pChannel->pConnect->TraceInfo;

    /*
     *  Check if this trace record should be output
     */
    if ( !(TraceClass & pTraceInfo->TraceClass) || !(TraceEnable & pTraceInfo->TraceEnable) )
        return;

    /*
     *  Format trace data
     */
    _vsnprintf( Buffer, sizeof(Buffer), Format, arg_marker );

    /*
     *  Write trace data
     */
    IcaTraceFormat( pTraceInfo, TraceClass, TraceEnable, Buffer );
}


/*******************************************************************************
 *
 *  _IcaOpenTraceFile
 *
 *  Open a trace file
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     pTraceFile (input)
 *        pointer to trace file name
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

#define NAMEPREFIX L"\\DosDevices\\"

NTSTATUS
_IcaOpenTraceFile(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PWCHAR pTraceFile
    )
{
    UNICODE_STRING TraceString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK iosb;
    HANDLE TraceFileHandle;
    PFILE_OBJECT pTraceFileObject;
    ULONG PrefixLength;
    ULONG TraceFileLength;
    NTSTATUS Status;

    PrefixLength    = wcslen( NAMEPREFIX ) * sizeof(WCHAR);
    TraceFileLength = wcslen( pTraceFile ) * sizeof(WCHAR);

    TraceString.Length = (USHORT) (PrefixLength + TraceFileLength);
    TraceString.MaximumLength = TraceString.Length + sizeof(UNICODE_NULL);
    TraceString.Buffer = ICA_ALLOCATE_POOL( NonPagedPool, TraceString.MaximumLength );

    if (TraceString.Buffer != NULL) {
        RtlCopyMemory( TraceString.Buffer, NAMEPREFIX, PrefixLength );
        RtlCopyMemory( (char *)TraceString.Buffer + PrefixLength, pTraceFile, TraceFileLength );
        TraceString.Buffer[(PrefixLength + TraceFileLength) / sizeof(WCHAR)] = UNICODE_NULL;
    }
    else {
        return STATUS_NO_MEMORY;        
    }

    /*
     * If we already have a trace file and the name is the same
     * as a previous call, then there's nothing to be done.
     */
    if ( pTraceInfo->pTraceFileName != NULL &&
         !_wcsicmp( TraceString.Buffer, pTraceInfo->pTraceFileName ) ) {
        ICA_FREE_POOL( TraceString.Buffer );
        return( STATUS_SUCCESS );
    }

    /*
     * Close the existing trace file if there is one
     */
    if ( pTraceInfo->pTraceFileName ) {
        _IcaCloseTraceFile( pTraceInfo );
    }

    InitializeObjectAttributes( &ObjectAttributes, &TraceString,
                                OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = ZwCreateFile(
             &TraceFileHandle,
             GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
             &ObjectAttributes,
             &iosb,                          // returned status information.
             0,                              // block size (unused).
             0,                              // file attributes.
             FILE_SHARE_READ | FILE_SHARE_WRITE,
             FILE_OVERWRITE_IF,              // create disposition.
             0,                              // create options.
             NULL,
             0
             );
    if ( !NT_SUCCESS( Status ) ) {
        ICA_FREE_POOL( TraceString.Buffer );
        return( Status );
    }

    /*
     * Use the trace file handle to get a pointer to the file object.
     */
    Status = ObReferenceObjectByHandle(
                 TraceFileHandle,
                 0L,                         // DesiredAccess
                 *IoFileObjectType,
                 KernelMode,
                 (PVOID *)&pTraceFileObject,
                 NULL
                 );
    ZwClose( TraceFileHandle );
    if ( !NT_SUCCESS( Status ) ) {
        ICA_FREE_POOL( TraceString.Buffer );
        return( Status );
    }

    /*
     * Save Trace file name and file object pointer
     */
    pTraceInfo->pTraceFileName = TraceString.Buffer;
    pTraceInfo->pTraceFileObject = pTraceFileObject;

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _IcaCloseTraceFile
 *
 *  Close a trace file
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

VOID
_IcaCloseTraceFile(
    IN PICA_TRACE_INFO pTraceInfo
    )
{
    PWCHAR pTraceFileName;
    PFILE_OBJECT pTraceFileObject;

    /*
     * First write out any deferred trace records that exist
     */
    _IcaFlushDeferredTrace( pTraceInfo );

    /*
     * Get/reset trace info fields
     */
    pTraceFileName = pTraceInfo->pTraceFileName;
    pTraceFileObject = pTraceInfo->pTraceFileObject;
    pTraceInfo->pTraceFileName = NULL;
    pTraceInfo->pTraceFileObject = NULL;

    /*
     * Close trace file and free resources
     */
    ICA_FREE_POOL( pTraceFileName );
    ObDereferenceObject( pTraceFileObject );
}


/*******************************************************************************
 *
 *  _IcaTraceWrite
 *
 *  Write a trace file entry
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     Buffer (input)
 *        pointer to trace buffer to write
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaTraceWrite(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PVOID Buffer
    )
{
    KIRQL irql;
    ULONG Length;
    PDEFERRED_TRACE pDeferred;
    PDEFERRED_TRACE *ppDeferredTrace;
    NTSTATUS Status;

    /*
     * Write to kernel debugger if necessary
     */
    if ( pTraceInfo->fTraceDebugger )
        DbgPrint( "%s", Buffer );

    /*
     * If no file object pointer, then we're done
     */
    if ( pTraceInfo->pTraceFileObject == NULL )
        return;

    Length = strlen(Buffer);

    /*
     * If current Irql is DISPATCH_LEVEL or higher, then we can't
     * write the data now, so queue it for later writing.
     */
    irql = KeGetCurrentIrql();
    if ( irql >= DISPATCH_LEVEL ) {
        KIRQL oldIrql;

        /*
         * Allocate and initialize a deferred trace entry
         */
        pDeferred = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(*pDeferred) + Length );
        if ( pDeferred == NULL )
            return;
        pDeferred->Next = NULL;
        pDeferred->Length = Length;
        RtlCopyMemory( pDeferred->Buffer, Buffer, Length );

        /*
         *  Since the deferred list may be manipulated in
         *  _IcaFlushDeferredTrace on behalf of an IOCTL_SYSTEM_TRACE
         *  which does not hold any locks, IcaSpinLock is used to
         *  ensure the list's integrity.
         */
        IcaAcquireSpinLock( &IcaTraceSpinLock, &oldIrql );

        /*
         * Add it to the end of the list
         */
        ppDeferredTrace = &pTraceInfo->pDeferredTrace;
        while ( *ppDeferredTrace )
            ppDeferredTrace = &(*ppDeferredTrace)->Next;
        *ppDeferredTrace = pDeferred;

        IcaReleaseSpinLock( &IcaTraceSpinLock, oldIrql );
        return;
    }

    /*
     * Write out any deferred trace records that exist
     */
    _IcaFlushDeferredTrace( pTraceInfo );

    /*
     * Now write the current trace buffer
     */
    CtxWriteFile( pTraceInfo->pTraceFileObject, Buffer, Length, NULL, NULL, NULL );
}


/*******************************************************************************
 *
 *  _IcaFlushDeferredTrace
 *
 *  Write any deferred trace file entries
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaFlushDeferredTrace( PICA_TRACE_INFO pTraceInfo )
{
    KIRQL oldIrql;
    PDEFERRED_TRACE pDeferred;

    IcaAcquireSpinLock( &IcaTraceSpinLock, &oldIrql );
    while ( (pDeferred = pTraceInfo->pDeferredTrace) ) {
        pTraceInfo->pDeferredTrace = pDeferred->Next;
        IcaReleaseSpinLock( &IcaTraceSpinLock, oldIrql );

        CtxWriteFile( pTraceInfo->pTraceFileObject, pDeferred->Buffer,
                      pDeferred->Length, NULL, NULL, NULL );
        ICA_FREE_POOL( pDeferred );

        IcaAcquireSpinLock( &IcaTraceSpinLock, &oldIrql );
    }
    IcaReleaseSpinLock( &IcaTraceSpinLock, oldIrql );
}


/*******************************************************************************
 *
 *  _FormatTime
 *
 *  format current time into buffer
 *
 *  ENTRY:
 *     pBuffer (output)
 *        pointer to buffer
 *     Length (input)
 *        length of buffer
 *
 *  EXIT:
 *     length of formated time
 *
 ******************************************************************************/

int
_FormatTime( CHAR * pBuffer, ULONG Length )
{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    int len;

    /*
     *  Get local time
     */
    KeQuerySystemTime( &SystemTime );
    ExSystemTimeToLocalTime( &SystemTime, &LocalTime );
    RtlTimeToTimeFields( &LocalTime, &TimeFields );

    /*
     *  Format buffer
     */
    len = _snprintf( pBuffer,
                     Length,
                     "%02d:%02d:%02d.%03d ",
                     TimeFields.Hour,
                     TimeFields.Minute,
                     TimeFields.Second,
                     TimeFields.Milliseconds );

    return( len );
}


/*******************************************************************************
 *
 *  _FormatThreadId
 *
 *  format thread id into buffer
 *
 *  ENTRY:
 *     pBuffer (output)
 *        pointer to buffer
 *     Length (input)
 *        length of buffer
 *
 *  EXIT:
 *     length of formated time
 *
 ******************************************************************************/

#define TEB_CLIENTID_OFFSET 0x1e0

int
_FormatThreadId( CHAR * pBuffer, ULONG Length )
{
    PCLIENT_ID pClientId;
    char Number[40]; //on IA64, %p is 16 chars, we need two of these. So 32 + 2 bytes for "." and "\0". Use 40 just in case
    int len;

    /*
     *  Get pointer to clientid structure in teb
     *  - use hardcoded teb offset
     */
    pClientId = (PCLIENT_ID) ((char*)PsGetCurrentThread() + TEB_CLIENTID_OFFSET);

    /*
     *  Format buffer
     */
    _snprintf( Number, sizeof(Number), "%p.%p",
               pClientId->UniqueProcess, pClientId->UniqueThread );

    len = _snprintf( pBuffer, Length, "%-7s ", Number );

    return( len );
}


/*******************************************************************************
 *
 *  _WriteHexData
 *
 *  format and write hex data
 *
 *  ENTRY:
 *     pTraceInfo (input)
 *        pointer to ICA_TRACE_INFO struct
 *     pBuffer (output)
 *        pointer to buffer
 *     Length (input)
 *        length of buffer
 *
 *  EXIT:
 *     length of formated time
 *
 ******************************************************************************/

VOID
_WriteHexData(
    IN PICA_TRACE_INFO pTraceInfo,
    IN PVOID pBuffer,
    IN ULONG ByteCount
    )
{
    PUCHAR pData;
    ULONG i;
    ULONG j;
    char Buffer[256];

    /*
     *  Output data
     */
    pData = (PUCHAR) pBuffer;
    for ( i=0; i < ByteCount; i += 16 ) {
        ULONG c = 0;
        for ( j=0; j < 16 && (i+j) < ByteCount; j++ )
            c += _snprintf( &Buffer[c], sizeof(Buffer)-c, "%02X ", pData[j] );
        for ( ; j < 16; j++ ) {
            Buffer[c++] = ' ';
            Buffer[c++] = ' ';
            Buffer[c++] = ' ';
        }
        Buffer[c++] = ' ';
        Buffer[c++] = ' ';
        for ( j=0; j < 16 && (i+j) < ByteCount; j++, pData++ ) {
            if ( *pData < 0x20 || *pData > 0x7f )
                Buffer[c++] = '.';
            else
                Buffer[c++] = *pData;
        }
        Buffer[c++] = '\n';
        Buffer[c++] = '\0';
        _IcaTraceWrite( pTraceInfo, Buffer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\timer.c ===
/*************************************************************************
*
* timer.c
*
* This module contains the ICA timer routines.
*
* Copyright 1998, Microsoft.
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop
#include <ntddkbd.h>
#include <ntddmou.h>


/*
 * Local structures
 */
typedef VOID (*PICATIMERFUNC)( PVOID, PVOID );

typedef struct _ICA_WORK_ITEM {
    LIST_ENTRY Links;
    WORK_QUEUE_ITEM WorkItem;
    PICATIMERFUNC pFunc;
    PVOID pParam;
    PSDLINK pSdLink;
    ULONG LockFlags;
    ULONG fCanceled: 1;
} ICA_WORK_ITEM, *PICA_WORK_ITEM;

/*
 *  Timer structure
 */
typedef struct _ICA_TIMER {
    LONG RefCount;
    KTIMER kTimer;
    KDPC TimerDpc;
    PSDLINK pSdLink;
    LIST_ENTRY WorkItemListHead;
} ICA_TIMER, * PICA_TIMER;


/*
 * Local procedure prototypes
 */
VOID
_IcaTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
_IcaDelayedWorker(
    IN PVOID WorkerContext
    );

BOOLEAN
_IcaCancelTimer(
    PICA_TIMER pTimer,
    PICA_WORK_ITEM *ppWorkItem
    );

VOID
_IcaReferenceTimer(
    PICA_TIMER pTimer
    );

VOID
_IcaDereferenceTimer(
    PICA_TIMER pTimer
    );

NTSTATUS
IcaExceptionFilter(
    IN PWSTR OutputString,
    IN PEXCEPTION_POINTERS pexi
    );


/*******************************************************************************
 *
 *  IcaTimerCreate
 *
 *  Create a timer  
 *
 *
 *  ENTRY:
 *     pContext (input)
 *         Pointer to SDCONTEXT of caller
 *     phTimer (output)
 *         address to return timer handle
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaTimerCreate(
    IN PSDCONTEXT pContext,
    OUT PVOID * phTimer
    )
{
    PICA_TIMER pTimer;
    NTSTATUS Status;

    /*
     * Allocate timer object and initialize it
     */
    pTimer = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_TIMER) );
    if ( pTimer == NULL )
        return( STATUS_NO_MEMORY );
 
    RtlZeroMemory( pTimer, sizeof(ICA_TIMER) );
    pTimer->RefCount = 1;
    KeInitializeTimer( &pTimer->kTimer );
    KeInitializeDpc( &pTimer->TimerDpc, _IcaTimerDpc, pTimer );
    pTimer->pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );
    InitializeListHead( &pTimer->WorkItemListHead );

    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, "ICADD: TimerCreate: %08x\n", pTimer ));

    *phTimer = (PVOID) pTimer;
    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  IcaTimerStart
 *
 *  Start a timer  
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *     pFunc (input)
 *        address of procedure to call when timer expires
 *     pParam (input)
 *        parameter to pass to procedure
 *     TimeLeft (input)
 *        relative time until timer expires (1/1000 seconds)
 *     LockFlags (input)
 *        Bit flags to specify which (if any) stack locks to obtain
 *
 *  EXIT:
 *     TRUE  : timer was already armed and had to be canceled
 *     FALSE : timer was not armed
 *
 ******************************************************************************/

BOOLEAN
IcaTimerStart(
    IN PVOID TimerHandle,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG TimeLeft,
    IN ULONG LockFlags )
{
    PICA_TIMER pTimer = (PICA_TIMER)TimerHandle;
    KIRQL oldIrql;
    PICA_WORK_ITEM pWorkItem;
    LARGE_INTEGER DueTime;
    BOOLEAN bCanceled, bSet;
 
    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, 
                 "ICADD: TimerStart: %08x, Time %08x, pFunc %08x (%08x)\n", 
                 TimerHandle, TimeLeft, pFunc, pParam ));

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pTimer->pSdLink->pStack->Resource ) );

    /*
     * Cancel the timer if it currently armed,
     * and get the current workitem and reuse it if there was one.
     */
    bCanceled = _IcaCancelTimer( pTimer, &pWorkItem );

    /*
     * Initialize the ICA work item (allocate one first if there isn't one).
     */
    if ( pWorkItem == NULL ) {
        pWorkItem = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_WORK_ITEM) );
        if ( pWorkItem == NULL ) {
            return( FALSE );
        }
    }

    pWorkItem->pFunc = pFunc;
    pWorkItem->pParam = pParam;
    pWorkItem->pSdLink = pTimer->pSdLink;
    pWorkItem->LockFlags = LockFlags;
    pWorkItem->fCanceled = FALSE;
    ExInitializeWorkItem( &pWorkItem->WorkItem, _IcaDelayedWorker, pWorkItem );

    /*
     * If the timer was NOT canceled above (we are setting it for
     * the first time), then reference the SDLINK object on behalf
     * of the timer thread.
     */
    if ( !bCanceled )
        IcaReferenceSdLink( pTimer->pSdLink );

    /*
     * If timer should run immediately, then just queue the
     * workitem to an ExWorker thread now.
     */
    if ( TimeLeft == 0 ) {

        ExQueueWorkItem( &pWorkItem->WorkItem, CriticalWorkQueue );

    } else {
    
        /*
         * Convert timer time from milliseconds to system relative time
         */
        DueTime = RtlEnlargedIntegerMultiply( TimeLeft, -10000 );

        /*
         * Increment the timer reference count,
         * insert the workitem onto the workitem list,
         * and arm the timer.
         */
        _IcaReferenceTimer( pTimer );
        IcaAcquireSpinLock( &IcaSpinLock, &oldIrql );
        InsertTailList( &pTimer->WorkItemListHead, &pWorkItem->Links );
        IcaReleaseSpinLock( &IcaSpinLock, oldIrql );
        bSet = KeSetTimer( &pTimer->kTimer, DueTime, &pTimer->TimerDpc );
        ASSERT( !bSet );
    }

    return( bCanceled );
}


/*******************************************************************************
 *
 *  IcaTimerCancel
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 ******************************************************************************/

BOOLEAN
IcaTimerCancel( IN PVOID TimerHandle )
{
    PICA_TIMER pTimer = (PICA_TIMER)TimerHandle;
    BOOLEAN bCanceled;

    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, 
                 "ICADD: TimerCancel: %08x\n", pTimer ));

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pTimer->pSdLink->pStack->Resource ) );

    /*
     * Cancel timer if it is enabled
     */
    bCanceled = _IcaCancelTimer( pTimer, NULL );
    if ( bCanceled )
        IcaDereferenceSdLink( pTimer->pSdLink );

    return( bCanceled );
}


/*******************************************************************************
 *
 *  IcaTimerClose
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 ******************************************************************************/

BOOLEAN
IcaTimerClose( IN PVOID TimerHandle )
{
    PICA_TIMER pTimer = (PICA_TIMER)TimerHandle;
    BOOLEAN bCanceled;

    TRACESTACK(( pTimer->pSdLink->pStack, TC_ICADD, TT_API3, 
                 "ICADD: TimerClose: %08x\n", pTimer ));

    ASSERT( ExIsResourceAcquiredExclusiveLite( &pTimer->pSdLink->pStack->Resource ) );

    /*
     * Cancel timer if it is enabled
     */
    bCanceled = IcaTimerCancel( TimerHandle );

    /*
     * Decrement timer reference
     * (the last reference will free the object)
     */
    //ASSERT( pTimer->RefCount == 1 );
    //ASSERT( IsListEmpty( &pTimer->WorkItemListHead ) );
    _IcaDereferenceTimer( pTimer );
 
    return( bCanceled );
}


/*******************************************************************************
 *
 *  IcaQueueWorkItemEx, IcaQueueWorkItem.
 *
 *  Queue a work item for async execution
 *
 *  REM: IcaQueueWorkItemEx is the new API. It allows the caller to preallocate
 *  the ICA_WORK_ITEM. IcaQueueWorkItem is left there for lecacy drivers that have not 
 *  been compiled with the new library not to crash the system.
 *
 *  ENTRY:
 *     pContext (input)
 *         Pointer to SDCONTEXT of caller
 *     pFunc (input)
 *        address of procedure to call when timer expires
 *     pParam (input)
 *        parameter to pass to procedure
 *     LockFlags (input)
 *        Bit flags to specify which (if any) stack locks to obtain
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/



NTSTATUS
IcaQueueWorkItem(
    IN PSDCONTEXT pContext,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG LockFlags )
{
    PSDLINK pSdLink;
    PICA_WORK_ITEM pWorkItem;

    NTSTATUS Status;

    Status = IcaQueueWorkItemEx( pContext, pFunc, pParam, LockFlags, NULL );
    return Status;
}


NTSTATUS
IcaQueueWorkItemEx(
    IN PSDCONTEXT pContext,
    IN PVOID pFunc, 
    IN PVOID pParam, 
    IN ULONG LockFlags,
    IN PVOID pIcaWorkItem )
{
    PSDLINK pSdLink;
    PICA_WORK_ITEM pWorkItem = (PICA_WORK_ITEM) pIcaWorkItem;
 
    pSdLink = CONTAINING_RECORD( pContext, SDLINK, SdContext );

    /*
     * Allocate the ICA work item if not yet allocated and initialize it.
     */
    if (pWorkItem == NULL) {
        pWorkItem = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_WORK_ITEM) );
        if ( pWorkItem == NULL )
            return( STATUS_NO_MEMORY );
    }

    pWorkItem->pFunc = pFunc;
    pWorkItem->pParam = pParam;
    pWorkItem->pSdLink = pSdLink;
    pWorkItem->LockFlags = LockFlags;
    ExInitializeWorkItem( &pWorkItem->WorkItem, _IcaDelayedWorker, pWorkItem );

    /*
     * Reference the SDLINK object on behalf of the delayed worker routine.
     */
    IcaReferenceSdLink( pSdLink );

    /*
     * Queue work item to an ExWorker thread.
     */
    ExQueueWorkItem( &pWorkItem->WorkItem, CriticalWorkQueue );

    return( STATUS_SUCCESS );
}



/*******************************************************************************
 *
 *  IcaAllocateWorkItem.
 *
 *  Allocate ICA_WORK_ITEM structure to queue a workitem.
 *
 *  REM:  The main reason to allocate this in termdd (instead of doing it
 *  in the caller is to keep ICA_WORK_ITEM an internal termdd structure that is
 *  opaque for protocol drivers. There is no need for an IcaFreeWorkItem() API in
 *  termdd since the deallocation is transparently done in termdd once the workitem
 *  has been delivered.
 *
 *  ENTRY:
 *     pParam (output) : pointer to return allocated workitem
 *
 *  EXIT:
 *     STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
IcaAllocateWorkItem(
    OUT PVOID *pParam )
{
    PICA_WORK_ITEM pWorkItem;

    *pParam = ICA_ALLOCATE_POOL( NonPagedPool, sizeof(ICA_WORK_ITEM) );
    if ( *pParam == NULL ){
        return( STATUS_NO_MEMORY );
    }
    return STATUS_SUCCESS;
}

/*******************************************************************************
 *
 *  _IcaTimerDpc
 *
 *  Ica timer DPC routine.
 *
 *
 *  ENTRY:
 *     Dpc (input)
 *        Unused
 * 
 *     DeferredContext (input)
 *        Pointer to ICA_TIMER object.
 * 
 *     SystemArgument1 (input)
 *        Unused
 * 
 *     SystemArgument2 (input)
 *        Unused
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PICA_TIMER pTimer = (PICA_TIMER)DeferredContext;
    KIRQL oldIrql;
    PLIST_ENTRY Head;
    PICA_WORK_ITEM pWorkItem;

    /*
     * Acquire spinlock and remove the first workitem from the list
     */
    IcaAcquireSpinLock( &IcaSpinLock, &oldIrql );

    Head = RemoveHeadList( &pTimer->WorkItemListHead );
    pWorkItem = CONTAINING_RECORD( Head, ICA_WORK_ITEM, Links );

    IcaReleaseSpinLock( &IcaSpinLock, oldIrql );

    /*
     * If workitem has been canceled, just free the memory now.
     */
    if ( pWorkItem->fCanceled ) {

        ICA_FREE_POOL( pWorkItem );

    /*
     * Otherwise, queue workitem to an ExWorker thread.
     */
    } else {

        ExQueueWorkItem( &pWorkItem->WorkItem, CriticalWorkQueue );
    }

    _IcaDereferenceTimer( pTimer );
}


/*******************************************************************************
 *
 *  _IcaDelayedWorker
 *
 *  Ica delayed worker routine.
 *
 *
 *  ENTRY:
 *     WorkerContext (input)
 *        Pointer to ICA_WORK_ITEM object.
 * 
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID
_IcaDelayedWorker(
    IN PVOID WorkerContext
    )
{
    PICA_CONNECTION pConnect;
    PICA_WORK_ITEM pWorkItem = (PICA_WORK_ITEM)WorkerContext;
    PICA_STACK pStack = pWorkItem->pSdLink->pStack;
    NTSTATUS Status;

    /*
     * Obtain any required locks before calling the worker routine.
     */
    if ( pWorkItem->LockFlags & ICALOCK_IO ) {
        pConnect = IcaLockConnectionForStack( pStack );
    }
    if ( pWorkItem->LockFlags & ICALOCK_DRIVER ) {
        IcaLockStack( pStack );
    }

    /*
     * Call the worker routine.
     */
    try {
        (*pWorkItem->pFunc)( pWorkItem->pSdLink->SdContext.pContext,
                             pWorkItem->pParam );
    } except( IcaExceptionFilter( L"_IcaDelayedWorker TRAPPED!!",
                                  GetExceptionInformation() ) ) {
        Status = GetExceptionCode();
    }

    /*
     * Release any locks acquired above.
     */
    if ( pWorkItem->LockFlags & ICALOCK_DRIVER ) {
        IcaUnlockStack( pStack );
    }
    if ( pWorkItem->LockFlags & ICALOCK_IO ) {
        IcaUnlockConnection( pConnect );
    }

    /*
     * Dereference the SDLINK object now.
     * This undoes the reference that was made on our behalf in the
     * IcaTimerStart or IcaQueueWorkItem routine.
     */
    IcaDereferenceSdLink( pWorkItem->pSdLink );

    /*
     * Free the ICA_WORK_ITEM memory block.
     */
    ICA_FREE_POOL( pWorkItem );
}


BOOLEAN
_IcaCancelTimer(
    PICA_TIMER pTimer,
    PICA_WORK_ITEM *ppWorkItem
    )
{
    KIRQL oldIrql;
    PLIST_ENTRY Tail;
    PICA_WORK_ITEM pWorkItem;
    BOOLEAN bCanceled;

    /*
     * Get IcaSpinLock to in order to cancel any previous timer
     */
    IcaAcquireSpinLock( &IcaSpinLock, &oldIrql );

    /*
     * See if the timer is currently armed.
     * The timer is armed if the workitem list is non-empty and
     * the tail entry is not marked canceled.
     */
    if ( !IsListEmpty( &pTimer->WorkItemListHead ) &&
         (Tail = pTimer->WorkItemListHead.Blink) &&
         (pWorkItem = CONTAINING_RECORD( Tail, ICA_WORK_ITEM, Links )) &&
         !pWorkItem->fCanceled ) {

        /*
         * If the timer can be canceled, remove the workitem from the list
         * and decrement the reference count for the timer.
         */
        if ( KeCancelTimer( &pTimer->kTimer ) ) {
            RemoveEntryList( &pWorkItem->Links );
            pTimer->RefCount--;
            ASSERT( pTimer->RefCount > 0 );


        /*
         * The timer was armed but could not be canceled.
         * On a MP system, its possible for this to happen and the timer
         * DPC can be executing on another CPU in parallel with this code.
         *
         * Mark the workitem as canceled,
         * but leave it for the timer DPC routine to cleanup.
         */
        } else {
            pWorkItem->fCanceled = TRUE;
            pWorkItem = NULL;
        }

        /*
         * Indicate we (effectively) canceled the timer
         */
        bCanceled = TRUE;

    /*
     * No timer is armed
     */
    } else {
        pWorkItem = NULL;
        bCanceled = FALSE;
    }

    /*
     * Release IcaSpinLock now
     */
    IcaReleaseSpinLock( &IcaSpinLock, oldIrql );

    if ( ppWorkItem ) {
        *ppWorkItem = pWorkItem;
    } else if ( pWorkItem ) {
        ICA_FREE_POOL( pWorkItem );
    }

    return( bCanceled );
}


VOID
_IcaReferenceTimer(
    PICA_TIMER pTimer
    )
{

    ASSERT( pTimer->RefCount >= 0 );

    /*
     * Increment the reference count
     */
    if ( InterlockedIncrement( &pTimer->RefCount) <= 0 ) {
        ASSERT( FALSE );
    }
}


VOID
_IcaDereferenceTimer(
    PICA_TIMER pTimer
    )
{

    ASSERT( pTimer->RefCount > 0 );

    /*
     * Decrement the reference count
     * If it is 0 then free the timer now.
     */
    if ( InterlockedDecrement( &pTimer->RefCount) == 0 ) {
        ASSERT( IsListEmpty( &pTimer->WorkItemListHead ) );
        ICA_FREE_POOL( pTimer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\wmi.c ===
/*++

Copyright (c) 1990-1999 Microsoft Corporation, All Rights Reserved

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles the wmi IRPs for the
    RDP remote port driver.

Environment:

    Kernel mode

Revision History :

    02/12/99 - Initial Revision based on pnpi8042 driver


--*/

#include <precomp.h>
#pragma hdrstop

#include <wmistr.h>

#include "ptdrvcom.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PtInitWmi)
#pragma alloc_text(PAGE, PtSystemControl)
#pragma alloc_text(PAGE, PtSetWmiDataItem)
#pragma alloc_text(PAGE, PtSetWmiDataBlock)
#pragma alloc_text(PAGE, PtKeyboardQueryWmiDataBlock)
#pragma alloc_text(PAGE, PtMouseQueryWmiDataBlock)
#pragma alloc_text(PAGE, PtQueryWmiRegInfo)
#endif

#define WMI_KEYBOARD_PORT_INFORMATION 0
#define WMI_MOUSE_PORT_INFORMATION    0

GUID KbKeyboardPortGuid = KEYBOARD_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO KbWmiGuidList[1] =
{
    { &KbKeyboardPortGuid, 1, 0 }  // Keyboard Port driver information
};

GUID MouPointerPortGuid = POINTER_PORT_WMI_STD_DATA_GUID;

WMIGUIDREGINFO MouWmiGuidList[1] =
{
    { &MouPointerPortGuid,  1, 0 }  // Pointer Port driver information
};

NTSTATUS
PtInitWmi(
    PCOMMON_DATA CommonData
    )
/*++

Routine Description:

    Initializes the WmiLibInfo data structure for the device represented by
    CommonData

Arguments:

    CommonData - the device

Return Value:

    status from IoWMIRegistrationControl

--*/
{
    PAGED_CODE();

    if (CommonData->IsKeyboard) {
        CommonData->WmiLibInfo.GuidCount = sizeof(KbWmiGuidList) /
                                           sizeof(WMIGUIDREGINFO);
        CommonData->WmiLibInfo.GuidList = KbWmiGuidList;
        CommonData->WmiLibInfo.QueryWmiDataBlock = PtKeyboardQueryWmiDataBlock;
    }
    else {
        CommonData->WmiLibInfo.GuidCount = sizeof(MouWmiGuidList) /
                                           sizeof(WMIGUIDREGINFO);
        CommonData->WmiLibInfo.GuidList = MouWmiGuidList;
        CommonData->WmiLibInfo.QueryWmiDataBlock = PtMouseQueryWmiDataBlock;
    }

    CommonData->WmiLibInfo.QueryWmiRegInfo = PtQueryWmiRegInfo;
    CommonData->WmiLibInfo.SetWmiDataBlock = PtSetWmiDataBlock;
    CommonData->WmiLibInfo.SetWmiDataItem = PtSetWmiDataItem;
    CommonData->WmiLibInfo.ExecuteWmiMethod = NULL;
    CommonData->WmiLibInfo.WmiFunctionControl = NULL;

    return IoWMIRegistrationControl(CommonData->Self,
                                    WMIREG_ACTION_REGISTER
                                    );
}

NTSTATUS
PtSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PCOMMON_DATA           commonData;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS               status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    status = WmiSystemControl(&commonData->WmiLibInfo,
                              DeviceObject,
                              Irp,
                              &disposition
                              );
    switch(disposition) {
    case IrpProcessed:
        //
        // This irp has been processed and may be completed or pending.
        //
        break;

    case IrpNotCompleted:
        //
        // This irp has not been completed, but has been fully processed.
        // we will complete it now
        //
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        break;

    case IrpForward:
    case IrpNotWmi:
        //
        // This irp is either not a WMI irp or is a WMI irp targetted
        // at a device lower in the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);
        break;

    default:
        //
        // We really should never get here, but if we do just forward....
        //
        ASSERT(FALSE);
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(commonData->TopOfStack, Irp);
        break;
    }

    return status;
}

//
// WMI System Call back functions
//
NTSTATUS
PtSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PCOMMON_DATA    commonData;
    NTSTATUS        status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    switch(GuidIndex) {

    case WMI_KEYBOARD_PORT_INFORMATION:
    // case WMI_MOUSE_PORT_INFORMATION:  // they are the same index
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              0,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PCOMMON_DATA    commonData;
    NTSTATUS        status;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_KEYBOARD_PORT_INFORMATION:
    // case WMI_MOUSE_PORT_INFORMATION:     // they are the same index
        status = STATUS_WMI_READ_ONLY;
        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              0,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtKeyboardQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS                    status;
    ULONG                       size = sizeof(KEYBOARD_PORT_WMI_STD_DATA);
    KEYBOARD_PORT_WMI_STD_DATA  kbData;

    PAGED_CODE();

    ASSERT(InstanceIndex == 0 && InstanceCount == 1);

    switch (GuidIndex) {
    case WMI_KEYBOARD_PORT_INFORMATION:

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&kbData,
                      size
                      );

        kbData.ConnectorType = KEYBOARD_PORT_WMI_STD_I8042;
        kbData.DataQueueSize = 1;
        kbData.ErrorCount    = 0;
        kbData.FunctionKeys  = KEYBOARD_NUM_FUNCTION_KEYS;
        kbData.Indicators    = KEYBOARD_NUM_INDICATORS;

        *(PKEYBOARD_PORT_WMI_STD_DATA) Buffer = kbData;

        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              size,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtMouseQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS                    status;
    ULONG                       size = sizeof(POINTER_PORT_WMI_STD_DATA);
    POINTER_PORT_WMI_STD_DATA   mouData;

    PAGED_CODE();

    //
    // Only ever registers 1 instance per guid
    //
    ASSERT(InstanceIndex == 0 && InstanceCount == 1);

    switch (GuidIndex) {
    case WMI_MOUSE_PORT_INFORMATION:

        if (OutBufferSize < size) {
            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        RtlZeroMemory(&mouData,
                      size
                      );

        mouData.ConnectorType = POINTER_PORT_WMI_STD_I8042;
        mouData.DataQueueSize = 0;

        //
        // We always claim to be a 3 button (wheel) mouse
        //
        mouData.Buttons = MOUSE_NUM_BUTTONS;
        mouData.ErrorCount = 0;
        mouData.HardwareType = POINTER_PORT_WMI_STD_MOUSE;

        *(PPOINTER_PORT_WMI_STD_DATA) Buffer = mouData;

        *InstanceLengthArray = size;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    return WmiCompleteRequest(DeviceObject,
                              Irp,
                              status,
                              size,
                              IO_NO_INCREMENT
                              );
}

NTSTATUS
PtQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    PCOMMON_DATA commonData;

    PAGED_CODE();

    commonData = (PCOMMON_DATA) DeviceObject->DeviceExtension;

    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.RegistryPath;
    *Pdo = commonData->PDO;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\httpproxy\isapi\stdafx.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Terminal Server ISAPI Proxy

Abstract:

    This is the ISAPI side of the terminal server proxy.  This opens a connection to the
    proxied server and then forwards data back and forth through IIS.  There is also
    a filter component which takes care of having more user friendly urls.

Author:

    Marc Reyhner 8/22/2000

--*/

#include "stdafx.h"

// nothing here...
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\drivers\termdd\virtual.c ===
/*************************************************************************
*
* virtual.c
*
* This module contains routines for managing ICA virtual channels.
*
* Copyright 1998, Microsoft.
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <precomp.h>
#pragma hdrstop

NTSTATUS
_IcaCallStack(
    IN PICA_STACK pStack,
    IN ULONG ProcIndex,
    IN OUT PVOID pParms
    );

NTSTATUS
IcaFlushChannel (
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
IcaDeviceControlVirtual(
    IN PICA_CHANNEL pChannel,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the device control routine for the ICA Virtual channel.

Arguments:

    pChannel -- pointer to ICA_CHANNEL object

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    SD_IOCTL SdIoctl;
    NTSTATUS Status;
    PICA_STACK pStack;

    /*
     * Extract the IOCTL control code and process the request.
     */
    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlVirtual, fc %d, ref %u (enter)\n", 
                   (code & 0x3fff) >> 2, pChannel->RefCount ));

    /*
     *  Process ioctl request
     */
    switch ( code ) {

        case IOCTL_ICA_VIRTUAL_LOAD_FILTER :
        case IOCTL_ICA_VIRTUAL_UNLOAD_FILTER :
        case IOCTL_ICA_VIRTUAL_ENABLE_FILTER :
        case IOCTL_ICA_VIRTUAL_DISABLE_FILTER :
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;


        case IOCTL_ICA_VIRTUAL_BOUND :
            Status = (pChannel->VirtualClass == UNBOUND_CHANNEL) ?
                       STATUS_INVALID_DEVICE_REQUEST : STATUS_SUCCESS;
            break;


        case IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA : 
            IcaLockConnection( pChannel->pConnect );
            if ( IsListEmpty( &pChannel->pConnect->StackHead ) ) {
                IcaUnlockConnection( pChannel->pConnect );
                return( STATUS_INVALID_DEVICE_REQUEST );
            }
            pStack = CONTAINING_RECORD( pChannel->pConnect->StackHead.Flink,
                                        ICA_STACK, StackEntry );

            if( (pStack->StackClass != Stack_Console) && 
                (pStack->StackClass != Stack_Primary) ) {
                IcaUnlockConnection( pChannel->pConnect );
                return( STATUS_INVALID_DEVICE_REQUEST );
            }

            IcaReferenceStack( pStack );
            IcaUnlockConnection( pChannel->pConnect );

            if ( pChannel->VirtualClass == UNBOUND_CHANNEL ) {
                IcaDereferenceStack( pStack );
                TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, channel not bound\n" ));
                return( STATUS_INVALID_DEVICE_REQUEST );
            }

            TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA begin\n" ));
            TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, pStack 0x%x\n", pStack ));

            SdIoctl.IoControlCode = code;
            SdIoctl.InputBuffer = &pChannel->VirtualClass;
            SdIoctl.InputBufferLength = sizeof(pChannel->VirtualClass);
            SdIoctl.OutputBuffer = Irp->UserBuffer;
            SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            Status = _IcaCallStack( pStack, SD$IOCTL, &SdIoctl );
            Irp->IoStatus.Information = SdIoctl.BytesReturned;

            TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, Status 0x%x\n", Status ));
            TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA end\n" ));

            IcaDereferenceStack( pStack );
            break;

        case IOCTL_ICA_VIRTUAL_CANCEL_INPUT :

            Status = IcaFlushChannel( pChannel, Irp, IrpSp );
            if ( !NT_SUCCESS(Status) )
                break;

            /* fall through */

        default :

            /*
             *  Make sure virtual channel is bound to a virtual channel number
             */
            if ( pChannel->VirtualClass == UNBOUND_CHANNEL ) {
                TRACECHANNEL(( pChannel, TC_ICADD, TT_ERROR, "ICADD: IcaDeviceControlVirtual, channel not bound\n" ));
                return( STATUS_INVALID_DEVICE_REQUEST );
            }

            /*
             *  Save virtual class in first 4 bytes of the input buffer 
             *  - this is used by the wd
             */
            if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(VIRTUALCHANNELCLASS) ) {
                SdIoctl.InputBuffer = &pChannel->VirtualClass;
                SdIoctl.InputBufferLength = sizeof(pChannel->VirtualClass);
            } else {
                SdIoctl.InputBuffer = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                SdIoctl.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                RtlCopyMemory( SdIoctl.InputBuffer, &pChannel->VirtualClass, sizeof(pChannel->VirtualClass) );
            }

            /*
             *  Send request to WD
             */
            SdIoctl.IoControlCode = code;
            SdIoctl.OutputBuffer = Irp->UserBuffer;
            SdIoctl.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            Status = IcaCallDriver( pChannel, SD$IOCTL, &SdIoctl );
            Irp->IoStatus.Information = SdIoctl.BytesReturned;
            break;
    }

    TRACECHANNEL(( pChannel, TC_ICADD, TT_API1, "ICADD: IcaDeviceControlVirtual, fc %d, ref %u, 0x%x\n", 
                   (code & 0x3fff) >> 2, pChannel->RefCount, Status ));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\httpproxy\isapi\stdafx.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Terminal Server ISAPI Proxy

Abstract:

    This is the ISAPI side of the terminal server proxy.  This opens a connection to the
    proxied server and then forwards data back and forth through IIS.  There is also
    a filter component which takes care of having more user friendly urls.

Author:

    Marc Reyhner 8/22/2000

--*/

#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <Winsock2.h>
#include <windows.h>
#include <httpext.h>
#include <httpfilt.h>
#include <tchar.h>


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\httpproxy\isapi\tsproxyacl.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Terminal Server ACL module

Abstract:

    This module implements ACL checking for the ISAPI extension.

Author:

    Marc Reyhner 9/7/2000

--*/

#include "stdafx.h"
#include <atlbase.h>
#include <atlconv.h>
#include "tsproxyacl.h"
#include "tsproxy.h"

#define USER_ACL_KEY        TS_PROXY_REG_KEY _T("\\User Permissions")
#define DENY_LIST           _T("Server Deny List")
#define ALLOW_LIST          _T("Server Allow List")
#define DENY_BY_DEFAULT     _T("Deny By Default")

// our local helper function

static BOOL ServerOnDenyList(LPSTR server);
static BOOL ServerOnAllowList(LPSTR server);
static BOOL CheckUserPermissions(LPSTR server, LPSTR user);
static DWORD GetRegDword(LPTSTR key, LPTSTR value, DWORD dwDefault);
static LPTSTR GetRegMultiString(LPTSTR key, LPTSTR value);
static LPVOID GetAndAllocateRegValue(LPTSTR key, LPTSTR value, DWORD type);

BOOL
VerifyServerAccess(
    IN LPEXTENSION_CONTROL_BLOCK lpECB,
    IN LPSTR server,
    IN LPSTR user
    )

/*++

Routine Description:

    This checks to see if the user is allowed access to the
    given server

Arguments:

    lpECB - extension control block

    server - Server access is requested to

    user - User requesting access

Return Value:

    TRUE - Access is allowed

    FALSE - Access is denied

--*/
{
    if (0 == GetRegDword(TS_PROXY_REG_KEY,DENY_BY_DEFAULT,0)) {
        if (ServerOnDenyList(server)) {
            return FALSE;
        }

        // allow by default so return TRUE since they aren't on
        // the deny list

        return TRUE;
    }

    if (ServerOnDenyList(server)) {
        return FALSE;
    }

    if (ServerOnAllowList(server)) {
        return TRUE;
    }

    return CheckUserPermissions(server,user);
}


BOOL ServerOnDenyList(LPSTR server)
{
    USES_CONVERSION;
    LPTSTR serverList;
    LPTSTR currentServer;
    UINT serverLength;

    serverList = GetRegMultiString(TS_PROXY_REG_KEY,DENY_LIST);
    if (!serverList) {
        return FALSE;
    }

    currentServer = serverList;
    while (serverLength = _tcslen(currentServer)) {
        if (_tcsicmp(A2T(server),currentServer)==0) {
            HeapFree(GetProcessHeap(),0,serverList);
            return TRUE;
        }
        currentServer += (serverLength+1);
    }

    HeapFree(GetProcessHeap(),0,serverList);
    return FALSE;
}

BOOL ServerOnAllowList(LPSTR server)
{

    USES_CONVERSION;
    LPTSTR serverList;
    LPTSTR currentServer;
    UINT serverLength;

    serverList = GetRegMultiString(TS_PROXY_REG_KEY,ALLOW_LIST);
    if (!serverList) {
        return FALSE;
    }
    currentServer = serverList;
    while (serverLength = _tcslen(currentServer)) {
        if (_tcsicmp(A2T(server),currentServer)==0) {
            HeapFree(GetProcessHeap(),0,serverList);
            return TRUE;
        }
        currentServer += (serverLength+1);
    }

    HeapFree(GetProcessHeap(),0,serverList);
    return FALSE;
}

BOOL CheckUserPermissions(LPSTR server, LPSTR user)
{
    
    USES_CONVERSION;
    LPTSTR serverList;
    LPTSTR currentServer;
    UINT serverLength;

    serverList = GetRegMultiString(USER_ACL_KEY,A2T(user));
    if (!serverList) {
        return FALSE;
    }
    currentServer = serverList;
    while (serverLength = _tcslen(currentServer)) {
        if (_tcsicmp(A2T(server),currentServer)==0) {
            HeapFree(GetProcessHeap(),0,serverList);
            return TRUE;
        }
        currentServer += (serverLength+1);
    }

    HeapFree(GetProcessHeap(),0,serverList);
    return FALSE;
}

DWORD GetRegDword(LPTSTR key, LPTSTR value, DWORD dwDefault)
{
    DWORD dwResult;
    LPDWORD lpdwRegValue;

    lpdwRegValue = (LPDWORD)GetAndAllocateRegValue(key,value,REG_DWORD);
    if (lpdwRegValue) {
        dwResult = *lpdwRegValue;
        HeapFree(GetProcessHeap(),0,lpdwRegValue);
    } else {
        dwResult = dwDefault;
    }
    return dwResult;
}

LPTSTR GetRegMultiString(LPTSTR key, LPTSTR value)
{
    return (LPTSTR)GetAndAllocateRegValue(key,value,REG_MULTI_SZ);
}

LPVOID GetAndAllocateRegValue(LPTSTR key, LPTSTR value, DWORD type)
{
    LONG retCode;
    HKEY hRegKey;
    LPBYTE lpValueData;
    DWORD dwValueSize;
    DWORD dwType;
    BOOL failure;

    hRegKey = NULL;
    failure = FALSE;
    lpValueData = NULL;

    retCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,key,0,KEY_QUERY_VALUE,&hRegKey);
    if (ERROR_SUCCESS != retCode) {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    retCode = RegQueryValueEx(hRegKey,value,NULL,&dwType,NULL,&dwValueSize);
    if (retCode != ERROR_SUCCESS) {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    // Make sure the data is the type they requested
    if (dwType != type) {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    lpValueData = (LPBYTE)HeapAlloc(GetProcessHeap(),0,dwValueSize);
    if (!lpValueData) {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    retCode = RegQueryValueEx(hRegKey,value,NULL,&dwType,lpValueData,
        &dwValueSize);
    if (retCode != ERROR_SUCCESS) {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

CLEANUP_AND_EXIT:
    if (failure) {
        if (lpValueData) {
            HeapFree(GetProcessHeap(),0,lpValueData);
            lpValueData = NULL;
        }
    }
    
    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return lpValueData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\httpproxy\isapi\tsproxy.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Terminal Server ISAPI Proxy

Abstract:

    This is the ISAPI side of the terminal server proxy.  This opens a connection to the
    proxied server and then forwards data back and forth through IIS.  There is also
    a filter component which takes care of having more user friendly urls.

Author:

    Marc Reyhner 8/22/2000

--*/

#include "stdafx.h"
#include <atlbase.h>
#include <atlconv.h>
#include "tsproxy.h"
#include "tsproxyacl.h"


//
//  Disable tracing for free builds.
//
#if DBG
#ifndef TRC_CL
#define TRC_CL TRC_LEVEL_DBG
#endif
#define TRC_ENABLE_PRF
#else
#ifndef TRC_CL
#define TRC_CL TRC_LEVEL_DIS
#endif
#undef TRC_ENABLE_PRF
#endif

//
//  Required for DCL Tracing
//
#define TRC_FILE  "tsproxy"

#ifndef OS_WIN32
#define OS_WIN32
#endif
#define TRC_GROUP TRC_GROUP_NETWORK
#define DEBUG_MODULE DBG_MOD_ANY
#include <adcgbase.h>
#include <at120ex.h>
#include <atrcapi.h>
#include <adcgbase.h>
#include <at120ex.h>


HINSTANCE g_hInstance;

//macros for goto end
#define CFRg(x) { if(!x) goto END; }


// The name the DLL returns to IIS.
#define ISAPI_DLL_NAME              "Microsoft Terminal Server Proxy"

// The amount of data we read or send at once.  This is set to the
// maximum amount before a SSL encrypt/decrypt needs to be chunked
#define TS_PROXY_READ_SIZE     16379
#define TS_MAX_READ_SIZE            200

// Various HTTP defines
#define HTTP_STATUS_OK              "200 OK"
#define HTTP_STATUS_ERR             "502 Terminal Server Proxy Connect Failure"
#define HTTP_METHOD_HEAD            "HEAD"
#define HTTP_CONTENTLENGTH_ZERO     "Content-Length: 0\r\n"
#define HTTP_USER_AGENT             "HTTP_USER_AGENT:"
#define TS_USER_AGENT_PREFIX        "Microsoft Terminal Server Proxy"
#define HTTP_URL_PREFIX             "http://"
#define HTTPS_URL_PREFIX            "https://"



//  Settings that can be changed in the registry
//  _NAME is the name of the value in the registry
//  _DFLT is the default value.

#define TS_PROXY_REMAP_PREFIX_NAME      "Url Remap Prefix"
#define TS_PROXY_REMAP_PREFIX_DFLT      "/ts"

#define TS_PROXY_REMAP_DEST_URL_NAME    "Url Remap Destination"
#define TS_PROXY_REMAP_DEST_URL_DFLT    "/tsproxy/connect.asp"

// not configurable but placed here since it belongs with the previous setting.
#define TS_PROXY_REMAP_DEST_URL_SUFFIX "%s?Server=%s&ProxyServer=%s"

#define TS_PROXY_INC_AGENT_DEST_NAME    "Invalid User Agent Redirect"
#define TS_PROXY_INC_AGENT_DEST_DFLT    "/browser.htm"

#define TS_PROXY_CONNECT_PORT_NAME  "Terminal Server Port"
#define TS_PROXY_CONNECT_PORT_DFLT  0xD3D

#define TS_PROXY_WSSNDBUFSIZE 4096
#define TS_PROXY_WSRCVBUFSIZE 8192



// Various Structures

typedef struct _READCALLBACKCONTEXT 
{
    HANDLE serverListenThread;
    SOCKET s;
	  DWORD  cbReadSoFar;        // Number of bytes read so far, used as index for readBuffer
    CHAR readBuffer[ TS_MAX_READ_SIZE ];
    LPEXTENSION_CONTROL_BLOCK lpECB;
} READCALLBACKCONTEXT, FAR *LPREADCALLBACKCONTEXT;

typedef struct _SERVERLISTENTCONTEXT 
{
    BOOL bTerminate;
    SOCKET s;
    LPEXTENSION_CONTROL_BLOCK lpECB;
} SERVERLISTENTCONTEXT, FAR *LPSERVERLISTENTCONTEXT;

// Static internal functions

static BOOL VerifyTsacUserAgent(LPEXTENSION_CONTROL_BLOCK lpECB);

static DWORD RedirectToBrowserPage(LPEXTENSION_CONTROL_BLOCK lpECB);

static LPSTR GetAndAllocateExtensionServerVariable(LPEXTENSION_CONTROL_BLOCK lpECB,
                                                   LPSTR lpstrVariable);
static LPSTR GetAndAllocateFilterServerVariable(PHTTP_FILTER_CONTEXT pfc,
                                                LPSTR lpstrVariable);
static LPSTR GetAndAllocateFilterHeader(PHTTP_FILTER_CONTEXT pfc,
                                        PHTTP_FILTER_PREPROC_HEADERS pPreproc,
                                        LPSTR lpstrVariable);
static DWORD StartTsProxy(LPEXTENSION_CONTROL_BLOCK lpECB);

static DWORD WINAPI ServerListenThread(LPVOID lpParameter);

VOID WINAPI ProxyReadCallback(LPEXTENSION_CONTROL_BLOCK lpECB,
    PVOID pContext,DWORD cbIO,DWORD dwError); 

static DWORD GetRegValueAsDword(LPCSTR regValue, DWORD dwDefaultValue);

static DWORD ReadFromClient(LPVOID lpParameter );

static LPSTR GetRegValueAsAnsiString(LPCSTR regValue, LPSTR defaultValue);

static LPVOID QueryRegistryData(LPCSTR regValue, DWORD typeRequested);


BOOL APIENTRY
DllMain(
    IN HINSTANCE hModule, 
    IN DWORD  ul_reason_for_call, 
    IN LPVOID lpReserved
	)

/*++

Routine Description:

    With DllMain we start winsock on process attach and stop it when
    we are detached from the process.

Arguments:

    hModule - Instance for this dll

    ul_reason_for_call - Why we were called.

    lpReserved - Reserved parameter. Should be Null?

Return Value:

    TRUE - Loading the dll was successfull

    FALSE - There was an error loading the dll.

--*/
{
    WORD wSockVersion;
    INT result;
    WSADATA wsaData;
    BOOL retValue;

  	DC_BEGIN_FN("DllMain");
    retValue = TRUE;
    switch (ul_reason_for_call)
	  {
		case DLL_PROCESS_ATTACH:
            g_hInstance = hModule;
            wSockVersion = MAKEWORD(2,0);
            result = WSAStartup(wSockVersion,&wsaData);
            if (result) 
            {
                retValue = FALSE;
            }
            break;
		
    case DLL_PROCESS_DETACH:
            WSACleanup();
		        break;
    }
	  
    DC_END_FN();
    return retValue;
}

BOOL WINAPI
GetFilterVersion(
    IN PHTTP_FILTER_VERSION pVer  
    )

/*++

Routine Description:

    Here we registers ourselves to get preproc header notifications and set
    the version of IIS we were compiled against.

Arguments:

    pVer - Filter version struct we need to fill in.

Return Value:

    TRUE - We don't have any way to cause an error so we always return true.

--*/
{
	  DC_BEGIN_FN("GetFilterVersion");
    
    pVer->dwFlags = ( SF_NOTIFY_PREPROC_HEADERS|SF_NOTIFY_ORDER_DEFAULT);
    
    pVer->dwFilterVersion = HTTP_FILTER_REVISION;
    
    strncpy( pVer->lpszFilterDesc,ISAPI_DLL_NAME,SF_MAX_FILTER_DESC_LEN-1);

	  DC_END_FN();
    return TRUE;
}

DWORD WINAPI
HttpFilterProc(
    IN PHTTP_FILTER_CONTEXT pfc,  
    IN DWORD notificationType,  
    IN LPVOID pvNotification  
    )

/*++

Routine Description:

    If the client requests a url that begins with our url base.  We remap
    it to the page which hosts the tsac control and fill in the server and
    proxy server settings.  For example by default. /ts/devmachine would be 
    remapped to /tsproxy/connect.asp?Server=devmachine?ProxyServer=SERVER_NAME
    where SERVER_NAME is the name of the server as fetched from IIS.

Arguments:

    pfc - Filter context passed in.

    notificationType - Always SF_NOTIFY_PREPROC_HEADERS since that is the only
                       event we are registered for.

    pvNotification - A PHTTP_FILTER_PREPROC_HEADERS structure passed in by IIS.

Return Value:

    SF_STATUS_REQ_NEXT_NOTIFICATION -  We always return that IIS should go on
                                       to the next filter.

--*/
{
    PHTTP_FILTER_PREPROC_HEADERS preproc;
    DWORD dwNewUrlSize;
    LPSTR origUrl  = NULL ;
    LPSTR serverName, chunked, clen;
    LPSTR newUrl = NULL;
    LPSTR remapPrefix = NULL;
    LPSTR newUrlBase = NULL;
    LPCSTR host;
    DWORD dwRemapPrefixLength;

    serverName = NULL;

	  DC_BEGIN_FN("HttpFilterProc");

    preproc = (PHTTP_FILTER_PREPROC_HEADERS)pvNotification;
    
    origUrl = GetAndAllocateFilterHeader(pfc,preproc,"URL");
    
    if (!origUrl) 
    {
        goto EXIT_POINT;
    }

    remapPrefix = GetRegValueAsAnsiString( TS_PROXY_REMAP_PREFIX_NAME, TS_PROXY_REMAP_PREFIX_DFLT );
    
    if (!remapPrefix) 
    {
        goto EXIT_POINT;
    }
    
    dwRemapPrefixLength = strlen(remapPrefix);

    if (0 != strncmp(origUrl,remapPrefix,dwRemapPrefixLength)) 
    {
        goto EXIT_POINT;
    }
    
    if (remapPrefix[dwRemapPrefixLength-1] != '/') 
    {
        if (origUrl[dwRemapPrefixLength] != '/') 
        {
            goto EXIT_POINT;   
        }
        dwRemapPrefixLength++;
    }
    
    host = origUrl + dwRemapPrefixLength;

    serverName = GetAndAllocateFilterServerVariable(pfc,"SERVER_NAME");
    if (!serverName) 
    {
        goto EXIT_POINT;
    }

    chunked = GetAndAllocateFilterServerVariable(pfc,"HTTP_TRANSFER_ENCODING");
    clen =    GetAndAllocateFilterServerVariable(pfc,"CONTENT_LENGTH");

    newUrlBase = GetRegValueAsAnsiString( TS_PROXY_REMAP_DEST_URL_NAME,   TS_PROXY_REMAP_DEST_URL_DFLT );
    
    if (!newUrlBase) 
    {
        goto EXIT_POINT;
    }
    
    dwNewUrlSize = strlen(newUrlBase) + strlen(TS_PROXY_REMAP_DEST_URL_SUFFIX)
        - 6 + strlen(host) + strlen(serverName) + 1;
    
    newUrl = (LPSTR)HeapAlloc(GetProcessHeap(),0,dwNewUrlSize);
    if (!newUrl) 
    {
        goto EXIT_POINT;
    }

    wsprintfA(newUrl,TS_PROXY_REMAP_DEST_URL_SUFFIX,newUrlBase,host,serverName);
    preproc->SetHeader(pfc,"URL",newUrl);
     

EXIT_POINT:
    if (origUrl) 
    {
        HeapFree(GetProcessHeap(),0,origUrl);
    }
    if (serverName) 
    {
        HeapFree(GetProcessHeap(),0,serverName);
    }
    if (newUrl) 
    {
        HeapFree(GetProcessHeap(),0,newUrl);
    }
    if (remapPrefix) 
    {
        HeapFree(GetProcessHeap(),0,remapPrefix);
    }
    if (newUrlBase) 
    {
        HeapFree(GetProcessHeap(),0,newUrlBase);
    }
    
	  DC_END_FN();

    return SF_STATUS_REQ_NEXT_NOTIFICATION;
}

BOOL WINAPI
GetExtensionVersion(
    IN HSE_VERSION_INFO* pVer
    )

/*++

Routine Description:

    We simple set our name and the version of IIS we were compiled against.

Arguments:

    pVer - Extension version struct we need to fill in.

Return Value:

    TRUE - We don't have any way to cause an error so we always return true.

--*/
{
	  DC_BEGIN_FN("GetExtensionVersion");
    pVer->dwExtensionVersion = HSE_VERSION;
    strncpy(pVer->lpszExtensionDesc,ISAPI_DLL_NAME,HSE_MAX_EXT_DLL_NAME_LEN-1);
	  DC_END_FN();
    return TRUE;
}

DWORD WINAPI 
HttpExtensionProc(
    IN LPEXTENSION_CONTROL_BLOCK lpECB 
    )

/*++

Routine Description:

    This is the primary entry point for the dll.  IIS calls this function
    whenever there is a connection for our extension.  We first check to
    see if the user agent is the terminal server client.  If not we send a 302
    response to the client to a url which tells them they can't use this url
    with a browser.  If it is the terminal server client we attempt to open
    a tcp connection to the server they specify in the query string and then 
    start routing data back and forth.

Arguments:

    lpECB - Extension control block structure passed in from IIS.

Return Value:

    HSE_STATUS_PENDING - We still have more processing to do.
    
    HSE_STATUS_ERROR - There was an error while processing the connection.

    HSE_STATUS_SUCCESS_AND_KEEP_CONN - The extension is done and IIS should
                                       keep the connection open.

--*/
{
    DWORD dwRetCode;
    HSE_SEND_HEADER_EX_INFO headerEx;
    BOOL result;

	DC_BEGIN_FN("HttpExtensionProc");

    if (!VerifyTsacUserAgent(lpECB)) 
    {
		    DC_END_FN();
        return RedirectToBrowserPage(lpECB);
    }

    if (0 == strcmp(lpECB->lpszMethod,HTTP_METHOD_HEAD)) 
    {
        headerEx.pszStatus = HTTP_STATUS_OK;
        headerEx.cchStatus = strlen(HTTP_STATUS_OK);
        headerEx.pszHeader = HTTP_CONTENTLENGTH_ZERO;
        headerEx.cchHeader = strlen(HTTP_CONTENTLENGTH_ZERO);
        headerEx.fKeepConn = TRUE;
        result = lpECB->ServerSupportFunction(lpECB->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER_EX,&headerEx,NULL,NULL);
        if (result) 
        {
			      DC_END_FN();
            return HSE_STATUS_SUCCESS_AND_KEEP_CONN;
        } 
        else 
        {
			      DC_END_FN();
            return HSE_STATUS_ERROR;
        }
    } 
    else 
    {
        dwRetCode = StartTsProxy(lpECB);
    
        if (dwRetCode != HSE_STATUS_ERROR) 
        {
            headerEx.pszStatus = HTTP_STATUS_OK;
            headerEx.cchStatus = strlen(HTTP_STATUS_OK);
        } 
        else 
        {
            headerEx.pszStatus = HTTP_STATUS_ERR;
            headerEx.cchStatus = strlen(HTTP_STATUS_ERR);
        }
        headerEx.pszHeader = NULL;
        headerEx.cchHeader = 0;
        headerEx.fKeepConn = TRUE;
        lpECB->ServerSupportFunction(lpECB->ConnID,
           HSE_REQ_SEND_RESPONSE_HEADER_EX,&headerEx,NULL,NULL);
		    DC_END_FN();
        return dwRetCode;
    }
}

BOOL WINAPI
TerminateExtension(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    IIS calls this when we are about to be unloaded.  Currently
    we don't do any processing here because IIS will not call us
	when we have open connections.

Arguments:

    dwFlags - IIS flags on why this function has been called.

Return Value:

    TRUE - We don't have any way to cause an error so we always return true.

--*/
{
    return TRUE;
}

BOOL
VerifyTsacUserAgent(
    IN LPEXTENSION_CONTROL_BLOCK lpECB
    )

/*++

Routine Description:

    This checks to see if the client user agent matches
    that of the terminal server client.

Arguments:

    lpECB - Extension control block given to use by IIS.

Return Value:

    TRUE - The user agent string matches that of the terminal server client.

    FALSE - The user agent string doesn't match that of TSAC.

--*/
{
    LPSTR headers;
    LPSTR line;
    LPSTR lineEnd;
    LPSTR userAgent;
    BOOL succeeded;

	  DC_BEGIN_FN("VerifyTsacUserAgent");

    succeeded = FALSE;
    
    headers = GetAndAllocateExtensionServerVariable(lpECB,"ALL_HTTP");
    
    if (!headers) 
    {
        goto CLEANUP_AND_EXIT;
    }
    line = headers;
    // While strlen(line) > 0 is what we are doing here
    while (line[0] != '\0') 
    {
        lineEnd = strchr(line,'\n');
        if (!lineEnd) 
        {
            goto CLEANUP_AND_EXIT;
        }
        
        *lineEnd = '\0';
        if (0 == strncmp(HTTP_USER_AGENT,line,strlen(HTTP_USER_AGENT))) 
        {
            userAgent = line + strlen(HTTP_USER_AGENT);
           
            if (0 == strncmp(userAgent,TS_USER_AGENT_PREFIX,
                strlen(TS_USER_AGENT_PREFIX))) 
            {
                succeeded = TRUE;
                break;
            }

        }
        line += ((lineEnd - line) + 1);
    }

CLEANUP_AND_EXIT:
    if (headers) 
    {
        HeapFree(GetProcessHeap(),0,headers);
    }

	  DC_END_FN();
    return succeeded;
}

DWORD
RedirectToBrowserPage(
    IN LPEXTENSION_CONTROL_BLOCK lpECB
    )

/*++

Routine Description:

    This attempts to do a redirect to either the default browser
    page or the one defined in the registry.

Arguments:

    lpECB - Extension control block structure passed in from IIS.

Return Value:

    HSE_STATUS_ERROR - There was an error while processing the redirect.

    HSE_STATUS_SUCCESS_AND_KEEP_CONN - The redirect was succeeded and IIS should
                                       keep the connection open.

--*/
{
    LPSTR fullRedirectUrl;
    DWORD fullRedirectUrlLength;
    LPSTR serverName;
    LPSTR https;
    BOOL failure;
    BOOL result;
    LPSTR urlPrefix;
    LPSTR url;

	  DC_BEGIN_FN("RedirectToBrowserPage");

    failure = FALSE;
    serverName = NULL;
    https = NULL;
    fullRedirectUrl = NULL;
    url = NULL;

    serverName = GetAndAllocateExtensionServerVariable(lpECB,"SERVER_NAME");
    
    if (!serverName) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    https = GetAndAllocateExtensionServerVariable(lpECB,"HTTPS");
    
    if (!https) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    if (0 == strcmp(https,"on")) 
    {
        urlPrefix = HTTPS_URL_PREFIX;
    } 
    else 
    {
        urlPrefix = HTTP_URL_PREFIX;
    }

    url = GetRegValueAsAnsiString(TS_PROXY_INC_AGENT_DEST_NAME, TS_PROXY_INC_AGENT_DEST_DFLT);
    
    if (!url) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    fullRedirectUrlLength = strlen(urlPrefix) + strlen(serverName) + strlen(url) + 1;
    fullRedirectUrl = (LPSTR)HeapAlloc(GetProcessHeap(), 0, fullRedirectUrlLength);
    
    if (!fullRedirectUrl) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    strcpy(fullRedirectUrl,urlPrefix);
    strcat(fullRedirectUrl,serverName);
    strcat(fullRedirectUrl,url);

    result = lpECB->ServerSupportFunction(lpECB->ConnID, HSE_REQ_SEND_URL_REDIRECT_RESP,fullRedirectUrl,&fullRedirectUrlLength,NULL);
    
    if (!result) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
CLEANUP_AND_EXIT:
    if (serverName) 
    {
        HeapFree(GetProcessHeap(),0,serverName);
    }
    if (https) 
    {
        HeapFree(GetProcessHeap(),0,https);
    }
    if (fullRedirectUrl) 
    {
        HeapFree(GetProcessHeap(),0,fullRedirectUrl);
    }
    if (url) 
    {
        HeapFree(GetProcessHeap(),0,url);
    }

	DC_END_FN();

    if (failure) 
    {
        return HSE_STATUS_ERROR;
    } 
    else 
    {
        return HSE_STATUS_SUCCESS_AND_KEEP_CONN;
    }
}

LPSTR
GetAndAllocateExtensionServerVariable(
    IN LPEXTENSION_CONTROL_BLOCK lpECB,
    IN LPSTR lpstrVariable
    )

/*++

Routine Description:

    This gets the requested extension server variable from IIS and allocates
    memory to hold the result.

Arguments:

    lpECB - Extension control block structure passed in from IIS.

    lpstrVariable - Name of the variable that is being requested.

Return Value:

    Non NULL - The value of the variable requested.

    NULL - There was an error getting the requested variable

--*/
{
    LPSTR value;
    DWORD valueLength;
    BOOL failure;
    BOOL result;

	DC_BEGIN_FN("GetAndAllocateExtensionServerVariable");
    
    failure = FALSE;
    value = NULL;
    valueLength = 0;

    result = lpECB->GetServerVariable(lpECB->ConnID,lpstrVariable,
        NULL,&valueLength);
    
    if (result || ERROR_INSUFFICIENT_BUFFER != GetLastError()) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    value = (LPSTR)HeapAlloc(GetProcessHeap(), 0, valueLength);
    
    if (!value) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    result = lpECB->GetServerVariable(lpECB->ConnID,lpstrVariable,
        value,&valueLength);
    
    if (!result) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

CLEANUP_AND_EXIT:
    if (failure) 
    {
        if (value) 
        {
            HeapFree(GetProcessHeap(),0,value);
            value = NULL;
        }
    }
	
    DC_END_FN();
    return value;
}

LPSTR
GetAndAllocateFilterServerVariable(
    IN PHTTP_FILTER_CONTEXT pfc,
    IN LPSTR lpstrVariable
    )

/*++

Routine Description:

    This gets the requested filter server variable from IIS and allocates
    memory to hold the result.

Arguments:

    pfc - Filter context for this session.

    lpstrVariable - Name of the variable that is being requested.

Return Value:

    Non NULL - The value of the variable requested.

    NULL - There was an error getting the requested variable

--*/
{
    LPSTR value;
    DWORD valueLength;
    BOOL failure;
    BOOL result;

	  DC_BEGIN_FN("GetAndAllocateFilterServerVariable");
    
    failure = FALSE;
    value = NULL;
    valueLength = 0;

    result = pfc->GetServerVariable(pfc,lpstrVariable,NULL,&valueLength);
    
    if (result || ERROR_INSUFFICIENT_BUFFER != GetLastError()) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    value = (LPSTR)HeapAlloc(GetProcessHeap(), 0, valueLength);
    
    if (!value) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    result = pfc->GetServerVariable(pfc,lpstrVariable,value,&valueLength);
    
    if (!result) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

CLEANUP_AND_EXIT:
    if (failure) 
    {
        if (value) 
        {
            HeapFree(GetProcessHeap(),0,value);
            value = NULL;
        }
    }

	  DC_END_FN();
    return value;
}

LPSTR
GetAndAllocateFilterHeader(
    IN PHTTP_FILTER_CONTEXT pfc,
    IN PHTTP_FILTER_PREPROC_HEADERS pPreproc,
    IN LPSTR lpstrVariable
    )

/*++

Routine Description:

    This gets the requested filter header from IIS and allocates
    memory to hold the result.

Arguments:

    pfc - Filter context for this session.

    pPreproc - Preproc headers structure given by IIS.

    lpstrVariable - Name of the header that is being requested.

Return Value:

    Non NULL - The value of the header requested.

    NULL - There was an error getting the requested header

--*/
{
    LPSTR value;
    DWORD valueLength;
    BOOL failure;
    BOOL result;

	  DC_BEGIN_FN("GetAndAllocateFilterHeader");
    
    failure = FALSE;
    value = NULL;
    valueLength = 0;

    result = pPreproc->GetHeader(pfc,lpstrVariable,NULL,&valueLength);
    
    if (result || ERROR_INSUFFICIENT_BUFFER != GetLastError()) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    value = (LPSTR)HeapAlloc(GetProcessHeap(), 0, valueLength);
    
    if (!value) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }
    
    result = pPreproc->GetHeader(pfc,lpstrVariable,value,&valueLength);
    
    if (!result) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

CLEANUP_AND_EXIT:
    if (failure) 
    {
        if (value) 
        {
            HeapFree(GetProcessHeap(),0,value);
            value = NULL;
        }
    }

	  DC_END_FN();
    return value;
}


DWORD
StartTsProxy(
    IN LPEXTENSION_CONTROL_BLOCK lpECB
    )

/*++

Routine Description:

    This attempts to open a connection to the remote server. We then
    start the server listen thread and the client read async callback.
    If an error occurrs we close the server connection and tell
    IIS to give up.

Arguments:

    lpECB - Extension control block for the session.

Return Value:

    HSE_STATUS_PENDING - The proxy was started and IIS should wait for
                         it to finish.

    HSE_STATUS_ERROR - There was an error starting the proxy.

--*/
{
	  USES_CONVERSION;
    BOOL fSuccess = FALSE;
    struct hostent *host;
    struct sockaddr_in addr_in;
    SOCKET s;
    int status;
    BOOL optVal;
    LPREADCALLBACKCONTEXT lpReadContext;
    LPSERVERLISTENTCONTEXT lpServerContext;
    HANDLE serverThread;
    DWORD dwBufferSize;
    DWORD retValue;
    DWORD dwResult;
    DWORD dwConnectPort;
    LPSTR lpstrUsername;
    unsigned long nonBlocking = 0;
    DCINT sizeVal;

    HANDLE ClientThread;

	  DC_BEGIN_FN("StartTsProxy");

    lpReadContext = NULL;
    lpServerContext = NULL;
    serverThread = NULL;
    s = INVALID_SOCKET;
    lpstrUsername = NULL;

    if (strlen(lpECB->lpszQueryString)==0) 
    {
        // We didn't get a server to connect to.
        DC_QUIT;
    }

    host = gethostbyname(lpECB->lpszQueryString);
    
    if (!host) 
    {
        // DNS lookup on the hostname failed
        DC_QUIT;
    }

    lpstrUsername = GetAndAllocateExtensionServerVariable(lpECB,"LOGON_USER");
    
    if (!VerifyServerAccess(lpECB,host->h_name, lpstrUsername)) 
    {
        DC_QUIT;
    }

    s = socket(AF_INET, SOCK_STREAM, 0);

    if ( INVALID_SOCKET == s )
    {
        TRC_ERR((TB, _T("Failed to get a socket - GLE:%d"), WSAGetLastError()));
        DC_QUIT;
    }

    /************************************************************************/
    /* Set the required options on this socket.  We do the following:       */
    /*                                                                      */
    /*  - disable the NAGLE algorithm.                                      */
    /*  - enable the don't linger option.  This means the closesocket call  */
    /*    will return immediately while any data queued for transmission    */
    /*    will be sent, if possible, before the underlying socket is        */
    /*    closed.                                                           */
    /************************************************************************/

    optVal = TRUE;
    status = setsockopt( s, IPPROTO_TCP, TCP_NODELAY, (PCHAR)&optVal, sizeof(optVal));
    
    status = setsockopt( s, SOL_SOCKET, SO_DONTLINGER,(PCHAR)&optVal, sizeof(optVal));

    //
    // Put the socket in blocking mode; 
    //
    status = ioctlsocket( s, FIONBIO, &nonBlocking);

    ZeroMemory( &addr_in, sizeof( addr_in ));

    addr_in.sin_family =  AF_INET;
    
    dwConnectPort = GetRegValueAsDword( TS_PROXY_CONNECT_PORT_NAME, TS_PROXY_CONNECT_PORT_DFLT );
    
    addr_in.sin_port = htons((USHORT)dwConnectPort);
    
    CopyMemory( &addr_in.sin_addr, host->h_addr_list[0], sizeof(addr_in.sin_addr) );

    status = connect( s, (struct sockaddr *)&addr_in, sizeof(addr_in) );

    /********************************************************************/
    /* We expect the connect to return an error of WSAEWOULDBLOCK -     */
    /* anything else indicates a genuine error.                         */
    /********************************************************************/
    
    if ( status == SOCKET_ERROR ) 
    {
        status = WSAGetLastError();
        if (status != WSAEWOULDBLOCK)
        {
            TRC_ERR((TB, _T("Connect failed - GLE:%d"), status));
            DC_QUIT;
        }
    }

    //
    //set the send and receive buffers (reserves them)
    //
    sizeVal = TS_PROXY_WSRCVBUFSIZE;
    status = setsockopt( s, SOL_SOCKET, SO_RCVBUF, (char DCPTR) &sizeVal, sizeof( DCINT ));
    sizeVal = TS_PROXY_WSSNDBUFSIZE;
    status = setsockopt( s, SOL_SOCKET,  SO_SNDBUF, (char DCPTR) &sizeVal, sizeof( DCINT ));

    //   
    // Set keep-alive to false
    //
    optVal = false;
    status = setsockopt( s, SOL_SOCKET, SO_KEEPALIVE, (PCHAR)&optVal, sizeof(optVal));
 
    if (status == SOCKET_ERROR) 
    {
        DC_QUIT;
    }

    lpServerContext = (LPSERVERLISTENTCONTEXT)HeapAlloc( GetProcessHeap(), 0, sizeof(SERVERLISTENTCONTEXT) );
    
    if (!lpServerContext) 
    {
        DC_QUIT;
    }

    lpServerContext->bTerminate = FALSE;
    memcpy( &lpServerContext->s, &s, sizeof( s ));
    lpServerContext->lpECB = lpECB;

    serverThread = CreateThread( NULL, 0, ServerListenThread, lpServerContext, CREATE_SUSPENDED, NULL);
   
    if (!serverThread) 
    {
        DC_QUIT;
    }

    lpReadContext = (LPREADCALLBACKCONTEXT)HeapAlloc( GetProcessHeap(), 0, sizeof(READCALLBACKCONTEXT) );

    if (!lpReadContext) 
    {
        DC_QUIT;
    }

    lpReadContext->s = s;
    lpReadContext->serverListenThread = serverThread;
	  lpReadContext->cbReadSoFar = 0;

    
    lpReadContext->lpECB = lpECB;
    
    //we have come this far, so we must have been successful
	//
  //start reading from client and send to server. 
  //
  	fSuccess = ReadFromClient( lpReadContext );

DC_EXIT_POINT:
    if (lpstrUsername) 
    {
        HeapFree(GetProcessHeap(),0,lpstrUsername);
    }

    if (serverThread) 
    {
        if ( !fSuccess ) 
        {
            lpServerContext->bTerminate = TRUE;
        }
        
        dwResult = ResumeThread(serverThread);
        if (dwResult == -1) 
        {
            fSuccess = FALSE;
            HeapFree(GetProcessHeap(),0,lpServerContext);
            lpServerContext = NULL;
        }
    }

    if ( !fSuccess ) 
	  {
        if (serverThread) 
        {
            CloseHandle(serverThread);    
        } 
        else if (lpServerContext) 
        {
            HeapFree(GetProcessHeap(),0,lpServerContext);
        }
        if (lpReadContext) 
        {
            HeapFree(GetProcessHeap(),0,lpReadContext);
        }
        if (s!=INVALID_SOCKET) 
        {
            closesocket(s);
        }

        retValue = HSE_STATUS_ERROR;
    } 
	  else 
	  {
        retValue = HSE_STATUS_PENDING;
    }

	  DC_END_FN();
    return retValue;
}


DWORD WINAPI
ServerListenThread(
    IN LPVOID lpParameter
    )

/*++

Routine Description:

    This thread loops reading data from the server and forwarding it to the
    client.  If an error occurrs we tell IIS to close the client connection
    and we then exit the thread.

Arguments:

    lpParameter - Context specified when we created the thread.

Return Value:

    0 - Novody is checking the thread exit value so we just return 0/

--*/
{
    int     read;
    BYTE    buf[ TS_MAX_READ_SIZE ];
    SOCKET  s;
    LPEXTENSION_CONTROL_BLOCK lpECB;
    BOOL    result;
    DWORD   dwBufferSize;

	  DC_BEGIN_FN("ServerListenThread");

    s = ((LPSERVERLISTENTCONTEXT)lpParameter)->s;

    lpECB = ((LPSERVERLISTENTCONTEXT)lpParameter)->lpECB;

    if ( ((LPSERVERLISTENTCONTEXT)lpParameter)->bTerminate ) 
    {
        HeapFree( GetProcessHeap(), 0, lpParameter );
        return 0;
    }

    HeapFree( GetProcessHeap(), 0, lpParameter );

    lpParameter = NULL;

    WSASetLastError( 0 );

    char* temp = "tsdata";
    int nOffset = strlen( temp );
    while ( TRUE )
    {
        
        strcpy( (PCHAR)buf, "tsdata" );
        
        read = recv( s, (PCHAR)buf+nOffset, sizeof( buf ), 0);

        dwBufferSize = read;
        
        if( 0 >= read )
        {
              //something has gone wrong; bail
                read = WSAGetLastError();
                TRC_ERR((TB, _T("Reading from server failed - GLE:%d"), read));
                break;
        }
        result = lpECB->WriteClient( lpECB->ConnID, buf, &dwBufferSize, HSE_IO_SYNC|HSE_IO_NODELAY );
        
        if ( !result || dwBufferSize != read ) 
        {
            // There was a problem writing to the client.
            TRC_ERR((TB, _T("Writing to client failed - GLE:%d"), WSAGetLastError ()));
            break;
        }
    }

  
    //
    // If this fails there isn't anything we can do so we just ignore the
    // return code.
    //
    lpECB->ServerSupportFunction( lpECB->ConnID, HSE_REQ_CLOSE_CONNECTION, NULL, NULL, NULL );
    
    //
    // It is the read callbacks job to close the socket.  We just exit here
    // since we closed client connection it should cause the callback
    // to cleanup the conneciton.
    //
	  
    DC_END_FN();
    return 0;
}


/*++

Routine Description:

    Reads data from client and sends to server if the data is contained within the ECB.
	If data is too large, just sets up an async read callback that IIS will call when data becomes available from the client

Arguments:

    lpECB - Extension control block for the connection.

    lpReadContext - Read context that contains server socket, and other data

Return Value:

    TRUE if successful
	FALSE if we could not send data to server or could not read from client

--*/


DWORD ReadFromClient( IN LPVOID lpParam )
{
	BOOL    result = FALSE;
  DWORD   dwFlags;
  DWORD   cbTotalToRead = TS_MAX_READ_SIZE;
	DWORD   hseStatus =  HSE_STATUS_PENDING;
	int     sent;
	DWORD   dwDataType;
    
	DC_BEGIN_FN("ReadFromClient");

  LPREADCALLBACKCONTEXT lpReadContext = (LPREADCALLBACKCONTEXT)lpParam;
	
  LPEXTENSION_CONTROL_BLOCK lpECB = lpReadContext->lpECB;

    //
    //  Set a call back function and context that will 
    //  be used for handling asynchrnous IO operations.
    //  This only needs to set up once.
    //

    CFRg( lpECB->ServerSupportFunction( lpECB->ConnID,HSE_REQ_IO_COMPLETION, ProxyReadCallback,NULL,(LPDWORD)lpReadContext ));
    
    dwDataType = HSE_IO_ASYNC;

    CFRg( lpECB->ServerSupportFunction( lpECB->ConnID,HSE_REQ_ASYNC_READ_CLIENT, lpReadContext->readBuffer, &cbTotalToRead, &dwDataType ));

  	result = TRUE;

END:
	DC_END_FN();
	return result;
}




VOID WINAPI
ProxyReadCallback(
    IN LPEXTENSION_CONTROL_BLOCK lpECB,
    IN PVOID pContext,
    IN DWORD cbIO,
    IN DWORD dwError
    )

/*++

Routine Description:

    Callback from IIS when data is received from the client.  If any errors
    occurr we close the socket to the server and wait for the server listening
    thread to exit.  When it exits we then tell IIS we are done with this
    connection.

    we just sit in an infinite loop reading from the client until the client closes the connection

Arguments:

    lpECB - Extension control block for the connection.

    pContext - Context we defined when requesting the async notification.

    cbIO - Bytes read from the client.  Zero indicates the connection closed.

    dwError - Win32 error code for the read. Non-zero means there was an error.

Return Value:

    None

--*/
{
    LPREADCALLBACKCONTEXT lpReadContext;
    int   sent = 0;
    DWORD cbTotalToRead;
    DWORD dwDataType;
    BOOL  fResult = FALSE;

	  DC_BEGIN_FN("ProxyReadCallback");

    lpReadContext = (LPREADCALLBACKCONTEXT)pContext;

    if (dwError != 0 || cbIO == 0) 
    {
        DC_QUIT;
    }

      WSASetLastError( 0 );
      cbTotalToRead = sizeof( lpReadContext->readBuffer );
      fResult = lpECB->ReadClient( lpECB->ConnID,  lpReadContext->readBuffer, &cbTotalToRead );
      
      if( !fResult || !cbTotalToRead )
      {
        TRC_ERR((TB, _T("Send failed - GLE:%d"), GetLastError ()));
        DC_QUIT;
      }

      //send the information to the server
      
      WSASetLastError( 0 );
      sent = send( lpReadContext->s, lpReadContext->readBuffer, cbTotalToRead, 0 );

      if (sent < 0 || (UINT)sent != cbTotalToRead ) 
      {
          TRC_ERR((TB, _T("Send failed - GLE:%d"), WSAGetLastError ()));
          fResult = FALSE;
          DC_QUIT;
      }

      //tell iis we want to keep reading      
      cbTotalToRead = sizeof( lpReadContext->readBuffer );
      dwDataType = HSE_IO_ASYNC;

      fResult = lpECB->ServerSupportFunction( lpECB->ConnID, HSE_REQ_ASYNC_READ_CLIENT, lpReadContext->readBuffer, &cbTotalToRead, &dwDataType );
      
 
      /*
      cbTotalToRead = lpECB->cbTotalBytes - lpReadContext->cbReadSoFar;
		
	    if ( cbTotalToRead > TS_PROXY_READ_SIZE ) 
	    {
	      cbTotalToRead = TS_PROXY_READ_SIZE;
	    }
    
      dwDataType = HSE_IO_ASYNC;
    
	    fResult = lpECB->ServerSupportFunction( lpECB->ConnID, HSE_REQ_ASYNC_READ_CLIENT, lpReadContext->readBuffer, &cbTotalToRead, &dwDataType );
    
      //something really went wrong since IIS is telling us it won't be able to give us any async data
	    if (!fResult) 
	    {
          break;
      }

	    lpReadContext->cbReadSoFar += cbIO;
      */

    // Basically if anything in here fails we are in deep
    // trouble.  We can't really do much about the failures
    // so we need to just keep going and hope it works.
    // All that said.  None of the calls in here should fail.

    // By shutting down the socket we should force the server listen
    // thread to exit since it is looping reading on the socket.
DC_EXIT_POINT:
    if (!fResult )
    {
      closesocket( lpReadContext->s );

      WaitForSingleObject( lpReadContext->serverListenThread,INFINITE );
    
      CloseHandle( lpReadContext->serverListenThread );

      lpECB->ServerSupportFunction( lpECB->ConnID, HSE_REQ_DONE_WITH_SESSION, NULL, NULL, NULL);

      HeapFree( GetProcessHeap(),0, lpReadContext );
    }

	  DC_END_FN();
}


DWORD
GetRegValueAsDword(
    IN LPCSTR regValue,
    IN DWORD dwDefaultValue
    )

/*++

Routine Description:

    This gets the requested DWORD value from the registry. If it is not found
    then the default value is returned instead.

Arguments:

    regValue - Name of the requested value.

    defaultValue - Value to use if not found in the registry.

Return Value:

    DWORD - Either the requested value or the default.

--*/
{
    DWORD dwRetValue;
    LPVOID lpRegValue;

	  DC_BEGIN_FN("GetRegValueAsDword");

    lpRegValue = QueryRegistryData(regValue,REG_DWORD);
    
    if (lpRegValue) 
    {
        dwRetValue = *((LPDWORD)lpRegValue);
        HeapFree(GetProcessHeap(),0,lpRegValue);
    } 
    else 
    {
        dwRetValue = dwDefaultValue;
    }

	  DC_END_FN();
    return dwRetValue;
}

LPSTR
GetRegValueAsAnsiString(
    IN LPCSTR regValue,
    LPSTR defaultValue
    )

/*++

Routine Description:

    This gets the requested string value from the registry. If it is not found
    then the default string is returned instead.  The returned string is always
    allocated in the function so it must be de-allocated when it is no longer
    needed.

Arguments:

    regValue - Name of the requested value.

    defaultValue - Value to use if not found in the registry.

Return Value:

    Non NULL - The value requested (or the default).

    NULL - There was not enough memory to allocate a buffer to hold
           the default string.

--*/
{
    LPVOID lpRegValue;
    LPSTR retString;

	  DC_BEGIN_FN("GetRegValueAsAnsiString");

    retString = NULL;

    lpRegValue = QueryRegistryData(regValue,REG_SZ);
    if (lpRegValue) 
    {
        retString = (LPSTR)lpRegValue;
    } 
    else 
    {
        retString = (LPSTR)HeapAlloc(GetProcessHeap(),0,sizeof(CHAR) * (strlen(defaultValue) + 1));
        if (!retString) 
        {
            goto CLEANUP_AND_EXIT;
        }
        
        lstrcpyA(retString,defaultValue);
    }

CLEANUP_AND_EXIT:

	  DC_END_FN();
    return retString;
}

LPVOID
QueryRegistryData(
    IN LPCSTR regValue,
    IN DWORD typeRequested
    )

/*++

Routine Description:

    This gets the requested value from the registry if it
    is of the given type.  If it is memory is allocated
    for the value and it is returned.

Arguments:

    regValue - Name of the requested value.

    typeRequested - Type of the registry value desired

Return Value:

    Non NULL - The value requested.

    NULL - There was an error getting the requested value

--*/
{
    LONG retCode;
    HKEY hRegKey;
    LPBYTE lpValueData;
    DWORD dwValueSize;
    DWORD dwType;
    BOOL failure;

	  DC_BEGIN_FN("QueryRegistryData");

    hRegKey = NULL;
    failure = FALSE;
    lpValueData = NULL;

    retCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, TS_PROXY_REG_KEY, 0, KEY_QUERY_VALUE, &hRegKey );
    
    if (ERROR_SUCCESS != retCode) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    retCode = RegQueryValueExA(hRegKey,regValue,NULL,&dwType,NULL,&dwValueSize);
    
    if (retCode != ERROR_SUCCESS) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    // Make sure the data is the type they requested
    if (dwType != typeRequested) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    lpValueData = (LPBYTE)HeapAlloc(GetProcessHeap(),0,dwValueSize);
    
    if (!lpValueData) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

    retCode = RegQueryValueExA( hRegKey, regValue, NULL, &dwType, lpValueData, &dwValueSize );
    
    if (retCode != ERROR_SUCCESS) 
    {
        failure = TRUE;
        goto CLEANUP_AND_EXIT;
    }

CLEANUP_AND_EXIT:
    if (failure) 
    {
        if (lpValueData) 
        {
            HeapFree(GetProcessHeap(),0,lpValueData);
            lpValueData = NULL;
        }
    }
    
    if (hRegKey) 
    {
        RegCloseKey(hRegKey);
    }

	  DC_END_FN();
    return lpValueData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\httpproxy\isapi\tsproxyacl.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Terminal Server ACL module

Abstract:

    This module implements ACL checking for the ISAPI extension.

Author:

    Marc Reyhner 9/7/2000

--*/

#ifndef __TSPROXYACL_H__
#define __TSPROXYACL_H__

BOOL VerifyServerAccess(LPEXTENSION_CONTROL_BLOCK lpECB,LPSTR server,LPSTR user);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\channel.c ===
/*************************************************************************
* CHANNEL.C
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:   Marc Bloomfield
*           Terry Treder
*           Brad Pedersen
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   External procedures defined
=============================================================================*/
NTSTATUS IcaChannelOpen( HANDLE hIca, CHANNELCLASS, PVIRTUALCHANNELNAME, HANDLE * phChannel );
NTSTATUS IcaChannelClose( HANDLE hChannel );
NTSTATUS IcaChannelIoControl( HANDLE hChannel, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );
VOID cdecl IcaChannelTrace( IN HANDLE hChannel, ULONG, ULONG, char *, ... );


/*=============================================================================
==   Internal procedures defined
=============================================================================*/

/*=============================================================================
==   Procedures used
=============================================================================*/
NTSTATUS _IcaStackOpen( HANDLE hIca, HANDLE * phStack, ICA_OPEN_TYPE, PICA_TYPE_INFO );



/****************************************************************************
 *
 * IcaChannelOpen
 *
 *   Open an ICA channel
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 *   Channel (input)
 *     ICA channel
 *
 *   pVirtualName (input)
 *     pointer to virtual channel name

 *   phChannel (output)
 *     Pointer to ICA channel handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaChannelOpen( IN HANDLE hIca, 
                IN CHANNELCLASS Channel, 
                IN PVIRTUALCHANNELNAME pVirtualName,
                OUT HANDLE * phChannel )
{
    ICA_TYPE_INFO TypeInfo;
    NTSTATUS Status;

    RtlZeroMemory( &TypeInfo, sizeof(TypeInfo) );
    TypeInfo.ChannelClass = Channel;
    if ( pVirtualName ) 
        strncpy( TypeInfo.VirtualName, pVirtualName, sizeof(TypeInfo.VirtualName) );

    Status = _IcaStackOpen( hIca, phChannel, IcaOpen_Channel, &TypeInfo );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    TRACE(( hIca, TC_ICAAPI, TT_API1, "TSAPI: IcaChannelOpen, %u/%s, %u, success\n", 
            Channel, TypeInfo.VirtualName, *phChannel ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badopen:
    TRACE(( hIca, TC_ICAAPI, TT_ERROR, "TSAPI: IcaChannelOpen, %u/%s, 0x%x\n", 
            Channel, TypeInfo.VirtualName, Status ));
    return( Status );
}


/****************************************************************************
 *
 * IcaChannelClose
 *
 *   Close an ICA channel
 *
 * ENTRY:
 *   hChannel (input)
 *     ICA channel handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaChannelClose( IN HANDLE hChannel )
{
    NTSTATUS Status;

    TRACECHANNEL(( hChannel, TC_ICAAPI, TT_API1, "TSAPI: IcaChannelClose[%u]\n", hChannel ));

    /*
     * Close the ICA device driver channel instance 
     */
    Status = NtClose( hChannel );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}

/****************************************************************************
 *
 * IcaChannelIoControl
 *
 *   Generic interface to an ICA channel
 *
 * ENTRY:
 *   hChannel (input)
 *     ICA channel handle
 *
 *   IoControlCode (input)
 *     I/O control code
 *
 *   pInBuffer (input)
 *     Pointer to input parameters
 *
 *   InBufferSize (input)
 *     Size of pInBuffer
 *
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaChannelIoControl( IN HANDLE hChannel,
                     IN ULONG IoControlCode,
                     IN PVOID pInBuffer,
                     IN ULONG InBufferSize,
                     OUT PVOID pOutBuffer,
                     IN ULONG OutBufferSize,
                     OUT PULONG pBytesReturned )
{
    NTSTATUS Status;

    Status = IcaIoControl( hChannel,
                           IoControlCode,
                           pInBuffer,
                           InBufferSize,
                           pOutBuffer,
                           OutBufferSize,
                           pBytesReturned );

    return( Status );
}


/*******************************************************************************
 *
 *  IcaChannelTrace
 *
 *  Write a trace record to the winstation trace file
 *
 * ENTRY:
 *   hChannel (input)
 *     ICA channel handle
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaChannelTrace( IN HANDLE hChannel,
                 IN ULONG TraceClass, 
                 IN ULONG TraceEnable, 
                 IN char * Format, 
                 IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;
    
    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker );

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;

    (void) IcaIoControl( hChannel,
                         IOCTL_ICA_CHANNEL_TRACE,
                         &Buffer,
                         sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                         NULL,
                         0,
                         NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\httpproxy\isapi\tsproxy.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Terminal Server ISAPI Proxy

Abstract:

    This is the ISAPI side of the terminal server proxy.  This opens a connection to the
    proxied server and then forwards data back and forth through IIS.  There is also
    a filter component which takes care of having more user friendly urls.

Author:

    Marc Reyhner 8/22/2000

--*/

#ifndef __TSPROXY_H__
#define __TSPROXY_H__

BOOL WINAPI GetFilterVersion(PHTTP_FILTER_VERSION pVer);
DWORD WINAPI HttpFilterProc(
    PHTTP_FILTER_CONTEXT pfc, DWORD notificationType, LPVOID pvNotification);

BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO* pVer);
DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK lpECB);
BOOL WINAPI TerminateExtension(DWORD dwFlags);

// globals

extern HINSTANCE g_hInstance;

//  Locaion of our key in the registry.
#define TS_PROXY_REG_KEY            _T("SOFTWARE\\Microsoft\\Terminal Server Proxy")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\cd.c ===
/*************************************************************************
* CD.C
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:   Marc Bloomfield
*           Terry Treder
*           Brad Pedersen
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   External procedures defined
=============================================================================*/
NTSTATUS IcaCdIoControl( HANDLE pContext, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );
NTSTATUS IcaCdWaitForSingleObject( HANDLE pContext, HANDLE, LONG );
NTSTATUS IcaCdWaitForMultipleObjects( HANDLE pContext, ULONG, HANDLE *, BOOL, LONG );
HANDLE   IcaCdCreateThread( HANDLE pContext, PVOID, PVOID, PULONG );

/*=============================================================================
==   Internal procedures defined
=============================================================================*/
NTSTATUS _CdOpen( PSTACK pStack, PWINSTATIONCONFIG2 );
VOID     _CdClose( PSTACK pStack );


/*=============================================================================
==   Procedures used
=============================================================================*/
void     _DecrementStackRef( IN PSTACK pStack );



/****************************************************************************
 *
 * IcaCdIoControl
 *
 *   Generic interface to an ICA stack  (for use by Connection Driver)
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaCdIoControl( IN HANDLE pContext,
                IN ULONG IoControlCode,
                IN PVOID pInBuffer,
                IN ULONG InBufferSize,
                OUT PVOID pOutBuffer,
                IN ULONG OutBufferSize,
                OUT PULONG pBytesReturned )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Unlock critical section
     */
    pStack->RefCount++;
    UNLOCK( &pStack->CritSec );   

    /*
     *  Call ICA Device driver
     */
    Status = IcaIoControl( pStack->hStack,
                           IoControlCode,
                           pInBuffer,
                           InBufferSize,
                           pOutBuffer,
                           OutBufferSize,
                           pBytesReturned );


    /*
     *  Re-lock critical section
     */
    LOCK( &pStack->CritSec );   
    _DecrementStackRef( pStack );

    if ( pStack->fClosing && (IoControlCode != IOCTL_ICA_STACK_POP) )
        Status = STATUS_CTX_CLOSE_PENDING;

    return( Status );
}


/****************************************************************************
 *
 * IcaCdWaitForSingleObject
 *
 *   Wait for handle to be signaled
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   hHandle (input)
 *     handle to wait on
 *   Timeout (input)
 *     timeout in milliseconds
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS 
IcaCdWaitForSingleObject( HANDLE pContext, 
                          HANDLE hHandle,
                          LONG Timeout )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Unlock critical section
     */
    pStack->RefCount++;
    UNLOCK( &pStack->CritSec );   

    /*
     *  Call ICA Device driver
     */
    Status = WaitForSingleObject( hHandle, Timeout );

    /*
     *  Re-lock critical section
     */
    LOCK( &pStack->CritSec );   
    _DecrementStackRef( pStack );

    if ( pStack->fClosing )
        Status = STATUS_CTX_CLOSE_PENDING;

    return( Status );
}


/****************************************************************************
 *
 * IcaCdWaitForMultipleObjects
 *
 *   Wait for one or more handles to be signaled
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   Count (input)
 *     count of handles
 *   phHandle (input)
 *     pointer to array of handles
 *   bWaitAll (input)
 *     wait for all flag
 *   Timeout (input)
 *     timeout in milliseconds
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS 
IcaCdWaitForMultipleObjects( HANDLE pContext, 
                             ULONG Count,
                             HANDLE * phHandle,
                             BOOL bWaitAll,
                             LONG Timeout )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Unlock critical section
     */
    pStack->RefCount++;
    UNLOCK( &pStack->CritSec );   

    /*
     *  Call ICA Device driver
     */
    Status = WaitForMultipleObjects( Count, phHandle, bWaitAll, Timeout );

    /*
     *  Re-lock critical section
     */
    LOCK( &pStack->CritSec );   
    _DecrementStackRef( pStack );

    if ( pStack->fClosing )
        Status = STATUS_CTX_CLOSE_PENDING;

    return( Status );
}


/****************************************************************************
 *
 * IcaCdCreateThread
 *
 *   Create a thread
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context 
 *   pProc (input)
 *     pointer to thread procedure
 *   pParam (input)
 *     parameter for thread procedure
 *   pThreadId (output)
 *     address to return thread id
 *
 * EXIT:
 *   thread handle (null on error)
 *
 ****************************************************************************/

typedef NTSTATUS (*PTHREAD_ROUTINE) ( PVOID );

typedef struct _CDCREATETHREADINFO {
    PTHREAD_ROUTINE pProc;
    PVOID pParam;
    PSTACK pStack;
} CDCREATETHREADINFO, *PCDCREATETHREADINFO;

NTSTATUS _CdThread( IN PCDCREATETHREADINFO pThreadInfo );


HANDLE
IcaCdCreateThread( HANDLE pContext, 
                   PVOID pProc, 
                   PVOID pParam, 
                   PULONG pThreadId )
{
    CDCREATETHREADINFO ThreadInfo;
    HANDLE Handle;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Initialize thread info
     */
    ThreadInfo.pProc = pProc;
    ThreadInfo.pParam = pParam;
    ThreadInfo.pStack = pStack;

    /*
     *  Increment reference 
     *  - this will be decremented when the thread exits
     */
    pStack->RefCount++;

    /*
     *  Create thread
     */
    Handle = CreateThread( NULL, 
                           5000, 
                           (LPTHREAD_START_ROUTINE) 
                           _CdThread,
                           &ThreadInfo, 
                           0, 
                           pThreadId );

    return( Handle );
}


NTSTATUS
_CdThread( IN PCDCREATETHREADINFO pThreadInfo )
{
    PSTACK pStack = pThreadInfo->pStack;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );   

    /*
     *  Call thread procedure in CD driver
     */
    (void) (pThreadInfo->pProc)( pThreadInfo->pParam );

    /*
     *  Decrement reference made in IcaCdCreateThread when thread exits
     */
    _DecrementStackRef( pStack );

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );   

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _CdOpen
 *
 *  Load and open connection driver dll
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationConfig (input)
 *      pointer to winstation config structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
_CdOpen( IN PSTACK pStack,
         IN PWINSTATIONCONFIG2 pWinStationConfig )
{
    PCDCONFIG pCdConfig;
    HANDLE Handle;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    pCdConfig = &pWinStationConfig->Cd;

    /*
     *  Return if there is no connection driver to load
     */
    if ( pCdConfig->CdClass == CdNone ) {
        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _CdOpen, no dll\n" ));
        return( STATUS_SUCCESS );
    }

    /*
     *  load CD DLL
     */
    Handle = LoadLibrary( pCdConfig->CdDLL );
    if ( Handle == NULL ) {
        Status = STATUS_CTX_PD_NOT_FOUND;
        goto badload;
    }

    /*
     *  get connection driver entry points
     */
    pStack->pCdOpen      = (PCDOPEN)      GetProcAddress( Handle, "CdOpen" );
    pStack->pCdClose     = (PCDCLOSE)     GetProcAddress( Handle, "CdClose" );
    pStack->pCdIoControl = (PCDIOCONTROL) GetProcAddress( Handle, "CdIoControl" );

    if ( pStack->pCdOpen == NULL || 
         pStack->pCdClose == NULL || 
         pStack->pCdIoControl == NULL ) {
        Status = STATUS_CTX_INVALID_PD;
        goto badproc;
    }

    /*
     *  Open CD driver
     */
    Status = (*pStack->pCdOpen)( pStack, 
				 &pWinStationConfig->Pd[0], // td parameters
                                 &pStack->pCdContext
			       );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    /*
     *  Save CD handle
     */
    pStack->hCdDLL = Handle;

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _CdOpen, %S, success\n",
                 pCdConfig->CdDLL ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  Open failed
     *  get proc address failed
     */
badopen:
badproc:
    pStack->pCdOpen      = NULL;
    pStack->pCdClose     = NULL;
    pStack->pCdIoControl = NULL;

    FreeLibrary( Handle );

    /*
     *  CD DLL load failed
     */
badload:
    pStack->pCdContext = NULL;

    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _CdOpen, %S, 0x%x\n", pCdConfig->CdDLL, Status ));
    return( Status );
}


/*******************************************************************************
 *
 *  _CdClose
 *
 *  Free local context structure
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
_CdClose( IN PSTACK pStack )
{
    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Close CD driver
     */
    if ( pStack->pCdClose ) {
        (void) (*pStack->pCdClose)( pStack->pCdContext );
    }

    /*
     *  Clear procedure pointers
     */
    pStack->pCdOpen      = NULL;
    pStack->pCdClose     = NULL;
    pStack->pCdIoControl = NULL;

    /*
     *  Unload dll
     */
    if ( pStack->hCdDLL ) {
        FreeLibrary( pStack->hCdDLL );
        pStack->hCdDLL = NULL;
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1,  "TSAPI: _CdClose\n" ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\icaapi.c ===
/*************************************************************************
* ICAAPI.C
*
* ICA DLL Interface for ICA Device Driver
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:   Marc Bloomfield
*           Terry Treder
*           Brad Pedersen
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*=============================================================================
==   External procedures defined
=============================================================================*/

#ifdef BUILD_AS_DLL
BOOL WINAPI DllEntryPoint( HINSTANCE, DWORD, LPVOID );
#endif

NTSTATUS IcaOpen( HANDLE * phIca );
NTSTATUS IcaClose( HANDLE hIca );
VOID cdecl IcaSystemTrace( IN HANDLE hIca, ULONG, ULONG, char *, ... );
VOID cdecl IcaTrace( IN HANDLE hIca, ULONG, ULONG, char *, ... );
NTSTATUS IcaIoControl( HANDLE hIca, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );


/*=============================================================================
==   Internal procedures defined
=============================================================================*/

NTSTATUS _IcaOpen( PHANDLE hIca, PVOID, ULONG );

/*=============================================================================
==   Procedures used
=============================================================================*/


#ifdef BUILD_AS_DLL
/****************************************************************************
 *
 * DllEntryPoint
 *
 *   Function is called when the DLL is loaded and unloaded.
 *
 * ENTRY:
 *   hinstDLL (input)
 *     Handle of DLL module
 *   fdwReason (input)
 *     Why function was called
 *   lpvReserved (input)
 *     Reserved; must be NULL
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Error occurred
 *
 ****************************************************************************/

BOOL WINAPI
DllEntryPoint( HINSTANCE hinstDLL,
               DWORD     fdwReason,
               LPVOID    lpvReserved )
{
    switch ( fdwReason ) {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hinstDLL);
            break;
    
        default:
            break;
    }

    return( TRUE );
}
#endif

/****************************************************************************
 *
 * IcaOpen
 *
 *   Open an instance to the ICA Device Driver
 *
 * ENTRY:
 *   phIca (output)
 *     Pointer to ICA instance handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaOpen( OUT HANDLE * phIca )
{
    NTSTATUS Status;        

    Status = _IcaOpen( phIca, NULL, 0 );
    if ( !NT_SUCCESS(Status) ) 
        goto badopen;

    TRACE(( *phIca, TC_ICAAPI, TT_API1, "TSAPI: IcaOpen, success\n" ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badopen:
    *phIca = NULL;
    return( Status );
}


/****************************************************************************
 *
 * IcaClose
 *
 *   Close an instance to the ICA Device Driver
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaClose( IN HANDLE hIca )
{
    NTSTATUS Status;

    TRACE(( hIca, TC_ICAAPI, TT_API1, "TSAPI: IcaClose\n" ));

    /*
     * Close the ICA device driver instance 
     */
    Status = NtClose( hIca );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaSystemTrace
 *
 *  Write a trace record to the system trace file
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaSystemTrace( IN HANDLE hIca,
                IN ULONG TraceClass, 
                IN ULONG TraceEnable, 
                IN char * Format, 
                IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;

    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker );

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;

    (void) IcaIoControl( hIca,
                         IOCTL_ICA_SYSTEM_TRACE,
                         &Buffer,
                         sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                         NULL,
                         0,
                         NULL );
}


/*******************************************************************************
 *
 *  IcaTrace
 *
 *  Write a trace record to the winstation trace file
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaTrace( IN HANDLE hIca,
          IN ULONG TraceClass, 
          IN ULONG TraceEnable, 
          IN char * Format, 
          IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;
    
    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker );

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;

    (void) IcaIoControl( hIca,
                         IOCTL_ICA_TRACE,
                         &Buffer,
                         sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                         NULL,
                         0,
                         NULL );
}


/****************************************************************************
 *
 * IcaIoControl
 *
 *   Generic interface to the ICA Device Driver
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 *   IoControlCode (input)
 *     I/O control code
 *
 *   pInBuffer (input)
 *     Pointer to input parameters
 *
 *   InBufferSize (input)
 *     Size of pInBuffer
 *
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaIoControl( IN HANDLE hIca,
              IN ULONG IoControlCode,
              IN PVOID pInBuffer,
              IN ULONG InBufferSize,
              OUT PVOID pOutBuffer,
              IN ULONG OutBufferSize,
              OUT PULONG pBytesReturned )
{
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    /*
     *  Issue ioctl
     */
    Status = NtDeviceIoControlFile( hIca,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &Iosb,
                                    IoControlCode, 
                                    pInBuffer, 
                                    InBufferSize,
                                    pOutBuffer,
                                    OutBufferSize );

    /*
     *  Wait for ioctl to complete
     */
    if ( Status == STATUS_PENDING ) {
        Status = NtWaitForSingleObject( hIca, FALSE, NULL );
        if ( NT_SUCCESS(Status)) 
            Status = Iosb.Status;
    }

    /*
     *  Convert warning into error
     */
    if ( Status == STATUS_BUFFER_OVERFLOW )
        Status = STATUS_BUFFER_TOO_SMALL;

    /*
     *  Initialize bytes returned
     */
    if ( pBytesReturned )
        *pBytesReturned = (ULONG)Iosb.Information;

    return( Status );
}


/****************************************************************************
 *
 * _IcaOpen
 *
 *   Open an instance to the ICA Device Driver or an ICA stack
 *
 * ENTRY:
 *   ph (output)
 *     Pointer to ICA or ICA stack instance handle
 *
 *   pEa (input)
 *     Pointer to extended attribute buffer
 *
 *   cbEa (input)
 *     Size of extended attribute buffer
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaOpen( PHANDLE ph,
          PVOID   pEa,
          ULONG   cbEa )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    IcaName;
    IO_STATUS_BLOCK   ioStatusBlock;

    /*
     * Initialize the object attributes
     */
    RtlInitUnicodeString( &IcaName, ICA_DEVICE_NAME );

    InitializeObjectAttributes( &objectAttributes,
                                &IcaName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    /*
     * Open an instance to the ICA device driver
     */
    Status = NtCreateFile( ph,
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           &objectAttributes,
                           &ioStatusBlock,
                           NULL,                               // AllocationSize
                           0L,                                 // FileAttributes
                           FILE_SHARE_READ | FILE_SHARE_WRITE, // ShareAccess
                           FILE_OPEN_IF,                       // CreateDisposition
                           0,
                           pEa,
                           cbEa );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\icaapip.h ===
/*************************************************************************
* ICAAPIP.H
*
*  This module contains private ICA DLL defines and structures
*
* Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
*  Author:   Brad Pedersen (7/12/96)
*************************************************************************/


/*=============================================================================
==   Defines
=============================================================================*/

#ifdef DBG
#define DBGPRINT(_arg) DbgPrint _arg
#else
#define DBGPRINT(_arg)
#endif

#if DBG
#undef TRACE
#undef TRACESTACK
#undef TRACECHANNEL
#define TRACE(_arg)         IcaTrace _arg
#define TRACESTACK(_arg)    IcaStackTrace _arg
#define TRACECHANNEL(_arg)  IcaChannelTrace _arg
#else
#define TRACE(_arg)
#define TRACESTACK(_arg)
#define TRACECHANNEL(_arg)
#endif


#define ICA_SD_MODULE_EXTENTION L".SYS"


/*=============================================================================
==   Typedefs
=============================================================================*/

typedef NTSTATUS (APIENTRY * PCDOPEN)( HANDLE, PPDCONFIG, PVOID * );
typedef NTSTATUS (APIENTRY * PCDCLOSE)( PVOID );
typedef NTSTATUS (APIENTRY * PCDIOCONTROL)( PVOID, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );

typedef NTSTATUS (APIENTRY * PSTACKIOCONTROLCALLBACK)( PVOID, PVOID, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );


/*=============================================================================
==   Semaphores
=============================================================================*/

/*
 *  Citrical section macros
 */
#define INITLOCK( _sem, _status ) { \
    _status = RtlInitializeCriticalSection( _sem ); \
    TRACE((hIca,TC_ICAAPI,TT_SEM,"INITLOCK: "#_sem"\n")); \
}
#define DELETELOCK( _sem ) { \
    RtlDeleteCriticalSection( _sem ); \
    TRACESTACK((pStack,TC_ICAAPI,TT_SEM,"DELETELOCK: "#_sem"\n")); \
}
#define LOCK( _sem ) { \
    ASSERTUNLOCK( _sem ); \
    RtlEnterCriticalSection( _sem ); \
    TRACESTACK((pStack,TC_ICAAPI,TT_SEM,"LOCK:   "#_sem"\n")); \
}
#define UNLOCK( _sem ) { \
    TRACESTACK((pStack,TC_ICAAPI,TT_SEM,"UNLOCK: "#_sem"\n")); \
    ASSERTLOCK( _sem ); \
    RtlLeaveCriticalSection( _sem ); \
}


#ifdef DBG
// (per JHavens) DWORD ThreadId is comparable to HANDLE OwningThread despite different sizes.
// Objects will still remain in <2GB address speace in Win64.


#define ASSERTLOCK(_sem) { ASSERT( LongToHandle(GetCurrentThreadId()) == (_sem)->OwningThread ); }
#define ASSERTUNLOCK(_sem) { ASSERT( LongToHandle(GetCurrentThreadId()) != (_sem)->OwningThread ); }

#else
#define ASSERTLOCK(_sem)
#define ASSERTUNLOCK(_sem)
#endif


/*=============================================================================
==   Structures
=============================================================================*/

/*
 *  Stack data structure
 */
typedef struct _STACK {

    /*
     *  Critical section protecting this structure and the
     *  connection driver
     */
    CRITICAL_SECTION CritSec;
    ULONG RefCount;
    HANDLE hUnloadEvent;
    HANDLE hCloseEvent;

    /*
     *  ICA Device driver stack handle
     */
    HANDLE hStack;

    /*
     *  Data for Connection Driver
     */
    HANDLE       hCdDLL;       // connection driver dll handle
    PVOID        pCdContext;   // pointer to connection driver context
    PCDOPEN      pCdOpen;      // pointer to connection driver open
    PCDCLOSE     pCdClose;     // pointer to connection driver close
    PCDIOCONTROL pCdIoControl; // pointer to connection driver IoControl

    ULONG fStackLoaded: 1;     // stack drivers are loaded
    ULONG fUnloading: 1;       // stack drivers are being unloaded
    ULONG fClosing: 1;         // stack is being closed

    PSTACKIOCONTROLCALLBACK pStackIoControlCallback;
    PVOID pCallbackContext;
} STACK, * PSTACK;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\icakey.c ===
/*************************************************************************
* T1.C
*
* Test program for ICA DLL Interface to ICA Device Driver
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <stdio.h>


#define MAX_READ 2

/*
 *   Data types and definitions
 */
#define KEYBOARD_THREAD_STACKSIZE 1024 * 4
typedef struct _THREADDATA {
    HANDLE handle;
} THREADDATA, * PTHREADDATA;

/*
 * Global variables
 */
static HANDLE ghIca                = NULL;
static HANDLE ghStack              = NULL;
static HANDLE ghKeyboard           = NULL;
static HANDLE ghMouse              = NULL;
static HANDLE ghVideo              = NULL;
static HANDLE ghBeep               = NULL;
static HANDLE ghCommand            = NULL;
static HANDLE ghCdm                = NULL;
static HANDLE ghThreadKeyboardRead = NULL;
static HANDLE ghStopEvent          = NULL;

/*
 * Private procedures
 */
LONG OpenStacks( void );
LONG ConnectStacks( void );
LONG CloseStacks( void );
LONG Initialize( void );
VOID KeyboardReadThread( PTHREADDATA pThreadData );
LONG KeyboardTest( void ); 

/****************************************************************************
 *
 * main
 *
 *   Main process entry point
 *
 * ENTRY:
 *   argc (input)
 *     Number of parameters
 *
 *   argv (input)
 *     Array of argument strings
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

int _cdecl
main (int argc, char *argv[])
{
    BOOL fSuccess = TRUE;
    LONG rc;


    /*
     * Open the ICA driver, an ICA stack, and some channels
     */
    if ( rc = OpenStacks() ) {
        goto done;
    }

    /*
     * Do some initialization
     */
    if ( rc = Initialize() ) {
        goto done;
    }

    printf( "Sleeping...\n" );
    Sleep(3000); // Give thread some time

    if ( rc = KeyboardTest() ) {
        goto done;
    }


    /*
     * Wait for stop event to be triggered.
     */
    printf( "ICAKEY main: Waiting for stop event...\n" );
    WaitForSingleObject( ghStopEvent, (DWORD)30000 );
    printf( "ICAKEY main: ...Stop event triggered\n" );

done:
    fSuccess = !rc;

    if ( rc = CloseStacks() ) {
        fSuccess = FALSE;
    }


    printf( "ICAKEY main: Test %s!\n", fSuccess ? "successful" : "failed" );
    return( 0 );
}


/****************************************************************************
 *
 * OpenStacks
 *
 *   Open ICA device driver, ICA stack, and ICA channels
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
OpenStacks( void )
{
    NTSTATUS rc;

    /*
     * Open an instance of the ICA device driver
     */
    if ( rc = IcaOpen( &ghIca ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaOpen\n",
                rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to ICA device driver: %08lX\n", ghIca );

    /*
     * Open an ICA stack instance
     */
    if ( rc = IcaStackOpen( ghIca, Stack_Primary, &ghStack ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaStackOpen\n", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to ICA stack: %08lX\n", ghStack );

    /*
     * Open the keyboard channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Keyboard, NULL, &ghKeyboard ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( keyboard )\n", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to keyboard channel: %08lX\n", ghKeyboard );

    /*
     * Open the mouse channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Mouse, NULL, &ghMouse ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( mouse )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to mouse channel: %08lX\n", ghMouse );

    /*
     * Open the video channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Video, NULL, &ghVideo ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( video )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to video channel: %08lX\n", ghVideo );

    /*
     * Open the beep channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Beep, NULL, &ghBeep ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( beep )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to beep channel: %08lX\n", ghBeep );

    /*
     * Open the command channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Command, NULL, &ghCommand ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( command )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to command channel: %08lX\n", ghCommand );

    /*
     * Open the cdm channel
     */
    if ( rc = IcaChannelOpen( ghIca, Channel_Virtual, VIRTUAL_CDM, &ghCdm ) ) {
        printf( "ICAKEY OpenStacks: Error 0x%x from IcaChannelOpen( VIRTUAL_CDM )", rc );
        goto done;
    }

    printf( "ICAKEY OpenStacks: Handle to cdm channel: %08lX\n", ghCdm );

done:
    return( rc );
}


/****************************************************************************
 *
 * CloseStacks
 *
 *   Close the ICA device driver, ICA stack, and ICA channels
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
CloseStacks( void )
{
    LONG rc = STATUS_SUCCESS;


    /*
     * Close the stop event handle
     */
    if ( ghStopEvent ) {
        CloseHandle( ghStopEvent );
    }

    /*
     * Kill the keyboard read thread
     */
    if ( ghThreadKeyboardRead ) {
        TerminateThread( ghThreadKeyboardRead, 0 );
        CloseHandle( ghThreadKeyboardRead );
    }

    /*
     * Close the keyboard channel
     */
    if ( ghKeyboard ) {
        if ( rc = IcaChannelClose( ghKeyboard ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Keyboard )\n", rc );
        }
    }

    /*
     * Close the mouse channel
     */
    if ( ghMouse ) {
        if ( rc = IcaChannelClose( ghMouse ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Mouse )\n", rc );
        }
    }

    /*
     * Close the video channel
     */
    if ( ghVideo ) {
        if ( rc = IcaChannelClose( ghVideo ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Video )\n", rc );
        }
    }

    /*
     * Close the beep channel
     */
    if ( ghBeep ) {
        if ( rc = IcaChannelClose( ghBeep ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Beep )\n", rc );
        }
    }

    /*
     * Close the command channel
     */
    if ( ghCommand ) {
        if ( rc = IcaChannelClose( ghCommand ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Command )\n", rc );
        }
    }

    /*
     * Close the cdm channel
     */
    if ( ghCdm ) {
        if ( rc = IcaChannelClose( ghCdm ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaChannelClose( Cdm )\n", rc );
        }
    }


    /*
     * Close the ICA stack instance
     */
    if ( ghStack ) {
        if ( rc = IcaStackClose( ghStack ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaStackClose\n", rc );
        }
    }


    /*
     * Close the ICA device driver instance
     */
    if ( ghIca ) {
        if ( rc = IcaClose( ghIca ) ) {
            printf( "ICAKEY CloseStacks: Error 0x%x from IcaClose\n", rc );
        }
    }

    return( rc );
}

/****************************************************************************
 *
 * Initialize
 *
 *   Do some initialization
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
Initialize( void ) 
{
    LONG  rc = STATUS_SUCCESS;
    DWORD tidKeyboardReadThread;
    THREADDATA ThreadData;

    /*
     * Create stop event to wait on later.
     */
    if ( !(ghStopEvent = CreateEvent( NULL, TRUE, FALSE, NULL )) ) {
        printf( "ICAKEY Initialize: Error 0x%x in CreateEvent\n", GetLastError() );
        goto done;
    }

    ThreadData.handle = ghKeyboard;

    /*
     * Startup the virtual channel read thread
     */
    if ( !(ghThreadKeyboardRead = CreateThread( NULL,
                                   KEYBOARD_THREAD_STACKSIZE,
                                   (LPTHREAD_START_ROUTINE)KeyboardReadThread,
                                   (LPVOID)&ThreadData, 0,
                                   (LPDWORD)&tidKeyboardReadThread )) ) {
        rc = GetLastError();
        printf( "ICAKEY Initialize: Error 0x%x creating keyboard read thread\n", rc );
        goto done;
    }

done:
    return( rc );
}

/*******************************************************************************
 *
 *  Function: KeyboardReadThread
 *
 *  Purpose: Keyboard read thread
 *
 *  Entry:
 *     pThreadData
 *        Pointer to thread creation data
 *
 *  Exit:
 *     void
 *
 ******************************************************************************/
VOID KeyboardReadThread( PTHREADDATA pThreadData )
{
    int                 rc;
    HANDLE              handle = pThreadData->handle;
    KEYBOARD_INPUT_DATA KeyboardInputData;
    DWORD               cbRead;
    OVERLAPPED          Overlapped;
    DWORD               dwError;
    int                 NumberRead = 0;

    Overlapped.Offset     = 0;
    Overlapped.OffsetHigh = 0;
    Overlapped.hEvent     = NULL;

    printf( "Keyboard read thread starting...\n" );

    /*
     * Now dedicate this thread to monitor the keyboard
     */
    do {
        cbRead = 0;
        
        if ( !ReadFile( ghKeyboard,
                        &KeyboardInputData,
                        sizeof( KeyboardInputData ),
                        &cbRead, &Overlapped ) ) {

            dwError = GetLastError();

            if ( dwError == ERROR_IO_PENDING ) {
	        // check on the results of the asynchronous read
	        if ( !GetOverlappedResult( ghKeyboard, &Overlapped, 
	   			       &cbRead, TRUE) ) { // wait for result
                    printf( "ICAKEY KeyboardReadThread: Error 0x%x from GetOverlappedResult( Channel_Keyboard )\n",
                            GetLastError() );
                    break;
                }
            }
	    else {

                printf( "ICAKEY KeyboardReadThread: Error 0x%x from ReadFile( Channel_Keyboard )\n",
                        dwError );
                break;
	    }
        }

        printf( "Unit number: 0x%x\nScan code: %02X\nFlags: %04X\nExtra info: %08X\n",
                KeyboardInputData.UnitId,
                KeyboardInputData.MakeCode,
                KeyboardInputData.Flags,
                KeyboardInputData.ExtraInformation );
        NumberRead++;

	if ( NumberRead == MAX_READ )
	    break;

    } while ( 1 );

    printf( "Keyboard read thread exiting...\n" );
    SetEvent( ghStopEvent );
    ExitThread( 0 );
}

/****************************************************************************
 *
 * KeyboardTest
 *
 *   Stuff some data into the keyboard channel for testing purposes
 *
 * ENTRY:
 *   void
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

LONG
KeyboardTest( void ) 
{
    LONG                rc = STATUS_SUCCESS;
    KEYBOARD_INPUT_DATA KeyboardInputData;
    ULONG               cbReturned;

    /*
     * Initialize the keystroke to fabricate
     */
    KeyboardInputData.UnitId           = 0;
    KeyboardInputData.MakeCode         = 0x32;  // Capital 'M'
    KeyboardInputData.Flags            = KEY_MAKE;
    KeyboardInputData.Reserved         = 0;
    KeyboardInputData.ExtraInformation = 0;

    /*
     * First stuff the make
     */
    if ( rc = IcaChannelIoControl( ghKeyboard,
                                   IOCTL_KEYBOARD_ICA_INPUT,
                                   &KeyboardInputData,
                                   sizeof( KeyboardInputData ),
                                   NULL,
                                   0,
                                   &cbReturned ) ) {
        printf( "ICAKEY KeyboardTest: Error 0x%x in IcaChannelIoControl\n", rc );
        goto done;
    }

    KeyboardInputData.Flags    = KEY_BREAK;

    /*
     * Now stuff the break
     */
    if ( rc = IcaChannelIoControl( ghKeyboard,
                                   IOCTL_KEYBOARD_ICA_INPUT,
                                   &KeyboardInputData,
                                   sizeof( KeyboardInputData ),
                                   NULL,
                                   0,
                                   &cbReturned ) ) {
        printf( "ICAKEY KeyboardTest: Error 0x%x in IcaChannelIoControl\n", rc );
        goto done;
    }

done:
    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <winsta.h>
#include <icadd.h>
#include <icaapi.h>

#include <stdio.h>
#include <stdarg.h>
#include <time.h>
#include <limits.h>

#include "icaapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\adcgbase.h ===
/****************************************************************************/
// adcgbase.h
//
// Common headers - portable include file. This is the main header which
// should be included by ALL files. It defines common and OS specific types
// and structures as well as including OS-specific headers.
//
// Copyright (C) 1997-1999 Microsoft Corporation
/****************************************************************************/
#ifndef _H_ADCGBASE
#define _H_ADCGBASE


/****************************************************************************/
/* Include basic type definitions.  Some of these may be OS-specific and    */
/* will be defined via a proxy header.                                      */
/****************************************************************************/
#include <adcgbtyp.h>

/****************************************************************************/
/* Include complex type definitions.  Some of these may be OS-specific and  */
/* will be defined via a proxy header.                                      */
/****************************************************************************/
#include <adcgctyp.h>

/****************************************************************************/
/* Include constants.                                                       */
/****************************************************************************/
#include <adcgcnst.h>

/****************************************************************************/
/* Include macros.                                                          */
/****************************************************************************/
#include <adcgmcro.h>

/****************************************************************************/
/* Include C runtime functions.                                             */
/****************************************************************************/
#include <adcgcfnc.h>

/****************************************************************************/
/* Include performance monitoring macros.                                   */
/****************************************************************************/
#include <adcgperf.h>

/****************************************************************************/
/* Include optional defines.                                                */
/****************************************************************************/
#include <aducdefs.h>

/****************************************************************************/
/* Include T.120 header files                                               */
/****************************************************************************/
#include <license.h>
#include <at128.h>
#include <at120ex.h>

//
// Use wide on CE leave unchange on other plats
//
#ifndef OS_WINCE
#define CE_WIDETEXT(x) (x)
#else
#define CE_WIDETEXT(x) _T(x)
#endif


#define SIZE_TCHARS(xx) sizeof(xx)/sizeof(TCHAR)

#ifndef SecureZeroMemory
#define SecureZeroMemory TsSecureZeroMemory
#endif

#if !defined(MIDL_PASS)
FORCEINLINE
PVOID
TsSecureZeroMemory(
    IN PVOID ptr, 
    IN SIZE_T cnt
    ) 
{
    volatile char *vptr = (volatile char *)ptr;
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
    return ptr;
}
#endif


#endif /* _H_ADCGBASE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\adcgbtyp.h ===
/****************************************************************************/
/* adcgbtyp.h                                                               */
/*                                                                          */
/* Basic types - portable                                                   */
/*                                                                          */
/* Copyright (C) 1997-1999 Microsoft Corporation                            */
/****************************************************************************/
#ifndef _H_ADCGBTYP
#define _H_ADCGBTYP


/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgbtyp.h>


/****************************************************************************/
/* Basic types abstracted from compiler built ins.                          */
/****************************************************************************/
#ifdef OS_WIN16
typedef short INT16;
typedef unsigned short UINT16;
typedef long INT32;
typedef unsigned long UINT32;
#define UNALIGNED
#endif

typedef unsigned long UNALIGNED FAR *PUINT32_UA;
typedef unsigned short UNALIGNED FAR *PUINT16_UA;
typedef UINT32 *PUINT32;


typedef int                            DCINT;
typedef signed char                    DCINT8;
typedef long                           DCINT32;

typedef unsigned int                   DCUINT;
typedef unsigned char                  DCUINT8;
typedef unsigned long                  DCUINT32;

#ifdef __midl
typedef long                           DCVOID;
#else
typedef void                           DCVOID;
#endif

typedef DCUINT                         DCBOOL;
typedef DCUINT16                       DCBOOL16;
typedef DCUINT32                       DCBOOL32;

typedef unsigned short UINT16;

#ifdef OS_WIN16
typedef unsigned long  UINT32;
#endif


/****************************************************************************/
/* Now derive further convenience types from system specific types.         */
/* First of all pointers to types.                                          */
/****************************************************************************/
typedef DCINT                DCPTR     PDCINT;
typedef DCINT8               DCPTR     PDCINT8;
typedef DCINT16              DCPTR     PDCINT16;
typedef DCINT32              DCPTR     PDCINT32;

typedef DCUINT               DCPTR     PDCUINT;
typedef DCUINT8              DCPTR     PDCUINT8;
typedef DCUINT16             DCPTR     PDCUINT16;
typedef DCUINT32             DCPTR     PDCUINT32;

typedef DCBOOL               DCPTR     PDCBOOL;
typedef DCBOOL16             DCPTR     PDCBOOL16;
typedef DCBOOL32             DCPTR     PDCBOOL32;
typedef DCVOID               DCPTR     PDCVOID;

/****************************************************************************/
/* Now define pointers to pointers of types.                                */
/****************************************************************************/
typedef PDCINT               DCPTR     PPDCINT;
typedef PDCINT8              DCPTR     PPDCINT8;
typedef PDCINT16             DCPTR     PPDCINT16;
typedef PDCINT32             DCPTR     PPDCINT32;

typedef PDCUINT              DCPTR     PPDCUINT;
typedef PDCUINT8             DCPTR     PPDCUINT8;
typedef PDCUINT16            DCPTR     PPDCUINT16;
typedef PDCUINT32            DCPTR     PPDCUINT32;

typedef PDCBOOL              DCPTR     PPDCBOOL;
typedef PDCBOOL16            DCPTR     PPDCBOOL16;
typedef PDCBOOL32            DCPTR     PPDCBOOL32;
typedef PDCVOID              DCPTR     PPDCVOID;

/****************************************************************************/
/* Define huge pointers to basic types.                                     */
/****************************************************************************/
typedef DCINT                DCHPTR    HPDCINT;
typedef DCINT8               DCHPTR    HPDCINT8;
typedef DCINT16              DCHPTR    HPDCINT16;
typedef DCINT32              DCHPTR    HPDCINT32;

typedef DCUINT               DCHPTR    HPDCUINT;
typedef DCUINT8              DCHPTR    HPDCUINT8;
typedef DCUINT16             DCHPTR    HPDCUINT16;
typedef DCUINT32             DCHPTR    HPDCUINT32;

typedef DCBOOL               DCHPTR    HPDCBOOL;
typedef DCBOOL16             DCHPTR    HPDCBOOL16;
typedef DCBOOL32             DCHPTR    HPDCBOOL32;
typedef DCVOID               DCHPTR    HPDCVOID;

/****************************************************************************/
/* Define pointers to huge pointers to types.                               */
/****************************************************************************/
typedef HPDCINT              DCPTR     PHPDCINT;
typedef HPDCINT8             DCPTR     PHPDCINT8;
typedef HPDCINT16            DCPTR     PHPDCINT16;
typedef HPDCINT32            DCPTR     PHPDCINT32;

typedef HPDCUINT             DCPTR     PHPDCUINT;
typedef HPDCUINT8            DCPTR     PHPDCUINT8;
typedef HPDCUINT16           DCPTR     PHPDCUINT16;
typedef HPDCUINT32           DCPTR     PHPDCUINT32;

typedef HPDCBOOL             DCPTR     PHPDCBOOL;
typedef HPDCBOOL16           DCPTR     PHPDCBOOL16;
typedef HPDCBOOL32           DCPTR     PHPDCBOOL32;
typedef HPDCVOID             DCPTR     PHPDCVOID;

/****************************************************************************/
/* Define unaligned pointers to types.                                      */
/****************************************************************************/
typedef DCINT    DCUNALIGNED DCPTR     PDCINT_UA;
typedef DCINT8   DCUNALIGNED DCPTR     PDCINT8_UA;
typedef DCINT16  DCUNALIGNED DCPTR     PDCINT16_UA;
typedef DCINT32  DCUNALIGNED DCPTR     PDCINT32_UA;

typedef DCUINT   DCUNALIGNED DCPTR     PDCUINT_UA;
typedef DCUINT8  DCUNALIGNED DCPTR     PDCUINT8_UA;
typedef DCUINT16 DCUNALIGNED DCPTR     PDCUINT16_UA;
typedef DCUINT32 DCUNALIGNED DCPTR     PDCUINT32_UA;

typedef DCBOOL   DCUNALIGNED DCPTR     PDCBOOL_UA;
typedef DCBOOL16 DCUNALIGNED DCPTR     PDCBOOL16_UA;
typedef DCBOOL32 DCUNALIGNED DCPTR     PDCBOOL32_UA;
typedef DCVOID   DCUNALIGNED DCPTR     PDCVOID_UA;

/****************************************************************************/
/* MCS/GCC use enumerations - we pretend they're longs                      */
/****************************************************************************/
typedef unsigned long                  DC_ENUM;


#if defined(OS_WIN16) || defined(OS_WINCE)
/****************************************************************************/
// Win16 types corresponding to new Win64/Win32 definitions.
/****************************************************************************/
typedef int INT_PTR;  // For dialog proc returns.
typedef unsigned UINT_PTR;  // On Win16 this is not exchangeable w/FAR *.
typedef long LONG_PTR;
typedef unsigned long ULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
#endif  // OS_WIN16


#endif /* _H_ADCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\acpudefs.h ===
/****************************************************************************/
/* Copyright(C) Microsoft Corporation 1998                                  */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/* CPU Cycle counter                                                        */
/*                                                                          */
/****************************************************************************/

#if defined(OS_WIN32) && !defined(DC_DEBUG) && defined(_M_IX86) && defined(PERF)
/****************************************************************************/
/*                                                                          */
/* CPU Cycle counter macros                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* variables used to store the count                                        */
/****************************************************************************/
#define MAX_FNS     12

/****************************************************************************/
/* Counter identifiers                                                      */
/****************************************************************************/
#define FC_MEM2SCRN_BITBLT      0
#define FC_DSTBLT_TYPE          1
#define FC_PATBLT_TYPE          2
#define FC_OPAQUERECT_TYPE      3
#define FC_SCRBLT_TYPE          4
#define FC_MEMBLT_TYPE          5
#define FC_LINETO_TYPE          6
#define FC_POLYLINE_TYPE        7
#define FC_INDEX_TYPE           8
#define FC_UHADDUPDATEREGION    9
#define FC_UHSETCLIPREGION      10
#define FC_UHPROCESSPALETTEPDU  11
#define FC_POLYGONSC_TYPE       12
#define FC_POLYGONCB_TYPE       13
#define FC_ELLIPSESC_TYPE       14
#define FC_ELLIPSECB_TYPE       15
#define FC_FAST_INDEX_TYPE      16
#define FC_FAST_GLYPH_TYPE      17

/****************************************************************************/
/* Routines to measure the count before and after                           */
/****************************************************************************/
#define TIMERSTART                     \
        {                              \
            unsigned long startHi;     \
            unsigned long startLo;     \
            unsigned long endHi;       \
            unsigned long endLo;       \
                                       \
            unsigned long timeLo;      \
            unsigned long timeHi;      \
                                       \
                                       \
            _asm mov eax,0             \
            _asm mov edx,0             \
                                       \
            _asm _emit 0Fh             \
            _asm _emit 31h             \
            _asm mov startHi, edx      \
            _asm mov startLo, eax      \

#define TIMERSTOP                      \
            _asm mov eax,0             \
            _asm mov edx,0             \
                                       \
            _asm _emit 0Fh             \
            _asm _emit 31h             \
            _asm mov endHi, edx        \
            _asm mov endLo, eax        \

#define UPDATECOUNTER(fn)                                       \
            callCount[fn]++;                                    \
                                                                \
            if (endLo < startLo)                                \
            {                                                   \
                timeLo = 0xFFFFFFFF - (startLo - endLo - 1);    \
                endHi--;                                        \
            }                                                   \
            else                                                \
            {                                                   \
                timeLo = endLo - startLo;                       \
            }                                                   \
                                                                \
            timeHi = endHi - startHi;                           \
                                                                \
            cycleCountLo[fn] = (unsigned long)(cycleCountLo[fn] + timeLo);\
                                                                \
            if (cycleCountLo[fn] < timeLo)                      \
            {                                                   \
                timeHi++;                                       \
            }                                                   \
                                                                \
            cycleCountHi[fn] += timeHi;                         \
        }

#define RESET_COUNTERS                         \
        {                                      \
            int idx;                           \
            for (idx = 0; idx < MAX_FNS; idx++)\
            {                                  \
                callCount[idx]    = 0;         \
                cycleCountHi[idx] = 0;         \
                cycleCountLo[idx] = 0;         \
            }                                  \
                                               \
            OutputDebugString(_T("Counters Reset\n"));   \
                                               \
        }                                      \

#define OUTPUT_COUNTERS                                                       \
        {                                                                     \
            int idx;                                                          \
            TCHAR result[80];                                                 \
            TCHAR fnNames[MAX_FNS][30] =                                      \
            {                                                                 \
              _T("BitmapRect sub order *"),                                   \
              _T("DSTBLT order"),                                             \
              _T("PATBLT order"),                                             \
              _T("OPAQUERECT order"),                                         \
              _T("SCRBLT order"),                                             \
              _T("MEMBLT order **"),                                          \
              _T("LINETO order **"),                                          \
              _T("POLYLINE order"),                                           \
              _T("INDEX (glyph) order *"),                                    \
              _T("UHAddUpdateRegion *"),                                      \
              _T("UHSetClipRegion *"),                                        \
              _T("UHProcessPalettePDU *"),                                    \
              _T("POLYGONSC order"),                                          \
              _T("POLYGONCB order"),                                          \
              _T("ELLIPSESC order"),                                          \
              _T("ELLIPSECB order"),                                          \
              _T("FASTINDEX order"),                                          \
              _T("FASTGLYPH order")                                       
            };                                                                \
                                                                              \
            OutputDebugString(_T("******************************************")\
                    _T("\n"));                                                \
            _stprintf(result, _T("%-29s %-6s %-12s %-12s\n"), _T("Operation"),\
                    _T("Hits"), _T("High cycles"), _T("Low cycles"));         \
                                                                              \
            OutputDebugString(result);                                        \
            for (idx = 0; idx < MAX_FNS; idx++)                               \
            {                                                                 \
                _stprintf(result, _T("%-29s %6lu %12lu %12lu\n"),             \
                       fnNames[idx], callCount[idx],                          \
                       cycleCountHi[idx], cycleCountLo[idx]);                 \
                OutputDebugString(result);                                    \
            }                                                                 \
            OutputDebugString(_T("******************************************")\
                    _T("\n"));                                                \
        }                                                                           \

#else

#define MAX_FNS
#define TIMERSTART
#define TIMERSTOP
#define UPDATECOUNTER(fn)

#define RESET_COUNTERS
#define OUTPUT_COUNTERS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\memory.c ===
/*******************************************************************************
* MEMORY.C
*
*   Memory allocation routines
*
* Copyright Citrix Systems Inc. 1996
* Copyright (C) 1997-1999 Microsoft Corp.
*
*   Author:   Brad Pedersen
******************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   External Functions Defined
=============================================================================*/
NTSTATUS IcaMemoryAllocate( ULONG, PVOID * );
VOID     IcaMemoryFree( PVOID );


/*=============================================================================
==   Internal Functions Defined
=============================================================================*/


/*******************************************************************************
 *
 *  IcaMemoryAllocate
 *
 *  This routine allocate a block of memory
 *
 *  ENTRY:
 *     Length (input)
 *        length of memory to allocate
 *     ppMemory (output)
 *        address to return pointer to memory
 *
 *  EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS 
IcaMemoryAllocate( ULONG Length, PVOID * ppMemory )
{
    ASSERT( Length > 0 );

    *ppMemory = LocalAlloc( 0, Length );
    if ( *ppMemory == NULL )
        return( STATUS_NO_MEMORY );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  IcaMemoryFree
 *
 *  This routine frees a block of memory allocated by "MemoryAllocate"
 *
 *  ENTRY:
 *     pMemory (output)
 *        pointer to memory to free
 *
 *  EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
IcaMemoryFree( PVOID pMemory )
{
    LocalFree( pMemory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\icaapi\stack.c ===
/*************************************************************************
* STACK.C
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*=============================================================================
==   Internal procedures defined
=============================================================================*/

NTSTATUS _IcaStackOpen( HANDLE hIca, HANDLE * phStack, ICA_OPEN_TYPE, PICA_TYPE_INFO );
NTSTATUS _IcaStackIoControlWorker( PSTACK pStack, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG );
NTSTATUS _IcaPushStackAndCreateEndpoint( PSTACK pStack, PWINSTATIONNAME,
                                         PWINSTATIONCONFIG2, PICA_STACK_ADDRESS,
                                         PICA_STACK_ADDRESS );
NTSTATUS _IcaPushStackAndOpenEndpoint( PSTACK pStack, PWINSTATIONNAME,
                                       PWINSTATIONCONFIG2, PVOID, ULONG );
NTSTATUS _IcaPushStack( PSTACK pStack, PWINSTATIONNAME, PWINSTATIONCONFIG2 );
NTSTATUS _IcaPushPd( PSTACK pStack, PWINSTATIONNAME, PWINSTATIONCONFIG2,
                     PDLLNAME, PPDCONFIG );
NTSTATUS _IcaPushWd( PSTACK pStack, PWINSTATIONNAME, PWINSTATIONCONFIG2 );
VOID     _IcaPopStack( PSTACK pStack );
NTSTATUS _IcaPopSd( PSTACK pStack );
NTSTATUS _IcaStackWaitForIca( PSTACK pStack, PWINSTATIONCONFIG2, BOOLEAN * );
void     _DecrementStackRef( IN PSTACK pStack );

/*=============================================================================
==   Procedures used
=============================================================================*/

NTSTATUS IcaMemoryAllocate( ULONG, PVOID * );
VOID     IcaMemoryFree( PVOID );
NTSTATUS _IcaOpen( PHANDLE hIca, PVOID, ULONG );
NTSTATUS _CdOpen( PSTACK pStack, PWINSTATIONCONFIG2 );
VOID     _CdClose( PSTACK pStack );



/****************************************************************************
 *
 * IcaStackOpen
 *
 *   Open an ICA stack
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *   Class (input)
 *     class (type) of stack
 *   pStackIoControlCallback (input)
 *     Pointer to StackIoControl callback procedure
 *   pCallbackContext (input)
 *     StackIoControl callback context value
 *   ppContext (output)
 *     Pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/


NTSTATUS
IcaStackOpen( IN HANDLE   hIca,
              IN STACKCLASS Class,
              IN PROC pStackIoControlCallback,
              IN PVOID pCallbackContext,
              OUT HANDLE * ppContext )
{
    ICA_TYPE_INFO TypeInfo;
    PSTACK pStack;
    NTSTATUS Status;


    /*
     *  Allocate Memory for stack context data structure
     */
    Status = IcaMemoryAllocate( sizeof(STACK), &pStack );
    if ( !NT_SUCCESS(Status) )
        goto badalloc;

    /*
     *  Zero STACK data structure
     */
    RtlZeroMemory( pStack, sizeof(STACK) );

    /*
     *  Initialize critical section
     */
    INITLOCK( &pStack->CritSec, Status );
    if ( !NT_SUCCESS( Status ) )
        goto badcritsec;

    /*
     *  Open stack handle to ica device driver
     */
    RtlZeroMemory( &TypeInfo, sizeof(TypeInfo) );
    TypeInfo.StackClass = Class;
    Status = _IcaStackOpen( hIca, &pStack->hStack, IcaOpen_Stack, &TypeInfo );
    if ( !NT_SUCCESS(Status) )
        goto badopen;

    /*
     * Save StackIoControl and Context callback values
     */
    pStack->pCallbackContext = pCallbackContext;
    pStack->pStackIoControlCallback = (PSTACKIOCONTROLCALLBACK)pStackIoControlCallback;

    *ppContext = pStack;

    TRACE(( hIca, TC_ICAAPI, TT_API1, "TSAPI: IcaStackOpen, type %u, success\n", Class ));

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badopen:
    DELETELOCK( &pStack->CritSec );

badcritsec:
    IcaMemoryFree( pStack );

badalloc:
    TRACE(( hIca, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackOpen, type %u, 0x%x\n", Class, Status ));
    *ppContext = NULL;
    return( Status );
}


/****************************************************************************
 *
 * IcaStackClose
 *
 *   Close an ICA stack
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackClose( IN HANDLE pContext )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackClose\n" ));

    /*
     *  Set closing flag
     */
    pStack->fClosing = TRUE;

    /*
     *  Unload stack
     */
    _IcaPopStack( pContext );

    /*
     *  Wait for reference count to go to zero before we continue
     */
    while ( pStack->RefCount > 0 ) {

        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack: waiting for refcount %d\n", pStack->RefCount ));

        pStack->hCloseEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pStack->hCloseEvent );

        UNLOCK( &pStack->CritSec );
        (void) WaitForSingleObject( pStack->hCloseEvent, INFINITE );
        LOCK( &pStack->CritSec );

        CloseHandle( pStack->hCloseEvent );
        pStack->hCloseEvent = NULL;
    }
    /*
     * Close the ICA device driver stack instance
     */
    Status = NtClose( pStack->hStack );
    pStack->hStack = NULL;

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );
    DELETELOCK( &pStack->CritSec );

    /*
     *  Free stack context memory
     */
    IcaMemoryFree( pContext );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackUnlock
 *
 *   Unlocks an ICA stack
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackUnlock( IN HANDLE pContext )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );
}


/****************************************************************************
 *
 * IcaStackTerminate
 *
 *   Prepare to close an ICA stack
 *   (unloads all stack drivers and marks stack as being closed)
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackTerminate( IN HANDLE pContext )
{
    PSTACK pStack;
    NTSTATUS Status = STATUS_SUCCESS;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackTerminate\n" ));

    /*
     *  Set closing flag
     */
    pStack->fClosing = TRUE;

    /*
     *  Unload stack
     */
    _IcaPopStack( pContext );

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    ASSERT( NT_SUCCESS(Status) );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackConnectionWait
 *
 *    Load template stack and wait for a connection
 *
 * NOTE: On an error the endpoint is closed and the stack is unloaded
 *
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to WinStation registry configuration data
 *   pAddress (input)
 *     Pointer to optional local address to wait on (or null)
 *   pEndpoint (output)
 *     Pointer to buffer to return connection endpoint (optional)
 *   BufferLength (input)
 *     length of endpoint data buffer
 *   pEndpointLength (output)
 *     pointer to return actual length of endpoint
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionWait( IN  HANDLE pContext,
                        IN  PWINSTATIONNAME pWinStationName,
                        IN  PWINSTATIONCONFIG2 pWinStationConfig,
                        IN  PICA_STACK_ADDRESS pAddress,
                        OUT PVOID pEndpoint,
                        IN  ULONG BufferLength,
                        OUT PULONG pEndpointLength )
{
    NTSTATUS Status;
    PSTACK pStack;
    BOOLEAN fStackLoaded;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  load template stack and create stack endpoint
     */
    if ( !(fStackLoaded = (BOOLEAN)pStack->fStackLoaded) ) {
        Status = _IcaPushStackAndCreateEndpoint( pStack,
                                                 pWinStationName,
                                                 pWinStationConfig,
                                                 pAddress,
                                                 NULL );
        if ( !NT_SUCCESS(Status) )
            goto badcreate;
    }

    /*
     *  Now wait for a connection.
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONNECTION_WAIT,
                                 NULL,
                                 0,
                                 pEndpoint,
                                 BufferLength,
                                 pEndpointLength );
    if ( !NT_SUCCESS(Status) )
        goto badwait;

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionWait, success\n" ));

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/
    /*
     * If the stack wasn't already loaded,
     * then pop all stack drivers now.
     */
badwait:
    if ( !fStackLoaded ) {
        _IcaPopStack( pContext );
    }

badcreate:
    *pEndpointLength = 0;
    memset( pEndpoint, 0, BufferLength );
    TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionWait, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackConnectionRequest
 *
 *   Load query stack and try to make a connection with the client
 *
 * NOTE: On an error the endpoint is NOT closed and the stack is unloaded
 *
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pAddress (input)
 *     address to connect to (remote address)
 *   pEndpoint (output)
 *     Pointer to buffer to return connection endpoint (optional)
 *   BufferLength (input)
 *     length of endpoint data buffer
 *   pEndpointLength (output)
 *     pointer to return actual length of endpoint
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionRequest( IN  HANDLE pContext,
                           IN  PWINSTATIONNAME pWinStationName,
                           IN  PWINSTATIONCONFIG2 pWinStationConfig,
                           IN  PICA_STACK_ADDRESS pAddress,
                           OUT PVOID pEndpoint,
                           IN  ULONG BufferLength,
                           OUT PULONG pEndpointLength )
{
    ULONG ReturnLength;
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Load template Stack
     */
    Status = _IcaPushStack( pContext, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) )
        goto badpush;

    /*
     *  Now initiate a connection to the specified address
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONNECTION_REQUEST,
                                 pAddress,
                                 sizeof(*pAddress),
                                 pEndpoint,
                                 BufferLength,
                                 pEndpointLength );
    if ( !NT_SUCCESS(Status) )
        goto badrequest;

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionRequest, success\n" ));

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badrequest:
    /* pop all stack drivers */
    _IcaPopStack( pContext );

badpush:
    *pEndpointLength = 0;
    memset( pEndpoint, 0, BufferLength );
    TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionRequest, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackConnectionAccept
 *
 *   Load final stack and complete the connection
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *     - this can be different from the initially connecting stack
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pEndpoint (input)
 *     pointer to endpoint data
 *   EndpointLength (input)
 *     Length of endpoint
 *   pStackState (input) (optional)
 *     Set if this Accept is for a re-connection
 *     Points to ICA_STACK_STATE_HEADER buffer returned by IcaStackQueryState
 *   BufferLength (input)
 *     Length of pStackState buffer
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionAccept( IN  HANDLE hIca,
                          IN  HANDLE pContext,
                          IN  PWINSTATIONNAME pWinStationName,
                          IN  PWINSTATIONCONFIG2 pWinStationConfig,
                          IN  PVOID pEndpoint,
                          IN  ULONG EndpointLength,
                          IN  PICA_STACK_STATE_HEADER pStackState,
                          IN  ULONG BufferLength,
                          IN  PICA_TRACE pTrace )
{
    NTSTATUS Status;
    ULONG cbReturned;
    ICA_STACK_CONFIG IcaStackConfig;
    BOOLEAN fQueryAgain;
    BOOLEAN fStackModified;
    ULONG i;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Verify parameters
     */
    if ( pEndpoint == NULL )
        return( STATUS_INVALID_PARAMETER );

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Check if we need to load and open the template stack again
     */
    if ( !pStack->fStackLoaded ) {
        Status = _IcaPushStackAndOpenEndpoint( pContext,
                                               pWinStationName,
                                               pWinStationConfig,
                                               pEndpoint,
                                               EndpointLength );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         * Enable trace now that the WD is loaded
         */

        IcaIoControl( hIca,
                      IOCTL_ICA_SET_TRACE,
                      pTrace,
                      sizeof ( ICA_TRACE ),
                      NULL,
                      0,
                      NULL );

    }

    /*
     *  If this is a reconnect, then issue set stack state call
     *  now that we have loaded the required PDs.
     */
    if ( pStackState ) {
        Status = _IcaStackIoControl( pStack,
                                     IOCTL_ICA_STACK_SET_STATE,
                                     pStackState,
                                     BufferLength,
                                     NULL,
                                     0,
                                     NULL );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

    /*
     * If this is not a re-connect of a previous session, then
     * prepare the stack for initial negotiation with the client.
     */
    } else {
        ICA_STACK_CONFIG_DATA ConfigData;

        memset(&ConfigData, 0, sizeof(ICA_STACK_CONFIG_DATA));
        ConfigData.colorDepth = pWinStationConfig->Config.User.ColorDepth;
        ConfigData.fDisableEncryption = pWinStationConfig->Config.User.fDisableEncryption;
        ConfigData.encryptionLevel = pWinStationConfig->Config.User.MinEncryptionLevel;
        ConfigData.fDisableAutoReconnect = pWinStationConfig->Config.User.fDisableAutoReconnect;


        /*
         *  Send the config data to stack driver
         */
        _IcaStackIoControl( pStack,
                            IOCTL_ICA_STACK_SET_CONFIG,
                            &ConfigData,
                            sizeof(ICA_STACK_CONFIG_DATA),
                            NULL,
                            0,
                            NULL);


        /*
         *  Wait for ICA Detect string from client
         */
        Status = _IcaStackWaitForIca( pContext,
                                      pWinStationConfig,
                                      &fStackModified );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         *  Check if the query stack is different than the template stack
         */
        if ( fStackModified ) {

            TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept, load query stack\n"));
            ASSERT(FALSE);

#ifdef notdef
            /*
             *  Unload all stack drivers except the transport
             *  and connection drivers
             *            -- we can not pop the td or cd
             *            -- we can not issue a cancel i/o
             */
            _IcaPopStack( pContext );

            /*
             *  Load and open the new query stack
             */
            Status = _IcaPushStackAndOpenEndpoint( pContext,
                                                   pWinStationName,
                                                   pWinStationConfig,
                                                   pEndpoint,
                                                   EndpointLength );
            if ( !NT_SUCCESS(Status) ) {
                goto badaccept;
            }
#endif
        }
    }


    /*
     * At this point the stack is now set up (again).  The client is
     * now queried for any configuration changes.
     *
     *  - repeat this loop until WD does not change
     */
    do {

        /*
         *  Clear query again flag
         */
        fQueryAgain = FALSE;

        /*
         * Query the client for the optional PD's
         */
        Status = _IcaStackIoControl( pStack,
                                     IOCTL_ICA_STACK_CONNECTION_QUERY,
                                     NULL,
                                     0,
                                     &IcaStackConfig,
                                     sizeof(IcaStackConfig),
                                     &cbReturned );

        if ( !NT_SUCCESS(Status) ) {
            TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionAccept: IOCTL_ICA_STACK_CONNECTION_QUERY, 0x%x\n", Status ));
            goto badaccept;
        }

        if ( cbReturned != sizeof(IcaStackConfig) ) {
            TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionAccept: Bad size %d from IOCTL_ICA_STACK_CONNECTION_QUERY\n", cbReturned ));
            Status = STATUS_INVALID_BUFFER_SIZE;
            goto badaccept;
        }

        TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept: IOCTL_ICA_STACK_CONNECTION_QUERY success\n" ));

        /*
         * If the WD changed we must load it (and the rest of the stack) and
         * reissue the query.
         */
        if ( _wcsnicmp( IcaStackConfig.WdDLL,
                        pWinStationConfig->Wd.WdDLL,
                        DLLNAME_LENGTH ) ) {

            TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept WD changing from %S to %S\n", pWinStationConfig->Wd.WdDLL, IcaStackConfig.WdDLL ));

            memcpy( pWinStationConfig->Wd.WdDLL,
                    IcaStackConfig.WdDLL,
                    sizeof( pWinStationConfig->Wd.WdDLL ) );

            fQueryAgain = TRUE;
        }

        /*
         *  If no new modules were requested, we are done querying
         */
        if ( !fQueryAgain && (IcaStackConfig.SdClass[0] == SdNone) )
            break;

        /*
         * Pop the WD to load new PD's underneath.
         */
        Status = _IcaPopSd( pContext );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         * Push Optional PD's
         */
        for ( i=0; i < SdClass_Maximum; i++ ) {

            if ( IcaStackConfig.SdClass[i] == SdNone )
                break;

            Status = _IcaPushPd( pContext,
                                 pWinStationName,
                                 pWinStationConfig,
                                 IcaStackConfig.SdDLL[i],
                                 &pWinStationConfig->Pd[0] );

            /*
             *  If the PD driver is not found, the client is using an optional
             *  PD that is not supported by the host.  Continue loading and let
             *  the client and server negoatiate the connection.
             */
            if ( !NT_SUCCESS(Status) && (Status != STATUS_OBJECT_NAME_NOT_FOUND) ) {
                goto badaccept;
            }
        }

        /*
         * Re-push the WD
         */
        Status = _IcaPushWd( pContext, pWinStationName, pWinStationConfig );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }

        /*
         * Re-Enable trace now that the WD is loaded
         */
        IcaIoControl( hIca,
                      IOCTL_ICA_SET_TRACE,
                      pTrace,
                      sizeof ( ICA_TRACE ),
                      NULL,
                      0,
                      NULL );

    } while ( fQueryAgain );

    /*
     *  If this is a reconnect, then issue set stack state call
     *  now that we have loaded the optional PDs.
     */
    if ( pStackState ) {
        Status = _IcaStackIoControl( pStack,
                                     IOCTL_ICA_STACK_SET_STATE,
                                     pStackState,
                                     BufferLength,
                                     NULL,
                                     0,
                                     NULL );
        if ( !NT_SUCCESS(Status) ) {
            goto badaccept;
        }
    }

    /*
     *  Send host module data to client
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONNECTION_SEND,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 NULL );
    if ( !NT_SUCCESS(Status) )
        goto badaccept;

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionAccept, success\n" ));

    /*
     *  Leave the critical section locked because the protocol sequence has
     *	not been finished. The sequence will be finished by the licensing core
     *	in termsrv.exe, and the critical section will be unlocked at that point.
     */
    //UNLOCK( &pStack->CritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badaccept:
    /* pop all stack drivers */
    _IcaPopStack( pContext );

    TRACESTACK(( pContext, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackConnectionAccept, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackQueryState
 *
 *   Query stack driver state information
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *     - this can be different from the initially connecting stack
 *
 *   pStackState (output)
 *     pointer to buffer to return stack state information
 *
 *   BufferLength (input)
 *     Length of pStackState buffer
 *
 *   pStateLength (output)
 *     length of returned stack state information
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackQueryState( IN HANDLE pContext,
                    OUT PICA_STACK_STATE_HEADER pStackState,
                    IN ULONG BufferLength,
                    OUT PULONG pStateLength )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Query state
     */
    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_QUERY_STATE,
                                 NULL,
                                 0,
                                 pStackState,
                                 BufferLength,
                                 pStateLength );

    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackQueryState, 0x%x\n", Status ));

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( Status );
}


/****************************************************************************
 *
 * IcaStackCreateShadowEndpoint
 *
 *    Load template stack and create the endpoint
 *
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pAddressIn (input)
 *     Pointer to local address of endpoint to create
 *   pAddressOut (output)
 *     Pointer to location to return address of endpoint created
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackCreateShadowEndpoint( HANDLE pContext,
                              PWINSTATIONNAME pWinStationName,
                              PWINSTATIONCONFIG2 pWinStationConfig,
                              PICA_STACK_ADDRESS pAddressIn,
                              PICA_STACK_ADDRESS pAddressOut )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  load template stack and create stack endpoint
     */
    if ( pStack->fStackLoaded ) {
        Status = STATUS_ADDRESS_ALREADY_ASSOCIATED;
    } else {
        Status = _IcaPushStackAndCreateEndpoint( pStack,
                                                 pWinStationName,
                                                 pWinStationConfig,
                                                 pAddressIn,
                                                 pAddressOut );
    }

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    if ( !NT_SUCCESS( Status ) ) {
        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: IcaStackCreateShadowEndpoint, success\n" ));
    } else {
        TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: IcaStackCreateShadowEndpoint, 0x%x\n", Status ));
    }

    return( Status );
}


/****************************************************************************
 *
 * IcaStackConnectionClose
 *
 *   Close the connection endpoint
 *
 *   This is the only way to close the connecting connection.
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pEndpoint (input)
 *     Structure defining connection endpoint
 *   EndpointLength (input)
 *     Length of endpoint
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackConnectionClose( IN  HANDLE pContext,
                         IN  PWINSTATIONCONFIG2 pWinStationConfig,
                         IN  PVOID pEndpoint,
                         IN  ULONG EndpointLength
                       )
{
    ULONG cbReturned;
    NTSTATUS Status;
    PSTACK pStack;
    BOOLEAN fPopStack = FALSE;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  If necessary, load the template stack
     *  - we can't issue ioctls without a stack
     */
    if ( !pStack->fStackLoaded ) {

        /*
         *  Load and open the template stack
         */
        Status = _IcaPushStackAndOpenEndpoint( pContext,
                                               TEXT(""),
                                               pWinStationConfig,
                                               pEndpoint,
                                               EndpointLength );
        if ( !NT_SUCCESS(Status) ) {
            goto badclose;
        }

        fPopStack = TRUE;   // remember we have to pop the stack below
    }

    /*
     *  Close endpoint
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CLOSE_ENDPOINT,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 NULL );

    /*
     *  Pop stack drivers if we loaded them above
     */
    if ( fPopStack )
        _IcaPopStack( pContext );

badclose:
    TRACESTACK(( pContext, TC_ICAAPI, TT_API1, "TSAPI: IcaStackConnectionClose, 0x%x\n", Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackCallback
 *
 *   dial specified phone number and make connection to client
 *
 * NOTE: On an error the endpoint is NOT closed and the stack is unloaded
 *
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pPhoneNumber (input)
 *     pointer to client phone number
 *   pEndpoint (output)
 *     Pointer to buffer to return connection endpoint
 *   BufferLength (input)
 *     length of endpoint data buffer
 *   pEndpointLength (output)
 *     pointer to return actual length of endpoint
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   STATUS_BUFFER_TOO_SMALL - endpoint buffer is too small (use *pEndpointLength)
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackCallback( IN  HANDLE pContext,
                  IN  PWINSTATIONCONFIG2 pWinStationConfig,
                  IN  WCHAR * pPhoneNumber,
                  OUT PVOID pEndpoint,
                  IN  ULONG BufferLength,
                  OUT PULONG pEndpointLength )
{
    NTSTATUS Status;
    ICA_STACK_CALLBACK Cb;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    wcscpy( Cb.PhoneNumber, pPhoneNumber );

    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_CALLBACK_INITIATE,
                                 &Cb,
                                 sizeof(Cb),
                                 pEndpoint,
                                 BufferLength,
                                 pEndpointLength );


    TRACESTACK(( pContext, TC_ICAAPI, TT_API1,
                 "TSAPI: IcaStackCallback: %S, 0x%x\n",
                 pPhoneNumber, Status ));
    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackDisconnect
 *
 *   Disconnect the specified stack from its ICA connection
 *
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *   hIca (input)
 *     handle to temp ICA connection
 *   pCallbackContext (input)
 *     New StackIoControl callback context value
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackDisconnect(
    HANDLE pContext,
    HANDLE hIca,
    PVOID pCallbackContext
    )
{
    PSTACK pStack;
    ICA_STACK_RECONNECT IoctlReconnect;
    NTSTATUS Status;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    IoctlReconnect.hIca = hIca;
    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_DISCONNECT,
                                 &IoctlReconnect,
                                 sizeof(IoctlReconnect),
                                 NULL,
                                 0,
                                 NULL );
    if ( NT_SUCCESS( Status ) ) {
        pStack->pCallbackContext = pCallbackContext;
    }

    UNLOCK( &pStack->CritSec );
    return( Status );
}


/****************************************************************************
 *
 * IcaStackReconnect
 *
 *   Reconnect the specified stack to a new ICA connection
 *
 *
 * ENTRY:
 *
 *   pContext (input)
 *     pointer to ICA stack context
 *   hIca (input)
 *     handle to temp ICA connection
 *   pCallbackContext (input)
 *     New StackIoControl callback context value
 *   sessionId (input)
 *     Session ID of the Winstation we are reconnecting to
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackReconnect(
    HANDLE pContext,
    HANDLE hIca,
    PVOID pCallbackContext,
    ULONG sessionId
    )
{
    PSTACK pStack;
    ICA_STACK_RECONNECT IoctlReconnect;
    PVOID SaveContext;
    NTSTATUS Status;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    SaveContext = pStack->pCallbackContext;
    pStack->pCallbackContext = pCallbackContext;

    IoctlReconnect.hIca = hIca;
    IoctlReconnect.sessionId = sessionId;
    Status = _IcaStackIoControl( pContext,
                                 IOCTL_ICA_STACK_RECONNECT,
                                 &IoctlReconnect,
                                 sizeof(IoctlReconnect),
                                 NULL,
                                 0,
                                 NULL );
    if ( !NT_SUCCESS( Status ) ) {
        pStack->pCallbackContext = SaveContext;
    }

    UNLOCK( &pStack->CritSec );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaStackTrace
 *
 *  Write a trace record to the winstation trace file
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   TraceClass (input)
 *     trace class bit mask
 *   TraceEnable (input)
 *     trace type bit mask
 *   Format (input)
 *     format string
 *   ...  (input)
 *     enough arguments to satisfy format string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID cdecl
IcaStackTrace( IN HANDLE pContext,
               IN ULONG TraceClass,
               IN ULONG TraceEnable,
               IN char * Format,
               IN ... )
{
    ICA_TRACE_BUFFER Buffer;
    va_list arg_marker;
    ULONG Length;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    va_start( arg_marker, Format );

    Length = (ULONG) _vsnprintf( Buffer.Data, sizeof(Buffer.Data), Format, arg_marker ) + 1;

    Buffer.TraceClass  = TraceClass;
    Buffer.TraceEnable = TraceEnable;
    Buffer.DataLength  = Length;
    if (pStack->hStack != NULL) {
        (void) IcaIoControl( pStack->hStack,
                             IOCTL_ICA_STACK_TRACE,
                             &Buffer,
                             sizeof(Buffer) - sizeof(Buffer.Data) + Length,
                             NULL,
                             0,
                             NULL );
    }

}


/****************************************************************************
 *
 * IcaStackIoControl
 *
 *   Generic interface to an ICA stack  (with locking)
 *
 * ENTRY:
 *   pContext (input)
 *     pointer to ICA stack context
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaStackIoControl( IN HANDLE pContext,
                   IN ULONG IoControlCode,
                   IN PVOID pInBuffer,
                   IN ULONG InBufferSize,
                   OUT PVOID pOutBuffer,
                   IN ULONG OutBufferSize,
                   OUT PULONG pBytesReturned )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Lock critical section
     */
    LOCK( &pStack->CritSec );

    /*
     *  Call worker routine
     */
    Status = _IcaStackIoControlWorker( pContext,
                                       IoControlCode,
                                       pInBuffer,
                                       InBufferSize,
                                       pOutBuffer,
                                       OutBufferSize,
                                       pBytesReturned );

    /*
     *  Unlock critical section
     */
    UNLOCK( &pStack->CritSec );

    return( Status );
}


/****************************************************************************
 *
 * IcaPushConsoleStack
 *
 *   Load initial stack
 *
 *       stack push for each stack driver
 *           in order td - pd - wd
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
IcaPushConsoleStack( IN HANDLE pContext,
                     IN PWINSTATIONNAME pWinStationName,
                     IN PWINSTATIONCONFIG2 pWinStationConfig,
                     IN PVOID pModuleData,
                     IN ULONG ModuleDataLength )
{
    NTSTATUS Status;
    PSTACK   pStack;
    ULONG cbReturned;
    ULONG i;

    pStack = (PSTACK) pContext;

    LOCK( &pStack->CritSec );

    /*
     * build the stack
     */
    Status = _IcaPushStack( pStack,
                            pWinStationName,
                            pWinStationConfig);


    if ( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "IcaPushConsoleStack _IcaPushStack failed\n"));
        goto failure;
    }

    /*
     * and now set up the connection to the console
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CONSOLE_CONNECT,
                                 pModuleData,
                                 ModuleDataLength,
                                 NULL,
                                 0,
                                 &cbReturned );

    if ( !NT_SUCCESS(Status) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "IcaPushConsoleStack - stack wait failed\n"));
        goto failure;
    }

    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "IcaPushConsoleStack - done stack wait\n"));

failure:
    UNLOCK( &pStack->CritSec );

    return( Status );
}


/****************************************************************************
 *
 * _IcaStackOpen
 *
 *   Open an ICA stack or an ICA channel
 *
 * ENTRY:
 *   hIca (input)
 *     ICA instance handle
 *
 *   phStack (output)
 *     Pointer to ICA stack or channel handle
 *
 *   OpenType (input)
 *     ICA open type
 *
 *   pTypeInfo (input)
 *     Pointer to ICA type info
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackOpen( HANDLE   hIca,
               HANDLE * phStack,
               ICA_OPEN_TYPE OpenType,
               PICA_TYPE_INFO pTypeInfo )
{
    NTSTATUS                  Status;
    PFILE_FULL_EA_INFORMATION pEa = NULL;
    ICA_OPEN_PACKET UNALIGNED * pIcaOpenPacket;
    ULONG                     cbEa = sizeof( FILE_FULL_EA_INFORMATION )
                                   + ICA_OPEN_PACKET_NAME_LENGTH
                                   + sizeof( ICA_OPEN_PACKET );


    /*
     * Allocate some memory for the EA buffer
     */
    Status = IcaMemoryAllocate( cbEa, &pEa );
    if ( !NT_SUCCESS(Status) )
        goto done;

    /*
     * Initialize the EA buffer
     */
    pEa->NextEntryOffset = 0;
    pEa->Flags           = 0;
    pEa->EaNameLength    = ICA_OPEN_PACKET_NAME_LENGTH;
    memcpy( pEa->EaName, ICAOPENPACKET, ICA_OPEN_PACKET_NAME_LENGTH + 1 );

    pEa->EaValueLength   = sizeof( ICA_OPEN_PACKET );
    pIcaOpenPacket       = (ICA_OPEN_PACKET UNALIGNED *)(pEa->EaName +
                                                          pEa->EaNameLength + 1);

    /*
     * Now put the open packe parameters into the EA buffer
     */
    pIcaOpenPacket->IcaHandle = hIca;
    pIcaOpenPacket->OpenType  = OpenType;
    pIcaOpenPacket->TypeInfo  = *pTypeInfo;


    Status = _IcaOpen( phStack, pEa, cbEa );

done:
    if ( pEa ) {
        IcaMemoryFree( pEa );
    }

    return( Status );
}


/****************************************************************************
 *
 * _IcaStackIoControl
 *
 *   Local (ICAAPI) interface to an ICA stack through callback routine
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackIoControl( IN HANDLE pContext,
                    IN ULONG IoControlCode,
                    IN PVOID pInBuffer,
                    IN ULONG InBufferSize,
                    OUT PVOID pOutBuffer,
                    IN ULONG OutBufferSize,
                    OUT PULONG pBytesReturned )
{
    NTSTATUS Status;
    PSTACK pStack;

    pStack = (PSTACK) pContext;

    /*
     *  Call callback function to handle StackIoControl
     */
    if ( pStack->pStackIoControlCallback ) {

        /*
         *  Unlock critical section
         */
        pStack->RefCount++;
        UNLOCK( &pStack->CritSec );

        Status = pStack->pStackIoControlCallback(
                            pStack->pCallbackContext,
                            pStack,
                            IoControlCode,
                            pInBuffer,
                            InBufferSize,
                            pOutBuffer,
                            OutBufferSize,
                            pBytesReturned );

        /*
         *  Re-lock critical section
         */
        LOCK( &pStack->CritSec );
        _DecrementStackRef( pStack );

    } else {

        Status = _IcaStackIoControlWorker( pStack,
                                           IoControlCode,
                                           pInBuffer,
                                           InBufferSize,
                                           pOutBuffer,
                                           OutBufferSize,
                                           pBytesReturned );
    }

    return( Status );
}


/****************************************************************************
 *
 * _IcaStackIoControlWorker
 *
 *   Private worker interface to an ICA stack
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   IoControlCode (input)
 *     I/O control code
 *   pInBuffer (input)
 *     Pointer to input parameters
 *   InBufferSize (input)
 *     Size of pInBuffer
 *   pOutBuffer (output)
 *     Pointer to output buffer
 *   OutBufferSize (input)
 *     Size of pOutBuffer
 *   pBytesReturned (output)
 *     Pointer to number of bytes returned
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackIoControlWorker( IN PSTACK pStack,
                          IN ULONG IoControlCode,
                          IN PVOID pInBuffer,
                          IN ULONG InBufferSize,
                          OUT PVOID pOutBuffer,
                          IN ULONG OutBufferSize,
                          OUT PULONG pBytesReturned )
{
    NTSTATUS Status;

    if ( pStack->pCdIoControl ) {

        /*
         *  Call connection driver, CD will call ICA device driver
         */
        Status = (*pStack->pCdIoControl)( pStack->pCdContext,
                                          IoControlCode,
                                          pInBuffer,
                                          InBufferSize,
                                          pOutBuffer,
                                          OutBufferSize,
                                          pBytesReturned );

        if ( pStack->fClosing && (IoControlCode != IOCTL_ICA_STACK_POP) )
            Status = STATUS_CTX_CLOSE_PENDING;

    } else {

        /*
         *  Unlock critical section
         */
        pStack->RefCount++;
        UNLOCK( &pStack->CritSec );

        /*
         *  Call ICA device driver directly
         *  - this stack does not have a connection driver
         */
        Status = IcaIoControl( pStack->hStack,
                               IoControlCode,
                               pInBuffer,
                               InBufferSize,
                               pOutBuffer,
                               OutBufferSize,
                               pBytesReturned );

        /*
         *  Re-lock critical section
         */
        LOCK( &pStack->CritSec );
        _DecrementStackRef( pStack );
    }

    return( Status );
}


/****************************************************************************
 *
 * _IcaPushStackAndCreateEndpoint
 *
 *   Load and create stack endpoint
 *
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pInAddress (input)
 *     pointer to address to use (optional)
 *   pOutAddress (output)
 *     pointer to location to return final address (optional)
 *
 *
 * EXIT:
 *   STATUS_SUCCESS          - Success
 *   other                   - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushStackAndCreateEndpoint( IN PSTACK pStack,
                                IN PWINSTATIONNAME pWinStationName,
                                IN PWINSTATIONCONFIG2 pWinStationConfig,
                                IN PICA_STACK_ADDRESS pInAddress,
                                OUT PICA_STACK_ADDRESS pOutAddress )
{
    ULONG BytesReturned;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Load template Stack
     */
    Status = _IcaPushStack( pStack, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) ) {
        goto badpush;
    }

    /*
     * Open the transport driver endpoint
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_CREATE_ENDPOINT,
                                 pInAddress,
                                 pInAddress ? sizeof(*pInAddress) : 0,
                                 pOutAddress,
                                 pOutAddress ? sizeof(*pOutAddress) : 0,
                                 &BytesReturned );
    if ( !NT_SUCCESS(Status) ) {
        goto badendpoint;
    }


    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushStackAndCreateEndpoint, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badendpoint:
    /* pop all stack drivers */
    _IcaPopStack( pStack );

badpush:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaPushStackAndCreateEndpoint, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPushStackAndOpenEndpoint
 *
 *   Load and open stack endpoint
 *
 *
 * ENTRY:
 *
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pEndpoint (input)
 *     Structure defining connection endpoint
 *   EndpointLength (input)
 *     Length of endpoint
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushStackAndOpenEndpoint( IN PSTACK pStack,
                              IN PWINSTATIONNAME pWinStationName,
                              IN PWINSTATIONCONFIG2 pWinStationConfig,
                              IN PVOID pEndpoint,
                              IN ULONG EndpointLength )
{
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Load the template stack again
     */
    Status = _IcaPushStack( pStack, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) ) {
        goto badpush;
    }

    /*
     *  Give open endpoint to the transport driver
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_OPEN_ENDPOINT,
                                 pEndpoint,
                                 EndpointLength,
                                 NULL,
                                 0,
                                 NULL );
    if ( !NT_SUCCESS(Status) ) {
        goto badendpoint;
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushStackAndOpenEndpoint, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badendpoint:
    /* pop all stack drivers */
    _IcaPopStack( pStack );

badpush:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaPushStackAndOpenEndpoint, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPushStack
 *
 *   Load initial stack
 *
 *       stack push for each stack driver
 *           in order td - pd - wd
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushStack( IN PSTACK pStack,
               IN PWINSTATIONNAME pWinStationName,
               IN PWINSTATIONCONFIG2 pWinStationConfig )
{
    PPDCONFIG pPdConfig;
    NTSTATUS Status;
    ULONG i;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Load and open connection driver
     */
    Status = _CdOpen( pStack, pWinStationConfig );
    if ( !NT_SUCCESS(Status) )
        goto badcdopen;

    /*
     *  Load PD(s)
     */
    pPdConfig = &pWinStationConfig->Pd[0];
    for ( i = 0; i < MAX_PDCONFIG; i++, pPdConfig++ ) {

        if ( pPdConfig->Create.SdClass == SdNone )
            break;

        /*
         * Do the push.
         */
        Status = _IcaPushPd( pStack,
                             pWinStationName,
                             pWinStationConfig,
                             pPdConfig->Create.PdDLL,
                             pPdConfig );
        if ( !NT_SUCCESS( Status ) ) {
            goto badpdpush;
        }

        if ( pStack->fClosing ) {
            goto stackclosing;
        }
    }

    /*
     *  Push the WD.
     */
    Status = _IcaPushWd( pStack, pWinStationName, pWinStationConfig );
    if ( !NT_SUCCESS(Status) )
        goto badwdpush;

    if ( pStack->fClosing ) {
        goto stackclosing;
    }

    /*
     *  Set stack loaded flag
     */
    pStack->fStackLoaded = TRUE;

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushStack, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badwdpush:
badpdpush:
    /* pop all stack drivers */
    _IcaPopStack( pStack );

badcdopen:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaPushStack, 0x%x\n", Status ));
    return( Status );

stackclosing:
    /*
     *  Unload all stack drivers
     */
    while ( _IcaPopSd( pStack ) == STATUS_SUCCESS ) {;}

    return( STATUS_CTX_CLOSE_PENDING );
}


/****************************************************************************
 *
 * _IcaPushPd
 *
 *   Push a PD module.
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *   pDllName (input)
 *     Name of module to push
 *   pPdConfig (input)
 *     pointer to configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushPd( IN PSTACK pStack,
            IN PWINSTATIONNAME pWinStationName,
            IN PWINSTATIONCONFIG2 pWinStationConfig,
            IN PDLLNAME pDllName,
            IN PPDCONFIG pPdConfig )
{
    ICA_STACK_PUSH IcaStackPush;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushPd, %S\n", pDllName ));

    memset( &IcaStackPush, 0, sizeof(IcaStackPush) );

    IcaStackPush.StackModuleType = Stack_Module_Pd;

    ASSERT( pDllName[0] );

    memcpy( IcaStackPush.StackModuleName, pDllName,
            sizeof( IcaStackPush.StackModuleName ) );

#ifndef _HYDRA_
//    wcscat( IcaStackPush.StackModuleName, ICA_SD_MODULE_EXTENTION );
#endif

    memcpy( IcaStackPush.OEMId,
            pWinStationConfig->Config.OEMId,
            sizeof(pWinStationConfig->Config.OEMId) );

    IcaStackPush.WdConfig = pWinStationConfig->Wd;
    IcaStackPush.PdConfig = *pPdConfig;

    memcpy( IcaStackPush.WinStationRegName,
            pWinStationName,
            sizeof(IcaStackPush.WinStationRegName) );

    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_PUSH,
                                 &IcaStackPush,
                                 sizeof( IcaStackPush ),
                                 NULL,
                                 0,
                                 NULL );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushPd, %S, 0x%x\n", pDllName, Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPushWd
 *
 *   Push a WD module.
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationName (input)
 *     registry name of WinStation
 *   pWinStationConfig (input)
 *     pointer to winstation registry configuration data
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPushWd( IN PSTACK pStack,
            IN PWINSTATIONNAME pWinStationName,
            IN PWINSTATIONCONFIG2 pWinStationConfig )
{
    ICA_STACK_PUSH IcaStackPush;
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushWd, %S\n", pWinStationConfig->Wd.WdDLL ));

    memset( &IcaStackPush, 0, sizeof(IcaStackPush) );

    IcaStackPush.StackModuleType = Stack_Module_Wd;

    memcpy( IcaStackPush.StackModuleName, pWinStationConfig->Wd.WdDLL,
            sizeof( IcaStackPush.StackModuleName ) );

#ifndef _HYDRA_
    //wcscat( IcaStackPush.StackModuleName, ICA_SD_MODULE_EXTENTION );
#endif

    memcpy( IcaStackPush.OEMId,
            pWinStationConfig->Config.OEMId,
            sizeof(pWinStationConfig->Config.OEMId) );

    IcaStackPush.WdConfig = pWinStationConfig->Wd;
    IcaStackPush.PdConfig = pWinStationConfig->Pd[0];

    memcpy( IcaStackPush.WinStationRegName,
            pWinStationName,
            sizeof(IcaStackPush.WinStationRegName) );

    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_PUSH,
                                 &IcaStackPush,
                                 sizeof( IcaStackPush ),
                                 NULL,
                                 0,
                                 NULL );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPushWd, %S, 0x%x\n", pWinStationConfig->Wd.WdDLL, Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaPopStack
 *
 *   Pop all the stack drivers
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *   nothing
 *
 ****************************************************************************/

void
_IcaPopStack( IN PSTACK pStack )
{
    ASSERTLOCK( &pStack->CritSec );

    /*
     *  If another thread is doing the unload, then nothing else to do.
     */
    if ( pStack->fUnloading )
        return;
    pStack->fUnloading = TRUE;

    /*
     *  Unload all stack drivers
     */
    while ( _IcaPopSd( pStack ) == STATUS_SUCCESS ) {
        ;
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack all stack drivers unloaded\n" ));

    /*
     *  Release CD threads
     */
    (void) _IcaStackIoControl( pStack,
                               IOCTL_ICA_STACK_CD_CANCEL_IO,
                               NULL, 0, NULL, 0, NULL );

    /*
     *  Wait for all other references (besides our own) to go away
     */
    pStack->RefCount++;
waitagain:
    while ( pStack->RefCount > 1 ) {

        TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack: waiting for refcount %d\n", pStack->RefCount ));

        pStack->hUnloadEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        ASSERT( pStack->hUnloadEvent );

        UNLOCK( &pStack->CritSec );
        (void) WaitForSingleObject( pStack->hUnloadEvent, INFINITE );
        LOCK( &pStack->CritSec );

		//	NOTE: seems to me that between being notified and locking the
		//	stack, some other thread could have locked the stack and bumped
		//	the ref count. no breaks have ever been hit, though.
		if (pStack->RefCount > 1) {
			goto waitagain;
		}

        CloseHandle( pStack->hUnloadEvent );
        pStack->hUnloadEvent = NULL;
    }
    _DecrementStackRef( pStack );

    /*
     *  Unload connection driver
     */
    _CdClose( pStack );

    /*
     *  Clear stack loaded flag
     */
    pStack->fStackLoaded = FALSE;
    pStack->fUnloading = FALSE;

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopStack\n" ));
}


/****************************************************************************
 *
 * _IcaPopSd
 *
 *   Pop a stack driver module  (wd or pd)
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaPopSd( IN PSTACK pStack )
{
    NTSTATUS Status;

    ASSERTLOCK( &pStack->CritSec );

    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_POP,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 NULL );

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaPopSd, 0x%x\n", Status ));
    return( Status );
}


/****************************************************************************
 *
 * _IcaStackWaitForIca
 *
 *   Wait for ICA Detect string
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *   pWinStationConfig (input/output)
 *     pointer to winstation registry configuration data
 *   pfStackModified (output)
 *     Pointer to stack modified flag
 *
 * EXIT:
 *   STATUS_SUCCESS - Success
 *   other          - Error return code
 *
 ****************************************************************************/

NTSTATUS
_IcaStackWaitForIca( IN PSTACK pStack,
                     IN OUT PWINSTATIONCONFIG2 pWinStationConfig,
                     OUT BOOLEAN * pfStackModified )
{
    ICA_STACK_CONFIG IcaStackConfig;
    PPDCONFIG pPdConfig;
    NTSTATUS Status;
    ULONG cbReturned;
    ULONG i;

    ASSERTLOCK( &pStack->CritSec );

    /*
     *  Initialize flag
     */
    *pfStackModified = FALSE;

    /*
     *  Wait for ICA Detect string from client
     */
    Status = _IcaStackIoControl( pStack,
                                 IOCTL_ICA_STACK_WAIT_FOR_ICA,
                                 NULL,
                                 0,
                                 &IcaStackConfig,
                                 sizeof(IcaStackConfig),
                                 &cbReturned );
    if ( !NT_SUCCESS(Status) ) {
        goto baddetect;
    }

    /*
     *  If ICA Detect returned any stack information, then update it
     */
    if ( cbReturned > 0 ) {

        ASSERT( FALSE );
#ifdef notdef

        /*
         *   this path has not been tested
         *
         *  Return configuration data
         *  -- skip transport driver (index 0)
         */
        for ( i = 0; i < (MAX_PDCONFIG-1); i++ ) {

            pPdConfig = &pWinStationConfig->Pd[i+1];

            memset( pPdConfig, 0, sizeof(PDCONFIG) );

            if ( IcaStackConfig.SdClass[i] == SdNone )
                break;

            pPdConfig->Create.SdClass = IcaStackConfig.SdClass[i];
            memcpy( pPdConfig->Create.PdDLL, IcaStackConfig.SdDLL[i], sizeof(DLLNAME) );
        }

        if ( IcaStackConfig.WdDLL[0] )
            memcpy( pWinStationConfig->Wd.WdDLL, IcaStackConfig.WdDLL, sizeof(DLLNAME) );

        /*
         *  Set modify flag
         */
        *pfStackModified = TRUE;
#endif
    }

    TRACESTACK(( pStack, TC_ICAAPI, TT_API1, "TSAPI: _IcaWaitForIca, success\n" ));
    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

baddetect:
    TRACESTACK(( pStack, TC_ICAAPI, TT_ERROR, "TSAPI: _IcaWaitForIca, 0x%x\n", Status ));
    return( Status );
}



/****************************************************************************
 *
 * _DecrementStackRef
 *
 *   decrement stack reference
 *
 * ENTRY:
 *   pStack (input)
 *     pointer to ICA stack structure
 *
 * EXIT:
 *   nothing
 *
 ****************************************************************************/

void
_DecrementStackRef( IN PSTACK pStack )
{
    pStack->RefCount--;

    if ( pStack->RefCount == 1 && pStack->hUnloadEvent ) {
        SetEvent( pStack->hUnloadEvent );

    } else if ( pStack->RefCount == 0 && pStack->hCloseEvent ) {
        SetEvent( pStack->hCloseEvent );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\adcgcfnc.h ===
/**INC+**********************************************************************/
/* Header:    adcgcfnc.h                                                    */
/*                                                                          */
/* Purpose:   C runtime functions - portable include file                   */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/adcgcfnc.h_v  $
 * 
 *    Rev 1.7   06 Aug 1997 14:32:22   AK
 * SFR1016: Apply Markups
 *
 *    Rev 1.6   06 Aug 1997 10:40:42   AK
 * SFR1016: Complete removal of DCCHAR etc
 *
 *    Rev 1.5   23 Jul 1997 10:47:52   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.4   15 Jul 1997 15:42:48   AK
 * SFR1016: Add Unicode support
 *
 *    Rev 1.3   09 Jul 1997 16:56:24   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_ADCGCFNC
#define _H_ADCGCFNC

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the required C headers                                           */
/****************************************************************************/
#ifndef OS_WINCE
#include <stdio.h>
#endif // OS_WINCE
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#ifndef OS_WINCE
#include <time.h>
#endif // OS_WINCE
/****************************************************************************/
/* Include the Windows-specific header.                                     */
/****************************************************************************/
#include <wdcgcfnc.h>

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Character Class Tests (normally in ctype.h)                              */
/* =====================                                                    */
/* In these definitions:                                                    */
/*                                                                          */
/*    'C' is of type DCINT.                                                 */
/*                                                                          */
/* These functions return a DCBOOL.                                         */
/****************************************************************************/
#define DC_ISALNUM(C)                  isalnum(C)
#define DC_ISALPHA(C)                  isalpha(C)
#define DC_ISCNTRL(C)                  iscntrl(C)
#define DC_ISDIGIT(C)                  isdigit(C)
#define DC_ISGRAPH(C)                  isgraph(C)
#define DC_ISLOWER(C)                  islower(C)
#define DC_ISPRINT(C)                  isprint(C)
#define DC_ISPUNCT(C)                  ispunct(C)
#define DC_ISSPACE(C)                  isspace(C)
#define DC_ISUPPER(C)                  isupper(C)
#define DC_ISXDIGIT(C)                 isxdigit(C)

/****************************************************************************/
/* These functions return a DCINT.                                          */
/****************************************************************************/
#define DC_TOLOWER(C)                  tolower(C)
#ifdef OS_WINCE
#define DC_TOUPPER(C)                  towupper(C)
#else // OS_WINCE
#define DC_TOUPPER(C)                  toupper(C)
#endif // OS_WINCE

/****************************************************************************/
/* Memory functions (from string.h)                                         */
/* ================                                                         */
/* In these definitions:                                                    */
/*    'S' and 'T' are of type PDCVOID.                                      */
/*    'CS' and 'CT' are of type (constant) PDCVOID.                         */
/*    'N' is of type DCINT.                                                 */
/*    'C' is an DCINT converted to DCACHAR.                                 */
/****************************************************************************/
/****************************************************************************/
/* These functions return a PDCVOID.                                        */
/****************************************************************************/
#define DC_MEMCPY(S, CT, N)            memcpy(S, CT, N)
#define DC_MEMMOVE(S, CT, N)           memmove(S, CT, N)
#define DC_MEMSET(S, C, N)             memset(S, C, N)

/****************************************************************************/
/* These functions return a DCINT.                                          */
/****************************************************************************/
#define DC_MEMCMP(CS, CT, N)           memcmp(CS, CT, N)

/****************************************************************************/
/* Utility functions (from stdlib.h)                                        */
/* =================                                                        */
/* In these defintions:                                                     */
/*    'CS' is of type (constant) PDCACHAR.                                  */
/*    'N' is of type DCINT.                                                 */
/*    'L' is of type DCINT32                                                */
/****************************************************************************/

/****************************************************************************/
/* These functions return a DCINT.                                          */
/****************************************************************************/
#define DC_ABS(N)                      abs(N)

/****************************************************************************/
/* These functions return a DCINT32.                                        */
/****************************************************************************/
#define DC_ATOL(CS)                    atol(CS)
#define DC_LABS(L)                     labs(L)

/****************************************************************************/
/* The maximum characters DC_?ITOA will convert into plus one for a         */
/* NULLTERM (see C library documentation).                                  */
/****************************************************************************/
#define MAX_ITOA_LENGTH 18

#endif /* _H_ADCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\adcgcnst.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* adcgcnst.h                                                               */
/*                                                                          */
/* DC-Groupware common constants - portable include file.                   */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/adcgcnst.h_v  $
//
//    Rev 1.7   05 Sep 1997 15:52:12   KH
// SFR1346: Define user message constants
//
//    Rev 1.6   20 Aug 1997 10:29:44   NL
// SFR1312: add DCS_RC_BUSY
//
//    Rev 1.5   15 Aug 1997 16:13:24   OBK
// SFR1133: Kernelisation: remove unused constants
//
//    Rev 1.4   06 Aug 1997 10:41:00   AK
// SFR1016: Complete removal of DCCHAR etc
//
//    Rev 1.3   23 Jul 1997 10:47:52   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:44:18   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/

/****************************************************************************/
/* CONTENTS                                                                 */
/* ========                                                                 */
/* This file contains constants for all:                                    */
/*                                                                          */
/* - names of shared memory blocks, locks and files                         */
/* - base and limit values by component for return values and events        */
/*                                                                          */
/* used by DC-Groupware components.                                         */
/*                                                                          */
/* The rationale for this file is to make it easier to detect name clashes  */
/* between components.  Therefore, even if you don't expect anyone else to  */
/* use your mutex, file, etc., you MUST include its name in here to ensure  */
/* that it doesn't happen inadvertently.                                    */
/****************************************************************************/
#ifndef _H_ADCGCNST
#define _H_ADCGCNST

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgcnst.h>

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Give numbers to our operating systems.                                   */
/****************************************************************************/
#define WIN_31                         1
#define MAC_S7                         3
#define WIN_95                         4
#define WIN_95_32                      5
#define WIN_NT                         6

/****************************************************************************/
/* Limits                                                                   */
/****************************************************************************/
#define MAX_DCUINT16                   65535

/****************************************************************************/
/* Drive and directory separators.                                          */
/****************************************************************************/
#define DC_MAX_PATH                    MAX_PATH

/****************************************************************************/
/* Return codes                                                             */
/* ============                                                             */
/* This section lists the ranges available for each component when defining */
/* its return codes.  A component must not define return codes outside its  */
/* permitted range.  The following ranges are currently defined:            */
/*                                                                          */
/* 0x0b00 - 0x0bFF : Share programming                                      */
/* 0x0f00 - 0x0fFF : Common functions                                       */
/* 0x1100 - 0x11FF : Trace functions                                        */
/*                                                                          */
/****************************************************************************/

#define SPI_BASE_RC                    ((DCUINT16) 0x0B00)
#define SPI_LAST_RC                    ((DCUINT16) 0x0BFF)

#define COM_BASE_RC                    ((DCUINT16) 0x0F00)
#define COM_LAST_RC                    ((DCUINT16) 0x0FFF)

#define TRC_BASE_RC                    ((DCUINT16) 0x1000)
#define TRC_LAST_RC                    ((DCUINT16) 0x10FF)

/****************************************************************************/
/* DC-Share return codes                                                    */
/* =====================                                                    */
/* These codes are intended to be very specific, such that the error code   */
/* (when in the trace log) clearly identifies the specific class of error,  */
/* as follows:                                                              */
/*                                                                          */
/* DCS_RC_OK             : OK                                               */
/* DCS_RC_ERR_LOGIC      : DC-Share internal logic                          */
/* DCS_RC_ERR_PARAM      : DC-Share internal parameter error                */
/* DCS_RC_ERR_MEMORY     : allocating memory                                */
/* DCS_RC_ERR_MEMLOCK    : locking memory                                   */
/* DCS_RC_ERR_STRING     : loading strings from resources                   */
/* DCS_RC_ERR_LOADBITMAP : loading bitmaps or icons from resources          */
/* DCS_RC_ERR_PROCADDR   : getting a proc address                           */
/* DCS_RC_ERR_WINDOW     : creating/registering Windows windows/classes     */
/* DCS_RC_ERR_HOOK       : setting a Windows hook                           */
/* DCS_RC_ERR_MSGQUEUE   : creating/manipulating Windows message queues     */
/* DCS_RC_ERR_BITMAP     : creating a Windows bitmap                        */
/* DCS_RC_ERR_DC         : creating/querying Windows DCs                    */
/* DCS_RC_ERR_OBJECT     : creating Windows objects (eg Palettes, Pens, ...)*/
/* DCS_RC_ERR_MMTIMER    : initialising multimedia timer                    */
/*                                                                          */
/****************************************************************************/
#define DC_RC_OK                       ((DCUINT16) 0)
#define DCS_RC_OK                      0
#define DCS_RC_ERR_LOGIC               2
#define DCS_RC_ERR_PARAM               3
#define DCS_RC_ERR_MEMORY              4
#define DCS_RC_ERR_MEMLOCK             5
#define DCS_RC_ERR_STRING              6
#define DCS_RC_ERR_LOADBITMAP          7
#define DCS_RC_ERR_PROCADDR            8
#define DCS_RC_ERR_WINDOW              9
#define DCS_RC_ERR_HOOK                10
#define DCS_RC_ERR_MSGQUEUE            11
#define DCS_RC_ERR_BITMAP              12
#define DCS_RC_ERR_DC                  13
#define DCS_RC_ERR_OBJECT              14
#define DCS_RC_ERR_MMTIMER             15
#define DCS_RC_FAIL_GENERAL            16
#define DCS_RC_FAIL_RESOURCE           17
#define DCS_RC_BUSY                    18

/****************************************************************************/
/* Shared memory block names                                                */
/* =========================                                                */
/* This section lists the shared memory block names used by each component. */
/****************************************************************************/

/****************************************************************************/
/* INI file section names for each of the DC-Groupware components.          */
/****************************************************************************/
#define TRC_INI_SECTION_NAME           _T("Trace")

#define DCS_INI_SECTION_NAME           L"Share"
#define PRI_INI_SECTION_NAME           L"PropertyIndex"
#define PRD_INI_SECTION_NAME           L"PropertyDefault"
#define PRO_INI_SECTION_NAME           L"PropertyOverride"

/****************************************************************************/
/* Null definitions.                                                        */
/****************************************************************************/
#define NULL_HWND                      ((HWND)0)
#define NULL_DCWINID                   ((DCWINID)0)
#define NULL_DCAPPID                   ((DCAPPID)0)
#define NULL_DCPALID                   ((DCPALID)0)
#define NULL_DCREGIONID                ((DCREGIONID)0)

/****************************************************************************/
/* Win3.1 doesn't have WM_APP, so we define it here to be well separated    */
/* from WM_USER. As long as it's less than 0x8000, we're OK.                */
/****************************************************************************/
#ifdef OS_WIN16
#define WM_APP WM_USER+0x1000
#endif

/****************************************************************************/
/* User defined messages.                                                   */
/****************************************************************************/
#define DUC_TD_MESSAGE_BASE  (WM_APP + 0)
#define DUC_CD_MESSAGE_BASE  (WM_APP + 10)
#define DUC_UI_MESSAGE_BASE  (WM_APP + 20)
#define DUC_CO_MESSAGE_BASE  (WM_APP + 30)

#endif /* _H_ADCGCNST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\adcgperf.h ===
/*INC+***********************************************************************/
/*                                                                          */
/* adcgperf.h                                                               */
/*                                                                          */
/* Performance Monitoring - portable include file                           */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  10Sep96 AK  SFR0569     Created for performance monitoring              */
/*                                                                          */
/*INC-***********************************************************************/
#ifndef _H_ADCGPERF
#define _H_ADCGPERF

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgperf.h>

#endif /* _H_ADCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\aducdefs.h ===
/**INC+**********************************************************************/
/* Header:  aduxdefs.h                                                      */
/*                                                                          */
/* Purpose: Optional defines used in the client                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/tshrclnt/inc/aducdefs.h_v  $
 *
 *    Rev 1.1   24 Sep 1997 14:29:30   AK
 * SFR1424: Rename adcgdefs.h for client
**/
/**INC-**********************************************************************/
#ifndef _H_ADUCDEFS
#define _H_ADUCDEFS

/****************************************************************************/
/* This header contains a list of all the optional defines used throughout  */
/* the project.  To compile-in some optionally defined code, enable the     */
/* appropriate option here.  Note that:                                     */
/*                                                                          */
/*  - all defines must be declared and documented here.  This is enforced   */
/*    by moans.                                                             */
/*  - the list must be sorted alphabetically.  This makes it easy to spot   */
/*    duplicate defines.                                                    */
/****************************************************************************/

/****************************************************************************/
/* DC_ANSI_TEXT_ORDERS enables support for encoded text orders where the    */
/* characters are in ANSI format.                                           */
/****************************************************************************/
#ifndef OS_WINCE
#define DC_ANSI_TEXT_ORDERS
#endif // OS_WINCE

/****************************************************************************/
/* DC_LATENCY enables the latency test code in UH and OP.  This code        */
/* generates a dummy key press (of the Ctrl key) whenever a large piece of  */
/* drawing is done.  This allows the client processing time for a single    */
/* key stroke to be accurately measured using a network sniffer (e.g.       */
/* NetMon).  In a typical situation Notepad is running in a remote session  */
/* (no other apps are running in the session) and the following occurs:     */
/*                                                                          */
/*  - Notepad has the focus on the client.                                  */
/*  - Press a key.                                                          */
/*  - Key-press is packaged by the client and sent on the wire.             */
/*  - Server interprets packet and injects the key-press.                   */
/*  - Notepad does some processing which results in a character being       */
/*    drawn on the screen.                                                  */
/*  - Server detects this drawing, packages it and sends it on the wire.    */
/*  - Client receives update packets and processes them.                    */
/*  - The drawing operation results in a dummy key-press being generated.   */
/*  - Dummy key-press is packaged by the client and sent on the wire.       */
/*                                                                          */
/* The time between the first update packet arriving and the dummy          */
/* key-press being sent is the total client processing time for a           */
/* key-press.                                                               */
/****************************************************************************/
#undef DC_LATENCY
/* #define DC_LATENCY */

/****************************************************************************/
/* DC_LOOPBACK enables the NL loopback testing code.  This stresses the     */
/* network layer by attempting to send a continual stream of packets with   */
/* incrementing size.  The equivalent code on the server detects loopback   */
/* packets and reflects them straight back to the client where they are     */
/* compared to ensure that they have not been corrupted by the round trip.  */
/****************************************************************************/
#undef DC_LOOPBACK
/* #define DC_LOOPBACK */

/****************************************************************************/
/* Code within DC_NLTEST is used solely for testing the network layer.  It  */
/* consists of:                                                             */
/*                                                                          */
/*  - a modification to TD_Recv so that it only ever tries to retrieve a    */
/*    single byte from WinSock regardless of the amount of data that the    */
/*    caller to TD_Recv asks for.  This stresses the common failure path    */
/*    within NL where processing of a packet has to be temporarily          */
/*    suspended until more data arrives.                                    */
/*  - random failure of NL_GetBuffer.  This stresses the whole of the       */
/*    client by simulating network layer back-pressure.                     */
/*                                                                          */
/****************************************************************************/
#undef DC_NLTEST
/* #define DC_NLTEST */

/****************************************************************************/
/* DC_SERVER_ORDERS_ONLY compiles the client using just the T.128 orders    */
/* that the server sends (i.e. removes unused T.128 orders).                */
/****************************************************************************/
/* #undef DC_SERVER_ORDERS_ONLY */
#define DC_SERVER_ORDERS_ONLY

/****************************************************************************/
/* Defining DC_PERF enables the timing code which enables the time spent    */
/* in several key functions to be easily determined.                        */
/****************************************************************************/
#undef DC_PERF
/* #define DC_PERF */

/****************************************************************************/
/* Defining SL_UNICODE_PROTOCOL enables code to send security package names */
/* in Unicode, rather than ANSI, format.                                    */
/****************************************************************************/
#undef SL_UNICODE_PROTOCOL
/* #define SL_UNICODE_PROTOCOL */

/****************************************************************************/
/* The following flags are defined elsewehere - for example in the build    */
/* scripts.  They are placed here to enable moans to detect legal defines - */
/* the moans use '/* FLAG:' to find these names.                            */
/*                                                                          */
/* FLAG: OS_WIN16                                                           */
/* - flag to indicate a Win16 build                                         */
/*                                                                          */
/* FLAG: OS_WIN32                                                           */
/* - flag to indicate a Win32 build                                         */
/*                                                                          */
/* FLAG: OS_WINDOWS                                                         */
/* - flag to indicate a Windows build                                       */
/*                                                                          */
/* FLAG: DC_DEBUG                                                           */
/* - flag to indicate a debug build                                         */
/*                                                                          */
/* FLAG: DC_DEFINE_GLOBAL_DATA                                              */
/* - used in aglobal.c to define global data                                */
/*                                                                          */
/* FLAG: UNICODE                                                            */
/* - Windows Unicode option                                                 */
/*                                                                          */
/* FLAG: HIPROF                                                             */
/* - HiProf profiler build                                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* The following flags are used in the server code.                         */
/* FLAG: CH_NO_COUNT                                                        */
/* FLAG: COMP_STATS                                                         */
/* FLAG: DC_FIXED_CODE_MODULE                                               */
/* FLAG: DC_INCLUDE_DATA                                                    */
/* FLAG: DC_INCL_PROTOTYPES                                                 */
/* FLAG: DC_INCL_TYPEDEFS                                                   */
/* FLAG: DC_INIT_DATA                                                       */
/* FLAG: DEBUG_EVICTION_LIST                                                */
/* FLAG: DIAGNOSE_BOUNDS                                                    */
/* FLAG: DITHER_MONO_CURSORS                                                */
/* FLAG: DLL_COREP                                                          */
/* FLAG: DLL_DISP                                                           */
/* FLAG: DLL_WD                                                             */
/* FLAG: GIN_ACCEPT_INVITES                                                 */
/* FLAG: HYDRA                                                              */
/* FLAG: NOT_SERVICE                                                        */
/* FLAG: ORDER_TRACE                                                        */
/* FLAG: QUERY_THROUGHPUT                                                   */
/* FLAG: RC_INVOKED                                                         */
/* FLAG: REMOVE_LINEAR                                                      */
/* FLAG: SNI_ASSERT                                                         */
/* FLAG: SNI_ASSERT                                                         */
/* FLAG: TRC_ENABLE_ALT                                                     */
/* FLAG: TRC_ENABLE_DBG                                                     */
/* FLAG: TRC_ENABLE_NRM                                                     */
/* FLAG: TRC_GROUP                                                          */
/* FLAG: TRC_TEST_LEVEL                                                     */
/* FLAG: V1_COMPRESSION                                                     */
/* FLAG: VER_APPSERV                                                        */
/* FLAG: VER_CPP                                                            */
/* FLAG: __cplusplus                                                        */
/* FLAG: USE_HET                                                            */
/* FLAG: USE_DS                                                             */
/* FLAG: USE_AWC                                                            */
/* FLAG: USE_FULL_CA                                                        */
/* FLAG: CA_MULTIPLE_CLIENTS                                                */
/*                                                                          */
/****************************************************************************/

#endif /* _H_ADUCDEFS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\adcgctyp.h ===
/**INC+**********************************************************************/
/* Header:    adcgctyp.h                                                    */
/*                                                                          */
/* Purpose:   Complex types - portable include file.                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/ADCGCTYP.H_v  $
 *
 *    Rev 1.7   07 Aug 1997 14:33:46   MR
 * SFR1133: Persuade Wd to compile under C++
 *
 *    Rev 1.6   23 Jul 1997 10:47:54   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.5   10 Jul 1997 11:51:36   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_ADCGCTYP
#define _H_ADCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include appropriate header files.                                        */
/****************************************************************************/
#ifndef __midl
#ifndef OS_WINCE
#include <time.h>
#endif // OS_WINCE
#endif

/****************************************************************************/
/* Include the proxy header.  This will then include the appropriate OS     */
/* specific header for us.                                                  */
/****************************************************************************/
#include <wdcgctyp.h>

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DC-Share specific types.  Note that some of these are OS specific so     */
/* the actual type definition appears in an OS specific header.  However    */
/* the definition of the pointer to type is OS independant and therefore    */
/* appears in this file.                                                    */
/****************************************************************************/
typedef DCUINT32                       DCAPPID;
typedef DCUINT32                       DCWINID;
typedef DCUINT                         DCLOCALPERSONID;
typedef DCUINT                         DCNETPERSONID;
typedef DCUINT32                       DCENTITYID;

typedef DCAPPID              DCPTR     PDCAPPID;
typedef DCWINID              DCPTR     PDCWINID;
typedef DCLOCALPERSONID      DCPTR     PDCLOCALPERSONID;
typedef DCNETPERSONID        DCPTR     PDCNETPERSONID;
typedef DCENTITYID           DCPTR     PDCENTITYID;

typedef DCREGIONID           DCPTR     PDCREGIONID;
typedef DCPALID              DCPTR     PDCPALID;
typedef DCCURSORID           DCPTR     PDCCURSORID;
typedef DCHFONT              DCPTR     PDCHFONT;
typedef DCFILETIME           DCPTR     PDCFILETIME;
typedef DCHFILE              DCPTR     PDCHFILE;

typedef PDCACHAR                       PDCSTR;
typedef DCUINT                         ATRETCODE;
typedef PDCVOID                        SYSREGION;

typedef SYSRECT              DCPTR     PSYSRECT;
typedef SYSAPPID             DCPTR     PSYSAPPID;
typedef SYSWINID             DCPTR     PSYSWINID;
typedef SYSBITMAP            DCPTR     PSYSBITMAP;
typedef SYSBMIHEADER         DCPTR     PSYSBMIHEADER;
typedef SYSBMI               DCPTR     PSYSBMI;
typedef SYSPOINT             DCPTR     PSYSPOINT;
typedef SYSREGION            DCPTR     PSYSREGION;

/****************************************************************************/
/* Window and dialog procedure typedefs.                                    */
/****************************************************************************/
#if !defined(DLL_DISP) && !defined(DLL_WD)
typedef WNDPROC                        PDCWNDPROC;
typedef DLGPROC                        PDCDLGPROC;
#endif

typedef WPARAM                         DCPARAM1;
typedef LPARAM                         DCPARAM2;

/****************************************************************************/
/* Time typedefs.                                                           */
/****************************************************************************/
typedef time_t                         DC_LONGTIME;
typedef struct tm                      DC_TMTIME;

/****************************************************************************/
/*                                                                          */
/* STRUCTURES                                                               */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* RGBQUAD                                                                  */
/* =======                                                                  */
/* rgbBlue         : blue value.                                            */
/* rgbGreen        : green value.                                           */
/*                                                                          */
/* rgbRed          : red value.                                             */
/* rgbReserved     : reserved.                                              */
/****************************************************************************/
typedef struct tagDCRGBQUAD
{
    DCUINT8     rgbBlue;
    DCUINT8     rgbGreen;
    DCUINT8     rgbRed;
    DCUINT8     rgbReserved;
} DCRGBQUAD;
typedef DCRGBQUAD DCPTR PDCRGBQUAD;

/****************************************************************************/
/* DCRECT16                                                                 */
/* ========                                                                 */
/* This is an OS independant rectangle structure.                           */
/*                                                                          */
/* left            : left position.                                         */
/* top             : top position.                                          */
/* right           : right position.                                        */
/* bottom          : bottom position.                                       */
/****************************************************************************/
typedef struct tagDCRECT16
{
    DCINT16     left;
    DCINT16     top;
    DCINT16     right;
    DCINT16     bottom;
} DCRECT16;
typedef DCRECT16 DCPTR PDCRECT16;

/****************************************************************************/
/* DCRECT                                                                   */
/* ======                                                                   */
/* left            : left position.                                         */
/* top             : top position.                                          */
/* right           : right position.                                        */
/* bottom          : bottom position.                                       */
/****************************************************************************/
typedef struct tagDCRECT
{
    DCINT       left;
    DCINT       top;
    DCINT       right;
    DCINT       bottom;
} DCRECT;
typedef DCRECT DCPTR PDCRECT;

/****************************************************************************/
/* DCRGB                                                                    */
/* =====                                                                    */
/* red             : red value.                                             */
/* green           : green value.                                           */
/* blue            : blue value.                                            */
/****************************************************************************/
typedef struct tagDCRGB
{
    DCUINT8 red;
    DCUINT8 green;
    DCUINT8 blue;
} DCRGB;
typedef DCRGB DCPTR PDCRGB;

/****************************************************************************/
/* DCCOLOR                                                                  */
/* =======                                                                  */
/*                                                                          */
/* Union of DCRGB and an index into a color table                           */
/*                                                                          */
/****************************************************************************/
typedef struct tagDCCOLOR
{
    union
    {
        DCRGB   rgb;
        DCUINT8 index;
    } u;
} DCCOLOR;
typedef DCCOLOR DCPTR PDCCOLOR;

/****************************************************************************/
/* DCSIZE                                                                   */
/* ======                                                                   */
/* width           : x dimension.                                           */
/* height          : y dimension.                                           */
/****************************************************************************/
typedef struct tagDCSIZE
{
    DCUINT      width;
    DCUINT      height;
} DCSIZE;
typedef DCSIZE DCPTR PDCSIZE;

/****************************************************************************/
/* DCPOINT                                                                  */
/* =======                                                                  */
/* x               : x co-ordinate.                                         */
/* y               : y co-ordinate.                                         */
/****************************************************************************/
typedef struct tagDCPOINT
{
    DCINT       x;
    DCINT       y;
} DCPOINT;
typedef DCPOINT DCPTR PDCPOINT;

/****************************************************************************/
/* DCPOINT16                                                                */
/* =========                                                                */
/* x               : x co-ordinate.                                         */
/* y               : y co-ordinate.                                         */
/****************************************************************************/
typedef struct tagDCPOINT16
{
    DCINT16     x;
    DCINT16     y;
} DCPOINT16;
typedef DCPOINT16 DCPTR PDCPOINT16;

/****************************************************************************/
/* DCPOINT32                                                                */
/* =========                                                                */
/* x               : x co-ordinate.                                         */
/* y               : y co-ordinate.                                         */
/****************************************************************************/
typedef struct tagDCPOINT32
{
    DCINT32     x;
    DCINT32     y;
} DCPOINT32;
typedef DCPOINT32 DCPTR PDCPOINT32;

#ifndef __midl
/****************************************************************************/
/* BITMAPINFO_ours                                                          */
/* ===============                                                          */
/* bmiHeader       :                                                        */
/* bmiColors       :                                                        */
/****************************************************************************/
typedef struct tagBITMAPINFO_ours
{
    SYSBMIHEADER       bmiHeader;
    DCRGBQUAD          bmiColors[256];
} BITMAPINFO_ours;

/****************************************************************************/
/* BITMAPINFO_PLUS                                                          */
/* ===============                                                          */
/* bmiHeader       :                                                        */
/* bmiColors       :                                                        */
/****************************************************************************/
typedef struct tagBINFO_PLUS
{
    SYSBMIHEADER       bmiHeader;
    DCRGBQUAD          bmiColors[256];
} BITMAPINFO_PLUS_COLOR_TABLE;
#endif

/****************************************************************************/
/* DC_DATE                                                                  */
/* =======                                                                  */
/* day             : day of the month (1-31).                               */
/* month           : month (1-12).                                          */
/* year            : year (e.g. 1996).                                      */
/****************************************************************************/
typedef struct tagDC_DATE
{
    DCUINT8  day;
    DCUINT8  month;
    DCUINT16 year;
} DC_DATE;
typedef DC_DATE DCPTR PDC_DATE;

/****************************************************************************/
/* DC_TIME                                                                  */
/* =======                                                                  */
/* hour            : hour (0-23).                                           */
/* min             : minute (0-59).                                         */
/* sec             : seconds (0-59).                                        */
/* hundredths      : hundredths of a second (0-99).                         */
/****************************************************************************/
typedef struct tagDC_TIME
{
    DCUINT8  hour;
    DCUINT8  min;
    DCUINT8  sec;
    DCUINT8  hundredths;
} DC_TIME;
typedef DC_TIME DCPTR PDC_TIME;

/****************************************************************************/
/* Types of addresses supported by Groupware (these go in the <addressType> */
/* field of the DC_PERSON_ADDRESS structure):                               */
/****************************************************************************/
#define DC_ADDRESS_TYPE_NONE                   0
#define DC_ADDRESS_TYPE_NETBIOS                1
#define DC_ADDRESS_TYPE_IPXSPX                 2
#define DC_ADDRESS_TYPE_VIRTUAL_ASYNC          3
#define DC_ADDRESS_TYPE_MODEM                  4
#define DC_ADDRESS_TYPE_LIVELAN                5
#define DC_ADDRESS_TYPE_PCS100                 6

/****************************************************************************/
/* This is the max number of addresses the address book will store for      */
/* one person:                                                              */
/****************************************************************************/
#define DC_MAX_ADDRESSES_PER_PERSON         6

/****************************************************************************/
/* These constants define the maximum length of person names and addresses  */
/* supported by the Address Book.                                           */
/****************************************************************************/
#define DC_MAX_NAME_LEN       48    /* for general purpose names            */
                                    /* (includes the nul term)              */
#define DC_MAX_ADDR_DATA_LEN  48    /* for general purpose addresses        */
                                    /* this may be binary data              */

/****************************************************************************/
/* Defines the maximum number of BYTES allowed in a translated "shared by " */
/* string.                                                                  */
/****************************************************************************/
#define DC_MAX_SHARED_BY_BUFFER     64
#ifdef DESKTOPSHARING
#define DC_MAX_SHAREDDESKTOP_BUFFER 64
#endif /*DESKTOPSHARING*/

/****************************************************************************/
/* Address for a specific transport type:                                   */
/****************************************************************************/
typedef struct tagDC_PERSON_ADDRESS
{
    DCUINT16      addressType;                    /* N'bios, async, IPX...  */
    DCUINT16      addressLen;                     /* length of <addressData>*/
    DCACHAR       addressData[DC_MAX_ADDR_DATA_LEN];   /* TDD specific data */
} DC_PERSON_ADDRESS;
typedef DC_PERSON_ADDRESS DCPTR PDC_PERSON_ADDRESS;

/****************************************************************************/
/* General purpose address holder                                           */
/****************************************************************************/
typedef struct tagDC_PERSON
{
    DCACHAR                  name[DC_MAX_NAME_LEN];

                                 /* textual name - displayed to user        */
                                 /* (must be NULL-terminated).              */

    DC_PERSON_ADDRESS        address[DC_MAX_ADDRESSES_PER_PERSON];

                                 /* array of addresses for this person      */
} DC_PERSON;
typedef DC_PERSON DCPTR PDC_PERSON;

#endif /* _H_ADCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\adcgmcro.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* adcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - portable include file.                      */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/adcgmcro.h_v  $
// 
//    Rev 1.9   22 Aug 1997 10:34:52   MD
// SFR1162: Retire DC_LOCAL_TO_WIRE16
//
//    Rev 1.8   24 Jul 1997 16:48:28   KH
// SFR1033: Add DCMAKEDCUINT16
//
//    Rev 1.7   23 Jul 1997 10:47:56   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.2   30 Jun 1997 15:23:52   OBK
// SFR0000: Fix erroneous DCHI8 macro
//
//    Rev 1.1   19 Jun 1997 21:45:40   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_ADCGMCRO
#define _H_ADCGMCRO

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include the Windows header.  This will then include the appropriate      */
/* specific header (Win31, Win NT, etc).                                    */
/****************************************************************************/
#include <wdcgmcro.h>

/****************************************************************************/
/*                                                                          */
/* STRUCTURES                                                               */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DC_ID_STAMP2                                                             */
/* ============                                                             */
/* This is used by the stamp macros below.                                  */
/*                                                                          */
/* component       :                                                        */
/* structure       :                                                        */
/* instance        :                                                        */
/****************************************************************************/
typedef struct tagDC_ID_STAMP2
{
    DCUINT16    component;
    DCUINT16    structure;
    DCUINT32    instance;
} DC_ID_STAMP2;
typedef DC_ID_STAMP2 DCPTR PDC_ID_STAMP2;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Common function macros used throughout the product.                      */
/****************************************************************************/
#define DC_QUIT                        goto DC_EXIT_POINT
#define DC_QUIT_ON_FAIL(hr)     if (FAILED(hr)) DC_QUIT;

/****************************************************************************/
/* New function entry/exit macros.                                          */
/****************************************************************************/
#define DC_BEGIN_FN(str)               TRC_FN(str); TRC_ENTRY;
#define DC_END_FN()                    TRC_EXIT;

/****************************************************************************/
/* Conversion macros.                                                       */
/****************************************************************************/
#define DCMAKEDCUINT32(lo16, hi16) ((DCUINT32)(((DCUINT16)(lo16)) |         \
                                     (((DCUINT32)((DCUINT16)(hi16))) << 16)))
#define DCMAKEDCUINT16(lowByte, highByte)                                   \
                            ((DCUINT16)(((DCUINT8)(lowByte)) |              \
                            (((DCUINT16)((DCUINT8)(highByte))) << 8)))

#define DCLO16(u32)  ((DCUINT16)((u32) & 0xFFFF))
#define DCHI16(u32)  ((DCUINT16)((((DCUINT32)(u32)) >> 16) & 0xFFFF))
#define DCLO8(w)     ((DCUINT8)((w) & 0xFF))
#define DCHI8(w)     ((DCUINT8)(((DCUINT16)(w) >> 8) & 0xFF))

/****************************************************************************/
/* Macro to round up a number to the nearest multiple of four.              */
/****************************************************************************/
#define DC_ROUND_UP_4(x)  ((x + 3) & ~((DCUINT32)0X03))

/****************************************************************************/
/* PAD macro - use it to add X pad bytes to a structure.                    */
/*                                                                          */
/* Can only be used once per structure.                                     */
/****************************************************************************/
#define DCPAD(X)                       DCINT8 padBytes[X]

/****************************************************************************/
/* Byte swapping macros for different endian architectures.                 */
/*                                                                          */
/*   DC_xx_WIRExx          converts in a functional form                    */
/*   DC_xx_WIRExx_INPLACE  converts a given field (must be an lvalue)       */
/*                                                                          */
/* Note that these macros require aligned access.  See below for unaligned  */
/* access macros.                                                           */
/*                                                                          */
/* Note that on bigendian machines DC_{TO,FROM}_WIRE16 casts to a DCUINT16. */
/* In code of the form                                                      */
/*     B = DC_{TO,FROM}_WIRE16(A)                                           */
/* there is an implicit cast to the type of B.  So if A is a DCINT16 and is */
/* negative, and B has > 16 bits, then B will end up being large and        */
/* positive.  It is therefore necessary to add a cast to a DCINT16.         */
/*                                                                          */
/****************************************************************************/
#ifndef DC_BIGEND

#define DC_TO_WIRE16(A)                (A)
#define DC_TO_WIRE32(A)                (A)
#define DC_FROM_WIRE16(A)              (A)
#define DC_FROM_WIRE32(A)              (A)
#define DC_TO_WIRE16_INPLACE(A)
#define DC_TO_WIRE32_INPLACE(A)
#define DC_FROM_WIRE16_INPLACE(A)
#define DC_FROM_WIRE32_INPLACE(A)

#else

#define DC_TO_WIRE16(A)                                                     \
                      (DCUINT16) (((DCUINT16)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT16)(((PDCUINT8)&(A))[0])))
#define DC_FROM_WIRE16(A)                                                   \
                      (DCUINT16) (((DCUINT16)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT16)(((PDCUINT8)&(A))[0])))
#define DC_TO_WIRE32(A)                                                     \
                      (DCUINT32) (((DCUINT32)(((PDCUINT8)&(A))[3]) << 24)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[2]) << 16)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[0])))
#define DC_FROM_WIRE32(A)                                                   \
                      (DCUINT32) (((DCUINT32)(((PDCUINT8)&(A))[3]) << 24)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[2]) << 16)|  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[1]) << 8) |  \
                                  ((DCUINT32)(((PDCUINT8)&(A))[0])))

#define DC_TO_WIRE16_INPLACE(A)        (A) = DC_TO_WIRE16(A)
#define DC_TO_WIRE32_INPLACE(A)        (A) = DC_TO_WIRE32(A)
#define DC_FROM_WIRE16_INPLACE(A)      (A) = DC_FROM_WIRE16(A)
#define DC_FROM_WIRE32_INPLACE(A)      (A) = DC_FROM_WIRE32(A)

#endif

/****************************************************************************/
/* Unaligned pointer access macros -- first macros to extract an integer    */
/* from an unaligned pointer.  Note that these macros assume that the       */
/* integer is in local byte order                                           */
/****************************************************************************/
#ifndef DC_NO_UNALIGNED

#define DC_EXTRACT_UINT16_UA(pA)      (*(PDCUINT16_UA)(pA))
#define DC_EXTRACT_INT16_UA(pA)       (*(PDCINT16_UA)(pA))
#define DC_EXTRACT_UINT32_UA(pA)      (*(PDCUINT32_UA)(pA))
#define DC_EXTRACT_INT32_UA(pA)       (*(PDCINT32_UA)(pA))

#else

#ifndef DC_BIGEND
#define DC_EXTRACT_UINT16_UA(pA) ((DCUINT16)  (((PDCUINT8)(pA))[0]) |        \
                                  (DCUINT16) ((((PDCUINT8)(pA))[1]) << 8) )

#define DC_EXTRACT_INT16_UA(pA)  ((DCINT16)   (((PDCUINT8)(pA))[0]) |        \
                                  (DCINT16)  ((((PDCUINT8)(pA))[1]) << 8) )

#define DC_EXTRACT_UINT32_UA(pA) ((DCUINT32)  (((PDCUINT8)(pA))[0])        | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[1]) << 8)  | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[2]) << 16) | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[3]) << 24) )

#define DC_EXTRACT_INT32_UA(pA)  ((DCINT32)   (((PDCUINT8)(pA))[0])        | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[1]) << 8)  | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[2]) << 16) | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[3]) << 24) )
#else
#define DC_EXTRACT_UINT16_UA(pA) ((DCUINT16)  (((PDCUINT8)(pA))[1]) |        \
                                  (DCUINT16) ((((PDCUINT8)(pA))[0]) << 8) )

#define DC_EXTRACT_INT16_UA(pA)  ((DCINT16)   (((PDCUINT8)(pA))[1]) |        \
                                  (DCINT16)  ((((PDCUINT8)(pA))[0]) << 8) )

#define DC_EXTRACT_UINT32_UA(pA) ((DCUINT32)  (((PDCUINT8)(pA))[3])        | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[2]) << 8)  | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[1]) << 16) | \
                                  (DCUINT32) ((((PDCUINT8)(pA))[0]) << 24) )

#define DC_EXTRACT_INT32_UA(pA)  ((DCINT32)   (((PDCUINT8)(pA))[3])        | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[2]) << 8)  | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[1]) << 16) | \
                                  (DCINT32)  ((((PDCUINT8)(pA))[0]) << 24) )
#endif

#endif

/****************************************************************************/
/* Now macros to insert an integer at an unaligned pointer value.  Again,   */
/* the value inserted will be in local format.                              */
/****************************************************************************/
#ifndef DC_NO_UNALIGNED

#define DC_INSERT_UINT16_UA(pA,V)      (*(PDCUINT16_UA)(pA)) = (V)
#define DC_INSERT_INT16_UA(pA,V)       (*(PDCINT16_UA)(pA)) = (V)
#define DC_INSERT_UINT32_UA(pA,V)      (*(PDCUINT32_UA)(pA)) = (V)
#define DC_INSERT_INT32_UA(pA,V)       (*(PDCINT32_UA)(pA)) = (V)

#else

#ifndef DC_BIGEND
#define DC_INSERT_UINT16_UA(pA,V)                                       \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_INT16_UA(pA,V)                                        \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_UINT32_UA(pA,V)                                           \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#define DC_INSERT_INT32_UA(pA,V)                                            \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#else
#define DC_INSERT_UINT16_UA(pA,V)                                       \
             {                                                          \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_INT16_UA(pA,V)                                        \
             {                                                          \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_UINT32_UA(pA,V)                                           \
             {                                                              \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#define DC_INSERT_INT32_UA(pA,V)                                            \
             {                                                              \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#endif

#endif

/****************************************************************************/
/* Now another version of these macros, to insert an integer at an          */
/* unaligned pointer value.  This time, the value inserted should be in     */
/* wire format.                                                             */
/****************************************************************************/
#ifndef DC_NO_UNALIGNED

#define DC_INSERT_WIRE_UINT16_UA(pA,V)      \
                               (*(PDCUINT16_UA)(pA)) = DC_TO_WIRE16(V)
#define DC_INSERT_WIRE_INT16_UA(pA,V)       \
                               (*(PDCINT16_UA)(pA))  = DC_TO_WIRE16(V)
#define DC_INSERT_WIRE_UINT32_UA(pA,V)      \
                               (*(PDCUINT32_UA)(pA)) = DC_TO_WIRE32(V)
#define DC_INSERT_WIRE_INT32_UA(pA,V)       \
                               (*(PDCINT32_UA)(pA))  = DC_TO_WIRE32(V)

#else

#define DC_INSERT_WIRE_UINT16_UA(pA,V)                                  \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_WIRE_INT16_UA(pA,V)                                   \
             {                                                          \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)     & 0x00FF);  \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8) & 0x00FF);  \
             }
#define DC_INSERT_WIRE_UINT32_UA(pA,V)                                      \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#define DC_INSERT_WIRE_INT32_UA(pA,V)                                       \
             {                                                              \
                 (((PDCUINT8)(pA))[0]) = (DCUINT8)( (V)      & 0x000000FF); \
                 (((PDCUINT8)(pA))[1]) = (DCUINT8)(((V)>>8)  & 0x000000FF); \
                 (((PDCUINT8)(pA))[2]) = (DCUINT8)(((V)>>16) & 0x000000FF); \
                 (((PDCUINT8)(pA))[3]) = (DCUINT8)(((V)>>24) & 0x000000FF); \
             }
#endif

/****************************************************************************/
/* Unaligned pointer in-place flipping macros.  These macros flip an        */
/* integer field to or from wire format in-place, but do not do any         */
/* unaligned accesses while they are doing it.                              */
/****************************************************************************/
#ifndef DC_BIGEND

#define DC_TO_WIRE16_INPLACE_UA(A)
#define DC_TO_WIRE32_INPLACE_UA(A)
#define DC_FROM_WIRE16_INPLACE_UA(A)
#define DC_FROM_WIRE32_INPLACE_UA(A)

#else

#ifndef DC_NO_UNALIGNED
#define DC_TO_WIRE16_INPLACE_UA(A)    DC_TO_WIRE16_INPLACE(A)
#define DC_TO_WIRE32_INPLACE_UA(A)    DC_TO_WIRE32_INPLACE(A)
#define DC_FROM_WIRE16_INPLACE_UA(A)  DC_FROM_WIRE16_INPLACE(A)
#define DC_FROM_WIRE32_INPLACE_UA(A)  DC_FROM_WIRE32_INPLACE(A)
#else
#define DC_TO_WIRE16_INPLACE_UA(A)               \
             {                                   \
                 DCUINT16 val;                   \
                 val = DC_TO_WIRE16(A);          \
                 DC_INSERT_UINT16_UA(&(A), val)  \
             }
#define DC_TO_WIRE32_INPLACE_UA(A)               \
             {                                   \
                 DCUINT32 val;                   \
                 val = DC_TO_WIRE32(A);          \
                 DC_INSERT_UINT32_UA(&(A), val)  \
             }
#define DC_FROM_WIRE16_INPLACE_UA(A)             \
             {                                   \
                 DCUINT16 val;                   \
                 val = DC_FROM_WIRE16(A);        \
                 DC_INSERT_UINT16_UA(&(A), val)  \
             }
#define DC_FROM_WIRE32_INPLACE_UA(A)             \
             {                                   \
                 DCUINT32 val;                   \
                 val = DC_FROM_WIRE32(A);        \
                 DC_INSERT_UINT32_UA(&(A), val)  \
             }
#endif

#endif

/****************************************************************************/
/* FLAG macro - parameter indicates bit which flag uses - use as follows:   */
/*                                                                          */
/* #define FILE_OPEN        DCFLAG8(0)                                      */
/* #define FILE_LOCKED      DCFLAG8(1)                                      */
/****************************************************************************/
#define DCFLAG(X)                      ((DCUINT8)  (1 << X))
#define DCFLAG8(X)                     ((DCUINT8)  (1 << X))
#define DCFLAG16(X)                    ((DCUINT16) (1 << X))
#define DCFLAG32(X)                    ((DCUINT32) (1 << X))
#define DCFLAGN(X)                     ((DCUINT)   (1 << X))

/****************************************************************************/
/* Flag manipulation macros:                                                */
/*                                                                          */
/* SET_FLAG       : sets a flag (i.e. assigns 1 to it).                     */
/* CLEAR_FLAG     : clears a flag (i.e. assigns 0 to it).                   */
/* TEST_FLAG      : returns the value of a flag.                            */
/* ASSIGN_FLAG    : takes a boolean value and uses it to set or clear a     */
/*                  flag.                                                   */
/****************************************************************************/
#define SET_FLAG(var, flag)            ((var) |=  (flag))

#ifndef CLEAR_FLAG
#define CLEAR_FLAG(var, flag)          ((var) &= ~(flag))
#endif

#define TEST_FLAG(var, flag)           (((var) &   (flag)) != 0)

#define ASSIGN_FLAG(var, flag, value)                                        \
    if (TRUE == value)                                                       \
    {                                                                        \
        SET_FLAG(var, flag);                                                 \
    }                                                                        \
    else                                                                     \
    {                                                                        \
        CLEAR_FLAG(var, flag);                                               \
    }

/****************************************************************************/
/* Stamp type and macro: each module should use these when stamping its     */
/* data structures.                                                         */
/****************************************************************************/
typedef DCUINT32                       DC_ID_STAMP;

#define DC_MAKE_ID_STAMP(X1, X2, X3, X4)                                    \
   ((DC_ID_STAMP) (((DCUINT32) X4) << 24) |                                 \
                  (((DCUINT32) X3) << 16) |                                 \
                  (((DCUINT32) X2) <<  8) |                                 \
                  (((DCUINT32) X1) <<  0) )

#define MAKE_STAMP16(X1, X2)                                                \
   ((DCUINT16)      (((DCUINT16) X2) <<  8) |                               \
                    (((DCUINT16) X1) <<  0) )

#define MAKE_STAMP32(X1, X2, X3, X4)                                        \
   ((DCUINT32)      (((DCUINT32) X4) << 24) |                               \
                    (((DCUINT32) X3) << 16) |                               \
                    (((DCUINT32) X2) <<  8) |                               \
                    (((DCUINT32) X1) <<  0) )

/****************************************************************************/
/* Other common macros.                                                     */
/****************************************************************************/
#define COM_SIZEOF_RECT(r)                                                  \
    (DCUINT32)((DCUINT32)((r).SRXMAX-(r).SRXMIN)*                           \
               (DCUINT32)((r).SRYMAX-(r).SRYMIN))

/****************************************************************************/
/* Macro to remove the "Unreferenced parameter" warning.                    */
/****************************************************************************/
#define DC_IGNORE_PARAMETER(PARAMETER)   \
                            PARAMETER;

/****************************************************************************/
/* Convert a non-zero value to 1.                                           */
/****************************************************************************/
#define MAKE_BOOL(A)                   (!(!(A)))

/****************************************************************************/
/* This macro works on 32 bit unsigned ticks and returns TRUE if TIME is    */
/* between BEGIN and END (both inclusive) allowing for the wraparound.      */
/****************************************************************************/
#define IN_TIME_RANGE(BEGIN, END, TIME)                                     \
    (((BEGIN) < (END)) ?                                                    \
    (((TIME) >= (BEGIN)) && ((TIME) <= (END))) :                            \
    (((TIME) >= (BEGIN)) || ((TIME) <= (END))))

/****************************************************************************/
/* Minimum and maximum macros.                                              */
/****************************************************************************/
#define DC_MIN(a, b)                   (((a) < (b)) ? (a) : (b))
#define DC_MAX(a, b)                   (((a) > (b)) ? (a) : (b))

/****************************************************************************/
/* Convert BPP to number of colors.                                         */
/****************************************************************************/
#define COLORS_FOR_BPP(BPP) (((BPP) > 8) ? 0 : (1 << (BPP)))

/****************************************************************************/
/* Normalize PALETTEINDEX macro across platforms                            */
/****************************************************************************/
#ifdef OS_WINCE
#define DC_PALINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))
#else // OS_WINCE
#define DC_PALINDEX(i)      PALETTEINDEX(i)
#endif // OS_WINCE

#endif /* _H_ADCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\atrcapi.h ===
/**INC+**********************************************************************/
/* Header:    atrcapi.h                                                     */
/*                                                                          */
/* Purpose:   tracing API header                                            */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/atrcapi.h_v  $
 *
 *    Rev 1.12   05 Sep 1997 10:36:56   SJ
 * SFR1334: Zippy enhancements
 *
 *    Rev 1.11   01 Sep 1997 19:44:04   SJ
 * SFR1333: win16 trace DLL fails to set its default trace options
 *
 *    Rev 1.10   28 Aug 1997 14:46:08   SJ
 * SFR1004: Use new trace groups - modify zippy accordingly
 *
 *    Rev 1.9   22 Aug 1997 15:10:20   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.8   19 Aug 1997 10:58:26   SJ
 * SFR1219: UT_Malloc and UT_Free tracing is confusing
 *
 *    Rev 1.7   31 Jul 1997 19:40:38   SJ
 * SFR1041: Port zippy to Win16
 *
 *    Rev 1.6   14 Jul 1997 12:47:36   SJ
 * SFR1004: Use new trace groups
 *
 *    Rev 1.5   09 Jul 1997 17:05:00   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_ATRCAPI
#define _H_ATRCAPI

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Define the trace level.                                                  */
/*                                                                          */
/* TRC_LEVEL_DBG         : All tracing is enabled                           */
/* TRC_LEVEL_NRM         : Debug level tracing is disabled                  */
/* TRC_LEVEL_ALT         : Normal and debug level tracing is disabled       */
/* TRC_LEVEL_ERR         : Alert, normal and debug level tracing is         */
/*                         disabled                                         */
/* TRC_LEVEL_ASSERT      : Error, alert, normal and debug level tracing     */
/*                         is disabled                                      */
/* TRC_LEVEL_DIS         : All tracing is disabled.                         */
/****************************************************************************/
#define TRC_LEVEL_DBG       0
#define TRC_LEVEL_NRM       1
#define TRC_LEVEL_ALT       2
#define TRC_LEVEL_ERR       3
#define TRC_LEVEL_ASSERT    4
#define TRC_LEVEL_DIS       5

/****************************************************************************/
/* Trace type for profile tracing (function entry / exit)                   */
/****************************************************************************/
#define TRC_PROFILE_TRACE   8

/****************************************************************************/
/* Tracing can be switched off at compile time to allow for 'debug' and     */
/* 'retail' versions of the product.  The following macros disable specific */
/* trace processing.                                                        */
/*                                                                          */
/* TRC_ENABLE_DBG    - Enable debug tracing                                 */
/* TRC_ENABLE_NRM    - Enable normal tracing                                */
/* TRC_ENABLE_ALT    - Enable alert tracing                                 */
/* TRC_ENABLE_ERR    - Enable error tracing                                 */
/* TRC_ENABLE_ASSERT - Enable assert tracing                                */
/* TRC_ENABLE_PRF    - Enable function profile tracing                      */
/****************************************************************************/
#if (TRC_CL == TRC_LEVEL_DBG)
#define TRC_ENABLE_DBG
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_NRM)
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_ALT)
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_ERR)
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_CL == TRC_LEVEL_ASSERT)
#define TRC_ENABLE_ASSERT
#endif

#ifdef TRC_CP
#define TRC_ENABLE_PRF
#endif

/****************************************************************************/
/* Component groups.  These are as follows:                                 */
/*                                                                          */
/* Client side:                                                             */
/* TRC_GROUP_NETWORK             : Network layer                            */
/* TRC_GROUP_SECURITY            : Security layer                           */
/* TRC_GROUP_CORE                : The core                                 */
/* TRC_GROUP_UI                  : User Interface                           */
/* TRC_GROUP_UTILITIES           : Utilities                                */
/* TRC_GROUP_UNUSEDx             : UNUSED                                   */
/* TRC_GROUP_TRACE                                                          */
/*                                                                          */
/****************************************************************************/
#define TRC_GROUP_NETWORK                 DCFLAGN(0)
#define TRC_GROUP_SECURITY                DCFLAGN(1)
#define TRC_GROUP_CORE                    DCFLAGN(2)
#define TRC_GROUP_UI                      DCFLAGN(3)
#define TRC_GROUP_UTILITIES               DCFLAGN(4)
#define TRC_GROUP_UNUSED1                 DCFLAGN(5)
#define TRC_GROUP_UNUSED2                 DCFLAGN(6)
#define TRC_GROUP_UNUSED3                 DCFLAGN(7)
#define TRC_GROUP_UNUSED4                 DCFLAGN(8)
#define TRC_GROUP_UNUSED5                 DCFLAGN(9)
#define TRC_GROUP_TRACE                   DCFLAGN(10)

/****************************************************************************/
/* TRC_GROUP must be defined - if it is not defined then display an error.  */
/****************************************************************************/
#ifndef TRC_GROUP
#error  TRC_GROUP must be defined
#endif /* ifndef TRC_GROUP */

/****************************************************************************/
/* Trace option flags.  These set various tracing options as follows:       */
/*                                                                          */
/* TRC_OPT_BREAK_ON_ERROR      : Break to the debugger on an error.         */
/* TRC_OPT_BEEP_ON_ERROR       : Beep on an error.                          */
/* TRC_OPT_FILE_OUTPUT         : Direct trace output to a disk file.        */
/* TRC_OPT_DEBUGGER_OUTPUT     : Direct trace output to the debugger.       */
/* TRC_OPT_FLUSH_ON_TRACE      : Flush each trace line to the disk file.    */
/* TRC_OPT_PROFILE_TRACING     : Enable profile tracing.                    */
/* TRC_OPT_STACK_TRACING       : Enable stack tracing.                      */
/* TRC_OPT_PROCESS_ID          : Display the process ID on every trace line.*/
/* TRC_OPT_THREAD_ID           : Display the thread (Win32 only) on every   */
/*                               trace line.                                */
/* TRC_OPT_TIME_STAMP          : Display the time stamp on every line.      */
/* TRC_OPT_RELATIVE_TIME_STAMP : (Reserved) Display the relative time.      */
/* TRC_OPT_BREAK_ON_ASSERT     : Break to the debugger on ASSERTS           */
/****************************************************************************/
#define TRC_OPT_BREAK_ON_ERROR          DCFLAG32(0)
#define TRC_OPT_BEEP_ON_ERROR           DCFLAG32(1)
#define TRC_OPT_FILE_OUTPUT             DCFLAG32(2)
#define TRC_OPT_DEBUGGER_OUTPUT         DCFLAG32(3)
#define TRC_OPT_FLUSH_ON_TRACE          DCFLAG32(4)
#define TRC_OPT_PROFILE_TRACING         DCFLAG32(5)
#define TRC_OPT_STACK_TRACING           DCFLAG32(6)
#define TRC_OPT_PROCESS_ID              DCFLAG32(7)
#define TRC_OPT_THREAD_ID               DCFLAG32(8)
#define TRC_OPT_TIME_STAMP              DCFLAG32(9)
#define TRC_OPT_RELATIVE_TIME_STAMP     DCFLAG32(10)
#define TRC_OPT_BREAK_ON_ASSERT         DCFLAG32(11)

/****************************************************************************/
/* Character versions of the maximum and minimum trace levels.              */
/****************************************************************************/
#define TRC_LEVEL_MIN_CHAR     '0'
#define TRC_LEVEL_MAX_CHAR     '5'

/****************************************************************************/
/* Character for function entry / exit tracing.                             */
/****************************************************************************/
#define TRC_LEVEL_PRF_CHAR     'P'

/****************************************************************************/
/* The TRC_TEST macro can be compiled in or out.  When compiled in, it is   */
/* equivalent to TRC_DBG.  It is normally compiled out.  To compile it in,  */
/* define TRC_ENABLE_TST.                                                   */
/****************************************************************************/
#ifdef TRC_ENABLE_TST
#define TRC_TST  TRC_DBG
#else
#define TRC_TST(x)
#endif /* TRC_ENABLE_TST */

/****************************************************************************/
/* The trace function naming macro.                                         */
/****************************************************************************/
#if (TRC_CL < TRC_LEVEL_DIS)
#define TRC_FN(A)       static const DCTCHAR __fnname[]  = _T(A);           \
                        PDCTCHAR trc_fn = (PDCTCHAR)__fnname;               \
                        PDCTCHAR trc_file = _file_name_;
#else
#define TRC_FN(A)
#endif

/****************************************************************************/
/* Entry and exit trace macros.                                             */
/****************************************************************************/
#define TRC_ENTRY  TRC_PRF((TB, TEXT("Enter {")));
#define TRC_EXIT   TRC_PRF((TB, TEXT("Exit  }")));

/****************************************************************************/
/* Trace buffer definition.                                                 */
/* see TRCX below                                                           */
/* the second parameter is the length of the output buffer in characters    */
/* (TRC_LINE_BUFFER_SIZE)                                                   */
/****************************************************************************/
#define TB     TRC_GetBuffer(), 255

/****************************************************************************/
/* Internal buffer sizes.                                                   */
/*                                                                          */
/* TRC_PREFIX_LIST_SIZE  : the length of the prefix string                  */
/* TRC_LINE_BUFFER_SIZE  : the length of the raw trace string as output by  */
/*                         an application                                   */
/* TRC_FRMT_BUFFER_SIZE  : the length of the formatted trace string         */
/*                         buffer - this includes the time, process ID,     */
/*                         thread ID and function name - It must be longer  */
/*                         than TRC_LINE_BUFFER_SIZE                        */
/* TRC_FILE_NAME_SIZE    : the maximum length of the fully qualified        */
/*                         trace output file name.                          */
/****************************************************************************/
#define TRC_PREFIX_LIST_SIZE             100
#define TRC_LINE_BUFFER_SIZE             256
#define TRC_FRMT_BUFFER_SIZE             400
#define TRC_FILE_NAME_SIZE       DC_MAX_PATH

/****************************************************************************/
/* The number of trace files.  This must be set to 2 - any other number is  */
/* not supported.                                                           */
/****************************************************************************/
#define TRC_NUM_FILES                      2

/****************************************************************************/
/* The minimum and maximum file sizes.                                      */
/* In Win32, the trace DLL will fail to initialize if the file size is set  */
/* to zero or to too high a value.                                          */
/* Go for 1 Kb to 32 Meg.                                                   */
/****************************************************************************/
#define TRC_MIN_TRC_FILE_SIZE      (0x400)
#define TRC_MAX_TRC_FILE_SIZE  (0x2000000)

/****************************************************************************/
/* Defaults                                                                 */
/****************************************************************************/
/****************************************************************************/
/* This is a copy of the comment in TRCSetDefaults, which should be updated */
/* whenever these defaults change.                                          */
/*                                                                          */
/* We set the following things:                                             */
/*                                                                          */
/* - trace level to Alert.                                                  */
/* - enable all component groups.                                           */
/* - remove all prefixes.                                                   */
/* - set the maximum trace file size to the default value.                  */
/* - set the data truncation size to the default value.                     */
/* - set the function name size to the default value.                       */
/* - enable the beep and file flags.                                        */
/* - set the first trace file name to TRC1.TXT                              */
/* - set the second trace file name to TRC2.TXT                             */
/* In Win32, additionally                                                   */
/* - set time stamp                                                         */
/* - set process ID                                                         */
/* - set thread ID                                                          */
/*                                                                          */
/****************************************************************************/
#define TRC_DEFAULT_MAX_FILE_SIZE    (100000)
#define TRC_DEFAULT_FUNC_NAME_LENGTH (12)
#define TRC_DEFAULT_DATA_TRUNC_SIZE  (64)
#define TRC_DEFAULT_PREFIX_LIST      (0)
#define TRC_DEFAULT_COMPONENTS       (0xFFFFFFFF)
#ifdef OS_WIN32
#ifdef OS_WINCE
#define TRC_DEFAULT_FLAGS            (TRC_OPT_BEEP_ON_ERROR | \
                                      TRC_OPT_DEBUGGER_OUTPUT | \
                                      TRC_OPT_THREAD_ID | \
                                      TRC_OPT_TIME_STAMP  )
#else // OS_WINCE
#define TRC_DEFAULT_FLAGS            (TRC_OPT_BEEP_ON_ERROR | \
                                      TRC_OPT_DEBUGGER_OUTPUT | \
                                      TRC_OPT_FILE_OUTPUT | \
                                      TRC_OPT_PROCESS_ID | \
                                      TRC_OPT_THREAD_ID | \
                                      TRC_OPT_TIME_STAMP  )
#endif // OS_WINCE
#else ifdef OS_WIN16
#define TRC_DEFAULT_FLAGS            (TRC_OPT_BEEP_ON_ERROR | \
                                      TRC_OPT_DEBUGGER_OUTPUT | \
                                      TRC_OPT_FILE_OUTPUT )
#endif

#define TRC_DEFAULT_TRACE_LEVEL      (TRC_LEVEL_ALT)
#define TRC_DEFAULT_FILE_NAME0       (_T("TRC1.TXT"))
#define TRC_DEFAULT_FILE_NAME1       (_T("TRC2.TXT"))

/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRC_CONFIG                                                               */
/* ==========                                                               */
/* This structure stores information about the current trace configuration. */
/*                                                                          */
/* traceLevel         : the current trace level.                            */
/* components         : currently enabled component groups.                 */
/* maxFileSize        : the maximum trace file size.                        */
/* dataTruncSize      : the amount of data that can be traced at a time.    */
/* flags              : trace flags.                                        */
/* funcNameLength     : number of characters of the function name traced to */
/*                      the output file.                                    */
/* prefixList         : a list of prefixes.                                 */
/* fileNames          : the name of the trace files.                        */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_CONFIG
{
    DCUINT32    traceLevel;
    DCUINT32    dataTruncSize;
    DCUINT32    funcNameLength;
    DCUINT32    components;
    DCUINT32    maxFileSize;
    DCUINT32    flags;
    DCTCHAR     prefixList[TRC_PREFIX_LIST_SIZE];
    DCTCHAR     fileNames[TRC_NUM_FILES][TRC_FILE_NAME_SIZE];
} TRC_CONFIG;

typedef TRC_CONFIG DCPTR PTRC_CONFIG;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* STANDARD TRACING AND ASSERTION MACROS                                    */
/*                                                                          */
/* TRC_ASSERT is for internal assertions and traces an error before popping */
/* up a message box and then terminating.  It is not NLS enabled and should */
/* only be used for calls from one DC component to another.  External APIs  */
/* must not use TRC_ASSERT.                                                 */
/*                                                                          */
/* TRC_ABORT is used on logically unreachable paths (for example            */
/* the default brach of a switch which should cover all cases already).     */
/*                                                                          */
/* A typical trace statement will have the form:                            */
/*                                                                          */
/*    TRC_NRM((TB, _T("Hello world: %hu"), worldNumber));                   */
/*                                                                          */
/* The following macros either expand this to:                              */
/*                                                                          */
/*    TRCX(TRC_LEVEL_NRM, (TB, _T("Hello world: %hu"), worldNumber));       */
/*                                                                          */
/* if normal level tracing is enabled or ignore it if normal level tracing  */
/* is disabled.                                                             */
/*                                                                          */
/****************************************************************************/
#ifdef TRC_ENABLE_DBG
#define TRC_DBG(string)   TRCX(TRC_LEVEL_DBG, string)
#else
#define TRC_DBG(string)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_NRM(string)   TRCX(TRC_LEVEL_NRM, string)
#else
#define TRC_NRM(string)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_ALT(string)   TRCX(TRC_LEVEL_ALT, string)
#else
#define TRC_ALT(string)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_ERR(string)   TRCX(TRC_LEVEL_ERR, string)
#else
#define TRC_ERR(string)
#endif

#ifdef TRC_ENABLE_ASSERT
#define TRC_ASSERT(condition, string)                                        \
              if (!(condition))   TRCX(TRC_LEVEL_ASSERT, string)
#define TRC_ABORT(string)         TRCX(TRC_LEVEL_ASSERT, string)
#else
#define TRC_ASSERT(condition, string)
#define TRC_ABORT(string)
#endif

/****************************************************************************/
/* Function profile (entry/exit) tracing.                                   */
/****************************************************************************/
#ifdef TRC_ENABLE_PRF
#define TRC_PRF(string)   TRCP(string)
#else
#define TRC_PRF(string)
#endif

VOID TRCSaferSprintf(PDCTCHAR outBuf, UINT cchLen, const PDCTCHAR format,...);

/****************************************************************************/
/* Now define the actual tracing macro, TRCX.  This macro compares the      */
/* tracer's level against the global trace level.  If the tracer's level is */
/* the same or higher than the global trace level then we:                  */
/*                                                                          */
/* - print the 'string' which is in the form:                               */
/*   (TB, _T("Hello world %hu"), worldNumber) which expands to              */
/*   (TRC_BufferGet(), "Hello world %hu", worldNumber)                      */
/* - call TRC_BufferTrace to actually trace the line out.                   */
/*                                                                          */
/* Note that TRC_BufferGet() also grabs the mutex to prevent other threads  */
/* from pre-empting us while we are tracing and that TRC_BufferTrace() will */
/* free the mutex for us once the trace line has been written.              */
/****************************************************************************/

/****************************************************************************/
/* Use the comma operator to make sure that TRCX macros to an Lvalue.       */
/* The innermost trc_fn is simply there to ensure that the whole expression */
/* is assignable.  It can be replaced by any other variable, if need be.    */
/****************************************************************************/
#if !defined(TRC_CONVERTOANSI)
#define TRCX(level, string)                                                  \
    (                                                                        \
     (level >= TRC_GetTraceLevel()) ?                                        \
     (                                                                       \
      (TRCSaferSprintf string,                                               \
       TRC_TraceBuffer(level, TRC_GROUP, (DCUINT)__LINE__, trc_fn, trc_file),\
       trc_fn)                                                               \
     )                                                                       \
     :                                                                       \
     0                                                                       \
    )

#define TRCP(string)                                                         \
    {                                                                        \
        if (TRC_ProfileTraceEnabled())                                       \
        {                                                                    \
            TRCSaferSprintf string,                                          \
            TRC_TraceBuffer(TRC_PROFILE_TRACE,                               \
                            TRC_GROUP,                                       \
                            (DCUINT)__LINE__,                                \
                            trc_fn,                                          \
                            trc_file);                                       \
        }                                                                    \
    }
#else
#define TRCX(level, string)                                                  \
    (                                                                        \
     (level >= TRC_GetTraceLevel()) ?                                        \
     (                                                                       \
      (                                                                      \
       TRC_ConvertAndSprintf string,                                         \
       TRC_TraceBuffer(level, TRC_GROUP, (DCUINT)__LINE__, trc_fn, trc_file),\
       trc_fn)                                                               \
     )                                                                       \
     :                                                                       \
     0                                                                       \
    )

#define TRCP(string)                                                         \
    {                                                                        \
        if (TRC_ProfileTraceEnabled())                                       \
        {                                                                    \
            TRC_ConvertAndSprintf string;                                    \
            TRC_TraceBuffer(TRC_PROFILE_TRACE,                               \
                            TRC_GROUP,                                       \
                            (DCUINT)__LINE__,                                \
                            trc_fn,                                          \
                            trc_file);                                       \
        }                                                                    \
    }
#endif

/****************************************************************************/
/* TRACE DATA MACROS                                                        */
/*                                                                          */
/* These are very similar to the standard tracing macros defined above      */
/* except that they do not accept a variable number of parameters.          */
/*                                                                          */
/* A typical ObMan data trace line will have the form:                      */
/*                                                                          */
/*    TRC_DATA_NRM("Some data", pData, sizeof(SOME_DATA));                  */
/*                                                                          */
/* If the appropriate level of tracing is enabled (normal in this case)     */
/* then this line will be expanded by the following macros to:              */
/*                                                                          */
/*    TRCX_DATA(TRC_GROUP_OBMAN, TRC_LEVEL_NRM, "Some data", pData, size);  */
/*                                                                          */
/****************************************************************************/
#ifdef TRC_ENABLE_DBG
#define TRC_DATA_DBG(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_DBG, _T(string), buffer, length)
#else
#define TRC_DATA_DBG(string, buffer, length)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NRM(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_NRM, _T(string), buffer, length)
#else
#define TRC_DATA_NRM(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_DATA_ALT(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_ALT, _T(string), buffer, length)
#else
#define TRC_DATA_ALT(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_DATA_ERR(string, buffer, length)                                 \
          TRCX_DATA(TRC_GROUP, TRC_LEVEL_ERR, _T(string), buffer, length)
#else
#define TRC_DATA_ERR(string, buffer, length)
#endif

/****************************************************************************/
/* Network, TDD and Obman trace data macros - these are just normal level   */
/* data tracing.                                                            */
/****************************************************************************/
#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NET(string, buffer, length)                                 \
         TRCX_DATA(TRC_GROUP_NETDATA, TRC_LEVEL_NRM, string, buffer, length)
#define TRC_DATA_TDD(string, buffer, length)                                 \
         TRCX_DATA(TRC_GROUP_TDDDATA, TRC_LEVEL_NRM, string, buffer, length)
#define TRC_DATA_OBMAN(string, buffer, length)                               \
         TRCX_DATA(TRC_GROUP_OBMANDATA, TRC_LEVEL_NRM, string, buffer, length)
#else
#define TRC_DATA_NET(string, buffer, length)
#define TRC_DATA_TDD(string, buffer, length)
#define TRC_DATA_OBMAN(string, buffer, length)
#endif

/****************************************************************************/
/* Define the trace data macro.  This is used for tracing data blocks.      */
/****************************************************************************/
#define TRCX_DATA(group, level, string, buffer, length)                      \
    {                                                                        \
        if (level >= TRC_GetTraceLevel())                                    \
        {                                                                    \
            TRCSaferSprintf(TB, string);                                     \
            TRC_TraceData(level,                                             \
                          group,                                             \
                          (DCINT)__LINE__,                                   \
                          trc_fn,                                            \
                          trc_file,                                          \
                          (PDCUINT8)buffer,                                  \
                          length);                                           \
        }                                                                    \
    }

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* TRC_Initialize                                                           */
/* TRC_Terminate                                                            */
/* TRC_GetBuffer                                                            */
/* TRC_TraceBuffer                                                          */
/* TRC_GetConfig                                                            */
/* TRC_SetConfig                                                            */
/* TRC_TraceData                                                            */
/* TRC_GetTraceLevel                                                        */
/* TRC_ProfileTraceEnabled                                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* API FUNCTION: TRC_Initialize(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function initializes the tracing for this component.                */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* initShared    : Boolean indicating whether we should attempt to create   */
/*                 the trace config shared memory or not.                   */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* 0             : success.                                                 */
/* TRC_RC_XXX    : failure.                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT32 DCAPI TRC_Initialize(DCBOOL initShared);

/****************************************************************************/
/* API FUNCTION: TRC_Terminate(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function terminates tracing for this component.                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* termShared    : Boolean indicating if shared memory should be released   */
/*                 or not.                                                  */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_Terminate(DCBOOL termShared);

/****************************************************************************/
/* API FUNCTION: TRC_GetBuffer(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function grabs the mutex and returns a pointer to the trace         */
/* buffer.                                                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* A pointer to the trace buffer.                                           */
/*                                                                          */
/****************************************************************************/
PDCTCHAR DCAPI TRC_GetBuffer(DCVOID);

/****************************************************************************/
/* API FUNCTION: TRC_TraceBuffer(...)                                       */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function copies the trace line that is currently in the trace       */
/* buffer into the trace file and / or to the debugger. It assumes that the */
/* mutex has already been acquired before it is called and releases the     */
/* mutex before returning.                                                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceLevel     : the requested trace level.                              */
/* traceComponent : the component group that the source file is in.         */
/* lineNumber     : the line number of the source file traced from.         */
/* funcName       : the function name traced from.                          */
/* fileName       : the file name of the module requesting trace.           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_TraceBuffer(DCUINT   traceLevel,
                             DCUINT   traceComponent,
                             DCUINT   lineNumber,
                             PDCTCHAR funcName,
                             PDCTCHAR fileName);

/****************************************************************************/
/* API FUNCTION: TRC_GetConfig(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function copies the current trace settings into the buffer pointed  */
/* to by pTraceConfig.                                                      */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pTraceConfig  : a pointer to a TRC_CONFIG structure.                     */
/* length        : the length of the buffer.                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE          : success.                                                 */
/* FALSE         : failure.                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_GetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length);

/****************************************************************************/
/* API FUNCTION: TRC_SetConfig(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function sets the trace configuration to that specified in the      */
/* passed TRC_CONFIG structure.                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* pTraceConfig  : a pointer to a TRC_CONFIG structure.                     */
/* length        : the length of the buffer.                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE          : success.                                                 */
/* FALSE         : failure.                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_SetConfig(PTRC_CONFIG pTraceConfig,
                                    DCUINT length);

/****************************************************************************/
/* API FUNCTION: TRC_TraceData(...)                                         */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceLevel     : the requested trace level.                              */
/* traceComponent : the component group that the source file is in.         */
/* lineNumber     : the line number of the source file traced from.         */
/* funcName       : the function name traced from.                          */
/* fileName       : the file name of the module requesting trace.           */
/* buffer         : the actual data to be traced.                           */
/* bufLength      : the length of the data.                                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_TraceData(DCUINT   traceLevel,
                           DCUINT   traceComponent,
                           DCUINT   lineNumber,
                           PDCTCHAR funcName,
                           PDCTCHAR fileName,
                           PDCUINT8 buffer,
                           DCUINT   bufLength);

/****************************************************************************/
/* API FUNCTION: TRC_GetTraceLevel(...)                                     */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function returns the current trace level.                           */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* The current trace level.                                                 */
/*                                                                          */
/****************************************************************************/
DCUINT DCAPI TRC_GetTraceLevel(DCVOID);

/****************************************************************************/
/* API FUNCTION: TRC_ProfileTraceEnabled(...)                               */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function returns the function entry/exit trace setting.             */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE / FALSE - is the profile tracing enabled.                           */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_ProfileTraceEnabled(DCVOID);

/****************************************************************************/
/* API FUNCTION: TRC_ResetTraceFiles(...)                                   */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function resets the trace files.  After checking that trace is      */
/* initialized it calls the OS specific internal function.                  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* None.                                                                    */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* TRUE / FALSE - is the profile tracing enabled.                           */
/*                                                                          */
/****************************************************************************/
DCBOOL DCAPI TRC_ResetTraceFiles(DCVOID);


/****************************************************************************/
/* Before including this file the TRC_FILE macro should be defined.  This   */
/* is much more efficient than relying on __FILE__ to give the correct      */
/* filename since it includes unnecessary path info (and extension info).   */
/* In addition each use of __FILE__ causes a new constant string to be      */
/* placed in the data segment.                                              */
/****************************************************************************/
#if (TRC_CL < TRC_LEVEL_DIS)

    /************************************************************************/
    /* Define another layer for _T() to work around preprocessor problems   */
    /************************************************************************/
#define TRC_T(x) _T(x)

#ifdef TRC_FILE
#define _file_name_ (PDCTCHAR)__filename
static const DCTCHAR __filename[] = TRC_T(TRC_FILE);
#endif /* TRC_FILE */

#endif

/****************************************************************************/
/*                                                                          */
/* OPERATING SYSTEM SPECIFIC INCLUDES                                       */
/*                                                                          */
/****************************************************************************/
#include <wtrcapi.h>

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _H_ATRCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\at120ex.h ===
/****************************************************************************/
// at120ex.h
//
// RDP T.120 protocol extensions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_AT120EX
#define _H_AT120EX


/****************************************************************************/
/* TShare security constants.                                               */
/****************************************************************************/
#include <tssec.h>

#if !defined(OS_WINCE) && !defined(OS_WIN16)
#include <winsta.h>
#endif //OS_WIN16

/****************************************************************************/
/*                                                                          */
/* Definition of GCC User Data used by RDP                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* H221 keys.                                                               */
/****************************************************************************/
#define H221_KEY_LEN            4
#define SERVER_H221_KEY         "McDn"
#define CLIENT_H221_KEY         "Duca"


/****************************************************************************/
/* User data identifiers                                                    */
/****************************************************************************/
/****************************************************************************/
/* Client to Server IDs                                                     */
/****************************************************************************/
#define RNS_UD_CS_CORE_ID       0xc001
#define RNS_UD_CS_SEC_ID        0xc002
#define RNS_UD_CS_NET_ID        0xc003
#define TS_UD_CS_CLUSTER_ID     0xC004

/****************************************************************************/
/* Server to Client IDs                                                     */
/****************************************************************************/
#define RNS_UD_SC_CORE_ID       0x0c01
#define RNS_UD_SC_SEC_ID        0x0c02
#define RNS_UD_SC_NET_ID        0x0c03

/****************************************************************************/
/* Color depths supported                                                   */
/****************************************************************************/
#define RNS_UD_COLOR_4BPP       0xca00
#define RNS_UD_COLOR_8BPP       0xca01
#define RNS_UD_COLOR_16BPP_555  0xca02
#define RNS_UD_COLOR_16BPP_565  0xca03
#define RNS_UD_COLOR_24BPP      0xca04

#ifdef DC_HICOLOR
/****************************************************************************/
/* High color support                                                       */
/****************************************************************************/
#define RNS_UD_24BPP_SUPPORT    0x01
#define RNS_UD_16BPP_SUPPORT    0x02
#define RNS_UD_15BPP_SUPPORT    0x04
#endif

/****************************************************************************/
/* SAS Sequence identifiers (incomplete).                                   */
/* Specifies the SAS sequence the client will use to access the login       */
/* screen in the Server.                                                    */
/****************************************************************************/
#define RNS_UD_SAS_NONE         0xaa01
#define RNS_UD_SAS_CADEL        0xaa02
#define RNS_UD_SAS_DEL          0xaa03
#define RNS_UD_SAS_SYSRQ        0xaa04
#define RNS_UD_SAS_ESC          0xaa05
#define RNS_UD_SAS_F8           0xaa06

/****************************************************************************/
/* Keyboard layout identifiers.                                             */
/****************************************************************************/
#define RNS_UD_KBD_DEFAULT          0


/****************************************************************************/
/* Version number                                                           */
/*      Major version   Minor version                                       */
/*      0xFFFF0000      0x0000FFFF                                          */
/****************************************************************************/
#define RNS_UD_VERSION          0x00080004  // Major 0008 - Minor 0004

#define _RNS_MAJOR_VERSION(x)   (x >> 16)
#define _RNS_MINOR_VERSION(x)   (x & 0x0000ffff)

#define RNS_UD_MAJOR_VERSION    (RNS_UD_VERSION >> 16)
#define RNS_UD_MINOR_VERSION    (RNS_UD_VERSION & 0x0000ffff)

#define RNS_TERMSRV_40_UD_VERSION 0x00080001  // UD version used by Terminal
                                              // server 4.0 RTM
#define RNS_DNS_USERNAME_UD_VERSION 0x00080004 // Usernames longer than 20 ok


/****************************************************************************/
// Security header flags
/****************************************************************************/
#define RNS_SEC_EXCHANGE_PKT        0x0001
#define RNS_SEC_ENCRYPT             0x0008
#define RNS_SEC_RESET_SEQNO         0x0010
#define RNS_SEC_IGNORE_SEQNO        0x0020
#define RNS_SEC_INFO_PKT            0x0040
#define RNS_SEC_LICENSE_PKT         0x0080
#define RDP_SEC_REDIRECTION_PKT     0x0100
#define RDP_SEC_REDIRECTION_PKT2    0x0200
#define RDP_SEC_REDIRECTION_PKT3    0x0400
#define RDP_SEC_SECURE_CHECKSUM     0x0800

//
// If this flag is specified by the server
// it means the client should encrypt all licensing
// packets it sends up to the server.
//
// This happens at this early stage because the server
// has to expose this capability before normal capability
// negotiation.
//
#define RDP_SEC_LICENSE_ENCRYPT_CS  0x0200


/****************************************************************************/
/* Flags which define non-data packets                                      */
/****************************************************************************/
#define RNS_SEC_NONDATA_PKT (RNS_SEC_EXCHANGE_PKT |                         \
                             RNS_SEC_INFO_PKT     |                         \
                             RNS_SEC_LICENSE_PKT  |                         \
                             RDP_SEC_REDIRECTION_PKT |                      \
                             RDP_SEC_REDIRECTION_PKT2 |                     \
                             RDP_SEC_REDIRECTION_PKT3)


/****************************************************************************/
/* RNS info packet flags                                                    */
/****************************************************************************/
#define RNS_INFO_MOUSE                  0x0001
#define RNS_INFO_DISABLECTRLALTDEL      0x0002
#define RNS_INFO_DOUBLECLICKDETECT      0x0004
#define RNS_INFO_AUTOLOGON              0x0008
#define RNS_INFO_UNICODE                0x0010
#define RNS_INFO_MAXIMIZESHELL          0x0020
#define RNS_INFO_LOGONNOTIFY            0x0040
#define RNS_INFO_COMPRESSION            0x0080
#define RNS_INFO_ENABLEWINDOWSKEY       0x0100
#define RNS_INFO_REMOTECONSOLEAUDIO     0x2000

// See compress.h for type values that can appear in these 4 bits.
#define RNS_INFO_COMPR_TYPE_MASK        0x1E00
#define RNS_INFO_COMPR_TYPE_SHIFT       9

// When this flag is set, the client should only send encrypted packet to server
#define RNS_INFO_FORCE_ENCRYPTED_CS_PDU 0x4000

/****************************************************************************/
/* Structure: RNS_SECURITY_HEADER                                           */
/*                                                                          */
/* Description: Security header sent with all packets if encryption is in   */
/*              force.                                                      */
/*                                                                          */
/* This header has the following structure:                                 */
/* - flags  (one or more of the RNS_SEC_ flags above)                       */
/****************************************************************************/
typedef struct tagRNS_SECURITY_HEADER
{
    TSUINT16 flags;
    TSUINT16 flagsHi;
} RNS_SECURITY_HEADER, FAR *PRNS_SECURITY_HEADER;
typedef RNS_SECURITY_HEADER UNALIGNED FAR *PRNS_SECURITY_HEADER_UA;


/****************************************************************************/
/* Structure: RNS_SECURITY_HEADER                                           */
/*                                                                          */
/* Description: Security header sent with all packets if encryption is in   */
/*              force.                                                      */
/*                                                                          */
/* This header has the following structure:                                 */
/* - flags  (one or more of the RNS_SEC_ flags above)                       */
/****************************************************************************/
typedef struct tagRNS_SECURITY_HEADER1
{
    TSUINT16 flags;
    TSUINT16 flagsHi;
    TSINT8   dataSignature[DATA_SIGNATURE_SIZE];
} RNS_SECURITY_HEADER1, FAR *PRNS_SECURITY_HEADER1;
typedef RNS_SECURITY_HEADER1 UNALIGNED FAR *PRNS_SECURITY_HEADER1_UA;


/****************************************************************************/
/* Structure: RNS_SECURITY_PACKET                                           */
/*                                                                          */
/* Description: Structure of security packet sent during security exchange  */
/*                                                                          */
/* The packet has the following structure                                   */
/* - flags  (RNS_SEC_EXCHANGE_PKT)                                          */
/* - length   length of data                                                */
/* - variable length data                                                   */
/****************************************************************************/
typedef struct tagRNS_SECURITY_PACKET
{
    TSUINT32 flags;
    TSUINT32 length;
    /* data follows */
} RNS_SECURITY_PACKET, FAR *PRNS_SECURITY_PACKET;
typedef RNS_SECURITY_PACKET UNALIGNED FAR *PRNS_SECURITY_PACKET_UA;


/****************************************************************************/
// RDP_SERVER_REDIRECTION_PACKET
//
// Used to communicate a server redirection to the client.
/****************************************************************************/
typedef struct
{
    // This corresponds to the security header flags field. We use this to
    // contain the "flag" RDP_SEC_REDIRECTION_PKT.
    TSUINT16 Flags;

    // Overall length of this packet, including the header fields.
    TSUINT16 Length;

    TSUINT32 SessionID;

    // Variable-length, zero-terminated Unicode string. No accompanying size
    // field is given since the size can be determined from the length above.
    // Up to TS_MAX_SERVERADDRESS_LENGTH Unicode characters in length (incl.
    // terminating null).
    TSUINT16 ServerAddress[1];
} RDP_SERVER_REDIRECTION_PACKET, FAR *PRDP_SERVER_REDIRECTION_PACKET;


typedef struct
{
    // This corresponds to the security header flags field. We use this to
    // contain the "flag" RDP_SEC_REDIRECTION_PKT.
    TSUINT16 Flags;

    // Overall length of this packet, including the header fields.
    TSUINT16 Length;

    TSUINT32 SessionID;
    TSUINT32 RedirFlags;
#define TARGET_NET_ADDRESS      0x1
#define LOAD_BALANCE_INFO       0x2

    // Variable-length. For each field, it has the form
    // ULONG Length
    // BYTE  data[]
} RDP_SERVER_REDIRECTION_PACKET_V2, FAR *PRDP_SERVER_REDIRECTION_PACKET_V2;


typedef struct
{
    // This corresponds to the security header flags field. We use this to
    // contain the "flag" RDP_SEC_REDIRECTION_PKT.
    TSUINT16 Flags;

    // Overall length of this packet, including the header fields.
    TSUINT16 Length;

    TSUINT32 SessionID;
    TSUINT32 RedirFlags;
#define TARGET_NET_ADDRESS      0x1
#define LOAD_BALANCE_INFO       0x2
#define LB_USERNAME             0x4
#define LB_DOMAIN               0x8
#define LB_PASSWORD             0x10

    // Variable-length. For each field, it has the form
    // ULONG Length
    // BYTE  data[]
} RDP_SERVER_REDIRECTION_PACKET_V3, FAR *PRDP_SERVER_REDIRECTION_PACKET_V3;

//
// Time zone packet
//
#ifndef _RDP_TIME_ZONE_INFORMATION_
#define _RDP_TIME_ZONE_INFORMATION_
typedef struct _RDP_SYSTEMTIME {
    TSUINT16 wYear;
    TSUINT16 wMonth;
    TSUINT16 wDayOfWeek;
    TSUINT16 wDay;
    TSUINT16 wHour;
    TSUINT16 wMinute;
    TSUINT16 wSecond;
    TSUINT16 wMilliseconds;
} RDP_SYSTEMTIME;

typedef struct _RDP_TIME_ZONE_INFORMATION {
    TSINT32 Bias;
    TSWCHAR StandardName[ 32 ];
    RDP_SYSTEMTIME StandardDate;
    TSINT32 StandardBias;
    TSWCHAR DaylightName[ 32 ];
    RDP_SYSTEMTIME DaylightDate;
    TSINT32 DaylightBias;
} RDP_TIME_ZONE_INFORMATION;
#endif //_RDP_TIME_ZONE_INFORMATION_


/****************************************************************************/
/* Structure: RNS_INFO_PACKET                                               */
/*                                                                          */
/* The packet has the following structure                                   */
/* - fMouse                 Mouse enabled flag                              */
/* - fDisableCtrlAltDel     CtrlAltDel disable state                        */
/* - fDoubleClickDetect     Double click detect state                       */
/* - Domain                 Domain                                          */
/* - UserName               UserName                                        */
/* - Password               Password                                        */
/****************************************************************************/
// The following fields are added post Win2000 Beta 3
// Future variable length fields can be appended to this struct in similar
// fashion

#define RNS_INFO_INVALID_SESSION_ID     LOGONID_NONE

typedef struct tagRNS_EXTENDED_INFO_PACKET
{
   TSUINT16     clientAddressFamily;
   TSUINT16     cbClientAddress;
   TSUINT8      clientAddress[TS_MAX_CLIENTADDRESS_LENGTH];
   TSUINT16     cbClientDir;
   TSUINT8      clientDir[TS_MAX_CLIENTDIR_LENGTH];
   //client time zone information
   RDP_TIME_ZONE_INFORMATION      clientTimeZone;
   TSUINT32     clientSessionId;
   //
   // List of features to disable
   // (flags are defined in the protocol independent header tsperf.h)
   //
   TSUINT32     performanceFlags;
   //
   // Flags field
   //
   TSUINT16     cbAutoReconnectLen;

   //
   // Variable length portion. Only sent up if autoreconnection info
   // is specified
   //
   TSUINT8      autoReconnectCookie[TS_MAX_AUTORECONNECT_LEN];
} RNS_EXTENDED_INFO_PACKET, FAR *PRNS_EXTENDED_INFO_PACKET;
typedef RNS_EXTENDED_INFO_PACKET UNALIGNED FAR *PRNS_EXTENDED_INFO_PACKET_UA;

typedef struct tagRNS_INFO_PACKET
{
    //
    // In UNICODE we reuse the CodePage field to hold the active input
    // locale identifier (formerly called keyboard layout)
    //
    TSUINT32 CodePage;
    TSUINT32 flags;
    TSUINT16 cbDomain;
    TSUINT16 cbUserName;
    TSUINT16 cbPassword;
    TSUINT16 cbAlternateShell;
    TSUINT16 cbWorkingDir;
    TSUINT8  Domain[TS_MAX_DOMAIN_LENGTH];
    TSUINT8  UserName[TS_MAX_USERNAME_LENGTH];
    TSUINT8  Password[TS_MAX_PASSWORD_LENGTH];
    TSUINT8  AlternateShell[TS_MAX_ALTERNATESHELL_LENGTH];
    TSUINT8  WorkingDir[TS_MAX_WORKINGDIR_LENGTH];
    RNS_EXTENDED_INFO_PACKET ExtraInfo;
} RNS_INFO_PACKET, FAR *PRNS_INFO_PACKET;
typedef RNS_INFO_PACKET UNALIGNED FAR *PRNS_INFO_PACKET_UA;


/****************************************************************************/
/* User Data Structures                                                     */
/****************************************************************************/

/****************************************************************************/
/* Structure: RNS_UD_HEADER                                                 */
/*                                                                          */
/* Header included in all user data structures                              */
/* - type       one of the RNS_UD constants above                           */
/* - length     length of data (including this header)                      */
/* - data       one of the data structures below                            */
/****************************************************************************/
typedef struct tagRNS_UD_HEADER
{
    TSUINT16 type;
    TSUINT16 length;
} RNS_UD_HEADER;
typedef RNS_UD_HEADER UNALIGNED FAR *PRNS_UD_HEADER;


/****************************************************************************/
/* Structure: RNS_UD_CS_CORE                                                */
/*                                                                          */
/* Client to Server core data                                               */
/* - header         standard header                                         */
/* - version        software version number                                 */
/* - desktopWidth   width of desktop in pels                                */
/* - desktopHeight  height of desktop in pels                               */
/* - colorDepth     color depth supported - see note below                  */
/* - SASSequence    SAS sequence to use - one of the SAS constants above    */
/* - keyboardLayout Keyboard layout / locale                                */
/* - clientName     Name in Unicode characters                              */
/* - keyboardType        ]                                                  */
/* - keyboardSubType     ] FE stuff                                         */
/* - keyboardFunctionKey ]                                                  */
/* - imeFileName         ]                                                  */
/* - postBeta2ColorDepth Color depth supported - see note below             */
/* - clientProductId                                                        */
/* - serialNumber                                                           */
#ifdef DC_HICOLOR
/* - highColorDepth       preferred color depth (if not 8bpp)               */
/* - supportedColorDepths high color depths supported by client             */
#endif
/****************************************************************************/
#ifdef DC_HICOLOR
/****************************************************************************/
/* Notes on color depths:                                                   */
/*                                                                          */
/* In the NT4 TSE development, beta 2 servers would only accept connections */
/* from clients requesting 8bpp - 4bpp support was only added later.  To    */
/* get around this problem while maintaining back compatibility with beta 2 */
/* servers, the postBeta2ColorDepth field was added which is recognised by  */
/* servers later than beta 2                                                */
/*                                                                          */
/* Later, support for high color depth (15, 16, and 24bpp) connections was  */
/* added to the protocol.  Again, for compatibility with old servers, new   */
/* fields are required.  The highColorDepth field contains the color depth  */
/* the client would like (one of the RNS_UD_COLOR_XX values) while the      */
/* supportedColorDepths field lists the high color depths the client is     */
/* capable of supporting (using the RNS_UD_XXBPP_SUPPORT flags ORed         */
/* together).                                                               */
/*                                                                          */
/* Thus a new client on a 24bpp system will typically advertise the         */
/* following color-related capabilities:                                    */
/*                                                                          */
/* colorDepth           = RNS_UD_COLOR_8BPP   - NT4 TSE Beta 2 servers look */
/*                                              at this field               */
/* postBeta2ColorDepth  = RNS_UD_COLOR_8BPP   - NT4 TSE and Win2000 servers */
/*                                              examine this field          */
/* highColorDepth       = RNS_UD_COLOR_24BPP  - post Win2000 (NT5.1?)       */
/* supportedColorDepths = RNS_UD_24BPP_SUPPORT  servers check these fields  */
/*                        RNS_UD_16BPP_SUPPORT  for preferred and supported */
/*                        RNS_UD_15BPP_SUPPORT  color depths                */
/*                                                                          */
/****************************************************************************/
#else
/****************************************************************************/
/* A note on color depths: A beta2 Server rejects connections from a        */
/* Client with a color depth of 4bpp.  A released Server supports this.     */
/* Therefore a new field, postBeta2ColorDepth, is added, which is           */
/* recognised by released Servers and can take the value 4bpp.  Beta2       */
/* Servers continue to check colorDepth only.                               */
/****************************************************************************/
#endif
typedef struct tagRNS_UD_CS_CORE
{
    RNS_UD_HEADER header;
    TSUINT32      version;
    TSUINT16      desktopWidth;
    TSUINT16      desktopHeight;
    TSUINT16      colorDepth;
    TSUINT16      SASSequence;
    TSUINT32      keyboardLayout;
    TSUINT32      clientBuild;
// Max size same as MAX_COMPUTERNAME_LENGTH in windows.h.
#define RNS_UD_CS_CLIENTNAME_LENGTH 15
    TSUINT16      clientName[RNS_UD_CS_CLIENTNAME_LENGTH + 1];
    TSUINT32      keyboardType;
    TSUINT32      keyboardSubType;
    TSUINT32      keyboardFunctionKey;
    TSUINT16      imeFileName[TS_MAX_IMEFILENAME];    // Unicode string, ASCII code only.
    TSUINT16      postBeta2ColorDepth;
    TSUINT16      clientProductId;
    TSUINT32      serialNumber;
#ifdef DC_HICOLOR
    TSUINT16      highColorDepth;
    TSUINT16      supportedColorDepths;
#endif
    //Used to specify early capability info
    //e.g support for error info PDU has to be
    //setup before licensing (which unfortunately
    //happens after caps negotiation)
#define RNS_UD_CS_SUPPORT_ERRINFO_PDU 0x0001

    TSUINT16      earlyCapabilityFlags;  
//fix shadow loop detection
//meherm 02/09/2001
#define CLIENT_PRODUCT_ID_LENGTH 32
    TSUINT16      clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
        
} RNS_UD_CS_CORE;
typedef RNS_UD_CS_CORE UNALIGNED FAR *PRNS_UD_CS_CORE;
typedef PRNS_UD_CS_CORE UNALIGNED FAR *PPRNS_UD_CS_CORE;

// Original size structure used by shadowing code - do not use!
typedef struct tagRNS_UD_CS_CORE_V0
{
    RNS_UD_HEADER header;
    TSUINT32      version;
    TSUINT16      desktopWidth;
    TSUINT16      desktopHeight;
    TSUINT16      colorDepth;
    TSUINT16      SASSequence;
    TSUINT32      keyboardLayout;
    TSUINT32      clientBuild;
// Max size same as MAX_COMPUTERNAME_LENGTH in windows.h.
#define RNS_UD_CS_CLIENTNAME_LENGTH 15
    TSUINT16      clientName[RNS_UD_CS_CLIENTNAME_LENGTH + 1];
    TSUINT32      keyboardType;
    TSUINT32      keyboardSubType;
    TSUINT32      keyboardFunctionKey;
    TSUINT16      imeFileName[TS_MAX_IMEFILENAME];    // Unicode string, ASCII code only.
    TSUINT16      postBeta2ColorDepth;
    TSUINT16      pad;
} RNS_UD_CS_CORE_V0, FAR *PRNS_UD_CS_CORE_V0;
typedef PRNS_UD_CS_CORE_V0 FAR *PPRNS_UD_CS_CORE_V0;

// Intermediate size structure used by shadowing code - do not use!
typedef struct tagRNS_UD_CS_CORE_V1
{
    RNS_UD_HEADER header;
    TSUINT32      version;
    TSUINT16      desktopWidth;
    TSUINT16      desktopHeight;
    TSUINT16      colorDepth;
    TSUINT16      SASSequence;
    TSUINT32      keyboardLayout;
    TSUINT32      clientBuild;
// Max size same as MAX_COMPUTERNAME_LENGTH in windows.h.
#define RNS_UD_CS_CLIENTNAME_LENGTH 15
    TSUINT16      clientName[RNS_UD_CS_CLIENTNAME_LENGTH + 1];
    TSUINT32      keyboardType;
    TSUINT32      keyboardSubType;
    TSUINT32      keyboardFunctionKey;
    TSUINT16      imeFileName[TS_MAX_IMEFILENAME];    // Unicode string, ASCII code only.
    TSUINT16      postBeta2ColorDepth;
    TSUINT16      clientProductId;
    TSUINT32      serialNumber;
} RNS_UD_CS_CORE_V1, FAR *PRNS_UD_CS_CORE_V1;
typedef PRNS_UD_CS_CORE_V1 FAR *PPRNS_UD_CS_CORE_V1;


/****************************************************************************/
/* Structure: RNS_UD_CS_SEC                                                 */
/*                                                                          */
/* Client to Server security data                                           */
/* - header                 standard header                                 */
/* - encryptionMethods      encryption method supported by the client       */
/* - extEncryptionMethods   used by the French Locale system for backward   */
/*                          compatibility.                                  */
/****************************************************************************/
typedef struct tagRNS_UD_CS_SEC
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethods;
    TSUINT32      extEncryptionMethods;
} RNS_UD_CS_SEC;
typedef RNS_UD_CS_SEC UNALIGNED FAR *PRNS_UD_CS_SEC;
typedef PRNS_UD_CS_SEC UNALIGNED FAR *PPRNS_UD_CS_SEC;

// Original size structure used by shadowing code - do not use!
typedef struct tagRNS_UD_CS_SEC_V0
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethods;
} RNS_UD_CS_SEC_V0, RNS_UD_CS_SEC_V1, FAR *PRNS_UD_CS_SEC_V0, FAR *PRNS_UD_CS_SEC_V1;
typedef PRNS_UD_CS_SEC_V0 FAR *PPRNS_UD_CS_SEC_V0;

/****************************************************************************/
/* Structure: RNS_UD_CS_NET                                                 */
/*                                                                          */
/* Description: Client to Server network data                               */
/* - header             standard header                                     */
/* - channelCount       number of channel names                             */
/* - channel names                                                          */
/****************************************************************************/
typedef struct tagRNS_UD_CS_NET
{
    RNS_UD_HEADER header;
    TSUINT32      channelCount;
    /* array of CHANNEL_DEF structures follows          */
} RNS_UD_CS_NET;
typedef RNS_UD_CS_NET UNALIGNED FAR *PRNS_UD_CS_NET;
typedef PRNS_UD_CS_NET UNALIGNED FAR *PPRNS_UD_CS_NET;

/****************************************************************************/
// TS_UD_CS_CLUSTER
//
// Client-to-server information for server clustering-aware clients.
/****************************************************************************/

// Flag values.

// Client supports basic redirection.
#define TS_CLUSTER_REDIRECTION_SUPPORTED            0x01

// Bits 2..5 represent the version for the PDU
#define TS_CLUSTER_REDIRECTION_VERSION              0x3C
#define TS_CLUSTER_REDIRECTION_VERSION1             0x0
#define TS_CLUSTER_REDIRECTION_VERSION2             0x1
#define TS_CLUSTER_REDIRECTION_VERSION3             0x2

// Set if the client has already been redirected and the SessionID field
// in the struct contains a valid value.
#define TS_CLUSTER_REDIRECTED_SESSIONID_FIELD_VALID 0x02

typedef struct
{
    RNS_UD_HEADER header;
    TSUINT32 Flags;
    TSUINT32 RedirectedSessionID;
} TS_UD_CS_CLUSTER;
typedef TS_UD_CS_CLUSTER UNALIGNED FAR *PTS_UD_CS_CLUSTER;


/****************************************************************************/
/* Structure: RNS_UD_SC_CORE                                                */
/*                                                                          */
/* Server to Client core data                                               */
/* - header             standard header                                     */
/* - version            software version number                             */
/****************************************************************************/
typedef struct tagRNS_UD_SC_CORE
{
    RNS_UD_HEADER header;
    TSUINT32      version;
} RNS_UD_SC_CORE, FAR *PRNS_UD_SC_CORE;


/****************************************************************************/
/* Structure: RNS_UD_SC_SEC                                                 */
/*                                                                          */
/* Server to Client security data                                           */
/* - header             standard header                                     */
/* - encryptionMethod   encryption method selected by the server            */
/* - encryptionLevel    encryption level supported by the server            */
/****************************************************************************/
typedef struct tagRNS_UD_SC_SEC
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethod;
    TSUINT32      encryptionLevel;
} RNS_UD_SC_SEC, FAR *PRNS_UD_SC_SEC, FAR * FAR *PPRNS_UD_SC_SEC;


/****************************************************************************/
/* Structure: RNS_UD_SC_SEC1                                                */
/*                                                                          */
/* Server to Client security data                                           */
/* - header             standard header                                     */
/* - encryptionMethod   encryption method selected by the server            */
/* - serverRandomLen    length of the server random                         */
/* - serverCertLen      server certificate length                           */
/* - server random data                                                     */
/* - server certificate data                                                */
/****************************************************************************/
typedef struct tagRNS_UD_SC_SEC1
{
    RNS_UD_HEADER header;
    TSUINT32      encryptionMethod;
    TSUINT32      encryptionLevel;
    TSUINT32      serverRandomLen;
    TSUINT32      serverCertLen;
    /* server random key data follows */
    /* server certificate data follows */
} RNS_UD_SC_SEC1, FAR *PRNS_UD_SC_SEC1;


/****************************************************************************/
/* Structure: RNS_UD_SC_NET                                                 */
/*                                                                          */
/* Server to Client network data                                            */
/* - header             standard header                                     */
/* - MCSChannelID       T128 MCS channel ID to use                          */
/* - pad                unused                                              */
/* - channelCount       number of channels                                  */
/* - channel IDs                                                            */
/****************************************************************************/
typedef struct tagRNS_UD_SC_NET
{
    RNS_UD_HEADER header;
    TSUINT16      MCSChannelID;
    TSUINT16      channelCount;  /* was pad, but always 0, in release 1   */
    /* array of 2-byte integer MCS channel IDs follows (0 = unknown)        */
} RNS_UD_SC_NET, FAR *PRNS_UD_SC_NET, FAR * FAR *PPRNS_UD_SC_NET;


#endif /* _H_AT120EX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\at128.h ===
/****************************************************************************/
// at128.h
//
// RDP/T.128 definitions
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _H_AT128
#define _H_AT128

/****************************************************************************/
/* Define basic types used in the rest of this header                       */
/****************************************************************************/
typedef unsigned long  TSUINT32, *PTSUINT32;
typedef unsigned short TSUINT16, *PTSUINT16;
typedef short          TSINT16,  *PTSINT16;
typedef unsigned char  TSUINT8,  *PTSUINT8;
typedef char           TSINT8,   *PTSINT8;
typedef short          TSBOOL16, *PTSBOOL16;
typedef long           TSINT32,  *PTSINT32;

typedef unsigned short TSWCHAR; 
typedef TCHAR          TSTCHAR;
typedef ULONG          TSCOLORREF;

/****************************************************************************/
// Turn off compiler padding of structures. Note this means that *all*
// pointers to structs defined in this file will be automatically UNALIGNED,
// which can cause a lot of problems for RISC platforms where unaligned
// means about eight times as much code.
// Save previous packing style if 32-bit build.
/****************************************************************************/
#ifdef OS_WIN16
#pragma pack (1)
#else
#pragma pack (push, t128pack, 1)
#endif

#define INT16_MIN   (-32768) 

/****************************************************************************/
/* Basic type definitions                                                   */
/****************************************************************************/
typedef TSUINT32 TS_SHAREID;

/****************************************************************************/
/* Constants                                                                */
/****************************************************************************/
#define TS_MAX_SOURCEDESCRIPTOR      48
#define TS_MAX_TERMINALDESCRIPTOR    16
#define TS_MAX_FACENAME              32
#define TS_MAX_ORDERS                32
#define TS_MAX_ENC_ORDER_FIELDS      24
#define TS_MAX_DOMAIN_LENGTH         512 
#define TS_MAX_DOMAIN_LENGTH_OLD     52
#define TS_MAX_USERNAME_LENGTH_OLD   44
#define TS_MAX_USERNAME_LENGTH       512
#define TS_MAX_PASSWORD_LENGTH       512 
#define TS_MAX_PASSWORD_LENGTH_OLD   32
#define TS_MAX_ALTERNATESHELL_LENGTH 512
#define TS_MAX_WORKINGDIR_LENGTH     512
#define TS_MAX_CLIENTADDRESS_LENGTH  64
#define TS_MAX_SERVERADDRESS_LENGTH  64
#define TS_MAX_CLIENTDIR_LENGTH      512
#define TS_MAX_GLYPH_CACHES          10
// Max size might be expand if exist very long IME file name.
#define TS_MAX_IMEFILENAME           32
// Length of the autoreconnect cookie
#define TS_MAX_AUTORECONNECT_LEN     128

//
// Autoreconnect verifier that is sent up to the server
//
#define TS_ARC_VERIFIER_LEN          16


/****************************************************************************/
/* Encoded Order types.                                                     */
/* These numbers are the values sent in encoded orders to identify the      */
/* order type. Range is 0..31.                                              */
/****************************************************************************/
#define TS_ENC_DSTBLT_ORDER           0x00
#define TS_ENC_PATBLT_ORDER           0x01
#define TS_ENC_SCRBLT_ORDER           0x02
#define TS_ENC_MEMBLT_ORDER           0x03
#define TS_ENC_MEM3BLT_ORDER          0x04
#define TS_ENC_ATEXTOUT_ORDER         0x05
#define TS_ENC_AEXTTEXTOUT_ORDER      0x06

#ifdef DRAW_NINEGRID
#define TS_ENC_DRAWNINEGRID_ORDER     0x07
#define TS_ENC_MULTI_DRAWNINEGRID_ORDER 0x08
#endif

#define TS_ENC_LINETO_ORDER           0x09
#define TS_ENC_OPAQUERECT_ORDER       0x0a
#define TS_ENC_SAVEBITMAP_ORDER       0x0b
// unused 0x0C
#define TS_ENC_MEMBLT_R2_ORDER        0x0d
#define TS_ENC_MEM3BLT_R2_ORDER       0x0e
#define TS_ENC_MULTIDSTBLT_ORDER      0x0f
#define TS_ENC_MULTIPATBLT_ORDER      0x10
#define TS_ENC_MULTISCRBLT_ORDER      0x11
#define TS_ENC_MULTIOPAQUERECT_ORDER  0x12
#define TS_ENC_FAST_INDEX_ORDER       0x13
#define TS_ENC_POLYGON_SC_ORDER       0x14
#define TS_ENC_POLYGON_CB_ORDER       0x15
#define TS_ENC_POLYLINE_ORDER         0x16
// unused  0x17
#define TS_ENC_FAST_GLYPH_ORDER       0x18
#define TS_ENC_ELLIPSE_SC_ORDER       0x19
#define TS_ENC_ELLIPSE_CB_ORDER       0x1a
#define TS_ENC_INDEX_ORDER            0x1b
#define TS_ENC_WTEXTOUT_ORDER         0x1c
#define TS_ENC_WEXTTEXTOUT_ORDER      0x1d
#define TS_ENC_LONG_WTEXTOUT_ORDER    0x1e
#define TS_ENC_LONG_WEXTTEXTOUT_ORDER 0x1f

#define TS_LAST_ORDER                 0x1f


/****************************************************************************/
/* Order Negotiation constants.                                             */
/* These numbers are indices to TS_ORDER_CAPABILITYSET.orderSupport, used   */
/* to advertise a node's capability to receive each type of encoded order.  */
/* Range is 0..TS_MAX_ORDERS-1.                                             */
/****************************************************************************/
#define TS_NEG_DSTBLT_INDEX          0x0000
#define TS_NEG_PATBLT_INDEX          0x0001
#define TS_NEG_SCRBLT_INDEX          0x0002
#define TS_NEG_MEMBLT_INDEX          0x0003
#define TS_NEG_MEM3BLT_INDEX         0x0004
#define TS_NEG_ATEXTOUT_INDEX        0x0005
#define TS_NEG_AEXTTEXTOUT_INDEX     0x0006

#ifdef DRAW_NINEGRID
#define TS_NEG_DRAWNINEGRID_INDEX    0x0007
#endif

#define TS_NEG_LINETO_INDEX          0x0008

#ifdef DRAW_NINEGRID
#define TS_NEG_MULTI_DRAWNINEGRID_INDEX 0x0009
#endif

#define TS_NEG_OPAQUERECT_INDEX      0x000A
#define TS_NEG_SAVEBITMAP_INDEX      0x000B
#define TS_NEG_WTEXTOUT_INDEX        0x000C
#define TS_NEG_MEMBLT_R2_INDEX       0x000D
#define TS_NEG_MEM3BLT_R2_INDEX      0x000E
#define TS_NEG_MULTIDSTBLT_INDEX     0x000F
#define TS_NEG_MULTIPATBLT_INDEX     0x0010
#define TS_NEG_MULTISCRBLT_INDEX     0x0011
#define TS_NEG_MULTIOPAQUERECT_INDEX 0x0012
#define TS_NEG_FAST_INDEX_INDEX      0x0013
#define TS_NEG_POLYGON_SC_INDEX      0x0014
#define TS_NEG_POLYGON_CB_INDEX      0x0015
#define TS_NEG_POLYLINE_INDEX        0x0016
// unused 0x17
#define TS_NEG_FAST_GLYPH_INDEX      0x0018
#define TS_NEG_ELLIPSE_SC_INDEX      0x0019
#define TS_NEG_ELLIPSE_CB_INDEX      0x001A
#define TS_NEG_INDEX_INDEX           0x001B
#define TS_NEG_WEXTTEXTOUT_INDEX     0x001C
#define TS_NEG_WLONGTEXTOUT_INDEX    0x001D
#define TS_NEG_WLONGEXTTEXTOUT_INDEX 0x001E


/****************************************************************************/
// Primary order bounds encoding description flags.
/****************************************************************************/
#define TS_BOUND_LEFT            0x01
#define TS_BOUND_TOP             0x02
#define TS_BOUND_RIGHT           0x04
#define TS_BOUND_BOTTOM          0x08
#define TS_BOUND_DELTA_LEFT      0x10
#define TS_BOUND_DELTA_TOP       0x20
#define TS_BOUND_DELTA_RIGHT     0x40
#define TS_BOUND_DELTA_BOTTOM    0x80


/****************************************************************************/
/* Structure types                                                          */
/****************************************************************************/

/****************************************************************************/
// TS_POINT16
/****************************************************************************/
typedef struct tagTS_POINT16
{
    TSINT16 x;
    TSINT16 y;
} TS_POINT16, FAR *PTS_POINT16;


/****************************************************************************/
// TS_RECTANGLE16
/****************************************************************************/
typedef struct tagTS_RECTANGLE16
{
    TSINT16 left;
    TSINT16 top;
    TSINT16 right;
    TSINT16 bottom;
} TS_RECTANGLE16, FAR *PTS_RECTANGLE16;


/****************************************************************************/
// TS_RECTANGLE32
/****************************************************************************/
typedef struct tagTS_RECTANGLE32
{
    TSINT32 left;
    TSINT32 top;
    TSINT32 right;
    TSINT32 bottom;
} TS_RECTANGLE32, FAR *PTS_RECTANGLE32;


/****************************************************************************/
/* Structure: TS_SHARECONTROLHEADER                                         */
/*                                                                          */
/* Description: ShareControlHeader                                          */
/* Note that this structure is not DWORD aligned, it relies on the packing  */
/* to ensure that structures following this (within a PDU) are correctly    */
/* aligned (i.e. do not have pad bytes inserted).                           */
/****************************************************************************/
typedef struct tagTS_SHARECONTROLHEADER
{
    TSUINT16 totalLength;
    TSUINT16 pduType;              /* Also encodes the protocol version  */
    TSUINT16 pduSource;
} TS_SHARECONTROLHEADER, FAR *PTS_SHARECONTROLHEADER;


/****************************************************************************/
// TS_BLENDFUNC
//
// This is the alphablend function information
/****************************************************************************/
typedef struct tagTS_BLENDFUNC
{
    BYTE     BlendOp;
    BYTE     BlendFlags;
    BYTE     SourceConstantAlpha;
    BYTE     AlphaFormat;

} TS_BLENDFUNC, FAR *PTS_BLENDFUNC;


/****************************************************************************/
/* Macros to access packet length field.                                    */
/****************************************************************************/
#define TS_DATAPKT_LEN(pPkt) \
        ((pPkt)->shareDataHeader.shareControlHeader.totalLength)
#define TS_CTRLPKT_LEN(pPkt) \
        ((pPkt)->shareControlHeader.totalLength)
#define TS_UNCOMP_LEN(pPkt)  ((pPkt)->shareDataHeader.uncompressedLength)


/****************************************************************************/
/* the pduType field contains the Protocol Version and the PDU type.  These */
/* masks select the relevant field.                                         */
/****************************************************************************/
#define TS_MASK_PDUTYPE          0x000F
#define TS_MASK_PROTOCOLVERSION  0xFFF0

/****************************************************************************/
/* PDUType values                                                           */
/****************************************************************************/
#define TS_PDUTYPE_FIRST                           1
#define TS_PDUTYPE_DEMANDACTIVEPDU                 1
#define TS_PDUTYPE_REQUESTACTIVEPDU                2
#define TS_PDUTYPE_CONFIRMACTIVEPDU                3
#define TS_PDUTYPE_DEACTIVATEOTHERPDU              4
#define TS_PDUTYPE_DEACTIVATESELFPDU               5
#define TS_PDUTYPE_DEACTIVATEALLPDU                6
#define TS_PDUTYPE_DATAPDU                         7
#define TS_PDUTYPE_SERVERCERTIFICATEPDU            8
#define TS_PDUTYPE_CLIENTRANDOMPDU                 9

#define TS_PDUTYPE_LAST                            9
#define TS_NUM_PDUTYPES                            9


/****************************************************************************/
// TS_SHAREDATAHEADER
/****************************************************************************/
typedef struct tagTS_SHAREDATAHEADER
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT8               pad1;
    TSUINT8               streamID;
    TSUINT16              uncompressedLength;
    TSUINT8               pduType2;
    TSUINT8               generalCompressedType;
    TSUINT16              generalCompressedLength;
} TS_SHAREDATAHEADER, FAR * PTS_SHAREDATAHEADER;


/****************************************************************************/
/* streamID values                                                          */
/****************************************************************************/
#define TS_STREAM_LOW       1
#define TS_STREAM_MED       2
#define TS_STREAM_HI        4


/****************************************************************************/
/* PDUType2 values                                                          */
/****************************************************************************/
#define TS_PDUTYPE2_APPLICATION                    25
#define TS_PDUTYPE2_CONTROL                        20
#define TS_PDUTYPE2_FONT                           11
#define TS_PDUTYPE2_INPUT                          28
#define TS_PDUTYPE2_MEDIATEDCONTROL                29
#define TS_PDUTYPE2_POINTER                        27
#define TS_PDUTYPE2_REMOTESHARE                    30
#define TS_PDUTYPE2_SYNCHRONIZE                    31
#define TS_PDUTYPE2_UPDATE                         2
#define TS_PDUTYPE2_UPDATECAPABILITY               32
#define TS_PDUTYPE2_WINDOWACTIVATION               23
#define TS_PDUTYPE2_WINDOWLISTUPDATE               24
#define TS_PDUTYPE2_DESKTOP_SCROLL                 26
#define TS_PDUTYPE2_REFRESH_RECT                   33
#define TS_PDUTYPE2_PLAY_SOUND                     34
#define TS_PDUTYPE2_SUPPRESS_OUTPUT                35
#define TS_PDUTYPE2_SHUTDOWN_REQUEST               36
#define TS_PDUTYPE2_SHUTDOWN_DENIED                37
#define TS_PDUTYPE2_SAVE_SESSION_INFO              38
#define TS_PDUTYPE2_FONTLIST                       39
#define TS_PDUTYPE2_FONTMAP                        40
#define TS_PDUTYPE2_SET_KEYBOARD_INDICATORS        41
#define TS_PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST    43
#define TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU          44
#define TS_PDUTYPE2_SET_KEYBOARD_IME_STATUS        45
#define TS_PDUTYPE2_OFFSCRCACHE_ERROR_PDU          46
#define TS_PDUTYPE2_SET_ERROR_INFO_PDU             47
#ifdef DRAW_NINEGRID
#define TS_PDUTYPE2_DRAWNINEGRID_ERROR_PDU         48
#endif
#ifdef DRAW_GDIPLUS
#define TS_PDUTYPE2_DRAWGDIPLUS_ERROR_PDU          49
#endif
#define TS_PDUTYPE2_ARC_STATUS_PDU                 50

/****************************************************************************/
/* Capabilities Structures:                                                 */
/****************************************************************************/

#define TS_CAPSETTYPE_GENERAL           1
#define TS_CAPSETTYPE_BITMAP            2
#define TS_CAPSETTYPE_ORDER             3
#define TS_CAPSETTYPE_BITMAPCACHE       4
#define TS_CAPSETTYPE_CONTROL           5
#define TS_CAPSETTYPE_ACTIVATION        7
#define TS_CAPSETTYPE_POINTER           8
#define TS_CAPSETTYPE_SHARE             9
#define TS_CAPSETTYPE_COLORCACHE        10
#define TS_CAPSETTYPE_WINDOWLIST        11
#define TS_CAPSETTYPE_SOUND             12
#define TS_CAPSETTYPE_INPUT             13
#define TS_CAPSETTYPE_FONT              14
#define TS_CAPSETTYPE_BRUSH             15
#define TS_CAPSETTYPE_GLYPHCACHE        16
#define TS_CAPSETTYPE_OFFSCREENCACHE    17
#define TS_CAPSETTYPE_BITMAPCACHE_HOSTSUPPORT 18
#define TS_CAPSETTYPE_BITMAPCACHE_REV2  19
#define TS_CAPSETTYPE_VIRTUALCHANNEL    20

#ifdef DRAW_NINEGRID
#define TS_CAPSETTYPE_DRAWNINEGRIDCACHE 21
#endif

#ifdef DRAW_GDIPLUS
#define TS_CAPSETTYPE_DRAWGDIPLUS        22
#endif

#define TS_CAPSFLAG_UNSUPPORTED         0
#define TS_CAPSFLAG_SUPPORTED           1


/****************************************************************************/
// TS_GENERAL_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_GENERAL_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 osMajorType;
#define TS_OSMAJORTYPE_UNSPECIFIED 0
#define TS_OSMAJORTYPE_WINDOWS     1
#define TS_OSMAJORTYPE_OS2         2
#define TS_OSMAJORTYPE_MACINTOSH   3
#define TS_OSMAJORTYPE_UNIX        4

    TSUINT16 osMinorType;
#define TS_OSMINORTYPE_UNSPECIFIED    0
#define TS_OSMINORTYPE_WINDOWS_31X    1
#define TS_OSMINORTYPE_WINDOWS_95     2
#define TS_OSMINORTYPE_WINDOWS_NT     3
#define TS_OSMINORTYPE_OS2_V21        4
#define TS_OSMINORTYPE_POWER_PC       5
#define TS_OSMINORTYPE_MACINTOSH      6
#define TS_OSMINORTYPE_NATIVE_XSERVER 7
#define TS_OSMINORTYPE_PSEUDO_XSERVER 8

    TSUINT16 protocolVersion;
#define TS_CAPS_PROTOCOLVERSION   0x0200
    TSUINT16 pad2octetsA;

    TSUINT16 generalCompressionTypes;

    // This field used to be pad2octetsB.
    // We are reusing the field to hold extra flags
    //
    // Bit 10: TS_EXTRA_NO_BITMAP_COMPRESSION_HDR capability indicates if the
    // server/client supports compressed bitmap without the redundent BC header
    // Note this value is defined in REV2 bitmap extraflags value for consistency
    TSUINT16 extraFlags;
    // Determines that server-to-client fast-path output is supported.
#define TS_FASTPATH_OUTPUT_SUPPORTED        0x0001
    // Tells if the compression level is set and can be negociated for the shadow.
#define TS_SHADOW_COMPRESSION_LEVEL         0x0002
    // Determine if the Client can support Long UserNames and Passwords
#define TS_LONG_CREDENTIALS_SUPPORTED       0x0004
    // Does the client support the reconnect cookie
#define TS_AUTORECONNECT_COOKIE_SUPPORTED   0x0008
    //
    // Support for safe-encryption checksumming
    //  Salt the checksum with the packet count
    //
#define TS_ENC_SECURE_CHECKSUM              0x0010
    

    TSBOOL16 updateCapabilityFlag;
    TSBOOL16 remoteUnshareFlag;
    TSUINT16 generalCompressionLevel;
    TSUINT8  refreshRectSupport; /* can receive refreshRect */
    TSUINT8  suppressOutputSupport; /* and suppressOutputPDU */
} TS_GENERAL_CAPABILITYSET, FAR *PTS_GENERAL_CAPABILITYSET;


/****************************************************************************/
// TS_BITMAP_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_BITMAP_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 preferredBitsPerPixel;
    TSBOOL16 receive1BitPerPixel;
    TSBOOL16 receive4BitsPerPixel;
    TSBOOL16 receive8BitsPerPixel;
    TSUINT16 desktopWidth;
    TSUINT16 desktopHeight;
    TSUINT16 pad2octets;
    TSBOOL16 desktopResizeFlag;
    TSUINT16 bitmapCompressionFlag;

    /************************************************************************/
    /* T.128 extension: fields for supporting > 8bpp color depths           */
    /* highColorFlags values - undefined bits must be set to zero.          */
    /************************************************************************/
#define TS_COLOR_FL_RECEIVE_15BPP 1 /* can receive (5,5,5) */
                                    /* rgbs in bitmap data */
#define TS_COLOR_FL_RECEIVE_16BPP 2 /* can receive (5,6,5) */
#define TS_COLOR_FL_RECEIVE_24BPP 4 /* can receive (8,8,8) */
    TSUINT8  highColorFlags;
    TSUINT8  pad1octet;

    /************************************************************************/
    /* Extension: indicate multiple rectangle support.                      */
    /************************************************************************/
    TSUINT16 multipleRectangleSupport;
    TSUINT16 pad2octetsB;
} TS_BITMAP_CAPABILITYSET, FAR *PTS_BITMAP_CAPABILITYSET;


/****************************************************************************/
// TS_ORDER_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_ORDER_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT8  terminalDescriptor[TS_MAX_TERMINALDESCRIPTOR];
    TSUINT32 pad4octetsA;
    TSUINT16 desktopSaveXGranularity;
    TSUINT16 desktopSaveYGranularity;
    TSUINT16 pad2octetsA;
    TSUINT16 maximumOrderLevel;
    TSUINT16 numberFonts;
    TSUINT16 orderFlags;
#define TS_ORDERFLAGS_NEGOTIATEORDERSUPPORT 0x0002
#define TS_ORDERFLAGS_CANNOTRECEIVEORDERS   0x0004
    /************************************************************************/
    /* TS_ORDERFLAGS_ZEROBOUNDSDELTASSUPPORT                                */
    /* Indicates support for the order encoding flag for zero bounds delta  */
    /* coords (TS_ZERO_BOUNDS_DELTAS).                                      */
    /*                                                                      */
    /* TS_ORDERFLAGS_COLORINDEXSUPPORT                                      */
    /* Indicates support for sending color indices, not RGBs, in orders.    */
    /*                                                                      */
    /* TS_ORDERFLAGS_SOLIDPATTERNBRUSHONLY                                  */
    /* Indicates that this party can receive only solid and pattern brushes.*/
    /************************************************************************/
#define TS_ORDERFLAGS_ZEROBOUNDSDELTASSUPPORT 0x0008
#define TS_ORDERFLAGS_COLORINDEXSUPPORT       0x0020
#define TS_ORDERFLAGS_SOLIDPATTERNBRUSHONLY   0x0040

    TSUINT8  orderSupport[TS_MAX_ORDERS];
    TSUINT16 textFlags;
#define TS_TEXTFLAGS_CHECKFONTASPECT      0x0001
#define TS_TEXTFLAGS_ALLOWDELTAXSIM       0x0020
#define TS_TEXTFLAGS_CHECKFONTSIGNATURES  0x0080
#define TS_TEXTFLAGS_USEBASELINESTART     0x0200
    /************************************************************************/
    /* T.128 extension: allow support for sending font "Cell Height" in     */
    /* addition to the standard "Character Height" in text orders.          */
    /************************************************************************/
#define TS_TEXTFLAGS_ALLOWCELLHEIGHT      0x0400 /* cell height allowed     */
#define TS_TEXT_AND_MASK (TS_TEXTFLAGS_CHECKFONTASPECT     \
                        | TS_TEXTFLAGS_CHECKFONTSIGNATURES \
                        | TS_TEXTFLAGS_USEBASELINESTART    \
                        | TS_TEXTFLAGS_ALLOWCELLHEIGHT)
#define TS_TEXT_OR_MASK (TS_TEXTFLAGS_ALLOWDELTAXSIM)

    TSUINT16 pad2octetsB;
    TSUINT32 pad4octetsB;
    TSUINT32 desktopSaveSize;
    TSUINT16 pad2octetsC;
    TSUINT16 pad2octetsD;
    TSUINT16 textANSICodePage;
#define TS_ANSI_CP_DEFAULT                1252    /* Windows mulitlingual   */
    TSUINT16 pad2octetsE;                         /* caps are DWord aligned */
} TS_ORDER_CAPABILITYSET, FAR * PTS_ORDER_CAPABILITYSET;


/****************************************************************************/
// TS_BITMAPCACHE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_BITMAPCACHE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT32 pad1;
    TSUINT32 pad2;
    TSUINT32 pad3;
    TSUINT32 pad4;
    TSUINT32 pad5;
    TSUINT32 pad6;
    TSUINT16 Cache1Entries;
    TSUINT16 Cache1MaximumCellSize;
    TSUINT16 Cache2Entries;
    TSUINT16 Cache2MaximumCellSize;
    TSUINT16 Cache3Entries;
    TSUINT16 Cache3MaximumCellSize;
} TS_BITMAPCACHE_CAPABILITYSET, FAR * PTS_BITMAPCACHE_CAPABILITYSET;


/****************************************************************************/
// TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT
//
// Sent from the server when it supports greater than rev1 bitmap caching.
// Allows the client to determine what sort of return capabilitites it should
// return in its ConfirmActivePDU.
/****************************************************************************/
typedef struct
{
    TSUINT16 capabilitySetType;  // TS_CAPSETTYPE_BITMAPCACHE_HOSTSUPPORT
    TSUINT16 lengthCapability;

    // Indicates the level of support available on the server. Note
    // that using TS_BITMAPCACHE_REV1 is not supported here, since in that
    // case the HOSTSUPPORT capability should simply not be included in
    // the capabilities sent to the client.
    TSUINT8 CacheVersion;
#define TS_BITMAPCACHE_REV1 0
#define TS_BITMAPCACHE_REV2 1

    TSUINT8  Pad1;
    TSUINT16 Pad2;
} TS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT,
        FAR *PTS_BITMAPCACHE_CAPABILITYSET_HOSTSUPPORT;


/****************************************************************************/
// TS_BITMAPCACHE_CAPABILITYSET_REV2
//
// Sent from client to server when the server indicates it supports rev2
// caching by sending TS_BITMAPCACHE_CAPABILITYSET_REV2_HOSTSUPPORT.
// Corresponds to the expanded capabilities used with persistent bitmap
// caches.
/****************************************************************************/
#define TS_BITMAPCACHE_0_CELL_SIZE 256

#define TS_BITMAPCACHE_SCREEN_ID 0xFF

typedef struct
{
    TSUINT32 NumEntries : 31;
    TSUINT32 bSendBitmapKeys : 1;
} TS_BITMAPCACHE_CELL_CACHE_INFO;

#define BITMAPCACHE_WAITING_LIST_INDEX  32767

typedef struct tagTS_BITMAPCACHE_CAPABILITYSET_REV2
{
    TSUINT16 capabilitySetType;  // TS_CAPSETTYPE_BITMAPCACHE_REV2
    TSUINT16 lengthCapability;

    // Flags.
    TSUINT16 bPersistentKeysExpected : 1;  // Persistent keys to be sent.
    TSUINT16 bAllowCacheWaitingList : 1;
    TSUINT16 Pad1 : 14;

    TSUINT8 Pad2;

    // Number of cell caches ready to be used.
    // The protocol allows maximum 5 caches, the server currently only
    // handles 3 caches.
    TSUINT8 NumCellCaches;
#define TS_BITMAPCACHE_MAX_CELL_CACHES 5
#define TS_BITMAPCACHE_SERVER_CELL_CACHES 3

    // Following space reserved for up to TS_BITMAPCACHE_MAX_CELL_CACHES
    // sets of information.
    TS_BITMAPCACHE_CELL_CACHE_INFO CellCacheInfo[
            TS_BITMAPCACHE_MAX_CELL_CACHES];
} TS_BITMAPCACHE_CAPABILITYSET_REV2, FAR *PTS_BITMAPCACHE_CAPABILITYSET_REV2;


/****************************************************************************/
// TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY
//
// Single bitmap entry for the list of entries that is used to preload the
// bitmap cache at connect time.
/****************************************************************************/
#define TS_BITMAPCACHE_NULL_KEY 0xFFFFFFFF
typedef struct
{
    TSUINT32 Key1;
    TSUINT32 Key2;
} TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY,
        FAR *PTS_BITMAPCACHE_PERSISTENT_LIST_ENTRY;


/****************************************************************************/
// TS_BITMAPCACHE_PERSISTENT_LIST
//
// Specifies one of a set of bitmap cache persistent entry preload lists.
/****************************************************************************/

// Defines the upper limit on the number of keys that can be specified
// in the combined TotalEntries below. More than this constitutes a
// breach of protocol and is cause for session termination.
#define TS_BITMAPCACHE_MAX_TOTAL_PERSISTENT_KEYS (256 * 1024)

typedef struct
{
    // Contains TS_PDUTYPE2_BITMAPCACHE_PERSISTENT_LIST as the secondary
    // PDU type.
    TS_SHAREDATAHEADER shareDataHeader;

    TSUINT16 NumEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    TSUINT16 TotalEntries[TS_BITMAPCACHE_MAX_CELL_CACHES];
    TSUINT8  bFirstPDU : 1;
    TSUINT8  bLastPDU : 1;
    TSUINT8  Pad1 : 6;
    TSUINT8  Pad2;
    TSUINT16 Pad3;
    TS_BITMAPCACHE_PERSISTENT_LIST_ENTRY Entries[1];
} TS_BITMAPCACHE_PERSISTENT_LIST, FAR *PTS_BITMAPCACHE_PERSISTENT_LIST;


/****************************************************************************/
// TS_BITMAPCACHE_ERROR_PDU
//
// Sent when the client encounters a catastrophic error in its caching.
// This PDU is sent to inform the server of the problem and what actions to
// take with each of the cell caches.
/****************************************************************************/

// maximum number of error pdus a client is allowed to send for a session
// this is also the maximum number of error pdus a server will handle
#define MAX_NUM_ERROR_PDU_SEND     5

typedef struct
{
    // Specifies the cache ID in this info block.
    TSUINT8 CacheID;

    // Specifies that the cache should have its contents emptied.
    // If FALSE and a NewNumEntries specifies a new nonzero size, the previous
    // cache contents in the initial (NewNumEntries) cells will be preserved.
    TSUINT8 bFlushCache : 1;

    // Specifies that the NewNumEntries field is valid.
    TSUINT8 bNewNumEntriesValid : 1;

    TSUINT8  Pad1 : 6;
    TSUINT16 Pad2;

    // New number of entries in the cache. Must be less than or equal to the
    // number of entries previously sent in the capabilities.
    TSUINT32 NewNumEntries;
} TS_BITMAPCACHE_ERROR_INFO, FAR *PTS_BITMAPCACHE_ERROR_INFO;

typedef struct
{
    // Contains TS_PDUTYPE2_BITMAPCACHE_ERROR_PDU as the secondary
    // PDU type.
    TS_SHAREDATAHEADER shareDataHeader;

    TSUINT8 NumInfoBlocks;

    TSUINT8  Pad1;
    TSUINT16 Pad2;

    TS_BITMAPCACHE_ERROR_INFO Info[1];
} TS_BITMAPCACHE_ERROR_PDU, FAR *PTS_BITMAPCACHE_ERROR_PDU;


/****************************************************************************/
// TS_OFFSCRCACHE_ERROR_PDU
/****************************************************************************/
typedef struct
{
    // Contains TS_PDUTYPE2_OFFSCRCACHE_ERROR_PDU as the secondary
    // PDU type
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           flags;
#define TS_FLUSH_AND_DISABLE_OFFSCREEN    0x1

} TS_OFFSCRCACHE_ERROR_PDU, FAR *PTS_OFFSCRCACHE_ERROR_PDU;

#ifdef DRAW_NINEGRID
/****************************************************************************/
// TS_DRAWNINEGRID_ERROR_PDU
/****************************************************************************/
typedef struct
{
    // Contains TS_PDUTYPE2_DRAWNINEGRID_ERROR_PDU as the secondary
    // PDU type
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           flags;
#define TS_FLUSH_AND_DISABLE_DRAWNINEGRID    0x1

} TS_DRAWNINEGRID_ERROR_PDU, FAR *PTS_DRAWNINEGRID_ERROR_PDU;
#endif

#ifdef DRAW_GDIPLUS
typedef struct
{
    // Contains TS_PDUTYPE2_DRAWGDIPLUS_ERROR_PDU as the secondary
    // PDU type
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           flags;
#define TS_FLUSH_AND_DISABLE_DRAWGDIPLUS    0x1

} TS_DRAWGDIPLUS_ERROR_PDU, FAR *PTS_DRAWGDIPLUS_ERROR_PDU;
#endif


/****************************************************************************/
// TS_COLORTABLECACHE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_COLORTABLECACHE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 colorTableCacheSize;
    TSUINT16 pad2octets;                          /* caps are DWORD aligned */
} TS_COLORTABLECACHE_CAPABILITYSET, FAR * PTS_COLORTABLECACHE_CAPABILITYSET;


/****************************************************************************/
// TS_WINDOWACTIVATION_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_WINDOWACTIVATION_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSBOOL16 helpKeyFlag;
    TSBOOL16 helpKeyIndexFlag;
    TSBOOL16 helpExtendedKeyFlag;
    TSBOOL16 windowManagerKeyFlag;
} TS_WINDOWACTIVATION_CAPABILITYSET, FAR * PTS_WINDOWACTIVATION_CAPABILITYSET;


/****************************************************************************/
// TS_CONTROL_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_CONTROL_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 controlFlags;
#define TS_CAPS_CONTROL_ALLOWMEDIATEDCONTROL 1

    TSBOOL16 remoteDetachFlag;
    TSUINT16 controlInterest;
#define TS_CONTROLPRIORITY_ALWAYS    1
#define TS_CONTROLPRIORITY_NEVER     2
#define TS_CONTROLPRIORITY_CONFIRM   3

    TSUINT16 detachInterest;
} TS_CONTROL_CAPABILITYSET, FAR * PTS_CONTROL_CAPABILITYSET;


/****************************************************************************/
// TS_POINTER_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_POINTER_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSBOOL16 colorPointerFlag;
    TSUINT16 colorPointerCacheSize;
    TSUINT16 pointerCacheSize;
} TS_POINTER_CAPABILITYSET, FAR * PTS_POINTER_CAPABILITYSET;


/****************************************************************************/
// TS_SHARE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_SHARE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 nodeID;
    TSUINT16 pad2octets;                          /* caps are DWORD aligned */
} TS_SHARE_CAPABILITYSET, FAR * PTS_SHARE_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_SOUND_CAPABILITYSET                                        */
/*                                                                          */
/* Description: Extension to T.128 for sound support                        */
/*                                                                          */
/* Set TS_SOUND_FLAG_BEEPS if capable of replaying beeps                    */
/* all undefined bits in soundFlags must be zero                            */
/****************************************************************************/
typedef struct tagTS_SOUND_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 soundFlags;
#define TS_SOUND_FLAG_BEEPS 0x0001

    TSUINT16 pad2octetsA;
} TS_SOUND_CAPABILITYSET, FAR * PTS_SOUND_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_INPUT_CAPABILITYSET                                        */
/*                                                                          */
/* Description: Extension to T.128 for input support                        */
/****************************************************************************/
typedef struct tagTS_INPUT_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
    TSUINT16 inputFlags;
    /************************************************************************/
    /* If TS_INPUT_FLAG_SCANCODES is set, it should be interpreted as 'this */
    /* party understands TS_INPUT_EVENT_SCANCODE'.  When all parties in a   */
    /* call support scancodes, scancodes should be sent in preference to    */
    /* codepoints, virtual keys or hotkeys.                                 */
    /************************************************************************/
#define TS_INPUT_FLAG_SCANCODES      0x0001
    /************************************************************************/
    /* If TS_INPUT_FLAG_CPVK is set, it should be interpreted as 'this      */
    /* party understands TS_INPUT_EVENT_CODEPOINT and                       */
    /* TS_INPUT_EVENT_VIRTUALKEY'                                           */
    /************************************************************************/
#define TS_INPUT_FLAG_CPVK           0x0002
    /************************************************************************/
    /* If TS_INPUT_FLAG_MOUSEX is set, it should be interpreted as 'this    */
    /* party can send or receive TS_INPUT_EVENT_MOUSEX'                     */
    /************************************************************************/
#define TS_INPUT_FLAG_MOUSEX         0x0004
    //
    // Specifies server support for fast-path input packets.
    // Deprecated because of an encryption security bug which affects input
    // packets
    //
#define TS_INPUT_FLAG_FASTPATH_INPUT 0x0008
    // Server support for receiving injected Unicode input from the client
#define TS_INPUT_FLAG_VKPACKET       0x0010
    //
    // New style fast path input identifier added to allow new clients that
    // have safe (fixed) encryption checksumming to use fastpath, all old clients
    // have to use slow path as that is unaffected by the security bug
    //
#define TS_INPUT_FLAG_FASTPATH_INPUT2 0x0020

    TSUINT16 pad2octetsA;
    TSUINT32 keyboardLayout;
    TSUINT32 keyboardType;
    TSUINT32 keyboardSubType;
    TSUINT32 keyboardFunctionKey;
    TSUINT16 imeFileName[TS_MAX_IMEFILENAME]; /* Unicode string, ASCII only */
} TS_INPUT_CAPABILITYSET, FAR * PTS_INPUT_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_FONT_CAPABILITYSET                                         */
/*                                                                          */
/* Description: Fontlist/map support                                        */
/****************************************************************************/
typedef struct tagTS_FONT_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

#define TS_FONTSUPPORT_FONTLIST 0x0001

    TSUINT16 fontSupportFlags;
    TSUINT16 pad2octets;
} TS_FONT_CAPABILITYSET, FAR * PTS_FONT_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_CACHE_DEFINITION                                           */
/*                                                                          */
/* Description: Extension to T.128 for glyph cache support                  */
/****************************************************************************/
typedef struct tagTS_CACHE_DEFINITION
{
    TSUINT16 CacheEntries;
    TSUINT16 CacheMaximumCellSize;
} TS_CACHE_DEFINITION, FAR * PTS_CACHE_DEFINITION;


/****************************************************************************/
// TS_GLYPHCACHE_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_GLYPHCACHE_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TS_CACHE_DEFINITION GlyphCache[TS_MAX_GLYPH_CACHES];
    TS_CACHE_DEFINITION FragCache;

    TSUINT16            GlyphSupportLevel;
    TSUINT16            pad2octets;
} TS_GLYPHCACHE_CAPABILITYSET, FAR * PTS_GLYPHCACHE_CAPABILITYSET;


/****************************************************************************/
// TS_BRUSH_CAPABILITYSET
/****************************************************************************/
typedef struct tagTS_BRUSH_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

#define TS_BRUSH_DEFAULT    0x0000
#define TS_BRUSH_COLOR8x8   0x0001
#define TS_BRUSH_COLOR_FULL 0x0002

    TSUINT32 brushSupportLevel;
} TS_BRUSH_CAPABILITYSET, FAR * PTS_BRUSH_CAPABILITYSET;


/****************************************************************************/
// Structure: TS_OFFSCREEN_CAPABILITYSET                                        
//   
// This is the capability set for the offscreen bitmap support
/****************************************************************************/
typedef struct tagTS_OFFSCREEN_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TSUINT32 offscreenSupportLevel;
#define TS_OFFSCREEN_DEFAULT     0x0000
#define TS_OFFSCREEN_SUPPORTED   0x0001
    
    // Unlike memory bitmap cache which has fixed bitmap cache entry size,
    // offscreen bitmap size varies depending on the apps.  So, we want to
    // allow both entries and cache size be to adjustable
    TSUINT16 offscreenCacheSize;
#define TS_OFFSCREEN_CACHE_SIZE_DEFAULT    2560    // in KB, 2.5 MB cache memory

    TSUINT16 offscreenCacheEntries;
#define TS_OFFSCREEN_CACHE_ENTRIES_DEFAULT 100     // 100 cache entries

} TS_OFFSCREEN_CAPABILITYSET, FAR * PTS_OFFSCREEN_CAPABILITYSET;

#ifdef DRAW_GDIPLUS
typedef struct tagTS_GDIPLUS_CACHE_ENTRIES
{
    TSUINT16 GdipGraphicsCacheEntries;
#define TS_GDIP_GRAPHICS_CACHE_ENTRIES_DEFAULT  10
    TSUINT16 GdipObjectBrushCacheEntries;
#define TS_GDIP_BRUSH_CACHE_ENTRIES_DEFAULT  5
    TSUINT16 GdipObjectPenCacheEntries;
#define TS_GDIP_PEN_CACHE_ENTRIES_DEFAULT  5
    TSUINT16 GdipObjectImageCacheEntries;
#define TS_GDIP_IMAGE_CACHE_ENTRIES_DEFAULT  10
    TSUINT16 GdipObjectImageAttributesCacheEntries;
#define TS_GDIP_IMAGEATTRIBUTES_CACHE_ENTRIES_DEFAULT  2
} TS_GDIPLUS_CACHE_ENTRIES, FAR *PTS_GDIPLUS_CACHE_ENTRIES;

typedef struct tagTS_GDIPLUS_CACHE_CHUNK_SIZE
{
    TSUINT16 GdipGraphicsCacheChunkSize;
#define TS_GDIP_GRAPHICS_CACHE_CHUNK_SIZE_DEFAULT 512
    TSUINT16 GdipObjectBrushCacheChunkSize;
#define TS_GDIP_BRUSH_CACHE_CHUNK_SIZE_DEFAULT 2*1024
    TSUINT16 GdipObjectPenCacheChunkSize;
#define TS_GDIP_PEN_CACHE_CHUNK_SIZE_DEFAULT 1024
    TSUINT16 GdipObjectImageAttributesCacheChunkSize;
#define TS_GDIP_IMAGEATTRIBUTES_CACHE_CHUNK_SIZE_DEFAULT 64
} TS_GDIPLUS_CACHE_CHUNK_SIZE, FAR * PTS_GDIPLUS_CACHE_CHUNK_SIZE;

typedef struct tag_TS_GDIPLUS_IMAGE_CACHE_PROPERTIES
{
    TSUINT16 GdipObjectImageCacheChunkSize;
#define TS_GDIP_IMAGE_CACHE_CHUNK_SIZE_DEFAULT 4*1024
    TSUINT16 GdipObjectImageCacheTotalSize;
#define TS_GDIP_IMAGE_CACHE_TOTAL_SIZE_DEFAULT 256 // In number of chunks
    TSUINT16 GdipObjectImageCacheMaxSize;
#define TS_GDIP_IMAGE_CACHE_MAX_SIZE_DEFAULT 128 //  In number of chunks
} TS_GDIPLUS_IMAGE_CACHE_PROPERTIES, FAR * PTS_GDIPLUS_IMAGE_CACHE_PROPERTIES;

typedef struct tagTS_DRAW_GDIPLUS_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TSUINT32 drawGdiplusSupportLevel;
#define TS_DRAW_GDIPLUS_DEFAULT     0x0000
#define TS_DRAW_GDIPLUS_SUPPORTED   0x0001
    TSUINT32 GdipVersion;
#define TS_GDIPVERSION_DEFAULT 0x0
    TSUINT32 drawGdiplusCacheLevel;
#define TS_DRAW_GDIPLUS_CACHE_LEVEL_DEFAULT 0x0
#define TS_DRAW_GDIPLUS_CACHE_LEVEL_ONE     0x1
    TS_GDIPLUS_CACHE_ENTRIES GdipCacheEntries;
    TS_GDIPLUS_CACHE_CHUNK_SIZE GdipCacheChunkSize;
    TS_GDIPLUS_IMAGE_CACHE_PROPERTIES GdipImageCacheProperties;
} TS_DRAW_GDIPLUS_CAPABILITYSET, FAR * PTS_DRAW_GDIPLUS_CAPABILITYSET;

#define ActualSizeToChunkSize(Size, ChunkSize) (((Size) + (ChunkSize - 1)) / ChunkSize)
#endif // DRAW_GDIPLUS

#ifdef DRAW_NINEGRID
/****************************************************************************/
// Structure: TS_DRAW_NINEGRID_CAPABILITYSET                                        
//   
// This is the capability set for the draw ninegrid support
/****************************************************************************/
typedef struct tagTS_DRAW_NINEGRID_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    TSUINT32 drawNineGridSupportLevel;
#define TS_DRAW_NINEGRID_DEFAULT     0x0000
#define TS_DRAW_NINEGRID_SUPPORTED   0x0001
#define TS_DRAW_NINEGRID_SUPPORTED_REV2   0x0002
    
    // Unlike memory bitmap cache which has fixed bitmap cache entry size,
    // drawninegrid bitmap size varies.  So, we want to allow both entries 
    // and cache size be to adjustable
    TSUINT16 drawNineGridCacheSize;
#define TS_DRAW_NINEGRID_CACHE_SIZE_DEFAULT    2560    // in KB, 2.5 MB cache memory

    TSUINT16 drawNineGridCacheEntries;
#define TS_DRAW_NINEGRID_CACHE_ENTRIES_DEFAULT 256     // 256 cache entries

} TS_DRAW_NINEGRID_CAPABILITYSET, FAR * PTS_DRAW_NINEGRID_CAPABILITYSET;
#endif

/****************************************************************************/
// Structure: TS_VIRTUALCHANNEL_CAPABILITYSET                                        
//   
// This is the capability set for virtual channels
/****************************************************************************/
typedef struct tagTS_VIRTUALCHANNEL_CAPABILITYSET
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;

    //
    // Server and client may adverise different capabilities
    // e.g today for scalability reasons C->S is limited to 8K
    // but S->C is 64K
    //
    //
#define TS_VCCAPS_DEFAULT                 0x0000
#define TS_VCCAPS_COMPRESSION_64K         0x0001
#define TS_VCCAPS_COMPRESSION_8K          0x0002
    TSUINT32 vccaps1;
} TS_VIRTUALCHANNEL_CAPABILITYSET, FAR * PTS_VIRTUALCHANNEL_CAPABILITYSET;

/****************************************************************************/
// TS_COMBINED_CAPABILITIES
/****************************************************************************/
typedef struct tagTS_COMBINED_CAPABILITIES
{
    TSUINT16 numberCapabilities;
    TSUINT16 pad2octets;
    TSUINT8  data[1];
} TS_COMBINED_CAPABILITIES, FAR * PTS_COMBINED_CAPABILITIES;


/****************************************************************************/
// TS_CAPABILITYHEADER
/****************************************************************************/
typedef struct tagTS_CAPABILITYHEADER
{
    TSUINT16 capabilitySetType;
    TSUINT16 lengthCapability;
} TS_CAPABILITYHEADER, FAR * PTS_CAPABILITYHEADER;


/****************************************************************************/
// TS_FONT_ATTRIBUTE
/****************************************************************************/
typedef struct tagTS_FONT_ATTRIBUTE
{
    TSUINT8  faceName[TS_MAX_FACENAME];
    TSUINT16 fontAttributeFlags;
#define TS_FONTFLAGS_FIXED_PITCH       0x0001
#define TS_FONTFLAGS_FIXED_SIZE        0x0002
#define TS_FONTFLAGS_ITALIC            0x0004
#define TS_FONTFLAGS_UNDERLINE         0x0008
#define TS_FONTFLAGS_STRIKEOUT         0x0010
#define TS_FONTFLAGS_TRUETYPE          0x0080
#define TS_FONTFLAGS_BASELINE          0x0100
#define TS_FONTFLAGS_UNICODE_COMPLIANT 0x0200
// Cell Height (rather than default Character Height) support.
#define TS_FONTFLAGS_CELLHEIGHT        0x0400

    TSUINT16 averageWidth;
    TSUINT16 height;
    TSUINT16 aspectX;
    TSUINT16 aspectY;
    TSUINT8  signature1;
#define TS_SIZECALCULATION_HEIGHT 100
#define TS_SIZECALCULATION_WIDTH  100
#define TS_SIG1_RANGE1_FIRST      0x30
#define TS_SIG1_RANGE1_LAST       0x5A
#define TS_SIG1_RANGE2_FIRST      0x24
#define TS_SIG1_RANGE2_LAST       0x26

    TSUINT8  signature2;
#define TS_SIG2_RANGE_FIRST       0x20
#define TS_SIG2_RANGE_LAST        0x7E

    TSUINT16 signature3;
#define TS_SIG3_RANGE1_FIRST      0x00
#define TS_SIG3_RANGE1_LAST       0x1E
#define TS_SIG3_RANGE2_FIRST      0x80
#define TS_SIG3_RANGE2_LAST       0xFE

    TSUINT16 codePage;
#define TS_CODEPAGE_ALLCODEPOINTS  0
#define TS_CODEPAGE_CORECODEPOINTS 255

    TSUINT16 ascent;
} TS_FONT_ATTRIBUTE, FAR *PTS_FONT_ATTRIBUTE;


/****************************************************************************/
// TS_KEYBOARD_EVENT
//
// See also the fast-path keyboard format specified below.
/****************************************************************************/
typedef struct tagTS_KEYBOARD_EVENT
{
    TSUINT16 keyboardFlags;
#define TS_KBDFLAGS_RIGHT           0x0001
#define TS_KBDFLAGS_QUIET           0x1000
#define TS_KBDFLAGS_DOWN            0x4000
#define TS_KBDFLAGS_RELEASE         0x8000

#define TS_KBDFLAGS_SECONDARY       0x0080
#define TS_KBDFLAGS_EXTENDED        0x0100
#define TS_KBDFLAGS_EXTENDED1       0x0200
#define TS_KBDFLAGS_ALT_DOWN        0x2000

    TSUINT16 keyCode;
    TSUINT16 pad2octets;
} TS_KEYBOARD_EVENT, FAR *PTS_KEYBOARD_EVENT;


/****************************************************************************/
// TS_SYNC_EVENT
//
// Sets toggle keys on server.
// See also the fast-path sync format specified below.
/****************************************************************************/
typedef struct tagTS_SYNC_EVENT
{
    TSUINT16 pad2octets;
    TSUINT32 toggleFlags;
#define TS_SYNC_KANA_LOCK     8
#define TS_SYNC_CAPS_LOCK     4
#define TS_SYNC_NUM_LOCK      2
#define TS_SYNC_SCROLL_LOCK   1

} TS_SYNC_EVENT, FAR *PTS_SYNC_EVENT;


/****************************************************************************/
// TS_POINTER_EVENT
//
// See also the fast-path mouse format specified below.
/****************************************************************************/
typedef struct tagTS_POINTER_EVENT
{
    TSUINT16 pointerFlags;

// Extensions for wheel-mouse support.
#define TS_FLAG_MOUSE_WHEEL         ((TSUINT16)0x0200)
#define TS_FLAG_MOUSE_DIRECTION     ((TSUINT16)0x0100)
#define TS_FLAG_MOUSE_ROTATION_MASK ((TSUINT16)0x01FF)
#define TS_FLAG_MOUSE_DOUBLE        ((TSUINT16)0x0400)

#define TS_FLAG_MOUSE_MOVE          ((TSUINT16)0x0800)
#define TS_FLAG_MOUSE_BUTTON1       ((TSUINT16)0x1000)
#define TS_FLAG_MOUSE_BUTTON2       ((TSUINT16)0x2000)
#define TS_FLAG_MOUSE_BUTTON3       ((TSUINT16)0x4000)
#define TS_FLAG_MOUSE_DOWN          ((TSUINT16)0x8000)

#define TS_FLAG_MOUSEX_BUTTON1      ((TSUINT16)0x0001)
#define TS_FLAG_MOUSEX_BUTTON2      ((TSUINT16)0x0002)
#define TS_FLAG_MOUSEX_DOWN         ((TSUINT16)0x8000)

    TSINT16  x;
    TSINT16  y;
} TS_POINTER_EVENT, FAR *PTS_POINTER_EVENT;


/****************************************************************************/
// TS_INPUT_EVENT
//
// See also the fast-path input event formats specified below.
/****************************************************************************/
typedef struct tagTS_INPUT_EVENT
{
    TSUINT32 eventTime;
    TSUINT16 messageType;
#define TS_INPUT_EVENT_SYNC            0
#define TS_INPUT_EVENT_CODEPOINT       1
#define TS_INPUT_EVENT_VIRTUALKEY      2
#define TS_INPUT_EVENT_HOTKEY          3
// Indicates client sends all keyboard input as raw scan codes.
#define TS_INPUT_EVENT_SCANCODE        4
// Indivates support for VKPACKET input. This is the same format
// as TS_INPUT_EVENT_SCANCODE but the meaning is interpreted
// differently - scancode is a unicode character
//
#define TS_INPUT_EVENT_VKPACKET        5
#define TS_INPUT_EVENT_MOUSE      0x8001
// MOUSEX allows us to support extended mouse buttons
// It still implies TS_POINTER_EVENT, but with different flag meanings
#define TS_INPUT_EVENT_MOUSEX     0x8002

    union
    {
        TS_KEYBOARD_EVENT key;
        TS_POINTER_EVENT  mouse;
        TS_SYNC_EVENT     sync;
    } u;
} TS_INPUT_EVENT, FAR * PTS_INPUT_EVENT;


/****************************************************************************/
// TS_INPUT_PDU
//
// Variable length list of TS_INPUT_EVENTs.
// See also the fast-path input format specified below.
/****************************************************************************/
typedef struct tagTS_INPUT_PDU
{
    TS_SHAREDATAHEADER       shareDataHeader;
    TSUINT16                 numberEvents;
    TSUINT16                 pad2octets;
    TS_INPUT_EVENT           eventList[1];
} TS_INPUT_PDU, FAR * PTS_INPUT_PDU;

// Sizes are for an InputPDU with 0 events attached.
#define TS_INPUTPDU_SIZE (sizeof(TS_INPUT_PDU) - sizeof(TS_INPUT_EVENT))
#define TS_INPUTPDU_UNCOMP_LEN  8


/****************************************************************************/
// Fast-path input codes. Fast-path input is designed to reduce the wire
// overhead of all the regular input PDU headers, by collapsing all the
// headers -- including X.224, MCS, encryption, share data, and input --
// into a bit-packed, optimized bytestream. Total win for a single keydown or
// keyup: before = 60 bytes, after = 12 bytes, an 80% decrease.
//
// Fast-path bytestream format:
//
// +--------+------+---------------+-----------+--------+
// | Header | Size | MAC signature | NumEvents | Events |
// +--------+------+---------------+-----------+--------+
//
// Header: Byte 0. This byte coincides with X.224 RFC1006 header byte 0,
//     which is always 0x03. In fastpath, we collapse three pieces of
//     information into this byte, 2 bits for security, 2 bits for
//     the action (to tell the difference between X.224 and other
//     actions), and 4 bits for a NumEvents field, which holds the
//     number of input events in the packet if in the range 1..15,
//     or 0 if we have a NumEvents field later on.
//
// Size: Overall packet length, first byte. The high bit determines
//     what the size of the size field is -- high bit 0 means the size
//     field is the low 7 bits, giving a range 0..127. High bit 1 means
//     the size field is the low 7 bits of this byte, plus the 8 bits of
//     the next byte, in big-endian order (the second byte contains the
//     low-order bits). This encoding scheme is based on ASN.1 PER
//     encoding used in MCS.
//
// Encryption signature: 8 bytes for encryption MAC signature of the
//     encrypted payload.
//
// NumEvents: If the header byte NumEvents is 0, there is a 1-byte field
//     here containing up to 256 for NumEvents.
//
// Bytestream input events: These correspond to the same event types already
//     defined for TS_INPUT_EVENT above, optimized for small size.
//     In each of the events following, there is at least one byte, where
//     the high 3 bits are the event type, and the bottom 5 bits are flags.
//     Additionally, each order type can use a defined number of extra bytes.
//     Descriptions of the event formats follow.
//
//     Keyboard: 2 bytes. Byte 0 contains the event type, plus special
//             extended and release flags. Byte 1 is the scan code.
//     Mouse: 7 bytes. Byte 0 contains only the event type. Bytes 1-6 contain
//             the same contents as a normal TS_POINTER_EVENT.
//     Sync: 1 byte. Byte 0 is the event type plus the regular sync flags.
/****************************************************************************/
    
// Masks for first-byte bits.
#define TS_INPUT_FASTPATH_ACTION_MASK     0x03
#define TS_INPUT_FASTPATH_NUMEVENTS_MASK  0x3C
#define TS_INPUT_FASTPATH_ENCRYPTION_MASK 0xC0

// Encryption settings
#define TS_INPUT_FASTPATH_ENCRYPTED       0x80
//
// Encrypted checksum packet
//
#define TS_INPUT_FASTPATH_SECURE_CHECKSUM 0x40

// 2 values here for future expansion.
#define TS_INPUT_FASTPATH_ACTION_FASTPATH 0x0
#define TS_INPUT_FASTPATH_ACTION_X224     0x3

// Event mask and type for each event in input.
// Event is encoded into high 3 bits of first byte.
// 4 values here for future expansion.
#define TS_INPUT_FASTPATH_EVENT_MASK     0xE0
#define TS_INPUT_FASTPATH_FLAGS_MASK     0x1F
#define TS_INPUT_FASTPATH_EVENT_KEYBOARD 0x00
#define TS_INPUT_FASTPATH_EVENT_MOUSE    0x20
#define TS_INPUT_FASTPATH_EVENT_MOUSEX   0x40
#define TS_INPUT_FASTPATH_EVENT_SYNC     0x60
#define TS_INPUT_FASTPATH_EVENT_VKPACKET 0x80

// Fastpath keyboard flags. These are set to be the same values as the server
// driver KEY_BREAK, KEY_E0, and KEY_E1 to simplify translation to kernel
// input event.
#define TS_INPUT_FASTPATH_KBD_RELEASE   0x01
#define TS_INPUT_FASTPATH_KBD_EXTENDED  0x02
#define TS_INPUT_FASTPATH_KBD_EXTENDED1 0x04


/****************************************************************************/
/* Structure: TS_CONFIRM_ACTIVE_PDU                                         */
/****************************************************************************/
typedef struct tagTS_CONFIRM_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              originatorID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT16              lengthCombinedCapabilities;

    // Source descriptor and Caps start here.
    TSUINT8               data[1];
} TS_CONFIRM_ACTIVE_PDU, FAR * PTS_CONFIRM_ACTIVE_PDU;


/****************************************************************************/
/* Size of Confirm Active without the data. 6 is the 3 UINT16's.            */
/****************************************************************************/
#define TS_CA_NON_DATA_SIZE (sizeof(TS_SHARECONTROLHEADER) + \
                            sizeof(TS_SHAREID) + 6)


/****************************************************************************/
/* Structure: TS_DEMAND_ACTIVE_PDU                                          */
/****************************************************************************/
typedef struct tagTS_DEMAND_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT16              lengthCombinedCapabilities;

    // Source descriptor and Caps start here.
    TSUINT8               data[1];
} TS_DEMAND_ACTIVE_PDU, FAR * PTS_DEMAND_ACTIVE_PDU;


/****************************************************************************/
/* Structure: TS_SERVER_CERTIFICATE_PDU                                     */
/*                                                                          */
/* Description: Used during shadowing to send the target server's cert +    */
/*              random to the client server.                                */
/****************************************************************************/
typedef struct tagTS_SERVER_CERTIFICATE_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TSUINT16              pad1;
    TSUINT32              encryptionMethod;
    TSUINT32              encryptionLevel;
    TSUINT32              shadowRandomLen;
    TSUINT32              shadowCertLen;

    // server random followed by server cert start here
    TSUINT8               data[1];
} TS_SERVER_CERTIFICATE_PDU, FAR * PTS_SERVER_CERTIFICATE_PDU;


/****************************************************************************/
/* Structure: TS_CLIENT_RANDOM_PDU                                          */
/*                                                                          */
/* Description: Used during shadowing to send the client's encrypted random */
/*              back to the shadow target server.                           */
/****************************************************************************/
typedef struct tagTS_CLIENT_RANDOM_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TSUINT16              pad1;
    TSUINT32              clientRandomLen;

    // client random starts here
    TSUINT8               data[1];
} TS_CLIENT_RANDOM_PDU, FAR * PTS_CLIENT_RANDOM_PDU;


/****************************************************************************/
/* Structure: TS_REQUEST_ACTIVE_PDU                                         */
/****************************************************************************/
typedef struct tagTS_REQUEST_ACTIVE_PDU
{
    TS_SHARECONTROLHEADER    shareControlHeader;
    TSUINT16                 lengthSourceDescriptor;
    TSUINT16                 lengthCombinedCapabilities;

    // Source descriptor and Caps start here.
    TSUINT8                  data[1];
} TS_REQUEST_ACTIVE_PDU, FAR * PTS_REQUEST_ACTIVE_PDU;


/****************************************************************************/
/* Structure: TS_DEACTIVATE_ALL_PDU                                         */
/****************************************************************************/
typedef struct tagTS_DEACTIVATE_ALL_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT8               sourceDescriptor[1];
} TS_DEACTIVATE_ALL_PDU, FAR * PTS_DEACTIVATE_ALL_PDU;


/****************************************************************************/
/* Structure: TS_DEACTIVATE_OTHER_PDU                                       */
/****************************************************************************/
typedef struct tagTS_DEACTIVATE_OTHER_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
    TSUINT16              deactivateID;
    TSUINT16              lengthSourceDescriptor;
    TSUINT8               sourceDescriptor[1];
} TS_DEACTIVATE_OTHER_PDU, FAR * PTS_DEACTIVATE_OTHER_PDU;


/****************************************************************************/
/* Structure: TS_DEACTIVATE_SELF_PDU                                        */
/****************************************************************************/
typedef struct tagTS_DEACTIVATE_SELF_PDU
{
    TS_SHARECONTROLHEADER shareControlHeader;
    TS_SHAREID            shareID;
} TS_DEACTIVATE_SELF_PDU, FAR * PTS_DEACTIVATE_SELF_PDU;


/****************************************************************************/
/* Structure: TS_SYNCHRONIZE_PDU                                            */
/****************************************************************************/
typedef struct tagTS_SYNCHRONIZE_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           messageType;
#define TS_SYNCMSGTYPE_SYNC  1

    TSUINT16           targetUser;
} TS_SYNCHRONIZE_PDU, FAR * PTS_SYNCHRONIZE_PDU;
#define TS_SYNC_PDU_SIZE sizeof(TS_SYNCHRONIZE_PDU)
#define TS_SYNC_UNCOMP_LEN 8


/****************************************************************************/
/* Structure: TS_CONTROL_PDU                                                */
/****************************************************************************/
typedef struct tagTS_CONTROL_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           action;
#define TS_CTRLACTION_FIRST            1
#define TS_CTRLACTION_REQUEST_CONTROL  1
#define TS_CTRLACTION_GRANTED_CONTROL  2
#define TS_CTRLACTION_DETACH           3
#define TS_CTRLACTION_COOPERATE        4
#define TS_CTRLACTION_LAST             4

    TSUINT16           grantId;
    TSUINT32           controlId;
} TS_CONTROL_PDU, FAR * PTS_CONTROL_PDU;
#define TS_CONTROL_PDU_SIZE sizeof(TS_CONTROL_PDU)
#define TS_CONTROL_UNCOMP_LEN 12


/****************************************************************************/
/* Structure: TS_FLOW_PDU                                                   */
/****************************************************************************/
typedef struct tagTS_FLOW_PDU
{
    TSUINT16 flowMarker;
#define TS_FLOW_MARKER        0x8000

    TSUINT16 pduType;              /* also includes protocol version     */
#define TS_PDUTYPE_FLOWTESTPDU                     65
#define TS_PDUTYPE_FLOWRESPONSEPDU                 66
#define TS_PDUTYPE_FLOWSTOPPDU                     67

    TSUINT8  flowIdentifier;
#define TS_MAX_FLOWIDENTIFIER 127

    TSUINT8  flowNumber;
    TSUINT16 pduSource;
} TS_FLOW_PDU, FAR * PTS_FLOW_PDU;
#define TS_FLOW_PDU_SIZE sizeof(TS_FLOW_PDU)


/****************************************************************************/
/* Structure: TS_FONT_PDU                                                   */
/****************************************************************************/
typedef struct tagTS_FONT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           numberFonts;
    TSUINT16           entrySize;
    TS_FONT_ATTRIBUTE  fontList[1];
} TS_FONT_PDU, FAR * PTS_FONT_PDU;


/****************************************************************************/
/* Structure: TS_FONT_LIST_PDU                                              */
/****************************************************************************/
typedef struct tagTS_FONT_LIST_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;

    TSUINT16           numberFonts;
    TSUINT16           totalNumFonts;

#define TS_FONTLIST_FIRST       0x0001
#define TS_FONTLIST_LAST        0x0002
    TSUINT16           listFlags;
    TSUINT16           entrySize;
    TS_FONT_ATTRIBUTE  fontList[1];
} TS_FONT_LIST_PDU, FAR * PTS_FONT_LIST_PDU;


/****************************************************************************/
/* Structure: TS_FONTTABLE_ENTRY                                            */
/****************************************************************************/
typedef struct tagTS_FONTTABLE_ENTRY
{
    TSUINT16 serverFontID;
    TSUINT16 clientFontID;
} TS_FONTTABLE_ENTRY, FAR * PTS_FONTTABLE_ENTRY;


/****************************************************************************/
/* Structure: TS_FONT_MAP_PDU                                               */
/*                                                                          */
/* Description: Font mapping table (sent from server to client)             */
/****************************************************************************/
typedef struct tagTS_FONT_MAP_PDU_DATA
{
    TSUINT16 numberEntries;
    TSUINT16 totalNumEntries;

#define TS_FONTMAP_FIRST        0x0001
#define TS_FONTMAP_LAST         0x0002
    TSUINT16 mapFlags;
    TSUINT16 entrySize;
    TS_FONTTABLE_ENTRY fontTable[1];
} TS_FONT_MAP_PDU_DATA, FAR * PTS_FONT_MAP_PDU_DATA;

typedef struct tagTS_FONT_MAP_PDU
{
    TS_SHAREDATAHEADER   shareDataHeader;
    TS_FONT_MAP_PDU_DATA data;
} TS_FONT_MAP_PDU, FAR * PTS_FONT_MAP_PDU;


/****************************************************************************/
// Fast-path output codes. Fast-path output is designed to reduce the wire
// overhead of all the server-to-client output "packages." These packages
// can contain one or more of the following PDU types, each of which is
// individually compressed (if compression is enabled):
//
//     Mouse pointers (TS_POINTER_PDU_DATA)
//     Output sync (No PDU body in fastpath version)
//     Orders (TS_UPDATE_ORDERS_PDU_DATA - fastpath version)
//     Screen data (TS_UPDATE_BITMAP_PDU_DATA)
//     Palettes (TS_UPDATE_PALETTE_PDU_DATA)
//
// The contents of the package can also be encrypted if high encryption
// is enabled.
//
// Fast-path output collapses a whole series of headers -- including X.224,
// MCS, encryption, and TS_SHAREDATAHEADERs included on each individual
// update PDU subpacket included in the package. It also defines a
// slightly different version of the original TS_UPDATE_XXX_PDU_DATA structs
// which optimize the TS_UPDATE_HDR space and combine the information
// into other headers in a bit-packed form.
//
// Fast-path bytestream format:
//
// +--------+------+---------------+-------------------------+
// | Header | Size | MAC signature | One or more update PDUs |
// +--------+------+---------------+-------------------------+
//
// Header: Byte 0. This byte coincides with X.224 RFC1006 header byte 0,
//     which is always 0x03. In fastpath, we collapse two pieces of
//     information into this byte, 2 bits for security, 2 bits for
//     the action (to tell the difference between X.224 and other
//     actions), and 4 bits currently unused but set to zero for possible
//     future use.
//
// Size: Overall packet length, first byte. The high bit determines
//     what the size of the size field is -- high bit 0 means the size
//     field is the low 7 bits, giving a range 0..127. High bit 1 means
//     the size field is the low 7 bits of this byte, plus the 8 bits of
//     the next byte, in big-endian order (the second byte contains the
//     low-order bits). This encoding scheme is based on ASN.1 PER
//     encoding used in MCS.
//
// Encryption signature: 8 bytes for encryption MAC signature of the
//     encrypted payload, if encryption enabled.
//
// Update PDU format:
//
// +--------+-------------------+------+-------------+
// | Header | Compression flags | Size | Update data |
// +--------+-------------------+------+-------------+
//
// Header: 1 byte. Contains two pieces of information, the update type
//     (TS_UPDATETYPE_XXX values) and a compression-used flag. If
//     compression-used is set, the next byte is a set of compression flags.
//
// Compression flags: Identical to the usage defined compress.h. Optional
//     byte -- if compression is not enabled on the session, it is not
//     included.
//
// Size: 2-byte size in little-endian (Intel) byte ordering. Fixed size
//     to allow update PDU header length to be determined before encoding
//     starting in the next byte after this field. Note that this is the
//     size of the data following this field -- if compression
//     is used the size is the compressed size.
//
// Update data: Formats as defined for individual PDUs. Some
//     formats match the non-fast-path formats for low-frequency packets,
//     others are special newer formats that collapse even more headers.
/****************************************************************************/

// Masks for first-byte bits.
#define TS_OUTPUT_FASTPATH_ACTION_MASK     0x03
#define TS_OUTPUT_FASTPATH_UNUSED_MASK     0x3C
#define TS_OUTPUT_FASTPATH_ENCRYPTION_MASK 0xC0

// Encryption flags
#define TS_OUTPUT_FASTPATH_ENCRYPTED       0x80
#define TS_OUTPUT_FASTPATH_SECURE_CHECKSUM 0x40

// 2 values here for future expansion.
#define TS_OUTPUT_FASTPATH_ACTION_FASTPATH 0x0
#define TS_OUTPUT_FASTPATH_ACTION_X224     0x3

// Masks and values for update PDU header byte.
// 11 values empty in update type field for future expansion of PDUs in
// packages. 1 extra bit available in compression flags for future
// expansion. 2 extra bits unused but available for future use.
#define TS_OUTPUT_FASTPATH_UPDATETYPE_MASK         0x0F
#define TS_OUTPUT_FASTPATH_UPDATE_COMPRESSION_MASK 0xC0
#define TS_OUTPUT_FASTPATH_COMPRESSION_USED        0x80


/****************************************************************************/
// TS_MONOPOINTERATTRIBUTE
/****************************************************************************/
typedef struct tagTS_MONOPOINTERATTRIBUTE
{
    TS_POINT16 hotSpot;
    TSUINT16   width;
    TSUINT16   height;
    TSUINT16   lengthPointerData;
    TSUINT8    monoPointerData[1];
} TS_MONOPOINTERATTRIBUTE, FAR * PTS_MONOPOINTERATTRIBUTE;


/****************************************************************************/
// TS_COLORPOINTERATTRIBUTE
//
// 24bpp color pointer.
/****************************************************************************/
typedef struct tagTS_COLORPOINTERATTRIBUTE
{
    TSUINT16   cacheIndex;
    TS_POINT16 hotSpot;
    TSUINT16   width;
    TSUINT16   height;
    TSUINT16   lengthANDMask;
    TSUINT16   lengthXORMask;
    TSUINT8    colorPointerData[1];
} TS_COLORPOINTERATTRIBUTE, FAR * PTS_COLORPOINTERATTRIBUTE;


/****************************************************************************/
// TS_POINTERATTRIBUTE
//
// Variable color depth pointer.
/****************************************************************************/
typedef struct tagTS_POINTERATTRIBUTE
{
    TSUINT16                 XORBpp;
    TS_COLORPOINTERATTRIBUTE colorPtrAttr;
} TS_POINTERATTRIBUTE, FAR * PTS_POINTERATTRIBUTE;


/****************************************************************************/
// TS_POINTER_PDU
//
// Container definition for various mouse pointer types.
// See also the fast-path output pointer definitions and types defined below.
/****************************************************************************/
typedef struct tagTS_POINTER_PDU_DATA
{
    TSUINT16 messageType;
#define TS_PTRMSGTYPE_SYSTEM      1
#define TS_PTRMSGTYPE_MONO        2
#define TS_PTRMSGTYPE_POSITION    3
#define TS_PTRMSGTYPE_COLOR       6
#define TS_PTRMSGTYPE_CACHED      7
#define TS_PTRMSGTYPE_POINTER     8

    TSUINT16 pad2octets;
    union
    {
        TSUINT32                 systemPointerType;
#define TS_SYSPTR_NULL    0
#define TS_SYSPTR_DEFAULT 0x7f00
        TS_MONOPOINTERATTRIBUTE  monoPointerAttribute;
        TS_COLORPOINTERATTRIBUTE colorPointerAttribute;
        TS_POINTERATTRIBUTE      pointerAttribute;
        TSUINT16                 cachedPointerIndex;
        TS_POINT16               pointerPosition;
    } pointerData;
} TS_POINTER_PDU_DATA, FAR * PTS_POINTER_PDU_DATA;

typedef struct tagTS_POINTER_PDU
{
    TS_SHAREDATAHEADER  shareDataHeader;
    TS_POINTER_PDU_DATA data;
} TS_POINTER_PDU, FAR * PTS_POINTER_PDU;

#define TS_POINTER_PDU_SIZE sizeof(TS_POINTER_PDU)


/****************************************************************************/
// Fast-path output for mouse pointers - overview.
//
// We use the fast-path header packet type to contain the mouse pointer
// update type explicitly. This allows us to collapse headers inside the
// TS_POINTER_PDU definition. Following are format descriptions for each
// pointer update type:
//
// TS_UPDATETYPE_MOUSEPTR_SYSTEM_NULL: Replaces systemPointerType ==
//     TS_SYSPTR_NULL. Payload is zero bytes.
//
// TS_UPDATETYPE_MOUSEPTR_SYSTEM_DEFAULT: Replaces systemPointerType ==
//     TS_SYSPTR_DEFAULT. Zero-byte payload.
//
// TS_UPDATETYPE_MOUSEPTR_MONO: Payload is TS_MONOPOINTERATTRIBUTE.
//
// TS_UPDATETYPE_MOUSEPTR_POSITION: Payload is a TS_POINT16.
//
// TS_UPDATETYPE_MOUSEPTR_COLOR: Payload is TS_COLORPOINTERATTRIBUTE.
//
// TS_UPDATETYPE_MOUSEPTR_CACHED: Payload is TSUINT16 cachedPointerIndex.
//
// TS_UPDATETYPE_MOUSEPTR_POINTER: Payload is TS_POINTERATTRIBUTE.
/****************************************************************************/


/****************************************************************************/
// Update types, used by TS_UPDATE_HDR and fast-path output.
/****************************************************************************/
#define TS_UPDATETYPE_ORDERS        0
#define TS_UPDATETYPE_BITMAP        1
#define TS_UPDATETYPE_PALETTE       2
#define TS_UPDATETYPE_SYNCHRONIZE   3

// Fast-path-only mouse pointer types, see fast-path output pointer
// description above.
#define TS_UPDATETYPE_MOUSEPTR_SYSTEM_NULL    5
#define TS_UPDATETYPE_MOUSEPTR_SYSTEM_DEFAULT 6
#define TS_UPDATETYPE_MOUSEPTR_MONO           7
#define TS_UPDATETYPE_MOUSEPTR_POSITION       8
#define TS_UPDATETYPE_MOUSEPTR_COLOR          9
#define TS_UPDATETYPE_MOUSEPTR_CACHED         10
#define TS_UPDATETYPE_MOUSEPTR_POINTER        11


/****************************************************************************/
/* Structure: TS_UPDATE_HDR                                                 */
/****************************************************************************/
typedef struct tagTS_UPDATE_HDR_DATA
{
    TSUINT16 updateType;
    TSUINT16 pad2octets;
} TS_UPDATE_HDR_DATA, FAR * PTS_UPDATE_HDR_DATA;

typedef struct tagTS_UPDATE_HDR
{
    TS_SHAREDATAHEADER shareDataHeader;
    TS_UPDATE_HDR_DATA data;
} TS_UPDATE_HDR, FAR * PTS_UPDATE_HDR;


/****************************************************************************/
/* Structure: TS_BITMAP_DATA                                                */
/*                                                                          */
/* Description: Data for a single rectangle in a BitmapUpdatePDU            */
/* Note: bitsPerPixel is included for backwards compatibility, although it  */
/* is the same for every rectangle sent.                                    */
/****************************************************************************/
typedef struct tagTS_BITMAP_DATA
{
    TSINT16  destLeft;
    TSINT16  destTop;
    TSINT16  destRight;
    TSINT16  destBottom;
    TSUINT16 width;
    TSUINT16 height;
    TSUINT16 bitsPerPixel;
    TSBOOL16 compressedFlag;

    // Bit 1:  TS_BITMAP_COMPRESSION Bitmap data is compressed or not
    // Bit 10: TS_EXTRA_NO_BITMAP_COMPRESSION_HDR indicates if the compressed
    //     bitmap data contains the redundant BC header or not. Note this
    //     value is defined in REV2 bitmap extraflags value for consistency.
#define TS_BITMAP_COMPRESSION 0x0001

    TSUINT16 bitmapLength;
    TSUINT8  bitmapData[1];            /* variable length field  */
} TS_BITMAP_DATA, FAR * PTS_BITMAP_DATA;


/****************************************************************************/
/* Structure: TS_UPDATE_BITMAP_PDU                                          */
/****************************************************************************/
typedef struct tagTS_UPDATE_BITMAP_PDU_DATA
{
    TSUINT16       updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16       numberRectangles;
    TS_BITMAP_DATA rectangle[1];
} TS_UPDATE_BITMAP_PDU_DATA, FAR * PTS_UPDATE_BITMAP_PDU_DATA;

typedef struct tagTS_UPDATE_BITMAP_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TS_UPDATE_BITMAP_PDU_DATA data;
} TS_UPDATE_BITMAP_PDU, FAR * PTS_UPDATE_BITMAP_PDU;

/****************************************************************************/
/* Structure: TS_UPDATE_CAPABILITYSET                                       */
/****************************************************************************/
typedef struct tagTS_UPDATE_CAPABILITYSET
{
    TS_BITMAP_CAPABILITYSET bitmapCapabilitySet;
} TS_UPDATE_CAPABILITYSET, FAR * PTS_UPDATE_CAPABILITYSET;


/****************************************************************************/
/* Structure: TS_UPDATE_CAPABILITY_PDU                                      */
/****************************************************************************/
typedef struct tagTS_UPDATE_CAPABILITY_PDU
{
    TS_SHAREDATAHEADER      shareDataHeader;
    TS_UPDATE_CAPABILITYSET updateCapabilitySet;
} TS_UPDATE_CAPABILITY_PDU, FAR * PTS_UPDATE_CAPABILITY_PDU;


/****************************************************************************/
// TS_UPDATE_ORDERS_PDU
//
// Variable size UpdateOrdersPDU.
// See also the fastpath version described below.
/****************************************************************************/
typedef struct tagTS_UPDATE_ORDERS_PDU_DATA
{
    TSUINT16 updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16 pad2octetsA;
    TSUINT16 numberOrders;
    TSUINT16 pad2octetsB;
    TSUINT8  orderList[1];
} TS_UPDATE_ORDERS_PDU_DATA, FAR * PTS_UPDATE_ORDERS_PDU_DATA;

typedef struct tagTS_UPDATE_ORDERS_PDU
{
    TS_SHAREDATAHEADER  shareDataHeader;
    TS_UPDATE_ORDERS_PDU_DATA data;
} TS_UPDATE_ORDERS_PDU, FAR * PTS_UPDATE_ORDERS_PDU;


/****************************************************************************/
// TS_UPDATE_ORDERS_PDU_DATA - fast-path bytestream version
//
// Rather than waste 6 of the 8 header bytes in the TS_UPDATE_ORDERS_PDU_DATA
// (updateType is already known in the fastpath header), we simply define
// a new optimized version: numberOrders is a 2-byte little-endian (Intel)
// format field preceding the bytestream of encoded orders.
/****************************************************************************/


/****************************************************************************/
/* Structure: TS_COLOR                                                      */
/****************************************************************************/
typedef struct tagTS_COLOR
{
    TSUINT8 red;
    TSUINT8 green;
    TSUINT8 blue;
} TS_COLOR, FAR * PTS_COLOR;


/****************************************************************************/
/* Structure: TS_COLOR_QUAD                                                 */
/****************************************************************************/
typedef struct tagTS_COLOR_QUAD
{
    TSUINT8 red;
    TSUINT8 green;
    TSUINT8 blue;
    TSUINT8 pad1octet;
} TS_COLOR_QUAD, FAR * PTS_COLOR_QUAD;


/****************************************************************************/
// TS_ORDER_HEADER
//
// There are several types of orders available using this control flag byte.
// They include:
//
// Primary orders: Denoted by the lower two control bits 01 meaning
// TS_STANDARD but not TS_SECONDARY. Primary orders are field encoded
// using the OE2 encoding logic on the server and the OD logic on the
// client. See oe2.h in the server code for field encoding rules.
// The upper six bits of the control byte are used for further information
// about the field encoding.
//
// Secondary orders: Denoted by low 2 control bits 11 meaning TS_STANDARD |
// TS_SECONDARY. The upper 6 bits are not used. Followed by the next 5
// bytes of the TS_SECONDARY_ORDER_HEADER definition, then followed by
// order-specific data.
//
// Alternate secondary orders: Introduced in RDP 5.1, these orders are
// denoted by low 2 control bits 10, meaning TS_SECONDARY but not
// TS_STANDARD. The upper 6 bits are used to encode the order type; the
// order format following the control byte is order-specific but not field
// encoded. This order type was introduced to overcome the wastefulness
// inherent in the secondary order header, allowing nonstandard secondary
// orders to follow whatever form best suits the data being carried.
//
// Control flag low 2 bit value 00 is not used in RDP 4.0, 5.0, or 5.1,
// but is reserved for future use.
/****************************************************************************/

#define TS_STANDARD                   1
#define TS_SECONDARY                  2
#define TS_BOUNDS                     4
#define TS_TYPE_CHANGE                8
#define TS_DELTA_COORDINATES         16

// Indicates that there are zero modified bounds coordinates.
// Used in conjunction with the TS_BOUNDS flags, the presence of this flag
// means that there is no subsequent byte for the bounds fields (it would be
// zero).
#define TS_ZERO_BOUNDS_DELTAS        32

// T.128 extension: two bits that contain the number of consecutive
// field encoding bytes that are zero.  When these bits indicate that
// there are zero-value field bytes, the corresponding bytes are not
// sent.  The count is for consecutive zeros from the last byte
// scanning backwards (the non-zero bytes normally appear at the
// beginning).
//
// Example: order that has three field encoding bytes
//
// field encoding bytes: 0x20 0x00 0x00
//
// There are two zeros (counting from the end backwards), so the
// control flags contain 0x80 (0x02 << 6), and the order is sent with
// just 0x20.  We therefore save sending the two bytes.
#define TS_ZERO_FIELD_BYTE_BIT0      64
#define TS_ZERO_FIELD_BYTE_BIT1     128
#define TS_ZERO_FIELD_COUNT_SHIFT     6
#define TS_ZERO_FIELD_COUNT_MASK   0xC0

// Alternate secondary order mask and shift values for the order type.
#define TS_ALTSEC_ORDER_TYPE_MASK 0xFC
#define TS_ALTSEC_ORDER_TYPE_SHIFT 2

typedef struct tagTS_ORDER_HEADER
{
    TSUINT8 controlFlags;
} TS_ORDER_HEADER, FAR *PTS_ORDER_HEADER;


/****************************************************************************/
// TS_SECONDARY_ORDER_HEADER
/****************************************************************************/

#define TS_CACHE_BITMAP_UNCOMPRESSED      0
#define TS_CACHE_COLOR_TABLE              1
#define TS_CACHE_BITMAP_COMPRESSED        2
#define TS_CACHE_GLYPH                    3
#define TS_CACHE_BITMAP_UNCOMPRESSED_REV2 4
#define TS_CACHE_BITMAP_COMPRESSED_REV2   5
#define TS_STREAM_BITMAP                  6
#define TS_CACHE_BRUSH                    7

#define TS_NUM_SECONDARY_ORDERS           8

typedef struct tagTS_SECONDARY_ORDER_HEADER
{
    TS_ORDER_HEADER orderHdr;
    TSUINT16        orderLength;

    // This field was used in RDP 4.0 to hold TS_EXTRA_SECONDARY, but was
    // re-tasked to allow secondary orders to use these two bytes as encoding
    // bytes and flags.
    TSUINT16        extraFlags;

    TSUINT8         orderType;
} TS_SECONDARY_ORDER_HEADER, FAR *PTS_SECONDARY_ORDER_HEADER;


/****************************************************************************/
/* The calculation of the value to store in the orderLength field of        */
/* TS_SECONDARY_ORDER_HEADER is non-trivial.  Hence we provide some macros  */
/* to make life easier.                                                     */
/****************************************************************************/
#define TS_SECONDARY_ORDER_LENGTH_FUDGE_FACTOR  8

#define TS_SECONDARY_ORDER_LENGTH_ADJUSTMENT                                \
                    (sizeof(TS_SECONDARY_ORDER_HEADER)  -                   \
                     FIELDSIZE(TS_SECONDARY_ORDER_HEADER, orderType) +      \
                     TS_SECONDARY_ORDER_LENGTH_FUDGE_FACTOR)

#define TS_CALCULATE_SECONDARY_ORDER_ORDERLENGTH(actualOrderLength)         \
           ((actualOrderLength) - TS_SECONDARY_ORDER_LENGTH_ADJUSTMENT)

#define TS_DECODE_SECONDARY_ORDER_ORDERLENGTH(secondaryOrderLength)         \
           ((secondaryOrderLength) + TS_SECONDARY_ORDER_LENGTH_ADJUSTMENT)


/****************************************************************************/
// Alternate secondary order type values.
/****************************************************************************/
#define TS_ALTSEC_SWITCH_SURFACE           0
#define TS_ALTSEC_CREATE_OFFSCR_BITMAP     1

#ifdef DRAW_NINEGRID
#define TS_ALTSEC_STREAM_BITMAP_FIRST      2
#define TS_ALTSEC_STREAM_BITMAP_NEXT       3
#define TS_ALTSEC_CREATE_NINEGRID_BITMAP   4
#endif

#ifdef DRAW_GDIPLUS
#define TS_ALTSEC_GDIP_FIRST              5
#define TS_ALTSEC_GDIP_NEXT               6
#define TS_ALTSEC_GDIP_END                7

#define TS_ALTSEC_GDIP_CACHE_FIRST              8
#define TS_ALTSEC_GDIP_CACHE_NEXT               9
#define TS_ALTSEC_GDIP_CACHE_END                10
#endif // DRAW_GDIPLUS

#ifdef DRAW_GDIPLUS
#define TS_NUM_ALTSEC_ORDERS               11
#else // DRAW_GDIPLUS
#ifdef DRAW_NINEGRID
#define TS_NUM_ALTSEC_ORDERS               5
#else
#define TS_NUM_ALTSEC_ORDERS               2
#endif // DRAW_NINEGRID
#endif // DRAW_GDIPLUS


/****************************************************************************/
/* Convert BPP to number of colors.                                         */
/****************************************************************************/
#ifdef DC_HICOLOR
/****************************************************************************/
/* This macro as it was doesn't cater for 15bpp.  Consider a 64 pel wide    */
/* bitmap at 15 and 16bpp.  It really has the same numner of bytes per scan */
/* line but this macro gives 128 for 16bpp and only 120 for 15bpp...        */
/****************************************************************************/
// WRONG: #define TS_BYTES_IN_SCANLINE(width, bpp) (((((width)*(bpp))+31)/32) * 4)
#define TS_BYTES_IN_SCANLINE(width, bpp) ((((width)*((((bpp)+3)/4)*4)+31)/32) * 4)
#else
#define TS_BYTES_IN_SCANLINE(width, bpp) (((((width)*(bpp))+31)/32) * 4)
#endif
#define TS_BYTES_IN_BITMAP(width, height, bpp) \
                             (TS_BYTES_IN_SCANLINE((width), (bpp)) * (height))


/****************************************************************************/
/* The Compressed Data header structure.                                    */
/*                                                                          */
/* Rather than add a field to indicate V1 vs V2 compression we use the      */
/* fact that V2 compression treats all the bitmap as main body and sets     */
/* the first row size to zero to distinguish them.  I hesitate to do this   */
/* but any bandwidth saving is important.                                   */
/****************************************************************************/
typedef struct tagTS_CD_HEADER
{
    TSUINT16 cbCompFirstRowSize;
    TSUINT16 cbCompMainBodySize;
    TSUINT16 cbScanWidth;
    TSUINT16 cbUncompressedSize;
} TS_CD_HEADER, FAR *PTS_CD_HEADER;
typedef TS_CD_HEADER UNALIGNED FAR *PTS_CD_HEADER_UA;


/****************************************************************************/
// Structure: TS_CACHE_BITMAP_ORDER
//
// Description: First cache-bitmap order revision used in RDP 4.0.
/****************************************************************************/
typedef struct tagTS_CACHE_BITMAP_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;

    // header.extraflags
    // Bit 10: TS_EXTRA_NO_BITMAP_COMPRESSION_HDR indicates if the compressed
    // bitmap data contains the redundant BC header or not. Note this value
    // is defined in REV2 bitmap extraflags value for consistency

    TSUINT8  cacheId;
    TSUINT8  pad1octet;
    TSUINT8  bitmapWidth;
    TSUINT8  bitmapHeight;
    TSUINT8  bitmapBitsPerPel;
    TSUINT16 bitmapLength;
    TSUINT16 cacheIndex;
    TSUINT8  bitmapData[1];
} TS_CACHE_BITMAP_ORDER, FAR *PTS_CACHE_BITMAP_ORDER;


/****************************************************************************/
// TS_CACHE_BITMAP_ORDER_REV2_HEADER
//
// Second version of cache-bitmap order that includes the hash key and
// changes the field definitions to minimize wire bytes.
/****************************************************************************/
// Maximum worst-case order size, rounded up to the nearest DWORD boundary.
#define TS_CACHE_BITMAP_ORDER_REV2_MAX_SIZE \
        (((sizeof(TS_CACHE_BITMAP_ORDER_REV2_HEADER) + 18) + 3) & ~0x03)
typedef struct
{
    // Two bytes in header.extraFlags are encoded as follows:
    //   Bits 0..2 (mask 0x0007): CacheID.
    //   Bits 3..6 (mask 0x0078): BitsPerPixelID, see below for values.
    //   Bit 7 (mask 0x0080): bHeightSameAsWidth, set to 1 when the bitmap
    //       height is the same as the encoded width.
    //   Bit 8 (mask 0x0100): bKeyPresent, set to 1 when the persistent key
    //       is encoded in the stream.
    //   Bit 9 (mask 0x0200): bStreamBitmap, set to 1 if this cache-bitmap
    //       order is a bitmap-streaming header.
    //   Bit 10 (mask 0x0400): noBitmapCompressionHdr, set to 1 if the
    //       compressed bitmap doesn't contain redundent header (8 bytes)
    //       This mask is used by REV1 bitmap header, SDA bitmap data
    //       and TS_GENERAL_CAPS as well
    //   Bit 11 (mask 0x0800): not cache flag, set to 1 if the bitmap
    //       is not to be cached in the bitmap cache

    TS_SECONDARY_ORDER_HEADER header;
#define TS_CacheBitmapRev2_CacheID_Mask            0x0007
#define TS_CacheBitmapRev2_BitsPerPixelID_Mask     0x0078
#define TS_CacheBitmapRev2_bHeightSameAsWidth_Mask 0x0080
#define TS_CacheBitmapRev2_bKeyPresent_Mask        0x0100
#define TS_CacheBitmapRev2_bStreamBitmap_Mask      0x0200
#define TS_EXTRA_NO_BITMAP_COMPRESSION_HDR         0x0400
#define TS_CacheBitmapRev2_bNotCacheFlag           0x0800

// These are defined to be in the same position they would be in the
// extraFlags field.
#define TS_CacheBitmapRev2_1BitPerPel   (0 << 3)
#define TS_CacheBitmapRev2_2BitsPerPel  (1 << 3)
#define TS_CacheBitmapRev2_4BitsPerPel  (2 << 3)
#define TS_CacheBitmapRev2_8BitsPerPel  (3 << 3)
#define TS_CacheBitmapRev2_16BitsPerPel (4 << 3)
#define TS_CacheBitmapRev2_24BitsPerPel (5 << 3)
#define TS_CacheBitmapRev2_32BitsPerPel (6 << 3)

    // 64-bit key. These are absent from the wire encoding if the cache
    // properties in the bitmap cache capabilities indicate the cache
    // is not persistent and bKeyPresent is false above.
    TSUINT32 Key1;
    TSUINT32 Key2;

    // Following fields are variable-sized and so only have a description.
    // Encoding rules:
    //   2-byte encoding: Uses high bit of first byte as a field length
    //       indicator, where 0 means the field is one byte (the 7 low
    //       bits of the first byte), 1 means it is 2 bytes (low 7 bits
    //       of the first byte are the high bits, 8 bits of next byte
    //       are the low bits, total 15 bits available).
    //   4-byte encoding: Uses high 2 bits of first byte as a field length
    //       indicator: 00 means a one-byte field (low 6 bits of that byte
    //       are the value), 01=2-byte field (low 6 bits + next byte, with
    //       1st 6 bits being most significant, 14 bits total for value),
    //       10=3-byte field (22 bits total for value), 11=4-byte field (30
    //       bits for value).

    // Bitmap width: 2-byte encoding.
    // Bitmap height: If same as width, the bHeightSameAsWidth bit is
    //     set above, otherwise appears here as a 2-byte encoding.
    // Bitmap length: 4-byte encoding.
    // Streaming extended info: This field is present only if the bStreamBitmap
    //     flag was set in the header field. This field is a 2-byte encoding
    //     specifying the length of the portion of the bitmap in this PDU.
    //     The rest of the bitmap data will be sent later with a series of
    //     TS_STREAM_BITMAP secondary orders.
    // Cache index: 2-byte encoding.
} TS_CACHE_BITMAP_ORDER_REV2_HEADER, FAR *PTS_CACHE_BITMAP_ORDER_REV2_HEADER;


/****************************************************************************/
// TS_STREAM_BITMAP_ORDER_HEADER
//
// Follow-up PDU to TS_CACHE_BITMAP_ORDER_REV2 that provides further blocks
// of data for the streamed bitmap. Note there are no first/last streaming
// bits provided, the block sizes sent are sufficient information to
// determine when the bitmap stream is complete.
/****************************************************************************/
// Maximum worst-case order size, rounded up to the nearest DWORD boundary.
#define TS_STREAM_BITMAP_ORDER_MAX_SIZE \
        (((sizeof(TS_STREAM_BITMAP_ORDER_HEADER) + 2) + 3) & ~0x03)
typedef struct
{
    TS_SECONDARY_ORDER_HEADER header;

    // Following fields are variable-sized according to encoding descriptions
    // given for TS_CACHE_BITMAP_ORDER_HEADER_REV2.

    // Data length: 2-byte encoding.
} TS_STREAM_BITMAP_ORDER_HEADER, FAR *PTS_STREAM_BITMAP_ORDER_HEADER;


/****************************************************************************/
/* Structure: TS_CACHE_COLOR_TABLE_ORDER                                    */
/****************************************************************************/
typedef struct tagTS_CACHE_COLOR_TABLE_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;
    TSUINT8                   cacheIndex;
    TSUINT16                  numberColors;
    TS_COLOR_QUAD             colorTable[1];
} TS_CACHE_COLOR_TABLE_ORDER, FAR * PTS_CACHE_COLOR_TABLE_ORDER;


/****************************************************************************/
/* Structure: TS_CACHE_GLYPH_DATA                                           */
/****************************************************************************/
typedef struct tagTS_CACHE_GLYPH_DATA
{
    TSUINT16 cacheIndex;
    TSINT16  x;
    TSINT16  y;
    TSUINT16 cx;
    TSUINT16 cy;
    TSUINT8  aj[1];
} TS_CACHE_GLYPH_DATA, FAR * PTS_CACHE_GLYPH_DATA;


/****************************************************************************/
/* Structure: TS_CACHE_GLYPH_ORDER                                          */
/****************************************************************************/
#define TS_EXTRA_GLYPH_UNICODE       16
typedef struct tagTS_CACHE_GLYPH_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;
    TSUINT8                   cacheId;
    TSUINT8                   cGlyphs;
    TS_CACHE_GLYPH_DATA       glyphData[1];
} TS_CACHE_GLYPH_ORDER, FAR * PTS_CACHE_GLYPH_ORDER;


/****************************************************************************/
/* Structure: TS_CACHE_GLYPH_ORDER_REV2                                     */
/****************************************************************************/
#define TS_GLYPH_DATA_REV2_HDR_MAX_SIZE    9

typedef struct tagTS_CACHE_GLYPH_ORDER_REV2
{
    // Two bytes in header.extraFlags are encoded as follows:
    //   Bits 0..3 (mask 0x000f): CacheID.
    //   Bit  4 (mask 0x0010): glyph unicode
    //   Bit  5 (mask 0x0020): Glyph REV2 order
    //   Bits 6..7: free
    //   Bits 8..15 (mask 0xff00): cGlyphs
    TS_SECONDARY_ORDER_HEADER header;

#define TS_CacheGlyphRev2_CacheID_Mask            0x000f
#define TS_CacheGlyphRev2_Mask                    0x0020
#define TS_CacheGlyphRev2_cGlyphs_Mask            0xff00

    // array of glyph data
    BYTE glyphData[1];

    // Following fields are variable-sized and so only have a description.
    // Encoding rules:
    //   2-byte encoding: Uses high bit of first byte as a field length
    //       indicator, where 0 means the field is one byte (the 7 low
    //       bits of the first byte), 1 means it is 2 bytes (low 7 bits
    //       of the first byte are the high bits, 8 bits of next byte
    //       are the low bits, total 15 bits available).
    //
    //   2-byte signed encoding: Uses high bit of first byte as a field length
    //       indicator, where 0 means the field is one byte (the 6 low
    //       bits of the first byte), 1 means it is 2 bytes (low 6 bits
    //       of the first byte are the high bits, 8 bits of next byte
    //       are the low bits, total 14 bits available).
    //       The second high bit used as a sign indicator.  0 means the
    //       field is unsigned, 1 means the field is signed
    //
    // cacheIndex: 1-byte field
    // Glyph x: 2-byte signed encoding
    // Glyph y: 2-byte signed encoding
    // Glyph cx: 2-byte unsigned encoding
    // Glyph cy: 2-byte unsigned encoding
    // Glyph bitmap data: in bytes

} TS_CACHE_GLYPH_ORDER_REV2, FAR * PTS_CACHE_GLYPH_ORDER_REV2;


/****************************************************************************/
/* Structure: TS_CACHE_BRUSH_ORDER                                          */
/****************************************************************************/
#define TS_CACHED_BRUSH 0x80
#define MAX_BRUSH_ENCODE_COLORS 4
typedef struct tagTS_CACHE_BRUSH_ORDER
{
    TS_SECONDARY_ORDER_HEADER header;
    TSUINT8                   cacheEntry;
    TSUINT8                   iBitmapFormat;
    TSUINT8                   cx;
    TSUINT8                   cy;
    TSUINT8                   style;
    TSUINT8                   iBytes;
    TSUINT8                   brushData[1];
#ifdef DC_HICOLOR
    // The layout of the brush data is dependent on the format of the
    // bitmap, and if it has been compressed in any way.  In particular,
    // many brushes actually only use two different colors, and the
    // majority use four or less.
    //
    // Two-color brushes are treated as mono bitmaps, so the brushData
    // array contains the bits encoded in 8 bytes.
    //
    // Four color brushes are represented as 2-bit indices into a color
    // table.  The brushData array thus contains
    //
    // - 16 bytes of bitmap data (8x8 pels x 2bpp)
    // - either
    //   - 4 1-byte indices into the current color table (for 8bpp
    //     sessions)
    //   - 4 4-byte color values, either color indices for 15/16bpp or full
    //     RGB values for 24bpp sessions
    //
    // The bits of brushes using more than 4 colors are simply copied into
    // the brushData at the appropriate color depth.
#endif

} TS_CACHE_BRUSH_ORDER, FAR * PTS_CACHE_BRUSH_ORDER;


/****************************************************************************/
// TS_CREATE_OFFSCR_BITMAP_ORDER
//
// This alternate secondary order creates an offscreen bitmap of size
// cx by cy. The bitmap ID is stored at the ExtraFlags field in the header
/****************************************************************************/
typedef struct tagTS_CREATE_OFFSCR_BITMAP_ORDER
{
    BYTE ControlFlags;

    // Bit 0..14: Offscreen bitmap ID
    // Bit 15: Flag to indicate if offscreen bitmap delete list is appended.
    TSUINT16 Flags;

    TSUINT16 cx;
    TSUINT16 cy;

    // Number offscreen bitmaps to delete: 2 bytes
    // Offscreen bitmap ID delete list: 2-bytes list
    TSUINT16 variableBytes[1];
} TS_CREATE_OFFSCR_BITMAP_ORDER, FAR * PTS_CREATE_OFFSCR_BITMAP_ORDER;


/****************************************************************************/
// TS_SWITCH_SURFACE_ORDER_HEADER
//
// This alternate secondary order switches the target drawing surface at the
// client, identified by the bitmap ID. The primary drawing surface (screen)
// has the bitmap ID of 0xFFFF.
/****************************************************************************/
#define SCREEN_BITMAP_SURFACE  0xFFFF

typedef struct tagTS_SWITCH_SURFACE_ORDER
{
    BYTE ControlFlags;
    TSUINT16 BitmapID;
} TS_SWITCH_SURFACE_ORDER, FAR * PTS_SWITCH_SURFACE_ORDER;



#ifdef DRAW_GDIPLUS
/****************************************************************************/
// Structure: TS_DRAW_GDIPLUS_ORDER
//
// Description: DrawGdiplus order
/****************************************************************************/
typedef struct tagTS_DRAW_GDIPLUS_ORDER_FRIST
{
    BYTE ControlFlags;
    BYTE Flags;   // curently not used
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
    TSUINT32 cbTotalEmfSize;
} TS_DRAW_GDIPLUS_ORDER_FIRST, FAR * PTS_DRAW_GDIPLUS_ORDER_FIRST;

typedef struct tagTS_DRAW_GDIPLUS_ORDER_NEXT
{
    BYTE ControlFlags;
    BYTE Flags;   // curently not used
    TSUINT16 cbSize;
} TS_DRAW_GDIPLUS_ORDER_NEXT, FAR * PTS_DRAW_GDIPLUS_ORDER_NEXT;

typedef struct tagTS_DRAW_GDIPLUS_ORDER_END
{
    BYTE ControlFlags;
    BYTE Flags;   // curently not used
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
    TSUINT32 cbTotalEmfSize;
} TS_DRAW_GDIPLUS_ORDER_END, FAR * PTS_DRAW_GDIPLUS_ORDER_END;

#define TS_GDIPLUS_ORDER_SIZELIMIT 4096

/****************************************************************************/
// Structure: TS_CACHE_DRAW_GDIPLUS_CACHE_ORDER
//
// Description: DrawGdiplus cache order
/****************************************************************************/
typedef struct tagTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST
{
    BYTE ControlFlags;
    BYTE Flags;
    #define TS_GDIPLUS_CACHE_ORDER_REMOVE_CACHEENTRY 0x1
    TSUINT16 CacheType;  // See following define for CacheType
    TSUINT16 CacheID;
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
} TS_DRAW_GDIPLUS_CACHE_ORDER_FIRST, FAR * PTS_DRAW_GDIPLUS_CACHE_ORDER_FIRST;

typedef struct tagTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT
{
    BYTE ControlFlags;
    BYTE Flags;
    TSUINT16 CacheType;  // See following define for CacheType
    TSUINT16 CacheID;
    TSUINT16 cbSize;
} TS_DRAW_GDIPLUS_CACHE_ORDER_NEXT, FAR * PTS_DRAW_GDIPLUS_CACHE_ORDER_NEXT;

typedef struct tagTS_DRAW_GDIPLUS_CACHE_ORDER_END
{
    BYTE ControlFlags;
    BYTE Flags;
    TSUINT16 CacheType;  // See following define for CacheType
    TSUINT16 CacheID;
    TSUINT16 cbSize;
    TSUINT32 cbTotalSize;
} TS_DRAW_GDIPLUS_CACHE_ORDER_END, FAR * PTS_DRAW_GDIPLUS_CACHE_ORDER_END;
                                                           
#define GDIP_CACHE_GRAPHICS_DATA 0x1
#define GDIP_CACHE_OBJECT_BRUSH 0x2
#define GDIP_CACHE_OBJECT_PEN 0x3
#define GDIP_CACHE_OBJECT_IMAGE 0x4
#define GDIP_CACHE_OBJECT_IMAGEATTRIBUTES 0x5

typedef struct tagTSEmfPlusRecord
{
    TSINT16 Type;        
    TSUINT16 Flags;     // Higher 8 bits is Gdi+ object type 
    TSUINT32 Size;      // If MSB is set, the following data will be cacheID
} TSEmfPlusRecord, FAR * PTSEmfPlusRecord;
#endif // DRAW_GDIPLUS


#ifdef DRAW_NINEGRID
/****************************************************************************/
// Structure: TS_CREATE_DRAW_NINEGRID_ORDER
//
// Description: Luna DrawNineGrid bitmap order
/****************************************************************************/
typedef struct tagTS_NINEGRID_BITMAP_INFO
{
    ULONG      flFlags;
    TSUINT16   ulLeftWidth;
    TSUINT16   ulRightWidth;
    TSUINT16   ulTopHeight;
    TSUINT16   ulBottomHeight;
    TSCOLORREF crTransparent;
} TS_NINEGRID_BITMAP_INFO, FAR * PTS_NINEGRID_BITMAP_INFO;

typedef struct tagTS_CREATE_NINEGRID_BITMAP_ORDER
{
    BYTE ControlFlags;
    BYTE BitmapBpp;
    TSUINT16 BitmapID;
    TSUINT16 cx;
    TSUINT16 cy;
    TS_NINEGRID_BITMAP_INFO nineGridInfo;
} TS_CREATE_NINEGRID_BITMAP_ORDER, FAR * PTS_CREATE_NINEGRID_BITMAP_ORDER;

/****************************************************************************/
// Streaming bitmap orders
/****************************************************************************/
#define TS_STREAM_BITMAP_BLOCK      4 * 1024    // stream bitmap block is 4k chunk
#define TS_STREAM_BITMAP_END        0x1
#define TS_STREAM_BITMAP_COMPRESSED 0x2
#define TS_STREAM_BITMAP_REV2 0x4

typedef struct tagTS_STREAM_BITMAP_FIRST_PDU
{
    BYTE ControlFlags;
    BYTE BitmapFlags;
    BYTE BitmapBpp;
    TSUINT16 BitmapId;
#define TS_DRAW_NINEGRID_BITMAP_CACHE 0x1
    
    TSUINT16 BitmapWidth;
    TSUINT16 BitmapHeight;
    TSUINT16 BitmapLength;

    TSUINT16 BitmapBlockLength;
} TS_STREAM_BITMAP_FIRST_PDU, FAR * PTS_STREAM_BITMAP_FIRST_PDU;

typedef struct tagTS_STREAM_BITMAP_NEXT_PDU
{
    BYTE ControlFlags;
    BYTE BitmapFlags;
    TSUINT16 BitmapId;
    TSUINT16 BitmapBlockLength;
} TS_STREAM_BITMAP_NEXT_PDU, FAR * PTS_STREAM_BITMAP_NEXT_PDU;

// For DRAW_STREM_REV2, the only change is the BitmapLength in tagTS_STREAM_BITMAP_FIRST_PDU
//  from TSUINT16 to TSUINT32
typedef struct tagTS_STREAM_BITMAP_FIRST_PDU_REV2
{
    BYTE ControlFlags;
    BYTE BitmapFlags;
    BYTE BitmapBpp;
    TSUINT16 BitmapId;
#define TS_DRAW_NINEGRID_BITMAP_CACHE 0x1
    
    TSUINT16 BitmapWidth;
    TSUINT16 BitmapHeight;
    TSUINT32 BitmapLength;

    TSUINT16 BitmapBlockLength;
} TS_STREAM_BITMAP_FIRST_PDU_REV2, FAR * PTS_STREAM_BITMAP_FIRST_PDU_REV2;


#if 0
/****************************************************************************/
// Structure: TS_CREATE_DRAW_STREAM_ORDER
//
// Description: Luna DrawStream order
/****************************************************************************/
typedef struct tagTS_CREATE_DRAW_STREAM_ORDER
{
    BYTE ControlFlags;
    TSUINT16 BitmapID;
    TSUINT16 cx;
    TSUINT16 cy;
    TSUINT8  bitmapBpp;
} TS_CREATE_DRAW_STREAM_ORDER, FAR * PTS_CREATE_DRAW_STREAM_ORDER;

/****************************************************************************/
// Structure: TS_DRAW_STREAM_ORDER
//
// Description: Luna DrawStream order
/****************************************************************************/
typedef struct tagTS_DRAW_STREAM_ORDER
{
    BYTE ControlFlags;
    TS_RECTANGLE16 Bounds; 
    TSUINT16 BitmapID;
    TSUINT8  nClipRects;
    TSUINT16 StreamLen;       
} TS_DRAW_STREAM_ORDER, FAR * PTS_DRAW_STREAM_ORDER;

typedef struct tagTS_DRAW_NINEGRID_ORDER
{
    BYTE ControlFlags;
    TSUINT16 BitmapID;
    TS_RECTANGLE16 dstBounds; 
    TS_RECTANGLE16 srcBounds;
    TSUINT8 nClipRects;    
} TS_DRAW_NINEGRID_ORDER, FAR * PTS_DRAW_NINEGRID_ORDER;

typedef struct _RDP_DS_COPYTILE
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_POINT16 ptlOrigin;
} RDP_DS_COPYTILE;

typedef struct _RDP_DS_SOLIDFILL
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TSCOLORREF crSolidColor;
} RDP_DS_SOLIDFILL;

typedef struct _RDP_DS_TRANSPARENTTILE
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_POINT16 ptlOrigin;
    TSCOLORREF crTransparentColor;
} RDP_DS_TRANSPARENTTILE;

typedef struct _RDP_DS_ALPHATILE
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_POINT16 ptlOrigin;
    TS_BLENDFUNC blendFunction;
} RDP_DS_ALPHATILE;

typedef struct _RDP_DS_STRETCH
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
} RDP_DS_STRETCH;

typedef struct _RDP_DS_TRANSPARENTSTRETCH
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TSCOLORREF crTransparentColor;
} RDP_DS_TRANSPARENTSTRETCH;

typedef struct _RDP_DS_ALPHASTRETCH
{
    BYTE ulCmdID;
    TS_RECTANGLE16 rclDst;
    TS_RECTANGLE16 rclSrc;
    TS_BLENDFUNC blendFunction;
} RDP_DS_ALPHASTRETCH;
#endif
#endif //DRAW_NINEGRID

/****************************************************************************/
/* Structure: TS_SECONDARY_ORDER                                            */
/****************************************************************************/
typedef struct tagTS_SECONDARY_ORDER
{
    union
    {
        TS_CACHE_BITMAP_ORDER      cacheBitmap;
        TS_CACHE_COLOR_TABLE_ORDER cacheColorTable;
        TS_CACHE_GLYPH_ORDER       cacheGlyph;
        TS_CACHE_BRUSH_ORDER       cacheBrush;
    } u;
} TS_SECONDARY_ORDER, FAR * PTS_SECONDARY_ORDER;


/****************************************************************************/
/* Structure: TS_UPDATE_PALETTE_PDU                                         */
/****************************************************************************/
typedef struct tagTS_UPDATE_PALETTE_PDU_DATA
{
    TSUINT16 updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16 pad2octets;
    TSUINT32 numberColors;
    TS_COLOR palette[1];      /* 16 or 256 entries               */
} TS_UPDATE_PALETTE_PDU_DATA, FAR * PTS_UPDATE_PALETTE_PDU_DATA;

typedef struct tagTS_UPDATE_PALETTE_PDU
{
    TS_SHAREDATAHEADER  shareDataHeader;
    TS_UPDATE_PALETTE_PDU_DATA data;
} TS_UPDATE_PALETTE_PDU, FAR * PTS_UPDATE_PALETTE_PDU;


/****************************************************************************/
/* Structure: TS_UPDATE_SYNCHRONIZE_PDU                                     */
/****************************************************************************/
typedef struct tagTS_UPDATE_SYNCHRONIZE_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16           updateType;            /* See TS_UPDATE_HDR         */
    TSUINT16           pad2octets;
} TS_UPDATE_SYNCHRONIZE_PDU, FAR * PTS_UPDATE_SYNCHRONIZE_PDU;


/****************************************************************************/
/* CONSTANTS                                                                */
/****************************************************************************/
#define TS_PROTOCOL_VERSION 0x0010

/****************************************************************************/
/* MCS priorities                                                           */
/****************************************************************************/
#define TS_LOWPRIORITY   3
#define TS_MEDPRIORITY   2
#define TS_HIGHPRIORITY  1

#ifdef DC_HICOLOR
/****************************************************************************/
/* Mask definitions for high color support                                  */
/****************************************************************************/
#define TS_RED_MASK_24BPP    0xff0000;
#define TS_GREEN_MASK_24BPP  0x00ff00;
#define TS_BLUE_MASK_24BPP   0x0000ff;

#define TS_RED_MASK_16BPP    0xf800
#define TS_GREEN_MASK_16BPP  0x07e0
#define TS_BLUE_MASK_16BPP   0x001f

#define TS_RED_MASK_15BPP    0x7c00
#define TS_GREEN_MASK_15BPP  0x03e0
#define TS_BLUE_MASK_15BPP   0x001f
#endif

/****************************************************************************/
/* Structure: TS_REFRESH_RECT_PDU                                           */
/*                                                                          */
/* Name of PDU: RefreshRectanglePDU (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Client -> Server (and optionally: Server -> Client)         */
/*      Requests that the Server should send data to the client to allow    */
/*      the client to redraw the areas defined by the rectangles defined in */
/*      the PDU. The server responds by sending updatePDUs (orders, bitmap  */
/*      data etc.) containing all the drawing information necessary to      */
/*      "fill in" the rectangle.  The server will probably implement this   */
/*      by invalidating the rectangle - which results in a bunch of drawing */
/*      orders from the affected apps, which are then remoted to the Client */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      numberOfAreas:   count of rectangles included                       */
/*      areaToRefresh:   area the client needs repainted                    */
/****************************************************************************/
typedef struct tagTS_REFRESH_RECT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT8            numberOfAreas;
    TSUINT8            pad3octets[3];
    TS_RECTANGLE16     areaToRefresh[1];        /* inclusive               */
} TS_REFRESH_RECT_PDU, FAR * PTS_REFRESH_RECT_PDU;
#define TS_REFRESH_RECT_PDU_SIZE sizeof(TS_REFRESH_RECT_PDU)
#define TS_REFRESH_RECT_UNCOMP_LEN 12


/****************************************************************************/
/* Structure: TS_SUPPRESS_OUTPUT_PDU                                        */
/*                                                                          */
/* Name of PDU: SuppressOutputPDU (a T.128 extension)                       */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Client -> Server                                            */
/*      Notifies the Server that there are changes in the areas of the      */
/*      shared desktop that are visible at the client.                      */
/*                                                                          */
/*      By default, at the start of a new session, the server assumes that  */
/*      the entire desktop is visible at the client and will send all       */
/*      remoted output to it.  During a session, the client can use this    */
/*      PDU to notify the server that only certain areas of the shared      */
/*      desktop are visible.  The server may then choose NOT to send output */
/*      for the other areas (note: the server does not guarantee to not     */
/*      send the output; the client must be capable of handling such output */
/*      by ignoring it).                                                    */
/*                                                                          */
/*      Once the client has sent one of these PDUs it is then responsible   */
/*      for keeping the server up to date i.e.  it must send further        */
/*      PDUs whenever the areas that can be excluded changes.  Note that    */
/*      processing the PDU at the server can be quite an expensive          */
/*      operation (because areas that were excluded but are now not-        */
/*      excluded need to be redrawn to ensure that the client has an        */
/*      up to date view of them).                                           */
/*                                                                          */
/*      The intent behind this PDU is not that the Client should notify the */
/*      server every time the client area is resized (by the user dragging  */
/*      the frame border for example) but to allow line-utilization         */
/*      optimization whenever there is any "significant" reason for         */
/*      output to be excluded.  The definition of "significant" is          */
/*      entirely a client decision but reasons might include                */
/*      - the client is minimized (which suggests that the user is          */
/*          likely to not want to see the Client output for a lengthy       */
/*          period of time)                                                 */
/*      - another application is maximized and has the focus (which         */
/*          again suggests that the client user may not be interested in    */
/*          output for a lengthy period of time)                            */
/*      - with multiple-monitor configuration at the client there may       */
/*          be some areas of the server desktop that are simply NEVER       */
/*          visible at the client; selectively suppressing output for       */
/*          those areas is a good idea.                                     */
/*                                                                          */
/*      Note that in TSE4.0 and Win2000, the Client only ever excludes      */
/*      output for the entire desktop, or for none of it. Similarly, the    */
/*      server only actually suppresses all output or none (it cannot       */
/*      suppress output for selected areas).                                */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      numberOfRectangles: TS_QUIET_FULL_SUPPRESSION (zero): indicates     */
/*                            that the Server may choose to stop sending    */
/*                            all output (including sound).                 */
/*                          1..TS_MAX_INCLUDED_RECTS: number of rectangles  */
/*                            following.                                    */
/*                          any other value: ASSERTABLE ERROR.              */
/*      includedRectangle[] Each rectangle defines an area of the desktop   */
/*                          for which the client requires output.           */
/****************************************************************************/
typedef struct tagTS_SUPPRESS_OUTPUT_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT8            numberOfRectangles;
#define TS_QUIET_FULL_SUPPRESSION   0
#define TS_MAX_INCLUDED_RECTS       128

    TSUINT8            pad3octets[3];
    TS_RECTANGLE16     includedRectangle[1];                 /* optional. */

} TS_SUPPRESS_OUTPUT_PDU, FAR * PTS_SUPPRESS_OUTPUT_PDU;
#define TS_SUPPRESS_OUTPUT_PDU_SIZE(n) \
       ((sizeof(TS_SUPPRESS_OUTPUT_PDU)-sizeof(TS_RECTANGLE16)) + \
        (n * sizeof(TS_RECTANGLE16)))
#define TS_SUPPRESS_OUTPUT_UNCOMP_LEN(n) \
                                             (8 + n * sizeof(TS_RECTANGLE16))


/****************************************************************************/
/* Structure: TS_PLAY_SOUND_PDU                                             */
/*                                                                          */
/* Name of PDU: PlaySoundPDU        (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Server -> Client                                            */
/*      On receipt, the Client should (if possible) generate some local     */
/*      audio output as indicated by the information in the packet.         */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      duration:     duration in ms                                        */
/*      frequency:    frequency in Hz                                       */
/****************************************************************************/
typedef struct tagTS_PLAY_SOUND_PDU_DATA
{
    TSUINT32 duration;
    TSUINT32 frequency;
} TS_PLAY_SOUND_PDU_DATA, FAR * PTS_PLAY_SOUND_PDU_DATA;

typedef struct tagTS_PLAY_SOUND_PDU
{
    TS_SHAREDATAHEADER       shareDataHeader;
    TS_PLAY_SOUND_PDU_DATA   data;
} TS_PLAY_SOUND_PDU, FAR * PTS_PLAY_SOUND_PDU;


/****************************************************************************/
/* Structure: TS_SHUTDOWN_REQUEST_PDU                                       */
/*                                                                          */
/* Name of PDU: ShutdownRequestPDU  (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Client -> Server                                            */
/*      Notifies the Server that the Client wishes to terminate. If the     */
/*      server objects for some reason (in RNS/Ducati this reason is        */
/*      "the user is still logged on to the underlying session") then       */
/*      the server responds with a shutdownDeniedPDU.  Otherwise, this      */
/*      PDU has no response, and the Server disconnects the Client (which   */
/*      then terminates).                                                   */
/****************************************************************************/
typedef struct tagTS_SHUTDOWN_REQ_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
} TS_SHUTDOWN_REQ_PDU, FAR * PTS_SHUTDOWN_REQ_PDU;
#define TS_SHUTDOWN_REQ_PDU_SIZE sizeof(TS_SHUTDOWN_REQ_PDU)
#define TS_SHUTDOWN_REQ_UNCOMP_LEN 4


/****************************************************************************/
/* Structure: TS_SHUTDOWN_DENIED_PDU                                        */
/*                                                                          */
/* Name of PDU: ShutdownDeniedPDU   (a T.128 extension)                     */
/*                                                                          */
/* Description of Function:                                                 */
/*   Flows from Server -> Client                                            */
/*      Notifies the Client that the remote user is still logged on to      */
/*      the NT session, and for this reason RNS is not going to end the     */
/*      conference (even though the client has signalled that this should   */
/*      happen by sending a ShutdownRequestPDU).                            */
/****************************************************************************/
typedef struct tagTS_SHUTDOWN_DENIED_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
} TS_SHUTDOWN_DENIED_PDU, FAR * PTS_SHUTDOWN_DENIED_PDU;


/****************************************************************************/
/* Structure: TS_LOGON_INFO                                                 */
/****************************************************************************/
typedef struct tagTS_LOGON_INFO
{
    TSUINT32 cbDomain;
    TSUINT8  Domain[TS_MAX_DOMAIN_LENGTH_OLD];

    TSUINT32 cbUserName;
    TSUINT8  UserName[TS_MAX_USERNAME_LENGTH];

    TSUINT32 SessionId;
} TS_LOGON_INFO, FAR * PTS_LOGON_INFO;

/****************************************************************************/
/* Structure: TS_LOGON_INFO_VERSION_2 ; For Supporting Long Credentials     */
/****************************************************************************/
typedef struct tagTS_LOGON_INFO_VERSION_2
{
    TSUINT16 Version; 
    #define SAVE_SESSION_PDU_VERSION_ONE 1
    TSUINT32 Size; 
    TSUINT32 SessionId;
    TSUINT32 cbDomain;
    TSUINT32 cbUserName;
    // NOTE -- Actual Domain and UserName follows this structure
    // The actual Domain name follows this structure immediately 
    // The actual UserName follows the Domain Name
    // Both the Domain and UserName are NULL terminated
} TS_LOGON_INFO_VERSION_2, FAR * PTS_LOGON_INFO_VERSION_2; 


/****************************************************************************/
/* Structure: TS_LOGON_INFO_EXTENDED ; Supports extended logon info         */
/****************************************************************************/
typedef struct tagTS_LOGON_INFO_EXTENDED
{
    // Overall length of this packet, including the header fields.
    TSUINT16 Length;
    // Flags specify which pieces of data are present (ordered)
    TSUINT32 Flags;
#define LOGON_EX_AUTORECONNECTCOOKIE    0x1

    // Variable-length. For each field, it has the form
    // ULONG Length
    // BYTE  data[]
} TS_LOGON_INFO_EXTENDED, FAR * PTS_LOGON_INFO_EXTENDED; 

/****************************************************************************/
/* Structure: TS_SAVE_SESSION_INFO_PDU                                      */
/****************************************************************************/
typedef struct tagTS_SAVE_SESSION_INFO_PDU_DATA
{
    TSUINT32 InfoType;
#define TS_INFOTYPE_LOGON               0
#define TS_INFOTYPE_LOGON_LONG          1
// Plain notify just notifies of the fact that we've logged on.
#define TS_INFOTYPE_LOGON_PLAINNOTIFY   2
// Extended logon info packet (e.g contains autoreconnect cookie)
#define TS_INFOTYPE_LOGON_EXTENDED_INFO 3

    union
    {
        TS_LOGON_INFO           LogonInfo;
        TS_LOGON_INFO_VERSION_2 LogonInfoVersionTwo;
        TS_LOGON_INFO_EXTENDED  LogonInfoEx;
    } Info;
} TS_SAVE_SESSION_INFO_PDU_DATA, FAR * PTS_SAVE_SESSION_INFO_PDU_DATA;

typedef struct tagTS_SAVE_SESSION_INFO_PDU
{
    TS_SHAREDATAHEADER            shareDataHeader;
    TS_SAVE_SESSION_INFO_PDU_DATA data;
} TS_SAVE_SESSION_INFO_PDU, FAR * PTS_SAVE_SESSION_INFO_PDU;
#define TS_SAVE_SESSION_INFO_PDU_SIZE sizeof(TS_SAVE_SESSION_INFO_PDU)


/****************************************************************************/
/* Structure: TS_SET_ERROR_INFO_PDU                                         */
/****************************************************************************/
typedef struct tagTS_SET_ERROR_INFO_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           errorInfo;
} TS_SET_ERROR_INFO_PDU, FAR * PTS_SET_ERROR_INFO_PDU;
#define TS_SET_ERROR_INFO_PDU_SIZE sizeof(TS_SET_ERROR_INFO_PDU)

/****************************************************************************/
/* Structure: TS_SET_KEYBOARD_INDICATORS_PDU                                */
/****************************************************************************/
typedef struct tagTS_SET_KEYBOARD_INDICATORS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16 UnitId;
    TSUINT16 LedFlags;
} TS_SET_KEYBOARD_INDICATORS_PDU, FAR * PTS_SET_KEYBOARD_INDICATORS_PDU;
#define TS_SET_KEYBOARD_INDICATORS_PDU_SIZE       sizeof(TS_SET_KEYBOARD_INDICATORS_PDU)


/****************************************************************************/
/* Structure: TS_SET_KEYBOARD_IME_STATUS_PDU                                */
/****************************************************************************/
typedef struct tagTS_SET_KEYBOARD_IME_STATUS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT16 UnitId;
    TSUINT32 ImeOpen;
    TSUINT32 ImeConvMode;
} TS_SET_KEYBOARD_IME_STATUS_PDU, FAR * PTS_SET_KEYBOARD_IME_STATUS_PDU;
#define TS_SET_KEYBOARD_IME_STATUS_PDU_SIZE sizeof(TS_SET_KEYBOARD_IME_STATUS_PDU)

/****************************************************************************/
/* Structure: TS_AUTORECONNECT_STATUS_PDU                                   */
/****************************************************************************/
typedef struct tagTS_AUTORECONNECT_STATUS_PDU
{
    TS_SHAREDATAHEADER shareDataHeader;
    TSUINT32           arcStatus;
} TS_AUTORECONNECT_STATUS_PDU, FAR * PTS_AUTORECONNECT_STATUS_PDU;
#define TS_AUTORECONNECT_STATUS_PDU_SIZE sizeof(TS_AUTORECONNECT_STATUS_PDU)



/****************************************************************************/
/* Restore packing style (previous for 32-bit, default for 16-bit).         */
/****************************************************************************/
#ifdef OS_WIN16
#pragma pack ()
#else
#pragma pack (pop, t128pack)
#endif


#endif /* _H_AT128 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\atrcint.h ===
/**INC+**********************************************************************/
/* Header:    atrcint.h                                                     */
/*                                                                          */
/* Purpose:   Internal tracing functions header                             */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/atrcint.h_v  $
 *
 *    Rev 1.5   10 Jul 1997 18:06:00   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.4   10 Jul 1997 17:16:14   KH
 * SFR1022: Get 16-bit trace working
**/
/**INC-**********************************************************************/
#ifndef _H_ATRCINT
#define _H_ATRCINT

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Internal trace state flags.  Trace can be in one of three states:        */
/*                                                                          */
/*  TRC_STATE_UNINTIALIZED : trace has been loaded but not been             */
/*                           initialized.  If a call is made to output a    */
/*                           line then trace will automatically intialize   */
/*                           itself and move to TRC_STATE_INITIALIZED.      */
/*                                                                          */
/*  TRC_STATE_INITIALIZED  : this is the normal state - trace is loaded and */
/*                           initialized.  Outputting of trace lines is     */
/*                           permitted in this mode.                        */
/*                                                                          */
/*  TRC_STATE_TERMINATED   : trace has been terminated.  Outputting of      */
/*                           trace lines is no longer allowed and any calls */
/*                           to output a line will be rejected.             */
/*                                                                          */
/****************************************************************************/
#define TRC_STATE_UNINITIALIZED        0
#define TRC_STATE_INITIALIZED          1
#define TRC_STATE_TERMINATED           2

/****************************************************************************/
/* Internal trace status flags.  These are used in the <trcStatus> field of */
/* the TRC_SHARED_DATA structure.                                           */
/*                                                                          */
/* TRC_STATUS_ASSERT_DISPLAYED         : is an assert box displayed?        */
/****************************************************************************/
#define TRC_STATUS_ASSERT_DISPLAYED    DCFLAG32(0)

/****************************************************************************/
/* Trace format definitions.  These are used for printing various parts of  */
/* the trace lines.                                                         */
/*                                                                          */
/* TIME     is the time in the form hours, mins, secs, hundredths.          */
/* DATE     is the date in the form day, month, year.                       */
/* FUNC     is the module function name.  This is of variable size.         */
/* LINE     is the line number within the source file.                      */
/* PROC     is the process identifier.                                      */
/* THRD     is the thread identifier.                                       */
/*                                                                          */
/****************************************************************************/
#define TRC_TIME_FMT                   _T("%02d:%02d:%02d.%02d")
#define TRC_DATE_FMT                   _T("%02d/%02d/%02d")
#define TRC_FUNC_FMT                   _T("%-*.*s")
#define TRC_LINE_FMT                   _T("%04d")
#define TRC_PROC_FMT                   _T("%04.4lx")
#define TRC_THRD_FMT                   _T("%04.4lx")

/****************************************************************************/
/* Assert box title                                                         */
/****************************************************************************/
#define TRC_ASSERT_TITLE     _T("ASSERTion failed")

/****************************************************************************/
/* Internal buffer sizes.                                                   */
/*                                                                          */
/* TRC_NUM_PREFIXES      : the number of prefixes supported.                */
/* TRC_PREFIX_LENGTH     : the length of each prefix string.                */
/* TRC_MAX_SYMNAME_SIZE  : the maximum length of a symbol name.             */
/****************************************************************************/
#define TRC_NUM_PREFIXES               20
#define TRC_PREFIX_LENGTH              8
#define TRC_MAX_SYMNAME_SIZE           1024

/****************************************************************************/
/* Maximum number of functions to write out in a stack trace.               */
/****************************************************************************/
#define TRC_MAX_SIZE_STACK_TRACE       100

/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRC_FILTER                                                               */
/* ==========                                                               */
/* The pointer to the filter definition for internal tracing                */
/*                                                                          */
/* trcStatus         : status flag to prevent multiple assert displays.     */
/* trcPfxNameArray   : prefix name array.                                   */
/* trcPfxLevelArray  : prefix level array.                                  */
/* trcPfxFnLvlArray  : prefix function entry/exit trace flag array.         */
/* trcPfxStartArray  : prefix line number range start                       */
/* trcPfxEndArray    : prefix line number range end                         */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_FILTER
{
    DCUINT32 trcStatus;
    DCTCHAR  trcPfxNameArray[TRC_NUM_PREFIXES][TRC_PREFIX_LENGTH];
    DCUINT32 trcPfxLevelArray[TRC_NUM_PREFIXES];
    DCBOOL32 trcPfxFnLvlArray[TRC_NUM_PREFIXES];
    DCUINT32 trcPfxStartArray[TRC_NUM_PREFIXES];
    DCUINT32 trcPfxEndArray[TRC_NUM_PREFIXES];
} TRC_FILTER;

typedef TRC_FILTER  DCPTR PTRC_FILTER;

/****************************************************************************/
/* TRC_LINE                                                                 */
/* ========                                                                 */
/* The TRC_LINE structure defines the format of a data trace line header.   */
/*                                                                          */
/* address    : the address of the data block.                              */
/* hexData    : the data in hex format.                                     */
/* asciiData  : the data in ascii format.                                   */
/* end        : terminating characters at the end of the line (CR+LF).      */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_LINE
{
    DCTCHAR address[10];
    DCTCHAR hexData[36];
    DCTCHAR asciiData[16];
    DCTCHAR end[3];
} TRC_LINE;

typedef TRC_LINE  DCPTR PTRC_LINE;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRCInternalError                                                         */
/* ================                                                         */
/* This macro outputs an internal error string to the debug console and     */
/* the trace file.                                                          */
/****************************************************************************/
#define TRCInternalError(pText)                                              \
{                                                                            \
    TRCOutput(pText, DC_ASTRLEN(pText), TRC_LEVEL_ALT);                      \
}

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/* TRCCheckState                                                            */
/* TRCDumpLine                                                              */
/* TRCInternalTrace                                                         */
/* TRCOutput                                                                */
/* TRCReadFlag                                                              */
/* TRCReadSharedDataConfig                                                  */
/* TRCResetTraceFiles                                                       */
/* TRCSetDefaults                                                           */
/* TRCShouldTraceThis                                                       */
/* TRCSplitPrefixes                                                         */
/* TRCStrnicmp                                                              */
/* TRCWriteFlag                                                             */
/* TRCWriteSharedDataConfig                                                 */
/*                                                                          */
/****************************************************************************/
DCBOOL32 DCINTERNAL TRCCheckState(DCVOID);

DCVOID DCINTERNAL TRCDumpLine(PDCUINT8 buffer,
                              DCUINT   length,
                              DCUINT32 offset,
                              DCUINT   traceLevel);

DCVOID DCINTERNAL TRCInternalTrace(DCUINT32 type);

DCVOID DCINTERNAL TRCOutput(PDCTCHAR pText,
                            DCINT    length,
                            DCINT    traceLevel);

DCVOID DCINTERNAL TRCReadFlag(PDCTCHAR  entryName,
                              DCUINT32  flag,
                              PDCUINT32 pSetting);

DCVOID DCINTERNAL TRCReadSharedDataConfig(DCVOID);

DCVOID DCINTERNAL TRCResetTraceFiles(DCVOID);

DCVOID DCINTERNAL TRCSetDefaults(DCVOID);

DCBOOL DCINTERNAL TRCShouldTraceThis(DCUINT32 traceComponent,
                                     DCUINT32 traceLevel,
                                     PDCTCHAR pFileName,
                                     DCUINT32 lineNumber);

DCVOID DCINTERNAL TRCSplitPrefixes(DCVOID);

DCINT32 DCINTERNAL TRCStrnicmp(PDCTCHAR pSource,
                               PDCTCHAR pTarget,
                               DCUINT32 count);

DCVOID DCINTERNAL TRCWriteFlag(PDCTCHAR entryName,
                               DCUINT32 flag,
                               DCUINT32 setting);

DCVOID DCINTERNAL TRCWriteSharedDataConfig(DCVOID);

DCVOID DCINTERNAL TRCNotifyAllTasks(DCVOID);

/****************************************************************************/
/*                                                                          */
/* OPERATING SYSTEM SPECIFIC INCLUDES                                       */
/*                                                                          */
/****************************************************************************/
#include <wtrcint.h>

#endif /* _H_ATRCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\compress.h ===
//************************************************************************
// compress.h
//
// Header for MPPC compression for RDP.
//
// Copyright (C) 1994-2000 Microsoft Corporation
//************************************************************************
#ifndef __COMPRESS_H
#define __COMPRESS_H


#ifndef BASETYPES
#define BASETYPES
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#endif  /* !BASETYPES */

// History buffer sizes for various compression levels.
#define HISTORY_SIZE_8K  (8192L)
#define HISTORY_SIZE_64K (65536L)

#ifndef OS_WINCE
// Enabling the compression instrumentation only for debug bits.
#ifdef DC_DEBUG
#define COMPR_DEBUG 1
#endif 

#endif

// Server-only items. The Win16 client compile will complain otherwise.
//#if defined(DLL_WD) || defined(DLL_DISP)

// Hash table number of entries used on the compress side.
#define HASH_TABLE_SIZE 32768

typedef struct SendContext {
    UCHAR    History [HISTORY_SIZE_64K];
    int      CurrentIndex;     // how far into the history buffer we are
    PUCHAR   ValidHistory;     // how much of history is valid
    unsigned ClientComprType;  // The compression types supported by decompress.
    ULONG    HistorySize;      // History size used based on ComprType.
    USHORT   HashTable[HASH_TABLE_SIZE];  // 16 bits=max 64K for HistorySize.
} SendContext;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


void initsendcontext(SendContext *, unsigned);

UCHAR compress(UCHAR *, UCHAR *, ULONG *, SendContext *);

#ifdef __cplusplus
}
#endif // __cplusplus



//#else //(DLL_WD) || (DLL_DISP)


// We split the receive context into two pieces to deal with the Win16
// client's inability to malloc over 64K without using a nasty HUGE pointer.

typedef struct RecvContext1 {
    UCHAR FAR *CurrentPtr;  // how far into the history buffer we are
} RecvContext1;

//
// 64K decompression context
//
typedef struct RecvContext2_64K {
    // We use one less byte to allow this struct to be allocated with
    // LocalAlloc() on the Win16 client.
    ULONG cbSize;
    ULONG cbHistorySize;
    UCHAR History[HISTORY_SIZE_64K - 1];

// Won't work if on Win16.
// Debug Fence code only works for 64K contexts
#ifdef COMPR_DEBUG
#define DEBUG_FENCE_16K_VALUE    0xABABABAB
    ULONG Debug16kFence;
#endif

} RecvContext2_64K;

//
// 8K decompression context
//
typedef struct RecvContext2_8K {
    // We use one less byte to allow this struct to be allocated with
    // LocalAlloc() on the Win16 client.
    ULONG cbSize;
    ULONG cbHistorySize;
    UCHAR History[HISTORY_SIZE_8K - 1];

#ifdef COMPR_DEBUG
#define DEBUG_FENCE_8K_VALUE    0xABCABCAB
    ULONG Debug8kFence;
#endif

} RecvContext2_8K;

//
// Generic decompression context.
// This is the 'type' we use when passing around
// compression contexts as parameters
// size field tells us which one we're using
//
//
// IMPORTANT: Field ordering must match exactly
//            Between the Generic type and any
//            size specific contexts.
typedef struct RecvContext2_Generic {
    ULONG cbSize;
    ULONG cbHistorySize;
    UCHAR History[1];
} RecvContext2_Generic;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

int initrecvcontext(RecvContext1 *, RecvContext2_Generic *, unsigned ComprType);

int decompress(
        UCHAR FAR *inbuf,
        int inlen,
        int start,
        UCHAR FAR * FAR *output,
        int *outlen,
        RecvContext1 *context1,
        RecvContext2_Generic *context2,
        unsigned ComprType);

#ifdef __cplusplus
}
#endif // __cplusplus



//#endif  // DLL_WD | DLL_DISP


//
// Other defines
//

// There are 8 bits of packet data in the generalCompressedType field of the
// SHAREDATAHEADER. Note that PACKET_ENCRYPTED is unused (therefore
// reusable in the future).
#define PACKET_FLUSHED    0x80
#define PACKET_AT_FRONT   0x40
#define PACKET_COMPRESSED 0x20
#define PACKET_ENCRYPTED  0x10

// Defines which of 16 potential compression types we are using.
// 8K corresponds to the TSE4 client and server. 64K is the newer re-optimized
// version used in TSE5. Note that the type values are re-used in the
// GCC conference client capability set. Any client advertising support for
// type N must support types 0..(N-1) since it could be talking to an older
// server and receive any older type.
#define PACKET_COMPR_TYPE_MASK 0x0F
#define PACKET_COMPR_TYPE_8K   0
#define PACKET_COMPR_TYPE_64K  1
#define PACKET_COMPR_TYPE_MAX  1

// VC compression options take up bytes 5 of the VC header flags field
#define VC_FLAG_COMPRESS_MASK              0xFF
#define VC_FLAG_COMPRESS_SHIFT             16
#define VC_FLAG_PRIVATE_PROTOCOL_MASK      0xFFFF0000



#endif  // __COMPRESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ddcgbtyp.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ddcgbtyp.h                                                               */
/*                                                                          */
/* DC-Groupware basic types - 16-bit Windows specific header                */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/ddcgbtyp.h_v  $
 *
 *    Rev 1.8   22 Sep 1997 15:10:22   KH
 * SFR1368: Keep the Win16 INI file in Windows, not Ducati, directory
 *
 *    Rev 1.7   22 Aug 1997 17:36:50   AK
 * SFR1330: Win16 retail build support
 *
 *    Rev 1.6   04 Aug 1997 14:54:44   KH
 * SFR1022: Move DCCALLBACK to wdcgbtyp, add LOADDS
 *
 *    Rev 1.5   10 Jul 1997 17:18:56   KH
 * SFR1022: Get 16-bit trace working
 *
 *    Rev 1.4   09 Jul 1997 17:09:48   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   04 Jul 1997 11:13:50   KH
 * SFR1022: Fix 16-bit compiler warnings
 *
 *    Rev 1.2   25 Jun 1997 14:32:52   KH
 * Win16Port: 16-bit basic types
 *
 *    Rev 1.1   19 Jun 1997 15:02:44   ENH
 * Win16Port: 16 bit specifics
**/
/**INC-**********************************************************************/
#ifndef _H_DDCGBTYP
#define _H_DDCGBTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Check whether we should include the system headers.                      */
/****************************************************************************/
#ifndef DC_NO_SYSTEM_HEADERS

/****************************************************************************/
/* Force strict type checking.                                              */
/****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/****************************************************************************/
/* Disable the following warnings for the Windows headers:                  */
/*                                                                          */
/* 4115: named type definition in parentheses                               */
/* 4201: nonstandard extension used : nameless struct/union                 */
/* 4214: nonstandard extension used : bit field types other than int        */
/* 4702: unreachable code effect                                            */
/* 4704: in-line assembler precludes global optimizations                   */
/* 4705: statement has no effect                                            */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4115)
#pragma warning (disable: 4201)
#pragma warning (disable: 4214)
#ifndef DC_DEBUG
#pragma warning (disable: 4702)
#pragma warning (disable: 4704)
#pragma warning (disable: 4705)
#endif

/****************************************************************************/
/* Include the system headers.                                              */
/****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <stddef.h>

#pragma warning (default: 4115)
#pragma warning (default: 4201)
#pragma warning (default: 4214)

/****************************************************************************/
/* Disable the following warnings for our code:                             */
/*                                                                          */
/* 4102: "Unreferenced label" warnings so that DC_EXIT_POINT can be placed  */
/*       in each function if there aren't (yet) any DC_QUITs.               */
/* 4514: unreferenced inline function has been removed                      */
/* 4001: nonstandard extension 'single line comment' was used               */
/* 4058: unions are now aligned on alignment requirement, not size          */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4102)
#pragma warning (disable: 4514)
#pragma warning (disable: 4001)
#pragma warning (disable: 4058)

/****************************************************************************/
/* Promote the following warnings to errors:                                */
/*                                                                          */
/* 4706 - "Assignment in conditional expression"                            */
/* 4013 - "'FunctionName' undefined; assuming extern returning int"         */
/*                                                                          */
/* Promote the following warnings to level 3:                               */
/*                                                                          */
/* 4100 - "unreferenced formal parameter"                                   */
/* 4701 - "Local variable may be used before being initialized".            */
/* 4244 - "conversion from 'int ' to 'short ', possible loss of data        */
/* 4127 - "conditional expression is constant                               */
/*                                                                          */
/****************************************************************************/
// #pragma warning (error: 4706)
// #pragma warning (error: 4013)
// #pragma warning (3    : 4100)
// #pragma warning (3    : 4701)
// #pragma warning (3    : 4244)
// #pragma warning (4    : 4127)

#endif /* DCS_NO_SYSTEM_HEADERS */

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* INI file access.                                                         */
/****************************************************************************/
#define DC_INIFILE "mstsc.ini"
#define DC_INI_INTVAL1 0x7fff
#define DC_INI_INTVAL2 (DC_INI_INTVAL1 - 1)
#define DC_INI_STRVAL1 "x"
#define DC_INI_STRVAL2 "w"

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DCPTR is used when declaring pointers to variables.  Use it to get the   */
/* correct pointer types for your memory model/compiler.                    */
/****************************************************************************/
#define DCPTR               FAR *

/****************************************************************************/
/* DCUNALIGNED is used to define pointers to values which are not aligned   */
/* on the correct boundary.  Doesn't apply for 16-bit.                      */
/****************************************************************************/
#define DCUNALIGNED

/****************************************************************************/
/* Define function calling conventions.  Note that PDCAPI should be used to */
/* declare a pointer to a function.                                         */
/****************************************************************************/
#define DCEXPORT           __export
#define DCLOADDS           __loadds
#define DCAPI              _pascal
#define DCINTERNAL         _pascal

#define PDCAPI              DCAPI      DCPTR
#define PDCCALLBACK         DCCALLBACK DCPTR
#define PDCINTERNAL         DCINTERNAL DCPTR

/****************************************************************************/
/* Define DCHPTR.                                                           */
/****************************************************************************/
#define HUGE               _huge
#define DCHPTR              HUGE *

#ifdef OS_WIN16
#define UNREFERENCED_PARAMETER(P)          (P)
#endif // OS_WIN16

#endif /* _H_DDCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ddcgcfnc.h ===
/****************************************************************************/
/*                                                                          */
/* ddcgcfnc.h                                                               */
/*                                                                          */
/* DC-Groupware C runtime functions - Windows 3.1 specific header.          */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/ddcgcfnc.h_v  $                                                                   */
// 
//    Rev 1.1   19 Jun 1997 15:06:22   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/****************************************************************************/
#ifndef _H_DDCGCFNC
#define _H_DDCGCFNC



/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

#endif /* _H_DDCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ddcgmcro.h ===
/****************************************************************************/
/*                                                                          */
/* ddcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - Windows 3.1 specific header.                */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/ddcgmcro.h_v  $                                                                   */
// 
//    Rev 1.3   17 Jul 1997 18:22:10   JPB
// SFR1031: Fixed FIELDSIZE macro for Win16
//
//    Rev 1.2   25 Jun 1997 14:43:28   KH
// Win16Port: 16-bit macros
//
//    Rev 1.1   19 Jun 1997 15:15:58   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/****************************************************************************/
#ifndef _H_DDCGMCRO
#define _H_DDCGMCRO

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Fieldsize macro.                                                         */
/****************************************************************************/
#define FIELDSIZE(type, field)   (sizeof(((type NEAR*)1)->field))

#endif /* _H_DDCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ddcgctyp.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ddcgctyp.h                                                               */
/*                                                                          */
/* DC-Groupware complex types - Windows 3.1 specific header.                */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/* $Log:   Y:/logs/h/dcl/ddcgctyp.h_v  $                                                                    */
//
//    Rev 1.6   15 Sep 1997 18:28:26   AK
// SFR1416: Move SD_BOTH definition
//
//    Rev 1.5   14 Aug 1997 14:03:00   KH
// SFR1022: Define (Ext)TextOutX macros
//
//    Rev 1.4   24 Jul 1997 16:54:14   KH
// SFR1033: Add GetLastError
//
//    Rev 1.3   08 Jul 1997 08:46:52   KH
// SFR1022: Add message parameter extraction macros
//
//    Rev 1.2   25 Jun 1997 14:38:12   KH
// Win16Port: 16-bit complex types
//
//    Rev 1.1   19 Jun 1997 15:09:56   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_DDCGCTYP
#define _H_DDCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
#include <toolhelp.h>
#include <string.h>

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Message box type flag unsupported on Win 3.x                             */
/****************************************************************************/
#define MB_SETFOREGROUND 0

/****************************************************************************/
/* Registry stuff not defined in standard 16-bit headers.                   */
/****************************************************************************/
/* from winreg.h */
#define HKEY_CURRENT_USER           (( HKEY ) 0x80000001 )
#define HKEY_LOCAL_MACHINE          (( HKEY ) 0x80000002 )
/* from ntddk.h */
#define REG_SZ              ( 1 ) /* Unicode nul terminated string          */
#define REG_EXPAND_SZ       ( 2 ) /* Unicode nul terminated string          */
                                  /* (with environment variable references) */
#define REG_BINARY          ( 3 ) /* Free form binary                       */
#define REG_DWORD           ( 4 ) /* 32-bit number                          */

/****************************************************************************/
/* 32-bit scroll bar constants.                                             */
/****************************************************************************/
#define SIF_RANGE           0x0001
#define SIF_PAGE            0x0002
#define SIF_POS             0x0004
#define SIF_DISABLENOSCROLL 0x0008
#define SIF_TRACKPOS        0x0010
#define SIF_ALL             (SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
typedef MINMAXINFO              DCPTR  LPMINMAXINFO;
typedef struct tagDCLARGEINTEGER
{
    DCUINT32 LowPart;
    DCINT32  HighPart;
} DCLARGEINTEGER;

/****************************************************************************/
/* Scroll bar info used by 32-bit API.                                      */
/****************************************************************************/
typedef struct tagSCROLLINFO
{
    DCUINT cbSize;
    DCUINT fMask;
    DCINT  nMin;
    DCINT  nMax;
    DCUINT nPage;
    DCINT  nPos;
    DCINT  nTrackPos;
}   SCROLLINFO, DCPTR LPSCROLLINFO;

/****************************************************************************/
/* Types which should not feature in a 16-bit build. Define to nonsense so  */
/* any 16-bit useage is caught at compile time.                             */
/****************************************************************************/
#define DCSURFACEID             *** ERROR ***
#define PDCSURFACEID            *** ERROR ***

/****************************************************************************/
/* Types used by DC-Groupware tracing                                       */
/****************************************************************************/
typedef DWORD HKEY;
typedef struct tagDCFILETIME
{
    DCUINT32 dwLowDateTime;
    DCUINT32 dwHighDateTime;
} DCFILETIME;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Unicode support for 16-bit client                                        */
/****************************************************************************/
#define ExtTextOutW(a, b, c, d, e, f, g, h) \
    (ExtTextOut(a, b, c, d, e, f, g, h))
#define ExtTextOutA(a, b, c, d, e, f, g, h) \
    (ExtTextOut(a, b, c, d, e, f, g, h))
#define TextOutW(a, b, c, d, e) (TextOut(a, b, c, d, e))
#define TextOutA(a, b, c, d, e) (TextOut(a, b, c, d, e))

/****************************************************************************/
/* String manipulation                                                      */
/****************************************************************************/
#define DC_CHARNEXT(pCurrentChar) (AnsiNext(pCurrentChar))
#define DC_CHARPREV(pStringStart, pCurrentChar) \
                                       (AnsiPrev(pStringStart, pCurrentChar))
#define DC_CHARLOWER(pString) (AnsiLower(pString))

/****************************************************************************/
/* Memory functions                                                         */
/****************************************************************************/
#define ZeroMemory(A,L) (DC_MEMSET(A,0,L))

/****************************************************************************/
/* Construct a 16-bit value fom two 8-bit values                            */
/****************************************************************************/
#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))

/****************************************************************************/
/* No GetLastError support on win31                                         */
/****************************************************************************/
#define GetLastError() (0)

/****************************************************************************/
/* Message parameter extraction macros.                                     */
/****************************************************************************/
/* WM_COMMAND                                                               */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     command identifier          notification code (HI),           */
/*                                        command identifier (LO)           */
/* lParam     control hwnd (HI),          control hwnd                      */
/*            notification code (LO)                                        */
/****************************************************************************/
#define DC_GET_WM_COMMAND_ID(wParam) (wParam)
#define DC_GET_WM_COMMAND_NOTIFY_CODE(wParam, lParam) (HIWORD(lParam))
#define DC_GET_WM_COMMAND_HWND(lParam) ((HWND)LOWORD(lParam))

/****************************************************************************/
/* WM_ACTIVATE                                                              */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     activation flag             minimized flag (HI),              */
/*                                        activation flag (LO)              */
/* lParam     minimized flag (HI),        hwnd                              */
/*            hwnd (LO)                                                     */
/****************************************************************************/
#define DC_GET_WM_ACTIVATE_ACTIVATION(wParam) (wParam)
#define DC_GET_WM_ACTIVATE_MINIMIZED(wParam, lParam) (HIWORD(lParam))
#define DC_GET_WM_ACTIVATE_HWND(lParam) ((HWND)LOWORD(lParam))

/****************************************************************************/
/* WM_HSCROLL and WM_VSCROLL                                                */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     scroll code                 position (HI),                    */
/*                                        scroll code (LO)                  */
/* lParam     hwnd (HI),                  hwnd                              */
/*            position (LO)                                                 */
/****************************************************************************/
#define DC_GET_WM_SCROLL_CODE(wParam) (wParam)
#define DC_GET_WM_SCROLL_POSITION(wParam, lParam) (LOWORD(lParam))
#define DC_GET_WM_SCROLL_HWND(lParam) ((HWND)LOWORD(lParam))

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
extern DCVOID FAR PASCAL DOS3Call(DCVOID);

#endif /* _H_DDCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ddcgperf.h ===
/**INC+**********************************************************************/
/* Header:  ddcgperf.h                                                      */
/*                                                                          */
/* Purpose: Performance monitoring - Windows 3.1 dummy header.              */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/ddcgperf.h_v  $
 * 
 *    Rev 1.1   15 Jul 1997 15:31:52   MD
 * SFR1029: Create performance build
**/
/**INC-**********************************************************************/
#ifndef _H_DDCGPERF
#define _H_DDCGPERF

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* We don't have any support for performance monitoring on Win3.1 so define */
/* all the macros to null.                                                  */
/****************************************************************************/
#define PRF_INC_COUNTER(x)
#define PRF_ADD_COUNTER(x,n)
#define PRF_SET_RAWCOUNT(x,n)
#define PRF_TIMER_START(x)
#define PRF_TIMER_STOP(x)

#endif /* _H_DDCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\dtrcint.h ===
/**INC+**********************************************************************/
/* Header:    dtrcint.h                                                     */
/*                                                                          */
/* Purpose:   Internal tracing functions header - Windows 3.1 specific      */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/dtrcint.h_v  $
 * 
 *    Rev 1.3   22 Sep 1997 15:11:36   KH
 * SFR1368: Keep the Win16 INI file in Windows, not Ducati, directory
 *
 *    Rev 1.2   09 Jul 1997 17:06:58   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.1   19 Jun 1997 15:28:30   ENH
 * Win16Port: 16 bit specifics
**/
/**INC-**********************************************************************/
#ifndef _H_DTRCINT
#define _H_DTRCINT

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Default values for kernel tracing - off for Win16                        */
/****************************************************************************/
#define TRC_DFLT_KERNEL_DEBUG 0
#define TRC_DFLT_KERNEL_TO_USER 0

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Macro to create the mutex which protects the shared data memory mapped   */
/* file.                                                                    */
/****************************************************************************/
#define TRCCreateMutex(a,b,c) ((HANDLE)1)

/****************************************************************************/
/* Macro to get the mutex which protects the shared data memory mapped      */
/* file.  Not used by Win16.                                                */
/****************************************************************************/
#define TRCGrabMutex() (0)

/****************************************************************************/
/* Macro to free the mutex.  Not used by Win16.                             */
/****************************************************************************/
#define TRCReleaseMutex() (TRUE)

/****************************************************************************/
/* Macro to close the mutex object. Not used by Win16.                      */
/****************************************************************************/
#define TRCCloseHandle(handle) (TRUE)

/****************************************************************************/
/* Trace a string out to the debugger.                                      */
/****************************************************************************/
#define TRCDebugOutput(pText)                                                \
{                                                                            \
    OutputDebugString(pText);                                                \
}

/****************************************************************************/
/* Get the current process Id using the Win32 GetCurrentProcessId function. */
/****************************************************************************/
#define TRCGetCurrentProcessId()   ((DCUINT32)(PDCVOID)GetCurrentTask())

/****************************************************************************/
/* No thread IDs on Win16                                                   */
/****************************************************************************/
#define TRCGetCurrentThreadId()    0

/****************************************************************************/
/* Define our own beep macro.                                               */
/****************************************************************************/
#define TRCBeep()                  MessageBeep(0)

/****************************************************************************/
/* Define our debug break macro.                                            */
/****************************************************************************/
DCVOID DCINTERNAL TRCDebugBreak(DCVOID);

/****************************************************************************/
/* Macro to create a registry key.                                          */
/****************************************************************************/
#define TRC_MAKE_SUBKEY(BUFFER) DC_ASTRCPY(BUFFER, DC_REG_PREFIX);           \
                                DC_ASTRCAT(BUFFER, TRC_INI_SECTION_NAME)

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/

#endif /* _H_DTRCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\mcscommn.h ===
/* (C) 1997-1998 Microsoft Corp.
 *
 * file   : MCSCommn.h
 * author : Erik Mavrinac
 *
 * description: Common definitions for MCS.
 */

#ifndef __MCSCOMMN_H
#define __MCSCOMMN_H



/*
 * MCSError return codes from MCS entry points. These are distinct from
 * T.125 Result, Diagnostic, and Reason codes which are defined below.
 *
 * MCS_NO_ERROR
 *     Success. This does not imply that the requested function is complete if
 *     the requested service is asynchronous -- the result code in a callback
 *     gives this information. This value should also be returned when handling
 *     an MCS callback and the callback has been processed.
 *
 * MCS_COMMAND_NOT_SUPPORTED
 *     The called entry point is not yet implemented.
 *
 * MCS_NOT_INITIALIZED
 *     The application has attempted to use MCS services before MCS has been
 *     initialized.  It is necessary for the node controller (or whatever
 *     application is serving as the node controller), to initialize MCS
 *     before it is called upon to perform any services.
 *
 * MCS_ALREADY_INITIALIZED
 *     The application has attempted to initialize MCS when it is already
 *     initialized.
 *
 * MCS_DOMAIN_ALREADY_EXISTS
 *     The application has attempted to create a domain that already exists.
 *
 * MCS_USER_NOT_ATTACHED
 *     This indicates that the application has issued an MCSAttachUserRequest,
 *     and then tried to use the returned handle before receiving an
 *     MCS_ATTACH_USER_CONFIRM (which essentially validates the handle).
 *
 * MCS_NO_SUCH_USER
 *     An unknown user handle was used during an MCS call.
 *
 * MCS_TRANSMIT_BUFFER_FULL
 *     This indicates that the call failed due to an MCS resource shortage.
 *     This will typically occur when there is a LOT of traffic through the
 *     MCS layer. It simply means that MCS could not process the request at
 *     this time. It is the responsibility of the application to retry at a
 *     later time.
 *
 * MCS_NO_SUCH_CONNECTION
 *     An unknown connection handle was used during an MCS call.
 *
 * MCS_NO_SUCH_DOMAIN
 *     The DomainHandle used was not valid.
 *
 * MCS_DOMAIN_NOT_HIERARCHICAL
 *     An attempt has been made to create an upward connection from a local
 *     domain that already has an upward connection.
 *
 * MCS_ALLOCATION_FAILURE
 *     The request could not be successfully invoked due to a resource
 *     allocation failure.
 *
 * MCS_INVALID_PARAMETER
 *     One of the parameters to an MCS call is invalid.
 */

typedef enum
{
    MCS_NO_ERROR,
    MCS_COMMAND_NOT_SUPPORTED,
    MCS_NOT_INITIALIZED,
    MCS_ALREADY_INITIALIZED,
    MCS_DOMAIN_ALREADY_EXISTS,
    MCS_NO_SUCH_DOMAIN,
    MCS_USER_NOT_ATTACHED,
    MCS_NO_SUCH_USER,
    MCS_NO_SUCH_CONNECTION,
    MCS_NO_SUCH_CHANNEL,
    MCS_DOMAIN_NOT_HIERARCHICAL,
    MCS_ALLOCATION_FAILURE,
    MCS_INVALID_PARAMETER,
    MCS_CALLBACK_NOT_PROCESSED,
    MCS_TOO_MANY_USERS,
    MCS_TOO_MANY_CHANNELS,
    MCS_CANT_JOIN_OTHER_USER_CHANNEL,
    MCS_USER_NOT_JOINED,
    MCS_SEND_SIZE_TOO_LARGE,
    MCS_SEND_SIZE_TOO_SMALL,
    MCS_NETWORK_ERROR,
    MCS_DUPLICATE_CHANNEL
} MCSError;
typedef MCSError *PMCSError;



/*
 * MCS types
 *
 * DomainHandle: Identifies a unique domain.
 *
 * ConnectionHandle: Identifies a distinct connection between two nodes in
 *     an MCS domain.
 *
 * UserHandle: Identifies a unique local user attachment.
 *
 * ChannelHandle: Identifies a unique channel that has been joined locally.
 *     Different from a ChannelID -- a ChannelID corresponds to a T.125
 *     ChannelID whereas a ChannelHandle is a local handle only.
 *
 * ChannelID: Identifies an MCS channel.  There are four different
 *     types of channels that are part of this type: user ID, static, private,
 *     and assigned.
 *
 * UserID: This is a special channel that identifies a particular user in an
 *     MCS domain.  Only that user can join the channel, so this is referred
 *     to as a single-cast channel.  All other channels are multi-cast,
 *     meaning that any number of users can join them at once.
 *
 * TokenID: A token is an MCS object that is used to resolve resource conflicts.
 *     If an application has a particular resource or service that can only
 *     be used by one user at a time, that user can request exclusive
 *     ownership of a token.
 *
 * DomainParameters: The set of negotiated characteristics of an MCS domain.
 *     These are negotiated by the first two nodes in a domain, after which
 *     they are set for all members.
 *
 * MCSPriority: Identifiers for the four data send priorities allowed in MCS.
 *
 * Segmentation: Flag field for use during data sends, specifies how the data
 *     are broken up between sends. SEGMENTATION_BEGIN implies that this is the
 *     first block in a sequence; SEGMETNATION_END means this is the last block.
 *     A singleton block would specify both flags.
 *
 * TokenStatus: States of a token. Corresponds to the TokenStatus enumeration
 *     values defined in T.125.
 *
 * MCSReason, MCSResult: Correspond to the values defined for the Reason and
 *     Result enumerations defined in the T.125 spec.
 */

typedef HANDLE DomainHandle;
typedef DomainHandle *PDomainHandle;
typedef HANDLE ConnectionHandle;
typedef ConnectionHandle *PConnectionHandle;
typedef HANDLE UserHandle;
typedef UserHandle *PUserHandle;
typedef HANDLE ChannelHandle;
typedef ChannelHandle *PChannelHandle;

typedef unsigned char *DomainSelector;

typedef unsigned ChannelID;
typedef ChannelID *PChannelID;

typedef ChannelID UserID;
typedef UserID *PUserID;

typedef ChannelID TokenID;
typedef TokenID *PTokenID;

typedef struct
{
    unsigned MaxChannels;
    unsigned MaxUsers;
    unsigned MaxTokens;
    unsigned NumPriorities;
    unsigned MinThroughput;
    unsigned MaxDomainHeight;
    unsigned MaxPDUSize;
    unsigned ProtocolVersion;
} DomainParameters, *PDomainParameters;

typedef enum
{
    MCS_TOP_PRIORITY    = 0,
    MCS_HIGH_PRIORITY   = 1,
    MCS_MEDIUM_PRIORITY = 2,
    MCS_LOW_PRIORITY    = 3
} MCSPriority;
typedef MCSPriority *PMCSPriority;

// Segmentation type and flags. The flag values correspond to bit locations
//   in PER-encoded PDUs for faster PDU creation.
typedef unsigned Segmentation;
typedef Segmentation *PSegmentation;
#define SEGMENTATION_BEGIN 0x20
#define SEGMENTATION_END   0x10

// Not used in this implementation, this comes from the NetMeeting user-mode
//   MCS implementation.
#if 0
// SegmentationFlag: Alternate specification of segmentation type that defines
//   how the buffers that are given to SendDataRequest() are divided in packets.
typedef enum {
    SEGMENTATION_ONE_PACKET,       // All the buffers make up one packet
    SEGMENTATION_MANY_PACKETS,     // Each buffer makes up one packet
    SEGMENTATION_PACKET_START,     // The first buffers of one packet
    SEGMENTATION_PACKET_CONTINUE,  // Middle buffers of a packet that was started earlier
    SEGMENTATION_PACKET_END        // The ending buffers of a packet which started earlier
} SegmentationFlag, *PSegmentationFlag;
#endif

typedef enum
{
    TOKEN_NOT_IN_USE      = 0,
    TOKEN_SELF_GRABBED    = 1,
    TOKEN_OTHER_GRABBED   = 2,
    TOKEN_SELF_INHIBITED  = 3,
    TOKEN_OTHER_INHIBITED = 4,
    TOKEN_SELF_RECIPIENT  = 5,
    TOKEN_SELF_GIVING     = 6,
    TOKEN_OTHER_GIVING    = 7
} TokenStatus;
typedef TokenStatus *PTokenStatus;

typedef enum
{
    REASON_DOMAIN_DISCONNECTED = 0,
    REASON_PROVIDER_INITIATED  = 1,
    REASON_TOKEN_PURGED        = 2,
    REASON_USER_REQUESTED      = 3,
    REASON_CHANNEL_PURGED      = 4
} MCSReason, *PMCSReason;

typedef enum
{
    RESULT_SUCCESSFUL              = 0,
    RESULT_DOMAIN_MERGING          = 1,
    RESULT_DOMAIN_NOT_HIERARCHICAL = 2,
    RESULT_NO_SUCH_CHANNEL         = 3,
    RESULT_NO_SUCH_DOMAIN          = 4,
    RESULT_NO_SUCH_USER            = 5,
    RESULT_NOT_ADMITTED            = 6,
    RESULT_OTHER_USER_ID           = 7,
    RESULT_PARAMETERS_UNACCEPTABLE = 8,
    RESULT_TOKEN_NOT_AVAILABLE     = 9,
    RESULT_TOKEN_NOT_POSSESSED     = 10,
    RESULT_TOO_MANY_CHANNELS       = 11,
    RESULT_TOO_MANY_TOKENS         = 12,
    RESULT_TOO_MANY_USERS          = 13,
    RESULT_UNSPECIFIED_FAILURE     = 14,
    RESULT_USER_REJECTED           = 15
} MCSResult, *PMCSResult;

// The following defines the DataRequestType type that defines whether a
//   SendDataRequest is a normal send or a uniform send.
typedef enum {
    NORMAL_SEND_DATA,
    UNIFORM_SEND_DATA,
} DataRequestType, *PDataRequestType;



/*
 * MCS callback definitions. The Params value is dependent on Message value
 *   being received, and should be cast to the right type before use.
 */

// MCS node controller callback.
typedef void (__stdcall *MCSNodeControllerCallback) (DomainHandle hDomain,
        unsigned Message, void *Params, void *UserDefined);

// MCS user callback.
typedef void (__stdcall *MCSUserCallback) (UserHandle hUser, unsigned Message,
        void *Params, void *UserDefined);

// MCS send-data indication callback.
typedef BOOLEAN (__fastcall *MCSSendDataCallback) (BYTE *pData, unsigned DataLength,
        void *UserDefined, UserHandle hUser, BOOLEAN bUniform,
        ChannelHandle hChannel, MCSPriority Priority, UserID SenderID,
        Segmentation Segmentation);



// Callback parameter types. Pointers to these structs are passed to the
//   callback in the Params value of the callback.

typedef struct
{
    ConnectionHandle hConnection;
    BOOLEAN          bUpwardConnection;
    DomainParameters DomainParams;
    BYTE             *pUserData;
    unsigned         UserDataLength;
} ConnectProviderIndication, *PConnectProviderIndication;

typedef struct
{
    DomainHandle     hDomain;
    ConnectionHandle hConnection;
    DomainParameters DomainParams;
    MCSResult        Result;
    BYTE             *pUserData;
    unsigned         UserDataLength;
} ConnectProviderConfirm, *PConnectProviderConfirm;

typedef struct
{
    DomainHandle     hDomain;
    ConnectionHandle hConnection;
    MCSReason        Reason;
} DisconnectProviderIndication, *PDisconnectProviderIndication;

typedef struct
{
    UserID    UserID;
    BOOLEAN   bSelf;
    MCSReason Reason;
} DetachUserIndication, *PDetachUserIndication;

typedef struct
{
    ChannelHandle hChannel;
    MCSError      ErrResult;
} ChannelJoinConfirm, *PChannelJoinConfirm;



/*
 * Callback values.
 */

#define MCS_CONNECT_PROVIDER_INDICATION     0
#define MCS_CONNECT_PROVIDER_CONFIRM        1
#define MCS_DISCONNECT_PROVIDER_INDICATION  2
#define MCS_ATTACH_USER_CONFIRM             3
#define MCS_DETACH_USER_INDICATION          4
#define MCS_CHANNEL_JOIN_CONFIRM            5
#define MCS_CHANNEL_CONVENE_CONFIRM         6
#define MCS_CHANNEL_DISBAND_INDICATION      7
#define MCS_CHANNEL_ADMIT_INDICATION        8
#define MCS_CHANNEL_EXPEL_INDICATION        9
#define MCS_SEND_DATA_INDICATION            10
#define MCS_UNIFORM_SEND_DATA_INDICATION    11
#define MCS_TOKEN_GRAB_CONFIRM              12
#define MCS_TOKEN_INHIBIT_CONFIRM           13
#define MCS_TOKEN_GIVE_INDICATION           14
#define MCS_TOKEN_GIVE_CONFIRM              15
#define MCS_TOKEN_PLEASE_INDICATION         16
#define MCS_TOKEN_RELEASE_CONFIRM           17
#define MCS_TOKEN_TEST_CONFIRM              18
#define MCS_TOKEN_RELEASE_INDICATION        19



/*
 * API function prototypes common to user and kernel mode implementations.
 */

#ifdef __cplusplus
extern "C" {
#endif



#ifndef APIENTRY
#define APIENTRY __stdcall
#endif



MCSError APIENTRY MCSAttachUserRequest(
        DomainHandle        hDomain,
        MCSUserCallback     UserCallback,
        MCSSendDataCallback SDCallback,
        void                *UserDefined,
        UserHandle          *phUser,
        unsigned            *pMaxSendSize,
        BOOLEAN             *pbCompleted);

UserID APIENTRY MCSGetUserIDFromHandle(UserHandle hUser);

MCSError APIENTRY MCSDetachUserRequest(
        UserHandle hUser);

MCSError APIENTRY MCSChannelJoinRequest(
        UserHandle    hUser,
        ChannelID     ChannelID,
        ChannelHandle *phChannel,
        BOOLEAN       *pbCompleted);

ChannelID APIENTRY MCSGetChannelIDFromHandle(ChannelHandle hChannel);

MCSError APIENTRY MCSChannelLeaveRequest(
        UserHandle    hUser,
        ChannelHandle hChannel);



#ifdef __cplusplus
}
#endif



#endif  // !defined(__MCSCOMMN_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\mcsioctl.h ===
/* (C) 1997 Microsoft Corp.
 *
 * file   : MCSIOCTL.h
 * author : Erik Mavrinac
 *
 * description: Definitions for the interface between MCSMUX and PDMCS.
 */

#ifndef __MCSIOCTL_H
#define __MCSIOCTL_H


/*
 * Defines
 */

// From uportmsg.h in NetMeeting project (defined there as
//   MAXIMUM_DOMAIN_SELECTOR).
#define MaxDomainSelectorLength 32

// Max allowable GCC data for connect-initial and connect-response PDUs.
// Used to reduce memory allocations for handling these PDUs -- if too large
//   we will send a bad response PDU and/or disconnect.
#define MaxGCCConnectDataLength 1024



/*
 * T.120 IOCTLs.
 */

#define IOCTL_T120_BASE (0x500)

// Used by MCSMUX to signal on a stack IOCTL that the included data is an MCS
//   request/response. An MCSXxxYyyIoctl struct is expected as the
//   pSdIoctl->InputBuffer; the Header.Type value in the struct will be used
//   to determine the type of the request.
#define IOCTL_T120_REQUEST _ICA_CTL_CODE (IOCTL_T120_BASE, METHOD_NEITHER)



/*
 * Used as the header of all data passed via IOCTL_T120_REQUEST or channel
 *   input.
 */

typedef struct {
    UserHandle hUser;  // PDMCS-supplied handle (NULL for node controller).
    int Type;  // MCS request/indication type.
} IoctlHeader;



/*
 * Connect provider (node controller only). These are special in that they
 *   only come from user mode and so the assoicated user data (if any)
 *   will always be packed at the end of the struct by MCSMUX.
 */

// Passed in by node controller. Confirm is defined next.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_REQUEST.
    unsigned char    CallingDomain[MaxDomainSelectorLength];
    unsigned         CallingDomainLength;
    unsigned char    CalledDomain[MaxDomainSelectorLength];
    unsigned         CalledDomainLength;
    BOOLEAN          bUpwardConnection;
    DomainParameters DomainParams;
    unsigned         UserDataLength;
    BYTE             UserData[MaxGCCConnectDataLength];
    
} ConnectProviderRequestIoctl;

typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_CONFIRM.
    ConnectionHandle hConn;
    DomainParameters DomainParams;
    MCSResult        Result;
} ConnectProviderConfirmIoctl;

// Asynchronous indication triggered when another node connects.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_INDICATION.
    ConnectionHandle hConn;
    BOOLEAN          bUpwardConnection;
    DomainParameters DomainParams;
    unsigned         UserDataLength;
    BYTE             UserData[MaxGCCConnectDataLength];
} ConnectProviderIndicationIoctl;

// Reply to connect-provider indication.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_CONNECT_PROVIDER_RESPONSE.
    ConnectionHandle hConn;
    MCSResult        Result;
    unsigned         UserDataLength;
    BYTE *           pUserData;
} ConnectProviderResponseIoctl;



/*
 * Disconnect provider (node controller only).
 */

// Passed in by node controller. There is no confirm.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_DISCONNECT_PROVIDER_REQUEST/INDICATION.
    ConnectionHandle hConn;
    MCSReason        Reason;
} DisconnectProviderRequestIoctl;

// Asynchronous indication.
typedef struct
{
    IoctlHeader      Header;  // Contains MCS_DISCONNECT_PROVIDER_REQUEST/INDICATION.
    ConnectionHandle hConn;
    MCSReason        Reason;
} DisconnectProviderIndicationIoctl;


/*
 * Attach user
 */

// Chosen domain is implicit since each PDMCS instance is a domain.
// Header.hUser is filled in during call to contain the user handle.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_ATTACH_USER_REQUEST.
    void        *UserDefined;
} AttachUserRequestIoctl;

typedef struct {
    UserHandle hUser;
    UserID     UserID;  // Valid only if bCompleted is TRUE.
    unsigned   MaxSendSize;
    MCSError   MCSErr;
    BOOLEAN    bCompleted;
} AttachUserReturnIoctl;

// Used only in the case where an attach-user request was sent across the net
//   to the top provider. Hydra 4.0 is always top provider so this is not used.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_ATTACH_USER_CONFIRM.
    UserHandle  hUser;
    void        *UserDefined;  // As passed into attach-user request.
    MCSResult   Result;
} AttachUserConfirmIoctl;



/*
 * Detach user
 */

// Passed in by application. This is synchronous -- no confirm is issued.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_DETACH_USER_REQUEST and the hUser.
} DetachUserRequestIoctl;

// Asynchronous indication triggered when another user detaches.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_DETACH_USER_INDICATION.
    void        *UserDefined;  // As passed into attach-user request.
    DetachUserIndication DUin;
} DetachUserIndicationIoctl;



/*
 * Channel join
 */

// Passed in by application. Confirm is defined next.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_CHANNEL_JOIN_REQUEST.
    ChannelID   ChannelID;
} ChannelJoinRequestIoctl;

typedef struct
{
    ChannelHandle hChannel;
    ChannelID     ChannelID;  // Valid only if bCompleted is TRUE.
    MCSError      MCSErr;
    BOOLEAN       bCompleted;
} ChannelJoinReturnIoctl;

// Used in the case where a channel-join request is sent across the net to
//   the top provider. Should not be used in Hydra 4.0 -- we are always TP.
typedef struct
{
    IoctlHeader Header;  // Contains MCS_CHANNEL_JOIN_CONFIRM.
    void        *UserDefined;  // As passed into attach-user request.
    MCSResult   Result;
    ChannelID   ChannelID;
} ChannelJoinConfirmIoctl;



/*
 * Channel leave
 */

// Passed in by application. This is synchronous -- no confirm is issued.
typedef struct
{
    IoctlHeader   Header;  // Contains MCS_CHANNEL_LEAVE_REQUEST.
    ChannelHandle hChannel;
} ChannelLeaveRequestIoctl;



/*
 * (Uniform) send data
 */

// Asynchronous indication triggered when data arrives. Used by both
//   send-data and uniform-send-data indications.
// Data is packed right after this struct.

typedef struct
{
    IoctlHeader   Header;  // Contains (UNIFORM)SEND_DATA_INDICATION.
    void          *UserDefined;  // As passed into attach-user request.
    ChannelHandle hChannel;
    UserID        SenderID;
    MCSPriority   Priority;
    Segmentation  Segmentation;
    unsigned      DataLength;
} SendDataIndicationIoctl;

// Passed in by application. This is synchronous -- no confirm is issued.
// This struct is used both for send-data and uniform-send-data requests.
typedef struct
{
    IoctlHeader     Header;  // Contains (UNIFORM_)MCS_SEND_DATA_REQUEST.
    DataRequestType RequestType;  // Redundant but useful info.
    ChannelHandle   hChannel;  // Kernel-mode hChannel.
    ChannelID       ChannelID;  // If hChn==NULL, unjoined chn to send to.
    MCSPriority     Priority;
    Segmentation    Segmentation;
    unsigned        DataLength;
} SendDataRequestIoctl;



/*
 * Request and response types for use in differentiating requests.
 */

// User attachment requests.
// These values must be contiguously numbered, since a dispatch table is used
//   to quickly call handler functions.
#define MCS_ATTACH_USER_REQUEST       0
#define MCS_DETACH_USER_REQUEST       1
#define MCS_CHANNEL_JOIN_REQUEST      2
#define MCS_CHANNEL_LEAVE_REQUEST     3
#define MCS_SEND_DATA_REQUEST         4
#define MCS_UNIFORM_SEND_DATA_REQUEST 5
#define MCS_CHANNEL_CONVENE_REQUEST   6
#define MCS_CHANNEL_DISBAND_REQUEST   7
#define MCS_CHANNEL_ADMIT_REQUEST     8
#define MCS_CHANNEL_EXPEL_REQUEST     9
#define MCS_TOKEN_GRAB_REQUEST        10
#define MCS_TOKEN_INHIBIT_REQUEST     11
#define MCS_TOKEN_GIVE_REQUEST        12
#define MCS_TOKEN_GIVE_RESPONSE       13
#define MCS_TOKEN_PLEASE_REQUEST      14
#define MCS_TOKEN_RELEASE_REQUEST     15
#define MCS_TOKEN_TEST_REQUEST        16

// NC-only requests.
#define MCS_CONNECT_PROVIDER_REQUEST    17
#define MCS_CONNECT_PROVIDER_RESPONSE   18
#define MCS_DISCONNECT_PROVIDER_REQUEST 19

// Startup synchonization trigger. This message is sent when the rest of the
//   system is ready for MCS to start processing inputs.
#define MCS_T120_START 20



/*
 * ICA virtual channel definitions for the T.120 input channel.
 */

#define Virtual_T120 "MS_T120"
#define Virtual_T120ChannelNum 31



#endif  // !defined(__MCSIOCTL_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\dtrcctl.h ===
/****************************************************************************/
/* NTRCCTL.H                                                                */
/*                                                                          */
/* Trace include function control file                                      */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/dtrcctl.h_v  $                                                                   */
// 
//    Rev 1.1   19 Jun 1997 15:21:46   ENH
// Win16Port: 16 bit specifics
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Win16 always includes all functions.                                     */
/****************************************************************************/
#define INC_TRC_ResetTraceFiles
#define INC_TRCOutput
#define INC_TRCReadFlag
#define INC_TRCSetDefaults
#define INC_TRCReadSharedDataConfig
#define INC_TRCWriteFlag
#define INC_TRCWriteSharedDataConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\license.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       license.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-03-97   FredCh   Created
//              12-16-97   v-sbhatt  Modified
//              12-22-97   HueiWang Add Extension OID
//              12-23-97   HueiWang Use structure instead of multiple OID
//
//----------------------------------------------------------------------------

#ifndef _LICENSE_H_
#define _LICENSE_H_

#include "platform.h"

#if defined(_WIN64)
#define UNALIGNED __unaligned
#define UNALIGNED64 __unaligned
#elif !defined (OS_WINCE)
#define UNALIGNED
#define UNALIGNED64
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Random number length
//

#define     LICENSE_RANDOM              32
#define     LICENSE_PRE_MASTER_SECRET   48
#define     LICENSE_MAC_WRITE_KEY       16
#define     LICENSE_SESSION_KEY         16
#define     LICENSE_MAC_DATA            16
#define     LICENSE_HWID_LENGTH         20


//////////////////////////////////////////////////////////////////////////////
// Licensing protocol versions
//
#ifndef OS_WIN16
#ifndef OS_WINCE
#define CALL_TYPE   _stdcall
#else
#define CALL_TYPE
#endif
#else
#define CALL_TYPE
#endif  //CALL_TYPE


//-----------------------------------------------------------------------------
//
// Licensing protocol version
//
// The lowest byte of the version DWORD will be the preamble version.
//
//-----------------------------------------------------------------------------

#define LICENSE_PROTOCOL_VERSION_1_0    0x00010000
#define LICENSE_PROTOCOL_VERSION_2_0    0x00020000

//
//  INT CompareTLSVersions(VERSION a, VERSION b);
//

#define CompareTLSVersions(a, b) \
    (HIWORD(a) == HIWORD(b) ? LOWORD(a) - LOWORD(b) : \
     HIWORD(a) - HIWORD(b))


#define PREAMBLE_VERSION_1_0            0x01
#define PREAMBLE_VERSION_2_0            0x02
#define PREAMBLE_VERSION_3_0            0x03

#define LICENSE_CURRENT_PREAMBLE_VERSION    PREAMBLE_VERSION_3_0

#define LICENSE_TS_40_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_1_0 | PREAMBLE_VERSION_2_0
#define LICENSE_TS_50_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_1_0 | PREAMBLE_VERSION_3_0
#define LICENSE_TS_51_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_2_0 | PREAMBLE_VERSION_3_0

#define LICENSE_HYDRA_40_PROTOCOL_VERSION LICENSE_TS_40_PROTOCOL_VERSION

#if 1
#define LICENSE_HIGHEST_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_1_0 | LICENSE_CURRENT_PREAMBLE_VERSION
#else
#define LICENSE_HIGHEST_PROTOCOL_VERSION LICENSE_PROTOCOL_VERSION_2_0 | LICENSE_CURRENT_PREAMBLE_VERSION
#endif

#define GET_PREAMBLE_VERSION( _Version ) ( BYTE )( _Version & 0x000000FF )

//-----------------------------------------------------------------------------
//
// Context flags used by the client and server licensing protocol APIs:
//
// LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION
//
//      Do not authenticate the server.  Server authentication is done through
//      validating the server's certificate.
//
// LICENSE_CONTEXT_USE_PROPRIETORY_CERT
//
//      Use in conjunction with the LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION 
//      flag to let that server know that a proprietory certificate has
//      been transmitted to the client.
//
// LICENSE_CONTEXT_USE_X509_CERT
//
//      Use in conjunction with the LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION 
//      flag to let that server know that an X509 certificate has
//      been transmitted to the client.
//
//-----------------------------------------------------------------------------

#define LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION    0x00000001
#define LICENSE_CONTEXT_USE_PROPRIETORY_CERT        0x00000002
#define LICENSE_CONTEXT_USE_X509_CERT               0x00000004


//////////////////////////////////////////////////////////////////////////////
//
// Hydra subtree Specific OID
//
#define szOID_PKIX_HYDRA_CERT_ROOT    "1.3.6.1.4.1.311.18"


/////////////////////////////////////////////////////////////////////////////
//
// License Info root at 1.3.6.1.4.1.311.18.1
//
// Reserved
//
#define szOID_PKIX_LICENSE_INFO         "1.3.6.1.4.1.311.18.1"

//
// structure for License Info
//

typedef struct __LicenseInfo {

    DWORD   dwVersion;
    DWORD   dwQuantity;
    WORD    wSerialNumberOffset;
    WORD    wSerialNumberSize;
    WORD    wScopeOffset;
    WORD    wScopeSize;
    WORD    wIssuerOffset;
    WORD    wIssuerSize;
    BYTE    bVariableDataStart[1];

} CERT_LICENSE_INFO;

#ifdef OS_WIN16
typedef CERT_LICENSE_INFO FAR * LPCERT_LICENSE_INFO;
#else
typedef CERT_LICENSE_INFO *LPCERT_LICENSE_INFO;
#endif  //OS_WIN16

/////////////////////////////////////////////////////////////////////////////
// Manufacturer value 1.3.6.1.4.1.311.18.2
// DWORD for manufacturer data
//
#define szOID_PKIX_MANUFACTURER         "1.3.6.1.4.1.311.18.2"

/////////////////////////////////////////////////////////////////////////////
//
// Manufacturer Specfic Data
//
// Reserved
// 
#define szOID_PKIX_MANUFACTURER_MS_SPECIFIC "1.3.6.1.4.1.311.18.3"

// structure for MS manufacturer specific data
typedef struct __MSManufacturerData {
    DWORD   dwVersion;      // bit 31 - 1 Temp. License.
    DWORD   dwPlatformID;
    DWORD   dwLanguageID;
    WORD    dwMajorVersion;
    WORD    dwMinorVersion;
    WORD    wProductIDOffset;
    WORD    wProductIDSize;
    BYTE    bVariableDataStart[1];
} MSMANUFACTURER_DATA;

////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
//
// OID for Certificate Version Stamp
//
// Reserved.
//
#define szOID_PKIX_HYDRA_CERT_VERSION       szOID_PKIX_HYDRA_CERT_ROOT ".4"

#define TERMSERV_CERT_VERSION_UNKNOWN  0xFFFFFFFF
#define TERMSERV_CERT_VERSION_BETA     0x00000000   // Beta2 license
#define TERMSERV_CERT_VERSION_NO_CERT  0x00010000   // New License without
                                                    // license server's
                                                    // certificate
#define TERMSERV_CERT_VERSION_RC1      0x00010001   // New license with
                                                    // license server's
                                                    // certificate

//
// We don't support this certificate format.
//
//#define HYDRA_CERT_VERSION_CURRENT  0x00020001  // License issued by 
//                                                // enforce version of
//                                                // license server

#define TERMSERV_CERT_VERSION_MAJOR(x)  HIWORD(x)
#define TERMSERV_CERT_VERSION_MINOR(x)  LOWORD(x)
#define TERMSERV_CERT_VERSION_CURRENT   0x00050001  

//-------------------------------------------------------------------------
//
// OID for License Server to identify licensed product.
//
#define szOID_PKIX_LICENSED_PRODUCT_INFO szOID_PKIX_HYDRA_CERT_ROOT ".5"

//
// dwFlags in LICENSED_VERSION_INFO
//
// Bit 31 - 1 if temporary license, 0 if perm. license
// Bit 24 to 30 - Any flag specific to temporary license, currently, there is none.
// Bit 23 - 1 if RTM License, 0 if beta license.
// Bit 16 to 22 - License server version.
// Bit 20 to 22 - Major version.
// Bit 16 to 19 - Minor version.
// Bit 15 - Enforce license server.
// Bit 0 to 3 is reserved by license server for internal use.
// Other bits are not use.
//
#define LICENSED_VERSION_TEMPORARY  0x80000000
#define LICENSED_VERSION_RTM        0x00800000
#define LICENSE_ISSUER_ENFORCE_TYPE 0x00008000

#define GET_LICENSE_ISSUER_VERSION(dwVersion) \
    (((dwVersion) & 0x007F0000) >> 16)    

#define GET_LICENSE_ISSUER_MAJORVERSION(dwVersion) \
    (((dwVersion) & 0x00700000) >> 20)

#define GET_LICENSE_ISSUER_MINORVERSION(dwVersion) \
    (((dwVersion) & 0x000F0000) >> 16)

#define IS_LICENSE_ISSUER_ENFORCE(dwVersion) \
    (((dwVersion) & LICENSE_ISSUER_ENFORCE_TYPE) > 0)

#define IS_LICENSE_ISSUER_RTM(dwVersion) \
    (((dwVersion) & LICENSED_VERSION_RTM) > 0)


typedef struct _LicensedVersionInfo {
    WORD    wMajorVersion;          // Product Major Version
    WORD    wMinorVersion;          // Product Minor Version
    DWORD   dwFlags;                // Product version specific flags
} LICENSED_VERSION_INFO;

#define LICENSED_PRODUCT_INFO_VERSION       0x0003000

typedef struct _LicensedProductInfo {
    DWORD   dwVersion;              // structure version identifier
    DWORD   dwQuantity;             // number of licenses
    DWORD   dwPlatformID;           // Client platform ID
    DWORD   dwLanguageID;           // Licensed Language ID

    WORD    wOrgProductIDOffset;    // Offset to original licensed Product ID
    WORD    wOrgProductIDSize;      // Size of original licensed product ID

    WORD    wAdjustedProductIdOffset;   // Policy modified licensed product Id
    WORD    wAdjustedProductIdSize;     // size of Policy modified licensed Id.

    WORD    wVersionInfoOffset;     // Offset to array of LicensedVersionInfo
    WORD    wNumberOfVersionInfo;   // Number of VersionInfo entries
    BYTE    bVariableDataStart[1];  // Variable data start.
} LICENSED_PRODUCT_INFO;

//
// OID for License Server specific info.
//
#define szOID_PKIX_MS_LICENSE_SERVER_INFO   szOID_PKIX_HYDRA_CERT_ROOT ".6"
#define MS_LICENSE_SERVER_INFO_VERSION1     0x0001000
#define MS_LICENSE_SERVER_INFO_VERSION2     0x0003000

//
// Version 1 structure
//
typedef struct _MsLicenseServerInfo10 {
    DWORD   dwVersion;
    WORD    wIssuerOffset;          // Offset to issuer
    WORD    wScopeOffset;           // Offset to scope
    BYTE    bVariableDataStart[1];
} MS_LICENSE_SERVER_INFO10;

typedef struct _MsLicenseServerInfo {
    DWORD   dwVersion;
    WORD    wIssuerOffset;          // Offset to issuer
    WORD    wIssuerIdOffset;        // offset to issuer's setup ID
    WORD    wScopeOffset;           // Offset to scope
    BYTE    bVariableDataStart[1];
} MS_LICENSE_SERVER_INFO;


//---------------------------------------------------------------------------
//
// Extension OID reserved for product policy module - only one is allowed.
//
#define szOID_PKIS_PRODUCT_SPECIFIC_OID     szOID_PKIX_HYDRA_CERT_ROOT ".7"

//
//
//
#define szOID_PKIS_TLSERVER_SPK_OID         szOID_PKIX_HYDRA_CERT_ROOT ".8"

//
// Save certificate chain into memory
// This flag is passed into CertSaveStore() dwSaveAs parameter
// Open should use same to open the store.

#define szLICENSE_BLOB_SAVEAS_TYPE   sz_CERT_STORE_PROV_PKCS7
#define LICENSE_BLOB_SAVEAS_TYPE    CERT_STORE_SAVE_AS_PKCS7

#define OID_ISSUER_LICENSE_SERVER_NAME  szOID_COMMON_NAME
#define OID_ISSUER_LICENSE_SERVER_SCOPE szOID_LOCALITY_NAME
 
#define OID_SUBJECT_CLIENT_COMPUTERNAME szOID_COMMON_NAME
#define OID_SUBJECT_CLIENT_USERNAME     szOID_LOCALITY_NAME
#define OID_SUBJECT_CLIENT_HWID         szOID_DEVICE_SERIAL_NUMBER


#ifdef OS_WIN16
typedef MSMANUFACTURER_DATA FAR *LPMSMANUFACTURER_DATA;
#else
typedef MSMANUFACTURER_DATA *LPMSMANUFACTURER_DATA;
#endif //OS_WIN16

///////////////////////////////////////////////////////////////////////////////
// 
#define LICENSE_GRACE_PERIOD    60


///////////////////////////////////////////////////////////////////////////////
// Product Info for Hydra
//

#define PRODUCT_INFO_COMPANY_NAME   L"Microsoft Corporation"


///////////////////////////////////////////////////////////////////////////////
// The Product SKU is made up of the following fields:
// x-y-z where x is the product identifer, y is the version
// and z and the type.
//

#define PRODUCT_INFO_SKU_PRODUCT_ID                 L"A02"
#define PRODUCT_INFO_INTERNET_SKU_PRODUCT_ID        L"B96"
#define PRODUCT_INFO_CONCURRENT_SKU_PRODUCT_ID      L"C50"      // not the same as what marketing uses, but that's okay

///////////////////////////////////////////////////////////////////////////////
//
// Microsoft Windows Terminal Server version definition.
//

#define MICROSOFT_WINDOWS_TERMINAL_SERVER_4_0       0x00040000
#define MICROSOFT_WINDOWS_TERMINAL_SERVER_5_0       0x00050000
#define MICROSOFT_WINDOWS_TERMINAL_SERVER_5_1       0x00050001


#define CURRENT_TERMINAL_SERVER_VERSION             MICROSOFT_WINDOWS_TERMINAL_SERVER_5_1


#define TERMSRV_OS_INDEX_WINNT_5_0                  0x00000000
#define TERMSRV_OS_INDEX_WINNT_5_1                  0x00000001
#define TERMSRV_OS_INDEX_WINNT_POST_5_1	            0x00000002

///////////////////////////////////////////////////////////////////////////////
//
// Scope name
//
#ifndef OS_WINCE //SCOPE_NAME is being defined by iprtrmib.h which is included by iphlpapi.h
#define SCOPE_NAME                  "microsoft.com"
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Maximum product info string length in bytes
//

#define MAX_PRODUCT_INFO_STRING_LENGTH      255


///////////////////////////////////////////////////////////////////////////////
// Different crypt algid definitions
// We are keeping an option open to generatize it in future 
//

///////////////////////////////////////////////////////////////////////////////
//
// Key exchange algorithms
//

#define KEY_EXCHANGE_ALG_RSA    1
#define KEY_EXCHANGE_ALG_DH     2


///////////////////////////////////////////////////////////////////////////////
//
// Certificate Signature Algorithms
//

#define SIGNATURE_ALG_RSA       1
#define SIGNATURE_ALG_DSS       2

///////////////////////////////////////////////////////////////////////////////
//
// Symmetric cryptographic algorithms
//

#define BASIC_RC4_128           1

///////////////////////////////////////////////////////////////////////////////
//
// MAC generation algorithms
//

#define MAC_MD5_SHA             1

///////////////////////////////////////////////////////////////////////////////
//
// hydra client to hydra server message types
//

#define HC_LICENSE_INFO                         0x12
#define HC_NEW_LICENSE_REQUEST                  0x13
#define HC_PLATFORM_INFO                        0x14
#define HC_PLATFORM_CHALENGE_RESPONSE           0x15


///////////////////////////////////////////////////////////////////////////////
//
// hydra server to hydra client message types
//

#define HS_LICENSE_REQUEST                      0x01
#define HS_PLATFORM_CHALLENGE                   0x02
#define HS_NEW_LICENSE                          0x03
#define HS_UPGRADE_LICENSE                      0x04

#define LICENSE_VERSION_1                       0x01


#define GM_ERROR_ALERT                          0xFF


///////////////////////////////////////////////////////////////////////////////
//
// Error and alert codes
//

#define GM_HC_ERR_INVALID_SERVER_CERTIFICATE    0x00000001
#define GM_HC_ERR_NO_LICENSE                    0x00000002
#define GM_HC_ERR_INVALID_MAC                   0x00000003
#define GM_HS_ERR_INVALID_SCOPE                 0x00000004
#define GM_HS_ERR_INVALID_MAC                   0x00000005
#define GM_HS_ERR_NO_LICENSE_SERVER             0x00000006
#define GM_HS_ERR_VALID_CLIENT                  0x00000007
#define GM_HS_ERR_INVALID_CLIENT                0x00000008                  
#define GM_HS_ERR_LICENSE_UPGRADE               0x00000009
#define GM_HS_ERR_EXPIRED_LICENSE               0x0000000A
#define GM_HS_ERR_INVALID_PRODUCTID             0x0000000B
#define GM_HS_ERR_INVALID_MESSAGE_LEN           0x0000000C


///////////////////////////////////////////////////////////////////////////////
//
// License status and status codes
//

typedef DWORD   LICENSE_STATUS;

#define LICENSE_STATUS_OK                                       0x00000000
#define LICENSE_STATUS_OUT_OF_MEMORY                            0x00000001
#define LICENSE_STATUS_INSUFFICIENT_BUFFER                      0x00000002
#define LICENSE_STATUS_INVALID_INPUT                            0x00000003
#define LICENSE_STATUS_INVALID_CLIENT_CONTEXT                   0x00000004
#define LICENSE_STATUS_INITIALIZATION_FAILED                    0x00000005
#define LICENSE_STATUS_INVALID_SIGNATURE                        0x00000006
#define LICENSE_STATUS_INVALID_CRYPT_STATE                      0x00000007
#define LICENSE_STATUS_CONTINUE                                 0x00000008
#define LICENSE_STATUS_ISSUED_LICENSE                           0x00000009
#define LICENSE_STATUS_CLIENT_ABORT                             0x0000000A
#define LICENSE_STATUS_SERVER_ABORT                             0x0000000B
#define LICENSE_STATUS_NO_CERTIFICATE                           0x0000000C
#define LICENSE_STATUS_NO_PRIVATE_KEY                           0x0000000D
#define LICENSE_STATUS_SEND_ERROR                               0x0000000E
#define LICENSE_STATUS_INVALID_RESPONSE                         0x0000000F
#define LICENSE_STATUS_CONTEXT_INITIALIZATION_ERROR             0x00000010
#define LICENSE_STATUS_NO_MESSAGE                               0x00000011
#define LICENSE_STATUS_INVALID_CLIENT_STATE                     0x00000012
#define LICENSE_STATUS_OPEN_STORE_ERROR                         0x00000013
#define LICENSE_STATUS_CLOSE_STORE_ERROR                        0x00000014
#define LICENSE_STATUS_WRITE_STORE_ERROR                        0x00000015
#define LICENSE_STATUS_INVALID_STORE_HANDLE                     0x00000016
#define LICENSE_STATUS_DUPLICATE_LICENSE_ERROR                  0x00000017
#define LICENSE_STATUS_INVALID_MAC_DATA                         0x00000018
#define LICENSE_STATUS_INCOMPLETE_MESSAGE                       0x00000019
#define LICENSE_STATUS_RESTART_NEGOTIATION                      0x0000001A
#define LICENSE_STATUS_NO_LICENSE_SERVER                        0x0000001B
#define LICENSE_STATUS_NO_PLATFORM_CHALLENGE                    0x0000001C
#define LICENSE_STATUS_NO_LICENSE_SERVER_SECRET_KEY             0x0000001D
#define LICENSE_STATUS_INVALID_SERVER_CONTEXT                   0x0000001E
#define LICENSE_STATUS_CANNOT_DECODE_LICENSE                    0x0000001F
#define LICENSE_STATUS_INVALID_LICENSE                          0x00000020
#define LICENSE_STATUS_CANNOT_VERIFY_HWID                       0x00000021
#define LICENSE_STATUS_NO_LICENSE_ERROR                         0x00000022
#define LICENSE_STATUS_EXPIRED_LICENSE                          0x00000023
#define LICENSE_STATUS_MUST_UPGRADE_LICENSE                     0x00000024
#define LICENSE_STATUS_UNSPECIFIED_ERROR                        0x00000025
#define LICENSE_STATUS_INVALID_PLATFORM_CHALLENGE_RESPONSE      0x00000026
#define LICENSE_STATUS_SHOULD_UPGRADE_LICENSE                   0x00000027
#define LICENSE_STATUS_CANNOT_UPGRADE_LICENSE                   0x00000028
#define LICENSE_STATUS_CANNOT_FIND_CLIENT_IMAGE                 0x00000029
#define LICENSE_STATUS_CANNOT_READ_CLIENT_IMAGE                 0x0000002A
#define LICENSE_STATUS_CANNOT_WRITE_CLIENT_IMAGE                0x0000002B
#define LICENSE_STATUS_CANNOT_FIND_ISSUER_CERT                  0x0000002C
#define LICENSE_STATUS_NOT_HYDRA                                0x0000002D
#define LICENSE_STATUS_INVALID_X509_NAME                        0x0000002E
#define LICENSE_STATUS_NOT_SUPPORTED                            0x0000002F
#define LICENSE_STATUS_INVALID_CERTIFICATE                      0x00000030
#define LICENSE_STATUS_NO_ATTRIBUTES                            0x00000031
#define LICENSE_STATUS_NO_EXTENSION                             0x00000032
#define LICENSE_STATUS_ASN_ERROR                                0x00000033
#define LICENSE_STATUS_INVALID_HANDLE                           0x00000034
#define LICENSE_STATUS_CANNOT_MAKE_KEY_PAIR                     0x00000035
#define LICENSE_STATUS_AUTHENTICATION_ERROR                     0x00000036
#define LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR                0x00000037
#define LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE                 0x00000038
#define LICENSE_STATUS_CANNOT_STORE_SECRET                      0x00000039
#define LICENSE_STATUS_CANNOT_RETRIEVE_SECRET                   0x0000003A
#define LICENSE_STATUS_UNSUPPORTED_VERSION                      0x0000003B
#define LICENSE_STATUS_NO_INTERNET_LICENSE_INSTALLED            0x0000003C

///////////////////////////////////////////////////////////////////////////////
// State transitions
//

#define ST_TOTAL_ABORT                          0x00000001
#define ST_NO_TRANSITION                        0x00000002
#define ST_RESET_PHASE_TO_START                 0x00000003
#define ST_RESEND_LAST_MESSAGE                  0x00000004


#define PLATFORM_WINNT_40                           0x00040000
#define PLATFORM_WINCE_20                           0x00020001          

///////////////////////////////////////////////////////////////////////////////
// message exchange supporting structures
//

typedef struct _Product_Info
{
    DWORD   dwVersion;
    DWORD   cbCompanyName;
    PBYTE   pbCompanyName;
    DWORD   cbProductID;
    PBYTE   pbProductID;
} Product_Info;

#ifdef OS_WIN16
typedef Product_Info FAR *PProduct_Info;
#else
typedef Product_Info *PProduct_Info;
#endif //OS_WIN16



typedef struct _Duration
{
    FILETIME        NotBefore;
    FILETIME        NotAfter;

} Duration;

#ifdef OS_WIN16
typedef Duration FAR * PDuration;
#else
typedef Duration *PDuration;
#endif  //OS_WIN16


typedef struct _New_License_Info
{
    DWORD       dwVersion;  //Added -Shubho
    DWORD       cbScope;
    PBYTE       pbScope;
    DWORD       cbCompanyName;
    PBYTE       pbCompanyName;
    DWORD       cbProductID;
    PBYTE       pbProductID;
    DWORD       cbLicenseInfo;
    PBYTE       pbLicenseInfo;

}New_License_Info;

#ifdef OS_WIN16
typedef New_License_Info FAR * PNew_License_Info;
#else
typedef New_License_Info *PNew_License_Info;
#endif  //OS_WIN16


///////////////////////////////////////////////////////////////////////////////
// binary blob format to support expanded message format
//

typedef struct _Binary_Blob
{
    WORD            wBlobType;
    WORD            wBlobLen;
    PBYTE           pBlob;

} Binary_Blob;

#ifdef OS_WIN16
typedef Binary_Blob FAR * PBinary_Blob;
#else
typedef Binary_Blob UNALIGNED* PBinary_Blob;
#endif  //OS_WIN16


///////////////////////////////////////////////////////////////////////////////
// Binary Blob Data Types
//

#define BB_DATA_BLOB                    0x0001
#define BB_RANDOM_BLOB                  0x0002
#define BB_CERTIFICATE_BLOB             0x0003
#define BB_ERROR_BLOB                   0x0004
#define BB_DH_KEY_BLOB                  0x0005
#define BB_RSA_KEY_BLOB                 0x0006
#define BB_DSS_SIGNATURE_BLOB           0x0007
#define BB_RSA_SIGNATURE_BLOB           0x0008
#define BB_ENCRYPTED_DATA_BLOB          0x0009
#define BB_MAC_DATA_BLOB                0x000A
#define BB_INTEGER_BLOB                 0x000B
#define BB_NAME_BLOB                    0x000C
#define BB_KEY_EXCHG_ALG_BLOB           0x000D
#define BB_SCOPE_BLOB                   0x000E
#define BB_CLIENT_USER_NAME_BLOB        0x000F
#define BB_CLIENT_MACHINE_NAME_BLOB     0x0010

//////////////////////////////////////////////////////
// Binary Blob Data Version Numbers
//

#define BB_ERROR_BLOB_VERSION			0x0001

///////////////////////////////////////////////////////////////////////////////
// message exchange structures for licensing protocol
//

typedef struct _Preamble
{
    BYTE    bMsgType;       // Contains the type of message
    BYTE    bVersion;       // Contains the version no. info.
    WORD    wMsgSize;        // Length of the whole message including PREAMBLE

} Preamble;

#ifdef OS_WIN16
typedef Preamble FAR * PPreamble;
#else
typedef Preamble * PPreamble;
#endif  //OS_WIN16


typedef struct  _Scope_List
{
    DWORD           dwScopeCount;
    PBinary_Blob    Scopes;

} Scope_List;

#ifdef OS_WIN16
typedef Scope_List FAR * PScope_List;
#else
typedef Scope_List * PScope_List;
#endif  //OS_WIN16


typedef struct _License_Error_Message
{
    DWORD       dwErrorCode;
    DWORD       dwStateTransition;
    Binary_Blob bbErrorInfo;

} License_Error_Message;

#ifdef OS_WIN16
typedef License_Error_Message FAR * PLicense_Error_Message;
#else
typedef License_Error_Message * PLicense_Error_Message;
#endif  //OS_WIN16


typedef struct _Hydra_Client_License_Info
{
    DWORD           dwPrefKeyExchangeAlg;
    DWORD           dwPlatformID;
    BYTE            ClientRandom[LICENSE_RANDOM];
    Binary_Blob     EncryptedPreMasterSecret;
    Binary_Blob     LicenseInfo;
    Binary_Blob     EncryptedHWID;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Client_License_Info;

#ifdef OS_WIN16
typedef Hydra_Client_License_Info FAR * PHydra_Client_License_Info;
#else
typedef Hydra_Client_License_Info * PHydra_Client_License_Info;
#endif  //OS_WIN16


typedef struct _Hydra_Client_New_License_Request
{
    DWORD           dwPrefKeyExchangeAlg;
    DWORD           dwPlatformID;
    BYTE            ClientRandom[LICENSE_RANDOM];
    Binary_Blob     EncryptedPreMasterSecret;
    Binary_Blob     ClientUserName;
    Binary_Blob     ClientMachineName;

} Hydra_Client_New_License_Request;

#ifdef OS_WIN16
typedef Hydra_Client_New_License_Request FAR * PHydra_Client_New_License_Request;
#else
typedef Hydra_Client_New_License_Request * PHydra_Client_New_License_Request;
#endif  //OS_WIN16


//
// High Byte - Major version, Low Byte - Minor version
// 
#define PLATFORMCHALLENGE_VERSION           0x0100

#define CURRENT_PLATFORMCHALLENGE_VERSION   PLATFORMCHALLENGE_VERSION

//
// Client Platform Challenge Type
//
#define WIN32_PLATFORMCHALLENGE_TYPE    0x0100
#define WIN16_PLATFORMCHALLENGE_TYPE    0x0200
#define WINCE_PLATFORMCHALLENGE_TYPE    0x0300
#define OTHER_PLATFORMCHALLENGE_TYPE    0xFF00


//
// Client License Detail level - 
//
//  This should be in LicenseRequest but
//  1) Require changes to RPC interface.
//  2) Nothing in structure for us to identify version.
//  3) Current licensing protocol, no way to tell actual client type
//

//
// client license + license server's self signed
//
#define LICENSE_DETAIL_SIMPLE           0x0001  

//
// license chain up to issuer of license server's certificate
//
#define LICENSE_DETAIL_MODERATE         0x0002  

// 
// Detail client license chain up to root.
//
#define LICENSE_DETAIL_DETAIL           0x0003

typedef struct __PlatformChallengeResponseData
{
    WORD  wVersion;         // structure version
    WORD  wClientType;      // client type
    WORD  wLicenseDetailLevel;  // license detail, TS will re-modify this value    
    WORD  cbChallenge;      // size of client challenge response data
    BYTE  pbChallenge[1];   // start of variable length data
} PlatformChallengeResponseData;

#ifdef OS_WIN16
typedef PlatformChallengeResponseData FAR * PPlatformChallengeResponseData;
#else
typedef PlatformChallengeResponseData * PPlatformChallengeResponseData;
#endif  //OS_WIN16

#define PLATFORM_CHALLENGE_LENGTH       64

typedef struct _Hydra_Client_Platform_Challenge_Response
{
    Binary_Blob     EncryptedChallengeResponse;
    Binary_Blob     EncryptedHWID;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Client_Platform_Challenge_Response;

#ifdef OS_WIN16
typedef Hydra_Client_Platform_Challenge_Response FAR * PHydra_Client_Platform_Challenge_Response;
#else
typedef Hydra_Client_Platform_Challenge_Response * PHydra_Client_Platform_Challenge_Response;
#endif  //OS_WIN16


typedef struct _Hydra_Server_License_Request
{
    BYTE                    ServerRandom[LICENSE_RANDOM];
    Product_Info            ProductInfo;
    Binary_Blob             KeyExchngList;
    Binary_Blob             ServerCert;
    Scope_List              ScopeList;

} Hydra_Server_License_Request;

#ifdef OS_WIN16
typedef Hydra_Server_License_Request FAR * PHydra_Server_License_Request;
#else
typedef Hydra_Server_License_Request * PHydra_Server_License_Request;
#endif  //OS_WIN16


typedef struct _Hydra_Server_Platform_Challenge
{
    DWORD           dwConnectFlags;
    Binary_Blob     EncryptedPlatformChallenge;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Server_Platform_Challenge;

#ifdef OS_WIN16
typedef Hydra_Server_Platform_Challenge FAR * PHydra_Server_Platform_Challenge;
#else
typedef Hydra_Server_Platform_Challenge * PHydra_Server_Platform_Challenge;
#endif  //OS_WIN16


typedef struct _Hydra_Server_New_License
{
    Binary_Blob     EncryptedNewLicenseInfo;
    BYTE            MACData[LICENSE_MAC_DATA];

} Hydra_Server_New_License;

#ifdef OS_WIN16
typedef Hydra_Server_New_License FAR * PHydra_Server_New_License;
#else
typedef Hydra_Server_New_License * PHydra_Server_New_License;
#endif  //OS_WIN16

typedef Hydra_Server_New_License    Hydra_Server_Upgrade_License;
typedef PHydra_Server_New_License   PHydra_Server_Upgrade_License;

///////////////////////////////////////////////////////////////////////////////
// Hydra Server Authentication Certificate structures;
// Here we assume that before Licensing module comes into play
// the client will somehow notify the Server about the supported
// Provider and the Hydra Server will accordingly provide 
// appropriate certificate
//

typedef struct _Hydra_Server_Cert
{
    DWORD           dwVersion;
    DWORD           dwSigAlgID;
    DWORD           dwKeyAlgID;
    Binary_Blob     PublicKeyData;
    Binary_Blob     SignatureBlob;

} Hydra_Server_Cert;

#ifdef OS_WIN16
typedef Hydra_Server_Cert FAR * PHydra_Server_Cert;
#else
typedef Hydra_Server_Cert * PHydra_Server_Cert;
#endif  //OS_WIN16


///////////////////////////////////////////////////////////////////////////////
// Hydra Client HWID structure 
// Note : We have to finalize on this structure and generation algorithm.
// Currently we have hardcoded these values in Cryptkey.c. - Shubho

typedef struct  _HWID
{
    DWORD       dwPlatformID;
    DWORD       Data1;
    DWORD       Data2;
    DWORD       Data3;
    DWORD       Data4;

} HWID;

#ifdef OS_WIN16
typedef HWID FAR * PHWID;
#else
typedef HWID * PHWID;
#endif //OS_WIN16

typedef struct _LicenseRequest
{
    PBYTE           pbEncryptedHwid;
    DWORD           cbEncryptedHwid;
    DWORD           dwLanguageID;
    DWORD           dwPlatformID;
    PProduct_Info   pProductInfo;

} LICENSEREQUEST;

#ifdef OS_WIN16
typedef LICENSEREQUEST FAR * PLICENSEREQUEST;
#else
typedef LICENSEREQUEST * PLICENSEREQUEST;
#endif  //OS_WIN16

//
// dwLicenseVersion Value
//
// HYDRA_CERT_VERSION_BETA     Beta2 client license
// HYDRA_CERT_VERSION_NO_CERT  Post Beta2 license without certificate chain
// HYDRA_CERT_VERSION_CURRENT  Post Beta2 license with certificate chain
//
typedef struct _LicensedProduct
{
    DWORD                  dwLicenseVersion;   
    DWORD                  dwQuantity;

    PBYTE                  pbOrgProductID;      // original license request product Id
    DWORD                  cbOrgProductID;      // size of original license request product Id

    LICENSEREQUEST         LicensedProduct;     // licensed product
    LICENSED_VERSION_INFO* pLicensedVersion;    // licensed product version    
    DWORD                  dwNumLicensedVersion; // number of licensed product version

    LPTSTR                 szIssuer;
    LPTSTR                 szIssuerId;          // license server setup ID
    LPTSTR                 szIssuerScope;
    LPTSTR                 szLicensedClient;
    LPTSTR                 szLicensedUser;
    LPTSTR                 szIssuerDnsName;

    HWID                   Hwid;

    FILETIME               NotBefore;           // license's validity
    FILETIME               NotAfter;

    PBYTE                  pbPolicyData;       // Policy specfic extension
    DWORD                  cbPolicyData;       // size of policy specific extension
    ULARGE_INTEGER         ulSerialNumber;     // Client license's serial number
} LICENSEDPRODUCT;

#ifdef OS_WIN16
typedef LICENSEDPRODUCT FAR * PLICENSEDPRODUCT;
#else
typedef  LICENSEDPRODUCT *PLICENSEDPRODUCT;
#endif  //OS_WIN16

//-----------------------------------------------------------------------------
//
// Types of certificate used by the server to authenticate itself to the clients
//
// CERT_TYPE_PROPRIETORY
//      Proprietory format certificate
//
// CERT_TYPE_X509
//      X509 format certificate
//
//-----------------------------------------------------------------------------

typedef enum
{
    CERT_TYPE_INVALID       = 0,
    CERT_TYPE_PROPRIETORY   = 1,
    CERT_TYPE_X509          = 2

} CERT_TYPE;


//+----------------------------------------------------------------------------
//
// Ceritificate Blob.  Each blob contains an X509 certificate
//
//+----------------------------------------------------------------------------

typedef struct _Cert_Blob
{
    DWORD   cbCert;     // size of this certificate blob
    BYTE    abCert[1];    // beginning byte of this certificate

} Cert_Blob;

#ifdef OS_WIN16
typedef Cert_Blob FAR * PCert_Blob;
#else
typedef  Cert_Blob * PCert_Blob;
#endif  //OS_WIN16

//+----------------------------------------------------------------------------
//
// Certificate chain with a number of certificate blobs
//
// The most significant bit denotes whether the certificate that has been 
// issued is temporary.  The license server will issue a temporary certificate 
// if it has not yet obtained a certificate from the clearing house.
//
// We also assume that the chain is in the order such that each subsequent 
// certificate belongs to the issuer of the previous certificate.
//
//+----------------------------------------------------------------------------

typedef struct _Cert_Chain
{
    DWORD       dwVersion;          // version of this structure
    DWORD       dwNumCertBlobs;     // Number of certificate blobs
    Cert_Blob   CertBlob[1];        // First certificate blob

} Cert_Chain;

#ifdef OS_WIN16
typedef Cert_Chain FAR * PCert_Chain;
#else
typedef  Cert_Chain * PCert_Chain;
#endif  //OS_WIN16

#define CERT_CHAIN_VERSION_1            0x00000001
#define CERT_CHAIN_VERSION_2            0x00000002
#define MAX_CERT_CHAIN_VERSION          CERT_CHAIN_VERSION_2

#define GET_CERTIFICATE_VERSION( x )    ( 0x0FFFFFFF & x )
#define IS_TEMP_CERTIFICATE( x )        ( 0xF0000000 & x )


//-----------------------------------------------------------------------------
//
// LICENSE_CAPABILITIES
//
// Data structure used to initialize a licensing context.
//
// KeyExchangeAlg - The key exchange algorithm: RSA or Diffie Helman
// ProtocolVer - The supported licensing protocol
// fAuthenticateServer - Whether the client is going to authenticate the server
// CertType - Indicate the type of certificate that has already been transmitted
// to the client.
//
//-----------------------------------------------------------------------------

typedef struct _LICENSE_CAPABILITIES
{
    DWORD       KeyExchangeAlg;
    DWORD       ProtocolVer;    
    BOOL        fAuthenticateServer;
    CERT_TYPE   CertType;
    DWORD       cbClientName;
    PBYTE       pbClientName;

} LICENSE_CAPABILITIES;

#ifdef OS_WIN16
typedef LICENSE_CAPABILITIES FAR * PLICENSE_CAPABILITIES;
#else
typedef LICENSE_CAPABILITIES * PLICENSE_CAPABILITIES;
#endif  //OS_WIN16
typedef PLICENSE_CAPABILITIES LPLICENSE_CAPABILITIES;


//-----------------------------------------------------------------------------
//
// Client licensing info retrievable by terminal server
//
//-----------------------------------------------------------------------------

typedef struct _TS_LICENSE_INFO
{
    ULARGE_INTEGER  ulSerialNumber;     // Client license's serial number
    
    DWORD           dwProductVersion;
    PBYTE           pbOrgProductID;      // original license request product Id
    DWORD           cbOrgProductID;      // size of original license request product Id

    BOOL            fTempLicense;
    
    LPTSTR          szIssuer;
    LPTSTR          szIssuerId;          // license server setup ID

    FILETIME        NotBefore;           // license's validity
    FILETIME        NotAfter;

    LPTSTR          szLicensedClient;       // client's machine name
    LPTSTR          szLicensedUser;         // client's user name
    
    PBYTE           pbRawLicense;       // storage for marking it later
    DWORD           cbRawLicense;

    DWORD           dwSupportFlags;
    
} TS_LICENSE_INFO;

#ifdef OS_WIN16
typedef TS_LICENSE_INFO FAR * PTS_LICENSE_INFO;
#else
typedef TS_LICENSE_INFO * PTS_LICENSE_INFO;
#endif  //OS_WIN16
typedef PTS_LICENSE_INFO LPTS_LICENSE_INFO;

// Support Flags: which DCRs are supported
#define SUPPORT_PER_SEAT_REISSUANCE     0x1
#define SUPPORT_PER_SEAT_POST_LOGON     0x2
#define SUPPORT_CONCURRENT              0x4
#define SUPPORT_WHISTLER_CAL            0x8

#define ALL_KNOWN_SUPPORT_FLAGS (SUPPORT_PER_SEAT_REISSUANCE|SUPPORT_PER_SEAT_POST_LOGON|SUPPORT_CONCURRENT|SUPPORT_WHISTLER_CAL)

// Mark Flags: bits marking the license

#define MARK_FLAG_USER_AUTHENTICATED 0x1


#endif  //_LICENSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ndcgbtyp.h ===
/**INC+**********************************************************************/
/* Header:    ndcgbtyp.h                                                    */
/*                                                                          */
/* Purpose:   Basic types - Win32 specific header                           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/tshrclnt/inc/dcl/ndcgbtyp.h_v  $
 *
 *    Rev 1.13   24 Sep 1997 10:34:42   AK
 * SFR1424: Disable warning 4702 for old compiler
 *
 *    Rev 1.12   22 Aug 1997 13:21:12   TH
 * SFR1133: Initial DD code drop
 *
 *    Rev 1.11   15 Aug 1997 17:06:28   mr
 * SFR1133: Tidy up CA further
 *
 *    Rev 1.10   07 Aug 1997 14:33:50   MR
 * SFR1133: Persuade Wd to compile under C++
 *
 *    Rev 1.9   05 Aug 1997 14:09:22   MR
 * SFR1133: Changes for Citrix build environment
 *
 *    Rev 1.8   04 Aug 1997 14:56:50   KH
 * SFR1022: Move DCCALLBACK to wdcgbtyp, add LOADDS
 *
 *    Rev 1.7   23 Jul 1997 10:47:56   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.6   10 Jul 1997 17:23:12   KH
 * SFR1022: Get 16-bit trace working
 *
 *    Rev 1.5   09 Jul 1997 17:08:38   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.3   16 Jul 1997 13:57:56   MR
 * SFR1080: Added PPDCACHAR
 *
 *    Rev 1.2   14 Jul 1997 17:15:48   OBK
 * SFR1080: Define DCACHAR and PDCACHAR
 *
 *    Rev 1.1   19 Jun 1997 21:50:30   OBK
 * SFR0000: Start of RNS codebase
**/
/**INC-**********************************************************************/
#ifndef _H_NDCGBTYP
#define _H_NDCGBTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Check whether we should include the system headers.                      */
/****************************************************************************/
#ifndef DC_NO_SYSTEM_HEADERS

#if defined(DLL_DISP) || defined(DLL_WD)

/****************************************************************************/
/* winsta.h defines BYTE as unsigned char; later, windef.h typedefs it.     */
/* This ends up as 'typedef unsigned char unsigned char' which doesn't      */
/* compile too well...                                                      */
/*                                                                          */
/* This is my attempt to avoid it                                           */
/****************************************************************************/
#ifdef BYTE
#undef BYTE
#endif

#define BYTE BYTE

/****************************************************************************/
/* Windows NT DDK include files (used to replace standard windows.h)        */
/*                                                                          */
/* The display driver runs in the Kernel space and so MUST NOT access any   */
/* Win32 functions or data.  Instead we can only use the Win32k functions   */
/* as described in the DDK.                                                 */
/****************************************************************************/
#include <stddef.h>
#include <stdarg.h>
#include <ntddk.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>

typedef struct  _FILETIME       /* from wtypes.h */
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;

#else

/****************************************************************************/
/* Standard USER space windows header files.                                */
/*                                                                          */
/* Force strict type checking.                                              */
/****************************************************************************/
#ifndef STRICT
#define STRICT
#endif

/****************************************************************************/
/* Disable the following warnings for the Windows headers:                  */
/*                                                                          */
/* 4115: named type definition in parentheses                               */
/* 4201: nonstandard extension used : nameless struct/union                 */
/* 4214: nonstandard extension used : bit field types other than int        */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4115)
#pragma warning (disable: 4201)
#pragma warning (disable: 4214)

/****************************************************************************/
/* Include the system headers.                                              */
/****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#ifdef OS_WINCE
#include <wince.h>
#endif

#pragma warning (default: 4115)
#pragma warning (default: 4201)
#pragma warning (default: 4214)

#endif /* defined(DLL_DISP) || defined(DLL_WD) */

#endif /* DCS_NO_SYSTEM_HEADERS */

/****************************************************************************/
/* Disable the following warnings for our code:                             */
/*                                                                          */
/* 4102: "Unreferenced label" warnings so that DC_EXIT_POINT can be placed  */
/*       in each function if there aren't (yet) any DC_QUITs.               */
/* 4514: unreferenced inline function has been removed                      */
/* 4057: slightly different types for L"string" and (wchar_t *)             */
/* 4702: unreachable code (retail VC++4.2 only)                             */
/*                                                                          */
/****************************************************************************/
#pragma warning (disable: 4102)
#pragma warning (disable: 4514)
#pragma warning (disable: 4057)
#ifndef DC_DEBUG
#pragma warning (disable: 4702)
#endif

/****************************************************************************/
/* Promote the following warnings to errors:                                */
/*                                                                          */
/* 4706 - "Assignment in conditional expression"                            */
/* 4013 - "'FunctionName' undefined; assuming extern returning int"         */
/*                                                                          */
/* Promote the following warnings to level 3:                               */
/*                                                                          */
/* 4100 - "unreferenced formal parameter"                                   */
/* 4701 - "Local variable may be used before being initialized".            */
/* 4244 - "conversion from 'int ' to 'short ', possible loss of data        */
/* 4127 - "conditional expression is constant                               */
/*                                                                          */
/****************************************************************************/
// #pragma warning (error: 4706)
// #pragma warning (error: 4013)
// #pragma warning (3    : 4100)
// #pragma warning (3    : 4701)
// #pragma warning (3    : 4244)
// #pragma warning (3    : 4127)


/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* DCPTR is used when declaring pointers to variables.  Use it to get the   */
/* correct pointer types for your memory model/compiler.                    */
/****************************************************************************/
#define DCPTR               *

/****************************************************************************/
/* DCUNALIGNED is used to define pointers to values which are not aligned   */
/* on the correct boundary.  e.g.  a DCUINT32 which does not start on a 4   */
/* byte boundary.                                                           */
/****************************************************************************/
#define DCUNALIGNED         UNALIGNED

/****************************************************************************/
/* Define function calling conventions.  Note that PDCAPI should be used to */
/* declare a pointer to a function.                                         */
/****************************************************************************/
#define DCEXPORT
#define DCLOADDS
#ifndef OS_WINCE
#define DCAPI              _stdcall
#define DCINTERNAL         _stdcall
#else	//no _stdcall support on CE.
#define DCAPI              __cdecl
#define DCINTERNAL         __cdecl
#define _stdcall           __cdecl
#define __stdcall          __cdecl
#endif

#define PDCAPI              DCAPI      DCPTR
#define PDCCALLBACK         DCCALLBACK DCPTR
#define PDCINTERNAL         DCINTERNAL DCPTR

/****************************************************************************/
/* Define DCHPTR.                                                           */
/****************************************************************************/
#define DCHPTR                         *

#endif /* _H_NDCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ndcgcfnc.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgcfnc.h                                                               */
/*                                                                          */
/* DC-Groupware C runtime functions - Windows NT specific header.           */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/ndcgcfnc.h_v  $
// 
//    Rev 1.4   06 Aug 1997 14:32:58   AK
// SFR1016: Apply Markups
//
//    Rev 1.3   06 Aug 1997 10:41:24   AK
// SFR1016: Complete removal of DCCHAR etc
//
//    Rev 1.2   23 Jul 1997 10:47:58   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:51:10   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGCFNC
#define _H_NDCGCFNC

#endif /* _H_NDCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\mcskernl.h ===
/* (C) 1996-1999 Microsoft Corp.
 *
 * file   : MCSKernl.h
 * author : Erik Mavrinac
 *
 * description: Kernel mode MCS initialization and user attachment interface
 *   definitions which supplement common definitions of MCSCommn.h.
 */

#ifndef __MCSKERNL_H
#define __MCSKERNL_H


#include "MCSCommn.h"
#include "MCSIoctl.h"


/*
 * Defines
 */

// Required prefix bytes when allocating a user mode buffer or
//   kernel mode OutBuf when making a send-data request. Allows reuse
//   of the buffer for local indications and constructing PDUs.
// Must be the greater of 16 bytes or sizeof(MCSSendDataIndicationIoctl).
#define SendDataReqPrefixBytes sizeof(SendDataIndicationIoctl)

// Used when allocating memory for send-data request, allows ASN.1
//   segmentation while copying the least amount of data.
#define SendDataReqSuffixBytes 2



/*
 * API prototypes.
 */

#ifdef __cplusplus
extern "C" {
#endif


// Prototypes for functons dealing with ICA stack ioctls downward and TD
//   data coming upward.
NTSTATUS MCSIcaChannelInput(void *, CHANNELCLASS,
        VIRTUALCHANNELCLASS, PINBUF, BYTE *, ULONG);
NTSTATUS MCSIcaRawInput(void *, PINBUF, BYTE *, ULONG);
NTSTATUS MCSIcaVirtualQueryBindings(DomainHandle, PSD_VCBIND *, unsigned *);
NTSTATUS MCSIcaT120Request(DomainHandle, PSD_IOCTL);
void     MCSIcaStackCancelIo(DomainHandle);



// Kernel-specific prototypes.

MCSError MCSInitialize(PSDCONTEXT, PSD_OPEN, DomainHandle *, void *);

MCSError APIENTRY MCSSetShadowChannel(
        DomainHandle hDomain,
        ChannelID    shadowChannel);

MCSError APIENTRY MCSGetDefaultDomain(PSDCONTEXT        pContext,
                                      PDomainParameters pDomParams,
                                      unsigned          *MaxSendSize,
                                      unsigned          *MaxX224DataSize,
                                      unsigned          *X224SourcePort);

MCSError APIENTRY MCSCreateDefaultDomain(PSDCONTEXT        pContext,
                                         DomainHandle      hDomain);
            
MCSError APIENTRY MCSGetDomainInfo(
                     DomainHandle      hDomain,
                     PDomainParameters pDomParams, // client's domain params
                     unsigned          *MaxSendSize, // client max PDU size
                     unsigned          *MaxX224DataSize, // client X.224
                     unsigned          *X224SourcePort); // client X.224

MCSError MCSCleanup(DomainHandle *phDomain);

UserID APIENTRY MCSGetUserIDFromHandle(UserHandle hUser);

ChannelID APIENTRY MCSGetChannelIDFromHandle(ChannelHandle hChannel);

MCSError __fastcall MCSSendDataRequest(
        UserHandle      hUser,
        ChannelHandle   hChannel,
        DataRequestType RequestType,
        ChannelID       ChannelID,
        MCSPriority     Priority,
        Segmentation    Segmentation,
        POUTBUF         pOutBuf);

void APIENTRY MCSProtocolErrorEvent(PSDCONTEXT, PPROTOCOLSTATUS, unsigned,
        BYTE *, unsigned);

BOOLEAN __fastcall DecodeLengthDeterminantPER(BYTE *, unsigned, BOOLEAN *,
        unsigned *, unsigned *);

#ifdef __cplusplus
}
#endif



#endif  // !defined(__MCSKERNL_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ndcgctyp.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgctyp.h                                                               */
/*                                                                          */
/* DC-Groupware complex types - Windows NT specific header.                 */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/NDCGCTYP.H_v  $
// 
//    Rev 1.5   23 Jul 1997 10:48:00   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:52:26   OBK
// SFR0000: Start of RNS codebase
//
//    Rev 1.4   08 Jul 1997 08:49:36   KH
// SFR1022: Add message parameter extraction macros
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGCTYP
#define _H_NDCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
typedef DCUINT32                       DCSURFACEID;
typedef DCSURFACEID          DCPTR     PDCSURFACEID;
typedef FILETIME                       DCFILETIME;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* String manipulation                                                      */
/****************************************************************************/
#define DC_CHARNEXT(pCurrentChar) (CharNext(pCurrentChar))
#define DC_CHARPREV(pStringStart, pCurrentChar) \
                                       (CharPrev(pStringStart, pCurrentChar))
#define DC_CHARLOWER(pString) (CharLower(pString))

/****************************************************************************/
/* Message parameter extraction macros.                                     */
/****************************************************************************/
/* WM_COMMAND                                                               */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     command identifier          notification code (HI),           */
/*                                        command identifier (LO)           */
/* lParam     control hwnd (HI),          control hwnd                      */
/*            notification code (LO)                                        */
/****************************************************************************/
#define DC_GET_WM_COMMAND_ID(wParam) (LOWORD(wParam))
#define DC_GET_WM_COMMAND_NOTIFY_CODE(wParam, lParam) (HIWORD(wParam))
#define DC_GET_WM_COMMAND_HWND(lParam) ((HWND)(lParam))

/****************************************************************************/
/* WM_ACTIVATE                                                              */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     activation flag             minimized flag (HI),              */
/*                                        activation flag (LO)              */
/* lParam     minimized flag (HI),        hwnd                              */
/*            hwnd (LO)                                                     */
/****************************************************************************/
#define DC_GET_WM_ACTIVATE_ACTIVATION(wParam) (LOWORD(wParam))
#define DC_GET_WM_ACTIVATE_MINIMIZED(wParam, lParam) (HIWORD(wParam))
#define DC_GET_WM_ACTIVATE_HWND(lParam) ((HWND)(lParam))

/****************************************************************************/
/* WM_HSCROLL and WM_VSCROLL                                                */
/*                                                                          */
/*               16-bit                         32-bit                      */
/* wParam     scroll code                 position (HI),                    */
/*                                        scroll code (LO)                  */
/* lParam     hwnd (HI),                  hwnd                              */
/*            position (LO)                                                 */
/****************************************************************************/
#define DC_GET_WM_SCROLL_CODE(wParam) (LOWORD(wParam))
#define DC_GET_WM_SCROLL_POSITION(wParam, lParam) (HIWORD(wParam))
#define DC_GET_WM_SCROLL_HWND(lParam) ((HWND)(lParam))

#endif /* _H_NDCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\nprfincl.h ===
/****************************************************************************/
/* Copyright(C) Microsoft Corporation 1998                                  */
/****************************************************************************/
/* nprfincl.h - auto-generated header file */

#define DCGOBJ                           0
#define PERF_BYTES_RECV                  2
#define PERF_BYTES_SENT                  4
#define PERF_PKTS_RECV                   6
#define PERF_PKTS_SENT                   8
#define PERF_WINSOCK_RECV_FAIL           10
#define PERF_WINSOCK_SEND_FAIL           12
#define PERF_PKTS_ALLOCATED              14
#define PERF_PKTS_FREED                  16

#define DCPRF_USER_COUNTERS   8
#define DCPRF_KERN_COUNTERS   0

#define DCPRF_COUNTER_TYPES \
{           \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    PERF_COUNTER_COUNTER,   \
    (DWORD)-1 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ndcgcnst.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgcnst.h                                                               */
/*                                                                          */
/* DC-Groupware common constants - Windows NT specific header.              */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/ndcgcnst.h_v  $
//
//    Rev 1.4   27 Aug 1997 16:28:08   enh
// SFR1189: Added command line registry session
//
//    Rev 1.3   22 Aug 1997 10:23:06   SJ
// SFR1316: Trace options in wrong place in the registry.
//
//    Rev 1.2   23 Jul 1997 10:47:58   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:51:52   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGCNST
#define _H_NDCGCNST

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Mutex and shared memory object names.                                    */
/****************************************************************************/
#define TRC_MUTEX_NAME                 _T("TRCMutex")
#define TRC_SHARED_DATA_NAME           _T("TRCSharedDataName")
#define TRC_TRACE_FILE_NAME            _T("TRCTraceFileName")

/****************************************************************************/
/* Server registry prefix.                                                  */
/****************************************************************************/
#define DC_REG_PREFIX             _T("SOFTWARE\\Microsoft\\Conferencing\\DCG\\")

/****************************************************************************/
/* ULS registry entry - for Microsoft's User Location Service               */
/****************************************************************************/
#define REGKEY_ULS_USERDETAILS  \
                      "Software\\Microsoft\\User Location Service\\Client"

#define REGVAL_ULS_NAME  "User Name"

/****************************************************************************/
/* Location of comupter name in registry (used by TDD)                      */
/****************************************************************************/
#define REGVAL_COMPUTERNAME "ComputerName"
#define REGKEY_COMPUTERNAME \
              "System\\CurrentControlSet\\control\\ComputerName\\ComputerName"

/****************************************************************************/
/* Registry keys for Modem TDD.                                             */
/****************************************************************************/
#define REGKEY_CONF         "SOFTWARE\\Microsoft\\Conferencing"
#define REGVAL_USE_R11      "R11 Compatibility"
#define REGVAL_AUTO_ANSWER  "AutoAnswer"
#define REGVAL_N_RINGS      "nPickupRings"

#define REGKEY_PSTN      "SOFTWARE\\Microsoft\\Conferencing\\Transports\\PSTN"
#define REGVAL_PROVNAME  "Provider Name"

/****************************************************************************/
/* Null definitions.                                                        */
/****************************************************************************/
#define NULL_DCSURFACEID               ((DCSURFACEID)0)
#define NULL_SYSBITMAP                 NULL

/****************************************************************************/
/* Performance monitoring file and application names                        */
/****************************************************************************/
#define PERF_APP_NAME "DCG"
#define DCG_PERF_INI_FILE "nprfini.ini"
#define DCG_PERF_HDR_FILE "nprfincl.h"

#endif /* _H_NDCGCNST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ndcgmcro.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - Windows NT specific header.                 */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
// $Log:   Y:/logs/h/dcl/NDCGMCRO.H_v  $
// 
//    Rev 1.4   23 Jul 1997 10:48:02   mr
// SFR1079: Merged \server\h duplicates to \h\dcl
//
//    Rev 1.1   19 Jun 1997 21:53:36   OBK
// SFR0000: Start of RNS codebase
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGMCRO
#define _H_NDCGMCRO

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* FIELDSIZE macro.                                                         */
/****************************************************************************/
#define FIELDSIZE(type, field)   (sizeof(((type *)1)->field))

/****************************************************************************/
/* FIELDOFFSET macro.                                                       */
/****************************************************************************/
#define FIELDOFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif /* _H_NDCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ndcgperf.h ===
/**INC+**********************************************************************/
/*                                                                          */
/* ndcgperf.h                                                               */
/*                                                                          */
/* DC-Groupware performance monitoring - Windows NT specific header.        */
/*                                                                          */
/* Copyright(c) Microsoft 1996-7                                            */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  10Sep96 AK  SFR0569     Created for performance monitoring              */
/*  22Jan97 AK  SFR1165     Add PRF_SET_RAWCOUNT                            */
/*  05Feb97 TH  SFR1373     Get C++ build working                           */
/*                                                                          */
/**INC-**********************************************************************/
#ifndef _H_NDCGPERF
#define _H_NDCGPERF

#ifdef VER_CPP
extern "C" {
#endif /* VER_CPP */

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Include the auto-generated header file containing constant definitions   */
/****************************************************************************/
#include <nprfincl.h>

#define DC_NO_PERFORMANCE_MONITOR

/****************************************************************************/
/* Import the shared data segment from the Performance DLL                  */
/****************************************************************************/
__declspec(dllimport) DWORD prfSharedDataBlock[1024];

/****************************************************************************/
/* Define the Performance Monitoring macros.                                */
/* Note that the constants are defined in nprfincl.h as 2, 4, 6, ...        */
/* The offsets into the shared data are 0, 8, 16, etc                       */
/****************************************************************************/
#ifndef DC_NO_PERFORMANCE_MONITOR

#define PRF_INC_COUNTER(x)                                                   \
      (*((DWORD *)(((PDCINT8)prfSharedDataBlock) + sizeof(DWORD)*((x)-2))))++;

#define PRF_ADD_COUNTER(x,n)                                                 \
   (*((DWORD *)(((PDCINT8)prfSharedDataBlock) + sizeof(DWORD)*((x)-2))))+=(n);

#define PRF_SET_RAWCOUNT(x,n)                                                \
   (*((DWORD *)(((PDCINT8)prfSharedDataBlock) + sizeof(DWORD)*((x)-2))))=(n);

/****************************************************************************/
/* Timers currently not implemented.                                        */
/****************************************************************************/
#define PRF_TIMER_START(x)
#define PRF_TIMER_STOP(x)

#else /* ..DC_NO_PERFORMANCE_MONITOR.. */

#define PRF_INC_COUNTER(x)
#define PRF_ADD_COUNTER(x,n)
#define PRF_SET_RAWCOUNT(x,n)
#define PRF_TIMER_START(x)
#define PRF_TIMER_STOP(x)

#endif /* DC_NO_PERFORMANCE_MONITOR  */

#ifdef VER_CPP
}
#endif  /* VER_CPP */
#endif /* _H_NDCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\pclip.h ===
/**INC+**********************************************************************/
/* Header:    pclip.h                                                       */
/*                                                                          */
/* Purpose:   Clip Redirector Addin protocol header                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1998                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/

#ifndef _H_PCLIP
#define _H_PCLIP

/****************************************************************************/
/* Name of the Clip virtual channel                                         */
/****************************************************************************/
#define CLIP_CHANNEL "CLIPRDR"

/****************************************************************************/
/* Structure: TS_CLIP_PDU                                                   */
/*                                                                          */
/* Name of PDU: ClipPDU              (a T.128 extension)                    */
/****************************************************************************/
typedef struct tagTS_CLIP_PDU
{
    TSUINT16                 msgType;

#define TS_CB_MONITOR_READY             1
#define TS_CB_FORMAT_LIST               2
#define TS_CB_FORMAT_LIST_RESPONSE      3
#define TS_CB_FORMAT_DATA_REQUEST       4
#define TS_CB_FORMAT_DATA_RESPONSE      5
#define TS_CB_TEMP_DIRECTORY            6

    TSUINT16                 msgFlags;

#define TS_CB_RESPONSE_OK               0x01
#define TS_CB_RESPONSE_FAIL             0x02
#define TS_CB_ASCII_NAMES               0x04

    TSUINT32                 dataLen;
    TSUINT8                  data[1];

} TS_CLIP_PDU;
typedef TS_CLIP_PDU UNALIGNED FAR *PTS_CLIP_PDU;


/****************************************************************************/
/* Structure: TS_CLIP_FORMAT                                                */
/*                                                                          */
/* Clipboard format information                                             */
/*                                                                          */
/* Field Descriptions:                                                      */
/*      format id                                                           */
/*      format name                                                         */
/*                                                                          */
/****************************************************************************/
#define TS_FORMAT_NAME_LEN  32

typedef struct tagTS_CLIP_FORMAT
{
    TSUINT32                formatID;

#define TS_FORMAT_NAME_LEN 32
    TSUINT8                formatName[TS_FORMAT_NAME_LEN];
} TS_CLIP_FORMAT;
typedef TS_CLIP_FORMAT UNALIGNED FAR * PTS_CLIP_FORMAT;


/****************************************************************************/
/* Structure: TS_CLIP_MFPICT                                                */
/*                                                                          */
/* Metafile information                                                     */
/*                                                                          */
/****************************************************************************/
typedef struct tagTS_CLIP_MFPICT
{
    TSUINT32    mm;
    TSUINT32    xExt;
    TSUINT32    yExt;
} TS_CLIP_MFPICT;
typedef TS_CLIP_MFPICT UNALIGNED FAR *PTS_CLIP_MFPICT;



#endif /* _H_PCLIP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ntrcapi.h ===
/****************************************************************************/
/*                                                                          */
/* ntrcapi.h                                                                */
/*                                                                          */
/* DC-Groupware tracing API header - Windows NT specifc                     */
/*                                                                          */
/* Copyright(c) Microsoft 1996                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  07Oct96 PAB Created     Millennium codebase.                            */
/*  22Oct96 PAB SFR0534     Mark ups from display driver review             */
/*  23Oct96 PAB SFR0730     Merged shared memory changes                    */
/*  17Dec96 PAB SFR0646     Use DLL_DISP to identify display driver code    */
/*                                                                          */
/****************************************************************************/
#ifndef _H_NTRCAPI
#define _H_NTRCAPI


#ifdef DLL_DISP
/****************************************************************************/
/* API FUNCTION: TRC_DDSetTrace(...)                                        */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function takes the new trace settings from the OSI request and sets */
/* the trace configuration accordingly.                                     */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* cjIn : Size of request block                                             */
/* pvIn : Pointer to new trace request block                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_DDSetTrace(DCUINT32 cjIn, PDCVOID pvIn);


/****************************************************************************/
/* API FUNCTION: TRC_DDGetTraceOutput(...)                                  */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function passes back any accumulated kernel mode tracing back to    */
/* the user mode task that requested the data.                              */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* cjIn : Size of request block                                             */
/* pvIn : Pointer to request block                                          */
/* cjOut: Size of output block                                              */
/* pvOut: Pointer to output block                                           */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_DDGetTraceOutput(DCUINT32 cjIn,
                                           PDCVOID  pvIn,
                                           DCUINT32 cjOut,
                                           PDCVOID  pvOut);


/****************************************************************************/
/* API FUNCTION: TRC_DDProcessRequest(...)                                  */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function processes tracing specific requests received on the        */
/* display driver side of the OSI.                                          */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* cjIn : Size of request block                                             */
/* pvIn : Pointer to new trace request block                                */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
ULONG DCAPI TRC_DDProcessRequest(SURFOBJ* pso,
                                          DCUINT32 cjIn,
                                          PDCVOID  pvIn,
                                          DCUINT32 cjOut,
                                          PDCVOID  pvOut);
#endif
#endif /* _H_NTRCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\ntrcctl.h ===
/****************************************************************************/
/* NTRCCTL.H                                                                */
/*                                                                          */
/* Trace include function control file                                      */
/*                                                                          */
/* Copyright(c) Microsoft 1996                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  26Sep96 PAB Created     Millennium code base                            */
/*  22Oct96 PAB SFR0534     Mark ups from display driver review             */
/*  17Dec96 PAB SFR0646     Use DLL_DISP to identify display driver code    */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Functions to be included in both user and kernel space                   */
/****************************************************************************/
#define INC_TRC_GetBuffer
#define INC_TRC_TraceBuffer
#define INC_TRC_GetConfig
#define INC_TRC_SetConfig
#define INC_TRC_TraceData
#define INC_TRC_GetTraceLevel
#define INC_TRC_ProfileTraceEnabled

#define INC_TRCCheckState
#define INC_TRCDumpLine
#define INC_TRCShouldTraceThis
#define INC_TRCSplitPrefixes


/****************************************************************************/
/* User space only functions.                                               */
/****************************************************************************/
#ifndef DLL_DISP
#define INC_TRC_ResetTraceFiles

#define INC_TRCOutput
#define INC_TRCReadFlag
#define INC_TRCSetDefaults
#define INC_TRCReadSharedDataConfig
#define INC_TRCWriteFlag
#define INC_TRCWriteSharedDataConfig
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\platform.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998.
//
//  File:       platform.h
//
//  Contents:   Platform Challenge data structures and functions.
//
//  History:    02-19-98   FredCh   Created
//
//----------------------------------------------------------------------------

#ifndef _PLATFORM_H_
#define _PLATFORM_H_

///////////////////////////////////////////////////////////////////////////////
//
// Definition of the platform ID.
//
// The platform ID is made up of portions:
// The most significant BYTE is used for identifying the OS platform which the
// client is running and the second most significant BYTE is used for identifying 
// the ISV that has provided the client image.  The last 2 bytes are used by 
// the ISV to specify the build of the client image.
//
// When supplying the platform ID for platform challenge, the client will use
// the logical OR value of the OS and IMAGE identifiers.  For example, a 
// Microsoft win32 build 356 client running on WINNT 4.0 will give the platform 
// value of:
// 
// CLIENT_OS_ID_WINNT_40 | CLIENT_IMAGE_ID_MICROSOFT | 0x00000164
//

#define CLIENT_OS_ID_WINNT_351                          0x01000000
#define CLIENT_OS_ID_WINNT_40                           0x02000000
#define CLIENT_OS_ID_WINNT_50                           0x03000000
#define CLIENT_OS_ID_MINOR_WINNT_51                     0x00000001
#define CLIENT_OS_ID_WINNT_POST_51                      0x04000000
#define CLIENT_OS_ID_OTHER                              0xFF000000
#define CLIENT_OS_INDEX_OTHER                           0x00000000
#define CLIENT_OS_INDEX_WINNT_50                        0x00000001
#define CLIENT_OS_INDEX_WINNT_51                        0x00000002
#define CLIENT_OS_INDEX_WINNT_POST_51                   0x00000003


#define CLIENT_IMAGE_ID_MICROSOFT                       0x00010000
#define CLIENT_IMAGE_ID_CITRIX                          0x00020000


///////////////////////////////////////////////////////////////////////////////
//
// Macros for getting the individual component of the platform ID
//

#define GetOSId( _PlatformId ) \
    _PlatformId & 0xFF000000

#define GetImageId( _PlatformId ) \
    _PlatformId & 0x00FF0000

#define GetImageRevision( _PlatformId ) \
    _PlatformId & 0x0000FFFF


///////////////////////////////////////////////////////////////////////////////
//
// platform challenge is 128 bits random number
//

#define PLATFORM_CHALLENGE_SIZE                 16      
#define PLATFORM_CHALLENGE_IMAGE_FILE_SIZE      16384


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\rdpsndp.h ===
/////////////////////////////////////////////////////////////////////
//
//      Module:     rdpsndp.h
//
//      Purpose:    Sound redirection protocol description
//
//      Copyright(C) Microsoft Corporation 2000
//
//      History:    4-10-2000  vladimis [created]
//
/////////////////////////////////////////////////////////////////////

#ifndef _VCSND_H
#define _VCSND_H

#ifdef _WIN32
#include <pshpack1.h>
#else
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#endif

#define RDPSND_PROTOCOL_VERSION     0x0005
//
//  Redefining the version number, this is in order to split the
//  dependency between the client and the server part of audio redirection
//
#define RDPSND_SRVPROTOCOL_VERSION  0x0002

#define _SNDVC_NAME     "RDPSND"

#define DEFAULT_VC_TIMEOUT  30000

//  Device capabilities
//
#define TSSNDCAPS_ALIVE     1
#define TSSNDCAPS_VOLUME    2
#define TSSNDCAPS_PITCH     4
#define TSSNDCAPS_TERMINATED 0x80000000

//  the block size must be bigger than the biggest
//  aligned block after acm conversion
//  for example, Mobile Voice (WAVE_FORMAT_CU_CODEC) format 
//  requres more than 4096
//  samples per block
//
#define TSSND_BLOCKSIZE         ( 8192 * TSSND_NATIVE_BLOCKALIGN )
#define TSSND_BLOCKSONTHENET    4

#define TSSND_NATIVE_BITSPERSAMPLE  16
#define TSSND_NATIVE_CHANNELS       2
#define TSSND_NATIVE_SAMPLERATE     22050
#define TSSND_NATIVE_BLOCKALIGN     ((TSSND_NATIVE_BITSPERSAMPLE * \
                                    TSSND_NATIVE_CHANNELS) / 8)
#define TSSND_NATIVE_AVGBYTESPERSEC (TSSND_NATIVE_BLOCKALIGN * \
                                    TSSND_NATIVE_SAMPLERATE)

#define RANDOM_KEY_LENGTH           32
#define RDPSND_SIGNATURE_SIZE       8

#define IsDGramWaveSigned( _version_ )  ( _version_ >= 3 )
#define CanUDPFragment( _version_ )     ( _version_ >= 4 )
#define IsDGramWaveAudioSigned( _version_ ) ( _version_ >= 5 )

//  Commands/Responses
//
enum {
    SNDC_NONE,
    SNDC_CLOSE, 
    SNDC_WAVE, 
    SNDC_SETVOLUME, 
    SNDC_SETPITCH,
    SNDC_WAVECONFIRM,
    SNDC_TRAINING,
    SNDC_FORMATS,
    SNDC_CRYPTKEY,
    SNDC_WAVEENCRYPT,
    SNDC_UDPWAVE,
    SNDC_UDPWAVELAST
    };

typedef struct {
    BYTE        Type;
    BYTE        bPad;
    UINT16      BodySize;
//  BYTE        Body[0];
} SNDPROLOG, *PSNDPROLOG;

typedef struct {
    SNDPROLOG   Prolog;
    UINT32      dwVolume;
} SNDSETVOLUME, *PSNDSETVOLUME;

typedef struct {
    SNDPROLOG   Prolog;
    UINT32      dwPitch;
} SNDSETPITCH, *PSNDSETPITCH;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    UINT16      wFormatNo;
    union {
    BYTE        cBlockNo;
    DWORD       dwBlockNo;
    };
//  BYTE        Wave[0];
} SNDWAVE, *PSNDWAVE;

#define RDPSND_FRAGNO_EXT       0x80
#define RDPSND_MIN_FRAG_SIZE    0x80
typedef struct {
    BYTE        Type;
    BYTE        cBlockNo;
    BYTE        cFragNo;
//
//  if RDPSND_FRAGNO_EXT is set
//  there will be another byte for the low bits of the frag no
//  BYTE        Wave[0];
} SNDUDPWAVE, *PSNDUDPWAVE;

typedef struct {
    BYTE        Type;
    UINT16      wTotalSize;
    UINT16      wTimeStamp;
    UINT16      wFormatNo;
    union {
    BYTE        cBlockNo;
    DWORD       dwBlockNo;
    };
//  BYTE        Wave[0];
} SNDUDPWAVELAST, *PSNDUDPWAVELAST;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    BYTE        cConfirmedBlockNo;
    BYTE        bPad;
} SNDWAVECONFIRM, *PSNDWAVECONFIRM;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    UINT16      wPackSize;
} SNDTRAINING, *PSNDTRAINING;

typedef struct {
    SNDPROLOG   Prolog;
    UINT16      wTimeStamp;
    UINT16      wVersion;
} SNDVERSION, *PSNDVERSION;

typedef struct {
    UINT16      wFormatTag;
    UINT16      nChannels;
    UINT32      nSamplesPerSec;
    UINT32      nAvgBytesPerSec;
    UINT16      nBlockAlign;
    UINT16      wBitsPerSample;
    UINT16      cbSize;
//
// extra fomat info
//
} SNDFORMATITEM, *PSNDFORMATITEM; 

typedef struct {
    SNDPROLOG   Prolog;
    UINT32      dwFlags;
    UINT32      dwVolume;
    UINT32      dwPitch;
    UINT16      wDGramPort;
    UINT16      wNumberOfFormats;
    BYTE        cLastBlockConfirmed;
    UINT16      wVersion;
    BYTE        bPad;
//  SNDFORMATITEM   pSndFmt[0];
} SNDFORMATMSG, *PSNDFORMATMSG;

typedef struct {
    SNDPROLOG   Prolog;
    DWORD       Reserved;
    BYTE        Seed[RANDOM_KEY_LENGTH];
} SNDCRYPTKEY, *PSNDCRYPTKEY;

#ifdef _WIN32
#include <poppack.h>
#else
#ifndef RC_INVOKED
#pragma pack()
#endif
#endif

#endif  // !_VCSND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\tsremdsk.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    tsremdsk.h

Abstract:

    Prototype for Salem related encryption function

Author:

    HueiWang    4/26/2000

--*/
#ifndef __TSREMDSK_H__
#define __TSREMDSK_H__

#define SALEMHELPASSISTANTACCOUNT_PASSWORDKEY  \
    L"0083343a-f925-4ed7-b1d6-d95d17a0b57b-RemoteDesktopHelpAssistantAccount"

#define SALEMHELPASSISTANTACCOUNT_FAKEPASSWORDKEY  \
    L"0083343a-f925-4ed7-b1d6-d95d17a0b57b"

#define REG_CONTROL_REMDSK				        L"Software\\Microsoft\\Remote Desktop"
#define REG_CONTROL_HELPSESSIONENTRY            L"Pending Help Session"
#define REG_VALUE_SYSTEMRESTORE			        L"SystemRestore"
#define REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY	L"SystemRestore_KEY"
#define REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP	L"SystemRestore_AllowToGetHelp"
#define REG_VALUE_SYSTEMRESTORE_INHELPMODE	    L"SystemRestore" L"_" REG_MACHINE_IN_HELP_MODE


#define SALEMHELPASSISTANTACCOUNT_SIDKEY \
    L"0083343a-f925-4ed7-b1d6-d95d17a0b57b-RemoteDesktopHelpAssistantSID"

#define SALEMHELPASSISTANTACCOUNT_NAME \
    L"HelpAssistant"

#define SALEMRDSADDINNAME \
    L"%WINDIR%\\SYSTEM32\\RDSADDIN.EXE"

#define SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY \
    L"c261dd33-c55b-4a37-924b-746bbf3569ad-RemoteDesktopHelpAssistantEncrypt"

#define SALEMHELPASSISTANTACCOUNT_ENCRYPTMUTEX \
    L"746bbf3569adEncrypt"


#define HELPASSISTANT_CRYPT_CONTAINER   L"HelpAssisantContainer"
#define ENCRYPT_ALGORITHM               CALG_RC4 
#define ENCRYPT_BLOCK_SIZE              8 

#define TERMSRV_TCPPORT                 3389

//
// Event Log ID, TermSrv and Rdshost at various inform
// sessmgr to log an event, this event log is re-mapping
// to actual event code in sessmgr.
// 
#define REMOTEASSISTANCE_EVENTLOG_TERMSRV_INVALID_TICKET    0x1
#define REMOTEASSISTANCE_EVENTLOG_TERMSRV_REVERSE_CONNECT   0x2

#ifdef __cplusplus
extern "C"{
#endif

DWORD
TSHelpAssistantBeginEncryptionCycle();

DWORD
TSHelpAssisantEndEncryptionCycle();

BOOL
TSHelpAssistantInEncryptionCycle();

VOID
TSHelpAssistantEndEncryptionLib();

DWORD
TSHelpAssistantInitializeEncryptionLib();

DWORD
TSHelpAssistantEncryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
);

DWORD
TSHelpAssistantDecryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
);


DWORD
TSGetHelpAssistantAccountName(
    OUT LPWSTR* ppszAccDomain,
    OUT LPWSTR* ppszAcctName
);    

DWORD
TSGetHelpAssistantAccountPassword(
    OUT LPWSTR* ppszAcctPwd
);

BOOL
TSIsMachineInHelpMode();

BOOL
TSIsMachinePolicyAllowHelp();

BOOL
TSIsMachineInSystemRestore();

DWORD
TSSystemRestoreCacheValues();

DWORD
TSSystemRestoreResetValues();



#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\tgcc.h ===
/****************************************************************************/
// tgcc.h
//
// TS GCC layer include file.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _GCC_H_
#define _GCC_H_


//---------------------------------------------------------------------------
// Defines
//---------------------------------------------------------------------------

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C        extern "C"
#else
    #define EXTERN_C        extern
#endif
#endif


//---------------------------------------------------------------------------
// Typedefs
//---------------------------------------------------------------------------

/*
** Typedefs that used to be defined in MCS but are no longer used there.
*/
typedef unsigned char *TransportAddress;
typedef HANDLE PhysicalHandle;


/*
** Typedef for a GCC Numeric string.  This typedef is used throughout GCC for
** storing variable length, NULL terminated, single byte character strings.
** A single character in this string is constrained to numeric values
** ranging from "0" to "9".
*/
typedef unsigned char GCCNumericCharacter;
typedef GCCNumericCharacter *GCCNumericString;


/*
** Typedef for a GCC Unicode string.  This typedef is used throughout GCC for
** storing variable length, NULL terminated, wide character strings.
*/
typedef unsigned short GCCUnicodeCharacter;
typedef GCCUnicodeCharacter FAR *GCCUnicodeString;


/*
** GCCConferenceName
** This structure defines the conference name.  In a create request, the
** conference name can include an optional unicode string but it must
** always include the simple numeric string.  In a join request, either
** one can be specified.
*/
typedef struct
{
    GCCNumericString numeric_string;
    GCCUnicodeString text_string;  /* optional */
} GCCConferenceName;


/*
** GCCConferenceID
** Locally allocated identifier of a created conference.  All subsequent
** references to the conference are made using the ConferenceID as a unique
** identifier. The ConferenceID shall be identical to the MCS domain
** selector used locally to identify the MCS domain associated with the
** conference.
*/
typedef unsigned long GCCConferenceID;


/*
** GCCPassword
** This is the unique password specified by the convenor of the
** conference that is used by the node controller to insure conference
** security. This is also a unicode string.
*/
typedef struct
{
    GCCNumericString numeric_string;
    GCCUnicodeString text_string;  /* optional */
} GCCPassword;


/*
** GCCTerminationMethod
** The termination method is used by GCC to determine
** what action to take when all participants of a conference have
** disconnected.  The conference can either be manually terminated
** by the node controller or it can terminate itself automatically when
** all the participants have left the conference.
*/
typedef enum
{
    GCC_AUTOMATIC_TERMINATION_METHOD = 0,
    GCC_MANUAL_TERMINATION_METHOD = 1
} GCCTerminationMethod;


/*
** ConferencePrivileges
** This structure defines the list of privileges that can be assigned to
** a particular conference.
*/
typedef struct
{
    T120Boolean terminate_is_allowed;
    T120Boolean eject_user_is_allowed;
    T120Boolean add_is_allowed;
    T120Boolean lock_unlock_is_allowed;
    T120Boolean transfer_is_allowed;
} GCCConferencePrivileges;


/*
** Typedef for a GCC octet string.  This typedef is used throughout GCC for
** storing variable length single byte character strings with embedded NULLs.
*/
typedef struct
{
    unsigned short octet_string_length;
    unsigned char FAR *octet_string;
} GCCOctetString;


/*
** Typedef for a GCC long string.  This typedef is used in GCC for
** storing variable length strings of longs with embedded NULLs.
*/
typedef struct
{
    unsigned short long_string_length;
    unsigned long FAR *long_string;
} GCCLongString;


/*
** The following enum structure typedefs are used to define the GCC Object Key.
** The GCC Object Key is used throughout GCC for things like the Application
** keys and Capability IDs.
*/
typedef enum
{
    GCC_OBJECT_KEY = 1,
    GCC_H221_NONSTANDARD_KEY = 2
} GCCObjectKeyType;

typedef struct
{
    GCCObjectKeyType key_type;
    union
    {
        GCCLongString object_id;
        GCCOctetString h221_non_standard_id;
    } u;
} GCCObjectKey;


/*
** GCCUserData
** This structure defines a user data element which is used throughout GCC.
*/
typedef struct
{
    GCCObjectKey key;
    GCCOctetString FAR UNALIGNED *octet_string;  /* optional */
} GCCUserData;


typedef enum
{
    GCC_STATUS_PACKET_RESOURCE_FAILURE   = 0,
    GCC_STATUS_PACKET_LENGTH_EXCEEDED    = 1,
    GCC_STATUS_CTL_SAP_RESOURCE_ERROR    = 2,
    GCC_STATUS_APP_SAP_RESOURCE_ERROR    = 3, /* parameter = Sap Handle */
    GCC_STATUS_CONF_RESOURCE_ERROR       = 4, /* parameter = Conference ID */
    GCC_STATUS_INCOMPATIBLE_PROTOCOL     = 5, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONF_NAME = 6, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_BAD_CONVENER  = 7, /* parameter = Physical Handle */
    GCC_STATUS_JOIN_FAILED_LOCKED        = 8  /* parameter = Physical Handle */
} GCCStatusMessageType;


/*
** GCCReason
** When GCC issues an indication to a user application, it often includes a
** reason parameter informing the user of why the activity is occurring.
*/
typedef enum
{
    GCC_REASON_USER_INITIATED = 0,
    GCC_REASON_UNKNOWN = 1,
    GCC_REASON_NORMAL_TERMINATION = 2,
    GCC_REASON_TIMED_TERMINATION = 3,
    GCC_REASON_NO_MORE_PARTICIPANTS = 4,
    GCC_REASON_ERROR_TERMINATION = 5,
    GCC_REASON_ERROR_LOW_RESOURCES = 6,
    GCC_REASON_MCS_RESOURCE_FAILURE = 7,
    GCC_REASON_PARENT_DISCONNECTED = 8,
    GCC_REASON_CONDUCTOR_RELEASE = 9,
    GCC_REASON_SYSTEM_RELEASE = 10,
    GCC_REASON_NODE_EJECTED = 11,
    GCC_REASON_HIGHER_NODE_DISCONNECTED = 12,
    GCC_REASON_HIGHER_NODE_EJECTED = 13,
    GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE = 14,
    GCC_REASON_SERVER_INITIATED = 15,
    LAST_GCC_REASON = GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE
} GCCReason;


/*
** GCCResult
**  When a user makes a request of GCC, GCC often responds with a result,
**  letting the user know whether or not the request succeeded.
*/
typedef enum
{
    GCC_RESULT_SUCCESSFUL         = 0,
    GCC_RESULT_RESOURCES_UNAVAILABLE      = 1,
    GCC_RESULT_INVALID_CONFERENCE       = 2,
    GCC_RESULT_INVALID_PASSWORD        = 3,
    GCC_RESULT_INVALID_CONVENER_PASSWORD  = 4,
    GCC_RESULT_SYMMETRY_BROKEN        = 5,
    GCC_RESULT_UNSPECIFIED_FAILURE       = 6,
    GCC_RESULT_NOT_CONVENER_NODE       = 7,
    GCC_RESULT_REGISTRY_FULL        = 8,
    GCC_RESULT_INDEX_ALREADY_OWNED        = 9,
    GCC_RESULT_INCONSISTENT_TYPE        = 10,
    GCC_RESULT_NO_HANDLES_AVAILABLE       = 11,
    GCC_RESULT_CONNECT_PROVIDER_FAILED    = 12,
    GCC_RESULT_CONFERENCE_NOT_READY       = 13,
    GCC_RESULT_USER_REJECTED        = 14,
    GCC_RESULT_ENTRY_DOES_NOT_EXIST       = 15,
    GCC_RESULT_NOT_CONDUCTIBLE           = 16,
    GCC_RESULT_NOT_THE_CONDUCTOR       = 17,
    GCC_RESULT_NOT_IN_CONDUCTED_MODE      = 18,
    GCC_RESULT_IN_CONDUCTED_MODE       = 19,
    GCC_RESULT_ALREADY_CONDUCTOR       = 20,
    GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED  = 21,
    GCC_RESULT_INVALID_CHALLENGE_RESPONSE  = 22,
    GCC_RESULT_INVALID_REQUESTER    = 23,
    GCC_RESULT_ENTRY_ALREADY_EXISTS    = 24, 
    GCC_RESULT_INVALID_NODE      = 25,
    GCC_RESULT_INVALID_SESSION_KEY    = 26,
    GCC_RESULT_INVALID_CAPABILITY_ID   = 27,
    GCC_RESULT_INVALID_NUMBER_OF_HANDLES  = 28, 
    GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING  = 29,
    GCC_RESULT_INCOMPATIBLE_PROTOCOL   = 30,
    GCC_RESULT_CONFERENCE_ALREADY_LOCKED  = 31,
    GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED  = 32,
    GCC_RESULT_INVALID_NETWORK_TYPE    = 33,
    GCC_RESULT_INVALID_NETWORK_ADDRESS   = 34,
    GCC_RESULT_ADDED_NODE_BUSY     = 35,
    GCC_RESULT_NETWORK_BUSY      = 36,
    GCC_RESULT_NO_PORTS_AVAILABLE    = 37,
    GCC_RESULT_CONNECTION_UNSUCCESSFUL   = 38,
    GCC_RESULT_LOCKED_NOT_SUPPORTED       = 39,
    GCC_RESULT_UNLOCK_NOT_SUPPORTED    = 40,
    GCC_RESULT_ADD_NOT_SUPPORTED    = 41,
    GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE = 42,
    LAST_CGG_RESULT = GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE
} GCCResult;


/*
** GCCMessageType
**  This section defines the messages that can be sent to the application
**  through the callback facility.  These messages correspond to the
**  indications and confirms that are defined within T.124.
*/
typedef enum
{
    /******************* NODE CONTROLLER CALLBACKS ***********************/
 
    /* Conference Create, Terminate related calls */
    GCC_CREATE_INDICATION     = 0,
    GCC_CREATE_CONFIRM      = 1,
    GCC_QUERY_INDICATION     = 2,
    GCC_QUERY_CONFIRM      = 3,
    GCC_JOIN_INDICATION      = 4,
    GCC_JOIN_CONFIRM      = 5,
    GCC_INVITE_INDICATION     = 6,
    GCC_INVITE_CONFIRM      = 7,
    GCC_ADD_INDICATION      = 8,
    GCC_ADD_CONFIRM       = 9,
    GCC_LOCK_INDICATION      = 10,
    GCC_LOCK_CONFIRM      = 11,
    GCC_UNLOCK_INDICATION     = 12,
    GCC_UNLOCK_CONFIRM      = 13,
    GCC_LOCK_REPORT_INDICATION    = 14,
    GCC_DISCONNECT_INDICATION    = 15,
    GCC_DISCONNECT_CONFIRM     = 16,
    GCC_TERMINATE_INDICATION    = 17,
    GCC_TERMINATE_CONFIRM     = 18,
    GCC_EJECT_USER_INDICATION    = 19,
    GCC_EJECT_USER_CONFIRM     = 20,
    GCC_TRANSFER_INDICATION     = 21,
    GCC_TRANSFER_CONFIRM     = 22,
    GCC_APPLICATION_INVOKE_INDICATION  = 23,  /* SHARED CALLBACK */
    GCC_APPLICATION_INVOKE_CONFIRM   = 24,  /* SHARED CALLBACK */
    GCC_SUB_INITIALIZED_INDICATION   = 25,

    /* Conference Roster related callbacks */
    GCC_ANNOUNCE_PRESENCE_CONFIRM   = 26,
    GCC_ROSTER_REPORT_INDICATION   = 27,  /* SHARED CALLBACK */
    GCC_ROSTER_INQUIRE_CONFIRM    = 28,  /* SHARED CALLBACK */

    /* Conductorship related callbacks */
    GCC_CONDUCT_ASSIGN_INDICATION   = 29,  /* SHARED CALLBACK */
    GCC_CONDUCT_ASSIGN_CONFIRM    = 30,
    GCC_CONDUCT_RELEASE_INDICATION   = 31,  /* SHARED CALLBACK */
    GCC_CONDUCT_RELEASE_CONFIRM    = 32,
    GCC_CONDUCT_PLEASE_INDICATION   = 33,
    GCC_CONDUCT_PLEASE_CONFIRM    = 34,
    GCC_CONDUCT_GIVE_INDICATION    = 35,
    GCC_CONDUCT_GIVE_CONFIRM    = 36,
    GCC_CONDUCT_INQUIRE_CONFIRM    = 37,  /* SHARED CALLBACK */
    GCC_CONDUCT_ASK_INDICATION    = 38,
    GCC_CONDUCT_ASK_CONFIRM     = 39,
    GCC_CONDUCT_GRANT_INDICATION   = 40,  /* SHARED CALLBACK */
    GCC_CONDUCT_GRANT_CONFIRM    = 41,

    /* Miscellaneous Node Controller callbacks */
    GCC_TIME_REMAINING_INDICATION   = 42,
    GCC_TIME_REMAINING_CONFIRM    = 43,
    GCC_TIME_INQUIRE_INDICATION    = 44,
    GCC_TIME_INQUIRE_CONFIRM    = 45,
    GCC_CONFERENCE_EXTEND_INDICATION  = 46,
    GCC_CONFERENCE_EXTEND_CONFIRM   = 47,
    GCC_ASSISTANCE_INDICATION    = 48,
    GCC_ASSISTANCE_CONFIRM     = 49,
    GCC_TEXT_MESSAGE_INDICATION    = 50,
    GCC_TEXT_MESSAGE_CONFIRM    = 51,

    /***************** USER APPLICATION CALLBACKS *******************/

    /* Application Roster related callbacks */
    GCC_PERMIT_TO_ENROLL_INDICATION   = 52,
    GCC_ENROLL_CONFIRM      = 53,
    GCC_APP_ROSTER_REPORT_INDICATION  = 54,  /* SHARED CALLBACK */
    GCC_APP_ROSTER_INQUIRE_CONFIRM   = 55,  /* SHARED CALLBACK */

    /* Application Registry related callbacks */
    GCC_REGISTER_CHANNEL_CONFIRM   = 56,
    GCC_ASSIGN_TOKEN_CONFIRM    = 57,
    GCC_RETRIEVE_ENTRY_CONFIRM    = 58,
    GCC_DELETE_ENTRY_CONFIRM    = 59,
    GCC_SET_PARAMETER_CONFIRM    = 60,
    GCC_MONITOR_INDICATION     = 61,
    GCC_MONITOR_CONFIRM      = 62,
    GCC_ALLOCATE_HANDLE_CONFIRM    = 63,


    /****************** NON-Standard Primitives **********************/
    GCC_PERMIT_TO_ANNOUNCE_PRESENCE = 100,  /* Node Controller Callback */
    GCC_CONNECTION_BROKEN_INDICATION = 101,  /* Node Controller Callback */
    GCC_FATAL_ERROR_SAP_REMOVED = 102,  /* Application Callback */
    GCC_STATUS_INDICATION = 103,  /* Node Controller Callback */
    GCC_TRANSPORT_STATUS_INDICATION = 104  /* Node Controller Callback */
} GCCMessageType;


/*
 * These structures are used to hold the information included for the
 * various callback messages.  In the case where these structures are used for
 * callbacks, the address of the structure is passed as the only parameter.
 */

/*
 * GCC_CREATE_INDICATION
 *
 * Union Choice:
 * CreateIndicationMessage
 *   This is a pointer to a structure that contains all necessary
 *   information about the new conference that is about to be created.
 */
typedef struct
{
    GCCConferenceName conference_name;
    GCCConferenceID conference_id;
    GCCPassword FAR *convener_password;  /* optional */
    GCCPassword FAR *password;  /* optional */
    T120Boolean conference_is_locked;
    T120Boolean conference_is_listed;
    T120Boolean conference_is_conductible;
    GCCTerminationMethod termination_method;
    GCCConferencePrivileges FAR *conductor_privilege_list;   /* optional */
    GCCConferencePrivileges FAR *conducted_mode_privilege_list;/* optional */
    GCCConferencePrivileges FAR *non_conducted_privilege_list; /* optional */
    GCCUnicodeString conference_descriptor;  /* optional */
    GCCUnicodeString caller_identifier;  /* optional */
    TransportAddress calling_address;  /* optional */
    TransportAddress called_address;  /* optional */
    DomainParameters FAR *domain_parameters;  /* optional */
    unsigned short number_of_user_data_members;
    GCCUserData FAR * FAR *user_data_list;  /* optional */
    ConnectionHandle connection_handle;
    PhysicalHandle physical_handle;
} CreateIndicationMessage;


/*
 * GCC_DISCONNECT_INDICATION
 *
 * Union Choice:
 * DisconnectIndicationMessage
 */
typedef struct
{
    GCCConferenceID conference_id;
    GCCReason reason;
    UserID disconnected_node_id;
} DisconnectIndicationMessage;


/*
 * GCC_TERMINATE_INDICATION
 *
 * Union Choice:
 * TerminateIndicationMessage
 */
typedef struct
{
    GCCConferenceID conference_id;
    UserID requesting_node_id;
    GCCReason reason;
} TerminateIndicationMessage;


/*
 * GCCMessage
 * This structure defines the message that is passed from GCC to either
 * the node controller or a user application when an indication or
 * confirm occurs.
 */
typedef struct
{
    GCCMessageType message_type;
    void FAR *user_defined;

    union {
        CreateIndicationMessage create_indication;
        DisconnectIndicationMessage disconnect_indication;
        TerminateIndicationMessage terminate_indication;
    } u;
} GCCMessage;


/*
 * This is the definition for the GCC callback function. Applications
 * writing callback routines should NOT use the typedef to define their
 * functions.  These should be explicitly defined the way that the
 * typedef is defined.
 */

#define GCC_CALLBACK_NOT_PROCESSED 0
#define GCC_CALLBACK_PROCESSED 1

typedef T120Boolean (CALLBACK *GCCCallBack) (GCCMessage FAR *gcc_message);


/*
** Typedef for a GCC Character string.  This typedef is used throughout GCC for
** storing variable length, NULL terminated, single byte character strings.
*/
typedef unsigned char GCCCharacter;
typedef GCCCharacter FAR *GCCCharacterString;


/*
** Typdef for GCC version which is used when registering the node controller
** or an application.
*/
typedef struct
{
    unsigned short major_version;
    unsigned short minor_version;
} GCCVersion;


/*
** GCCNonStandardParameter
** This structure is used within the NetworkAddress typedef and
** the NetworkService typedef defined below.
*/
typedef struct
{
    GCCObjectKey object_key;
    GCCOctetString parameter_data;
} GCCNonStandardParameter;


/*
** GCCNetworkAddress
** The following block of structures defines the Network Address as defined
** by T.124.  Most of these structures were taken almost verbatim from the
** ASN.1 interface file.  Since I'm not really sure what most of this stuff
** is for I really didn't know how to simplify it.
*/
typedef struct
{
    T120Boolean         speech;
    T120Boolean         voice_band;
    T120Boolean         digital_56k;
    T120Boolean         digital_64k;
    T120Boolean         digital_128k;
    T120Boolean         digital_192k;
    T120Boolean         digital_256k;
    T120Boolean         digital_320k;
    T120Boolean         digital_384k;
    T120Boolean         digital_512k;
    T120Boolean         digital_768k;
    T120Boolean         digital_1152k;
    T120Boolean         digital_1472k;
    T120Boolean         digital_1536k;
    T120Boolean         digital_1920k;
    T120Boolean         packet_mode;
    T120Boolean         frame_mode;
    T120Boolean         atm;
} GCCTransferModes;

#define MAXIMUM_DIAL_STRING_LENGTH 17
typedef char GCCDialingString[MAXIMUM_DIAL_STRING_LENGTH];

typedef struct
{
    unsigned short length;
    unsigned short FAR *value;
} GCCExtraDialingString;

typedef struct
{
    T120Boolean         telephony3kHz;
    T120Boolean         telephony7kHz;
    T120Boolean         videotelephony;
    T120Boolean         videoconference;
    T120Boolean         audiographic;
    T120Boolean         audiovisual;
    T120Boolean         multimedia;
} GCCHighLayerCompatibility;

typedef struct
{
    GCCTransferModes transfer_modes;
    GCCDialingString international_number;
    GCCCharacterString sub_address_string;  /* optional */
    GCCExtraDialingString FAR *extra_dialing_string;  /* optional */
    GCCHighLayerCompatibility FAR *high_layer_compatibility; /* optional */
} GCCAggregatedChannelAddress;

#define MAXIMUM_NSAP_ADDRESS_SIZE 20
typedef struct
{
    struct
    {
        unsigned short  length;
        unsigned char   value[MAXIMUM_NSAP_ADDRESS_SIZE];
    } nsap_address;

    GCCOctetString FAR *transport_selector;  /* optional */
} GCCTransportConnectionAddress;

typedef enum
{
    GCC_AGGREGATED_CHANNEL_ADDRESS = 1,
    GCC_TRANSPORT_CONNECTION_ADDRESS = 2,
    GCC_NONSTANDARD_NETWORK_ADDRESS = 3
} GCCNetworkAddressType;

typedef struct
{
    GCCNetworkAddressType  network_address_type;
    union
    {
        GCCAggregatedChannelAddress aggregated_channel_address;
        GCCTransportConnectionAddress transport_connection_address;
        GCCNonStandardParameter non_standard_network_address;
    } u;
} GCCNetworkAddress;


/*
 * This section defines the valid return values from GCC function calls.  Do
 * not confuse this return value with the Result and Reason values defined
 * by T.124 (which are discussed later).  These values are returned directly
 * from the call to the API entry point, letting you know whether or not the
 * request for service was successfully invoked.  The Result and Reason
 * codes are issued as part of an indication or confirm which occurs
 * asynchronously to the call that causes it.
 */
typedef enum
{
    GCC_NO_ERROR = 0,
    GCC_NOT_INITIALIZED = 1,
    GCC_ALREADY_INITIALIZED = 2,
    GCC_ALLOCATION_FAILURE = 3,
    GCC_NO_SUCH_APPLICATION = 4,
    GCC_INVALID_CONFERENCE = 5,
    GCC_CONFERENCE_ALREADY_EXISTS = 6,
    GCC_NO_TRANSPORT_STACKS = 7,
    GCC_INVALID_ADDRESS_PREFIX = 8,
    GCC_INVALID_TRANSPORT = 9,
    GCC_FAILURE_CREATING_PACKET = 10,
    GCC_QUERY_REQUEST_OUTSTANDING = 11,
    GCC_INVALID_QUERY_TAG = 12,
    GCC_FAILURE_CREATING_DOMAIN = 13,
    GCC_CONFERENCE_NOT_ESTABLISHED = 14,
    GCC_INVALID_PASSWORD = 15,
    GCC_INVALID_MCS_USER_ID = 16,
    GCC_INVALID_JOIN_RESPONSE_TAG = 17,
    GCC_TRANSPORT_ALREADY_LOADED = 18,
    GCC_TRANSPORT_BUSY = 19,
    GCC_TRANSPORT_NOT_READY = 20,
    GCC_DOMAIN_PARAMETERS_UNACCEPTABLE = 21,
    GCC_APP_NOT_ENROLLED = 22,
    GCC_NO_GIVE_RESPONSE_PENDING = 23,
    GCC_BAD_NETWORK_ADDRESS_TYPE = 24,
    GCC_BAD_OBJECT_KEY = 25,
    GCC_INVALID_CONFERENCE_NAME = 26,
    GCC_INVALID_CONFERENCE_MODIFIER = 27,
    GCC_BAD_SESSION_KEY = 28,
    GCC_BAD_CAPABILITY_ID = 29,
    GCC_BAD_REGISTRY_KEY = 30,
    GCC_BAD_NUMBER_OF_APES = 31,
    GCC_BAD_NUMBER_OF_HANDLES = 32,
    GCC_ALREADY_REGISTERED = 33,
    GCC_APPLICATION_NOT_REGISTERED = 34,
    GCC_BAD_CONNECTION_HANDLE_POINTER = 35,
    GCC_INVALID_NODE_TYPE = 36,
    GCC_INVALID_ASYMMETRY_INDICATOR = 37,
    GCC_INVALID_NODE_PROPERTIES = 38,
    GCC_BAD_USER_DATA = 39,
    GCC_BAD_NETWORK_ADDRESS = 40,
    GCC_INVALID_ADD_RESPONSE_TAG = 41,
    GCC_BAD_ADDING_NODE = 42,
    GCC_FAILURE_ATTACHING_TO_MCS = 43,
    GCC_INVALID_TRANSPORT_ADDRESS = 44,
    GCC_INVALID_PARAMETER = 45,
    GCC_COMMAND_NOT_SUPPORTED = 46,
    GCC_UNSUPPORTED_ERROR = 47,
    GCC_TRANSMIT_BUFFER_FULL = 48,
    GCC_INVALID_CHANNEL = 49,
    GCC_INVALID_MODIFICATION_RIGHTS = 50,
    GCC_INVALID_REGISTRY_ITEM = 51,
    GCC_INVALID_NODE_NAME = 52,
    GCC_INVALID_PARTICIPANT_NAME = 53,
    GCC_INVALID_SITE_INFORMATION = 54,
    GCC_INVALID_NON_COLLAPSED_CAP = 55,
    GCC_INVALID_ALTERNATIVE_NODE_ID = 56,
    LAST_GCC_ERROR = GCC_INVALID_ALTERNATIVE_NODE_ID
} GCCError, *PGCCError;


#if DBG

// Debug print levels

typedef enum
{
    DBNONE,
    DBERROR,
    DBWARN,
    DBNORMAL,
    DBDEBUG,
    DbDETAIL,
    DBFLOW,
    DBALL
} DBPRINTLEVEL;

#endif // Typedefs



//---------------------------------------------------------------------------
// Prototypes
//---------------------------------------------------------------------------

GCCError
APIENTRY
GCCRegisterNodeControllerApplication (
        GCCCallBack control_sap_callback,
        void FAR *user_defined,
        GCCVersion gcc_version_requested,
        unsigned short FAR *initialization_flags,
        unsigned long FAR *application_id,
        unsigned short FAR *capabilities_mask,
        GCCVersion FAR *gcc_high_version,
        GCCVersion FAR *gcc_version);


GCCError
APIENTRY
GCCCleanup(ULONG application_id);


GCCError
APIENTRY
GCCLoadTransport(
                char FAR *transport_identifier,
                char FAR *transport_file_name);

GCCError
APIENTRY 
GCCConferenceCreateResponse(
                GCCNumericString        conference_modifier,
                DomainHandle            hDomain,
                T120Boolean             use_password_in_the_clear,
                DomainParameters FAR *  domain_parameters,
                unsigned short          number_of_network_addresses,
                GCCNetworkAddress FAR * FAR *local_network_address_list,
                unsigned short          number_of_user_data_members,
                GCCUserData FAR * FAR * user_data_list,
                GCCResult               result);

GCCError
APIENTRY
GCCConferenceInit(
                HANDLE        hIca,
                HANDLE        hStack,
                PVOID         pvContext,
                DomainHandle  *phDomain);

GCCError
APIENTRY
GCCConferenceTerminateRequest(
                DomainHandle     hDomain,
                ConnectionHandle hConnection,
                GCCReason        reason);


#if DBG
EXTERN_C VOID   GCCSetPrintLevel(IN DBPRINTLEVEL DbPrintLevel);

#else
#define GCCSetPrintLevel(_x_)

#endif


#endif // _GCC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\tsgdiplusenums.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2001, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusEnums.h
*
* Abstract:
*
*   GDI+ Enumeration Types
*
\**************************************************************************/

#define GDIPLUS_TS_QUERYVER 4122
#define GDIPLUS_TS_RECORD 4123

//---------------------------------------------------------------------------
// EMF+ Persistent object types
//---------------------------------------------------------------------------

enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeCustomLineCap,
    ObjectTypeGraphics,

    ObjectTypeMax = ObjectTypeGraphics,
    ObjectTypeMin = ObjectTypeBrush
};

//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.

enum EmfPlusRecordType;

#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects

    EmfPlusRecordTypeObject,

    // Drawing Records

    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records

    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextContrast,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    EmfPlusRecordTypeDrawDriverString,

    EmfPlusRecordTypeStrokeFillPath,
    EmfPlusRecordTypeSerializableObject,
    EmfPlusRecordTypeSetTSGraphics,              // For private use by TS
    EmfPlusRecordTypeSetTSClip,                  // For private use by TS

    // NOTE: New records *must* be added immediately before this line.

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\tsrvexp.h ===
//---------------------------------------------------------------------------
//
//  File:       TSrvExp.h
//
//  Contents:   TShareSRV public export include file
//
//  Copyright:  (c) 1992 - 1997, Microsoft Corporation.
//              All Rights Reserved.
//              Information Contained Herein is Proprietary
//              and Confidential.
//
//  History:    7-JUL-97    BrianTa         Created.
//
//---------------------------------------------------------------------------

#ifndef _TSRVEXP_H_
#define _TSRVEXP_H_

#include <t120.h>
#include <at128.h>
#include <license.h>
#include <tssec.h>
#include <at120ex.h>

/****************************************************************************/
/* Defines                                                                  */
/****************************************************************************/

#define NET_MAX_SIZE_SEND_PKT           32000

/****************************************************************************/
/* IOCTL definitions                                                        */
/****************************************************************************/

#define IOCTL_TSHARE_CONF_CONNECT       _ICA_CTL_CODE(0x900, METHOD_NEITHER)
#define IOCTL_TSHARE_CONF_DISCONNECT    _ICA_CTL_CODE(0x901, METHOD_NEITHER)
#define IOCTL_TSHARE_USER_LOGON         _ICA_CTL_CODE(0x903, METHOD_NEITHER)
#define IOCTL_TSHARE_GET_SEC_DATA       _ICA_CTL_CODE(0x904, METHOD_NEITHER)
#define IOCTL_TSHARE_SET_SEC_DATA       _ICA_CTL_CODE(0x905, METHOD_NEITHER)
#define IOCTL_TSHARE_SET_NO_ENCRYPT     _ICA_CTL_CODE(0x906, METHOD_NEITHER)
#define IOCTL_TSHARE_QUERY_CHANNELS     _ICA_CTL_CODE(0x907, METHOD_NEITHER)
#define IOCTL_TSHARE_CONSOLE_CONNECT    _ICA_CTL_CODE(0x908, METHOD_NEITHER)

#define IOCTL_TSHARE_SEND_CERT_DATA     _ICA_CTL_CODE(0x909, METHOD_NEITHER)
#define IOCTL_TSHARE_GET_CERT_DATA      _ICA_CTL_CODE(0x90A, METHOD_NEITHER)
#define IOCTL_TSHARE_SEND_CLIENT_RANDOM _ICA_CTL_CODE(0x90B, METHOD_NEITHER)
#define IOCTL_TSHARE_GET_CLIENT_RANDOM  _ICA_CTL_CODE(0x90C, METHOD_NEITHER)
#define IOCTL_TSHARE_SHADOW_CONNECT     _ICA_CTL_CODE(0x90D, METHOD_NEITHER)
#define IOCTL_TSHARE_SET_ERROR_INFO     _ICA_CTL_CODE(0x90E, METHOD_NEITHER)
#define IOCTL_TSHARE_SEND_ARC_STATUS    _ICA_CTL_CODE(0x90F, METHOD_NEITHER)


//***************************************************************************
// Typedefs
//***************************************************************************

//***************************************************************************
// User data info
//***************************************************************************

typedef struct _USERDATAINFO
{
    ULONG           cbSize;                 // Structure size (incl data)

    TSUINT32        version;                // The client version
    HANDLE          hDomain;                // Domain handle
    ULONG           ulUserDataMembers;      // Number of UserData members
    GCCUserData     rgUserData[1];          // User data

} USERDATAINFO, *PUSERDATAINFO;


//***************************************************************************
// Logon Info
//***************************************************************************

typedef struct _LOGONINFO
{
#define LI_USE_AUTORECONNECT    0x0001
    TSUINT32        Flags;
    TSUINT8         Domain[TS_MAX_DOMAIN_LENGTH];
    TSUINT8         UserName[TS_MAX_USERNAME_LENGTH];
    TSUINT32        SessionId;

} LOGONINFO, *PLOGONINFO;

//***************************************************************************
// Security Info used with the IOCTL_TSHARE_SET_SEC_DATA ioctl
//***************************************************************************

typedef struct _SECINFO
{
    CERT_TYPE           CertType;   // certificate type that was transmitted to the client
    RANDOM_KEYS_PAIR    KeyPair;    // generated key pair

} SECINFO, *PSECINFO;

typedef struct _SHADOWCERT
{
    ULONG pad1;             // This needs to be sizeof(RNS_UD_HEADER)
    ULONG encryptionMethod;
    ULONG encryptionLevel;
    ULONG shadowRandomLen;
    ULONG shadowCertLen;

    // shadow random and certificate follow
    BYTE  data[1];
} SHADOWCERT, *PSHADOWCERT;

typedef struct _CLIENTRANDOM
{
    ULONG clientRandomLen;

    // client random follows
    BYTE  data[1];
} CLIENTRANDOM, *PCLIENTRANDOM;

typedef struct _SECURITYTIMEOUT
{
    LONG ulTimeout;
} SECURITYTIMEOUT, *PSECURITYTIMEOUT;

// Winstation Driver data for shadowing.  This information is passed to the
// shadow stack's WD.  Include all data required to validate the shadow request
// such that the shadow can be rejected at this point if required.
//
typedef struct tagTSHARE_MODULE_DATA {
    // size of this structure in bytes
    UINT32 ulLength;

    // Gather sufficient data to create a conference
    RNS_UD_CS_CORE_V0 clientCoreData;
    RNS_UD_CS_SEC_V0  clientSecurityData;

    // Information to reestablish the MCS domain
    // MCS domain, channel, user, token information.
    DomainParameters DomParams;  // This domain's negotiated parameters.
    unsigned MaxSendSize;

    // X.224 information.
    unsigned MaxX224DataSize;  // Negotiated in X.224 connection.
    unsigned X224SourcePort;

    // Share load count
    LONG shareId;
    
    // Although we repeat some fields below, we have to keep the previous
    // junk around for backwards compatibility with B3.  The only new data
    // added to this structure should be in the form of GCC user data so we
    // don't get alignment issues in the future
    UINT32        ulVersion;
    UINT32        reserved[8]; // for future extension

    // Start of pre-parsed variable user data
    ULONG         userDataLen;
    RNS_UD_HEADER userData;
} TSHARE_MODULE_DATA, *PTSHARE_MODULE_DATA;


// Winstation Driver data for shadowing at Win2000 B3
typedef struct tagTSHARE_MODULE_DATA_B3 {
    // size of this structure in bytes
    UINT32 ulLength;

    // Gather sufficient data to create a conference
    RNS_UD_CS_CORE_V0 clientCoreData;
    RNS_UD_CS_SEC_V0  clientSecurityData;

    // Information to reestablish the MCS domain
    // MCS domain, channel, user, token information.
    DomainParameters DomParams;  // This domain's negotiated parameters.
    unsigned MaxSendSize;
    
    // X.224 information.
    unsigned MaxX224DataSize;  // Negotiated in X.224 connection.
    unsigned X224SourcePort;

    // Share load count
    LONG shareId;
} TSHARE_MODULE_DATA_B3, *PTSHARE_MODULE_DATA_B3;


// Winstation Driver data for shadowing at Win2000 B3 + Ooops!
typedef struct tagTSHARE_MODULE_DATA_B3_OOPS {
    // size of this structure in bytes
    UINT32 ulLength;

    // Gather sufficient data to create a conference
    RNS_UD_CS_CORE_V1 clientCoreData;
    RNS_UD_CS_SEC_V1  clientSecurityData;

    // Information to reestablish the MCS domain
    // MCS domain, channel, user, token information.
    DomainParameters DomParams;  // This domain's negotiated parameters.
    unsigned MaxSendSize;
    
    // X.224 information.
    unsigned MaxX224DataSize;  // Negotiated in X.224 connection.
    unsigned X224SourcePort;

    // Share load count
    LONG shareId;
} TSHARE_MODULE_DATA_B3_OOPS, *PTSHARE_MODULE_DATA_B3_OOPS;


#endif // _TSRVEXP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\tsutil.h ===
/*
 *  TSUtil.h
 *
 *  General purpose utilities library. The entry points listed in this header
 *  conform to the Win32 API style.
 */

#ifndef __TERMSRV_INC_TSUTIL_H__
#define __TERMSRV_INC_TSUTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Terminal Services Utilities
 */

BOOL WINAPI
IsFullTerminalServicesEnabled(
    VOID
    );

BOOL WINAPI
IsPersonalTerminalServicesEnabled(
    VOID
    );

BOOL WINAPI
IsTerminalServicesEnabled(
    VOID
    );

BOOL WINAPI
IsPersonalWorkstation(
    VOID
);

/*
 *  ACL Utilities
 */

#if defined(__ACCESS_CONTROL__) && (defined(_WINNT_) || defined(_NTDEF_))

BOOL WINAPI
AddSidToObjectsSecurityDescriptor(
    IN HANDLE hObject,
    IN SE_OBJECT_TYPE ObjectType,
    IN PSID pSid,
    IN DWORD dwNewAccess,
    IN ACCESS_MODE AccessMode,
    IN DWORD dwInheritance
    );

BOOL WINAPI
AddSidToSecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR *ppSd,
    IN PSID pSid,
    IN DWORD dwNewAccess,
    IN ACCESS_MODE AccessMode,
    IN DWORD dwInheritance
    );

BOOL WINAPI
ConvertAbsoluteToSelfRelative(
    OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    IN PSECURITY_DESCRIPTOR pAbsoluteSd,
    IN PDWORD pcbSelfRelativeSd OPTIONAL
    );

BOOL WINAPI
ConvertSelfRelativeToAbsolute(
    OUT PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    IN PSECURITY_DESCRIPTOR pSelfRelativeSd
    );

BOOL WINAPI
DestroySecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR *ppSd
    );

BOOL WINAPI
IsSecurityDescriptorAbsolute(
    IN PSECURITY_DESCRIPTOR pSd
    );

#endif

/*
 *  String Utilities
 */

PSTR WINAPI
AllocateAndCopyStringA(
    IN PCSTR pString
    );

PWSTR WINAPI
AllocateAndCopyStringW(
    IN PCWSTR pString
    );

BOOL WINAPI
ConvertAnsiToUnicode(
    OUT PWSTR *ppUnicodeString,
    IN PCSTR pAnsiString
    );

BOOL WINAPI
ConvertUnicodeToAnsi(
    OUT PSTR *ppAnsiString,
    IN PCWSTR pUnicodeString
    );

/*
 *  User Utilities
 */

#ifdef _WINNT_

BOOL WINAPI
CreateAdminSid(
    OUT PSID *ppAdminSid
    );

BOOL WINAPI
CreateSystemSid(
    OUT PSID *ppSystemSid
    );

BOOL WINAPI
IsUserMember(
    IN PSID pSid
    );

#endif

/*
 *  Miscellaneous Utilities
 */

#ifndef __TERMSRV_INC_TSUTILNT_H__
#define GetCurrentConsoleId() (USER_SHARED_DATA->ActiveConsoleId)
#define GetCurrentLogonId() (NtCurrentPeb()->LogonId)
#endif

BOOL WINAPI
LoadStringResourceW(
    IN HMODULE hModule,
    IN UINT uiResourceId,
    OUT PWSTR *ppString,
    OUT PDWORD pcchString OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif // __TERMSRV_INC_TSUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\tssec.h ===
/*++

Copyright (c) 1994-1997  Microsoft Corporation

Module Name:

    tssec.h

Abstract:

    contains data definitions required for tshare data encryption.

Author:

    Madan Appiah (madana)  30-Dec-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _TSSEC_H_
#define _TSSEC_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifdef OS_WIN16

#define RSA32API

typedef unsigned long       ULONG;
typedef ULONG FAR*          LPULONG;

#define UNALIGNED

#endif // OS_WIN16


#include <rc4.h>

#define RANDOM_KEY_LENGTH           32  // size of a client/server random key
#define MAX_SESSION_KEY_SIZE        16  // max size of a session key
#define PRE_MASTER_SECRET_LEN       48  // size of a pre-master key
#define SEC_MAX_USERNAME            256 // size of username

#define UPDATE_SESSION_KEY_COUNT    (1024 * 4)
    // update session key after this many encryptions.

#define DATA_SIGNATURE_SIZE         8
    // size of the data signature that sent accross.

/****************************************************************************/
/* Encryption levels - bit field.                                           */
/****************************************************************************/
#define SM_40BIT_ENCRYPTION_FLAG        0x01
#define SM_128BIT_ENCRYPTION_FLAG       0x02
#define SM_56BIT_ENCRYPTION_FLAG        0x08

typedef struct _RANDOM_KEYS_PAIR {
    BYTE clientRandom[RANDOM_KEY_LENGTH];
    BYTE serverRandom[RANDOM_KEY_LENGTH];
} RANDOM_KEYS_PAIR, FAR *LPRANDOM_KEYS_PAIR;

//
// Autoreconnection specific security structures
// These are defined here because they are not necessarily RDP
// specific. Although the PDU's wrapping these packets will
// be protocol specific.
//

// Server to client ARC packet
#define ARC_SC_SECURITY_TOKEN_LEN 16
typedef struct _ARC_SC_PRIVATE_PACKET {
    ULONG cbLen;
    ULONG Version;
    ULONG LogonId;
    BYTE  ArcRandomBits[ARC_SC_SECURITY_TOKEN_LEN];
} ARC_SC_PRIVATE_PACKET, *PARC_SC_PRIVATE_PACKET;

#define ARC_CS_SECURITY_TOKEN_LEN 16
typedef struct _ARC_CS_PRIVATE_PACKET {
    ULONG cbLen;
    ULONG Version;
    ULONG LogonId;
    BYTE  SecurityVerifier[ARC_CS_SECURITY_TOKEN_LEN];
} ARC_CS_PRIVATE_PACKET, *PARC_CS_PRIVATE_PACKET;

BOOL
MakeSessionKeys(
    LPRANDOM_KEYS_PAIR pKeyPair,
    LPBYTE pbEncryptKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    LPBYTE pbDecryptKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    LPBYTE pbMACSaltKey,
    DWORD dwKeyStrength,
    LPDWORD pdwKeyLength,
    DWORD dwEncryptionLevel
    );

BOOL
UpdateSessionKey(
    LPBYTE pbStartKey,
    LPBYTE pbCurrentKey,
    DWORD dwKeyStrength,
    DWORD dwKeyLength,
    struct RC4_KEYSTRUCT FAR *prc4Key,
    DWORD dwEncryptionLevel
    );

BOOL
EncryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4EncryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fCheckSumEncryptedData,
    DWORD  dwEncryptionCount
    );

BOOL
DecryptData(
    DWORD dwEncryptionLevel,
    LPBYTE pSessionKey,
    struct RC4_KEYSTRUCT FAR *prc4DecryptKey,
    DWORD dwKeyLength,
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbMACSaltKey,
    LPBYTE pbSignature,
    BOOL   fCheckSumCipherText,
    DWORD  dwDecryptionCount
    );

//
// RNG init/term functions for DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH
//
VOID
TSRNG_Initialize(
    );
VOID
TSRNG_Shutdown(
    );

//
// RNG bit gathering function i.e all the work happens here
//
// Params:
//  pbRandomKey - where to place the random bits
//  dwRandomKeyLen - size in bytes of pbRandomKey
//
// Returns
//  Success flag
//
BOOL
TSRNG_GenerateRandomBits(
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen
    );

#ifndef NO_INCLUDE_LICENSING
BOOL
GetServerCert(
    LPBYTE FAR *ppServerCertBlob,
    LPDWORD pdwServerCertLen
    );

VOID
InitRandomGenerator(
    VOID);

BOOL
GenerateRandomKey(
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen
    );


BOOL
UnpackServerCert(
    LPBYTE pbCert,
    DWORD dwCertLen,
    PHydra_Server_Cert pServerCert
    );

BOOL
ValidateServerCert(
    PHydra_Server_Cert pServerCert
    );

#endif // NO_INCLUDE_LICENSING

BOOL
EncryptClientRandom(
    LPBYTE pbSrvPublicKey,
    DWORD dwSrvPublicKey,
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen,
    LPBYTE pbEncRandomKey,
    LPDWORD pdwEncRandomKey
    );

BOOL
DecryptClientRandom(
    LPBYTE pbEncRandomKey,
    DWORD dwEncRandomKeyLen,
    LPBYTE pbRandomKey,
    LPDWORD pdwRandomKeyLen
    );

BOOL EncryptDecryptLocalData(
    LPBYTE pbData,
    DWORD dwDataLen
    );

BOOL EncryptDecryptLocalData50(
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbSalt,
    DWORD dwSaltLen
    );

void PortableEncode(LPBYTE pbData,
                    DWORD dwDataLen);

void PortableEncode50(LPBYTE pbData,
                      DWORD dwDataLen,
                      LPBYTE pbSalt,
                      DWORD dwSaltLength);

//
// remove (or comment) the following definition to disable the MSRC4.
//

// #define USE_MSRC4

#ifdef USE_MSRC4

VOID
msrc4_key(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbKey);

VOID
msrc4(
    struct RC4_KEYSTRUCT FAR *pKS,
    DWORD dwLen,
    LPBYTE pbuf);

#else // USE_MSRC4

#define msrc4_key   rc4_key
#define msrc4       rc4

#endif // USE_MSRC4

BOOL
FindIsFrenchSystem(
    VOID
    );

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // _TSSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wdcgbtyp.h ===
/**INC+**********************************************************************/
/* Header:    wdcgbtyp.h                                                    */
/*                                                                          */
/* Purpose:   Basic types - Windows specific header                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wdcgbtyp.h_v  $
 *
 *    Rev 1.4   04 Aug 1997 14:58:38   KH
 * SFR1022: Move DCCALLBACK from n/ddcgbtyp
 *
 *    Rev 1.3   23 Jul 1997 10:48:04   mr
 * SFR1079: Merged \server\h duplicates to \h\dcl
 *
 *    Rev 1.2   09 Jul 1997 17:11:24   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.1   19 Jun 1997 14:22:20   ENH
 * Win16Port: Make compatible with 16 bit build
**/
/**INC-**********************************************************************/
#ifndef _H_WDCGBTYP
#define _H_WDCGBTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Determine our target Windows platform and include the appropriate header */
/* file.                                                                    */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows 3.1 : ddcgbtyp.h                                                 */
/* Windows NT  : ndcgbtyp.h                                                 */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgbtyp.h>
#elif defined( OS_WIN32 )
#include <ndcgbtyp.h>
#endif

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Support ASCII (A), Wide (W) = Unicode, and Mixed (T) character sets.     */
/****************************************************************************/
typedef char                           DCACHAR;
typedef wchar_t                        DCWCHAR;
typedef TCHAR                          DCTCHAR;

typedef DCACHAR              DCPTR     PDCACHAR;
typedef DCWCHAR              DCPTR     PDCWCHAR;
typedef DCTCHAR              DCPTR     PDCTCHAR;

typedef PDCACHAR             DCPTR     PPDCACHAR;
typedef PDCWCHAR             DCPTR     PPDCWCHAR;
typedef PDCTCHAR             DCPTR     PPDCTCHAR;

/****************************************************************************/
/* Basic types abstracted from compiler built ins.                          */
/****************************************************************************/
typedef short                          DCINT16;
typedef unsigned short                 DCUINT16;

/****************************************************************************/
/* Define function calling conventions.                                     */
/****************************************************************************/
#define DCCALLBACK         CALLBACK

/****************************************************************************/
/* Windows specific definitions.                                            */
/****************************************************************************/
typedef HRGN                           DCREGIONID;
typedef HINSTANCE                      DCINSTANCE;

#endif /* _H_WDCGBTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wdcgcnst.h ===
/****************************************************************************/
/*                                                                          */
/* wdcgcnst.h                                                               */
/*                                                                          */
/* DC-Groupware common constants - Windows NT specific header.              */
/*                                                                          */
/* Copyright(c) Microsoft 1996-1997                                         */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/* $Log:   Y:/logs/h/dcl/wdcgcnst.h_v  $                                                                    */
//
//    Rev 1.1   19 Jun 1997 14:29:30   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/
#ifndef _H_WDCGCNST
#define _H_WDCGCNST



/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Mutex and shared memory object names.                                    */
/****************************************************************************/
#define TRC_MUTEX_NAME                 _T("TRCMutex")
#define TRC_SHARED_DATA_NAME           _T("TRCSharedDataName")
#define TRC_TRACE_FILE_NAME            _T("TRCTraceFileName")

/****************************************************************************/
/* Registry prefix.                                                         */
/****************************************************************************/
#define DC_REG_PREFIX             _T("SOFTWARE\\Microsoft\\Conferencing\\DCG\\")

/****************************************************************************/
/* ULS registry entry - for Microsoft's User Location Service               */
/****************************************************************************/
#define REGKEY_ULS_USERDETAILS  \
                      "Software\\Microsoft\\User Location Service\\Client"

#define REGVAL_ULS_NAME  "User Name"

/****************************************************************************/
/* Location of comupter name in registry (used by TDD)                      */
/****************************************************************************/
#define REGVAL_COMPUTERNAME "ComputerName"
#define REGKEY_COMPUTERNAME \
              "System\\CurrentControlSet\\control\\ComputerName\\ComputerName"

/****************************************************************************/
/* Registry keys for Modem TDD.                                             */
/****************************************************************************/
#define REGKEY_CONF         "SOFTWARE\\Microsoft\\Conferencing"
#define REGVAL_USE_R11      "R11 Compatibility"
#define REGVAL_AUTO_ANSWER  "AutoAnswer"
#define REGVAL_N_RINGS      "nPickupRings"

#define REGKEY_PSTN      "SOFTWARE\\Microsoft\\Conferencing\\Transports\\PSTN"
#define REGVAL_PROVNAME  "Provider Name"

/****************************************************************************/
/* Null definitions.                                                        */
/****************************************************************************/
#define NULL_SYSBITMAP                 NULL

/****************************************************************************/
/* Performance monitoring file and application names                        */
/****************************************************************************/
#define PERF_APP_NAME "DCG"
#define DCG_PERF_INI_FILE "nprfini.ini"
#define DCG_PERF_HDR_FILE "nprfincl.h"

/****************************************************************************/
/* Get the platform specific definitions                                    */
/****************************************************************************/
#ifdef OS_WIN32
#include <ndcgcnst.h>
#endif

#endif /* _H_WDCGCNST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wdcgperf.h ===
/**INC+**********************************************************************/
/* Header:    wdcgperf.h                                                    */
/*                                                                          */
/* Purpose:   Performance Monitoring - portable include file                */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wdcgperf.h_v  $
 *
 *    Rev 1.1   15 Jul 1997 15:31:34   MD
 * SFR1029: Create performance build
**/
/**INC-**********************************************************************/
#ifndef _H_WDCGPERF
#define _H_WDCGPERF

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Determine our target Windows platform and include the appropriate header */
/* file.                                                                    */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows 3.1 : ddcgperf.h                                                 */
/* Windows NT  : ndcgperf.h                                                 */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgperf.h>
#elif defined( OS_WIN32 )
#include <ndcgperf.h>
#endif

#endif /* _H_WDCGPERF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\tsutilnt.h ===
/*
 *  TSUtil.h
 *
 *  General purpose utilities library. The entry points listed in this header
 *  conform to the NT API style.
 */

#ifndef __TERMSRV_INC_TSUTILNT_H__
#define __TERMSRV_INC_TSUTILNT_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  ACL Utilities
 */

#ifdef _NTSEAPI_

NTSTATUS NTAPI
NtConvertAbsoluteToSelfRelative(
    OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    IN PSECURITY_DESCRIPTOR pAbsoluteSd,
    IN PULONG pcbSelfRelativeSd OPTIONAL
    );

NTSTATUS NTAPI
NtConvertSelfRelativeToAbsolute(
    OUT PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    IN PSECURITY_DESCRIPTOR pSelfRelativeSd
    );

NTSTATUS NTAPI
NtDestroySecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR *ppSd
    );

NTSTATUS NTAPI
NtIsSecurityDescriptorAbsolute(
    IN PSECURITY_DESCRIPTOR pSd,
    OUT PBOOLEAN pfAbsolute
    );

#endif

/*
 *  String Utilities
 */

NTSTATUS NTAPI
NtAllocateAndCopyStringA(
    PSTR *ppDestination,
    PCSTR pString
    );

NTSTATUS NTAPI
NtAllocateAndCopyStringW(
    PWSTR *ppDestination,
    PCWSTR pString
    );

NTSTATUS NTAPI
NtConvertAnsiToUnicode(
    PWSTR *ppUnicodeString,
    PCSTR pAnsiString
    );

NTSTATUS NTAPI
NtConvertUnicodeToAnsi(
    PSTR *ppAnsiString,
    PCWSTR pUnicodeString
    );

/*
 *  User Utilities
 */

#ifdef _NTSEAPI_

NTSTATUS NTAPI
NtCreateAdminSid(
    OUT PSID *ppAdminSid
    );

NTSTATUS NTAPI
NtCreateSystemSid(
    OUT PSID *ppSystemSid
    );

#endif

/*
 *  LSA Utilities
 */

#ifdef _NTLSA_

VOID NTAPI
InitLsaString(
    IN PLSA_UNICODE_STRING pLsaString,
    IN PCWSTR pString
    );

#endif

/*
 *  Miscellaneous Utilities
 */

#ifndef __TERMSRV_INC_TSUTIL_H__
#define GetCurrentConsoleId() (USER_SHARED_DATA->ActiveConsoleId)
#define GetCurrentLogonId() (NtCurrentPeb()->LogonId)
#endif

#ifdef __cplusplus
}
#endif

#endif // __TERMSRV_INC_TSUTILNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wdcgcfnc.h ===
/**INC+**********************************************************************/
/* Header:    wdcgcfnc.h                                                    */
/*                                                                          */
/* Purpose:   C runtime functions - Windows specific header                 */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wdcgcfnc.h_v  $
 *
 *    Rev 1.6   22 Aug 1997 15:10:48   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.5   06 Aug 1997 14:33:10   AK
 * SFR1016: Apply Markups
 *
 *    Rev 1.4   06 Aug 1997 10:41:14   AK
 * SFR1016: Complete removal of DCCHAR etc
 *
 *    Rev 1.3   15 Jul 1997 15:41:48   AK
 * SFR1016: Add Unicode support
 *
 *    Rev 1.2   09 Jul 1997 17:12:02   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.1   19 Jun 1997 14:26:36   ENH
 * Win16Port: Make compatible with 16 bit build
**/
/**INC-**********************************************************************/
#ifndef _H_WDCGCFNC
#define _H_WDCGCFNC

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Huge memory functions (based on those from windows.h)                    */
/* =====================                                                    */
/* In these definitions:                                                    */
/*    'S' and 'T' are of type HPDCVOID.                                     */
/*    'CS' and 'CT' are of type (constant) HPDCVOID.                        */
/*    'N' is of type DCINT32.                                               */
/****************************************************************************/
/****************************************************************************/
/* This function returns a PDCVOID (WIN32) or DCVOID (WIN16).               */
/****************************************************************************/
#define DC_HMEMCPY(S, CT, N)           hmemcpy(S, CT, N)

#ifdef OS_WIN16
#include <ddcgcfnc.h>
#else
#include <ndcgcfnc.h>
#endif

/****************************************************************************/
/* String handling functions                                                */
/****************************************************************************/
#define DC_ASTRLEN(S)                   strlen(S)
#define DC_WSTRLEN(S)                   wcslen(S)
#define DC_TSTRLEN(S)                   _tcslen(S)

#define DC_ASTRCPY(S, T)                strcpy(S, T)
#define DC_WSTRCPY(S, T)                wcscpy(S, T)
#define DC_TSTRCPY(S, T)                _tcscpy(S, T)

#define DC_ASTRNCPY(S, CT, N)           strncpy(S, CT, N)
#define DC_WSTRNCPY(S, CT, N)           wcsncpy(S, CT, N)
#define DC_TSTRNCPY(S, CT, N)           _tcsncpy(S, CT, N)

#define DC_ASTRCAT(S, T)                strcat(S, T)
#define DC_WSTRCAT(S, T)                wcscat(S, T)
#define DC_TSTRCAT(S, T)                _tcscat(S, T)

#define DC_ASTRCMP(S, T)                strcmp(S, T)
#define DC_WSTRCMP(S, T)                wcscmp(S, T)
#define DC_TSTRCMP(S, T)                _tcscmp(S, T)

#define DC_ASPRINTF                     sprintf
#define DC_WSPRINTF                     swprintf
#define DC_TSPRINTF                     _stprintf
#define DC_TNSPRINTF                    _sntprintf

#define DC_ASTRCHR(S, C)                strchr(S, C)
#define DC_WSTRCHR(S, C)                wcschr(S, C)
#define DC_TSTRCHR(S, C)                _tcschr(S, C)

#define DC_ASTRTOK(S, T)                strtok(S, T)
#define DC_WSTRTOK(S, T)                wcstok(S, T)
#define DC_TSTRTOK(S, T)                _tcstok(S, T)

#define DC_ASTRICMP(S, T)               _stricmp(S, T)
#define DC_WSTRICMP(S, T)               wcsicmp(S, T)
#define DC_TSTRICMP(S, T)               _tcsicmp(S, T)

#define DC_ASTRNCMP(S, T, N)            strncmp(S, T, N)
#define DC_WSTRNCMP(S, T, N)            wcsncmp(S, T, N)
#define DC_TSTRNCMP(S, T, N)            _tcsncmp(S, T, N)

#define DC_ASTRNICMP(S, T, N)           _strnicmp(S, T, N)

#define DC_ASSCANF                      sscanf
#define DC_WSSCANF                      swscanf
#define DC_TSSCANF                      _stscanf

#define DC_ACSLWR                       _strlwr
#define DC_TCSLWR                       _tcslwr

/****************************************************************************/
/* Space required to hold null-terminated string.                           */
/****************************************************************************/
#define DC_ASTRBYTELEN(S)   (DC_ASTRLEN(S) + 1)
#define DC_WSTRBYTELEN(S)   ((DC_WSTRLEN(S) + 1) * sizeof(DCWCHAR))
#define DC_TSTRBYTELEN(S)   ((DC_TSTRLEN(S) + 1) * sizeof(DCTCHAR))

/****************************************************************************/
/* ATOI and ITOA functions                                                  */
/****************************************************************************/
#define DC_ULTOA(N, S, M)               _ultoa(N, S, M)
#define DC_ITOA(N, S, M)                _itoa(N, S, M)
#define DC_ITOW(N, S, M)                _itow(N, S, M)
#define DC_ITOT(N, S, M)                _itot(N, S, M)

#define DC_ASTRTOUL(CS, ENDPTR, BASE)   strtoul(CS, ENDPTR, BASE)
#define DC_ATOI(CS)                     atoi(CS)
#define DC_WTOI(CS)                     _wtoi(CS)
#define DC_TTOI(CS)                     _ttoi(CS)

#endif /* _H_WDCGCFNC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wdcgmcro.h ===
/****************************************************************************/
/*                                                                          */
/* wdcgmcro.h                                                               */
/*                                                                          */
/* DC-Groupware common macros - Windows specific header.                    */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/wdcgmcro.h_v  $                                                                   */
// 
//    Rev 1.2   17 Jul 1997 18:23:06   JPB
// SFR1031: Fixed FIELDSIZE macro for Win16
//
//    Rev 1.1   19 Jun 1997 14:40:00   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/
#ifndef _H_WDCGMCRO
#define _H_WDCGMCRO

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Byte swapping macros for different endian architectures.                 */
/****************************************************************************/
#define DCWIRETONATIVE16(A)
#define DCWIRETONATIVE32(A)
#define DCNATIVETOWIRE16(A)
#define DCNATIVETOWIRE32(A)

/****************************************************************************/
/* Macros to convert from/to a DC-Share standard app ID and an OS-specific  */
/* task/process handle.                                                     */
/****************************************************************************/
#define CO_TO_DCAPPID(htask)    ((DCAPPID)(htask))
#define CO_FROM_DCAPPID(appid)  ((DWORD)(appid))

/****************************************************************************/
/* Macros to convert from/to a DC-Share standard handles and OS-specific    */
/* handles.                                                                 */
/****************************************************************************/
#define CO_TO_DCWINID(hwnd)            ((DCWINID)(hwnd))
#define CO_TO_DCINSTANCE(hinst)        ((DCINSTANCE)(hinst))
#define CO_TO_DCREGIONID(region)       ((DCREGIONID)(region))
#define CO_TO_DCSURFACEID(surface)     ((DCSURFACEID)(surface))
#define CO_TO_DCPALID(palette)         ((DCPALID)(palette))

#define CO_FROM_DCWINID(winid)         ((HWND)(winid))
#define CO_FROM_DCINSTANCE(instance)   ((HINSTANCE)(instance))
#define CO_FROM_DCREGIONID(dcregion)   ((HRGN)(dcregion))
#define CO_FROM_DCSURFACEID(dcsurface) ((HDC)(dcsurface))
#define CO_FROM_DCPALID(dcpalid)       ((HPALETTE)(dcpalid))

/****************************************************************************/
/* Macros to convert from/to a DC-Share standard cursor ID and an           */
/* OS-specific cursor handle.                                               */
/****************************************************************************/
#define CO_TO_DCCURSORID(hcursor)      ((DCCURSORID)((DCUINT32)(hcursor)))
#define CO_FROM_DCCURSORID(cursorid)   ((HCURSOR)((DCUINT32)(cursorid)))

/****************************************************************************/
/* Macro to return the current tick count.                                  */
/****************************************************************************/
#define CO_GET_TICK_COUNT() GetTickCount()

/****************************************************************************/
/* Macros to Post / Send messages                                           */
/****************************************************************************/
#define CO_POST_MSG(a,b,c,d) \
            PostMessage(CO_FROM_DCWINID(a),(b),(WPARAM)(c),(LPARAM)(d))
#define CO_SEND_MSG(a,b,c,d) \
            SendMessage(CO_FROM_DCWINID(a),(b),(WPARAM)(c),(LPARAM)(d))
#define CO_POST_QUIT_MSG(a) PostQuitMessage(a)

/****************************************************************************/
/* Check if a pointer is valid                                              */
/****************************************************************************/
#define DC_IS_VALID_PTR(PTR, SIZE)    (!IsBadWritePtr((PTR), (SIZE)))

/****************************************************************************/
/* Include platform specific stuff.                                         */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgmcro.h>
#else
#include <ndcgmcro.h>
#endif

#endif /* _H_WDCGMCRO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wdcgctyp.h ===
/****************************************************************************/
/*                                                                          */
/* wdcgctyp.h                                                               */
/*                                                                          */
/* DC-Groupware complex types - Windows specific header.                    */
/*                                                                          */
/* Copyright(c) Microsoft 1997                                              */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/wdcgctyp.h_v  $                                                                   */
//
//    Rev 1.3   15 Sep 1997 18:27:18   AK
// SFR1416: Move SD_BOTH definition
//
//    Rev 1.2   26 Jun 1997 09:54:04   KH
// Win16Port: Move some common definitions from n/d files
//
//    Rev 1.1   19 Jun 1997 14:33:02   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/
#ifndef _H_WDCGCTYP
#define _H_WDCGCTYP

/****************************************************************************/
/*                                                                          */
/* INCLUDES                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Include appropriate header files.                                        */
/****************************************************************************/
#ifndef OS_WINCE
#include <sys\timeb.h>
#endif // OS_WINCE
/****************************************************************************/
/* Determine our target Windows platform and include the appropriate header */
/* file.                                                                    */
/* Currently we support:                                                    */
/*                                                                          */
/* Windows 3.1 : ddcgctyp.h                                                 */
/* Windows NT  : ndcgctyp.h                                                 */
/*                                                                          */
/****************************************************************************/
#ifdef OS_WIN16
#include <ddcgctyp.h>
#elif defined( OS_WIN32 )
#include <ndcgctyp.h>
#endif

/****************************************************************************/
/*                                                                          */
/* TYPES                                                                    */
/*                                                                          */
/****************************************************************************/
typedef HPALETTE                       DCPALID;
typedef HCURSOR                        DCCURSORID;
typedef HTASK                          SYSAPPID;
typedef HWND                           SYSWINID;
typedef HFILE                          DCHFILE;
typedef RECT                           SYSRECT;
typedef PALETTEENTRY                   DCPALETTEENTRY;
typedef DCPALETTEENTRY          DCPTR  PDCPALETTEENTRY;

/****************************************************************************/
/* A few useful drawing and bitmap types.                                   */
/****************************************************************************/
typedef HBITMAP                        SYSBITMAP;
typedef BITMAPINFOHEADER               SYSBMIHEADER;
typedef BITMAPINFO                     SYSBMI;

typedef RGBTRIPLE               DCPTR  PRGBTRIPLE;
typedef RGBQUAD                 DCPTR  PRGBQUAD;

/****************************************************************************/
/* Fields for Bmp info structure.                                           */
/****************************************************************************/
#define BMISIZE                        biSize
#define BMIWIDTH                       biWidth
#define BMIHEIGHT                      biHeight
#define BMIPLANES                      biPlanes
#define BMIBITCOUNT                    biBitCount
#define BMICOMPRESSION                 biCompression
#define BMISIZEIMAGE                   biSizeImage
#define BMIXPELSPERMETER               biXPelsPerMeter
#define BMIYPELSPERMETER               biYPelsPerMeter
#define BMICLRUSED                     biClrUsed
#define BMICLRIMPORTANT                biClrImportant

/****************************************************************************/
/* Compression options.                                                     */
/****************************************************************************/
#define BMCRGB                         BI_RGB
#define BMCRLE8                        BI_RLE8
#define BMCRLE4                        BI_RLE4

typedef POINT                          SYSPOINT;

/****************************************************************************/
/* Fields for sysrect structure.                                            */
/****************************************************************************/
#define SRXMIN                         left
#define SRXMAX                         right
#define SRYMIN                         top
#define SRYMAX                         bottom

/****************************************************************************/
/* For fonts...                                                             */
/****************************************************************************/
typedef TEXTMETRIC                     DCTEXTMETRIC;
typedef PTEXTMETRIC                    PDCTEXTMETRIC;
typedef HFONT                          DCHFONT;

/****************************************************************************/
/* Time typedefs.                                                           */
/****************************************************************************/
typedef struct _timeb                  DC_TIMEB;

/****************************************************************************/
/* Mutex handle                                                             */
/****************************************************************************/
typedef HANDLE      DCMUTEX;

/****************************************************************************/
/* Window enumeration handle                                                */
/****************************************************************************/
typedef DCUINT32                       DCENUMWNDHANDLE;
typedef DCENUMWNDHANDLE DCPTR          PDCENUMWNDHANDLE;

/****************************************************************************/
/* Macros for Window and Dialog procedures.                                 */
/****************************************************************************/
#define DCRESULT             LRESULT
#define DCWNDPROC            LRESULT   CALLBACK
#define DCDLGPROC            BOOL      CALLBACK

/****************************************************************************/
/* The following constants are available in WinSock 1.1 and 2.0 but not     */
/* given names in WinSock 1.1.                                              */
/****************************************************************************/
#define SD_RECEIVE      0x00
#define SD_SEND         0x01
#define SD_BOTH         0x02

#endif /* _H_WDCGCTYP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wtrcapi.h ===
/**INC+**********************************************************************/
/* Header:    wtrcapi.h                                                     */
/*                                                                          */
/* Purpose:   Tracing API header - Windows specific                         */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wtrcapi.h_v  $
 *
 *    Rev 1.3   29 Aug 1997 09:23:14   ENH
 * SFR1259: Changed SystemError
 *
 *    Rev 1.2   09 Jul 1997 18:08:08   AK
 * SFR1016: Initial changes to support Unicode
**/
/**INC-**********************************************************************/
#ifndef _H_WTRCAPI
#define _H_WTRCAPI

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* The return code passed from ExitThread after an assert.                  */
/****************************************************************************/
#define TRC_THREAD_EXIT          10

/****************************************************************************/
/* The size of buffer maintained for kernel mode tracing.                   */
/****************************************************************************/
#define TRC_KRNL_BUFFER_SIZE          0x8000

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/
/* A macro to get the last system error and trace it out as an alert level  */
/* trace.                                                                   */
/****************************************************************************/
#ifdef TRC_ENABLE_ALT
#define TRC_SYSTEM_ERROR(string)                                             \
{                                                                            \
    if (TRC_LEVEL_ALT >= TRC_GetTraceLevel())                                \
    {                                                                        \
        TRC_SystemError(TRC_GROUP,                                           \
                        __LINE__,                                            \
                        trc_fn,                                              \
                        trc_file,                                            \
                        _T(string));                                         \
    }                                                                        \
}
#else
#define TRC_SYSTEM_ERROR(string)
#endif

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/* TRC_SystemError                                                          */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* API FUNCTION: TRC_SystemError(...)                                       */
/*                                                                          */
/* DESCRIPTION:                                                             */
/* ============                                                             */
/* This function traces out the last system error as an alert level trace.  */
/*                                                                          */
/* PARAMETERS:                                                              */
/* ===========                                                              */
/* traceComponent : trace component name.                                   */
/* lineNumber     : line number.                                            */
/* funcName       : function name.                                          */
/* fileName       : file name.                                              */
/* string         : name of failed function                                 */
/*                                                                          */
/* RETURNS:                                                                 */
/* ========                                                                 */
/* Nothing.                                                                 */
/*                                                                          */
/****************************************************************************/
DCVOID DCAPI TRC_SystemError(DCUINT   traceComponent,
                             DCUINT   lineNumber,
                             PDCTCHAR funcName,
                             PDCTCHAR fileName,
                             PDCTCHAR string);

#if defined(TRC_CONVERTOANSI)
/****************************************************************************/
/* See wtrcapi.c for details.                                               */
/****************************************************************************/
DCVOID DCAPI TRC_ConvertAndSprintf(PDCTCHAR, const PDCACHAR, ...);
#endif

/****************************************************************************/
/* Get the platform specific definitions                                    */
/****************************************************************************/
#ifdef OS_WIN32
#include <ntrcapi.h>
#endif

#endif /* _H_WTRCAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wtrcint.h ===
/**INC+**********************************************************************/
/* Header:    wtrcint.h                                                     */
/*                                                                          */
/* Purpose:   Interal tracing functions header - Windows specific           */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/h/dcl/wtrcint.h_v  $
 *
 *    Rev 1.8   29 Aug 1997 09:22:56   ENH
 * SFR1259: Changed SystemError
 *
 *    Rev 1.7   22 Aug 1997 15:11:18   SJ
 * SFR1291: Win16 Trace DLL doesn't write integers to ini file properly
 *
 *    Rev 1.6   10 Jul 1997 18:09:44   AK
 * SFR1016: Initial changes to support Unicode
 *
 *    Rev 1.5   10 Jul 1997 17:26:14   KH
 * SFR1022: Get 16-bit trace working
**/
/**INC-**********************************************************************/
#ifndef _H_WTRCINT
#define _H_WTRCINT

#ifdef VER_HOST
#include <wosiapi.h>
#endif /* VER_HOST */

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Notification constants.                                                  */
/****************************************************************************/
#define TRC_TRACE_DLL_INITIALIZE       0
#define TRC_TRACE_DLL_TERMINATE        1
#define TRC_PROCESS_ATTACH_NOTIFY      2
#define TRC_PROCESS_DETACH_NOTIFY      3
#define TRC_THREAD_ATTACH_NOTIFY       4
#define TRC_THREAD_DETACH_NOTIFY       5
#define TRC_SYMBOLS_LOADING_NOTIFY     6
#define TRC_SYMBOLS_LOADED_NOTIFY      7
#define TRC_SYMBOLS_UNLOAD_NOTIFY      8
#define TRC_FILES_RESET                9

/****************************************************************************/
/* Trace internal error return values.                                      */
/****************************************************************************/
#define TRC_RC(N)                      ((DCUINT16)N + TRC_BASE_RC)

#define TRC_RC_CREATE_MAPPING_FAILED   TRC_RC(  1)
#define TRC_RC_MAP_VIEW_FAILED         TRC_RC(  2)
#define TRC_RC_CREATE_FILE_FAILED      TRC_RC(  3)
#define TRC_RC_IO_ERROR                TRC_RC(  4)
#define TRC_RC_CREATE_MUTEX_FAILED     TRC_RC(  5)
#define TRC_RC_SYMBOL_LOAD_FAILED      TRC_RC(  6)
#define TRC_RC_SYMBOL_UNLOAD_FAILED    TRC_RC(  7)
#define TRC_RC_SET_SEC_INFO_FAILED     TRC_RC(  8)

/****************************************************************************/
/* Assert box text                                                          */
/****************************************************************************/
#define TRC_ASSERT_TEXT   _T("%s\n\nFunction %s in file %s at line %d.\n")

#define TRC_ASSERT_TEXT2  _T("\n(Press Retry to debug the application)")

/****************************************************************************/
/* Registry buffer constants.                                               */
/****************************************************************************/
#define TRC_MAX_SUBKEY                 256

/****************************************************************************/
/* Internal trace status flags.  These are maintained on a per process      */
/* basis and are stored in the <trcProcessStatus> field.                    */
/*                                                                          */
/* TRC_STATUS_SYMBOLS_LOADED           : are the debug symbols loaded.      */
/****************************************************************************/
#define TRC_STATUS_SYMBOLS_LOADED      DCFLAG32(1)

/****************************************************************************/
/* Carriage return and line feed pair.                                      */
/****************************************************************************/
#define TRC_CRLF                       _T("\r\n")

/****************************************************************************/
/* Trace format definitions.  These are used for printing various parts of  */
/* the trace lines.                                                         */
/*                                                                          */
/* MODL     is the module name.                                             */
/* STCK     is the stack format (offset, bp, parm1-4).                      */
/*                                                                          */
/****************************************************************************/
#define TRC_MODL_FMT                  _T("%8.8s")
#define TRC_STCK_FMT                  _T("%08x %08x %08x %08x %08x %08x %08x")

#ifdef VER_HOST
/****************************************************************************/
/* Specific values for trace escape codes                                   */
/****************************************************************************/
#define TRC_ESC(code)           (OSI_TRC_ESC_FIRST + code)

#define TRC_ESC_SET_TRACE       TRC_ESC(0)  /* Set new trace level & filter */

#define TRC_ESC_GET_TRACE       TRC_ESC(1)  /* Get latest kernel trace data */

#endif /* VER_HOST */

/****************************************************************************/
/*                                                                          */
/* TYPEDEFS                                                                 */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* TRC_SHARED_DATA                                                          */
/* ===============                                                          */
/* The pointer to the start of the shared data memory mapped file is cast   */
/* as a PTRC_SHARED_DATA.                                                   */
/*                                                                          */
/*                                                                          */
/* trcConfig          - a trace configuration structure which contains the  */
/*                      trace level, prefix list etc.                       */
/* trcIndicator       - which trace MMF is in use.                          */
/* trcOffset          - the current offset from the start of the trace      */
/*                      file.                                               */
/* trcpOutputBuffer   - the trace output buffer.                            */
/* trcpModuleFileName - the module file name of the trace DLL.              */
/* trcpStorageBuffer  - the kernel mode trace output buffer.                */
/*                                                                          */
/****************************************************************************/
typedef struct tagTRC_SHARED_DATA
{
    TRC_CONFIG     trcConfig;
    TRC_FILTER     trcFilter;
    DCUINT         trcIndicator;
    DCUINT32       trcOffset;
    DCTCHAR        trcpOutputBuffer[TRC_LINE_BUFFER_SIZE];
    DCTCHAR        trcpModuleFileName[TRC_FILE_NAME_SIZE];
    DCTCHAR        trcpStorageBuffer[TRC_KRNL_BUFFER_SIZE];
} TRC_SHARED_DATA;

typedef TRC_SHARED_DATA  DCPTR PTRC_SHARED_DATA;

#ifdef VER_HOST
/**STRUCT+*******************************************************************/
/* STRUCTURE: TRC_CHANGE_CONFIG                                             */
/*                                                                          */
/* DESCRIPTION:                                                             */
/*                                                                          */
/* This structure is used to pass the new trace settings to the OSI task.   */
/****************************************************************************/
typedef struct tagTRC_CHANGE_CONFIG
{
    OSI_ESCAPE_HEADER header;           /* Common escape header             */

    TRC_CONFIG        config;           /* New tracing configuration        */

    TRC_FILTER        filter;           /* New filter configuration         */

} TRC_CHANGE_CONFIG, DCPTR PTRC_CHANGE_CONFIG;
/**STRUCT-*******************************************************************/


/**STRUCT+*******************************************************************/
/* STRUCTURE: TRC_GET_OUTPUT                                                */
/*                                                                          */
/* DESCRIPTION:                                                             */
/*                                                                          */
/* This structure is used to pass the latest kernel mode tracing to user    */
/* space.                                                                   */
/****************************************************************************/
typedef struct tagTRC_GET_OUTPUT
{
    OSI_ESCAPE_HEADER header;           /* Common escape header             */

    PDCTCHAR          buffer;           /* Latest buffer of trace output    */

    DCUINT32          length;           /* Length of data in the buffer     */

    DCUINT32          linesLost;        /* Lines lost from kernel trace     */

} TRC_GET_OUTPUT, DCPTR PTRC_GET_OUTPUT;
/**STRUCT-*******************************************************************/
#endif /* VER_HOST */

/****************************************************************************/
/*                                                                          */
/* FUNCTIONS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/*                                                                          */
/* TRCBlankFile                                                             */
/* TRCCloseAllFiles                                                         */
/* TRCCloseSharedData                                                       */
/* TRCCloseSingleFile                                                       */
/* TRCDetermineIndicator                                                    */
/* TRCDetermineOffset                                                       */
/* TRCDisplayAssertBox                                                      */
/* TRCGetCurrentDate                                                        */
/* TRCGetCurrentTime                                                        */
/* TRCGetFileTime                                                           */
/* TRCSystemError                                                           */
/* TRCOpenAllFiles                                                          */
/* TRCOpenSharedData                                                        */
/* TRCOpenSingleFile                                                        */
/* TRCOutputToFile                                                          */
/* TRCReadEntry                                                             */
/* TRCReadProfInt                                                           */
/* TRCReadProfString                                                        */
/* TRCStackTrace                                                            */
/* TRCSymbolsLoad                                                           */
/* TRCSymbolsUnload                                                         */
/* TRCWriteEntry                                                            */
/* TRCWriteProfInt                                                          */
/* TRCWriteProfString                                                       */
/*                                                                          */
/****************************************************************************/
DCVOID DCINTERNAL TRCMaybeSwapFile(DCUINT length);

DCVOID DCINTERNAL TRCExitProcess(DCUINT32 exitCode);

DCVOID DCINTERNAL TRCBlankFile(DCUINT fileNumber);

DCVOID DCINTERNAL TRCCloseAllFiles(DCVOID);

DCVOID DCINTERNAL TRCCloseSharedData(DCVOID);

DCVOID DCINTERNAL TRCCloseSingleFile(DCUINT fileNumber, DCUINT seconds);

DCVOID DCINTERNAL TRCDetermineIndicator(DCVOID);

DCUINT32 DCINTERNAL TRCDetermineOffset(DCUINT32 fileNum);

DCVOID DCINTERNAL TRCDisplayAssertBox(PDCTCHAR pText);

DCVOID DCINTERNAL TRCGetCurrentDate(PDC_DATE pDate);

DCVOID DCINTERNAL TRCGetCurrentTime(PDC_TIME pTime);

DCVOID DCINTERNAL TRCGetKernelTrace(DCVOID);

#ifndef DLL_DISP
DCBOOL DCINTERNAL TRCGetFileTime(DCUINT      fileNumber,
                                 PDCFILETIME pFileTime);

DCUINT DCINTERNAL TRCReadEntry(HKEY     topLevelKey,
                               PDCTCHAR pEntry,
                               PDCVOID  pBuffer,
                               DCINT    bufferSize,
                               DCINT32  expectedDataType);

DCUINT DCINTERNAL TRCWriteEntry(HKEY     topLevelKey,
                                PDCTCHAR pEntry,
                                PDCTCHAR pData,
                                DCINT    dataSize,
                                DCINT32  dataType);

#endif

DCVOID DCINTERNAL TRCSystemError(DCUINT   traceComponent,
                                 DCUINT   lineNumber,
                                 PDCTCHAR funcName,
                                 PDCTCHAR fileName,
                                 PDCTCHAR string);

DCUINT DCINTERNAL TRCOpenAllFiles(DCVOID);

DCUINT DCINTERNAL TRCOpenSharedData(DCVOID);

DCUINT DCINTERNAL TRCOpenSingleFile(DCUINT fileNumber);

DCVOID DCINTERNAL TRCOutputToFile(PDCTCHAR pText,
                                  DCUINT   length,
                                  DCUINT   traceLevel);

DCVOID DCINTERNAL TRCOutputToUser(PDCTCHAR pText,
                                  DCUINT32 length,
                                  DCUINT32 traceLevel);

DCUINT DCINTERNAL TRCReadProfInt(PDCTCHAR pEntry,
                                 PDCUINT32   pValue);

DCUINT DCINTERNAL TRCReadProfString(PDCTCHAR pEntry,
                                    PDCTCHAR pBuffer,
                                    DCINT16  bufferSize);

DCVOID DCINTERNAL TRCStackTrace(DCUINT traceLevel);

DCUINT DCINTERNAL TRCSymbolsLoad(DCVOID);

DCUINT DCINTERNAL TRCSymbolsUnload(DCVOID);

DCUINT DCINTERNAL TRCWriteProfInt(PDCTCHAR  pEntry,
                                  PDCUINT32 pValue);

DCUINT DCINTERNAL TRCWriteProfString(PDCTCHAR pEntry,
                                     PDCTCHAR pBuffer);

DCUINT DCINTERNAL TRCGetModuleFileName(PDCTCHAR pModuleName,
                                       UINT cchModuleName);

/****************************************************************************/
/* Get the platform specific definitions                                    */
/****************************************************************************/
#ifdef OS_WIN16
#include <dtrcint.h>
#else
#include <ntrcint.h>
#endif

#endif /* _H_WTRCINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\inc\wtrcctl.h ===
/****************************************************************************/
/* WTRCCTL.H                                                                */
/*                                                                          */
/* Trace include function control switch file - Windows specific            */
/*                                                                          */
/* Copyright(c) Microsoft, Data Connection 1997                             */
/*                                                                          */
/****************************************************************************/
/* Changes:                                                                 */
/*                                                                          */
/*  $Log:   Y:/logs/h/dcl/wtrcctl.h_v  $                                                                   */
// 
//    Rev 1.1   19 Jun 1997 14:46:36   ENH
// Win16Port: Make compatible with 16 bit build
/*                                                                          */
/****************************************************************************/

#ifndef _H_WTRCCTL
#define _H_WTRCCTL

/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Functions to be included in both user and kernel space                   */
/****************************************************************************/
#define INC_TRC_GetBuffer
#define INC_TRC_TraceBuffer
#define INC_TRC_GetConfig
#define INC_TRC_SetConfig
#define INC_TRC_TraceData
#define INC_TRC_GetTraceLevel
#define INC_TRC_ProfileTraceEnabled

#define INC_TRCCheckState
#define INC_TRCDumpLine
#define INC_TRCShouldTraceThis
#define INC_TRCSplitPrefixes

/****************************************************************************/
/* Determine our target OS and include the appropriate header file.         */
/* Currently we support:                                                    */
/****************************************************************************/
#ifdef OS_WIN16
#include <dtrcctl.h>
#else
#include <ntrcctl.h>
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\clrhouse\keypklib\precomp.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1999 Microsoft Corporation
//
// File:        precomp.h
//
// Contents:    precompile header file
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <wincrypt.h>

#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <stdlib.h>
#include <mbstring.h>

#include "licekpak.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\clrhouse\keypklib\keypack.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1999 Microsoft Corporation
//
// File:        keypack.c
//
// Contents:    Keypack encoding/decoding library
//
// History:     
//
//---------------------------------------------------------------------------
#include "precomp.h"
#include <stddef.h>
#include "md5.h"
#include "rc4.h"

typedef struct _Enveloped_Data
{
    DWORD   cbEncryptedKey;
    PBYTE   pbEncryptedKey;
    DWORD   cbEncryptedData;
    PBYTE   pbEncryptedData;
} Enveloped_Data, * PEnveloped_Data;


///////////////////////////////////////////////////////////////////////////////
//
// Internal functions
//

DWORD WINAPI
VerifyAndGetLicenseKeyPack(
    HCRYPTPROV          hCryptProv,
    PLicense_KeyPack    pLicenseKeyPack,
    DWORD               cbSignerCert, 
    PBYTE               pbSignerCert,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate,
    DWORD               cbSignedBlob, 
    PBYTE               pbSignedBlob 
);

DWORD WINAPI
GetCertificate(
    DWORD               cbCertificateBlob,
    PBYTE               pbCertificateBlob,
    HCRYPTPROV          hCryptProv,
    PCCERT_CONTEXT    * ppCertContext,
    HCERTSTORE        * phCertStore 
);

DWORD WINAPI
VerifyCertificateChain( 
    HCERTSTORE          hCertStore, 
    PCCERT_CONTEXT      pCertContext,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate 
);

DWORD WINAPI
GetCertVerificationResult(
    DWORD dwFlags 
);

DWORD WINAPI
UnpackEnvelopedData( 
    IN OUT PEnveloped_Data pEnvelopedData, 
    IN DWORD cbPackedData, 
    IN PBYTE pbPackedData 
);

DWORD WINAPI
GetEnvelopedData( 
    IN DWORD dwEncyptType,
    IN HCRYPTPROV hCryptProv, 
    IN PEnveloped_Data pEnvelopedData,
    OUT PDWORD pcbData,
    OUT PBYTE *ppbData 
);

/////////////////////////////////////////////////////////

DWORD WINAPI
LicensePackEncryptDecryptData(
    IN PBYTE pbParm,
    IN DWORD cbParm,
    IN OUT PBYTE pbData,
    IN DWORD cbData
    )
/*++

Abstract:

    Internal routine to encrypt/decrypt a blob of data

Parameter:

    pbParm : binary blob to generate encrypt/decrypt key.
    cbParm : size of binary blob.
    pbData : data to be encrypt/decrypt.
    cbData : size of data to be encrypt/decrypt.

Returns:

    ERROR_SUCCESS or error code.

Remark:


--*/
{
    DWORD dwRetCode = ERROR_SUCCESS;
    MD5_CTX md5Ctx;
    RC4_KEYSTRUCT rc4KS;
    BYTE key[16];
    int i;

    if(NULL == pbParm || 0 == cbParm)
    {
        SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
        return dwRetCode;
    }

    MD5Init(&md5Ctx);
    MD5Update(
            &md5Ctx,
            pbParm,
            cbParm
        );

    MD5Final(&md5Ctx);

    memset(key, 0, sizeof(key));

    for(i=0; i < 5; i++)
    {
        key[i] = md5Ctx.digest[i];
    }        

    //
    // Call RC4 to encrypt/decrypt data
    //
    rc4_key(
            &rc4KS, 
            sizeof(key), 
            key 
        );

    rc4(
        &rc4KS, 
        cbData, 
        pbData
    );

	return dwRetCode;
}

static BYTE rgbPubKeyWithExponentOfOne[] =
{
0x06, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x31, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00,

0xab, 0xef, 0xfa, 0xc6, 0x7d, 0xe8, 0xde, 0xfb,
0x68, 0x38, 0x09, 0x92, 0xd9, 0x42, 0x7e, 0x6b,
0x89, 0x9e, 0x21, 0xd7, 0x52, 0x1c, 0x99, 0x3c,
0x17, 0x48, 0x4e, 0x3a, 0x44, 0x02, 0xf2, 0xfa,
0x74, 0x57, 0xda, 0xe4, 0xd3, 0xc0, 0x35, 0x67,
0xfa, 0x6e, 0xdf, 0x78, 0x4c, 0x75, 0x35, 0x1c,
0xa0, 0x74, 0x49, 0xe3, 0x20, 0x13, 0x71, 0x35,
0x65, 0xdf, 0x12, 0x20, 0xf5, 0xf5, 0xf5, 0xc1
};

//---------------------------------------------------------------

BOOL WINAPI 
GetPlaintextKey(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hSymKey,
    OUT BYTE *pbPlainKey   // this must be a 16 byte buffer
    )
/*++

part of Jeff Spelman's code

--*/
{
    HCRYPTKEY   hPubKey = 0;
    BYTE        rgbSimpleBlob[128];
    DWORD       cbSimpleBlob;
    BYTE        *pb;
    DWORD       i;
    BOOL        fRet = FALSE;

    memset(rgbSimpleBlob, 0, sizeof(rgbSimpleBlob));

    if (!CryptImportKey(hProv,
                        rgbPubKeyWithExponentOfOne,
                        sizeof(rgbPubKeyWithExponentOfOne),
                        0,
                        0,
                        &hPubKey))
    {
        goto Ret;
    }

    cbSimpleBlob = sizeof(rgbSimpleBlob);
    if (!CryptExportKey(hSymKey,
                        hPubKey,
                        SIMPLEBLOB,
                        0,
                        rgbSimpleBlob,
                        &cbSimpleBlob))
    {
        goto Ret;
    }

    memset(pbPlainKey, 0, 16);
    pb = rgbSimpleBlob + sizeof(BLOBHEADER) + sizeof(ALG_ID);
    // byte reverse the key
    for (i = 0; i < 5; i++)
    {
        pbPlainKey[i] = pb[5 - (i + 1)];
    }

    fRet = TRUE;

Ret:
    if (hPubKey)
    {
        CryptDestroyKey(hPubKey);
    }

    return fRet;
}

//--------------------------------------------------------------------

DWORD WINAPI
KeyPackDecryptData(
    IN DWORD dwEncryptType,
    IN HCRYPTPROV hCryptProv,
    IN BYTE* pbEncryptKey,
    IN DWORD cbEncryptKey,
    IN BYTE* pbEncryptData,
    IN DWORD cbEncryptData,
    OUT PBYTE* ppbDecryptData,
    OUT PDWORD pcbDecryptData
    )
/*++

Abstract:

    Decrypt a blob of data

Parameters:

    bForceCrypto : TRUE if always use Crypto. API, FALSE otherwise.
    hCryptProv :
    pbEncryptKey :
    cbEncryptKey :
    pbEncryptData :
    cbEncryptData :
    ppbDecryptData :
    pcbDecryptData :

Returns:

    ERROR_SUCCESS or error code.

Remark:

--*/
{
    HCRYPTKEY hSymKey = 0;
    DWORD dwErrCode = ERROR_SUCCESS;
    BYTE rgbPlainKey[16];
    RC4_KEYSTRUCT KeyStruct;
    BOOL  bFrenchLocale;
    

    bFrenchLocale = (MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH) == GetSystemDefaultLangID());

    if( (HCRYPTPROV)NULL == hCryptProv || NULL == pbEncryptKey || 0 == cbEncryptKey ||
        NULL == pbEncryptData || 0 == cbEncryptData )
    {
        SetLastError(dwErrCode = ERROR_INVALID_PARAMETER);
        return dwErrCode;
    }

    if( NULL == ppbDecryptData || NULL == pcbDecryptData )
    {
        SetLastError(dwErrCode = ERROR_INVALID_PARAMETER);
        return dwErrCode;
    }

    *pcbDecryptData = 0;
    *ppbDecryptData = NULL;

    if(!CryptImportKey(
                    hCryptProv,
                    pbEncryptKey,
                    cbEncryptKey,
                    0,
                    CRYPT_EXPORTABLE,
                    &hSymKey
                ))
    {
        dwErrCode = GetLastError();
        goto cleanup;
    }

    *pcbDecryptData = cbEncryptData;
    *ppbDecryptData = (PBYTE) LocalAlloc(LPTR, cbEncryptData);
    if(NULL == *ppbDecryptData)
    {
        dwErrCode = GetLastError();
        goto cleanup;
    }

    memcpy(
            *ppbDecryptData,
            pbEncryptData,
            *pcbDecryptData
        );

    if( LICENSE_KEYPACK_ENCRYPT_ALWAYSFRENCH == dwEncryptType || 
        (TRUE == bFrenchLocale && LICENSE_KEYPACK_ENCRYPT_CRYPTO == dwEncryptType) )
    {
        if(!GetPlaintextKey(
                        hCryptProv,
                        hSymKey,
                        rgbPlainKey))
        {
            dwErrCode = GetLastError();
            goto cleanup;
        }

        //
        // RC4 - input buffer size = output buffer size
        //
        rc4_key(&KeyStruct, sizeof(rgbPlainKey), rgbPlainKey);
        rc4(&KeyStruct, *pcbDecryptData, *ppbDecryptData);

        dwErrCode = ERROR_SUCCESS;
    }
    else
    {
        if(!CryptDecrypt(hSymKey, 0, TRUE, 0, *ppbDecryptData, pcbDecryptData))
        {
            dwErrCode = GetLastError();
            if(NTE_BAD_LEN == dwErrCode)
            {
                PBYTE pbNew;
                //
                // output buffer is too small, re-allocate
                //
                pbNew = (PBYTE) LocalReAlloc(
                                            *ppbDecryptData, 
                                            *pcbDecryptData, 
                                            LMEM_ZEROINIT
                                        );
                if(NULL == pbNew)
                {
                    dwErrCode = GetLastError();
                    goto cleanup;
                }

                *ppbDecryptData = pbNew;
            }

            memcpy(
                    *ppbDecryptData,
                    pbEncryptData,
                    cbEncryptData
                );

            if(!CryptDecrypt(hSymKey, 0, TRUE, 0, *ppbDecryptData, pcbDecryptData))
            {
                dwErrCode = GetLastError();
            }
        }
    }
        
cleanup:

    if (hSymKey)
    {
        CryptDestroyKey(hSymKey);
    }
 
    if(dwErrCode != ERROR_SUCCESS)
    {
        if(*ppbDecryptData != NULL)
        {
            LocalFree(*ppbDecryptData);
        }

        *ppbDecryptData = NULL;
        *pcbDecryptData = 0;
    }

    return dwErrCode;   
}    

///////////////////////////////////////////////////////////////////////////////
//
// decode the encrypted license key pack blob with the license server's private 
// key.
//
// hCryptProv is opened with the key container that contains the key exchange
// private key.
//
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
DecodeLicenseKeyPackEx(
    OUT PLicense_KeyPack pLicenseKeyPack,
    IN PLicensePackDecodeParm pDecodeParm,
    IN DWORD cbKeyPackBlob,
    IN PBYTE pbKeyPackBlob 
    )
/*++

Abstract:

    Decode the encrypted license key pack blob.

Parameters:

    pLicenseKeyPack : Decoded license key pack.
    hCryptProv : 


--*/
{
    DWORD dwRetCode = ERROR_SUCCESS;
    DWORD cbSignedBlob, cbSignature;
    PBYTE pbSignedBlob = NULL, pcbSignature = NULL;
    Enveloped_Data EnvelopedData;
    PEncodedLicenseKeyPack pEncodedLicensePack;

    if( NULL == pLicenseKeyPack || NULL == pDecodeParm ||
        NULL == pbKeyPackBlob || 0 == cbKeyPackBlob )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if( (HCRYPTPROV)NULL == pDecodeParm->hCryptProv )
    {
        return ERROR_INVALID_PARAMETER;
    }


    pEncodedLicensePack = (PEncodedLicenseKeyPack)pbKeyPackBlob;
    
    if(pEncodedLicensePack->dwSignature != LICENSEPACKENCODE_SIGNATURE)
    {
        // 
        // EncodedLicenseKeyPack() puts size of encryption key as first DWORD
        //
        dwRetCode = DecodeLicenseKeyPack(
                                    pLicenseKeyPack,
                                    pDecodeParm->hCryptProv,
                                    pDecodeParm->cbClearingHouseCert,
                                    pDecodeParm->pbClearingHouseCert,
                                    pDecodeParm->cbRootCertificate,
                                    pDecodeParm->pbRootCertificate,
                                    cbKeyPackBlob,
                                    pbKeyPackBlob
                                );

        return dwRetCode;
    }

    if(pEncodedLicensePack->dwStructVersion > LICENSEPACKENCODE_CURRENTVERSION)
    {
        return ERROR_INVALID_DATA;
    }

    if( pEncodedLicensePack->dwEncodeType > LICENSE_KEYPACK_ENCRYPT_MAX )
    {
        return ERROR_INVALID_DATA;
    }

    if( cbKeyPackBlob != offsetof(EncodedLicenseKeyPack, pbData) + pEncodedLicensePack->cbData )   
    {
        return ERROR_INVALID_DATA;
    }
    
    //
    // depends on encryption type, check input parameter
    //
    if( LICENSE_KEYPACK_ENCRYPT_PRIVATE == pEncodedLicensePack->dwEncodeType )
    {
        if(NULL == pDecodeParm->pbDecryptParm || 0 == pDecodeParm->cbDecryptParm )
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if( 0 == pDecodeParm->cbClearingHouseCert ||
        NULL == pDecodeParm->pbClearingHouseCert ||
        0 == pDecodeParm->cbRootCertificate ||
        NULL == pDecodeParm->pbRootCertificate )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the enveloped data
    //
    memset( 
            &EnvelopedData, 
            0, 
            sizeof( Enveloped_Data ) 
        );

    dwRetCode = UnpackEnvelopedData( 
                                &EnvelopedData, 
                                pEncodedLicensePack->cbData,
                                &(pEncodedLicensePack->pbData[0])
                            );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }

    switch( pEncodedLicensePack->dwEncodeType )
    {
        case LICENSE_KEYPACK_ENCRYPT_NONE:
        case LICENSE_KEYPACK_ENCRYPT_PRIVATE:
            pbSignedBlob = EnvelopedData.pbEncryptedData;
            cbSignedBlob = EnvelopedData.cbEncryptedData;
            
            EnvelopedData.pbEncryptedData = NULL;
            EnvelopedData.pbEncryptedData = 0;
            if( LICENSE_KEYPACK_ENCRYPT_PRIVATE == pEncodedLicensePack->dwEncodeType )
            {
                dwRetCode = LicensePackEncryptDecryptData(
                                                pDecodeParm->pbDecryptParm,
                                                pDecodeParm->cbDecryptParm,
                                                pbSignedBlob,
                                                cbSignedBlob
                                            );
            }
            break;

        case LICENSE_KEYPACK_ENCRYPT_CRYPTO:
        case LICENSE_KEYPACK_ENCRYPT_ALWAYSCRYPTO:
        case LICENSE_KEYPACK_ENCRYPT_ALWAYSFRENCH:

            //
            // unpack the enveloped data to get the signed keypack blob
            //
            dwRetCode = GetEnvelopedData( 
                                    pEncodedLicensePack->dwEncodeType,
                                    pDecodeParm->hCryptProv, 
                                    &EnvelopedData, 
                                    &cbSignedBlob, 
                                    &pbSignedBlob 
                                );

            break;

        default:

            // impossible to come here
            dwRetCode = ERROR_INVALID_DATA;
    }

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }
    
    //
    // Get the license keypack from the signed blob.  We also provide the
    // clearing house certificate to verify the authenticity of the keypack.
    //

    dwRetCode = VerifyAndGetLicenseKeyPack( 
                                    pDecodeParm->hCryptProv, 
                                    pLicenseKeyPack, 
                                    pDecodeParm->cbClearingHouseCert, 
                                    pDecodeParm->pbClearingHouseCert,
                                    pDecodeParm->cbRootCertificate, 
                                    pDecodeParm->pbRootCertificate,
                                    cbSignedBlob, 
                                    pbSignedBlob 
                                );

done:

    if( EnvelopedData.pbEncryptedKey )
    {
        LocalFree( EnvelopedData.pbEncryptedKey );
    }

    if( EnvelopedData.pbEncryptedData )
    {
        LocalFree( EnvelopedData.pbEncryptedData );
    }

    if( pbSignedBlob )
    {
        LocalFree( pbSignedBlob );
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
GetEnvelopedData( 
    IN DWORD dwEncryptType,
    IN HCRYPTPROV hCryptProv, 
    IN PEnveloped_Data pEnvelopedData,
    OUT PDWORD pcbData,
    OUT PBYTE *ppbData 
    )
/*++


--*/
{
    HCRYPTKEY hPrivateKey = 0;
    DWORD dwRetCode = ERROR_SUCCESS;

    
    if( (HCRYPTPROV)NULL == hCryptProv || pEnvelopedData == NULL || 
        ppbData == NULL || pcbData == NULL )
    {
        SetLastError(dwRetCode = ERROR_INVALID_PARAMETER);
        return dwRetCode;
    }


    //
    // Make sure we have a exchange key to decrypt session key.
    // 
   
    if( !CryptGetUserKey( hCryptProv, AT_KEYEXCHANGE, &hPrivateKey ) )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // decrypt the data, KeyPackDecryptData() handle
    // memory freeing in case of error.
    //

    dwRetCode = KeyPackDecryptData(
                                dwEncryptType,
                                hCryptProv,
                                pEnvelopedData->pbEncryptedKey,
                                pEnvelopedData->cbEncryptedKey,
                                pEnvelopedData->pbEncryptedData,
                                pEnvelopedData->cbEncryptedData,
                                ppbData,
                                pcbData
                            );
    
done:

    if( hPrivateKey )
    {
        CryptDestroyKey( hPrivateKey );
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
UnpackEnvelopedData( 
    IN OUT PEnveloped_Data pEnvelopedData, 
    IN DWORD cbPackedData, 
    IN PBYTE pbPackedData 
    )
/*++

Abstract:

    Unpack an encrypted license pack blob.

Parameters:

    pEnvelopedData :
    cbPackedData :
    pbPackedData :

Returns:
    

--*/
{
    PBYTE pbCopyPos = pbPackedData;
    DWORD cbDataToUnpack = cbPackedData;

    //
    // ensure that the data is of minimum length
    //
    if( ( ( sizeof( DWORD ) * 2 ) > cbPackedData ) ||
        ( NULL == pbPackedData ) ||
        ( NULL == pEnvelopedData ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // read a DWORD to get the encrypted key length
    //

    memcpy( &pEnvelopedData->cbEncryptedKey, pbCopyPos, sizeof( DWORD ) );

    pbCopyPos += sizeof( DWORD );
    cbDataToUnpack -= sizeof( DWORD );
    
    if( cbDataToUnpack < pEnvelopedData->cbEncryptedKey )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    // Allocate memory to unpack the encrypted key
    //
    if(pEnvelopedData->cbEncryptedKey > 0)
    {
        pEnvelopedData->pbEncryptedKey = LocalAlloc( GPTR, pEnvelopedData->cbEncryptedKey );

        if( NULL == pEnvelopedData->pbEncryptedKey )
        {
            return( GetLastError() );
        }

        memcpy( pEnvelopedData->pbEncryptedKey, pbCopyPos, pEnvelopedData->cbEncryptedKey );
    }
    
    pbCopyPos += pEnvelopedData->cbEncryptedKey;
    cbDataToUnpack -= pEnvelopedData->cbEncryptedKey;

    //
    // expecting to read a DWORD for the encrypted data length
    //

    if( sizeof( DWORD ) > cbDataToUnpack )
    {
        return( ERROR_INVALID_DATA );
    }

    memcpy( &pEnvelopedData->cbEncryptedData, pbCopyPos, sizeof( DWORD ) );

    pbCopyPos += sizeof( DWORD );
    cbDataToUnpack -= sizeof( DWORD );

    if( cbDataToUnpack < pEnvelopedData->cbEncryptedData )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    // allocate memory for the encrypted data
    //

    pEnvelopedData->pbEncryptedData = LocalAlloc( GPTR, pEnvelopedData->cbEncryptedData );

    if( NULL == pEnvelopedData->pbEncryptedData )
    {
        return( GetLastError() );
    }

    memcpy( pEnvelopedData->pbEncryptedData, pbCopyPos, pEnvelopedData->cbEncryptedData );

    return( ERROR_SUCCESS );
}


///////////////////////////////////////////////////////////////////////////////
//
// decode the encrypted license key pack blob with the license server's private 
// key.
//
// hCryptProv is opened with the key container that contains the key exchange
// private key.
//
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
DecodeLicenseKeyPack(
    PLicense_KeyPack        pLicenseKeyPack,
    HCRYPTPROV              hCryptProv,
    DWORD                   cbClearingHouseCert,
    PBYTE                   pbClearingHouseCert,
    DWORD                   cbRootCertificate,
    PBYTE                   pbRootCertificate,
    DWORD                   cbKeyPackBlob,
    PBYTE                   pbKeyPackBlob )
{
    DWORD dwRetCode = ERROR_SUCCESS;
    DWORD cbSignedBlob, cbSignature;
    PBYTE pbSignedBlob = NULL, pcbSignature = NULL;
    Enveloped_Data EnvelopedData;

    if( 0 == hCryptProv )
    {
        return( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Get the enveloped data
    //

    memset( &EnvelopedData, 0, sizeof( Enveloped_Data ) );

    dwRetCode = UnpackEnvelopedData( &EnvelopedData, cbKeyPackBlob, pbKeyPackBlob );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }

    //
    // unpack the enveloped data to get the signed keypack blob
    //

    dwRetCode = GetEnvelopedData( 
                            LICENSE_KEYPACK_ENCRYPT_CRYPTO,
                            hCryptProv, 
                            &EnvelopedData, 
                            &cbSignedBlob, 
                            &pbSignedBlob 
                        );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }
    
    //
    // Get the license keypack from the signed blob.  We also provide the
    // clearing house certificate to verify the authenticity of the keypack.
    //

    dwRetCode = VerifyAndGetLicenseKeyPack( hCryptProv, pLicenseKeyPack, 
                                            cbClearingHouseCert, pbClearingHouseCert,
                                            cbRootCertificate, pbRootCertificate,
                                            cbSignedBlob, pbSignedBlob );

done:

    if( EnvelopedData.pbEncryptedKey )
    {
        LocalFree( EnvelopedData.pbEncryptedKey );
    }

    if( EnvelopedData.pbEncryptedData )
    {
        LocalFree( EnvelopedData.pbEncryptedData );
    }

    if( pbSignedBlob )
    {
        LocalFree( pbSignedBlob );
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
VerifyAndGetLicenseKeyPack(
    HCRYPTPROV          hCryptProv, 
    PLicense_KeyPack    pLicenseKeyPack,
    DWORD               cbSignerCert, 
    PBYTE               pbSignerCert,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate,
    DWORD               cbSignedBlob, 
    PBYTE               pbSignedBlob )
{
    DWORD dwRetCode = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = 0;
    HCERTSTORE hCertStore = 0;
    HCRYPTHASH hCryptHash = 0;
    HCRYPTKEY hPubKey = 0;
    PBYTE pbCopyPos = pbSignedBlob, pbSignedHash;
    PKeyPack_Description pKpDesc;
    DWORD i, cbSignedHash;
    
    SetLastError(ERROR_SUCCESS);

    //
    // make sure that the signed key blob is of the minimum size
    //

    if( cbSignedBlob < ( ( 8 * sizeof( DWORD ) ) + ( 3 * sizeof( FILETIME ) ) + 
                       sizeof( GUID ) ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // get a certificate context for the signer's certificate
    //

    dwRetCode = GetCertificate( cbSignerCert,
                                pbSignerCert,
                                hCryptProv,
                                &pCertContext,
                                &hCertStore );

    if( ERROR_SUCCESS != dwRetCode )
    {
        SetLastError(dwRetCode);
        goto ErrorReturn;
    }
    
    //
    // Verify the signer's certificate and the certificate chain that issued the
    // certificate.
    //

    dwRetCode = VerifyCertificateChain( hCertStore, pCertContext, 
                                        cbRootCertificate, pbRootCertificate );

    if( ERROR_SUCCESS != dwRetCode )
    {
        SetLastError(dwRetCode);
        goto ErrorReturn;
    }

    //
    // unpack the signed blob
    //
    memcpy( &pLicenseKeyPack->dwVersion, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );
    
    memcpy( &pLicenseKeyPack->dwKeypackType, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );
    
    memcpy( &pLicenseKeyPack->dwDistChannel, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );
    
    memcpy( &pLicenseKeyPack->KeypackSerialNum, pbCopyPos, sizeof( GUID ) );
    pbCopyPos += sizeof( GUID );
    
    memcpy( &pLicenseKeyPack->IssueDate, pbCopyPos, sizeof( FILETIME ) );
    pbCopyPos += sizeof( FILETIME );

    memcpy( &pLicenseKeyPack->ActiveDate, pbCopyPos, sizeof( FILETIME ) );
    pbCopyPos += sizeof( FILETIME );

    memcpy( &pLicenseKeyPack->ExpireDate, pbCopyPos, sizeof( FILETIME ) );
    pbCopyPos += sizeof( FILETIME );

    memcpy( &pLicenseKeyPack->dwBeginSerialNum, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwQuantity, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->cbProductId, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->cbProductId )
    {
        pLicenseKeyPack->pbProductId = LocalAlloc( GPTR, pLicenseKeyPack->cbProductId );

        if( NULL == pLicenseKeyPack->pbProductId )
        {
            goto ErrorReturn;
        }

        memcpy( pLicenseKeyPack->pbProductId, pbCopyPos, pLicenseKeyPack->cbProductId );
        pbCopyPos += pLicenseKeyPack->cbProductId;
    }

    memcpy( &pLicenseKeyPack->dwProductVersion, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwPlatformId, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwLicenseType, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    memcpy( &pLicenseKeyPack->dwDescriptionCount, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->dwDescriptionCount )
    {
        //
        // allocate memory for the keypack descriptions structure
        //

        pLicenseKeyPack->pDescription = LocalAlloc( GPTR, ( sizeof( KeyPack_Description ) * 
                                        pLicenseKeyPack->dwDescriptionCount ) );

        if( NULL == pLicenseKeyPack->pDescription )
        {
            goto ErrorReturn;
        }
        
        for( i = 0, pKpDesc = pLicenseKeyPack->pDescription; 
             i < pLicenseKeyPack->dwDescriptionCount; 
             i++, pKpDesc++ )
        {
            memcpy( &pKpDesc->Locale, pbCopyPos, sizeof( LCID ) );
            pbCopyPos += sizeof( LCID );

            memcpy( &pKpDesc->cbProductName, pbCopyPos, sizeof( DWORD ) );
            pbCopyPos += sizeof( DWORD );

            if( pKpDesc->cbProductName )
            {
                //
                // allocate memory for product name
                //
                
                pKpDesc->pbProductName = LocalAlloc( GPTR, pKpDesc->cbProductName );

                if( NULL == pKpDesc->pbProductName )
                {
                    goto ErrorReturn;
                }

                //
                // copy the product name
                //

                memcpy( pKpDesc->pbProductName, pbCopyPos, pKpDesc->cbProductName );
                pbCopyPos += pKpDesc->cbProductName;
            }

            memcpy( &pKpDesc->cbDescription, pbCopyPos, sizeof( DWORD ) );
            pbCopyPos += sizeof( DWORD );

            if( pKpDesc->cbDescription )
            {
                //
                // allocate memory for the keypack description
                //

                pKpDesc->pDescription = LocalAlloc( GPTR, pKpDesc->cbDescription );

                if( NULL == pKpDesc->pDescription )
                {
                    goto ErrorReturn;
                }

                //
                // copy the key pack description
                //

                memcpy( pKpDesc->pDescription, pbCopyPos, pKpDesc->cbDescription );
                pbCopyPos += pKpDesc->cbDescription;
            }
        }
    }

    memcpy( &pLicenseKeyPack->cbManufacturer, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->cbManufacturer )
    {
        pLicenseKeyPack->pbManufacturer = LocalAlloc( GPTR, pLicenseKeyPack->cbManufacturer );

        if( NULL == pLicenseKeyPack->pbManufacturer )
        {
            goto ErrorReturn;
        }

        memcpy( pLicenseKeyPack->pbManufacturer, pbCopyPos, pLicenseKeyPack->cbManufacturer );
        pbCopyPos += pLicenseKeyPack->cbManufacturer;
    }

    memcpy( &pLicenseKeyPack->cbManufacturerData, pbCopyPos, sizeof( DWORD ) );
    pbCopyPos += sizeof( DWORD );

    if( pLicenseKeyPack->cbManufacturerData )
    {
        pLicenseKeyPack->pbManufacturerData = LocalAlloc( GPTR, pLicenseKeyPack->cbManufacturerData );

        if( NULL == pLicenseKeyPack->pbManufacturerData )
        {
            goto ErrorReturn;
        }

        memcpy( pLicenseKeyPack->pbManufacturerData, pbCopyPos, pLicenseKeyPack->cbManufacturerData );
        pbCopyPos += pLicenseKeyPack->cbManufacturerData;
    }

    //
    // get the size and the pointer of the signed hash.
    //

    memcpy( &cbSignedHash, pbCopyPos, sizeof( DWORD ) );
    
    pbSignedHash = pbCopyPos + sizeof( DWORD );

    //
    // compute the hash
    //

    if( !CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &hCryptHash ) )
    {
        goto ErrorReturn;
    }

    
    if( !CryptHashData( hCryptHash, pbSignedBlob, (DWORD)(pbCopyPos - pbSignedBlob), 0 ) )
    {
        goto ErrorReturn;
    }

    //
    // import the public key
    //

    if( !CryptImportPublicKeyInfoEx( hCryptProv, X509_ASN_ENCODING, 
                                     &pCertContext->pCertInfo->SubjectPublicKeyInfo, 
                                     CALG_RSA_SIGN, 0, NULL, &hPubKey ) )
    {
        goto ErrorReturn;
    }
    
    //
    // use the public key to verify the signed hash
    //

    if( !CryptVerifySignature( hCryptHash, pbSignedHash, cbSignedHash, hPubKey, 
                               NULL, 0) )
    {
        goto ErrorReturn;
    }    
    
ErrorReturn:

    dwRetCode = GetLastError();

    if( hCryptHash )
    {
        CryptDestroyHash( hCryptHash );
    }

    if( hPubKey )
    {
        CryptDestroyKey( hPubKey );
    }

    if( pCertContext )
    {
        CertFreeCertificateContext( pCertContext );
    }

    if( hCertStore )
    {
        CertCloseStore( hCertStore, CERT_CLOSE_STORE_FORCE_FLAG );        
    }

    return( dwRetCode );
}

///////////////////////////////////////////////////////////////////////////////
//
// GetCertificate
//
// Get the first certificate from the certificate blob.  The certificate blob
// is in fact a certificate store that may contain a chain of certificates.
// This function also return handles to the crypto provider and the certificate
// store.
//
///////////////////////////////////////////////////////////////////////////////

DWORD WINAPI
GetCertificate(
    DWORD               cbCertificateBlob,
    PBYTE               pbCertificateBlob,
    HCRYPTPROV          hCryptProv,
    PCCERT_CONTEXT    * ppCertContext,
    HCERTSTORE        * phCertStore )
{
    CRYPT_DATA_BLOB CertBlob;
    DWORD dwRetCode = ERROR_SUCCESS;
    
    //
    // Open the PKCS7 certificate store
    //
    
    CertBlob.cbData = cbCertificateBlob;
    CertBlob.pbData = pbCertificateBlob;

    *phCertStore = CertOpenStore( sz_CERT_STORE_PROV_PKCS7,
                                  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                  hCryptProv,
                                  CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                  &CertBlob );

    if( NULL == ( *phCertStore ) )
    {
        return( GetLastError() );
    }

    //
    // get the first certificate from the store
    //

    *ppCertContext = CertEnumCertificatesInStore( *phCertStore, NULL );
    
    if( NULL == ( *ppCertContext ) )
    {
        return( GetLastError() );
    }
                    
    return( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
//
// VerifyCertificateChain
//
// Verify the certificate represented by the cert context against the 
// issuers in the certificate store.  The caller may provide a root
// certificate so that all issuers are eventually verified against this
// root certificate.  If no root certificate is provided, then the last
// issuer in the chain must be a self-signing issuer.
//
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
VerifyCertificateChain( 
    HCERTSTORE          hCertStore, 
    PCCERT_CONTEXT      pCertContext,
    DWORD               cbRootCertificate,
    PBYTE               pbRootCertificate )
{
    DWORD dwRetCode = ERROR_SUCCESS, dwFlags;
    PCCERT_CONTEXT pRootCertCtx = NULL;
    PCCERT_CONTEXT pIssuerCertCtx = NULL;
    PCCERT_CONTEXT pCurrentContext = NULL;

    if( ( 0 != cbRootCertificate ) && ( NULL != pbRootCertificate ) )
    {
        //
        // Get a certificate context for the root certificate
        //

        pRootCertCtx = CertCreateCertificateContext( X509_ASN_ENCODING, 
                                                     pbRootCertificate,
                                                     cbRootCertificate );

        if( NULL == pRootCertCtx )
        {
            dwRetCode = GetLastError();
            goto done;
        }
    }

    //
    // Verify the certificate chain.  The time, signature and validity of
    // the subject certificate is verified.  Only the signatures are verified
    // for the certificates in the issuer chain.
    //

    dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG |
              CERT_STORE_TIME_VALIDITY_FLAG;

    pCurrentContext = CertDuplicateCertificateContext( pCertContext );

    if (NULL == pCurrentContext)
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }

    do
    {   
        pIssuerCertCtx = NULL;
     
        pIssuerCertCtx = CertGetIssuerCertificateFromStore( hCertStore,
                                                            pCurrentContext,
                                                            pIssuerCertCtx,
                                                            &dwFlags );
        if( pIssuerCertCtx )
        {            
            //
            // Found the issuer, verify that the checks went OK
            //

            dwRetCode = GetCertVerificationResult( dwFlags );

            if( ERROR_SUCCESS != dwRetCode )
            {
                break;
            }
            
            //
            // only verify the signature for subsequent issuer certificates
            //

            dwFlags = CERT_STORE_SIGNATURE_FLAG;

            //
            // free the current certificate context and make the current issuer certificate
            // the subject certificate for the next iteration.
            //

            CertFreeCertificateContext( pCurrentContext );
            
            pCurrentContext = pIssuerCertCtx;
            
        }
        
    } while( pIssuerCertCtx );


    if( ERROR_SUCCESS != dwRetCode )
    {
        //
        // encountered some error while verifying the certificate
        //

        goto done;
    }

    //
    // we got here because we have walked through the chain of issuers in the
    // store.  The last issuer in the chain may or may not be a self signing root.
    //

    if( pRootCertCtx )
    {
        //
        // The caller has specified a root certificate that must be used.  Verify the
        // last issuer against this root certificate regardless of whether it is a
        // self signing root.
        //

        dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG  |
                  CERT_STORE_TIME_VALIDITY_FLAG;

        if( ( NULL == pCurrentContext ) || 
            ( !CertVerifySubjectCertificateContext( pCurrentContext, pRootCertCtx, &dwFlags ) ) )
        {
            dwRetCode = GetLastError();
            goto done;
        }

        //
        // get the certificate verification result
        //

        dwRetCode = GetCertVerificationResult( dwFlags );
    }
    else
    {
        //
        // if the caller did not specify a CA root certificate, make sure that the root
        // issuer of the certificate is a self-signed root.  Otherwise, return an error
        //

        if( CRYPT_E_SELF_SIGNED != GetLastError() )
        {
            dwRetCode = GetLastError();
        }
    }

done:
    
    if( pRootCertCtx )
    {
        CertFreeCertificateContext( pRootCertCtx );
    }

    if( pCurrentContext )
    {
        CertFreeCertificateContext( pCurrentContext );
    }

    if( pIssuerCertCtx )
    {
        CertFreeCertificateContext( pIssuerCertCtx );
    }

    return( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI
GetCertVerificationResult(
    DWORD dwFlags )
{
    if( dwFlags & CERT_STORE_SIGNATURE_FLAG )
    {
        //
        // The certificate signature did not verify
        //

        return( (DWORD )NTE_BAD_SIGNATURE );

    }
            
    if( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
    {
        //
        // The certificate has expired
        //

        return( ( DWORD )CERT_E_EXPIRED );
    }

    //
    // check if the cert has been revoked
    //

    if( dwFlags & CERT_STORE_REVOCATION_FLAG ) 
    {            
        if( !( dwFlags & CERT_STORE_NO_CRL_FLAG ) )
        {
            //
            // The certificate has been revoked
            //
                    
            return( ( DWORD )CERT_E_REVOKED );
        }
    }

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\inc\licemem.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997 - 1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#ifndef _LICEMEM_H_
#define _LICEMEM_H_

///////////////////////////////////////////////////////////////////////////////
// Memory API
//

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS 
LicenseMemoryAllocate( 
    ULONG Len, 
    PVOID UNALIGNED * ppMem );


VOID     
LicenseMemoryFree( 
    PVOID UNALIGNED * ppMem );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\clrhouse\test\kpdisk\kpdisk.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>

#include "licekpak.h"


///////////////////////////////////////////////////////////////////////////////
// The Manufacturing run ID used by this product.
//

GUID g_MfrId = { 0xdedaa678, 0xb83c, 0x11d1, { 0x9c, 0xb3, 0x00, 0xc0, 0x4f, 0xb1, 0x6e, 0x75 } };

void
EncodeDisk(
    DWORD dwSerialNum,
    char * szKeyContainer,
    char * szCertFile,
    char * szFileName );


void
DecodeDisk(
    char * szFileName );


DWORD
GetCertificate(
    char *  szCertFile,
    PBYTE * ppCert,
    PDWORD  pcbCert );

///////////////////////////////////////////////////////////////////////////////
void _cdecl main(int argc, char *argv[])
{
    DWORD dwSerialNum;
    char szFileName[255];
    char szKeyContainer[255];
    char szCertFile[255];

    if( 0 == _stricmp( "encode", argv[1] ) )
    {
        if( argc < 5 )
        {
            goto Usage;
        }

        //
        // encode a disk, get the serial number and file name
        //

        sscanf( argv[2], "%d", &dwSerialNum );
        sscanf( argv[3], "%s", szKeyContainer );
        sscanf( argv[4], "%s", szCertFile );
        sscanf( argv[5], "%s", szFileName );

        EncodeDisk( dwSerialNum, szKeyContainer, szCertFile, szFileName );

    } 
    else if ( 0 == _stricmp( "decode", argv[1] ) )
    {
        //
        // decode the disk
        //

        if( argc < 3 )
        {
            goto Usage;
        }

        sscanf( argv[2], "%s", szFileName );
        DecodeDisk( szFileName );

    }

    return;

Usage:

    printf( "Usage: \n" );
    printf( "encode serial_number key_container certificate_file filename\n" );
    printf( "decode filename\n" );

    return;

}


///////////////////////////////////////////////////////////////////////////////
void
EncodeDisk(
    DWORD dwSerialNum,
    char * szKeyContainer,
    char * szCertFile,
    char * szFileName )
{            
    License_KeyPack_Mfr_Info MfrInfo;
    DWORD dwRetCode;
    TCHAR tszFileName[255];
    TCHAR tszKeyContainer[255];

    mbstowcs( tszFileName, szFileName, strlen( szFileName ) + 1 );
    mbstowcs( tszKeyContainer, szKeyContainer, strlen( szKeyContainer ) + 1 );

    //
    // read the certificate file
    //

    MfrInfo.pbMfrCertificate    = NULL;
    MfrInfo.cbMfrCertificate    = 0;
    
    dwRetCode = GetCertificate( szCertFile, &MfrInfo.pbMfrCertificate,
                                &MfrInfo.cbMfrCertificate );

    if( ERROR_SUCCESS != dwRetCode )
    {
        printf( "cannot get certificate: 0x%x\n", dwRetCode );
        goto done;
    }

    //
    // take the manufacturer certificate file name as input and generate
    // a disk file containing the manufacturer info.
    //

    MfrInfo.dwVersion           = KEYPACK_MFR_INFO_VERSION_1_0;
    MfrInfo.ManufacturerId      = g_MfrId;
    MfrInfo.dwSequenceNumber    = dwSerialNum;
    MfrInfo.pbMfrSignature      = NULL;
    MfrInfo.cbMfrSignature      = 0;

    dwRetCode = EncodeKeyPackManufacturerInfo( &MfrInfo, tszKeyContainer, tszFileName );

    if( ERROR_SUCCESS != dwRetCode )
    {
        printf( "Cannot encode manufacturer info: 0x%x\n", dwRetCode );
    }

done:
    
    if( MfrInfo.pbMfrCertificate )
    {
        LocalFree( MfrInfo.pbMfrCertificate );
    }

    return;
}


///////////////////////////////////////////////////////////////////////////////
void
DecodeDisk(
    char * szFileName )
{
    TCHAR tszFileName[255];
    License_KeyPack_Mfr_Info MfrInfo;
    DWORD dwRetCode;
 
    mbstowcs( tszFileName, szFileName, strlen( szFileName ) + 1 );

    dwRetCode = DecodeKeyPackManufacturerInfo( &MfrInfo, tszFileName, 0, NULL );

    if( ERROR_SUCCESS != dwRetCode )
    {
        printf( "cannot decode manufacturer info\n" );
    }
    else
    {
        printf( "Manufacturer Version: 0x%x\n", MfrInfo.dwVersion );
        printf( "Manufacturer Serial Number: %d\n", MfrInfo.dwSequenceNumber );
    }

    return;
}


///////////////////////////////////////////////////////////////////////////////
DWORD
GetCertificate(
    char *  szCertFile,
    PBYTE * ppCert,
    PDWORD  pcbCert )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwRetCode = ERROR_SUCCESS, cbRead = 0;
    TCHAR tszCertFile[255];

    mbstowcs( tszCertFile, szCertFile, strlen( szCertFile ) + 1 );

    hFile = CreateFile( tszCertFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    {
        dwRetCode = GetLastError();
        goto done;
    }
    
    //
    // find out the size of the file
    //

    *pcbCert = GetFileSize( hFile, NULL );

    if( 0xFFFFFFFF == ( *pcbCert ) )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // allocate memory for reading the file content
    //

    *ppCert = LocalAlloc( GPTR, *pcbCert );

    if( NULL == ( *ppCert ) )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // read the manufacturer info
    //

    if( !ReadFile( hFile, *ppCert, *pcbCert, &cbRead, NULL ) )
    {
        dwRetCode = GetLastError();
    }

done:

    if( INVALID_HANDLE_VALUE != hFile )
    {
        CloseHandle( hFile );
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\clrhouse\test\kpcode\kpcode.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "licekpak.h"

#define AllocateMemory(size) LocalAlloc(LPTR, size)
#define FreeMemory(ptr) LocalFree(ptr)


#define ENCRYPTCONTAINER _TEXT("Encrypt")
#define DECRYPTCONTAINER _TEXT("Decrypt")

///////////////////////////////////////////////////////////////////////////////
// The keypack serial number
//

LPTSTR pszPID = _TEXT("This is a test");
GUID g_KeypackSN = { 0xdedaa678, 0xb83c, 0x11d1, { 0x9c, 0xb3, 0x00, 0xc0, 0x4f, 0xb1, 0x6e, 0x75 } };


DWORD
InitializeKeyPackInfo( 
    PLicense_KeyPack pLicenseKeyPack );


void
FreeLicenseKeyPack( 
    PLicense_KeyPack     pLicenseKeyPack );


void
PrintKeyPackInfo(
    PLicense_KeyPack    pLicenseKeyPack );


DWORD
EncodeKeyPack( 
    HCRYPTPROV       hCrypt,
    PLicense_KeyPack pLicenseKeyPack, 
    PBYTE            pbLSCert,
    DWORD            cbLSCert,
    PDWORD           pcbEncodedBlob, 
    PBYTE *          ppbEncodedBlob );


DWORD
DecodeKeyPack(     
    HCRYPTPROV      hCryptProv,
    PLicense_KeyPack    pLicenseKeyPack, 
    DWORD               cbEncodedBlob, 
    PBYTE               pbEncodedBlob,
    char *              pszCHCertFile, 
    char *              pszLSKeyContainer );


DWORD
GetCertificate(
    char *  szCertFile,
    PBYTE * ppCert,
    PDWORD  pcbCert );


///////////////////////////////////////////////////////////////////////////////

DWORD 
TLSSaveCertAsPKCS7(
    HCRYPTPROV hCryptProv,
    PBYTE pbCert, 
    DWORD cbCert, 
    PBYTE* ppbEncodedCert, 
    PDWORD pcbEncodedCert
    )
/*

*/
{
    DWORD           dwStatus=ERROR_SUCCESS;
    HCERTSTORE      hStore=NULL;
    PCCERT_CONTEXT  pCertContext=NULL;
    CRYPT_DATA_BLOB saveBlob;

    do {
        hStore=CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        hCryptProv,
                        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                        NULL
                    );

        if(!hStore)
        {
            dwStatus = GetLastError();
            break;
        }

        pCertContext = CertCreateCertificateContext(
                                            X509_ASN_ENCODING,
                                            pbCert,
                                            cbCert
                                        );

        if(!pCertContext)
        {
            dwStatus = GetLastError();
            break;
        }

        //
        // always start from empty so CERT_STORE_ADD_ALWAYS
        if(!CertAddCertificateContextToStore(
                                hStore, 
                                pCertContext, 
                                CERT_STORE_ADD_ALWAYS, 
                                NULL
                            ))
        {
            dwStatus = GetLastError();
            break;
        }

        memset(&saveBlob, 0, sizeof(saveBlob));

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          CERT_STORE_SAVE_AS_PKCS7,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0) && (dwStatus=GetLastError()) != ERROR_MORE_DATA)
        {
            dwStatus = GetLastError();
            break;
        }

        if(!(saveBlob.pbData = (PBYTE)AllocateMemory(saveBlob.cbData)))
        {
            dwStatus=GetLastError();
            break;
        }

        // save certificate into memory
        if(!CertSaveStore(hStore, 
                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                          CERT_STORE_SAVE_AS_PKCS7,
                          CERT_STORE_SAVE_TO_MEMORY,
                          &saveBlob,
                          0))
        {
            dwStatus = GetLastError();
            break;
        }
        
        *ppbEncodedCert = saveBlob.pbData;
        *pcbEncodedCert = saveBlob.cbData;

    } while(FALSE);    

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, CERT_CLOSE_STORE_FORCE_FLAG);
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////

HCRYPTPROV
CryptoInit(
    LPTSTR szContainer
    )
/*++

--*/
{
    HCRYPTPROV hProv;
    HCRYPTKEY hKey;

    // Attempt to acquire a handle to the default key container.
    if(!CryptAcquireContext(&hProv, szContainer, NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
    {
        // Create default key container.
        if(!CryptAcquireContext(&hProv, szContainer, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET)) 
        {
            return NULL;
        }
    }

    // Attempt to get handle to signature key.
    if(!CryptGetUserKey(hProv, AT_SIGNATURE, &hKey)) 
    {
        if(GetLastError() == NTE_NO_KEY && !CryptGenKey(hProv,AT_SIGNATURE,0,&hKey)) 
            return NULL;
    }

    CryptDestroyKey(hKey);

    // Attempt to get handle to exchange key.
    if(!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey)) 
    {
        if(GetLastError() == NTE_NO_KEY && !CryptGenKey(hProv, AT_KEYEXCHANGE, 0, &hKey)) 
            return NULL;
    }

    CryptDestroyKey(hKey);
    return hProv;
}

///////////////////////////////////////////////////////////////////////////////

const DWORD dwCertRdnValueType = CERT_RDN_PRINTABLE_STRING;

/////////////////////////////////////////////////////////////////////

DWORD
TLSExportPublicKey(
    IN HCRYPTPROV hCryptProv,
    IN DWORD      dwKeyType,
    IN OUT PDWORD pcbByte,
    IN OUT PCERT_PUBLIC_KEY_INFO  *ppbByte
    )
/*

*/
{
    BOOL bRetCode=TRUE;

    *pcbByte=0;
    *ppbByte=NULL;

    bRetCode = CryptExportPublicKeyInfo(
                    hCryptProv, 
                    dwKeyType, 
                    X509_ASN_ENCODING, 
                    NULL, 
                    pcbByte);
    if(bRetCode == FALSE)
        goto cleanup;
    
    if((*ppbByte=(PCERT_PUBLIC_KEY_INFO)AllocateMemory(*pcbByte)) == NULL)
        goto cleanup;

    bRetCode = CryptExportPublicKeyInfo(
                    hCryptProv, 
                    dwKeyType,
                    X509_ASN_ENCODING, 
                    *ppbByte, 
                    pcbByte);
    if(bRetCode == FALSE)
    {
        FreeMemory(*ppbByte);
        *pcbByte = 0;
    }

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

/////////////////////////////////////////////////////////////////////

DWORD 
TLSCryptEncodeObject(  
    IN  DWORD   dwEncodingType,
    IN  LPCSTR  lpszStructType,
    IN  const void * pvStructInfo,
    OUT PBYTE*  ppbEncoded,
    OUT DWORD*  pcbEncoded
    )
/*

Description:
    
    Allocate memory and encode object, wrapper for CryptEncodeObject()

*/
{
    DWORD dwStatus = ERROR_SUCCESS;

    if(!CryptEncodeObject(dwEncodingType, lpszStructType, pvStructInfo, NULL, pcbEncoded) ||
       (*ppbEncoded=(PBYTE)AllocateMemory(*pcbEncoded)) == NULL ||
       !CryptEncodeObject(dwEncodingType, lpszStructType, pvStructInfo, *ppbEncoded, pcbEncoded))
    {
        dwStatus=GetLastError();
    }

    return dwStatus;
}

/////////////////////////////////////////////////////////////////////

DWORD
TLSCryptSignAndEncodeCertificate(
    IN HCRYPTPROV  hCryptProv,
    IN DWORD dwKeySpec,
    IN PCERT_INFO pCertInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OUT PBYTE* ppbEncodedCert,
    IN OUT PDWORD pcbEncodedCert
    )
/*

*/
{
    BOOL bRetCode;

    bRetCode = CryptSignAndEncodeCertificate(  
                    hCryptProv,
                    dwKeySpec,
                    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
                    pCertInfo,
                    pSignatureAlgorithm,
                    NULL,
                    NULL,
                    pcbEncodedCert);

    if(bRetCode == FALSE && GetLastError() != ERROR_MORE_DATA)
        goto cleanup;

    *ppbEncodedCert=(PBYTE)AllocateMemory(*pcbEncodedCert);
    if(*ppbEncodedCert == FALSE)
        goto cleanup;

    bRetCode = CryptSignAndEncodeCertificate(  
                    hCryptProv,
                    AT_SIGNATURE,
                    X509_ASN_ENCODING,
                    X509_CERT_TO_BE_SIGNED,
                    pCertInfo,
                    pSignatureAlgorithm,
                    NULL,
                    *ppbEncodedCert,
                    pcbEncodedCert);

    if(bRetCode == FALSE)
    {
        FreeMemory(*ppbEncodedCert);
        *pcbEncodedCert = 0;
    }

cleanup:

    return (bRetCode) ? ERROR_SUCCESS : GetLastError();
}

/////////////////////////////////////////////////////////////////////

DWORD
CreateSelfSignCertificate(
    HCRYPTPROV hCryptProv,
    LPTSTR pszIssuer,
    DWORD dwKeySpec,
    PBYTE* ppbCert,
    PDWORD pcbCert
    )
/*++


--*/
{
    DWORD dwStatus=ERROR_SUCCESS;
    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm={ szOID_OIWSEC_sha1RSASign, 0, 0 };
    CERT_INFO CertInfo;
    PCERT_PUBLIC_KEY_INFO pbPublicKeyInfo=NULL;
    DWORD cbPublicKeyInfo=0;
    DWORD serialnumber;

    CERT_RDN_ATTR rgNameAttr[] = { 
        {   
            szOID_COMMON_NAME, 
            dwCertRdnValueType, 
            _tcslen(pszIssuer) * sizeof(TCHAR), 
            (UCHAR *)pszIssuer 
        }
    };
                                    
    CERT_RDN rgRDN[] = { sizeof(rgNameAttr)/sizeof(rgNameAttr[0]), &rgNameAttr[0] };
    CERT_NAME_INFO Name = {1, rgRDN};

    memset(&CertInfo, 0, sizeof(CERT_INFO));
    
    CertInfo.dwVersion = CERT_V3;
    CertInfo.SerialNumber.cbData = sizeof(DWORD);
    CertInfo.SerialNumber.pbData = (PBYTE)&serialnumber;
    CertInfo.SignatureAlgorithm = SignatureAlgorithm;

    TLSCryptEncodeObject(
                CRYPT_ASN_ENCODING,
                X509_NAME,
                &Name,
                &(CertInfo.Issuer.pbData),
                &(CertInfo.Issuer.cbData)
            );

    GetSystemTimeAsFileTime(&CertInfo.NotBefore);
    GetSystemTimeAsFileTime(&CertInfo.NotAfter);
    
    CertInfo.Subject.pbData = CertInfo.Issuer.pbData;
    CertInfo.Subject.cbData = CertInfo.Issuer.cbData;

    dwStatus = TLSExportPublicKey(
                        hCryptProv,
                        dwKeySpec,
                        &cbPublicKeyInfo,
                        &pbPublicKeyInfo
                    );

    if(dwStatus != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    CertInfo.SubjectPublicKeyInfo = *pbPublicKeyInfo;

    dwStatus = TLSCryptSignAndEncodeCertificate(
                            hCryptProv,
                            dwKeySpec,
                            &CertInfo,
                            &SignatureAlgorithm,
                            ppbCert,
                            pcbCert
                        );

cleanup:

    return dwStatus;
}

///////////////////////////////////////////////////////////////////////////////

void _cdecl main(int argc, char *argv[])
{
    License_KeyPack LicenseKeyPack;
    License_KeyPack DecodedKeyPack;
    PBYTE pbEncodedBlob;
    DWORD cbEncodedBlob;
    DWORD dwRetCode;

    HCRYPTPROV hTest;

    PBYTE pbEncryptCert;
    DWORD cbEncryptCert;
    
    PBYTE pbDecryptCert;
    DWORD cbDecryptCert;

    PBYTE pbEncryptCertPKCS7;
    DWORD cbEncryptCertPKCS7;
    
    PBYTE pbDecryptCertPKCS7;
    DWORD cbDecryptCertPKCS7;

    HCRYPTPROV  hEncrypt;
    HCRYPTPROV  hDecrypt;
    

    memset(&LicenseKeyPack, 0, sizeof(LicenseKeyPack));
    memset(&DecodedKeyPack, 0, sizeof(DecodedKeyPack));

    hTest = CryptoInit(_TEXT("Test"));
    if(hTest == NULL)
    {
        exit(0);
    }


    //
    // Initialize two crypto provider
    //
    hEncrypt = CryptoInit(ENCRYPTCONTAINER);
    if(hEncrypt == NULL)
    {
        exit(0);
    }

    hDecrypt = CryptoInit(DECRYPTCONTAINER);
    if(hDecrypt == NULL)
    {
        exit(0);
    }

    //
    // Generate two test certificate
    //
    if(CreateSelfSignCertificate(
                            hEncrypt,
                            ENCRYPTCONTAINER,
                            AT_KEYEXCHANGE,
                            &pbEncryptCert,
                            &cbEncryptCert
                        ) != ERROR_SUCCESS)
    {
        exit(0);
    }

    //
    // Generate two test certificate
    //
    if(CreateSelfSignCertificate(
                            hDecrypt,
                            DECRYPTCONTAINER,
                            AT_KEYEXCHANGE,
                            &pbDecryptCert,
                            &cbDecryptCert
                        ) != ERROR_SUCCESS)
    {
        exit(0);
    }

    TLSSaveCertAsPKCS7(
                hEncrypt,
                pbEncryptCert,
                cbEncryptCert,
                &pbEncryptCertPKCS7,
                &cbEncryptCertPKCS7
            );

    TLSSaveCertAsPKCS7(
                hDecrypt,
                pbDecryptCert,
                cbDecryptCert,
                &pbDecryptCertPKCS7,
                &cbDecryptCertPKCS7
            );

    //
    // initialize the license key pack with the information we want to
    // encode
    //

    memset( &LicenseKeyPack , 0, sizeof( License_KeyPack ) );

    dwRetCode = InitializeKeyPackInfo( &LicenseKeyPack );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }

    //
    // encode the license key pack.
    //

    dwRetCode = EncodeKeyPack( 
                        hTest,
                        &LicenseKeyPack, 
                        pbDecryptCertPKCS7, 
                        cbDecryptCertPKCS7,
                        &cbEncodedBlob, 
                        &pbEncodedBlob 
                    );

    if( ERROR_SUCCESS != dwRetCode )
    {
        printf( "cannot encode key pack: %d\n", dwRetCode );
        goto done;
    }
    
    memset( &DecodedKeyPack, 0, sizeof( License_KeyPack ) );

    if( ERROR_SUCCESS != dwRetCode )
    {
        goto done;
    }

    //
    // decode the license key pack
    //

    dwRetCode = DecodeKeyPack( 
                            hDecrypt,
                            &DecodedKeyPack, 
                            cbEncodedBlob, 
                            pbEncodedBlob,
                            pbDecryptCertPKCS7, 
                            cbDecryptCertPKCS7 
                        );

    if( ERROR_SUCCESS != dwRetCode )
    {
        printf( "cannot encode key pack: %d\n", dwRetCode );
        goto done;
    }

    //
    // print the information in the decoded license key pack
    //

    PrintKeyPackInfo( &DecodedKeyPack );

done:

    FreeLicenseKeyPack( &LicenseKeyPack );
    FreeLicenseKeyPack( &DecodedKeyPack );

    if( pbEncodedBlob )
    {
        LocalFree( pbEncodedBlob );
    }

    return;

Usage:

    printf( "Usage: \n" );
    printf( "LS_Certificate_File, LS_KeyContainer_Name, CH_Certificate_File, CH_KeyContainer_Name\n" );
    
    return;

}


#define KEYPACK_DESCRIPTION_1   L"Joe's BlockBuster Software"
#define KEYPACK_DESCRIPTION_2   L"Claire's Garage Bestseller"
#define KEYPACK_PRODUCTNAME_1   L"Joe and Claire's Most Excellent Compiler"
#define KEYPACK_PRODUCTNAME_2   L"NetWise Surfer"
#define MANUFACTURER            L"Joe and Claire"
#define MANUFACTURER_DATA       L"2356 Elm Street, Seattle, WA"
#define PRODUCT_ID              L"1234"

///////////////////////////////////////////////////////////////////////////////
DWORD
InitializeKeyPackInfo( 
    PLicense_KeyPack pLicenseKeyPack )
{
    SYSTEMTIME SystemTime;
    PKeyPack_Description pKpDesc;    

    pLicenseKeyPack->dwVersion = LICENSE_KEYPACK_VERSION_1_0;
    pLicenseKeyPack->dwKeypackType = LICENSE_KEYPACK_TYPE_MOLP;
    pLicenseKeyPack->dwDistChannel = LICENSE_DISTRIBUTION_CHANNEL_OEM; 

    memcpy( &pLicenseKeyPack->KeypackSerialNum, &g_KeypackSN, sizeof( GUID ) );

    //
    // setting all the time to the current time
    //

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &pLicenseKeyPack->IssueDate );    
    pLicenseKeyPack->ActiveDate = pLicenseKeyPack->IssueDate;
    pLicenseKeyPack->ExpireDate = pLicenseKeyPack->IssueDate;

    pLicenseKeyPack->dwBeginSerialNum = 9999;

    pLicenseKeyPack->dwQuantity = 799;

    pLicenseKeyPack->cbProductId = ( wcslen( PRODUCT_ID ) + 1 ) * sizeof( WCHAR );

    pLicenseKeyPack->pbProductId = LocalAlloc( GPTR, pLicenseKeyPack->cbProductId );

    memcpy( pLicenseKeyPack->pbProductId, PRODUCT_ID, pLicenseKeyPack->cbProductId );

    pLicenseKeyPack->dwProductVersion = 0x0000FFFF;

    pLicenseKeyPack->dwPlatformId = 0x0000FFFF;

    pLicenseKeyPack->dwLicenseType = 0xBEEFFACE;

    pLicenseKeyPack->dwDescriptionCount = 2;

    pLicenseKeyPack->pDescription = LocalAlloc( GPTR, 
                                                2 * sizeof( KeyPack_Description ) );

    if( NULL == pLicenseKeyPack->pDescription )
    {
        return( GetLastError() );
    }

    //
    // fill in the keypack descriptions
    //

    pKpDesc = pLicenseKeyPack->pDescription;

    pKpDesc->Locale = GetSystemDefaultLCID();

    pKpDesc->cbProductName = ( wcslen( KEYPACK_PRODUCTNAME_1 ) + 1 ) * sizeof( WCHAR );
    pKpDesc->pbProductName = LocalAlloc( GPTR, pKpDesc->cbProductName );

    if( NULL == pKpDesc->pbProductName )
    {
        return( GetLastError() );
    }

    memcpy( pKpDesc->pbProductName, KEYPACK_PRODUCTNAME_1, pKpDesc->cbProductName );

    pKpDesc->cbDescription = ( wcslen( KEYPACK_DESCRIPTION_1 ) + 1 ) * sizeof( WCHAR );
    pKpDesc->pDescription = LocalAlloc( GPTR, pKpDesc->cbDescription );

    if( NULL == pKpDesc->pDescription )
    {
        return( GetLastError() );
    }

    memcpy( pKpDesc->pDescription, KEYPACK_DESCRIPTION_1, pKpDesc->cbDescription );

    pKpDesc++;

    pKpDesc->Locale = GetSystemDefaultLCID();

    pKpDesc->cbProductName = ( wcslen( KEYPACK_PRODUCTNAME_2 ) + 1 ) * sizeof( WCHAR );
    pKpDesc->pbProductName = LocalAlloc( GPTR, pKpDesc->cbProductName );

    if( NULL == pKpDesc->pbProductName )
    {
        return( GetLastError() );
    }

    memcpy( pKpDesc->pbProductName, KEYPACK_PRODUCTNAME_2, pKpDesc->cbProductName );

    pKpDesc->cbDescription = ( wcslen( KEYPACK_DESCRIPTION_2 ) + 1 ) * sizeof( WCHAR );
    pKpDesc->pDescription = LocalAlloc( GPTR, pKpDesc->cbDescription );

    if( NULL == pKpDesc->pDescription )
    {
        return( GetLastError() );
    }

    memcpy( pKpDesc->pDescription, KEYPACK_DESCRIPTION_2, pKpDesc->cbDescription );

    pLicenseKeyPack->cbManufacturer = ( wcslen( MANUFACTURER ) + 1 ) * sizeof( WCHAR );

    pLicenseKeyPack->pbManufacturer = LocalAlloc( GPTR, pLicenseKeyPack->cbManufacturer );

    if( NULL == pLicenseKeyPack->pbManufacturer )
    {
        return( GetLastError() );
    }

    memcpy( pLicenseKeyPack->pbManufacturer, MANUFACTURER, pLicenseKeyPack->cbManufacturer );

    pLicenseKeyPack->cbManufacturerData = ( wcslen( MANUFACTURER_DATA ) + 1 ) * sizeof( WCHAR );

    pLicenseKeyPack->pbManufacturerData = LocalAlloc( GPTR, pLicenseKeyPack->cbManufacturerData );

    if( NULL == pLicenseKeyPack->pbManufacturerData )
    {
        return( GetLastError() );
    }

    memcpy( pLicenseKeyPack->pbManufacturerData, MANUFACTURER_DATA, pLicenseKeyPack->cbManufacturerData );

    return( ERROR_SUCCESS );
}


///////////////////////////////////////////////////////////////////////////////
void
FreeLicenseKeyPack( 
    PLicense_KeyPack     pLicenseKeyPack )
{
    DWORD i;

    PKeyPack_Description pKpDesc;

    if( pLicenseKeyPack->pDescription )
    {
        for( i = 0, pKpDesc = pLicenseKeyPack->pDescription;
             i < pLicenseKeyPack->dwDescriptionCount;
             i++, pKpDesc++ )
        {
            LocalFree( pKpDesc->pDescription );
        }
    }

    LocalFree( pLicenseKeyPack->pDescription );
    LocalFree( pLicenseKeyPack->pbManufacturer );
    LocalFree( pLicenseKeyPack->pbManufacturerData );

    return;
}


///////////////////////////////////////////////////////////////////////////////
void
PrintKeyPackInfo(
    PLicense_KeyPack    pLicenseKeyPack )
{
    DWORD i;
    PKeyPack_Description pKpDesc;

    printf( "Keypack version: 0x%x\n", pLicenseKeyPack->dwVersion );

    printf( "Keypack type: 0x%x\n", pLicenseKeyPack->dwKeypackType );

    printf( "Keypack distribution channel: 0x%x\n", pLicenseKeyPack->dwDistChannel );

    printf( "Keypack serial number: 0x%x-0x%x-0x%x-0x%x%x%x%x%x%x%x%x\n", 
            pLicenseKeyPack->KeypackSerialNum.Data1,
            pLicenseKeyPack->KeypackSerialNum.Data2,
            pLicenseKeyPack->KeypackSerialNum.Data3,
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[0],
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[1],
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[2],
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[3],
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[4],
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[5],
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[6],
            ( DWORD )pLicenseKeyPack->KeypackSerialNum.Data4[7] );

    printf( "Keypack Quantity: %d\n", pLicenseKeyPack->dwQuantity );

    printf( "Keypack Product Id: %S\n", pLicenseKeyPack->pbProductId );

    printf( "Keypack product version: 0x%x\n", pLicenseKeyPack->dwProductVersion );

    printf( "Keypack platform Id: 0x%x\n", pLicenseKeyPack->dwPlatformId );

    printf( "Keypack license type: 0x%x\n", pLicenseKeyPack->dwLicenseType );

    if( pLicenseKeyPack->dwDescriptionCount )
    {
        for( i = 0, pKpDesc = pLicenseKeyPack->pDescription;
             i < pLicenseKeyPack->dwDescriptionCount;
             i++, pKpDesc++ )
        {
            printf( "Keypack Product Name: %S\n", pKpDesc->pbProductName );
            printf( "Keypack Description: %S\n", pKpDesc->pDescription );            
        }
    }

    printf( "Keypack Manufacturer: %S\n", pLicenseKeyPack->pbManufacturer );
    printf( "Keypack Manufacturer data: %S\n", pLicenseKeyPack->pbManufacturerData );

    return;
}


///////////////////////////////////////////////////////////////////////////////
DWORD
EncodeKeyPack( 
    HCRYPTPROV       hCrypt,
    PLicense_KeyPack pLicenseKeyPack, 
    PBYTE            pbLSCert,
    DWORD            cbLSCert,
    PDWORD           pcbEncodedBlob, 
    PBYTE *          ppbEncodedBlob )
{
    DWORD dwRetCode = ERROR_SUCCESS;

    //
    // encode the license keypack info
    //
    LicensePackEncodeParm parm;

    memset(&parm, 0, sizeof(LicensePackEncodeParm));

    parm.dwEncodeType = LICENSE_KEYPACK_ENCRYPT_ALWAYSFRENCH;
    parm.hCryptProv = hCrypt;
    parm.pbEncryptParm = pbLSCert;
    parm.cbEncryptParm = cbLSCert;

    dwRetCode = EncodeLicenseKeyPackEx( 
                                pLicenseKeyPack,
                                &parm,
                                ppbEncodedBlob,
                                pcbEncodedBlob
                            );

done:

    return( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
DWORD
DecodeKeyPack( 
    HCRYPTPROV          hCrypt,
    PLicense_KeyPack    pLicenseKeyPack, 
    DWORD               cbEncodedBlob, 
    PBYTE               pbEncodedBlob,
    PBYTE               pbCHCert,
    DWORD               cbCHCert )
{
    DWORD dwRetCode = ERROR_SUCCESS;

    LicensePackDecodeParm parm;

    memset(&parm, 0, sizeof(parm));
    parm.hCryptProv = hCrypt;
    parm.pbDecryptParm = (PBYTE)pszPID;
    parm.cbDecryptParm = (lstrlen(pszPID) + 1) * sizeof(TCHAR);
    parm.cbClearingHouseCert = cbCHCert;
    parm.pbClearingHouseCert = pbCHCert;

    parm.pbRootCertificate = pbCHCert;
    parm.cbRootCertificate = cbCHCert;
    
    dwRetCode = DecodeLicenseKeyPackEx( 
                                    pLicenseKeyPack,
                                    &parm,
                                    cbEncodedBlob,
                                    pbEncodedBlob 
                                );
done:

    return( dwRetCode );
}


///////////////////////////////////////////////////////////////////////////////
DWORD
GetCertificate(
    char *  szCertFile,
    PBYTE * ppCert,
    PDWORD  pcbCert )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwRetCode = ERROR_SUCCESS, cbRead = 0;
    TCHAR tszCertFile[255];

    mbstowcs( tszCertFile, szCertFile, strlen( szCertFile ) + 1 );

    hFile = CreateFile( tszCertFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    {
        dwRetCode = GetLastError();
        goto done;
    }
    
    //
    // find out the size of the file
    //

    *pcbCert = GetFileSize( hFile, NULL );

    if( 0xFFFFFFFF == ( *pcbCert ) )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // allocate memory for reading the file content
    //

    *ppCert = LocalAlloc( GPTR, *pcbCert );

    if( NULL == ( *ppCert ) )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    //
    // read the manufacturer info
    //

    if( !ReadFile( hFile, *ppCert, *pcbCert, &cbRead, NULL ) )
    {
        dwRetCode = GetLastError();
    }

done:

    if( INVALID_HANDLE_VALUE != hFile )
    {
        CloseHandle( hFile );
    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\inc\sysapi.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        sysapi.h
//
// Contents:    Support APIs used by licensing code
//
// History:     01-10-98    FredCh  Created
//
//-----------------------------------------------------------------------------


#ifndef _SYSAPI_H_
#define _SYSAPI_H_

#include "protect.h"
#include "licemem.h"

///////////////////////////////////////////////////////////////////////////////
// Binary blob API
//

VOID
CopyBinaryBlob(
    PBYTE           pbBuffer, 
    PBinary_Blob    pbbBlob, 
    DWORD *         pdwCount );


LICENSE_STATUS
GetBinaryBlob(
    PBinary_Blob    pBBlob,
    PBYTE           pMessage,
    PDWORD          pcbProcessed );


VOID
FreeBinaryBlob(
    PBinary_Blob pBlob );


#define GetBinaryBlobSize( _Blob ) sizeof( WORD ) + sizeof( WORD ) + _Blob.wBlobLen


#define InitBinaryBlob( _pBlob )    \
    ( _pBlob )->pBlob = NULL;       \
    ( _pBlob )->wBlobLen = 0;       


///////////////////////////////////////////////////////////////////////////////
// Hydra server certificate, public and private key API
//

LICENSE_STATUS
GetServerCertificate(
    CERT_TYPE       CertType,
    PBinary_Blob    pCertBlob,
    DWORD           dwKeyAlg );


LICENSE_STATUS
GetHydraServerPrivateKey(
    CERT_TYPE   CertType,
    PBYTE *     ppPrivateKey,
    PDWORD      pcbPrivateKey );


///////////////////////////////////////////////////////////////////////////////
// character conversion macros.  Note: These macros allocate memory from
// the program stack, so the returned memory does not need to be explicitly freed.
//

#define M2W( _pWchar, _pMchar ) \
    _pWchar = _alloca( ( _mbslen( ( unsigned char * )_pMchar ) + 1 ) * sizeof( WCHAR ) ); \
    if( _pWchar ) \
    {   \
        mbstowcs( _pWchar, ( unsigned char * )_pMchar, _mbslen( ( unsigned char * )_pMchar ) + 1 ); \
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\inc\licemem.inc ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
LicenseMemoryAllocate( ULONG Length, PVOID UNALIGNED * ppMemory )
{    
    if( 0 == Length )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppMemory = LocalAlloc( LMEM_ZEROINIT, Length );

    if( NULL == *ppMemory )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    return( LICENSE_STATUS_OK );
}


///////////////////////////////////////////////////////////////////////////////
VOID
LicenseMemoryFree( PVOID UNALIGNED * ppMemory )
{
    if( NULL == *ppMemory )
    {
        return;
    }

    LocalFree( *ppMemory );
    *ppMemory = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\decode.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        decode.h
//
// Contents:    License decoding API
//
// History:     01-21-98    FredCh  Created
//
//-----------------------------------------------------------------------------

#ifndef _DECODE_H_
#define _DECODE_H_

LICENSE_STATUS
DecodeLicense(
    PLicense_Verification_Data    pDecodedData,
    DWORD                         cbLicense,
    PBYTE                         pLicense );


LICENSE_STATUS
DecodeLicenseObject(
    LPCSTR          lpszStructType,
    const BYTE   *  pbEncoded,
    DWORD           cbEncoded,
    PVOID *         ppObject );


LICENSE_STATUS
DecodeSubjectField(
    BYTE *                      pbEncoded, 
    DWORD                       cbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
DecodeLicenseExtension( 
    DWORD               cExt, 
    PCERT_EXTENSION     pExt,
    PBYTE *             ppExtensionData,
    LPSTR               pszExtensionOID );


LICENSE_STATUS
DecodeSignedContent(
    BYTE *                      pbEncoded,
    DWORD                       cbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
DecodeLicenseInfo( 
    PCERT_INFO                  pInfo,
    DWORD                       cbEncoded,
    PBYTE                       pbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
PrintLicenseInfo( 
    PCERT_INFO                  pInfo,
    DWORD                       cbEncoded,
    PBYTE                       pbEncoded,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
DecodeName(
    BYTE *pbEncoded, 
    DWORD cbEncoded );


void 
PrintBytes(
    LPCSTR  pszHdr, 
    BYTE    *pb, 
    DWORD   cbSize );


LPCSTR 
FileTimeText( 
    FILETIME *pft );


void 
PrintExtensions(
    DWORD           cExt, 
    PCERT_EXTENSION pExt);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\inc\protect.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef _PROTECT_H_
#define _PROTECT_H_

//////////////////////////////////////////////////////////////////////////////
//  Citrical section macros
//

#define INITLOCK( _sem ) \
{ \
    InitializeCriticalSection( _sem ); \
}

#define DELETELOCK( _sem ) \
{ \
    DeleteCriticalSection( _sem ); \
}

#define LOCK( _sem ) \
{ \
    EnterCriticalSection( _sem ); \
}

#define UNLOCK( _sem ) \
{ \
    LeaveCriticalSection( _sem ); \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\hspack.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       HSpack.h
//
//  Contents:	Functions that are used to pack and unpack different messages
//				going out and coming in from the server
//  Classes:
//
//  Functions:
//
//  History:    12-20-97  v-sbhatt   Created
//
//----------------------------------------------------------------------------

#ifndef	_HSPACK_H_
#define _HSPACK_H_

//
// Functions for Packing different Server Messages from the corresponding
// structures to simple binary blob
//

LICENSE_STATUS
PackHydraServerLicenseRequest(
    DWORD                           dwProtocolVersion,
    PHydra_Server_License_Request   pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );

LICENSE_STATUS
PackHydraServerPlatformChallenge(
    DWORD                               dwProtocolVersion,
    PHydra_Server_Platform_Challenge    pCanonical,
    PBYTE *                             ppbBuffer,
    DWORD *                             pcbBuffer );

LICENSE_STATUS
PackHydraServerNewLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_New_License       pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );

LICENSE_STATUS
PackHydraServerUpgradeLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_Upgrade_License   pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );

LICENSE_STATUS
PackHydraServerErrorMessage(
    DWORD                           dwProtocolVersion,
    PLicense_Error_Message          pCanonical,
    PBYTE *                         ppbBuffer,
    DWORD *                         pcbBuffer );


LICENSE_STATUS
PackNewLicenseInfo(
    PNew_License_Info               pCanonical,
    PBYTE *                         ppNetwork, 
    DWORD *                         pcbNetwork );

//
// Functions for unpacking different Hydra Client Messages from 
// simple binary blobs to corresponding structure
//

				
LICENSE_STATUS
UnPackHydraClientErrorMessage(
    PBYTE                   pbMessage,
    DWORD                   cbMessage,
    PLicense_Error_Message  pCanonical );


LICENSE_STATUS
UnPackHydraClientLicenseInfo(
    PBYTE                       pbMessage,
    DWORD                       cbMessage, 
    PHydra_Client_License_Info  pCanonical );


LICENSE_STATUS
UnPackHydraClientNewLicenseRequest(
    PBYTE                               pbMessage,
    DWORD                               cbMessage,
    PHydra_Client_New_License_Request   pCanonical );


LICENSE_STATUS
UnPackHydraClientPlatformChallengeResponse(
    PBYTE                                       pbMessage,
    DWORD                                       cbMessage,
    PHydra_Client_Platform_Challenge_Response   pCanonical );

#endif	//_HSPACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\licprot.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        licprot.c
//
// Contents:    Implementation of Hydra Server License Protocol API
//
// History:     02-08-00    RobLeit  Created
//
//-----------------------------------------------------------------------------

#include "precomp.h"
#include <rpcnterr.h>
#include <lmapibuf.h>

#include "licemem.inc"
#include <srvdef.h>

VOID 
LogLicensingTimeBombExpirationEvent();

void
ThrottleLicenseLogEvent(
    WORD        wEventType,
    DWORD       dwEventId,
    WORD        cStrings,
    PWCHAR    * apwszStrings );

LICENSE_STATUS
LsStatusToLicenseStatus(
    DWORD       LsStatus,
    DWORD       LsStatusDefault
);

#define LS_DISCOVERY_TIMEOUT (1*1000)

// Copied from tlserver\server\srvdef.h
#define PERMANENT_LICENSE_EXPIRE_DATE   INT_MAX

#define SECONDS_IN_A_DAY                86400   // number of seconds in a day

#define TERMINAL_SERVICE_EVENT_LOG      L"TermService"

///////////////////////////////////////////////////////////////////////////////
//
// Global variables
//

HANDLE g_hEventLog = NULL;
BOOL g_fEventLogOpen = FALSE;
CRITICAL_SECTION g_EventLogCritSec;
DWORD g_dwLicenseExpirationLeeway = PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY;
DWORD g_dwTerminalServerVersion;

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
InitializeProtocolLib()
{
    LICENSE_STATUS lsStatus;

    //
    // initialize the cert util library
    //

    if (LSInitCertutilLib( 0 ))
    {
        __try
        {
            INITLOCK( &g_EventLogCritSec );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {

            return LICENSE_STATUS_OUT_OF_MEMORY;
        }

        g_hEventLog = RegisterEventSource( NULL, TERMINAL_SERVICE_EVENT_LOG );

        if (NULL != g_hEventLog)
        {
            g_fEventLogOpen = TRUE;
        }
    }
    else
    {
        return LICENSE_STATUS_SERVER_ABORT;
    }

    lsStatus = InitializeLicensingTimeBomb();

    if (lsStatus == LICENSE_STATUS_OK)
    {
        DWORD dwStatus;
        HKEY hKey;

        DWORD dwOSVersion = GetVersion();
        g_dwTerminalServerVersion = (DWORD)(HIBYTE(LOWORD(dwOSVersion)));
        g_dwTerminalServerVersion |= (DWORD)(LOBYTE(LOWORD(dwOSVersion)) << 16);

        dwStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE, HYDRA_SERVER_PARAM, 0,
                NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey,
                NULL);

        if (dwStatus == ERROR_SUCCESS)
        {
            DWORD dwBuffer;
            DWORD cbBuffer = sizeof(DWORD);

            dwStatus = RegQueryValueEx(hKey, PERSEAT_LEEWAY_VALUE, NULL, NULL,
                    (LPBYTE)&dwBuffer, &cbBuffer);

            if (dwStatus == ERROR_SUCCESS)
            {
                g_dwLicenseExpirationLeeway = min(dwBuffer,
                        PERMANENT_LICENSE_LEASE_EXPIRE_LEEWAY);
            }
            
            
        }
    }

    return lsStatus;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ShutdownProtocolLib()
{
    //
    // shut down cert util library
    //

    g_fEventLogOpen = FALSE;

    DeregisterEventSource( g_hEventLog );

    g_hEventLog = NULL;

    DELETELOCK(&g_EventLogCritSec);

    LSShutdownCertutilLib();

    return( LICENSE_STATUS_OK );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CreateProtocolContext(
    IN  LPLICENSE_CAPABILITIES  pLicenseCap,
    OUT HANDLE *    phContext)
{
    LICENSE_STATUS Status;
    PHS_Protocol_Context pLicenseContext = NULL;

    //
    // allocate the protocol context
    //

    Status = LicenseMemoryAllocate( sizeof( HS_Protocol_Context ), &pLicenseContext );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    //
    // Note: InitializeCriticalSection could throw an exception during
    // low memory conditions.
    //

    __try
    {
        INITLOCK( &pLicenseContext->CritSec );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {

#if DBG
        DbgPrint( "LICPROT: CreateLicenseContext: InitializeCriticalSection exception: 0x%x\n",
                  GetExceptionCode() );
#endif

        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto error;                
    }

    pLicenseContext->hLSHandle = NULL;
    pLicenseContext->State = INIT;
    pLicenseContext->dwProtocolVersion = LICENSE_HIGHEST_PROTOCOL_VERSION;
    pLicenseContext->fAuthenticateServer = TRUE;
    pLicenseContext->CertTypeUsed = CERT_TYPE_INVALID;
    pLicenseContext->dwKeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;
    pLicenseContext->fLoggedProtocolError = FALSE;

    //
    // Initialize the crypto context parameters
    //

    pLicenseContext->CryptoContext.dwCryptState    = CRYPT_SYSTEM_STATE_INITIALIZED;
    pLicenseContext->CryptoContext.dwSessKeyAlg    = BASIC_RC4_128;
    pLicenseContext->CryptoContext.dwMACAlg        = MAC_MD5_SHA;



    if (NULL != pLicenseCap)
    {
        //
        // initialize the license context with the incoming data.
        //

        pLicenseContext->fAuthenticateServer = pLicenseCap->fAuthenticateServer;
        pLicenseContext->dwProtocolVersion = pLicenseCap->ProtocolVer;
    
        //
        // If the client is not authenticating the server, this means that
        // the client already has our certificate.  But we need to know which
        // certificate the client has.
        //

        if( FALSE == pLicenseContext->fAuthenticateServer )
        {
            pLicenseContext->CertTypeUsed = pLicenseCap->CertType;
        }

        //
        // remember the client's machine name
        //
        
        if( pLicenseCap->pbClientName )
        {
            Status = LicenseMemoryAllocate( 
                                           pLicenseCap->cbClientName,
                                           &pLicenseContext->ptszClientMachineName );
            
            if( LICENSE_STATUS_OK == Status )
            {
                //
                // copy the client machine name
                //
                
                memcpy( pLicenseContext->ptszClientMachineName, 
                        pLicenseCap->pbClientName,
                        pLicenseCap->cbClientName );
            }
            else
            {
                goto error;
            }
        }
    }
    else
    {
        pLicenseContext->ptszClientMachineName = NULL;
    }

    *phContext = ( HANDLE )pLicenseContext;

    return( Status );

error:

    //
    // encountered error creating context, free allocated memory before
    // returning
    //

    if( pLicenseContext )
    {
        if (pLicenseContext->ptszClientMachineName)
        {
            LicenseMemoryFree(&pLicenseContext->ptszClientMachineName);
        }

       LicenseMemoryFree( &pLicenseContext );
    }

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
DeleteProtocolContext(
    HANDLE hContext )
{
    PHS_Protocol_Context pLicenseContext = ( PHS_Protocol_Context )hContext;

    if( NULL == pLicenseContext )
    {
        return( LICENSE_STATUS_INVALID_SERVER_CONTEXT );
    }

    LOCK( &pLicenseContext->CritSec );

    if (pLicenseContext->hLSHandle != NULL)
    {
        TLSDisconnectFromServer(pLicenseContext->hLSHandle);
        pLicenseContext->hLSHandle = NULL;
    }

    if( pLicenseContext->ProductInfo.pbCompanyName )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbCompanyName );
    }

    if( pLicenseContext->ProductInfo.pbProductID )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbProductID );
    }

    if( pLicenseContext->ptszClientUserName )
    {
        LicenseMemoryFree( &pLicenseContext->ptszClientUserName );
    }

    if( pLicenseContext->ptszClientMachineName )
    {
        LicenseMemoryFree( &pLicenseContext->ptszClientMachineName );
    }

    if( pLicenseContext->pbOldLicense )
    {
        LicenseMemoryFree( &pLicenseContext->pbOldLicense );
    }
    
    //
    // Free the license info that's being cached
    //

    if( pLicenseContext->pTsLicenseInfo )
    {
        LicenseMemoryFree( &pLicenseContext->pTsLicenseInfo );
    }

    UNLOCK( &pLicenseContext->CritSec );
 
    DELETELOCK( &pLicenseContext->CritSec );
    
    LicenseMemoryFree( &pLicenseContext );
        
    return( LICENSE_STATUS_OK );

}

///////////////////////////////////////////////////////////////////////////////
void
HandleErrorCondition( 
    PHS_Protocol_Context   pLicenseContext,
    PDWORD                      pcbOutBuf, 
    PBYTE *                     ppOutBuf, 
    LICENSE_STATUS *            pStatus )
{
    License_Error_Message ErrorMsg;
    LICENSE_STATUS licenseStatus;

    //
    // returns the correct error code based on the error condition
    //

    switch( *pStatus )
    {
    case( LICENSE_STATUS_NO_LICENSE_SERVER ):

        ErrorMsg.dwErrorCode            = GM_HS_ERR_NO_LICENSE_SERVER;
        ErrorMsg.dwStateTransition      = ST_NO_TRANSITION;
        
        break;

    case( LICENSE_STATUS_INVALID_MAC_DATA ):

        ErrorMsg.dwErrorCode            = GM_HC_ERR_INVALID_MAC;
        ErrorMsg.dwStateTransition      = ST_TOTAL_ABORT;
        
        break;

    //
    // Handle all other error conditions as invalid client
    //

    case( LICENSE_STATUS_INVALID_RESPONSE ):        
    default:
        
        ErrorMsg.dwErrorCode            = GM_HS_ERR_INVALID_CLIENT;
        ErrorMsg.dwStateTransition      = ST_TOTAL_ABORT;        
        
        break;
    }

    //
    // for now, we are not sending any error string
    //

    ErrorMsg.bbErrorInfo.wBlobLen   = 0;
    ErrorMsg.bbErrorInfo.pBlob      = NULL;

    //
    // pack the error message
    //

    licenseStatus = PackHydraServerErrorMessage( 
                        pLicenseContext->dwProtocolVersion, 
                        &ErrorMsg, 
                        ppOutBuf, 
                        pcbOutBuf );

    if( LICENSE_STATUS_OK != licenseStatus )
    {
#if DBG
        DbgPrint( "HandleErrorConditions: cannot pack error message: 0x%x\n", *pStatus );
#endif
        *pStatus = LICENSE_STATUS_SERVER_ABORT;
    }

    return;
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CreateHydraServerHello( 
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf )
{
    Hydra_Server_License_Request LicenseRequest;
    LICENSE_STATUS Status;
    Binary_Blob ScopeBlob;
    CHAR szScope[] = SCOPE_NAME;
    DWORD dwCertSize;

    //
    // generate a server random number
    //

    GenerateRandomBits( LicenseRequest.ServerRandom, LICENSE_RANDOM );

    memcpy( pLicenseContext->CryptoContext.rgbServerRandom, 
            LicenseRequest.ServerRandom, 
            LICENSE_RANDOM );

    //
    // fill in the product info.  Allocate memory for and initialize the
    // license context copy of the product info and then just copy the
    // same product info to the license request.
    // NOTE: This info should probably be passed in in the future
    //

    Status = InitProductInfo( 
                        &( pLicenseContext->ProductInfo ), 
                        PRODUCT_INFO_SKU_PRODUCT_ID );
    
    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "CreateHydraServerHello: cannot init product info: 0x%x\n", Status );
#endif
        goto no_request;
    }


    memcpy( &LicenseRequest.ProductInfo, 
            &pLicenseContext->ProductInfo, 
            sizeof( Product_Info ) );    
    
    //
    // get the hydra server certificate and fill in the key exchange list
    //

    LicenseRequest.KeyExchngList.wBlobType    = BB_KEY_EXCHG_ALG_BLOB;
    LicenseRequest.KeyExchngList.wBlobLen     = sizeof( DWORD );
    LicenseRequest.KeyExchngList.pBlob        = ( PBYTE )&pLicenseContext->dwKeyExchangeAlg;

    LicenseRequest.ServerCert.pBlob = NULL;
    LicenseRequest.ServerCert.wBlobLen = 0;

    //
    // We may or may not have to send the client the certificate depending on whether the
    // client is authenticating the server.
    //

    if( TRUE == pLicenseContext->fAuthenticateServer )
    {
        //
        // decide on what kind of certificate to get depending on the client's version.
        // Pre-Hydra 5.0 clients only knows how to decode proprietory certificate.
        // Use X509 certificate for all other clients.
        //

        if( CERT_TYPE_INVALID == pLicenseContext->CertTypeUsed )
        {
            if( PREAMBLE_VERSION_3_0 > GET_PREAMBLE_VERSION( pLicenseContext->dwProtocolVersion ) )
            {
                pLicenseContext->CertTypeUsed = CERT_TYPE_PROPRIETORY;
            }
            else
            {
                pLicenseContext->CertTypeUsed = CERT_TYPE_X509;
            }
        }

        Status = TLSGetTSCertificate( 
                        pLicenseContext->CertTypeUsed,
                        &LicenseRequest.ServerCert.pBlob, 
                        &dwCertSize);

        LicenseRequest.ServerCert.wBlobLen = LOWORD(dwCertSize);
        LicenseRequest.ServerCert.wBlobType = BB_CERTIFICATE_BLOB;

        if( ( LICENSE_STATUS_OK != Status ) &&
            ( CERT_TYPE_X509 == pLicenseContext->CertTypeUsed ) )
        {
            //
            // if we cannot get the X509 certificate chain, use the proprietory
            // certificate.
            //

            pLicenseContext->CertTypeUsed = CERT_TYPE_PROPRIETORY;

            Status = TLSGetTSCertificate( 
                        pLicenseContext->CertTypeUsed,
                        &LicenseRequest.ServerCert.pBlob, 
                        &dwCertSize);

            LicenseRequest.ServerCert.wBlobLen = LOWORD(dwCertSize);
            LicenseRequest.ServerCert.wBlobType = BB_CERTIFICATE_BLOB;

        }

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: cannot get server certificate: %x\n", Status );
#endif
            goto no_request;
        }
    }

    //
    // fill in the scope info.  This info may be passed in in the future.
    //

    LicenseRequest.ScopeList.dwScopeCount       = 1;
    LicenseRequest.ScopeList.Scopes             = &ScopeBlob;

    ScopeBlob.wBlobType  = BB_SCOPE_BLOB;
    ScopeBlob.pBlob      = szScope;
    ScopeBlob.wBlobLen   = strlen( ScopeBlob.pBlob ) + 1;    

    strcpy( pLicenseContext->Scope, ScopeBlob.pBlob );

    //
    // Pack the server hello message into network format
    //

    Status = PackHydraServerLicenseRequest( 
                    pLicenseContext->dwProtocolVersion, 
                    &LicenseRequest, 
                    ppOutBuf, 
                    pcbOutBuf );

    //
    // free the memory containing the server certificate
    //

    if( LicenseRequest.ServerCert.pBlob )
    {
        TLSFreeTSCertificate( LicenseRequest.ServerCert.pBlob );
        LicenseRequest.ServerCert.pBlob = NULL;
    }
    
    if( LICENSE_STATUS_OK != Status )
    {
        goto no_request;        
    }

    Status = LICENSE_STATUS_CONTINUE;

    //
    // change the state of the context
    //

    pLicenseContext->State = SENT_SERVER_HELLO;

    return( Status );

    //=========================================================================
    // Error return
    //=========================================================================

no_request:

    //
    // free memory and handles
    //

    if( pLicenseContext->ProductInfo.pbCompanyName )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbCompanyName );
    }

    if( pLicenseContext->ProductInfo.pbProductID )
    {
        LicenseMemoryFree( &pLicenseContext->ProductInfo.pbProductID );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleHelloResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf )
{
    PPreamble pPreamble;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > sizeof( Preamble ) );

    if( ( NULL == pInBuf ) || ( sizeof( Preamble ) > cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check the message preamble to determine how to unpack the message
    //

    pPreamble = ( PPreamble )pInBuf;

    if( HC_LICENSE_INFO == pPreamble->bMsgType )
    {
        //
        // Client has sent us its license
        //

        return( HandleClientLicense( pLicenseContext, cbInBuf, pInBuf, pcbOutBuf, ppOutBuf ) );

    }
    else if( HC_NEW_LICENSE_REQUEST == pPreamble->bMsgType )
    {
        //
        // Client has requested for a new license
        //

        return( HandleNewLicenseRequest( pLicenseContext, cbInBuf, pInBuf, pcbOutBuf, ppOutBuf ) );

    } 
    else if( GM_ERROR_ALERT == pPreamble->bMsgType )
    {
        //
        // Client has encountered an error
        //

        return( HandleClientError( pLicenseContext, cbInBuf, pInBuf, pcbOutBuf, ppOutBuf ) );
    }

    //
    // The client response is invalid for the current server state
    //

    return( LICENSE_STATUS_INVALID_RESPONSE );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ChooseLicense( 
    PValidation_Info    pValidationInfo,
    DWORD               dwNumLicenses, 
    LICENSEDPRODUCT *   pLicenseInfo, 
    LPDWORD             pdwLicenseIndex,
    BOOL                fMatchingVersion )
{
    DWORD
        dwCurrentLicense,
        dwProductVersion;
    LICENSEDPRODUCT *
        pCurrentLicense = pLicenseInfo;
    BOOL
        fFoundLicense = FALSE;

    if( ( 0 >= dwNumLicenses ) || ( NULL == pLicenseInfo ) || ( NULL == pdwLicenseIndex ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Find a license with the license array that matches the criteria.
    // The caller may be looking for a license that matches the current product
    // version, or for a license that is later than the current product version.
    //
    
    for( dwCurrentLicense = 0; dwCurrentLicense < dwNumLicenses; dwCurrentLicense++ )
    {
        if( TERMSERV_CERT_VERSION_BETA == pCurrentLicense->dwLicenseVersion )
        {
            continue;
        }

        dwProductVersion = pCurrentLicense->pLicensedVersion->wMajorVersion;
        dwProductVersion <<= 16;
        dwProductVersion |= pCurrentLicense->pLicensedVersion->wMinorVersion;

        if( fMatchingVersion )
        {
            //
            // we should be looking for a license with a matching version
            //

            if( dwProductVersion == pValidationInfo->pProductInfo->dwVersion )
            {
                fFoundLicense = TRUE;
                break;
            }
        }
        else
        {
            //
            // Looking for a license that is later than the current product
            // version.
            //
            
            if( dwProductVersion > pValidationInfo->pProductInfo->dwVersion )
            {
                fFoundLicense = TRUE;
                break;
            }
        }

        //
        // continue looking for the license
        //
        
        pCurrentLicense++;                
    }

    if( FALSE == fFoundLicense )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    *pdwLicenseIndex = dwCurrentLicense;

    return( LICENSE_STATUS_OK );

}

///////////////////////////////////////////////////////////////////////////////
VOID
UpdateVerifyResult(
    LICENSE_STATUS * pCurrentStatus,
    LICENSE_STATUS   NewStatus )
{
    //
    // Update the current status with the best result so far.
    // The ratings of the license verification result are as follows:
    //
    // (1) LICENSE_STATUS_OK
    // (2) LICENSE_STATUS_SHOULD_UPGRADE_LICENSE
    // (3) LICENSE_STATUS_MUST_UPGRADE_LICENSE
    // (4) Other LICENSE_STATUS_xxx
    //

    if( LICENSE_STATUS_OK == *pCurrentStatus )
    {
        return;
    }
    else if( LICENSE_STATUS_OK == NewStatus )
    {
        *pCurrentStatus = NewStatus;
        return;
    }
    
    if( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == *pCurrentStatus )
    {
        return;
    }
    else if( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == NewStatus )
    {
        *pCurrentStatus = NewStatus;
        return;
    }

    if( LICENSE_STATUS_MUST_UPGRADE_LICENSE == *pCurrentStatus )
    {
        return;
    }
    else if( LICENSE_STATUS_MUST_UPGRADE_LICENSE == NewStatus )
    {
        *pCurrentStatus = NewStatus;
        return;
    }

    *pCurrentStatus = NewStatus;
    return;    
}

/*++

Function:

    FreeTsLicenseInfo

Description:

    Release all the memory used in the given TS_LICENSE_INFO structure

Parameter:

    pTsLicenseInfo - Pointer to a TS_LICENSE_INFO structure

Return:

    Nothing.

--*/

VOID
FreeTsLicenseInfo(
    PTS_LICENSE_INFO    pTsLicenseInfo )
{
    if( NULL == pTsLicenseInfo )
    {
        return;
    }

    if( pTsLicenseInfo->pbRawLicense )
    {
        LicenseMemoryFree( &pTsLicenseInfo->pbRawLicense );
    }

    //
    // release all memory within the structure
    //

    memset( pTsLicenseInfo, 0, sizeof( TS_LICENSE_INFO ) );

    return;
}

/*++

Function:

    CacheLicenseInfo

Description:

    Cache the client licensing info

Parameters:

    pLicenseContext - Pointer to license protocol context
    pCurrentLicense - Pointer to the license info to cache

Returns:

    nothing.

--*/
    
VOID
CacheLicenseInfo(
    PHS_Protocol_Context    pLicenseContext,
    PLICENSEDPRODUCT        pCurrentLicense )
{
    LICENSE_STATUS
        Status;
    
    //
    // free the old information in the cache
    //

    if( pLicenseContext->pTsLicenseInfo )
    {
        FreeTsLicenseInfo( pLicenseContext->pTsLicenseInfo );
    }
    else
    {
        Status = LicenseMemoryAllocate( sizeof( TS_LICENSE_INFO ), &pLicenseContext->pTsLicenseInfo );

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICEMGR: CacheLicenseInfo: cannot allocate memory for license info cache\n" );
#endif
            return;
        }
    }

    //
    // decide if the license is temporary
    //

    if( pCurrentLicense->pLicensedVersion->dwFlags & 0x80000000 )
    {
        pLicenseContext->pTsLicenseInfo->fTempLicense = TRUE;
    }
    else
    {
        pLicenseContext->pTsLicenseInfo->fTempLicense = FALSE;
    }

    //
    // cache license validity dates
    //

    pLicenseContext->pTsLicenseInfo->NotAfter = pCurrentLicense->NotAfter;

    return;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ValidateHydraLicense( 
    PHS_Protocol_Context        pLicenseContext, 
    PValidation_Info            pValidationInfo,
    DWORD                       dwNumLicenses,
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState )
{
    LICENSE_STATUS 
        Status = LICENSE_STATUS_INVALID_LICENSE,
        CurrentStatus;
    DWORD
        dwLicenseIndex = 0,
        dwCurrentLicense = 0;
    PLICENSEDPRODUCT
        pCurrentLicense;
    BOOL
        fFoundMatchingVersion = FALSE;

    //
    // The client could have given us multiple licenses.  Pick the right
    // license from the array of licenses to validate.  Always try to pick
    // the license that matches the current product version before looking
    // for a license that is for a later version.
    //

    CurrentStatus = ChooseLicense( 
                            pValidationInfo, 
                            dwNumLicenses, 
                            pLicenseInfo, 
                            &dwLicenseIndex,
                            TRUE );

    if( LICENSE_STATUS_OK == CurrentStatus )
    {
        //
        // Verify the license that is the same version as the current product
        // version

        // initialize the license state
        //

        LicenseInitState( *pdwLicenseState );
        pCurrentLicense = pLicenseInfo + dwLicenseIndex;
        fFoundMatchingVersion = TRUE;

        //
        // verify HWID
        //

        CurrentStatus = VerifyClientHwid( pLicenseContext, pValidationInfo, pCurrentLicense );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto verify_later_license;
        }

        //
        // verify product info.  Also verifies the product version.
        // The product version determines if the license needs to be
        // upgraded or not.
        //

        CurrentStatus = VerifyLicenseProductInfo( 
                                    pLicenseContext, 
                                    pValidationInfo, 
                                    pCurrentLicense, 
                                    pdwLicenseState );

        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto verify_later_license;
        }

        //
        // verify license valid date and time.  This validation is only
        // needed if it is a temporary license
        //

        CurrentStatus = VerifyLicenseDateAndTime( pCurrentLicense, pdwLicenseState );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto verify_later_license;
        }

        CurrentStatus = GetVerifyResult( *pdwLicenseState );
        UpdateVerifyResult( &Status, CurrentStatus );

        //
        // cache the license we tried to validate
        //
        
        CacheLicenseInfo( pLicenseContext, pCurrentLicense );

        //
        // If the current license is OK, then we're done verifying
        //

        if( LICENSE_STATUS_OK == Status )
        {
            return( Status );
        }
    }

verify_later_license:
           
    //
    // Cannot find or did not sucessfully verify a license that matches the current
    // product version.  The following code finds and verifies licenses that 
    // are later than the current product version.
    //

    CurrentStatus = ChooseLicense( 
                            pValidationInfo, 
                            dwNumLicenses, 
                            pLicenseInfo, 
                            &dwLicenseIndex,
                            FALSE );

    if( LICENSE_STATUS_OK != CurrentStatus )
    {
        
        if( FALSE == fFoundMatchingVersion )
        {
            //
            // cannot find a license that is the same or later than the current
            // product version  ==> this license must be upgraded.
            //

            LicenseSetState( *pdwLicenseState, LICENSE_STATE_OLD_VERSION );
            return( GetVerifyResult( *pdwLicenseState ) );
        }
        else
        {
            return( Status );
        }
    }
    
    pCurrentLicense = pLicenseInfo + dwLicenseIndex;
    dwCurrentLicense = dwLicenseIndex;

    while(  dwCurrentLicense < dwNumLicenses )
    {        
        //
        // initialize the license state
        //

        LicenseInitState( *pdwLicenseState );

        //
        // verify HWID
        //

        CurrentStatus = VerifyClientHwid( pLicenseContext, pValidationInfo, pCurrentLicense );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto next_license;
        }

        //
        // verify product info.  Also verifies the product version.
        // The product version determines if the license needs to be
        // upgraded or not.
        //

        CurrentStatus = VerifyLicenseProductInfo( 
                                    pLicenseContext, 
                                    pValidationInfo, 
                                    pCurrentLicense, 
                                    pdwLicenseState );

        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto next_license;
        }

        //
        // verify license valid date and time.  This validation is only
        // needed if it is a temporary license
        //

        CurrentStatus = VerifyLicenseDateAndTime( pCurrentLicense, pdwLicenseState );
    
        if( LICENSE_STATUS_OK != CurrentStatus )
        {
            UpdateVerifyResult( &Status, CurrentStatus );
            goto next_license;
        }

        CurrentStatus = GetVerifyResult( *pdwLicenseState );

        UpdateVerifyResult( &Status, CurrentStatus );

        //
        // cache the info of the license we had just try to validate
        //

        CacheLicenseInfo( pLicenseContext, pCurrentLicense );

        if( LICENSE_STATUS_OK == Status )
        {
            //
            // if the license is OK, then we can stop the verification process
            //

            break;
        }

next_license:

        //
        // Get the next license that is later than the current product version.
        //

        if( dwNumLicenses <= ++dwCurrentLicense )
        {
            break;
        }

        pCurrentLicense++;

        CurrentStatus = ChooseLicense( 
                            pValidationInfo, 
                            dwNumLicenses - dwCurrentLicense, 
                            pCurrentLicense, 
                            &dwLicenseIndex,
                            FALSE );
        
        if( LICENSE_STATUS_OK != CurrentStatus )    
        {
            break;
        }

        pCurrentLicense += dwLicenseIndex;
        dwCurrentLicense += dwLicenseIndex;
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ValidateLicense(
    PHS_Protocol_Context pLicenseContext, 
    PValidation_Info     pValidationInfo,
    PDWORD               pdwLicenseState,
    BOOL                 fCheckForPermanent )
{
    LICENSE_STATUS Status;
    DWORD dwNumLicenseInfo = 0;
    LICENSEDPRODUCT * pLicenseInfo = NULL;
    static DWORD    cchComputerName;
    static TCHAR    szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cbSecretKey = 0;
    PBYTE pbSecretKey = NULL;

    if( NULL == pLicenseContext )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Get the secret key that is used to encrypt the HWID
    //

    LicenseGetSecretKey( &cbSecretKey, NULL );

    Status = LicenseMemoryAllocate( cbSecretKey, &pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseGetSecretKey( &cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // decode license issued by hydra license server certificate engine.
    // Decoding the license will also get us back the decrypted HWID.
    //

    __try
    {
        Status = LSVerifyDecodeClientLicense( 
                            pValidationInfo->pLicense,
                            pValidationInfo->cbLicense,                                          
                            pbSecretKey,
                            cbSecretKey,
                            &dwNumLicenseInfo,
                            NULL );                            

        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

        Status = LicenseMemoryAllocate( 
                        sizeof( LICENSEDPRODUCT ) * dwNumLicenseInfo, 
                        &pLicenseInfo );

        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

        Status = LSVerifyDecodeClientLicense( 
                            pValidationInfo->pLicense,
                            pValidationInfo->cbLicense,                                          
                            pbSecretKey,
                            cbSecretKey,
                            &dwNumLicenseInfo,
                            pLicenseInfo );
                            
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DWORD dwExceptionCode = GetExceptionCode();
        Status = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
    }

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICEMGR: cannot decode license: 0x%x\n", Status );
#endif
        goto done;
    }

    //
    // now validate the license
    //

    Status = ValidateHydraLicense( 
                        pLicenseContext, 
                        pValidationInfo, 
                        dwNumLicenseInfo, 
                        pLicenseInfo,                         
                        pdwLicenseState );


    if (fCheckForPermanent
        && LICENSE_STATUS_OK == Status
        && !pLicenseContext->pTsLicenseInfo->fTempLicense
        && pLicenseContext->ProductInfo.cbProductID >= sizeof(TERMSERV_FREE_TYPE))
    {
        int i;
        TCHAR *pszT;

        for (i = 0, pszT = (TCHAR *)(pLicenseContext->ProductInfo.pbProductID + pLicenseContext->ProductInfo.cbProductID - sizeof(TERMSERV_FREE_TYPE)); i < sizeof(TERMSERV_FREE_TYPE); i++)
        {
            if (TERMSERV_FREE_TYPE[i] != pszT[i])
                goto done;
        }

        ReceivedPermanentLicense();
    }
    
done:

    if( pbSecretKey )
    {
        LicenseMemoryFree( &pbSecretKey );
    }

    //
    // Free the array of licensed product info
    //
        
    if( pLicenseInfo )
    {
        while( dwNumLicenseInfo-- )
        {
            LSFreeLicensedProduct( pLicenseInfo + dwNumLicenseInfo );
        }

        LicenseMemoryFree( &pLicenseInfo );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleClientLicense(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf )
{
    LICENSE_STATUS Status, UpgradeStatus;
    Hydra_Client_License_Info LicenseInfo;
    PBYTE pPreMasterSecret = NULL;
    DWORD dwPreMasterSecretLen = 0;
    HWID Hwid;
    Validation_Info ValidationInfo;
    License_Error_Message ErrorMsg;
    DWORD dwLicenseState = 0;
    BYTE MacData[LICENSE_MAC_DATA];
    DWORD CertType;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Unpack the client license info message
    //

    InitBinaryBlob( &LicenseInfo.EncryptedPreMasterSecret );
    InitBinaryBlob( &LicenseInfo.LicenseInfo );
    InitBinaryBlob( &LicenseInfo.EncryptedHWID );

    Status = UnPackHydraClientLicenseInfo( pInBuf, cbInBuf, &LicenseInfo );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }

    //
    // Initialize the crypto context with the key exchange info and build the pre-master
    // secret.  We need the server and client random numbers and the pre-master secret
    // to build the pre-master secret.
    //

    memcpy( pLicenseContext->CryptoContext.rgbClientRandom,
            LicenseInfo.ClientRandom,
            LICENSE_RANDOM );
    
    pLicenseContext->CryptoContext.dwKeyExchAlg = LicenseInfo.dwPrefKeyExchangeAlg;

    dwPreMasterSecretLen = LICENSE_PRE_MASTER_SECRET;

    Status = GetEnvelopedData( pLicenseContext->CertTypeUsed,
                               LicenseInfo.EncryptedPreMasterSecret.pBlob,
                               ( DWORD )LicenseInfo.EncryptedPreMasterSecret.wBlobLen,
                               &pPreMasterSecret,
                               &dwPreMasterSecretLen );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        goto construct_return_msg;
    }

    //
    // Set the pre-master secret and generate the master secret
    //

    Status = LicenseSetPreMasterSecret( &pLicenseContext->CryptoContext, pPreMasterSecret );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }
    
    Status = LicenseBuildMasterSecret( &pLicenseContext->CryptoContext );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }

    //
    // Derive the session key from the key exchange info
    //

    Status = LicenseMakeSessionKeys( &pLicenseContext->CryptoContext, 0 );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }    

    //
    // Use the session key to decrypt the HWID
    //

    if( LicenseInfo.EncryptedHWID.wBlobLen > sizeof(Hwid) )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto construct_return_msg;
    }

    memcpy( &Hwid, 
            LicenseInfo.EncryptedHWID.pBlob, 
            LicenseInfo.EncryptedHWID.wBlobLen );

    Status = LicenseDecryptSessionData( &pLicenseContext->CryptoContext,
                                        ( PBYTE )&Hwid,
                                        ( DWORD )LicenseInfo.EncryptedHWID.wBlobLen );

    if( LICENSE_STATUS_OK != Status )
    {
        goto construct_return_msg;
    }    

    //
    // Calculate the MAC on the HWID.
    //

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext, 
                                 ( PBYTE )&Hwid, 
                                 sizeof( HWID ), 
                                 MacData);
    
    if( LICENSE_STATUS_OK != Status )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto construct_return_msg;
    }

    //
    // now verify the MAC data
    //

    if( 0 != memcmp( MacData, LicenseInfo.MACData, LICENSE_MAC_DATA ) )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto construct_return_msg;
    }

    //
    // keep track of the client platform ID
    //

    pLicenseContext->dwClientPlatformID = LicenseInfo.dwPlatformID;

    //
    // call the license manager to validate the license.
    // For now, we don't have to fill in the product info fields
    //

    ValidationInfo.pValidationData = ( PBYTE )&Hwid;
    ValidationInfo.cbValidationData = LICENSE_HWID_LENGTH;
    ValidationInfo.pProductInfo = &pLicenseContext->ProductInfo;
    ValidationInfo.pLicense = LicenseInfo.LicenseInfo.pBlob;
    ValidationInfo.cbLicense = ( DWORD )LicenseInfo.LicenseInfo.wBlobLen;

    Status = ValidateLicense( pLicenseContext, 
                              &ValidationInfo, 
                              &dwLicenseState,
                              FALSE     // fCheckForPermanent
                              );

    //
    // If the license cannot be decoded, then it is time to issue a new license
    // for the client.
    //

    if( LICENSE_STATUS_CANNOT_DECODE_LICENSE == Status ||
        LICENSE_STATUS_INVALID_LICENSE == Status )
    {
        LICENSE_STATUS StatusT = IssuePlatformChallenge( pLicenseContext, pcbOutBuf, ppOutBuf );

        if( LICENSE_STATUS_OK != StatusT )
        {
            //
            // cannot obtain a platform challenge for the client
            //

#if DBG
            DbgPrint( "LICPROT: cannot issue platform challenge: 0x%x\n", Status );
#endif
            goto construct_return_msg;
        }
        
        pLicenseContext->State = ISSUED_PLATFORM_CHALLENGE;
        Status = LICENSE_STATUS_CONTINUE;
        goto done;
    }

#ifdef UPGRADE_LICENSE

    //
    // check if the license needs to be upgraded.
    //
     
    if( ( LICENSE_STATUS_MUST_UPGRADE_LICENSE == Status ) ||
        ( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == Status ) )
    {
        //
        // issue the platform challenge for upgrading a license
        //

        UpgradeStatus = IssuePlatformChallenge( 
                                        pLicenseContext,
                                        pcbOutBuf, 
                                        ppOutBuf );

        if( LICENSE_STATUS_OK == UpgradeStatus )
        {
            //
            // keep track of the old license and continue with the licensing
            // protocol.  We will upgrade the old license when the client
            // returns with the platform challenge.
            //

            if( pLicenseContext->pbOldLicense )
            {
                LicenseMemoryFree( &pLicenseContext->pbOldLicense );
            }

            pLicenseContext->pbOldLicense = LicenseInfo.LicenseInfo.pBlob;
            pLicenseContext->cbOldLicense = LicenseInfo.LicenseInfo.wBlobLen;
            
            pLicenseContext->State = ISSUED_PLATFORM_CHALLENGE;
            Status = LICENSE_STATUS_CONTINUE;

            goto done;
        }
        else if(  LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == Status ) 
        {    
            //
            // Let the client go through if we cannot issue a platform challenge to
            // upgrade a valid license now.
            //

            Status = LICENSE_STATUS_OK;
            goto construct_return_msg;
        }
        else
        {
            // LICENSE_STATUS_MUST_UPGRADE_LICENSE: send back the real error

            Status = UpgradeStatus;
        }

        //
        // cannot issue platform challenge to upgrade a license that is not good
        // any more.
        //

#if DBG
        DbgPrint( "LICPROT: cannot issue platform challenge to upgrade license: 0x%x\n", Status );
#endif
        
    }

#else

    //
    // we are ignoring license upgrade
    //

    if( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == Status )
    {
        //
        // change the status to OK
        //

        Status = LICENSE_STATUS_OK;
    }

#endif

    //
    // now construct the message to return to the client, based on the current
    // status code
    //

construct_return_msg:

    if( LICENSE_STATUS_OK != Status )
    {
        //
        // The current status states that the client could not be validated
        // due to some error
        //

#if DBG
        DbgPrint( "HandleClientLicense: constructing error message: 0x%x\n", Status );
#endif

        //
        // handle the error condition and update our state
        //

        HandleErrorCondition( pLicenseContext, pcbOutBuf, ppOutBuf, &Status );

        pLicenseContext->State = VALIDATION_ERROR;
    
        if( (LICENSE_STATUS_INVALID_RESPONSE == Status)
            || (LICENSE_STATUS_INVALID_MAC_DATA == Status)
            || (LICENSE_STATUS_CANNOT_DECODE_LICENSE == Status)
            || (LICENSE_STATUS_INVALID_LICENSE == Status) )
        {
            WORD wLogString = 0;
            LPTSTR ptszLogString[1] = { NULL };

            //
            // Log the failure
            //
            
            if( pLicenseContext->ptszClientMachineName )
            {
                wLogString = 1;
                ptszLogString[0] = pLicenseContext->ptszClientMachineName;
            }

            LicenseLogEvent( EVENTLOG_INFORMATION_TYPE, 
                             EVENT_INVALID_LICENSE, 
                             wLogString, ptszLogString );

            pLicenseContext->fLoggedProtocolError = TRUE;

        }
        else if ((NULL != pLicenseContext->pTsLicenseInfo)
                 && (!pLicenseContext->fLoggedProtocolError))
        {
            LPTSTR ptszLogString[1] = { NULL };

            if( pLicenseContext->ptszClientMachineName )
            {
                ptszLogString[0] = pLicenseContext->ptszClientMachineName;
            }

            // Couldn't renew/upgrade license

            pLicenseContext->fLoggedProtocolError = TRUE;

            if (pLicenseContext->pTsLicenseInfo->fTempLicense)
            {
                // The expired temporary license could not be upgraded
                LicenseLogEvent(
                                EVENTLOG_INFORMATION_TYPE,
                                EVENT_EXPIRED_TEMPORARY_LICENSE,
                                1,
                                ptszLogString
                                );
            }
            else
            {
                // The expired permanent license could not be renewed
                LicenseLogEvent(
                                EVENTLOG_INFORMATION_TYPE,
                                EVENT_EXPIRED_PERMANENT_LICENSE,
                                1,
                                ptszLogString
                                );
            }
        }

        goto done;
    }

    //
    // The license has been validated successfully, generate the message to 
    // return to the client
    //

    Status = ConstructServerResponse( pLicenseContext->dwProtocolVersion,
                                      LICENSE_RESPONSE_VALID_CLIENT,                                       
                                      pcbOutBuf,
                                      ppOutBuf );
    
    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "HandleClientLicense: cannot pack error message: 0x%x\n", Status );
#endif
        pLicenseContext->State = ABORTED; 
        Status = LICENSE_STATUS_SERVER_ABORT;
    }
    else
    {            
        pLicenseContext->State = VALIDATED_LICENSE_COMPLETE;
    }    

done:

    //
    // free the memory used in the license info structure
    //

    FreeBinaryBlob( &LicenseInfo.EncryptedPreMasterSecret );
    FreeBinaryBlob( &LicenseInfo.EncryptedHWID );
    
    if( pLicenseContext->pbOldLicense != LicenseInfo.LicenseInfo.pBlob )
    {
        FreeBinaryBlob( &LicenseInfo.LicenseInfo );
    }
    
    if( pPreMasterSecret )
    {
        LicenseMemoryFree( &pPreMasterSecret );
    }

    return( Status);

}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleNewLicenseRequest(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf )
{
    LICENSE_STATUS  Status;
    Hydra_Client_New_License_Request    NewLicenseRequest;
    PBYTE   pPreMasterSecret = NULL;
    DWORD   dwPreMasterSecretLen = 0;
    DWORD   dwChallengeLen = 0;
    DWORD   CertType;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    InitBinaryBlob( &NewLicenseRequest.EncryptedPreMasterSecret );
        
    //
    // Unpack the new license request
    //

    Status = UnPackHydraClientNewLicenseRequest( pInBuf, cbInBuf, &NewLicenseRequest );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot unpack client request: 0x%x\n", Status );
#endif
        return( Status );
    }

    //
    // save the client user and machine name
    //
    
#ifdef UNICODE

    //
    // convert the client's user and machine name to unicode
    //

    if( ( NewLicenseRequest.ClientUserName.pBlob ) && 
        ( NULL == pLicenseContext->ptszClientUserName ) )
    {
        Status = Ascii2Wchar( NewLicenseRequest.ClientUserName.pBlob, 
                              &pLicenseContext->ptszClientUserName );

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot convert client user name: %s to wide char: 0x%x\n",
                      NewLicenseRequest.ClientUserName.pBlob, Status );
#endif
        }        
    }

    if( ( NewLicenseRequest.ClientMachineName.pBlob ) &&
        ( NULL == pLicenseContext->ptszClientMachineName ) )
    {
        Status = Ascii2Wchar( NewLicenseRequest.ClientMachineName.pBlob, 
                              &pLicenseContext->ptszClientMachineName );

        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot convert client machine name %s to wide char: 0x%x\n", 
                      NewLicenseRequest.ClientMachineName.pBlob, Status );
#endif
        }
    }

#else // non-UNICODE

    //
    // save the client's user and machine name
    //

    if( ( NewLicenseRequest.ClientUserName.pBlob ) && 
        ( NULL == pLicenseContext->ptszClientUserName ) )
    {
        Status = LicenseMemoryAllocate( 
                        NewLicenseRequest.ClientUserName.wBlobLen,
                        &pLicenseContext->ptszClientUserName );
                        
        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot allocate memory for client's user name: 0x%x\n", 
                       Status );
#endif
        }
        else
        {
            memcpy( pLicenseContext->ptszClientUserName, 
                    NewLicenseRequest.ClientUserName.pBlob, 
                    NewLicenseRequest.ClientUserName.wBlobLen );
        }
    }

    if( ( NewLicenseRequest.ClientMachineName.pBlob ) &&
        ( NULL == pLicenseContext->ptszClientMachineName ) )
    {
        Status = LicenseMemoryAllocate( 
                        NewLicenseRequest.ClientMachineName.wBlobLen,
                        &pLicenseContext->ptszClientMachineName );
                        
        if( LICENSE_STATUS_OK != Status )
        {
#if DBG
            DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot allocate memory for client's machine name: 0x%x\n", 
                       Status );
#endif
        }
        else
        {
            memcpy( pLicenseContext->ptszClientMachineName, 
                    NewLicenseRequest.ClientMachineName.pBlob, 
                    NewLicenseRequest.ClientMachineName.wBlobLen );
        }
    }

#endif // UNICODE

    //
    // Initialize the crypto context with the key exchange info and build the pre-master
    // secret.  We need the server and client random numbers and the pre-master secret
    // to build the pre-master secret.
    //

    memcpy( pLicenseContext->CryptoContext.rgbClientRandom,
            NewLicenseRequest.ClientRandom,
            LICENSE_RANDOM );
    
    pLicenseContext->CryptoContext.dwKeyExchAlg = NewLicenseRequest.dwPrefKeyExchangeAlg;

    //
    // Get the pre-master secret from the enveloped data
    //
        
    Status = GetEnvelopedData( pLicenseContext->CertTypeUsed,
                               NewLicenseRequest.EncryptedPreMasterSecret.pBlob,
                               ( DWORD )NewLicenseRequest.EncryptedPreMasterSecret.wBlobLen,
                               &pPreMasterSecret,
                               &dwPreMasterSecretLen );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: HandleNewLicenseRequest: cannot get enveloped data: 0x%x", Status );
#endif
        goto done;
    }    

    //
    // set the premaster secret and generate the master secret
    //

    Status = LicenseSetPreMasterSecret(  &pLicenseContext->CryptoContext, pPreMasterSecret );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseBuildMasterSecret( &pLicenseContext->CryptoContext );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // Derive the session key from the key exchange info
    //

    Status = LicenseMakeSessionKeys( &pLicenseContext->CryptoContext, 0 );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }    

    //
    // record the client platform ID and issue the platform challenge
    //

    pLicenseContext->dwClientPlatformID = NewLicenseRequest.dwPlatformID;

    Status = IssuePlatformChallenge( pLicenseContext, pcbOutBuf, ppOutBuf );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // update our state
    //

    pLicenseContext->State = ISSUED_PLATFORM_CHALLENGE;

    Status = LICENSE_STATUS_CONTINUE;


done:

    FreeBinaryBlob( &NewLicenseRequest.EncryptedPreMasterSecret );
    FreeBinaryBlob( &NewLicenseRequest.ClientUserName );
    FreeBinaryBlob( &NewLicenseRequest.ClientMachineName );

    if( pPreMasterSecret )
    {
        LicenseMemoryFree( &pPreMasterSecret );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandleClientError(
PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf )
{
    LICENSE_STATUS Status;
    License_Error_Message ClientError;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    InitBinaryBlob( &ClientError.bbErrorInfo );

    //
    // unpack the client error
    //

    Status = UnPackHydraClientErrorMessage( pInBuf, cbInBuf, &ClientError );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    //
    // Process the client error code, the possible errors are:
    // (1) Error processing the hydra server certificate
    // (2) Client has no license and does not want one
    //
    // For now, just record the client error and abort the operation
    //

    pLicenseContext->dwClientError = ClientError.dwErrorCode;
    pLicenseContext->State = ABORTED;

    FreeBinaryBlob( &ClientError.bbErrorInfo );

    return( LICENSE_STATUS_CLIENT_ABORT );
}

LICENSE_STATUS
AuthWithLicenseServer(
    PHS_Protocol_Context     pLicenseContext )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    LPBYTE lpCert = NULL;
    DWORD dwResult, RpcStatus;
    DWORD dwSize;

    if (pLicenseContext->hLSHandle == NULL)
        return LICENSE_STATUS_INVALID_SERVER_CONTEXT;

    Status = TLSGetTSCertificate(CERT_TYPE_X509, &lpCert, &dwSize);

    if (Status != LICENSE_STATUS_OK)
    {
        Status = TLSGetTSCertificate(CERT_TYPE_PROPRIETORY, &lpCert, &dwSize);
    }

    if (Status != LICENSE_STATUS_OK)
    {
        goto done;
    }

    RpcStatus = TLSSendServerCertificate(
                                         pLicenseContext->hLSHandle,
                                         dwSize,
                                         lpCert,
                                         &dwResult
                                         );

    if( ( RPC_S_OK != RpcStatus ) || ( LSERVER_S_SUCCESS != dwResult ) )
    {
        Status = LICENSE_STATUS_AUTHENTICATION_ERROR;
        goto done;
    }

done:
    if (lpCert)
        TLSFreeTSCertificate(lpCert);

    return Status;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CheckConnectLicenseServer(
    PHS_Protocol_Context      pLicenseContext )
{
    LICENSE_STATUS Status = LICENSE_STATUS_NO_LICENSE_SERVER;

    if (pLicenseContext->hLSHandle != NULL)
        return LICENSE_STATUS_OK;

    pLicenseContext->hLSHandle = TLSConnectToAnyLsServer(LS_DISCOVERY_TIMEOUT);

    if (NULL != pLicenseContext->hLSHandle)
    {
        Status = AuthWithLicenseServer(pLicenseContext);
        if (Status == LICENSE_STATUS_OK)
        {
            goto done;
        }
    }
    else
    {
        BOOL fInDomain;
        LPWSTR szDomain = NULL;
        DWORD dwErr;

        dwErr = TLSInDomain(&fInDomain,&szDomain);

        if ((ERROR_SUCCESS == dwErr) && (NULL != szDomain))
        {
            ThrottleLicenseLogEvent( 
                                EVENTLOG_WARNING_TYPE,
                                fInDomain
                                  ? EVENT_NO_LICENSE_SERVER_DOMAIN
                                    : EVENT_NO_LICENSE_SERVER_WORKGROUP,
                                1, 
                                &szDomain );
        }
        else
        {
            ThrottleLicenseLogEvent( 
                                EVENTLOG_WARNING_TYPE,
                                EVENT_NO_LICENSE_SERVER,
                                0, 
                                NULL );
        }

        if (NULL != szDomain)
        {
            NetApiBufferFree(szDomain);
        }
    }

    // error case
    if (NULL != pLicenseContext->hLSHandle)
    {
        TLSDisconnectFromServer(pLicenseContext->hLSHandle);
        pLicenseContext->hLSHandle = NULL;
    }

done:
    return Status;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CheckConnectNamedLicenseServer(
    PHS_Protocol_Context      pLicenseContext,
    TCHAR                     *tszComputerName)
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;

    if (pLicenseContext->hLSHandle != NULL)
        return LICENSE_STATUS_OK;

    pLicenseContext->hLSHandle = TLSConnectToLsServer(tszComputerName);

    if (NULL == pLicenseContext->hLSHandle)
    {
        Status = LICENSE_STATUS_NO_LICENSE_SERVER;
        goto done;
    }

    Status = AuthWithLicenseServer(pLicenseContext);
    if (Status != LICENSE_STATUS_OK)
    {
        TLSDisconnectFromServer(pLicenseContext->hLSHandle);
        pLicenseContext->hLSHandle = NULL;
    }

done:
    return Status;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
CheckUpgradeLicense(
    PHS_Protocol_Context      pLicenseContext, 
    PDWORD                    pSupportFlags,
    PLicense_Request          pLicenseRequest,
    DWORD                     cbChallengeResponse,
    PBYTE                     pbChallengeResponse,
    PHWID                     pHwid,
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf )
{
    LICENSE_STATUS 
        Status = LICENSE_STATUS_OK;
    DWORD 
        cbLicense = 0;
    PBYTE 
        pbLicense = NULL;
    Validation_Info 
        ValidationInfo;
    DWORD
        dwLicenseState = 0;
    DWORD
        RpcStatus, LsStatus;
    BOOL
        fRetried = FALSE;

reconnect:    
    Status = CheckConnectLicenseServer(pLicenseContext);
    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    RpcStatus = TLSUpgradeLicenseEx(pLicenseContext->hLSHandle,
                                  pSupportFlags,
                                  pLicenseRequest,
                                  0,       // ChallengeContext unused
                                  cbChallengeResponse,
                                  pbChallengeResponse,
                                  pLicenseContext->cbOldLicense,
                                  pLicenseContext->pbOldLicense,
                                  1,       // dwQuantity
                                  &cbLicense,
                                  &pbLicense,
                                  &LsStatus
                                  );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            Status = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        Status = LsStatusToLicenseStatus(LsStatus,
                                      LICENSE_STATUS_CANNOT_UPGRADE_LICENSE);
    }

    ValidationInfo.pValidationData = ( PBYTE )pHwid;
    ValidationInfo.cbValidationData = LICENSE_HWID_LENGTH;
    ValidationInfo.pProductInfo = &pLicenseContext->ProductInfo;
        
    //
    // if we cannot upgrade the license, check if the current license is
    // still good.  If it is, return it to the client.
    //

    if( LICENSE_STATUS_OK != Status )
    {
        LICENSE_STATUS
            LicenseStatus;

        ValidationInfo.pLicense = pLicenseContext->pbOldLicense;
        ValidationInfo.cbLicense = pLicenseContext->cbOldLicense;

        LicenseStatus = ValidateLicense( 
                                    pLicenseContext, 
                                    &ValidationInfo, 
                                    &dwLicenseState,
                                    FALSE       // fCheckForPermanent
                                    );

        if( ( LICENSE_STATUS_OK == LicenseStatus ) || 
            ( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE == LicenseStatus ) )
        {
            //
            // Store the raw license bits for later use. Ignore failure;
            // that only means that if this is a license that should be
            // marked, termsrv won't be able to.
            //

            CacheRawLicenseData(pLicenseContext,
                    pLicenseContext->pbOldLicense,
                    pLicenseContext->cbOldLicense);

            //
            // The current license is still OK, send it back to the client.
            //

            Status = PackageLicense( 
                            pLicenseContext, 
                            pLicenseContext->cbOldLicense, 
                            pLicenseContext->pbOldLicense, 
                            pcbOutBuf, 
                            ppOutBuf,
                            FALSE );
        
        }
        else
        {
            //
            // The current license is not good any more
            //

#if DBG
            DbgPrint( "UpgradeLicense: cannot upgrade license 0x%x\n", Status );
#endif
            
        }
        
        goto done;
    }

    //
    // the license upgrade was successful.  Now validate the new license so
    // that the new license info will be cached.
    //

    ValidationInfo.pLicense = pbLicense;
    ValidationInfo.cbLicense = cbLicense;

    ValidateLicense( 
            pLicenseContext, 
            &ValidationInfo, 
            &dwLicenseState,
            TRUE        // fCheckForPermanent
            );

    //
    // Store the raw license bits for later use. Ignore failure; that only
    // means that if this is a license that should be marked, termsrv won't be
    // able to.
    //

    CacheRawLicenseData(pLicenseContext,
            pLicenseContext->pbOldLicense,
            pLicenseContext->cbOldLicense);

    //
    // pack up the upgraded license
    //

    Status = PackageLicense( pLicenseContext, 
                             cbLicense,
                             pbLicense, 
                             pcbOutBuf, 
                             ppOutBuf,
                             FALSE );

done:

    if( pbLicense )
    {
        LicenseMemoryFree( &pbLicense );
    }

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
HandlePlatformChallengeResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf )
{
    LICENSE_STATUS Status;
    Hydra_Client_Platform_Challenge_Response PlatformChallengeResponse;
    BYTE ChallengeResponse[PLATFORM_CHALLENGE_LENGTH];
    PBYTE pLicense = NULL;
    DWORD cbLicenseSize = 0;
    License_Request LicenseRequest;
    HS_LICENSE_STATE HsState = ABORTED;
    License_Requester_Info  RequesterInfo;
    BYTE bEncryptedHwid[ sizeof( HWID ) ];    
    PBYTE pbSecretKey = NULL;
    DWORD cbMacData = 0, cbSecretKey = 0, cbEncryptedHwid = sizeof( HWID );
    BYTE MacData[ sizeof( HWID ) + PLATFORM_CHALLENGE_LENGTH ];
    BYTE ComputedMac[LICENSE_MAC_DATA];
    HWID Hwid;
    DWORD RpcStatus,LsStatus;
    TCHAR tszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    TCHAR tszUserName[UNLEN + 1];
    DWORD dwComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD dwUserName = UNLEN + 1;
    DWORD dwSupportFlags = ALL_KNOWN_SUPPORT_FLAGS;
    BOOL fRetried = FALSE;

    ASSERT( NULL != pInBuf );
    ASSERT( cbInBuf > 0 );

    if( ( NULL == pInBuf ) || ( 0 >= cbInBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }
    
    //
    // unpack the platform challenge response
    //

    InitBinaryBlob( &PlatformChallengeResponse.EncryptedChallengeResponse );
    InitBinaryBlob( &PlatformChallengeResponse.EncryptedHWID );

    Status = UnPackHydraClientPlatformChallengeResponse( pInBuf, cbInBuf, &PlatformChallengeResponse );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // decrypt the encrypted challenge response and HWID
    //

    ASSERT(PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen
           <= PLATFORM_CHALLENGE_LENGTH);

    memcpy( ChallengeResponse,
            PlatformChallengeResponse.EncryptedChallengeResponse.pBlob,
            PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen );

    Status = LicenseDecryptSessionData( &pLicenseContext->CryptoContext,
                                        ChallengeResponse,
                                        ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }        

    //
    // decrypt the client's HWID
    //

    if( PlatformChallengeResponse.EncryptedHWID.wBlobLen > sizeof(Hwid) )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto done;
    }

    memcpy( &Hwid, 
            PlatformChallengeResponse.EncryptedHWID.pBlob, 
            PlatformChallengeResponse.EncryptedHWID.wBlobLen );

    Status = LicenseDecryptSessionData( &pLicenseContext->CryptoContext,
                                        ( PBYTE )&Hwid,
                                        ( DWORD )PlatformChallengeResponse.EncryptedHWID.wBlobLen );
    
    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }        
    
    //
    // Verify the MAC data on the decrypted challenge response and the HWID
    //

    cbMacData += ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen;
    
    memcpy( MacData, 
            ChallengeResponse, 
            ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen );

    cbMacData += ( DWORD )PlatformChallengeResponse.EncryptedHWID.wBlobLen;
    
    memcpy( MacData + ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen,
            &Hwid,
            ( DWORD )PlatformChallengeResponse.EncryptedHWID.wBlobLen );

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext,
                                 MacData,
                                 cbMacData,
                                 ComputedMac );

    if( LICENSE_STATUS_OK != Status )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto done;
    }

    if( 0 != memcmp( ComputedMac, 
                     PlatformChallengeResponse.MACData,
                     LICENSE_MAC_DATA ) )
    {
        Status = LICENSE_STATUS_INVALID_MAC_DATA;
        goto done;
    }

    //
    // now get the license server's secret key and encrypt the HWID before transmitting it.
    //

    LicenseGetSecretKey( &cbSecretKey, NULL );

    Status = LicenseMemoryAllocate( cbSecretKey, &pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseGetSecretKey( &cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseEncryptHwid( &Hwid, &cbEncryptedHwid, bEncryptedHwid, 
                                 cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }
    
    LicenseRequest.cbEncryptedHwid = cbEncryptedHwid;
    LicenseRequest.pbEncryptedHwid = bEncryptedHwid;

    //
    // send the platform challenge response to the license manager and wait for it
    // to issue a new license.
    //

    LicenseRequest.pProductInfo = &pLicenseContext->ProductInfo;
    
    LicenseRequest.dwPlatformID = pLicenseContext->dwClientPlatformID;
    LicenseRequest.dwLanguageID = GetSystemDefaultLCID();

    //
    // if we don't have the client's user and machine name, get it now.
    //

    if( NULL == pLicenseContext->ptszClientMachineName )
    {
        //
        // if we don't have the client machine name, just use the
        // hydra server machine name
        //

        if( !GetComputerName( tszComputerName, &dwComputerName ) )
        {
#if DBG
            DbgPrint( "HandlePlatformChallengeResponse: cannot get computer name: 0x%x\n", GetLastError() );
#endif
            memset( tszComputerName, 0, ( MAX_COMPUTERNAME_LENGTH + 1 ) * sizeof( TCHAR ) );
        }

        RequesterInfo.ptszMachineName = tszComputerName;
    }
    else
    {
        RequesterInfo.ptszMachineName = pLicenseContext->ptszClientMachineName;
    }

    if( NULL == pLicenseContext->ptszClientUserName )
    {
        //
        // if we don't have the client's user name, just use the 
        // hydra server logged on user name.
        //

        if( !GetUserName( tszUserName, &dwUserName ) )
        {
#if DBG
            DbgPrint( "HandlePlatformChallengeResponse: cannot get user name: 0x%x\n", GetLastError() );
#endif
            memset( tszUserName, 0, ( UNLEN + 1 ) * sizeof( TCHAR ) );
        }

        RequesterInfo.ptszUserName = tszUserName;
    }
    else
    {
        RequesterInfo.ptszUserName = pLicenseContext->ptszClientUserName;
    }

    if( pLicenseContext->pbOldLicense )
    {
        //
        // attempt to upgrade an old license
        //
        
        Status = CheckUpgradeLicense(
                                pLicenseContext,
                                &dwSupportFlags,
                                &LicenseRequest,
                                ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen,
                                ChallengeResponse,
                                &Hwid,
                                pcbOutBuf,
                                ppOutBuf );

        if ((NULL != pLicenseContext->pTsLicenseInfo)
            && (LICENSE_STATUS_OK != Status))
        {
            pLicenseContext->fLoggedProtocolError = TRUE;

            if (pLicenseContext->pTsLicenseInfo->fTempLicense)
            {
                // The expired temporary license could not be upgraded
                LicenseLogEvent(
                                EVENTLOG_INFORMATION_TYPE,
                                EVENT_EXPIRED_TEMPORARY_LICENSE,
                                1,
                                &(RequesterInfo.ptszMachineName)
                                );
            }
            else
            {
                // The expired permanent license could not be renewed
                LicenseLogEvent(
                                EVENTLOG_INFORMATION_TYPE,
                                EVENT_EXPIRED_PERMANENT_LICENSE,
                                1,
                                &(RequesterInfo.ptszMachineName)
                                );
            }
        }

        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

    }
    else
    {
reconnect:

        Status = CheckConnectLicenseServer(pLicenseContext);
        if( LICENSE_STATUS_OK != Status )
        {
            goto done;
        }

        RpcStatus = TLSIssueNewLicenseEx( 
                                       pLicenseContext->hLSHandle,
                                       &dwSupportFlags,
                                       0,       // ChallengeContext unused
                                       &LicenseRequest,
                                       RequesterInfo.ptszMachineName,
                                       RequesterInfo.ptszUserName,
                                       ( DWORD )PlatformChallengeResponse.EncryptedChallengeResponse.wBlobLen,
                                       ChallengeResponse,
                                       TRUE,
                                       1,       // dwQuantity
                                       &cbLicenseSize,
                                       &pLicense,
                                       &LsStatus );

        if ( RPC_S_OK != RpcStatus )
        {
            if (!fRetried)
            {
                fRetried = TRUE;
                pLicenseContext->hLSHandle = NULL;
                goto reconnect;
            }
            else
            {
                Status = LICENSE_STATUS_NO_LICENSE_SERVER;
            }
        }
        else if ( LSERVER_ERROR_BASE <= LsStatus )
        {
            Status = LsStatusToLicenseStatus(LsStatus,
                                         LICENSE_STATUS_NO_LICENSE_ERROR);
        }
        else
        {
            DWORD dwLicenseState;
            Validation_Info ValidationInfo;

            //
            // Validate the license for the sole purpose of caching the
            // information.
            //

            ValidationInfo.pValidationData = ( PBYTE )&Hwid;
            ValidationInfo.cbValidationData = LICENSE_HWID_LENGTH;
            ValidationInfo.pProductInfo = &pLicenseContext->ProductInfo;
            ValidationInfo.pLicense = pLicense;
            ValidationInfo.cbLicense = cbLicenseSize;

            ValidateLicense(pLicenseContext,
                            &ValidationInfo,
                            &dwLicenseState,
                            TRUE        // fCheckForPermanent
                            );

            //
            // Store the raw license bits for later use. Ignore failure;
            // that only means that if this is a license that should be
            // marked, termsrv won't be able to.
            //

            CacheRawLicenseData(pLicenseContext, pLicense, cbLicenseSize);
            
            //
            // package up the new license
            //
            
            Status = PackageLicense( pLicenseContext, 
                                     cbLicenseSize, 
                                     pLicense, 
                                     pcbOutBuf, 
                                     ppOutBuf,
                                     TRUE );
        }
    }

    SetExtendedData(pLicenseContext, dwSupportFlags);

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    //
    // done with the protocol
    //

    HsState = ISSUED_LICENSE_COMPLETE;
    Status = LICENSE_STATUS_ISSUED_LICENSE;

done:

    //
    // log all issue license failures
    //

    if( (LICENSE_STATUS_ISSUED_LICENSE != Status)
        && (pLicenseContext != NULL)
        && (!pLicenseContext->fLoggedProtocolError) )
    {
        pLicenseContext->fLoggedProtocolError = TRUE;

        LicenseLogEvent( EVENTLOG_INFORMATION_TYPE, 
                         EVENT_CANNOT_ISSUE_LICENSE,                          
                         0, NULL );
    }

    if( pLicense )
    {
        LicenseMemoryFree( &pLicense );
    }

    if( pbSecretKey )
    {
        LicenseMemoryFree( &pbSecretKey );
    }
    
    if( pLicenseContext->pbOldLicense )
    {
        //
        // free the old license
        //

        LicenseMemoryFree( &pLicenseContext->pbOldLicense );
        pLicenseContext->cbOldLicense = 0;
    }

    FreeBinaryBlob( &PlatformChallengeResponse.EncryptedChallengeResponse );
    FreeBinaryBlob( &PlatformChallengeResponse.EncryptedHWID );

    pLicenseContext->State = HsState;

    return( Status );                                    
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
IssuePlatformChallenge(
    PHS_Protocol_Context pLicenseContext, 
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf )
{
    Hydra_Server_Platform_Challenge     
        PlatformChallenge;
    DWORD
        dwChallengeLen;
    LPBYTE
        pbChallengeData = NULL;
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;
    DWORD
        RpcStatus,LsStatus;
    CHALLENGE_CONTEXT
        ChallengeContext;

    //
    // generate the platform challenge
    //

    ASSERT( pLicenseContext );

    Status = CheckConnectLicenseServer(pLicenseContext);
    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    RpcStatus = TLSIssuePlatformChallenge(pLicenseContext->hLSHandle,
                                          pLicenseContext->dwClientPlatformID,
                                          &ChallengeContext, // Context is unused by server, but we need a non-null pointer
                                          &dwChallengeLen,
                                          &pbChallengeData,
                                          &LsStatus);

    if(( RPC_S_OK != RpcStatus ) || ( LSERVER_ERROR_BASE <= LsStatus ) )
    {
        Status = LICENSE_STATUS_NO_PLATFORM_CHALLENGE ;
#if DBG
        DbgPrint( "LICPROT: cannot issue platform challenge: 0x%x\n", Status );
#endif
        goto done;
    }                                     
    
    //
    // Form the platform challenge message
    //

    PlatformChallenge.EncryptedPlatformChallenge.wBlobLen = ( WORD )dwChallengeLen;
    PlatformChallenge.EncryptedPlatformChallenge.pBlob = pbChallengeData;

    //
    // calculate the MAC for the unencrypted platform challenge
    //

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext,
				                 PlatformChallenge.EncryptedPlatformChallenge.pBlob,
				                 ( DWORD )PlatformChallenge.EncryptedPlatformChallenge.wBlobLen,
				                 PlatformChallenge.MACData );

	if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: cannot generate MAC data for challenge platform: 0x%x\n", Status );
#endif
        goto done;
    }

    //
    // encrypt the platform challenge
    //

    Status = LicenseEncryptSessionData( &pLicenseContext->CryptoContext,
                                        PlatformChallenge.EncryptedPlatformChallenge.pBlob,
                                        PlatformChallenge.EncryptedPlatformChallenge.wBlobLen );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: cannot encrypt platform challenge data: 0x%x\n", Status );
#endif
        goto done;
    }
			   
    //
    // pack the platform challenge
    //

    Status = PackHydraServerPlatformChallenge( 
                    pLicenseContext->dwProtocolVersion,
                    &PlatformChallenge, 
                    ppOutBuf, 
                    pcbOutBuf );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LICPROT: cannot pack platform challenge data: 0x%x\n", Status );
#endif
        goto done;
    }

done:

    if( pbChallengeData )
    {
        LicenseMemoryFree( &pbChallengeData );
    }

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackageLicense(
    PHS_Protocol_Context pLicenseContext, 
    DWORD                     cbLicense,
    PBYTE                     pLicense,
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf,
    BOOL                      fNewLicense )
{
    LICENSE_STATUS Status;
    New_License_Info NewLicenseInfo;
    Hydra_Server_New_License NewLicense;
    DWORD cbEncryptedLicenseInfo = 0;

    if( ( 0 == cbLicense ) || ( NULL == pLicense ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Initialize the new license information
    //

    NewLicenseInfo.dwVersion        = pLicenseContext->ProductInfo.dwVersion;

	NewLicenseInfo.cbScope          = strlen( pLicenseContext->Scope ) + 1;
	NewLicenseInfo.pbScope          = pLicenseContext->Scope;

	NewLicenseInfo.cbCompanyName    = pLicenseContext->ProductInfo.cbCompanyName;
	NewLicenseInfo.pbCompanyName    = pLicenseContext->ProductInfo.pbCompanyName;

	NewLicenseInfo.cbProductID      = pLicenseContext->ProductInfo.cbProductID;
	NewLicenseInfo.pbProductID      = pLicenseContext->ProductInfo.pbProductID;

    NewLicenseInfo.cbLicenseInfo    = cbLicense;
	NewLicenseInfo.pbLicenseInfo    = pLicense;
    
    //
    // initialize the blob that will contain the encrypted new license 
    // information
    //

    NewLicense.EncryptedNewLicenseInfo.wBlobLen = 0;
    NewLicense.EncryptedNewLicenseInfo.pBlob = NULL;
    
    //
    // pack the new license information
    //

    Status = PackNewLicenseInfo( &NewLicenseInfo,
                                 &NewLicense.EncryptedNewLicenseInfo.pBlob, 
                                 &cbEncryptedLicenseInfo );

    NewLicense.EncryptedNewLicenseInfo.wBlobLen = ( WORD )cbEncryptedLicenseInfo;

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }                                

    //
    // calculate the mac data
    //

    Status = LicenseGenerateMAC( &pLicenseContext->CryptoContext,
                                 NewLicense.EncryptedNewLicenseInfo.pBlob,
                                 ( DWORD )NewLicense.EncryptedNewLicenseInfo.wBlobLen,
                                 NewLicense.MACData );
    
    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }    
                                 
        
    //
    // Encrypt the new license info
    //

    Status = LicenseEncryptSessionData( &pLicenseContext->CryptoContext,
                                        NewLicense.EncryptedNewLicenseInfo.pBlob,
                                        cbEncryptedLicenseInfo );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }
    
    //
    // package up the license for the client
    //

    if( fNewLicense )
    {
        Status = PackHydraServerNewLicense( 
                        pLicenseContext->dwProtocolVersion, 
                        &NewLicense, 
                        ppOutBuf, 
                        pcbOutBuf );
    }
    else
    {
        Status = PackHydraServerUpgradeLicense( 
                        pLicenseContext->dwProtocolVersion, 
                        &NewLicense, 
                        ppOutBuf, 
                        pcbOutBuf );
    }
    
done:
    
    if( NewLicense.EncryptedNewLicenseInfo.pBlob )
    {
        LicenseMemoryFree( &NewLicense.EncryptedNewLicenseInfo.pBlob );
    }

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ConstructProtocolResponse(
    HANDLE      hLicense,
    DWORD       dwResponse,
    PDWORD      pcbOutBuf,
    PBYTE *     ppOutBuf )
{
    PHS_Protocol_Context 
        pLicenseContext;
    LICENSE_STATUS 
        Status;

    pLicenseContext = ( PHS_Protocol_Context )hLicense;

    if (pLicenseContext == NULL)
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    LOCK( &pLicenseContext->CritSec );
    
    //
    // construct the server response.  If this is a per seat license context, use the
    // licensing protocol version specified in the context.  Otherwise, use the
    // protocol version that is compatible with Terminal server 4.0.
    //

    Status = ConstructServerResponse( 
                        pLicenseContext->dwProtocolVersion,
                        dwResponse, 
                        pcbOutBuf, 
                        ppOutBuf );

    UNLOCK( &pLicenseContext->CritSec );

    return( Status );
}



///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
ConstructServerResponse(
    DWORD                           dwProtocolVersion,
    DWORD                           dwResponse,
    PDWORD                          pcbOutBuf,
    PBYTE *                         ppOutBuf )
{
    License_Error_Message ErrorMsg;
    LICENSE_STATUS Status;
    
    if( ( NULL == pcbOutBuf ) || ( NULL == ppOutBuf ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( LICENSE_RESPONSE_VALID_CLIENT == dwResponse )
    {
        ErrorMsg.dwErrorCode            = GM_HS_ERR_VALID_CLIENT;
        ErrorMsg.dwStateTransition      = ST_NO_TRANSITION;
    }
    else if( LICENSE_RESPONSE_INVALID_CLIENT == dwResponse )
    {
        ErrorMsg.dwErrorCode            = GM_HS_ERR_INVALID_CLIENT;
        ErrorMsg.dwStateTransition      = ST_TOTAL_ABORT;
    }
    else
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    ErrorMsg.bbErrorInfo.wBlobLen   = 0;
    ErrorMsg.bbErrorInfo.pBlob      = NULL;

    Status = PackHydraServerErrorMessage( 
                    dwProtocolVersion, 
                    &ErrorMsg, 
                    ppOutBuf, 
                    pcbOutBuf );
    
    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
GetHydraServerPrivateKey(
    CERT_TYPE   CertType,
    PBYTE *     ppPrivateKey,
    PDWORD      pcbPrivateKey )
{
#ifndef USE_HARDCODED

    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    HANDLE hPrivateKeyFile = NULL;
    DWORD dwFileSizeHigh, dwFileSizeLow;
    WCHAR szPrivateKeyFile[MAX_PATH];

    //
    // form the path to the private key file
    //

    GetSystemDirectory( ( LPTSTR )szPrivateKeyFile, MAX_PATH );
    wcscat( szPrivateKeyFile, L"\\" );
    wcscat( szPrivateKeyFile, HYDRA_SERVER_PRIVATE_KEY_FILE );
    
    //
    // get the private key of the hydra server.
    // For now, get the private key from a file.
    //

    hPrivateKeyFile = CreateFile( szPrivateKeyFile,
                                  GENERIC_READ,
                                  0,
                                  NULL,                               
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );

    if( INVALID_HANDLE_VALUE == hPrivateKeyFile )
    {
        Status = LICENSE_STATUS_NO_PRIVATE_KEY;
        goto done;
    }
    
    //
    // get the private key file size.  We're counting on the private key file
    // not to exceed 64K
    //

    dwFileSizeLow = GetFileSize( hPrivateKeyFile, &dwFileSizeHigh );

    if( 0xFFFFFFFF == dwFileSizeLow )
    {
        Status = LICENSE_STATUS_NO_PRIVATE_KEY;
        goto done;
    }
    
    //
    // allocate memory for the certificate and read the private key from the file.
    //

    *ppPrivateKey = NULL;
    Status = LicenseMemoryAllocate( dwFileSizeLow, ppPrivateKey );
    
    if( LICENSE_STATUS_OK != Status )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto done;
    }
    
    if( 0 > ReadFile( hPrivateKeyFile, 
                      *ppPrivateKey, 
                      dwFileSizeLow, 
                      pcbPrivateKey, 
                      NULL ) )
    {
        if( *ppPrivateKey )
        {
            LicenseMemoryFree( ppPrivateKey );
        }    

        Status = LICENSE_STATUS_NO_PRIVATE_KEY;        
    }

done:
    
    if( hPrivateKeyFile )
    {
        CloseHandle( hPrivateKeyFile );
    }
   
    return( Status );

#else

    LICENSE_STATUS  Status;
    DWORD           dwSize;
    LSCSPINFO       CspData;

    //
    // Get the private key for the certificate that we are using
    //

    if( CERT_TYPE_PROPRIETORY == CertType )
    {
        CspData = LsCspInfo_PrivateKey;
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        CspData = LsCspInfo_X509CertPrivateKey;
    }
    else
    {
        return( LICENSE_STATUS_NO_PRIVATE_KEY );
    }

    //
    // call the Lscsp library to obtain the private key
    //

    if( LsCsp_GetServerData( CspData, NULL, &dwSize ) != LICENSE_STATUS_OK )
    {
        return( LICENSE_STATUS_NO_PRIVATE_KEY );
    }

    Status = LicenseMemoryAllocate( dwSize, ppPrivateKey );
    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    if( LsCsp_GetServerData( CspData, *ppPrivateKey, &dwSize )
            != LICENSE_STATUS_OK )
    {
        LicenseMemoryFree( ppPrivateKey );
        return( LICENSE_STATUS_INSUFFICIENT_BUFFER );
    }

    *pcbPrivateKey = dwSize;

    return( LICENSE_STATUS_OK );
        
#endif

}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
GetEnvelopedData( 
    CERT_TYPE   CertType,
    PBYTE       pEnvelopedData,
    DWORD       dwEnvelopedDataLen,
    PBYTE *     ppData,
    PDWORD      pdwDataLen )
{
    LICENSE_STATUS
        Status;

    LsCsp_DecryptEnvelopedData(
                        CertType,
                        pEnvelopedData,
                        dwEnvelopedDataLen,
                        NULL,
                        pdwDataLen );
    
    Status = LicenseMemoryAllocate( *pdwDataLen, ppData );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    if( !LsCsp_DecryptEnvelopedData(
                        CertType,
                        pEnvelopedData,
                        dwEnvelopedDataLen,
                        *ppData,
                        pdwDataLen ) )
    {
        Status = LICENSE_STATUS_INVALID_INPUT;
    }

done:
    
    return( Status );    
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
InitProductInfo(
    PProduct_Info   pProductInfo,
    LPTSTR          lptszProductSku )
{
    LICENSE_STATUS Status;

    pProductInfo->pbCompanyName = NULL;
    pProductInfo->pbProductID = NULL;   
    
    pProductInfo->dwVersion      = g_dwTerminalServerVersion;    

    pProductInfo->cbCompanyName  = wcslen( PRODUCT_INFO_COMPANY_NAME )  * sizeof( WCHAR )
                                   + sizeof( WCHAR );

    Status = LicenseMemoryAllocate( pProductInfo->cbCompanyName,
                                    &pProductInfo->pbCompanyName );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "InitProductInfo: cannot allocate memory: 0x%x\n", Status );
#endif
        goto error;
    }
    
    wcscpy( ( PWCHAR )pProductInfo->pbCompanyName, PRODUCT_INFO_COMPANY_NAME );

    pProductInfo->cbProductID = _tcslen( lptszProductSku ) * sizeof( TCHAR )
								+ sizeof( TCHAR );

    Status = LicenseMemoryAllocate( pProductInfo->cbProductID,
                                    &pProductInfo->pbProductID );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "InitProductInfo: cannot allocate memory: 0x%x\n", Status );
#endif
        goto error;
    }
    
    _tcscpy( ( PTCHAR )pProductInfo->pbProductID, lptszProductSku );

    return( Status );

error:

    //
    // error return, free allocated resources
    //

    if( pProductInfo->pbCompanyName )
    {
        LicenseMemoryFree( &pProductInfo->pbCompanyName );
    }

    if( pProductInfo->pbProductID )
    {
        LicenseMemoryFree( &pProductInfo->pbProductID );
    }

    return( Status );
}

#define THROTTLE_WRAPAROUND 100

//
// Reduce the frequency of logging
// No need to strictly limit it to once every 100 calls
//

void
ThrottleLicenseLogEvent(
    WORD        wEventType,
    DWORD       dwEventId,
    WORD        cStrings,
    PWCHAR    * apwszStrings )
{
    static LONG lLogged = THROTTLE_WRAPAROUND;
    LONG lResult;

    lResult = InterlockedIncrement(&lLogged);

    if (THROTTLE_WRAPAROUND <= lResult)
    {
        LicenseLogEvent(
                        wEventType,
                        dwEventId,
                        cStrings,
                        apwszStrings );

        lLogged = 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
void
LicenseLogEvent(
    WORD        wEventType,
    DWORD       dwEventId,
    WORD        cStrings,
    PWCHAR    * apwszStrings )
{
    if (!g_fEventLogOpen)
    {	
        LOCK(&g_EventLogCritSec);

        if (!g_fEventLogOpen)
        {
            g_hEventLog = RegisterEventSource( NULL,
                                               TERMINAL_SERVICE_EVENT_LOG );

            if (NULL != g_hEventLog)
            {
                g_fEventLogOpen = TRUE;
            }
        }

        UNLOCK(&g_EventLogCritSec);
    }

    if( g_hEventLog )
    {
        WCHAR *wszStringEmpty = L"";

        if (NULL == apwszStrings)
            apwszStrings = &wszStringEmpty;

        if ( !ReportEvent( g_hEventLog, 
                           wEventType,
                           0, 
                           dwEventId,
                           NULL, 
                           cStrings, 
                           0, 
                           apwszStrings, 
                           NULL ) )
        {
#if DBG
            DbgPrint( "LogEvent: could not log event: 0x%x\n", GetLastError() );
#endif
        }
    }

    return;
}

#ifdef UNICODE

/*++

Function:

    Ascii2Wchar

Description:

    Convert an ascii string to a wide character string.  This function is only
    defined if UNICODE is defined.  This function allocates memory for the
    return value of the wide character string.

Arguments:

    lpszAsciiStr - Points to the ascii string
    ppwszWideStr - Points to the pointer to the wide character string.

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code otherwise.

--*/

LICENSE_STATUS
Ascii2Wchar
(
    LPSTR lpszAsciiStr,
    LPWSTR * ppwszWideStr )
{
    LICENSE_STATUS
        Status;

    if( ( NULL == lpszAsciiStr ) || ( NULL == ppwszWideStr ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // allocate memory for the wide string
    //


    //
    // Allocate extra space for NULL, mbstowcs() does not NULL terminate string
    // 

    Status = LicenseMemoryAllocate( 
                    ( _mbslen( lpszAsciiStr ) + 2 ) * sizeof( WCHAR ), 
                    ppwszWideStr );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    if( 0 >= mbstowcs( *ppwszWideStr, lpszAsciiStr, _mbslen( lpszAsciiStr ) + 1 ) )
    {
#if DBG
        DbgPrint( "LICPROT: Ascii2Wchar: cannot convert ascii string to wide char\n" );
#endif
        Status = LICENSE_STATUS_INVALID_INPUT;
    }

    return( Status );
}

#endif

/*++

Function:

    QueryLicenseInfo

Description:

    Query the license information provided by the client

Parameters:

    pLicenseContext - License protocol context
    pTsLicenseInfo - Pointer to license information

Return:

    If successful, pTsLicenseInfo will contain the license info and this
    function returns LICENSE_STATUS_SUCCESS.  Otherwise, returns a
    LICENSE_STATUS error.

--*/

LICENSE_STATUS
QueryLicenseInfo(
    HANDLE               hContext,
    PTS_LICENSE_INFO     pTsLicenseInfo )
{
    PHS_Protocol_Context
        pLicenseContext = (PHS_Protocol_Context) hContext;
    LICENSE_STATUS
        Status;

    if( ( NULL == hContext ) || ( NULL == pTsLicenseInfo ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( NULL == pLicenseContext->pTsLicenseInfo )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    //
    // indicate if the license is temporary
    //

    pTsLicenseInfo->fTempLicense = pLicenseContext->pTsLicenseInfo->fTempLicense;

    //
    // license validity dates
    //

    pTsLicenseInfo->NotAfter = pLicenseContext->pTsLicenseInfo->NotAfter;

    //
    // raw license data
    //

    if (NULL != pTsLicenseInfo->pbRawLicense)
    {
        LicenseMemoryFree( &pTsLicenseInfo->pbRawLicense );
    }


    Status = LicenseMemoryAllocate(
                       pLicenseContext->pTsLicenseInfo->cbRawLicense,
                       &(pTsLicenseInfo->pbRawLicense));

    if (Status != LICENSE_STATUS_OK)
    {
        return Status;
    }

    memcpy(pTsLicenseInfo->pbRawLicense,
            pLicenseContext->pTsLicenseInfo->pbRawLicense,
            pLicenseContext->pTsLicenseInfo->cbRawLicense);

    pTsLicenseInfo->cbRawLicense
        = pLicenseContext->pTsLicenseInfo->cbRawLicense;

    //
    // flags
    //

    pTsLicenseInfo->dwSupportFlags
        = pLicenseContext->pTsLicenseInfo->dwSupportFlags;

    return( LICENSE_STATUS_OK );
}

/*++

Function:

    FreeLicenseInfo

Description:

    Free the memory allocated for the elements in the TS_LICENSE_INFO structure.

Parameters:

    pTsLicenseInfo - Pointer to a TS_LICENSE_INFO structure

Returns:

    Nothing.

--*/

VOID
FreeLicenseInfo(
    PTS_LICENSE_INFO        pTsLicenseInfo )
{
    FreeTsLicenseInfo( pTsLicenseInfo );
    return;
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
AcceptProtocolContext(
    IN HANDLE hContext,
    IN DWORD cbInBuf,
    IN PBYTE pInBuf,
    IN OUT DWORD * pcbOutBuf,
    IN OUT PBYTE * ppOutBuf )
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS Status;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

	LOCK( &pLicenseContext->CritSec );

    if( INIT == pLicenseContext->State )
    {
        //
        // Generate a hydra server hello message to request for client
        // license
        //

        Status = CreateHydraServerHello(pLicenseContext,
                                        cbInBuf,
                                        pInBuf,
                                        pcbOutBuf,
                                        ppOutBuf);
        goto done;
        
    } 
    else if( SENT_SERVER_HELLO == pLicenseContext->State )
    {
        //
        // Hello response from the client
        //

        Status = HandleHelloResponse(pLicenseContext,
                                     cbInBuf,
                                     pInBuf,
                                     pcbOutBuf,
                                     ppOutBuf);
        goto done;
    }
    else if( ISSUED_PLATFORM_CHALLENGE == pLicenseContext->State )
    {
        //
        // Handle the platform challenge response
        //

        Status = HandlePlatformChallengeResponse(pLicenseContext,
                                                 cbInBuf,
                                                 pInBuf,
                                                 pcbOutBuf,
                                                 ppOutBuf);
        goto done;
    }
    else
    {
        Status = LICENSE_STATUS_INVALID_SERVER_CONTEXT;
    }

    //
    // check other states to create other messages as required...
    //

done:

    //
    // handle any error before returning.
    //
    // If the current status is LICENSE_STATUS_SERVER_ABORT, it means
    // that we have already tried to handle the error conditions 
    // with no success and the only option is to abort without
    // informing the client licensing protocol.
    //

    if( ( LICENSE_STATUS_OK != Status ) &&
        ( LICENSE_STATUS_CONTINUE != Status ) &&
        ( LICENSE_STATUS_ISSUED_LICENSE != Status ) &&
        ( LICENSE_STATUS_SEND_ERROR != Status ) &&
        ( LICENSE_STATUS_SERVER_ABORT != Status ) &&
        ( LICENSE_STATUS_INVALID_SERVER_CONTEXT != Status ) )
    {
        HandleErrorCondition( pLicenseContext, pcbOutBuf, ppOutBuf, &Status );
    }

    UNLOCK( &pLicenseContext->CritSec );

    return( Status );
}

LICENSE_STATUS
RequestNewLicense(
    IN HANDLE hContext,
    IN TCHAR *tszLicenseServerName,
    IN LICENSEREQUEST *pLicenseRequest,
    IN TCHAR *tszComputerName,
    IN TCHAR *tszUserName,
    IN BOOL fAcceptTempLicense,
    IN BOOL fAcceptFewerLicenses,
    IN DWORD *pdwQuantity,
    OUT DWORD *pcbLicense,
    OUT PBYTE *ppbLicense
    )
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS LsStatus;
    DWORD dwChallengeResponse = 0;
    DWORD RpcStatus;
    DWORD dwSupportFlags = SUPPORT_PER_SEAT_REISSUANCE;
    BOOL fRetried = FALSE;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

    LOCK( &pLicenseContext->CritSec );

reconnect:
    if (NULL != tszLicenseServerName)
    {
        LsStatus = CheckConnectNamedLicenseServer(pLicenseContext,
                                                  tszLicenseServerName);
    }
    else
    {
        LsStatus = CheckConnectLicenseServer(pLicenseContext);
    }

    if( LICENSE_STATUS_OK != LsStatus )
    {
        goto done;
    }

    RpcStatus = TLSIssueNewLicenseExEx( 
                        pLicenseContext->hLSHandle,
                        &dwSupportFlags,
                        0,                      // Challenge Context
                        pLicenseRequest,
                        tszComputerName,
                        tszUserName,
                        sizeof(DWORD),          // cbChallengeResponse
                        (PBYTE) &dwChallengeResponse,
                        fAcceptTempLicense,
                        fAcceptFewerLicenses,
                        pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        &LsStatus );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            LsStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        LsStatus = LsStatusToLicenseStatus(LsStatus,
                                           LICENSE_STATUS_NO_LICENSE_ERROR);
    }

done:

    UNLOCK( &pLicenseContext->CritSec );

    return LsStatus;
}

// TODO: Generalize this for all license types

LICENSE_STATUS
ReturnInternetLicense(
    IN HANDLE hContext,
    IN TCHAR *tszLicenseServer,
    IN LICENSEREQUEST *pLicenseRequest,
    IN ULARGE_INTEGER ulSerialNumber,
    IN DWORD dwQuantity
    )
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS LsStatus;
    DWORD RpcStatus;
    BOOL fRetried = FALSE;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

	LOCK( &pLicenseContext->CritSec );


reconnect:
    if (NULL != tszLicenseServer)
    {
        LsStatus = CheckConnectNamedLicenseServer(pLicenseContext,
                                                  tszLicenseServer);
    }
    else
    {
        LsStatus = CheckConnectLicenseServer(pLicenseContext);
    }

    if (LICENSE_STATUS_OK != LsStatus)
    {
        goto done;
    }

    RpcStatus = TLSReturnInternetLicenseEx(
                         pLicenseContext->hLSHandle,
                         pLicenseRequest,
                         &ulSerialNumber,
                         dwQuantity,
                         &LsStatus );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            LsStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        LsStatus = LsStatusToLicenseStatus(LsStatus,
                                           LICENSE_STATUS_NOT_SUPPORTED);
    }

done:

    UNLOCK( &pLicenseContext->CritSec );

    return( LsStatus );
}

/****************************************************************************
 *
 * FileTimeToUnixTime
 *
 *   Convert FILETIME to UNIX time (time_t)
 *
 * ENTRY:
 *   pft (input)
 *     pointer FILETIME structure
 *   t (input/output)
 *     pointer to UNIX time
 *
 * EXIT:
 *   TRUE - Success
 *   FALSE - Failure
 *
 ****************************************************************************/

BOOL
FileTimeToUnixTime(
    LPFILETIME  pft,
    time_t *    t
    )
{
    SYSTEMTIME sysTime;
    struct tm gmTime;

    if( FileTimeToSystemTime( pft, &sysTime ) == FALSE )
    {
        return( FALSE );
    }

    if( sysTime.wYear >= 2038 )
    {
        *t = INT_MAX;
    }
    else
    {
        //
        // Unix time support up to 2038/1/18
        // restrict any expiration data
        //

        memset( &gmTime, 0, sizeof( gmTime ) );
        gmTime.tm_sec = sysTime.wSecond;
        gmTime.tm_min = sysTime.wMinute;
        gmTime.tm_hour = sysTime.wHour;
        gmTime.tm_year = sysTime.wYear - 1900;
        gmTime.tm_mon = sysTime.wMonth - 1;
        gmTime.tm_mday = sysTime.wDay;

        *t = mktime( &gmTime );
    }

    return( *t != ( time_t )-1 );
}

/*++

Function:

    DaysToExpiration

Description:

    Return expiration info from the client license

Parameters:

    hContext - License protocol context
    pdwDaysLeft - Number of days to expiration is returned here.  If the
                        license has already expired, this is 0.  If the
                        license has no expiration date, this is 0xFFFFFFFF
    pfTemporary - Whether the license is temporary is returned here

Return:

    If successful, the output parameters are filled in, and this
    function returns LICENSE_STATUS_SUCCESS.  Otherwise, returns a
    LICENSE_STATUS error.

--*/

LICENSE_STATUS
DaysToExpiration(
    HANDLE               hContext,
    DWORD                *pdwDaysLeft,
    BOOL                 *pfTemporary
    )
{
    PHS_Protocol_Context
        pLicenseContext = (PHS_Protocol_Context) hContext;
    time_t
        Expiration,
        CurrentTime;

    if ( NULL == hContext )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( NULL == pLicenseContext->pTsLicenseInfo )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    //
    // indicate if the license is temporary
    //

    if (NULL != pfTemporary)
    {
        *pfTemporary = pLicenseContext->pTsLicenseInfo->fTempLicense;
    }

    //
    // license validity dates
    //

    if (NULL != pdwDaysLeft)
    {
        if ( FALSE == FileTimeToUnixTime( &pLicenseContext->pTsLicenseInfo->NotAfter, &Expiration ) )
        {
            return (LICENSE_STATUS_INVALID_CLIENT_CONTEXT);
        }

        if (PERMANENT_LICENSE_EXPIRE_DATE == Expiration)
        {
            *pdwDaysLeft = 0xFFFFFFFF;
        }
        else
        {
            time( &CurrentTime );

            if( CurrentTime >= Expiration )
            {
                //
                // license already expired
                //

                *pdwDaysLeft = 0;
            }

            //
            // figure out how many more days to go before license expires
            //

            *pdwDaysLeft = (DWORD)(( Expiration - CurrentTime ) / SECONDS_IN_A_DAY);
        }
    }

    return( LICENSE_STATUS_OK );
}


/*++

Function:

    MarkLicenseFlags

Description:

    Marks the license at the license server as being used in a valid logon.

--*/

LICENSE_STATUS
MarkLicenseFlags(
    HANDLE hContext,
    UCHAR ucFlags
    )
{
    PHS_Protocol_Context pLicenseContext;
    LICENSE_STATUS LsStatus;
    DWORD RpcStatus;
    BOOL fRetried = FALSE;

    pLicenseContext = ( PHS_Protocol_Context )hContext;

    if( NULL == pLicenseContext->pTsLicenseInfo )
    {
        return( LICENSE_STATUS_NO_LICENSE_ERROR );
    }

    if (!pLicenseContext->pTsLicenseInfo->fTempLicense)
    {
        return LICENSE_STATUS_OK;
    }

	LOCK( &pLicenseContext->CritSec );

reconnect:
    LsStatus = CheckConnectLicenseServer(pLicenseContext);

    if( LICENSE_STATUS_OK != LsStatus )
    {
        goto done;
    }

    RpcStatus = TLSMarkLicense( 
                        pLicenseContext->hLSHandle,
                        ucFlags,
                        pLicenseContext->pTsLicenseInfo->cbRawLicense,
                        pLicenseContext->pTsLicenseInfo->pbRawLicense,
                        &LsStatus );

    if ( RPC_S_OK != RpcStatus )
    {
        if (!fRetried)
        {
            fRetried = TRUE;
            pLicenseContext->hLSHandle = NULL;
            goto reconnect;
        }
        else
        {
            LsStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        }
    }
    else if ( LSERVER_ERROR_BASE <= LsStatus )
    {
        LsStatus = LsStatusToLicenseStatus(LsStatus,
                                           LICENSE_STATUS_NOT_SUPPORTED);
    }  

done:
    UNLOCK( &pLicenseContext->CritSec );

    return LsStatus;
}


/*++

Function:

    CacheRawLicenseData

Description:

    Caches the unpacked license bits in the TS_LICENSE_INFO for later use.
    The TS_LICENSE_INFO struct should already be created.

--*/

LICENSE_STATUS
CacheRawLicenseData(
    PHS_Protocol_Context pLicenseContext,
    PBYTE pbRawLicense,
    DWORD cbRawLicense
    )
{
    LICENSE_STATUS Status;

    if ((pLicenseContext == NULL) || (pLicenseContext->pTsLicenseInfo == NULL))
    {
        return(LICENSE_STATUS_INVALID_INPUT);
    }

    if (pLicenseContext->pTsLicenseInfo->pbRawLicense != NULL)
    {
        LicenseMemoryFree(&(pLicenseContext->pTsLicenseInfo->pbRawLicense));
    }

    Status = LicenseMemoryAllocate(cbRawLicense,
            &(pLicenseContext->pTsLicenseInfo->pbRawLicense));

    if (Status == LICENSE_STATUS_OK)
    {
        memcpy(pLicenseContext->pTsLicenseInfo->pbRawLicense, pbRawLicense,
                cbRawLicense);

        pLicenseContext->pTsLicenseInfo->cbRawLicense = cbRawLicense;
    }

    return(Status);
}

/*++

Function:

    SetExtendedData

Description:

    Sets the new fields in the TsLicenseInfo.

--*/

LICENSE_STATUS
SetExtendedData(
    PHS_Protocol_Context pLicenseContext,
    DWORD dwSupportFlags
    )
{
    if ((pLicenseContext == NULL) || (pLicenseContext->pTsLicenseInfo == NULL))
    {
        return(LICENSE_STATUS_INVALID_INPUT);
    }

    pLicenseContext->pTsLicenseInfo->dwSupportFlags = dwSupportFlags;

    return(LICENSE_STATUS_OK);
}

/*++

Function:

    LsStatusToLicenseStatus

Description:

    Map a license server error code to a LICENSE_STATUS

--*/

LICENSE_STATUS
LsStatusToLicenseStatus(
    DWORD LsStatus,
    DWORD LsStatusDefault
    )
{
    LICENSE_STATUS LicenseStatus;

    switch (LsStatus)
    {
    case LSERVER_S_SUCCESS:
        LicenseStatus = LICENSE_STATUS_OK;
        break;

    case LSERVER_E_OUTOFMEMORY:
        LicenseStatus = LICENSE_STATUS_OUT_OF_MEMORY;
        break;

    case LSERVER_E_INVALID_DATA:
        LicenseStatus = LICENSE_STATUS_INVALID_INPUT;
        break;

    case LSERVER_E_LS_NOTPRESENT:
    case LSERVER_E_LS_NOTRUNNING:
        LicenseStatus = LICENSE_STATUS_NO_LICENSE_SERVER;
        break;

    case LSERVER_E_NO_LICENSE:
    case LSERVER_E_NO_PRODUCT:
    case LSERVER_E_NO_CERTIFICATE:      // not activated
        LicenseStatus = LICENSE_STATUS_NO_LICENSE_ERROR;
        break;

    case LSERVER_E_INTERNAL_ERROR:
        LicenseStatus = LICENSE_STATUS_UNSPECIFIED_ERROR;
        break;

    default:
        LicenseStatus = LsStatusDefault;
        break;
    }

    return LicenseStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\hspack.c ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include "precomp.h"


///////////////////////////////////////////////////////////////////////////////
VOID
CopyBinaryBlob(
    PBYTE           pbBuffer, 
    PBinary_Blob    pbbBlob, 
    DWORD *         pdwCount )
{
    *pdwCount = 0;

    //
    // First copy the wBlobType data;
    //

    memcpy( pbBuffer, &pbbBlob->wBlobType, sizeof( WORD ) );
    pbBuffer += sizeof( WORD );
    *pdwCount += sizeof( WORD );

    //
    // Copy the wBlobLen data
    //

    memcpy( pbBuffer, &pbbBlob->wBlobLen, sizeof( WORD ) );
    pbBuffer += sizeof( WORD );
    *pdwCount += sizeof( WORD );

    if( 0 == pbbBlob->wBlobLen )
    {
        return;
    }

    //
    // Copy the actual data
    //

    memcpy( pbBuffer, pbbBlob->pBlob, pbbBlob->wBlobLen );
    *pdwCount += pbbBlob->wBlobLen;

}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
GetBinaryBlob(
    PBinary_Blob    pBBlob,
    PBYTE           pMessage,
    PDWORD          pcbProcessed )
{
    PBinary_Blob    pBB;
    LICENSE_STATUS  Status;

    pBB = ( PBinary_Blob )pMessage;
    
    pBBlob->wBlobType = pBB->wBlobType;
    pBBlob->wBlobLen = pBB->wBlobLen;
    pBBlob->pBlob = NULL;

    *pcbProcessed = 2 * ( sizeof( WORD ) );
        
    if( 0 == pBBlob->wBlobLen )
    {
        return( LICENSE_STATUS_OK );
    }

    //
    // Check that strings are NULL terminated
    //
    switch (pBB->wBlobType)
    {
        case BB_CLIENT_USER_NAME_BLOB:
        case BB_CLIENT_MACHINE_NAME_BLOB:
            if ('\0' != pMessage[(2 * sizeof(WORD)) + (pBB->wBlobLen) - 1])
            {
                __try
                {
                    //
                    // Handle bug in old client, where length is off by one
                    //
                    if ('\0' == pMessage[(2 * sizeof(WORD)) + pBB->wBlobLen])
                    {
                        pBBlob->wBlobLen++;
                        break;
                    }
                }
                __except( EXCEPTION_EXECUTE_HANDLER )
                {
                    return( LICENSE_STATUS_INVALID_INPUT );
                }

                //
                // Handle WTB client bug - send wrong data size.
                // At this stage of licensing, we don't really care about
                // client's machine and user name
                //
                pMessage[(2 * sizeof(WORD)) + (pBB->wBlobLen) - 1] = '\0';
                if(!(pBB->wBlobLen & 0x01))
                {
                    //
                    // Even length, assuming UNICODE, wBlobLen must > 1 to
                    // come to here
                    //
                    pMessage[(2 * sizeof(WORD)) + (pBB->wBlobLen) - 2] = '\0';
                }
                
                //return( LICENSE_STATUS_INVALID_INPUT );
            }
            break;
    }

    //
    // allocate memory for and copy the actual data
    //
    if( BB_CLIENT_USER_NAME_BLOB == pBB->wBlobType || 
        BB_CLIENT_MACHINE_NAME_BLOB == pBB->wBlobType )
    {
        // WINCE client sends UNICODE, add extra NULL at the end
        Status = LicenseMemoryAllocate( ( DWORD )pBBlob->wBlobLen + sizeof(WCHAR), &(pBBlob->pBlob) );
    }
    else
    {
        Status = LicenseMemoryAllocate( ( DWORD )pBBlob->wBlobLen, &(pBBlob->pBlob) );
    }

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }
    
    __try
    {
        memcpy( pBBlob->pBlob, pMessage + ( 2 * sizeof( WORD ) ), pBBlob->wBlobLen );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        LicenseMemoryFree( &pBBlob->pBlob );

        return( LICENSE_STATUS_INVALID_INPUT );
    }


    *pcbProcessed += ( DWORD )pBBlob->wBlobLen;

    return( LICENSE_STATUS_OK );
}


///////////////////////////////////////////////////////////////////////////////
VOID
FreeBinaryBlob(
    PBinary_Blob pBlob )
{
    if( pBlob->pBlob )
    {
        LicenseMemoryFree( &pBlob->pBlob );
        pBlob->wBlobLen = 0;
    }

    return;
}


    
///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerLicenseRequest(
    DWORD                           dwProtocolVersion,
    PHydra_Server_License_Request   pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    Preamble        Header;
    DWORD           i, cbCopied;
    PBinary_Blob    pBlob;
    LICENSE_STATUS  Status = LICENSE_STATUS_OK;
    PBYTE           pNetworkBuf;    

    ASSERT( pCanonical );
    
    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );        
    }

    //
    // calculate the size needed for network format
    //

    Header.wMsgSize = (WORD)(sizeof( Preamble ) + 
                      LICENSE_RANDOM +
                      sizeof( DWORD ) + 
                      sizeof( DWORD ) + pCanonical->ProductInfo.cbCompanyName +
                      sizeof( DWORD ) + pCanonical->ProductInfo.cbProductID +
                      GetBinaryBlobSize( pCanonical->KeyExchngList ) +
                      GetBinaryBlobSize( pCanonical->ServerCert ) +
                      sizeof( DWORD ) +
                      ( pCanonical->ScopeList.dwScopeCount * ( sizeof( WORD ) + sizeof( WORD ) ) ) );

    for( i = 0, pBlob = pCanonical->ScopeList.Scopes; 
         i < pCanonical->ScopeList.dwScopeCount; 
         i++ )
    {
        Header.wMsgSize += pBlob->wBlobLen;
        pBlob++;
    }

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    pNetworkBuf = *ppNetwork;

    //
    // copy the header
    //

    Header.bMsgType = HS_LICENSE_REQUEST;
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the server random number
    //

    memcpy( pNetworkBuf, pCanonical->ServerRandom, LICENSE_RANDOM );
    pNetworkBuf += LICENSE_RANDOM;

    //
    // copy the product info
    //

    memcpy( pNetworkBuf, &pCanonical->ProductInfo.dwVersion, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, &pCanonical->ProductInfo.cbCompanyName, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->ProductInfo.pbCompanyName, 
            pCanonical->ProductInfo.cbCompanyName );
    pNetworkBuf += pCanonical->ProductInfo.cbCompanyName;

    memcpy( pNetworkBuf, &pCanonical->ProductInfo.cbProductID, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->ProductInfo.pbProductID, 
            pCanonical->ProductInfo.cbProductID );
    pNetworkBuf += pCanonical->ProductInfo.cbProductID;

    //
    // copy the key exchange list
    //

    CopyBinaryBlob( pNetworkBuf, &pCanonical->KeyExchngList, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the hydra server certificate
    //

    CopyBinaryBlob( pNetworkBuf, &pCanonical->ServerCert, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the scope list
    //

    memcpy( pNetworkBuf, &pCanonical->ScopeList.dwScopeCount, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    for( i = 0, pBlob = pCanonical->ScopeList.Scopes; 
         i < pCanonical->ScopeList.dwScopeCount; 
         i++ )
    {
        CopyBinaryBlob( pNetworkBuf, pBlob, &cbCopied );
        pNetworkBuf += cbCopied;
        pBlob++;
    }
    
PackError:

    return( Status );

}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerPlatformChallenge(
    DWORD                               dwProtocolVersion,
    PHydra_Server_Platform_Challenge    pCanonical,
    PBYTE*                              ppNetwork,
    DWORD*                              pcbNetwork )
{
    Preamble        Header;
    DWORD           cbCopied;
    PBinary_Blob    pBlob;
    LICENSE_STATUS  Status = LICENSE_STATUS_OK;
    PBYTE           pNetworkBuf;    

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );        
    }

    //
    // calculate the buffer size needed
    //

    Header.wMsgSize = sizeof( Preamble ) +
                      sizeof( DWORD ) +
                      GetBinaryBlobSize( pCanonical->EncryptedPlatformChallenge ) +
                      LICENSE_MAC_DATA; 

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    
    pNetworkBuf = *ppNetwork;

    //
    // copy the header
    //

    Header.bMsgType = HS_PLATFORM_CHALLENGE;
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the connect flag
    //

    memcpy( pNetworkBuf, &pCanonical->dwConnectFlags, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    //
    // copy the encrypted platform challenge
    //
    
    CopyBinaryBlob( pNetworkBuf, &pCanonical->EncryptedPlatformChallenge, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the MAC
    //

    memcpy( pNetworkBuf, pCanonical->MACData, LICENSE_MAC_DATA );

    
PackError:

    return( Status );    
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerNewLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_New_License       pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    Preamble Header;
    DWORD cbCopied;
    PBinary_Blob pBlob;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PBYTE pNetworkBuf;    

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // calculate the buffer size needed
    //

    Header.wMsgSize = sizeof( Preamble ) +
                      GetBinaryBlobSize( pCanonical->EncryptedNewLicenseInfo ) +
                      LICENSE_MAC_DATA;

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    
    pNetworkBuf = *ppNetwork;

    //
    // copy the header
    //

    Header.bMsgType = HS_NEW_LICENSE;
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the encrypted new license info
    //

    CopyBinaryBlob( pNetworkBuf, &pCanonical->EncryptedNewLicenseInfo, &cbCopied );
    pNetworkBuf += cbCopied;

    //
    // copy the MAC
    //

    memcpy( pNetworkBuf, pCanonical->MACData, LICENSE_MAC_DATA );
    
PackError:

    return( Status );    

}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerUpgradeLicense(
    DWORD                           dwProtocolVersion,
    PHydra_Server_Upgrade_License   pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    LICENSE_STATUS Status;
    PPreamble pHeader;

    Status = PackHydraServerNewLicense( dwProtocolVersion, pCanonical, ppNetwork, pcbNetwork );

    if( LICENSE_STATUS_OK == Status )
    {
        //
        // make this an upgrade license message
        //

        pHeader = ( PPreamble )*ppNetwork;
        pHeader->bMsgType = HS_UPGRADE_LICENSE;
    }

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackHydraServerErrorMessage(
    DWORD                           dwProtocolVersion,
    PLicense_Error_Message          pCanonical,
    PBYTE*                          ppNetwork,
    DWORD*                          pcbNetwork )
{
    Preamble Header;
    DWORD cbCopied;
    PBinary_Blob pBlob;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PBYTE pNetworkBuf;    

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // calculate the buffer size needed
    //

    Header.wMsgSize = sizeof( Preamble ) +
                      sizeof( DWORD ) +
                      sizeof( DWORD ) +
                      GetBinaryBlobSize( pCanonical->bbErrorInfo );

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( Header.wMsgSize, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto PackError;
    }

    *pcbNetwork = Header.wMsgSize;
    
    pNetworkBuf = *ppNetwork;

    //
    // set up preamble
    //

    Header.bMsgType = GM_ERROR_ALERT; 
    Header.bVersion = GET_PREAMBLE_VERSION( dwProtocolVersion );

    memcpy( pNetworkBuf, &Header, sizeof( Preamble ) );
    pNetworkBuf += sizeof( Preamble );

    //
    // copy the error code, state transition and error info
    //

    memcpy( pNetworkBuf, &pCanonical->dwErrorCode, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, &pCanonical->dwStateTransition, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    CopyBinaryBlob( pNetworkBuf, &pCanonical->bbErrorInfo, &cbCopied );
    
PackError:

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
PackNewLicenseInfo( 
    PNew_License_Info               pCanonical,
    PBYTE*                          ppNetwork, 
    DWORD*                          pcbNetwork )
{
    DWORD cbBufNeeded;
    PBYTE pNetworkBuf;    
    LICENSE_STATUS Status = LICENSE_STATUS_OK;

    ASSERT( pCanonical );
    ASSERT( pcbNetwork );
    ASSERT( ppNetwork );

    if( ( NULL == pCanonical ) ||
        ( NULL == pcbNetwork ) ||
        ( NULL == ppNetwork ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // calculate the buffer size needed and check that the output
    // buffer is large enough
    //

    cbBufNeeded = 5 * sizeof( DWORD ) +
                  pCanonical->cbScope +
                  pCanonical->cbCompanyName +
                  pCanonical->cbProductID +
                  pCanonical->cbLicenseInfo;

    //
    // allocate the output buffer
    //

    Status = LicenseMemoryAllocate( cbBufNeeded, ppNetwork );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    *pcbNetwork = cbBufNeeded;
    
    pNetworkBuf = *ppNetwork;

    //
    // start copying the data
    //

    memcpy( pNetworkBuf, &pCanonical->dwVersion, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, &pCanonical->cbScope, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbScope, pCanonical->cbScope );
    pNetworkBuf += pCanonical->cbScope;

    memcpy( pNetworkBuf, &pCanonical->cbCompanyName, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbCompanyName, pCanonical->cbCompanyName );
    pNetworkBuf += pCanonical->cbCompanyName;

    memcpy( pNetworkBuf, &pCanonical->cbProductID, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbProductID, pCanonical->cbProductID );
    pNetworkBuf += pCanonical->cbProductID;

    memcpy( pNetworkBuf, &pCanonical->cbLicenseInfo, sizeof( DWORD ) );
    pNetworkBuf += sizeof( DWORD );

    memcpy( pNetworkBuf, pCanonical->pbLicenseInfo, pCanonical->cbLicenseInfo );
    pNetworkBuf += pCanonical->cbLicenseInfo;

done:

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
// Functions for unpacking different Hydra Client Messages from 
// simple binary blobs to corresponding structure
//

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientErrorMessage(
    PBYTE                           pbMessage,
    DWORD                           cbMessage,
    PLicense_Error_Message          pCanonical )
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0;

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;

    if( GM_ERROR_ALERT != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientErrorMessage: received unexpected message type %c\n", pHeader->bMsgType );        
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 2 * sizeof( DWORD );
    ASSERT( pHeader->wMsgSize >= ( WORD )cbUnpacked );

    //
    // get the license error structure
    //

    pNetwork = pbMessage + sizeof( Preamble );
    
    memcpy( &pCanonical->dwErrorCode, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );
    
    memcpy( &pCanonical->dwStateTransition, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    Status = GetBinaryBlob( &( pCanonical->bbErrorInfo ), pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }
    
    cbUnpacked += cbProcessed;

    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientLicenseInfo(
    PBYTE                           pbMessage,
    DWORD                           cbMessage, 
    PHydra_Client_License_Info      pCanonical )
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0;

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;

    if( HC_LICENSE_INFO != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientLicenseInfo: received unexpected message type %c\n", pHeader->bMsgType );        
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 
                 2 * sizeof( DWORD ) +
                 LICENSE_RANDOM +
                 LICENSE_MAC_DATA;

    ASSERT( pHeader->wMsgSize >= ( WORD )cbUnpacked );

    //
    // get the license info structure
    //

    pNetwork = pbMessage + sizeof( Preamble );
    
    memcpy( &pCanonical->dwPrefKeyExchangeAlg, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->dwPlatformID, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->ClientRandom, pNetwork, LICENSE_RANDOM );
    pNetwork += LICENSE_RANDOM;

    Status = GetBinaryBlob( &pCanonical->EncryptedPreMasterSecret, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        return( Status );
    }

    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    Status = GetBinaryBlob( &pCanonical->LicenseInfo, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        return( Status );
    }
    
    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    Status = GetBinaryBlob( &pCanonical->EncryptedHWID, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        if (Status == LICENSE_STATUS_INVALID_INPUT)
        {
            Status = LICENSE_STATUS_INVALID_RESPONSE;
        }

        return( Status );
    }
    
    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    memcpy( pCanonical->MACData, pNetwork, LICENSE_MAC_DATA );

    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientNewLicenseRequest(
    PBYTE                               pbMessage,
    DWORD                               cbMessage,
    PHydra_Client_New_License_Request   pCanonical )
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0;

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;

    if( HC_NEW_LICENSE_REQUEST != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientNewLicenseRequest: received unexpected message type %c\n", pHeader->bMsgType );
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 
                 2 * sizeof( DWORD ) +
                 LICENSE_RANDOM;

    ASSERT( pHeader->wMsgSize >= ( WORD )cbUnpacked );

    //
    // get the new license request structure
    //

    pNetwork = pbMessage + sizeof( Preamble );
    
    memcpy( &pCanonical->dwPrefKeyExchangeAlg, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->dwPlatformID, pNetwork, sizeof( DWORD ) );
    pNetwork += sizeof( DWORD );

    memcpy( &pCanonical->ClientRandom, pNetwork, LICENSE_RANDOM );
    pNetwork += LICENSE_RANDOM;

    Status = GetBinaryBlob( &pCanonical->EncryptedPreMasterSecret, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    cbUnpacked += cbProcessed;
    pNetwork += cbProcessed;

    //
    // we changed the licensing protocol to include the client user and machine
    // name.  So to prevent an older client that does not have the user and machine
    // name binary blobs from crashing the server, we add this check for the
    // message length.
    //

    if( pHeader->wMsgSize <= cbUnpacked )
    {
#if DBG
        DbgPrint( "UnPackHydraClientNewLicenseRequest: old licensing protocol\n" );
#endif
        pCanonical->ClientUserName.pBlob = NULL;
        pCanonical->ClientMachineName.pBlob = NULL;

        //
        // make these 2 fields optional for now.
        //

        return( Status );
    }
        
    Status = GetBinaryBlob( &pCanonical->ClientUserName, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    cbUnpacked += cbProcessed;
    pNetwork += cbProcessed;

    Status = GetBinaryBlob( &pCanonical->ClientMachineName, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    cbUnpacked += cbProcessed;
    
    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
UnPackHydraClientPlatformChallengeResponse(
    PBYTE                                       pbMessage,
    DWORD                                       cbMessage,
    PHydra_Client_Platform_Challenge_Response   pCanonical )
{
    DWORD cbUnpacked = 0;
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    PPreamble pHeader;
    PBYTE pNetwork;
    DWORD cbProcessed = 0;

    //
    // check the input parameters
    //

    ASSERT( NULL != pbMessage );
    ASSERT( 0 < cbMessage );
    ASSERT( NULL != pCanonical );

    if( ( NULL == pbMessage ) ||
        ( 0 >= cbMessage ) ||
        ( NULL == pCanonical ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // check the preamble
    //
    
    pHeader = ( PPreamble )pbMessage;

    if( HC_PLATFORM_CHALENGE_RESPONSE != pHeader->bMsgType )
    {
#if DBG
        DbgPrint( "UnPackHydraClientPlatformChallengeResponse: received unexpected message type %c\n", pHeader->bMsgType );
#endif
        return( LICENSE_STATUS_INVALID_RESPONSE );
    }

    //
    // do a calculation of the fixed field length
    //

    cbUnpacked = sizeof( Preamble ) + 
                 LICENSE_MAC_DATA;

    ASSERT( pHeader->wMsgSize >= ( WORD )cbUnpacked );

    //
    // get the platform challenge response structure
    //

    pNetwork = pbMessage + sizeof( Preamble );

    Status = GetBinaryBlob( &pCanonical->EncryptedChallengeResponse, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    Status = GetBinaryBlob( &pCanonical->EncryptedHWID, pNetwork, &cbProcessed );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    pNetwork += cbProcessed;
    cbUnpacked += cbProcessed;

    memcpy( pCanonical->MACData, pNetwork, LICENSE_MAC_DATA );

    ASSERT( pHeader->wMsgSize == ( WORD )cbUnpacked );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\licprotp.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        licprotp.h
//
// Contents:    Hydra Server License Protocol API private header file
//
// History:     02-08-00    RobLeit  Created
//
//-----------------------------------------------------------------------------


#ifndef _LICPROTP_H_
#define _LICPROTP_H_

//-----------------------------------------------------------------------------
//
// Hydra server licensing-related registry keys and values
//
//-----------------------------------------------------------------------------

#define HYDRA_SERVER_PARAM              L"SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters"
#define PERSEAT_LEEWAY_VALUE            L"PerSeatExpirationLeeway"

//-----------------------------------------------------------------------------
//
// Info of the license requester
//
// pwszMachineName - The name of the machine that the license is installed on.
// pwszUserName - The user name for which the license is issued to.
//
//-----------------------------------------------------------------------------

typedef struct _License_Requester_Info
{
    LPTSTR ptszMachineName;
    LPTSTR ptszUserName;

} License_Requester_Info, * PLicense_Requester_Info;


//-----------------------------------------------------------------------------
//
// The license request structure
//
//-----------------------------------------------------------------------------

typedef LICENSEREQUEST License_Request;
typedef PLICENSEREQUEST PLicense_Request;

//-----------------------------------------------------------------------------
//
// The files containing the hydra server certificates and keys
//
//-----------------------------------------------------------------------------

#define HYDRA_SERVER_RSA_CERTIFICATE_FILE   L"hsrsa.cer"
#define HYDRA_SERVER_PRIVATE_KEY_FILE       L"hskey.prv"

//-----------------------------------------------------------------------------
//
// Registry value to configure number of days prior to grace period expiration
// for event logging.
//
//-----------------------------------------------------------------------------

#define HS_PARAM_GRACE_PERIOD_EXPIRATION_WARNING_DAYS   L"LicensingGracePeriodExpirationWarningDays"

//-----------------------------------------------------------------------------
//
// The license protocol states
//
//-----------------------------------------------------------------------------

typedef enum
{
    INIT = 1,
    SENT_SERVER_HELLO,
    CLIENT_LICENSE_PENDING,
    ISSUED_PLATFORM_CHALLENGE,
    ABORTED,
    ISSUED_LICENSE_COMPLETE,
    VALIDATION_ERROR,
    VALIDATED_LICENSE_COMPLETE

} HS_LICENSE_STATE;

///////////////////////////////////////////////////////////////////////////
// The validation information that needs to be given to validate a license.
//

typedef struct _Validation_Info
{
    Product_Info  * pProductInfo;
    DWORD           cbLicense;
    PBYTE           pLicense;
    DWORD           cbValidationData;
    PBYTE           pValidationData;

} Validation_Info, * PValidation_Info;

//////////////////////////////////////////////////////////////////////////////
// The data used for verifying licenses
//

typedef struct _License_Verification_Data
{
    //
    // encrypted HWID
    //

    PBYTE       pEncryptedHwid;
    DWORD       cbEncryptedHwid;

    //
    // Valid dates
    //

    FILETIME    NotBefore;
    FILETIME    NotAfter;

    //
    // License Info
    //

    LPCERT_LICENSE_INFO pLicenseInfo;

    //
    // Manufacturer
    //

    PBYTE       pManufacturer;
    
    //
    // Manufacturer Data
    //

    LPMSMANUFACTURER_DATA pManufacturerData;
    
    //
    // Add any other fields necessary for verifying a license:
    //
      
} License_Verification_Data, * PLicense_Verification_Data;

//-----------------------------------------------------------------------------
//
// license protocol context
//
//-----------------------------------------------------------------------------

typedef struct _HS_Protocol_Context
{
    CRITICAL_SECTION    CritSec;    
    DWORD               dwProtocolVersion;
    BOOL                fAuthenticateServer;
    Product_Info        ProductInfo;
    HS_LICENSE_STATE    State;
    TLS_HANDLE          hLSHandle;
    DWORD               dwClientPlatformID;
    DWORD               dwClientError;
    PCHALLENGE_CONTEXT  pChallengeContext;
    PTCHAR              ptszClientUserName;
    PTCHAR              ptszClientMachineName;
    CERT_TYPE           CertTypeUsed;
    DWORD               dwKeyExchangeAlg;
    DWORD               cbOldLicense;
    PBYTE               pbOldLicense;
    PTS_LICENSE_INFO    pTsLicenseInfo;
    CryptSystem         CryptoContext;
    BOOL                fLoggedProtocolError;
    BYTE                Scope[MAX_PRODUCT_INFO_STRING_LENGTH];

} HS_Protocol_Context, * PHS_Protocol_Context;

#define PLATFORM_CHALLENGE_LENGTH       64

//-----------------------------------------------------------------------------
//
// Internal Functions
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

LICENSE_STATUS
CreateHydraServerHello( 
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf );


void
HandleErrorCondition( 
    PHS_Protocol_Context        pLicenseContext, 
    PDWORD                      pcbOutBuf, 
    PBYTE          *            ppOutBuf, 
    LICENSE_STATUS *            pStatus );


LICENSE_STATUS
ConstructServerResponse(
    DWORD                           dwProtocolVersion,
    DWORD                           dwResponse,
    PDWORD                          pcbOutBuf,
    PBYTE *                         ppOutBuf );


LICENSE_STATUS
HandleHelloResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf );


LICENSE_STATUS
HandleClientLicense(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf );


LICENSE_STATUS
HandleNewLicenseRequest(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf );


LICENSE_STATUS
HandleClientError(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf );


LICENSE_STATUS
HandlePlatformChallengeResponse(
    PHS_Protocol_Context pLicenseContext, 
    DWORD cbInBuf, 
    PBYTE pInBuf, 
    DWORD * pcbOutBuf, 
    PBYTE * ppOutBuf );


LICENSE_STATUS
GetEnvelopedData( 
    CERT_TYPE   CertType,
    PBYTE       pEnvelopedData,
    DWORD       dwEnvelopedDataLen,
    PBYTE *     ppData,
    PDWORD      pdwDataLen );


LICENSE_STATUS
InitProductInfo(
    PProduct_Info pProductInfo,
    LPTSTR        lptszProductSku );


LICENSE_STATUS
IssuePlatformChallenge(
    PHS_Protocol_Context      pLicenseContext, 
    PDWORD                    pcbOutBuf,
    PBYTE *                   ppOutBuf );


LICENSE_STATUS
PackageLicense(
    PHS_Protocol_Context      pLicenseContext, 
    DWORD                     cbLicense,
    PBYTE                     pLicense,
    PDWORD                    pcbOutBuf,
    PBYTE                   * ppOutBuf,
    BOOL                      fNewLicense );


void
LicenseLogEvent(
    WORD wEventType,
    DWORD dwEventId,
    WORD cStrings,
    PWCHAR *apwszStrings );

LICENSE_STATUS
CacheRawLicenseData(
    PHS_Protocol_Context pLicenseContext,
    PBYTE pbRawLicense,
    DWORD cbRawLicense );


LICENSE_STATUS
SetExtendedData(
    PHS_Protocol_Context pLicenseContext,
    DWORD dwSupportFlags );


#ifdef UNICODE

LICENSE_STATUS
Ascii2Wchar(
    LPSTR lpszAsciiStr,
    LPWSTR * ppwszWideStr );

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\precomp.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <lmcons.h>

#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <stdlib.h>
#include <mbstring.h>
#include <tchar.h>
#include <time.h>
#include <limits.h>

#include "rng.h"

#include "license.h"
#include "lscsp.h"
#include "certutil.h"

#include "hslice.h"
#include "cryptkey.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "base64.h"
#include "licprotp.h"
#include "verify.h"
#include "hspack.h"
#include "sysapi.h"
#include "icaevent.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\timebomb.cpp ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        timebomb.cpp
//
// Contents:    Implement licensing timebomb-related APIs
//
// History:     08-12-98    FredCh  Created
//
//-----------------------------------------------------------------------------

#include "precomp.h"
#include "tlsapip.h"
#include "time.h"

extern "C" {

//-----------------------------------------------------------------------------
//
// The LSA secret name used to store the licensing timebomb expiration
//
//-----------------------------------------------------------------------------

#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

#define BETA2_LICENSING_TIME_BOMB_5_1 L"BETA2TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

// L$ means only readable from the local machine

#define BETA_LICENSING_TIME_BOMB_5_1 L"L$BETA3TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define RTM_LICENSING_TIME_BOMB_5_1 L"L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define BETA_LICENSING_TIME_BOMB_LATEST_VERSION BETA_LICENSING_TIME_BOMB_5_1

#define RTM_LICENSING_TIME_BOMB_LATEST_VERSION RTM_LICENSING_TIME_BOMB_5_1

//-----------------------------------------------------------------------------
//
// The global licensing time bomb value.
//
//-----------------------------------------------------------------------------

FILETIME g_LicenseTimeBomb;

//-----------------------------------------------------------------------------
//
// The number of licensing grace period is 90 days.  By default, we start
// logging events when there are less than 15 days from expiration and the
// terminal server has not registered itself with a license server.
//
//-----------------------------------------------------------------------------

#define GRACE_PERIOD 120
#define GRACE_PERIOD_EXPIRATION_WARNING_DAYS 15


//-----------------------------------------------------------------------------
//
// Only log the grace period warning or error once a day.  
//
//-----------------------------------------------------------------------------

#define GRACE_PERIOD_EVENT_LOG_INTERVAL     (1000*60*60*24)

//-----------------------------------------------------------------------------
//
// Thread used to warn administrator when grace period is about to expire
//
//-----------------------------------------------------------------------------
HANDLE g_GracePeriodThreadExitEvent = NULL;
CRITICAL_SECTION g_EventCritSec;

//-----------------------------------------------------------------------------
//
// Internal functions
//
//-----------------------------------------------------------------------------

BOOL
CalculateTimeBombExpiration(
    FILETIME *  pExpiration );

DWORD
GetExpirationWarningDays();

BOOL
IsLicensingTimeBombExpired();

/*++

Function:

    InitializeLicensingTimeBomb

Description:

    Initialize the licensing time bomb value.

Argument:

    None.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
InitializeLicensingTimeBomb()
{
    LICENSE_STATUS
        Status;
    DWORD
        cbTimeBomb = sizeof( FILETIME );
    NTSTATUS
        NtStatus;

    NtStatus = RtlInitializeCriticalSection(&g_EventCritSec);

    if (STATUS_SUCCESS != NtStatus)
    {
        return LICENSE_STATUS_INITIALIZATION_FAILED;
    }

    Status = LsCsp_RetrieveSecret( 
                        (TLSIsBetaNTServer()) ? BETA_LICENSING_TIME_BOMB_LATEST_VERSION : RTM_LICENSING_TIME_BOMB_LATEST_VERSION, 
                        ( LPBYTE )&g_LicenseTimeBomb,
                        &cbTimeBomb );

    if( LICENSE_STATUS_OK == Status && cbTimeBomb == sizeof(g_LicenseTimeBomb) )
    {
        return( LICENSE_STATUS_OK );
    }

    //
    // Calculate and set the timebomb
    //

    if( FALSE == CalculateTimeBombExpiration( &g_LicenseTimeBomb ) )
    {
#if DBG
        DbgPrint( "CalculateTimeBombExpiration: cannot calculate licensing time bomb expiration.\n" );
#endif
        return( LICENSE_STATUS_INITIALIZATION_FAILED );
    }

    Status = LsCsp_StoreSecret( 
                        (TLSIsBetaNTServer()) ? BETA_LICENSING_TIME_BOMB_LATEST_VERSION : RTM_LICENSING_TIME_BOMB_LATEST_VERSION, 
                        ( LPBYTE )&g_LicenseTimeBomb,
                        sizeof( g_LicenseTimeBomb ) );

    return( Status );
}


/*++

Function:

    IsLicensingTimeBombExpired

Description:

    Check if the licensing time bomb has expired.

Argument:

    None.

Return:

    TRUE if the timebomb has expired or FALSE otherwise.

--*/

BOOL
IsLicensingTimeBombExpired()
{
    SYSTEMTIME
        SysTimeNow;
    FILETIME
        FileTimeNow,
        FileTimeExpiration;

    GetSystemTime( &SysTimeNow );

    SystemTimeToFileTime( &SysTimeNow, &FileTimeNow );
    
    RtlEnterCriticalSection(&g_EventCritSec);

    FileTimeExpiration.dwLowDateTime = g_LicenseTimeBomb.dwLowDateTime;
    FileTimeExpiration.dwHighDateTime = g_LicenseTimeBomb.dwHighDateTime;

    RtlLeaveCriticalSection(&g_EventCritSec);

    if( 0 > CompareFileTime( &FileTimeExpiration, &FileTimeNow ) )
    {
        return( TRUE );
    }
    
    return( FALSE );
}

/*++

Function:

    CalculateTimeBombExpiration

Description:

    Calculate the licensing time bomb expiration.

Argument:

    pExpiration - The timebomb expiration date and time

Return:

    TRUE if the expiration is calculated successfully or FALSE otherwise.

--*/

BOOL
CalculateTimeBombExpiration(
    FILETIME *  pExpiration )
{
    time_t 
        now = time( NULL );
    struct tm *
        GmTime = gmtime( &now );
    SYSTEMTIME
        SysTime;
    
    if(( NULL == pExpiration ) || ( NULL == GmTime ))
    {
        return( FALSE );
    }

    //
    // Add the days of licensing grace period to get the time bomb
    // expiration.
    //

    GmTime->tm_mday += GRACE_PERIOD;
    
    if( ( ( time_t ) -1 ) == mktime( GmTime ) )
    {
        return( FALSE );
    }

    memset( &SysTime, 0, sizeof( SYSTEMTIME ) ); 

    SysTime.wYear            = (WORD) GmTime->tm_year + 1900;
    SysTime.wMonth           = (WORD) GmTime->tm_mon + 1;
    SysTime.wDay             = (WORD) GmTime->tm_mday;
    SysTime.wDayOfWeek       = (WORD) GmTime->tm_wday;
    SysTime.wHour            = (WORD) GmTime->tm_hour;    
    SysTime.wMinute          = (WORD) GmTime->tm_min;    
    SysTime.wSecond          = (WORD) GmTime->tm_sec;    

    return( SystemTimeToFileTime( &SysTime, pExpiration ) );

}

/*++

Function:

    ReceivedPermanentLicense();

Description:

    Store the fact that we've received a permanent license

Argument:

    None.

--*/

VOID
ReceivedPermanentLicense()
{
    static fReceivedPermanent = FALSE;

    if (!fReceivedPermanent)
    {
        RtlEnterCriticalSection(&g_EventCritSec);

        if (IsLicensingTimeBombExpired())
        {
            // We expired at some time in the past (before the last reboot)

            fReceivedPermanent = TRUE;
        }
        else if (!fReceivedPermanent)
        {
            FILETIME ftNow;
            SYSTEMTIME stNow;

            fReceivedPermanent = TRUE;

            GetSystemTime( &stNow );

            SystemTimeToFileTime( &stNow , &ftNow );

            LsCsp_StoreSecret( 
                              (TLSIsBetaNTServer()) ? BETA_LICENSING_TIME_BOMB_LATEST_VERSION : RTM_LICENSING_TIME_BOMB_LATEST_VERSION, 
                              ( LPBYTE ) &ftNow,
                              sizeof( ftNow ) );

            g_LicenseTimeBomb.dwLowDateTime = ftNow.dwLowDateTime;
            g_LicenseTimeBomb.dwHighDateTime = ftNow.dwHighDateTime;
        }


        RtlLeaveCriticalSection(&g_EventCritSec);
    }
}

/*++

Function:

    CheckLicensingTimeBombExpiration();


Description:

    The following events are logged when the terminal server
    has not registered itself with a license server:

    (1) The grace period for registration has expired
    (2) The grace period for registration is about to expire.  By default, 
    the system starts logging this event 15 days prior to the grace period
    expiration.

Argument:

    None.

Return:

    Nothing.

--*/

VOID
CheckLicensingTimeBombExpiration()
{
    SYSTEMTIME
        SysWarning,
        SysExpiration;
    FILETIME
        FileWarning,
        FileExpiration,
        CurrentTime;
    struct tm 
        tmWarning,
        tmExpiration;
    DWORD
        dwWarningDays;

    //
    // if the licensing timebomb has expired, go ahead and log the event now
    //

    if( IsLicensingTimeBombExpired() )
    {
        LicenseLogEvent( 
                EVENTLOG_ERROR_TYPE,
                EVENT_LICENSING_GRACE_PERIOD_EXPIRED,
                0, 
                NULL );

        return;
    }

    //
    // get the timebomb expiration in system time format
    //

    RtlEnterCriticalSection(&g_EventCritSec);

    FileExpiration.dwLowDateTime = g_LicenseTimeBomb.dwLowDateTime;
    FileExpiration.dwHighDateTime = g_LicenseTimeBomb.dwHighDateTime;

    RtlLeaveCriticalSection(&g_EventCritSec);

    if( !FileTimeToSystemTime( &FileExpiration, &SysExpiration ) )
    {
#if DBG
        DbgPrint( "LICPROT: LogLicensingTimeBombExpirationEvent: FileTimeToSystemTime failed: 0x%x\n", GetLastError() );
#endif
        return;
    }

    //
    // convert the timebomb expiration to tm format
    //

    tmExpiration.tm_year  = SysExpiration.wYear - 1900;
    tmExpiration.tm_mon   = SysExpiration.wMonth - 1;
    tmExpiration.tm_mday  = SysExpiration.wDay;
    tmExpiration.tm_wday  = SysExpiration.wDayOfWeek;
    tmExpiration.tm_hour  = SysExpiration.wHour;
    tmExpiration.tm_min   = SysExpiration.wMinute;
    tmExpiration.tm_sec   = SysExpiration.wSecond; 
    tmExpiration.tm_isdst = -1;

    memcpy( &tmWarning, &tmExpiration, sizeof( tm ) );

    //
    // Get the number of days prior to expiration to start logging event
    //

    dwWarningDays = GetExpirationWarningDays();

    //
    // subtract these number of days from the expiration date
    //

    tmWarning.tm_mday -= dwWarningDays;

    //
    // get the accurate date
    //

    if( ( ( time_t ) -1 ) == mktime( &tmWarning ) )
    {
#if DBG
        DbgPrint( "LICPROT: LogLicensingTimeBombExpirationEvent: mktime failed\n" );
#endif
        return;
    }

    //
    // convert the date to systemtime format
    //

    memset( &SysWarning, 0, sizeof( SYSTEMTIME ) ); 

    SysWarning.wYear            = (WORD) tmWarning.tm_year + 1900;
    SysWarning.wMonth           = (WORD) tmWarning.tm_mon + 1;
    SysWarning.wDay             = (WORD) tmWarning.tm_mday;
    SysWarning.wDayOfWeek       = (WORD) tmWarning.tm_wday;
    SysWarning.wHour            = (WORD) tmWarning.tm_hour;    
    SysWarning.wMinute          = (WORD) tmWarning.tm_min;    
    SysWarning.wSecond          = (WORD) tmWarning.tm_sec;    

    //
    // convert from systemtime to filetime
    //

    if( !SystemTimeToFileTime( &SysWarning, &FileWarning ) )
    {
#if DBG
        DbgPrint( "LICPROT: LogLicensingTimeBombExpirationEvent: SystemTimeToFileTime failed: 0x%x\n", GetLastError() );
#endif
        return;
    }

    //
    // get the current time
    //

    GetSystemTimeAsFileTime( &CurrentTime );

    //
    // Log an event if we are within the warning period
    //

    if( 0 > CompareFileTime( &FileWarning, &CurrentTime ) )
    {
        LPTSTR szDate = TEXT("err");
        LPTSTR
            ptszLogString[1];
        int cchDate;
        BOOL fAllocated = FALSE;

        //
        // get the expiration date in string format.
        //
        cchDate = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                LOCALE_NOUSEROVERRIDE,
                                &SysWarning,
                                NULL,
                                NULL,
                                0);

        if (0 != cchDate)
        {
            szDate = (LPTSTR) LocalAlloc(LMEM_FIXED,cchDate * sizeof(TCHAR));

            if (NULL != szDate)
            {
                fAllocated = TRUE;

                if (0 == GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                       LOCALE_NOUSEROVERRIDE,
                                       &SysWarning,
                                       NULL,
                                       szDate,
                                       cchDate))
                {
                    LocalFree(szDate);
                    fAllocated = FALSE;
                    szDate = TEXT("err");
                }
            }
            else
            {
                szDate = TEXT("err");
            }
        }

        //
        // log the event
        //
        
        ptszLogString[0] = szDate;

        LicenseLogEvent( 
                        EVENTLOG_WARNING_TYPE,
                        EVENT_LICENSING_GRACE_PERIOD_ABOUT_TO_EXPIRE,
                        1, 
                        ptszLogString );

        if (fAllocated)
        {
            LocalFree(szDate);
        }
    }

    return;
}


/*++

Function:

    GetExpirationWarningDays

Descriptions:

    Get the number of days prior to grace period expiration to log warning.

Arguments:

    none.

Returns:

    Nothing.

--*/

DWORD
GetExpirationWarningDays()
{
    HKEY
        hKey = NULL;
    DWORD
        dwDays = GRACE_PERIOD_EXPIRATION_WARNING_DAYS,
        dwValueType,
        dwDisp,
        cbValue = sizeof( DWORD );
    LONG
        lReturn;

    lReturn = RegCreateKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        HYDRA_SERVER_PARAM,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        &dwDisp );

    if( ERROR_SUCCESS == lReturn )
    {
        //
        // query the number of days prior to expiration to log warnings
        //

        lReturn = RegQueryValueEx( 
                            hKey,
                            HS_PARAM_GRACE_PERIOD_EXPIRATION_WARNING_DAYS,
                            NULL,
                            &dwValueType,
                            ( LPBYTE )&dwDays,
                            &cbValue );

        if( ERROR_SUCCESS == lReturn )
        {
            //
            // check if the warning days value is within bound
            //

            if( dwDays > GRACE_PERIOD )
            {
                dwDays = GRACE_PERIOD_EXPIRATION_WARNING_DAYS;
            }
        }
        else
        {
            //
            // can't query the value, set the default
            //

            dwDays = GRACE_PERIOD_EXPIRATION_WARNING_DAYS;

            lReturn = RegSetValueEx( 
                            hKey,
                            HS_PARAM_GRACE_PERIOD_EXPIRATION_WARNING_DAYS,
                            0,
                            REG_DWORD,
                            ( PBYTE )&dwDays,
                            sizeof( DWORD ) );
        }
    }

    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( dwDays );
}

/****************************************************************************
 *
 * _AllowLicensingGracePeriodConnection
 *
 *   Check if the licensing grace period has expired.
 *
 * ENTRY:
 *   Nothing.
 *
 * EXIT:
 *   TRUE           - Allow connection
 *   FALSE          - Disallow connection
 *
 ****************************************************************************/

BOOL
AllowLicensingGracePeriodConnection()
{
    return !IsLicensingTimeBombExpired();
}

DWORD WINAPI
GracePeriodCheckingThread(
                          LPVOID lpParam)
{
    HANDLE hExit = (HANDLE) lpParam;
    DWORD dwWaitStatus;
    DWORD dwWaitInterval = GRACE_PERIOD_EVENT_LOG_INTERVAL;

    // Yield our first time slice

    Sleep(0);

    while (1)
    {
        CheckLicensingTimeBombExpiration();

        dwWaitStatus = WaitForSingleObject(hExit, dwWaitInterval);

        if (WAIT_OBJECT_0 == dwWaitStatus)
        {
            // hExit was signalled
            CloseHandle(hExit);

            goto done;
        }
    }

done:

    return 1;
}

DWORD
StartCheckingGracePeriod()
{
    HANDLE hThread = NULL;
    DWORD Status = ERROR_SUCCESS;

    if (NULL != g_GracePeriodThreadExitEvent)
    {
        // already started
        return ERROR_SUCCESS;
    }

    RtlEnterCriticalSection(&g_EventCritSec);

    // Check one more time

    if (NULL != g_GracePeriodThreadExitEvent)
    {
        // already started
        goto done;
    }

    //
    // Create the event to signal thread exit
    //
        
    g_GracePeriodThreadExitEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    
    if( NULL == g_GracePeriodThreadExitEvent )
    {
        Status = GetLastError();
        goto done;
    }

    //
    // Create the caching thread
    //
        
    hThread = CreateThread(
                           NULL,
                           0,
                           GracePeriodCheckingThread,
                           ( LPVOID )g_GracePeriodThreadExitEvent,
                           0,
                           NULL );

    if (hThread == NULL)
    {
        CloseHandle(g_GracePeriodThreadExitEvent);

        g_GracePeriodThreadExitEvent = NULL;

        Status = GetLastError();

        goto done;
    }

    CloseHandle(hThread);

done:
    RtlLeaveCriticalSection(&g_EventCritSec);

    return ERROR_SUCCESS;
}

DWORD
StopCheckingGracePeriod()
{
    //
    // Signal the thread to exit
    //

    if (NULL == g_GracePeriodThreadExitEvent)
    {
        // already stopped
        return ERROR_SUCCESS;
    }

    RtlEnterCriticalSection(&g_EventCritSec);

    // Check one more time
    if (NULL == g_GracePeriodThreadExitEvent)
    {
        // already stopped
        goto done;
    }

    SetEvent( g_GracePeriodThreadExitEvent );

    g_GracePeriodThreadExitEvent = NULL;

done:
    RtlLeaveCriticalSection(&g_EventCritSec);

    return ERROR_SUCCESS;
}

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\verify.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        verify.c
//
// Contents:    License Verification API
//
// History:     01-21-98    FredCh  Created
//
//-----------------------------------------------------------------------------
#include "precomp.h"
#include "tlsapip.h"

extern DWORD g_dwLicenseExpirationLeeway;

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
GetVerifyResult(
    DWORD   dwLicenseState )
{
    switch( dwLicenseState )
    {

    //
    // Temporary licenses verification results
    //
    case ( LICENSE_STATE_INVALID_PRODUCT ) :

        // FALL THRU - TS5 RC1 license server bug.

    case( VERIFY_RESULT_TEMP_0_0 ):

        return( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE );

    case( VERIFY_RESULT_TEMP_EXPIRED_0 ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_TEMP_0_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_TEMP_EXPIRED_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    //
    // permanent license verification results
    //

    case( VERIFY_RESULT_0_EXPIRED_0 ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_EXPIRED_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_LEEWAY_0 ):

        return( LICENSE_STATUS_SHOULD_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_LEEWAY_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_0_OLD ):

        return( LICENSE_STATUS_MUST_UPGRADE_LICENSE );

    case( VERIFY_RESULT_0_0_0 ):

        return( LICENSE_STATUS_OK );

    default:

        //
        // this case should never happen. For now, if it happens, just
        // let the client go through
        //

        // ASSERT( VERIFY_RESULT_0_EXPIRED_0 );

#if DBG
        DbgPrint( "GetVerifyResult: Invalid verification result: 0x%x\n", dwLicenseState );
#endif

        return( LICENSE_STATUS_INVALID_LICENSE );
        // return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyClientHwid( 
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo )
{
    HWID Hwid;
    LICENSE_STATUS Status;

    //
    // do a memory compare of the HWID
    //

    if( 0 != memcmp( &pLicenseInfo->Hwid, pValidationInfo->pValidationData, 
                     sizeof( HWID ) ) )
    {
        return( LICENSE_STATUS_CANNOT_VERIFY_HWID );
    }                                

    return ( LICENSE_STATUS_OK );

#if 0

#define LICENSE_MIN_MATCH_COUNT 3


    HWID* pHwid;
    DWORD dwMatchCount;

    //
    // liceapi.c, line 1023 set this to HWID
    //
    pHwid = (HWID *)pValidationInfo->pValidationData;

    dwMatchCount = 0;

    dwMatchCount += (pHwid->dwPlatformID == pLicenseInfo->Hwid.dwPlatformID);
    dwMatchCount += (pHwid->Data1 == pLicenseInfo->Hwid.Data1);
    dwMatchCount += (pHwid->Data2 == pLicenseInfo->Hwid.Data2);
    dwMatchCount += (pHwid->Data3 == pLicenseInfo->Hwid.Data3);
    dwMatchCount += (pHwid->Data4 == pLicenseInfo->Hwid.Data4);
 
    return (dwMatchCount >= LICENSE_MIN_MATCH_COUNT) ?
                    LICENSE_STATUS_OK : LICENSE_STATUS_CANNOT_VERIFY_HWID;
#endif
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyLicenseProductInfo( 
    PHS_Protocol_Context        pLmContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState )
{
    DWORD
        cbCompanyName = ( wcslen( PRODUCT_INFO_COMPANY_NAME ) + 1 ) * sizeof( TCHAR ),
        cbProductId = ( wcslen( PRODUCT_INFO_SKU_PRODUCT_ID ) + 1 ) * sizeof( TCHAR ); 

    //
    // Verify the company name
    //

    if( pLicenseInfo->LicensedProduct.pProductInfo->cbCompanyName < cbCompanyName )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid company name in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    if ( 0 != memcmp( pLicenseInfo->LicensedProduct.pProductInfo->pbCompanyName,
                      PRODUCT_INFO_COMPANY_NAME, cbCompanyName ) )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid company name in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    //
    // verify the product ID
    //

    if( pLicenseInfo->cbOrgProductID < cbProductId )
    {
        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    if( 0 != memcmp( pLicenseInfo->pbOrgProductID, 
                     PRODUCT_INFO_SKU_PRODUCT_ID, cbProductId ) )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid product ID in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    //
    // Check actual licensed product.
    //
    
    if( pLicenseInfo->LicensedProduct.pProductInfo->cbProductID == 0 )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid Product ID in client license\n" );
#endif

        // return( LICENSE_STATUS_INVALID_LICENSE );
        return( LICENSE_STATUS_CANNOT_DECODE_LICENSE );
    }

    if( 0 != memcmp(pLicenseInfo->LicensedProduct.pProductInfo->pbProductID,
                    PRODUCT_INFO_SKU_PRODUCT_ID, wcslen(PRODUCT_INFO_SKU_PRODUCT_ID) * sizeof(WCHAR)) )
    {
#if DBG
        DbgPrint( "LICPROT: Invalid product ID in client license\n" );
#endif

        if( 0 == memcmp(pLicenseInfo->LicensedProduct.pProductInfo->pbProductID,
                    PRODUCT_INFO_INTERNET_SKU_PRODUCT_ID, wcslen(PRODUCT_INFO_INTERNET_SKU_PRODUCT_ID) * sizeof(WCHAR)) )
        {
            // TS5 beta3 RC1 license server bug, force a upgrade license.
            LicenseSetState( *pdwLicenseState, LICENSE_STATE_INVALID_PRODUCT );
            return( LICENSE_STATUS_OK );
        }

        //
        // Backward compatibility - treat the new product ID as product family and 
        // let client connect
        //
    }


    //
    // check if this is a temporary license
    //
    if( pLicenseInfo->pLicensedVersion->dwFlags & 0x80000000 )
    {
        LicenseSetState( *pdwLicenseState, LICENSE_STATE_TEMPORARY );
    }
    else if(TLSIsBetaNTServer() == FALSE)
    {
        // verify license is issued by RTM license server
        if(IS_LICENSE_ISSUER_RTM(pLicenseInfo->pLicensedVersion->dwFlags) == FALSE)
        {
            //LicenseSetState( *pdwLicenseState, VERIFY_RESULT_BETA_LICENSE );
            return( LICENSE_STATUS_INVALID_LICENSE );
        }
    }

    if(TLSIsLicenseEnforceEnable() == TRUE)
    {
        //
        // W2K beta 3 to RC1 upgrade.
        // Enforce TermSrv will reject any license issued by Beta 3 non-enforce license
        // server.
        //
        if( GET_LICENSE_ISSUER_MAJORVERSION(pLicenseInfo->pLicensedVersion->dwFlags) <= 5 &&
            GET_LICENSE_ISSUER_MINORVERSION(pLicenseInfo->pLicensedVersion->dwFlags) <= 2 )
        {
            //
            // Build 20XX license server has version of 05 03, since we still need to maintain
            // inter-op, we don't want to keep rejecting client holding non-enforce
            // license server, so we check if license issuer is 5.2 or older.
            //
            if( IS_LICENSE_ISSUER_ENFORCE(pLicenseInfo->pLicensedVersion->dwFlags) == FALSE )
            {
        #if DBG
                DbgPrint( "LICPROT: Rejecting license from non-enforce license server\n" );
        #endif

                return( LICENSE_STATUS_INVALID_LICENSE );
            }
        }
    }

    return( LICENSE_STATUS_OK );
}


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyLicenseDateAndTime( 
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState )
{
    SYSTEMTIME  CurrentSysTime;
    FILETIME    CurrentFileTime; 
    LONG        lReturn;
    ULARGE_INTEGER ullNotAfterLeeway;
    ULARGE_INTEGER ullCurrentTime;

    //
    // get the current system time
    //

    GetSystemTime( &CurrentSysTime );

    //
    // convert it to file time
    //

    SystemTimeToFileTime( &CurrentSysTime, &CurrentFileTime );

    //
    // Verify that the license is still valid at this time
    //

    lReturn = CompareFileTime( &pLicenseInfo->NotAfter, &CurrentFileTime );

    if( 1 != lReturn )
    {
        LicenseSetState( *pdwLicenseState, LICENSE_STATE_EXPIRED );            
    }
    else if (!(pLicenseInfo->pLicensedVersion->dwFlags & 0x80000000))
    {
        // permanent license

        ullNotAfterLeeway.LowPart = pLicenseInfo->NotAfter.dwLowDateTime;
        ullNotAfterLeeway.HighPart = pLicenseInfo->NotAfter.dwHighDateTime;
        
        ullNotAfterLeeway.QuadPart -= Int32x32To64(g_dwLicenseExpirationLeeway,10*1000*1000);

        ullCurrentTime.LowPart = CurrentFileTime.dwLowDateTime;
        ullCurrentTime.HighPart = CurrentFileTime.dwHighDateTime;

        if (ullNotAfterLeeway.QuadPart < ullCurrentTime.QuadPart)
        {
            LicenseSetState( *pdwLicenseState, LICENSE_STATE_LEEWAY );
        }
    }

    return( LICENSE_STATUS_OK );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\prottest\prottest.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        prottest.c
//
// Contents:    Test program for hydra licensing protocol
//
// History:     01-07-98    FredCh  Created
//
//-----------------------------------------------------------------------------

#include <windows.h>

#include <stdio.h>
#include <time.h>
#include <limits.h>
#include <stdlib.h>

#include "license.h"
#include "hslice.h"
#include "cryptkey.h"
#include "hccontxt.h"
#include "licecert.h"
#include "lscsp.h"
#include "sysapi.h"

#include "prottest.h"

#define MSG_SIZE        2048

BOOL
LsCsp_UnpackServerCert(
    LPBYTE pbCert,
    DWORD dwCertLen,
    PHydra_Server_Cert pServerCert );

///////////////////////////////////////////////////////////////////////////////
HANDLE g_hServerEvent = NULL, g_hClientEvent = NULL;
BYTE * pbServerMessage = NULL;
PBYTE  ClientMessage;//[MSG_SIZE];
DWORD  cbServerMessage = 0;
DWORD  cbClientMessage;
LPBYTE g_pbPubKey = NULL;
DWORD  g_cbPubKey = 0;
Hydra_Server_Cert g_ServerCertificate;

const BYTE g_abServerCertificate[184] = {
    0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x5C, 0x00,
    0x52, 0x53, 0x41, 0x31, 0x48, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x83, 0x76, 0x5B, 0x09,
    0x8F, 0xC1, 0x74, 0x12, 0x1B, 0xD3, 0x4E, 0x72,
    0x72, 0x4D, 0xBE, 0xCE, 0x55, 0x1D, 0x29, 0x3D,
    0x0E, 0xED, 0x28, 0x09, 0x50, 0x66, 0x32, 0xFA,
    0x1D, 0xD2, 0xCC, 0x42, 0xDE, 0x5B, 0x4E, 0x3C,
    0x35, 0xF6, 0x73, 0x5B, 0x0C, 0x0D, 0xB0, 0xA6,
    0x4D, 0x76, 0xBA, 0xC0, 0x88, 0x5F, 0xC4, 0x67,
    0x0B, 0xB8, 0xA3, 0x23, 0xA6, 0xC7, 0x79, 0xBD,
    0x80, 0xD1, 0xA8, 0x75, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x48, 0x00,
    0x19, 0x50, 0x2E, 0x2E, 0x82, 0xB4, 0xEB, 0xB3,
    0x87, 0x85, 0xB9, 0x31, 0x4C, 0x29, 0x07, 0x05,
    0xD7, 0x37, 0x99, 0x86, 0x15, 0x30, 0x56, 0xE4,
    0x47, 0x7A, 0x2C, 0x2F, 0x4C, 0xBD, 0xF0, 0x37,
    0xD3, 0x94, 0x01, 0xC8, 0x73, 0xEA, 0x5C, 0x2C,
    0x3F, 0x60, 0x27, 0x1E, 0x5D, 0xA9, 0x54, 0x32,
    0xDC, 0x49, 0xA4, 0x7E, 0x26, 0xAF, 0xEA, 0x07,
    0xCA, 0x4E, 0xE9, 0x95, 0x8E, 0x66, 0xF0, 0x33,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

///////////////////////////////////////////////////////////////////////////////
void
_stdcall
HydraServerThread();

void
_stdcall
HydraClientThread();


BOOL
TsIssueLicenseExpirationWarning(
    LPDWORD lpdwDays,
    PTS_LICENSE_INFO pTsLicenseInfo );

BOOL
FileTimeToUnixTime(
    LPFILETIME  pft,
    time_t *    t );

VOID
DisplayLicenseMessage(
    DWORD   dwDaysLeft );

///////////////////////////////////////////////////////////////////////////////
void _cdecl main(int argc, char *argv[])
{    
    DWORD ServerThreadID, ClientThreadID;
    HANDLE ThreadHandles[2];
    DWORD WaitStatus  = 0;
    Binary_Blob CertBlob;
    LICENSE_STATUS Status;
    DWORD dwFlag = CERT_DATE_DONT_VALIDATE;
    //
    // Create the server and client events
    //

    ThreadHandles[0] = NULL;
    ThreadHandles[1] = NULL;

    g_hServerEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    g_hClientEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if( ( NULL == g_hServerEvent ) || ( NULL == g_hClientEvent ) )
    {
        printf( "Cannot create events\n" );
        return;
    }

    InitializeLicenseLib( TRUE );

    memset( &CertBlob, 0, sizeof( CertBlob ) );

    //
    // get the X509 certificate
    //

    Status = GetServerCertificate( CERT_TYPE_X509, &CertBlob, KEY_EXCHANGE_ALG_RSA );

    if( LICENSE_STATUS_OK == Status )
    {
        Status = VerifyCertChain( 
                        CertBlob.pBlob, 
                        CertBlob.wBlobLen, 
                        NULL, 
                        &g_cbPubKey,
                        &dwFlag );

        if( LICENSE_STATUS_INSUFFICIENT_BUFFER == Status )
        {
            g_pbPubKey = LocalAlloc( LPTR, g_cbPubKey );

            if( NULL == g_pbPubKey )
            {
                goto done;
            }

            Status = VerifyCertChain( CertBlob.pBlob, 
                                      CertBlob.wBlobLen,
                                      g_pbPubKey, 
                                      &g_cbPubKey,
                                      &dwFlag );
        }            

        if( LICENSE_STATUS_OK != Status )
        {
            printf( "Cannot verify X509 certificate chain: %x\n", Status );
            goto done;
        }
    }

    //
    // unpack the hardcoded certificate
    //

    if( !LsCsp_UnpackServerCert( ( LPBYTE )g_abServerCertificate, sizeof( g_abServerCertificate ),
                &g_ServerCertificate ) )
    {
        printf( "cannot unpack server certificate\n" );
    }
        
            
    //
    // Create the server and client threads
    //

    ThreadHandles[0] = CreateThread( NULL, 
                                     0, 
                                     ( LPTHREAD_START_ROUTINE )HydraServerThread, 
                                     NULL, 
                                     0, 
                                     &ServerThreadID );

    ThreadHandles[1] = CreateThread( NULL, 
                                     0, 
                                     ( LPTHREAD_START_ROUTINE )HydraClientThread, 
                                     NULL, 
                                     0, 
                                     &ClientThreadID );

    //
    // wait for the server and client thread to die
    //

    WaitStatus = WaitForMultipleObjects( 2, ThreadHandles, TRUE, INFINITE );

    //
    // close the event handles
    //
done:

    if( g_hServerEvent )
    {
        CloseHandle( g_hServerEvent );
    }

    if( g_hClientEvent )
    {
        CloseHandle( g_hClientEvent );
    }

    if( ThreadHandles[0] )
    {
        CloseHandle( ThreadHandles[0] );
    }

    if( ThreadHandles[1] )
    {
        CloseHandle( ThreadHandles[1] );
    }

    ShutdownLicenseLib();

    if( pbServerMessage )
    {
        LocalFree( pbServerMessage );
    }

    if( CertBlob.pBlob )
    {
        LocalFree( CertBlob.pBlob );
    }

    if( g_pbPubKey )
    {
        LocalFree( g_pbPubKey );
    }

    return;
}

#define HYDRA_40_LICENSING_PROTOCOL_FLAG        0
#define HYDRA_40_LICENSING_PROTOCOL_VERSION     LICENSE_PROTOCOL_VERSION_1_0 | PREAMBLE_VERSION_2_0


///////////////////////////////////////////////////////////////////////////////
void
_stdcall
HydraServerThread()
{
    LICENSE_STATUS Status;
    HANDLE hContext = NULL;
    LICENSE_CAPABILITIES LicenseCap;
    TS_LICENSE_INFO
        TsLicenseInfo;

    Status = CreateLicenseContext( &hContext, LICENSE_CONTEXT_PER_SEAT );

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "HydraServerThread(): error creating license context\n" );
        return;
    }

    memset( &LicenseCap, 0, sizeof( LicenseCap ) );

    LicenseCap.KeyExchangeAlg = KEY_EXCHANGE_ALG_RSA;

#ifdef HYDRA_40_TEST

    //
    // talking to a Hydra 4.0 client
    //

    LicenseCap.ProtocolVer = HYDRA_40_LICENSING_PROTOCOL_VERSION;
    LicenseCap.fAuthenticateServer = TRUE;

    Status = InitializeLicenseContext( 
                        hContext,
                        0,
                        &LicenseCap );

#else

#ifdef HYDRA_50_NO_SERVER_AUTHEN_X509 

    //
    // talking to a Hydra 5.0 client and don't send certificate
    //

    LicenseCap.ProtocolVer = LICENSE_HIGHEST_PROTOCOL_VERSION;
    LicenseCap.fAuthenticateServer = FALSE;
    LicenseCap.CertType = CERT_TYPE_X509;

    Status = InitializeLicenseContext( 
                        hContext,
                        0,
                        &LicenseCap );

#else

#ifdef HYDRA_50_NO_SERVER_AUTHEN_PROPRIETORY

    //
    // talking to a Hydra 5.0 client and don't send certificate
    //

    LicenseCap.ProtocolVer = LICENSE_HIGHEST_PROTOCOL_VERSION;
    LicenseCap.fAuthenticateServer = FALSE;
    LicenseCap.CertType = CERT_TYPE_PROPRIETORY;

    Status = InitializeLicenseContext( 
                        hContext,
                        0,
                        &LicenseCap );
#else
    
    //
    // talking to a Hydra 5.0 client and also send certificate
    //
    
    LicenseCap.ProtocolVer = LICENSE_HIGHEST_PROTOCOL_VERSION;
    LicenseCap.fAuthenticateServer = TRUE;
    
    Status = InitializeLicenseContext( 
                        hContext,
                        0,
                        &LicenseCap );

#endif // HYDRA_50_NO_SERVER_AUTHEN_X509

#endif // HYDRA_50_NO_SERVER_AUTHEN_PROPRIETORY

#endif // HYDRA_40_TEST


    if( LICENSE_STATUS_OK != Status )
    {
        printf( "HydraServerThread(): cannot initialize license context: %x\n", Status );
        goto done;
    }

    Status = AcceptLicenseContext( hContext,
                                   0,
                                   NULL,
                                   &cbServerMessage,
                                   &pbServerMessage );
    

    while( LICENSE_STATUS_CONTINUE == Status )
    {
        SetEvent( g_hClientEvent );

        WaitForSingleObject( g_hServerEvent, INFINITE );

        if( pbServerMessage )
        {
            LocalFree( pbServerMessage );
            pbServerMessage = NULL;
            cbServerMessage = 0;
        }

        Status = AcceptLicenseContext( hContext,
                                       cbClientMessage,
                                       ClientMessage,
                                       &cbServerMessage,
                                       &pbServerMessage );
    
    }

done:

    if( hContext )
    {
        DWORD
            dwDaysLeft = 0;

        memset( &TsLicenseInfo, 0, sizeof( TsLicenseInfo ) );

        Status = QueryLicenseInfo( hContext, &TsLicenseInfo );

        if( LICENSE_STATUS_OK != Status )
        {
            printf( "HydraSeverThread: cannot query license info: %x\n", Status );
        }

        if( TsIssueLicenseExpirationWarning( &dwDaysLeft, &TsLicenseInfo ) )
        {
            DisplayLicenseMessage( dwDaysLeft );            
        }
    
        FreeLicenseInfo( &TsLicenseInfo );

        DeleteLicenseContext( hContext );
    }

    if( ( LICENSE_STATUS_ISSUED_LICENSE == Status ) || 
        ( LICENSE_STATUS_OK == Status ) )
    {
        //
        // issueing a license or the license has been successfully validated
        //
        
        printf( "HydraServerThread: Protocol completed successfully\n" );
        SetEvent( g_hClientEvent );
     
    }
    else if( LICENSE_STATUS_SEND_ERROR == Status )
    {
        printf( "HydraServerThread: sending error to client\n" );
        SetEvent( g_hClientEvent );

    }
    else
    {
        printf( "HydraServerThread: protocol error: aborted\n" );
    }
        
    return;
}

///////////////////////////////////////////////////////////////////////////////
void
_stdcall
HydraClientThread()
{
    LICENSE_STATUS Status;
    HANDLE hContext;


#ifdef HYDRA_50_NO_SERVER_AUTHEN_X509

    //
    // no server authentication required.  Use the public key in the 
    // X509 certificate
    //

    Status = LicenseInitializeContext( 
                        &hContext,           
                        LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION );

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "Cannot initialize client context: %x\n", Status );
        return;
    }

    //
    // set the public key
    //

    Status = LicenseSetPublicKey(
                        hContext,
                        g_cbPubKey,
                        g_pbPubKey );

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "Cannot set public key: %x\n", Status );
        goto done;
    }

#else

#ifdef HYDRA_50_NO_SERVER_AUTHEN_PROPRIETORY

    //
    // no server authentication required.  Use the proprietory certificate
    //

    Status = LicenseInitializeContext( 
                        &hContext,           
                        LICENSE_CONTEXT_NO_SERVER_AUTHENTICATION );

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "Cannot initialize client context: %x\n", Status );
        return;
    }

    //
    // set the proprietory certificate
    //

    Status = LicenseSetCertificate( 
                        hContext,
                        &g_ServerCertificate );

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "cannot set certificate: %x\n", Status );
        goto done;
    }

#else

    //
    // hydra 4.0/5.0 licensing protocol.with certificate validation
    //

    Status = LicenseInitializeContext( 
                        &hContext,           
                        0 );

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "Cannot initialize client context: %x\n", Status );
        return;
    }
    
#endif

#endif
    
    if( NULL == hContext )
    {
        printf( "HydraClientThread(): error creating license context\n" );
        return;
    }

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "HydraClientThread(): error setting certificate: %x\n", Status );
        LicenseDeleteContext( hContext );
        return;
    }


    WaitForSingleObject( g_hClientEvent, INFINITE );

    cbClientMessage = 0;//MSG_SIZE;

    if( LICENSE_STATUS_CONTINUE != (Status = LicenseAcceptContext( hContext,
                                   0,
                                   pbServerMessage,
                                   cbServerMessage,
                                   NULL,//ClientMessage,
                                   &cbClientMessage )) )
	{
		printf("Error handling Server request\n");
		return;
	}

	if( NULL == (ClientMessage = (PBYTE)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, cbClientMessage)) )
	{
		printf("Error allocating memory\n");
		return;
	}
	
	//memset(ClientMessage, 0x00, cbClientMessage);

	Status = LicenseAcceptContext(hContext,
                                  0,
                                  pbServerMessage,
                                  cbServerMessage,
                                  ClientMessage,
                                  &cbClientMessage);
    
    while( LICENSE_STATUS_CONTINUE == Status )
    {
        SetEvent( g_hServerEvent );

        WaitForSingleObject( g_hClientEvent, INFINITE );

        cbClientMessage = 0;
		
		if(ClientMessage)
        {
			GlobalFree((HGLOBAL)ClientMessage);
            ClientMessage = NULL;
        }

		Status = LicenseAcceptContext( hContext,
									   0,
									   pbServerMessage,
									   cbServerMessage,
									   NULL,//ClientMessage,
									   &cbClientMessage);

		if( ( Status == LICENSE_STATUS_OK ) || ( Status != LICENSE_STATUS_CONTINUE ) )
		{
			break;
		}
		
        if( NULL == (ClientMessage = (PBYTE)GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, cbClientMessage)) )
		{
			printf("Error allocating memory\n");
			break;
		}
			
		memset(ClientMessage, 0x00, cbClientMessage);

        Status = LicenseAcceptContext( hContext,
                                       0,
                                       pbServerMessage,
                                       cbServerMessage,
                                       ClientMessage,
                                       &cbClientMessage );
                                       

    }

done:

    LicenseDeleteContext( hContext );

    if( LICENSE_STATUS_OK == Status )
    {
        printf( "HydraClientThread: license protocol completed successfully\n" );
    }
    else
    {
        printf( "HydraClientThread: license protocol failed: 0x%x\n", Status );
    }
	
    if( ClientMessage )
    {
	    GlobalFree( ( HGLOBAL )ClientMessage );
    }

    return;
}



#define SECONDS_IN_A_DAY                86400   // number of seconds in a day
#define ISSUE_LICENSE_WARNING_PERIOD    150     // days to expiration when warning should be issued.

///////////////////////////////////////////////////////////////////////////////
BOOL
TsIssueLicenseExpirationWarning(
    LPDWORD lpdwDays,
    PTS_LICENSE_INFO pTsLicenseInfo )
{
    time_t
        Expiration,
        CurrentTime;
    DWORD
        dwDaysLeft;

    if( NULL == pTsLicenseInfo )
    {
        return( FALSE );
    }

    if( FALSE == pTsLicenseInfo->fTempLicense )
    {
        return( FALSE );
    }

    //
    // The client license is temporary, figure out how long more
    // the license is valid
    //

    if( FALSE == FileTimeToUnixTime( &pTsLicenseInfo->NotAfter, &Expiration ) )
    {
        return( FALSE );
    }

    time( &CurrentTime );

    if( CurrentTime >= Expiration )
    {
        //
        // license already expired
        //

        *lpdwDays = 0xFFFFFFFF;
        return( TRUE );
    }

    dwDaysLeft = ( Expiration - CurrentTime ) / SECONDS_IN_A_DAY;

    printf( "Number of days left for temporary license expiration: %d\n", dwDaysLeft );

    if( ISSUE_LICENSE_WARNING_PERIOD >= dwDaysLeft )
    {
        *lpdwDays = dwDaysLeft;
        return( TRUE );
    }

    return( FALSE );
}


///////////////////////////////////////////////////////////////////////////////
BOOL
FileTimeToUnixTime(
    LPFILETIME  pft,
    time_t *    t )
{
    SYSTEMTIME sysTime;
    struct tm gmTime;

    if( FileTimeToSystemTime( pft, &sysTime ) == FALSE )
    {
        return( FALSE );
    }

    if( sysTime.wYear >= 2038 )
    {
        *t = INT_MAX;
    }
    else
    {
        //
        // Unix time support up to 2038/1/18
        // restrict any expiration data 
        //

        memset( &gmTime, 0, sizeof( gmTime ) );
        gmTime.tm_sec = sysTime.wSecond;
        gmTime.tm_min = sysTime.wMinute;
        gmTime.tm_hour = sysTime.wHour;
        gmTime.tm_year = sysTime.wYear - 1900;
        gmTime.tm_mon = sysTime.wMonth - 1;
        gmTime.tm_mday = sysTime.wDay;

        *t = mktime( &gmTime );
    }

    return( *t != ( time_t )-1 );
}
    
///////////////////////////////////////////////////////////////////////////////
VOID
DisplayLicenseMessage(
    DWORD   dwDaysLeft )
{
    TCHAR
        szMsgCaption[512],
        szMsgTitle[256];
    HMODULE
        hModule = GetModuleHandle( NULL );
    LPDWORD
        lpdw;
    TCHAR
        tszDays[ 10 ];
    
    if( 0xFFFFFFFF == dwDaysLeft )
    {
        printf( "Temporary License has expired!\n" );

        LoadString( hModule, STR_TEMP_LICENSE_EXPIRED_MSG, szMsgCaption, 512 );
    }
    else
    {
        printf( "%d days left before temporary license expires\n", dwDaysLeft );

        //
        // convert the number of days left to UNICODE character
        //

        _ultow( dwDaysLeft, tszDays, 10 );        
        lpdw = ( LPDWORD )&tszDays[0];

        //
        // prepare license about to expire message
        //
        
        LoadString( hModule, STR_TEMP_LICENSE_EXPIRATION_MSG, szMsgCaption, 512 );

        FormatMessage( 
                FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szMsgCaption,
                0,
                MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                ( LPTSTR )szMsgCaption,
                sizeof( szMsgCaption ),
                ( va_list * )&lpdw );

    }

    //
    // prepare message title
    //

    LoadString( hModule, STR_TEMP_LICENSE_MSG_TITLE, szMsgTitle, 256 );

    MessageBox( NULL, szMsgCaption, szMsgTitle, MB_OK );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\prottest\prottest.h ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------

#ifndef _PROTTEST_H_
#define _PROTTEST_H_

#define STR_TEMP_LICENSE_EXPIRED_MSG        100
#define STR_TEMP_LICENSE_EXPIRATION_MSG     101
#define STR_TEMP_LICENSE_MSG_TITLE          102

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\licprot\verify.h ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        verify.h
//
// Contents:    Header file for license Verification API
//
// History:     01-21-98    FredCh  Created
//
//-----------------------------------------------------------------------------

#ifndef _VERIFY_H_
#define _VERIFY_H_

///////////////////////////////////////////////////////////////////////////////
// 
// These is the license upgrade logic
//
//  Action            |   Temp License |     Expired     |   Version < HS
//                    |                |                 |   
//  ---------------------------------------------------------------------------
//  Should Upgrade    |        1       |         0       |       0
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        1       |         1       |       0
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        1       |         0       |       1
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        1       |         1       |       1
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        0       |         1       |       1
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        0       |         1       |       0
//  ---------------------------------------------------------------------------
//  Must Upgrade      |        0       |         0       |       1
//  ---------------------------------------------------------------------------
//  Should Upgrade    |        0       | 0 (past leeway) |       0
//  ---------------------------------------------------------------------------
//  OK                |        0       |         0       |       0
//  ---------------------------------------------------------------------------
//

///////////////////////////////////////////////////////////////////////////////
#define LICENSE_STATE_TEMPORARY         0x00000001
#define LICENSE_STATE_EXPIRED           0x00000002
#define LICENSE_STATE_OLD_VERSION       0x00000004
#define LICENSE_STATE_INVALID_PRODUCT   0x00000008  // TS5 RC1 license server
                                                    //  bug - must upgrade
#define LICENSE_STATE_LEEWAY            0x00000010

#define VERIFY_RESULT_TEMP_0_0          LICENSE_STATE_TEMPORARY
#define VERIFY_RESULT_TEMP_EXPIRED_0    LICENSE_STATE_TEMPORARY | LICENSE_STATE_EXPIRED
#define VERIFY_RESULT_TEMP_0_OLD        LICENSE_STATE_TEMPORARY | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_TEMP_EXPIRED_OLD  LICENSE_STATE_TEMPORARY | LICENSE_STATE_EXPIRED | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_EXPIRED_0       LICENSE_STATE_EXPIRED
#define VERIFY_RESULT_0_EXPIRED_OLD     LICENSE_STATE_EXPIRED | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_LEEWAY_0        LICENSE_STATE_LEEWAY
#define VERIFY_RESULT_0_LEEWAY_OLD      LICENSE_STATE_LEEWAY | LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_0_OLD           LICENSE_STATE_OLD_VERSION
#define VERIFY_RESULT_0_0_0             0x00000000
#define VERIFY_RESULT_INVALID_PRODUCT   LICENSE_STATE_INVALID_PRODUCT
#define VERIFY_RESULT_BETA_LICENSE      VERIFY_RESULT_TEMP_EXPIRED_0


#define LicenseInitState( _CurrentState ) \
    _CurrentState = 0

#define LicenseSetState( _CurrentState, _State ) \
    _CurrentState |= _State


///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
VerifyHwid(
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
VerifyLicenseSignature(
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,    
    PLicense_Verification_Data  pDecodedData );


LICENSE_STATUS
VerifyProductInfo(
    PHS_Protocol_Context        pLmContext,
    PValidation_Info            pValidationInfo,
    PLicense_Verification_Data  pDecodedData,
    PDWORD                      pdwLicenseState );


LICENSE_STATUS
VerifyDateAndTime(
    PLicense_Verification_Data  pDecodedData,
    PDWORD                      pdwLicenseState );


LICENSE_STATUS
GetVerifyResult(
    DWORD   dwLicenseState );


LICENSE_STATUS
VerifyClientHwid( 
    PHS_Protocol_Context        pContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo );


LICENSE_STATUS
VerifyLicenseProductInfo( 
    PHS_Protocol_Context        pLmContext,
    PValidation_Info            pValidationInfo,
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState );


LICENSE_STATUS
VerifyLicenseDateAndTime( 
    PLICENSEDPRODUCT            pLicenseInfo,
    PDWORD                      pdwLicenseState );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\hserver\tests\certreq\certreq.cpp ===
//+--------------------------------------------------------------------------
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// File:        
//
// Contents:    
//
// History:     
//
//---------------------------------------------------------------------------


#include <windows.h>

#include <stdio.h>

#include "license.h"
#include "cryptkey.h"
#include "lscsp.h"
#include "licecert.h"

#define SECRET_DATA     "I love sushi"

BOOL
GetCspData(
    LSCSPINFO   CspInfo,
    LPBYTE *    ppbData,
    LPDWORD     pcbData );

//+----------------------------------------------------------------------------
int _cdecl main( int argc, char *argv[] )
{    
    LICENSE_STATUS
        Status;
    LPBYTE
        pbProprietoryCert = NULL,
        pbX509Cert = NULL,
        pbPrivKey = NULL,
        pbX509PrivKey = NULL,
        pbX509PubKey = NULL,
        pbEnvelopedData = NULL,
        pbData = NULL;
    DWORD
        cbProprietoryCert = 0,
        cbX509Cert = 0,
        cbPrivKey = 0,
        cbX509PrivKey = 0,
        cbX509PubKey = 0,
        cbEnvelopedData = 0,
        cbData = 0;
    BYTE
        abData[512];
    
    //
    // Initialize the CSP library
    //

    Status = LsCsp_Initialize();

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "Error initializing LSCSP: %x\n", Status );
        return 1;
    }

    //
    // Retrieve the proprietory certificate
    //

    if( !GetCspData( LsCspInfo_Certificate, &pbProprietoryCert, &cbProprietoryCert ) )
    {
        printf( "Cannot get proprietory certificate\n" );
    }
    else
    {
        printf( "Got proprietory certificate\n" );
    }

    //
    // Retrieve the X509 certificate
    //

    if( !GetCspData( LsCspInfo_X509Certificate, &pbX509Cert, &cbX509Cert ) )
    {
        printf( "Cannot get X509 certificate\n" );
    }
    else
    {
        printf( "Got X509 certificate\n" );
    }
    
    //
    // retrieve private key for the proprietory certificate
    //

    if( !GetCspData( LsCspInfo_PrivateKey, &pbPrivKey, &cbPrivKey ) )
    {
        printf( "Cannot get private key for the proprietory certificate\n");
    }
    else
    {
        printf( "Got the private key for the proprietory certificate\n" );
    }

    //
    // retrieve the private key for the X509 certificate
    //

    if( !GetCspData( LsCspInfo_X509CertPrivateKey, &pbX509PrivKey, &cbX509PrivKey ) )
    {
        printf( "Cannot get private key for the X509 certificate\n");
    }
    else
    {
        printf( "Got the private key for the X509 certificate\n" );
    }

    //
    // validate the X509 certificate and get the public key from the certificate
    //

    Status = VerifyCertChain( pbX509Cert, cbX509Cert, NULL, &cbX509PubKey );

    if( LICENSE_STATUS_INSUFFICIENT_BUFFER == Status )
    {
        pbX509PubKey = new BYTE[ cbX509PubKey ];

        if( NULL != pbX509PubKey )
        {
            Status = VerifyCertChain( pbX509Cert, cbX509Cert, pbX509PubKey, &cbX509PubKey );
        }
    }
    
    if( LICENSE_STATUS_OK != Status )
    {
        printf( "Cannot verify certificate chain\n" );
        goto done;
    }
    
    //
    // Use the public key to encrypt a blob of data
    //

    Status = LicenseEnvelopeData(
                    pbX509PubKey,
                    cbX509PubKey,
                    ( LPBYTE )SECRET_DATA,
                    strlen( SECRET_DATA ) + 1,
                    NULL,
                    &cbEnvelopedData );

    pbEnvelopedData = new BYTE[ cbEnvelopedData ];

    if( NULL == pbEnvelopedData )
    {
        goto done;
    }

    Status = LicenseEnvelopeData(
                    pbX509PubKey,
                    cbX509PubKey,
                    ( LPBYTE )SECRET_DATA,
                    strlen( SECRET_DATA ) + 1,
                    pbEnvelopedData,
                    &cbEnvelopedData );

    //
    // Decrypt the encrypted data
    //

    cbData = sizeof( abData );

    Status = LsCsp_DecryptEnvelopedData(
                    CERT_TYPE_X509,
                    pbEnvelopedData,
                    cbEnvelopedData,
                    abData,
                    &cbData );


    if( LICENSE_STATUS_OK == Status )
    {
        printf( "Secret data is: %s", pbData );
    }

done:

    if( pbProprietoryCert )
    {
        delete [] pbProprietoryCert;        
    }
        
    if( pbX509Cert )
    {
        delete [] pbX509Cert;        
    }
    
    if( pbPrivKey )
    {
        delete [] pbPrivKey;
    }

    if( pbX509PrivKey )
    {
        delete [] pbX509PrivKey;
    }

    if( pbX509PubKey )
    {
        delete [] pbX509PubKey;
    }

    if( pbEnvelopedData )
    {
        delete [] pbEnvelopedData;
    }

    LsCsp_Exit();
    
    return 1;                       
}


///////////////////////////////////////////////////////////////////////////////
BOOL
GetCspData(
    LSCSPINFO   CspInfo,
    LPBYTE *    ppbData,
    LPDWORD     pcbData )
{
    LICENSE_STATUS
        Status;
    BOOL
        fResult = TRUE;

    *ppbData = NULL;
    *pcbData = 0;

    Status = LsCsp_GetServerData( CspInfo, NULL, pcbData );

    if( LICENSE_STATUS_OK == Status )
    {        
        *ppbData = new BYTE[ *pcbData ];

        if( NULL == *ppbData )
        {
            printf( "Out of memory\n" );
            fResult = FALSE;
            goto done;
        }

        Status = LsCsp_GetServerData( CspInfo, *ppbData, pcbData );        
    }

    if( LICENSE_STATUS_OK != Status )
    {
        printf( "cannot get LSCSP data: %x\n", Status );

        if( *ppbData )
        {
            delete [] *ppbData;
            *pcbData = 0;
        }

        fResult = FALSE;
    }

done:

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\addkp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++

  
Module Name:

    AddKp.cpp

Abstract:
    
    This Module contains the implementation of CAddKeyPack Dialog class
    (Dialog box used for adding keypacks)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "defines.h"
#include "LicMgr.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "AddKP.h"
#include "LicAgrmt.h"
#include "AddLic.h"
#include "lsserver.h"
#include "remlic.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddKeyPack dialog


CAddKeyPack::CAddKeyPack(CWnd* pParent /*=NULL*/)
    : CDialog(CAddKeyPack::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddKeyPack)
    m_KeypackType = _T("");
    m_TotalLicenses = 0;
    m_pKeyPackList = NULL;
    //}}AFX_DATA_INIT
}

CAddKeyPack::CAddKeyPack(KeyPackList *pKeyPackList, BOOL bIsUserAdmin,CWnd* pParent /*=NULL*/)
    : CDialog(CAddKeyPack::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddKeyPack)
    m_KeypackType = _T("");
    m_TotalLicenses = 0;
    m_pKeyPackList = pKeyPackList;
    m_bIsUserAdmin = bIsUserAdmin;
   
     //}}AFX_DATA_INIT
}

void CAddKeyPack::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddKeyPack)
    
    DDX_CBString(pDX, IDC_KEYPACK_TYPE, m_KeypackType);
    DDX_Control(pDX, IDC_KEYPACK_TYPE, m_LicenseCombo);
    DDX_Text(pDX,IDC_TOTAL_LICENSES,m_TotalLicenses);
    
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddKeyPack, CDialog)
    //{{AFX_MSG_MAP(CAddKeyPack)
    ON_BN_CLICKED(IDC_HELP2, OnHelp2)
    ON_CBN_SELCHANGE(IDC_KEYPACK_TYPE, OnSelchangeKeypackType)
    ON_BN_CLICKED(IDC_ADD, OnAddLicenses)
    ON_BN_CLICKED(IDC_REMOVE, OnRemoveLicenses)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddKeyPack message handlers

BOOL CAddKeyPack::OnInitDialog() 
{
    CDialog::OnInitDialog();
       
    // TODO: Add extra initialization here
    
    if(!m_bIsUserAdmin)
    {
        GetDlgItem(IDC_ADD)->EnableWindow(FALSE);
        GetDlgItem(IDC_REMOVE)->EnableWindow(FALSE);
    }

    //CString SKU1;
    //CString SKU2;

    CString SKU236;

    //SKU1.LoadString(IDS_SKU1);
    //SKU2.LoadString(IDS_SKU2);

    SKU236.LoadString(IDS_236_SKU);

    POSITION pos = m_pKeyPackList->GetHeadPosition();
    while(pos)
    {
        CKeyPack *pKeyPack = (CKeyPack *)m_pKeyPackList->GetNext(pos);
        if(NULL == pKeyPack)
            return FALSE;
        LSKeyPack sKeyPack = pKeyPack->GetKeyPackStruct();
        
        //if(((0 == SKU1.CompareNoCase(sKeyPack.szProductId)) ||
        //    (0 == SKU2.CompareNoCase(sKeyPack.szProductId)))&& 

#if 0
        if(_tcsnicmp(sKeyPack.szProductId, SKU236.GetBuffer(0), SKU236.GetLength()) != 0)
            continue;
#endif

        if( sKeyPack.ucKeyPackType == LSKEYPACKTYPE_TEMPORARY ||
            sKeyPack.ucKeyPackType == LSKEYPACKTYPE_FREE)
        {
            continue;
        }
        
        int nResult = m_LicenseCombo.AddString(sKeyPack.szProductDesc);
        if(nResult == CB_ERR || nResult == CB_ERRSPACE)
            return FALSE;
     }
     m_LicenseCombo.SetCurSel(0);
     OnSelchangeKeypackType();
         
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddKeyPack::OnHelp2() 
{
    // TODO: Add your control notification handler code here
    AfxGetApp()->WinHelp(IDC_HELP2,HELP_CONTEXT );
    
}

void CAddKeyPack::OnOK() 
{
    // TODO: Add extra validation here
    //Validate the information Entered
    UpdateData();
    if(m_KeypackType.IsEmpty())
    {
         AfxMessageBox(IDS_INVALID_FIELDS);
         return;
    }

    //Ask the user to select number of Licenses he wants to add.

    CAddLicenses AddLicense;

    if(IDCANCEL == AddLicense.DoModal())
        return;


    //Display the License agreement

     CLicAgreement LicAgreement;
     CString TempString;
     TempString.LoadString(IDS_LIC_AGRMT);
     LicAgreement.m_License.Format((LPCTSTR)TempString,AddLicense.m_NumLicenses);
     if( IDCANCEL == LicAgreement.DoModal())
         return;
     else
         CDialog::OnOK();
}

void CAddKeyPack::OnSelchangeKeypackType() 
{
    // TODO: Add your control notification handler code here

    UpdateData();
    //Get the Current Selection.

    int nSelection = m_LicenseCombo.GetCurSel( );

    //Get the Product Description.

    CString ProdDesc;

    m_LicenseCombo.GetLBText(nSelection,ProdDesc);

    //Search and pickup the keypack with this product description.
    //Set the Edit box to display the total licenses.

    POSITION pos = m_pKeyPackList->GetHeadPosition();
    while(pos)
    {
        CKeyPack *pKeyPack = (CKeyPack *)m_pKeyPackList->GetNext(pos);
        if(NULL == pKeyPack)
            break;
        LSKeyPack sKeyPack = pKeyPack->GetKeyPackStruct();
        
        if(0 == ProdDesc.CompareNoCase(sKeyPack.szProductDesc))
        {
           m_TotalLicenses = sKeyPack.dwTotalLicenseInKeyPack;
           break;
        }
     }
    UpdateData(FALSE);
    return;
}

void CAddKeyPack::OnAddLicenses() 
{
    int nCount = m_LicenseCombo.GetCount( );
    CString ProdDesc, DescBeforeAddLicense;
    CKeyPack *pKeyPack = NULL;
    LSKeyPack sKeyPack;
    HRESULT hResult = ERROR_SUCCESS;
	BOOL bUpdateData = TRUE;

    CLicMgrApp *pApp = (CLicMgrApp*)AfxGetApp();
    ASSERT(pApp);
    if(NULL == pApp)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
     }
    CMainFrame * pWnd = (CMainFrame *)pApp->m_pMainWnd ;
    ASSERT(pWnd);
    if(NULL == pWnd)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }
    m_LicenseCombo.GetLBText(m_LicenseCombo.GetCurSel(),DescBeforeAddLicense);

    CAddLicenses  AddLicense(this);
    if(IDOK == AddLicense.DoModal())
    {
        //Get the LicensePack to which the data has to be added.

         //Display the License agreement
	   ProdDesc = AddLicense.m_LicensePack;
	   GetKeyPack(ProdDesc,&pKeyPack);
       if(NULL == pKeyPack)
       {
           AfxMessageBox(IDS_INTERNAL_ERROR);
           return;
       }
	   sKeyPack = pKeyPack->GetKeyPackStruct();
	   if(0 != ProdDesc.CompareNoCase(DescBeforeAddLicense))
	   {
		   //User has changed selection in the AddLicenses Dialog.
		   //reset the m_TotalLicenses and set bUpdateData to FALSE;
		   m_TotalLicenses = sKeyPack.dwTotalLicenseInKeyPack;
		   bUpdateData = FALSE;

	   }

       CLicAgreement LicAgreement;
       CString TempString;
       TempString.LoadString(IDS_LIC_AGRMT);
       LicAgreement.m_License.Format((LPCTSTR)TempString,m_TotalLicenses + AddLicense.m_NumLicenses);
       if( IDCANCEL == LicAgreement.DoModal())
           return;
       SetCursor(LoadCursor(NULL,IDC_WAIT));
       hResult = pWnd->AddLicenses(pKeyPack,AddLicense.m_NumLicenses);
       if(ERROR_SUCCESS != hResult)
       {
           if(LSERVER_E_ACCESS_DENIED == hResult)
               AfxMessageBox(IDS_NO_ACCESS);
           else
               AfxMessageBox(IDS_INTERNAL_ERROR);
           return;
       }
       m_TotalLicenses = m_TotalLicenses + AddLicense.m_NumLicenses;
	   sKeyPack = pKeyPack->GetKeyPackStruct();
       if((m_TotalLicenses != sKeyPack.dwTotalLicenseInKeyPack) && !bUpdateData)
       {
           TempString.Format(IDS_TOTAL_CHANGED,sKeyPack.dwTotalLicenseInKeyPack - AddLicense.m_NumLicenses,sKeyPack.dwTotalLicenseInKeyPack);
           AfxMessageBox(TempString);
       }
       m_TotalLicenses = sKeyPack.dwTotalLicenseInKeyPack;
       if(bUpdateData)
	   {
           UpdateData(FALSE);
	   }
       return;
  }
}

void CAddKeyPack::OnRemoveLicenses() 
{
    int nCount = m_LicenseCombo.GetCount( );
    CString ProdDesc,DescBeforeRemLicense;
    CKeyPack *pKeyPack = NULL;
    LSKeyPack sKeyPack;
    CString TempString;
    CString RemWarning;
    HRESULT hResult = ERROR_SUCCESS;

    CLicMgrApp *pApp = (CLicMgrApp*)AfxGetApp();
    ASSERT(pApp);
    if(NULL == pApp)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
     }
    CMainFrame * pWnd = (CMainFrame *)pApp->m_pMainWnd ;
    ASSERT(pWnd);
    if(NULL == pWnd)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }
    m_LicenseCombo.GetLBText(m_LicenseCombo.GetCurSel(),DescBeforeRemLicense);
    CRemoveLicenses  RemLicense(this);
    if(IDOK == RemLicense.DoModal())
    {
        //Get the LicensePack to which the data has to be added.

        ProdDesc = RemLicense.m_LicensePack;
        GetKeyPack(ProdDesc,&pKeyPack);
        if(NULL == pKeyPack)
        {
            AfxMessageBox(IDS_INTERNAL_ERROR);
            return;
        }
        sKeyPack = pKeyPack->GetKeyPackStruct();
        if(RemLicense.m_NumLicenses > sKeyPack.dwTotalLicenseInKeyPack)
        {
           TempString.LoadString(IDS_REMOVE_MORE);
           RemWarning.Format((LPCTSTR)TempString, sKeyPack.dwNumberOfLicenses,RemLicense.m_NumLicenses);
           AfxMessageBox(RemWarning);
           return;
        }
        TempString.LoadString(IDS_REMOVE_WARNING);
        RemWarning.Format((LPCTSTR)TempString,RemLicense.m_NumLicenses,ProdDesc);
        if(IDNO  == AfxMessageBox(RemWarning,MB_YESNO))
           return;
        hResult = pWnd->RemoveLicenses(pKeyPack,RemLicense.m_NumLicenses);
        if(ERROR_SUCCESS != hResult && LSERVER_I_REMOVE_TOOMANY != hResult)
        {
            if(LSERVER_E_ACCESS_DENIED == hResult)
                AfxMessageBox(IDS_NO_ACCESS);
            else
                AfxMessageBox(IDS_INTERNAL_ERROR);
            return;
        }
        if(LSERVER_I_REMOVE_TOOMANY == hResult)
        {
            sKeyPack = pKeyPack->GetKeyPackStruct();
            TempString.Format(IDS_REMOVE_TOOMANY,sKeyPack.dwTotalLicenseInKeyPack);
            AfxMessageBox(TempString);
            m_TotalLicenses = sKeyPack.dwTotalLicenseInKeyPack;
            UpdateData(FALSE);
            return;
        }
        m_TotalLicenses = m_TotalLicenses - RemLicense.m_NumLicenses;
        sKeyPack = pKeyPack->GetKeyPackStruct();
        if((m_TotalLicenses != sKeyPack.dwTotalLicenseInKeyPack) &&
            (0 == ProdDesc.CompareNoCase(DescBeforeRemLicense)))
        {
            TempString.Format(IDS_TOTAL_CHANGED,sKeyPack.dwTotalLicenseInKeyPack + RemLicense.m_NumLicenses,sKeyPack.dwTotalLicenseInKeyPack);
            AfxMessageBox(TempString);
            m_TotalLicenses = sKeyPack.dwTotalLicenseInKeyPack;

        }
        if(0 == ProdDesc.CompareNoCase(DescBeforeRemLicense))
            UpdateData(FALSE);
        return;



    }

   //Get the Product Description.

   
}

void CAddKeyPack::GetKeyPack(CString ProdDesc, CKeyPack ** ppKeyPack) 
{
    if(NULL == ppKeyPack)
        return;
    *ppKeyPack = NULL;
    if(NULL == m_pKeyPackList)
        return;
    
    CKeyPack * pKeyPack = NULL;
    LSKeyPack sKeyPack;
    POSITION pos = m_pKeyPackList->GetHeadPosition();
    while(pos)
    {
        pKeyPack = (CKeyPack *)m_pKeyPackList->GetNext(pos);
        if(NULL == pKeyPack)
            return;
        sKeyPack = pKeyPack->GetKeyPackStruct();
    
        if(0 == ProdDesc.CompareNoCase(sKeyPack.szProductDesc))
        {
           *ppKeyPack = pKeyPack;
           break;
        }
    }
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\addkp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:
    
    AddKp.h

Abstract:
    
    This Module defines the CAddKeyPack Dialog class
    (Dialog box used for adding keypacks)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/
#if !defined(AFX_ADDKEYPACK_H__0AD8B4BD_995D_11D1_850D_00C04FB6CBB5__INCLUDED_)
#define AFX_ADDKEYPACK_H__0AD8B4BD_995D_11D1_850D_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CAddKeyPack dialog
class CAddLicenses;
class CRemoveLicenses;

class CAddKeyPack : public CDialog
{
// Construction
public:
    BOOL m_bIsUserAdmin;
    CAddKeyPack(CWnd* pParent = NULL);   // standard constructor
    CAddKeyPack(KeyPackList *pKeyPackList,BOOL bIsUserAdmin,CWnd* pParent = NULL);
    void GetKeyPack(CString ProdDesc, CKeyPack ** ppKeyPack);

    friend CAddLicenses;
    friend CRemoveLicenses;
private:
    KeyPackList * m_pKeyPackList;


// Dialog Data
    //{{AFX_DATA(CAddKeyPack)
    enum { IDD = IDD_ADD_KEYPACK };
    CString    m_KeypackType;
    CComboBox m_LicenseCombo;
    UINT m_TotalLicenses;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddKeyPack)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddKeyPack)
    virtual BOOL OnInitDialog();
    afx_msg void OnHelp2();
    afx_msg void OnAddLicenses();
    afx_msg void OnRemoveLicenses();
    virtual void OnOK();
    afx_msg void OnSelchangeKeypackType();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDKEYPACK_H__0AD8B4BD_995D_11D1_850D_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\cmdln.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	cmdln.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrCommandLine class
    (used for CommandLine Processing)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "cmdln.h"
//Change this function to process the commandline differently

void CLicMgrCommandLine::ParseParam(LPCTSTR pszParam, BOOL bFlag, BOOL bLast)
{
   if (!bFlag && m_bFirstParam)
   {
      m_FileName = pszParam;
      m_bFirstParam = FALSE;
   }
}

CLicMgrCommandLine::CLicMgrCommandLine():CCommandLineInfo()
{
    m_bFirstParam = TRUE;
    m_FileName = _T("");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\addlic.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	AddLic.h

Abstract:
    
    This Module defines the CAddLicenses Dialog class
    (Dialog box used for adding Licenses)

Author:

    Arathi Kundapur (v-akunda) 22-Feb-1998

Revision History:

--*/

#if !defined(AFX_ADDLIC_H__EA547D83_A88B_11D1_84DD_00C04FB6CBB5__INCLUDED_)
#define AFX_ADDLIC_H__EA547D83_A88B_11D1_84DD_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000
// AddLic.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddLicenses dialog

class CAddLicenses : public CDialog
{
// Construction
public:
	CAddLicenses(CWnd* pParent = NULL);   // standard constructor
    CAddLicenses(CAddKeyPack *pAddKeyPack,CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CAddLicenses)
	enum { IDD = IDD_ADD_LICENSES };
	CSpinButtonCtrl	m_SpinCtrl;
    CComboBox m_LicenseCombo;
	CString	m_LicensePack;
	DWORD	m_NumLicenses;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddLicenses)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddLicenses)
	virtual BOOL OnInitDialog();
    afx_msg void OnHelp();

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CAddKeyPack * m_pAddKeyPack;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDLIC_H__EA547D83_A88B_11D1_84DD_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\cntdlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	CntDlg.cpp

Abstract:
    
    This Module contains the implementation of CConnectDialog class
    (Dialog box for Connecting to Server)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "defines.h"
#include "LicMgr.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "CntDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectDialog dialog


CConnectDialog::CConnectDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CConnectDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(CConnectDialog)
    m_Server = _T("");
    //}}AFX_DATA_INIT
}


void CConnectDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConnectDialog)
    DDX_Text(pDX, IDC_SERVER, m_Server);
    DDV_MaxChars(pDX, m_Server, 100);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectDialog, CDialog)
    //{{AFX_MSG_MAP(CConnectDialog)
    ON_BN_CLICKED(IDC_HELP1, OnHelp1)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectDialog message handlers

void CConnectDialog::OnHelp1() 
{
    // TODO: Add your control notification handler code here
   AfxGetApp()->WinHelp(IDC_HELP1,HELP_CONTEXT );
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\cntdlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	CntDlg.h

Abstract:
    
    This Module defines CConnectDialog class
    (Dialog box for Connecting to Server)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_CONNECTDIALOG_H__AF425817_988E_11D1_850A_00C04FB6CBB5__INCLUDED_)
#define AFX_CONNECTDIALOG_H__AF425817_988E_11D1_850A_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
// CConnectDialog dialog

class CConnectDialog : public CDialog
{
// Construction
public:
    CConnectDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CConnectDialog)
    enum { IDD = IDD_CONNECT_DIALOG };
    CString    m_Server;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CConnectDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CConnectDialog)
    afx_msg void OnHelp1();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONNECTDIALOG_H__AF425817_988E_11D1_850A_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\addlic.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


Module Name:

    AddLic.cpp

Abstract:
    
    This Module contains the implementation of CAddLicenses Dialog class
    (Dialog box used for adding licenses)

Author:

    Arathi Kundapur (v-akunda) 22-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "licmgr.h"
#include "defines.h"
#include "lsserver.h"
#include "addkp.h"
#include "AddLic.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddLicenses dialog


CAddLicenses::CAddLicenses(CWnd* pParent /*=NULL*/)
    : CDialog(CAddLicenses::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddLicenses)
    m_LicensePack = _T("");
    m_NumLicenses = 0;
    m_pAddKeyPack = NULL;
    //}}AFX_DATA_INIT
}

CAddLicenses::CAddLicenses(CAddKeyPack * pAddKeyPack,CWnd* pParent /*=NULL*/)
    : CDialog(CAddLicenses::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddLicenses)
    m_LicensePack = _T("");
    m_NumLicenses = 0;
    m_pAddKeyPack = pAddKeyPack;
    //}}AFX_DATA_INIT
}


void CAddLicenses::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddLicenses)
    DDX_Control(pDX, IDC_SPIN_LICNESES, m_SpinCtrl);
    DDX_Control(pDX, IDC_LICNESE_PACK, m_LicenseCombo);
    DDX_CBString(pDX, IDC_LICNESE_PACK, m_LicensePack);
    DDX_Text(pDX, IDC_NUM_LICENSES, m_NumLicenses);
    DDV_MinMaxDWord(pDX, m_NumLicenses, 1, 9999);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddLicenses, CDialog)
    //{{AFX_MSG_MAP(CAddLicenses)
    ON_BN_CLICKED(IDC_HELP3, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddLicenses message handlers

BOOL CAddLicenses::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
    // TODO: Add extra initialization here

    CString ProdDesc;

    if(NULL == m_pAddKeyPack)
        return FALSE;

    int nCount = m_pAddKeyPack->m_LicenseCombo.GetCount( );
    for(int i = 0; i < nCount; i++)
    {
        m_pAddKeyPack->m_LicenseCombo.GetLBText(i,ProdDesc);
        m_LicenseCombo.AddString(ProdDesc);
    }

    m_SpinCtrl.SetBase(1);
    m_SpinCtrl.SetRange(1,MAX_LICENSES);
    m_SpinCtrl.SetPos(1);

    m_LicenseCombo.SetCurSel(m_pAddKeyPack->m_LicenseCombo.GetCurSel());
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddLicenses::OnHelp() 
{
    // TODO: Add your control notification handler code here
    AfxGetApp()->WinHelp(IDC_HELP3,HELP_CONTEXT );
    return;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\cmdln.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	AddKp.h

Abstract:
    
    This Module defines CLicMgrCommandLine class
    (CommandLine Processing)
   
Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

class CLicMgrCommandLine : public CCommandLineInfo
{
private:
    BOOL m_bFirstParam;
public:
    CString m_FileName;
    CLicMgrCommandLine();
    virtual void ParseParam(LPCTSTR pszParam, BOOL bFlag, BOOL bLast);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\custprop.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	Custprop.cpp

Abstract:
    
    This Module contains the implementation of CCustomPropertySheet class
    (Base class for the property sheets)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "LicMgr.h"
#include "CustProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCustomPropertySheet

IMPLEMENT_DYNAMIC(CCustomPropertySheet, CPropertySheet)

CCustomPropertySheet::CCustomPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CCustomPropertySheet::CCustomPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CCustomPropertySheet::~CCustomPropertySheet()
{
}


BEGIN_MESSAGE_MAP(CCustomPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CCustomPropertySheet)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCustomPropertySheet message handlers

BOOL CCustomPropertySheet::OnInitDialog() 
{
    BOOL bResult = CPropertySheet::OnInitDialog();
    
    // TODO: Add your specialized code here
    //Hide the Cancel button

    GetDlgItem(IDCANCEL)->ShowWindow(SW_HIDE);
    
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\custprop.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	Custprop.h

Abstract:
    
    This Module defines the CCustomPropertySheet class
    (Base class for the property sheets)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_CUSTOMPROPERTYSHEET_H__3B3F2ECE_8C69_11D1_8AD5_00C04FB6CBB5__INCLUDED_)
#define AFX_CUSTOMPROPERTYSHEET_H__3B3F2ECE_8C69_11D1_8AD5_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CCustomPropertySheet

class CCustomPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CCustomPropertySheet)

// Construction
public:
    CCustomPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CCustomPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCustomPropertySheet)
    public:
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CCustomPropertySheet();

    // Generated message map functions
protected:
    //{{AFX_MSG(CCustomPropertySheet)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CUSTOMPROPERTYSHEET_H__3B3F2ECE_8C69_11D1_8AD5_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\defines.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    defines.h

Abstract:
    
    This Module includes the definitions.
   
Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#ifndef _DEFINES_H_
#define _DEFINES_H_

#include <rpc.h>
#include "lsclient.h"
#include "license.h"
#include "tlsapip.h"
#include <rpcnsi.h>

#define WM_ADD_SERVER       WM_USER + 1
#define WM_SEL_CHANGE       WM_USER + 2
#define WM_ADD_ALL_SERVERS  WM_USER + 3
#define WM_ADD_KEYPACKS     WM_USER + 4
#define WM_ADD_KEYPACK      WM_USER + 5
#define WM_DELETE_SERVER    WM_USER + 6
#define WM_UPDATE_SERVER    WM_USER + 7
#define WM_ENUMERATESERVER  (WM_USER + 8)

#define TERMSERVICE_PARAMETER_KEY _T("system\\CurrentcontrolSet\\Services\\TermService\\enum")
#define USE_LICSENSE_SERVER _T("UseLicenseServer")
#define LICSENSE_SERVER _T("DefaultLicenseServer")


enum NODETYPE {
    NODE_ALL_SERVERS,
    NODE_SERVER,
    NODE_KEYPACK,
    NODE_NONE
};

#define LG_BITMAP_WIDTH    32
#define LG_BITMAP_HEIGHT 32
#define SM_BITMAP_WIDTH    16
#define SM_BITMAP_HEIGHT 16

#define MAX_COLUMNS              6
#define NUM_SERVER_COLUMNS       2
#define NUM_KEYPACK_COLUMNS      5
#define NUM_LICENSE_COLUMNS      3
#define MAX_LICENSES             9999

#define NUM_PLATFORM_TYPES      1
#define NUM_KEYPACK_STATUS      7
#define NUM_PURCHASE_CHANNEL    3
#define NUM_LICENSE_STATUS      5
#define NUM_KEYPACK_TYPE        8

#define KEYPACK_DISPNAME_WIDTH  250
#define KEYPACK_OTHERS_WIDTH    100


//Return values. Bound to change

#define ALREADY_EXPANDED    0
#define CONNECTION_FAILED   1
#define ENUM_FAILED         2
#define ADD_KEYPACK_FAILED  4
#define E_DUPLICATE         5
#define ERROR_UNLIMITED_KEYPACK 6

enum SERVER_TYPE
{
	SERVER_TS4,
	SERVER_TS5_ENFORCED,
	SERVER_TS5_NONENFORCED
};

enum VIEW
{
    TREEVIEW,
    LISTVIEW,
    NOVIEW
};

typedef enum 
{
    TLSERVER_UNKNOWN,
    TLSERVER_TS4,
    TLSERVER_UNREGISTER,
    TLSERVER_CH_REGISTERED,
    TLSERVER_PHONE_REGISTERED,
    TLSERVER_TS5_NONENFORCED
} SERVER_REGISTRATION_STATUS;


#define E_NO_SERVER  ((HRESULT)0x80050001L)

#endif //_DEFINES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\licagrmt.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LicAgrmt.cpp

Abstract:
    
    This Module contains the implementation of the CLicAgreement Dialog class
    (Dialog box used for displaying License Agreement)

Author:

    Arathi Kundapur (v-akunda) 17-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "licmgr.h"
#include "LicAgrmt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicAgreement dialog


CLicAgreement::CLicAgreement(CWnd* pParent /*=NULL*/)
	: CDialog(CLicAgreement::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLicAgreement)
	m_License = _T("");
	//}}AFX_DATA_INIT
}


void CLicAgreement::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLicAgreement)
	DDX_Text(pDX, IDC_LICENSE, m_License);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicAgreement, CDialog)
	//{{AFX_MSG_MAP(CLicAgreement)
	ON_BN_CLICKED(IDC_AGREE, OnAgree)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicAgreement message handlers

void CLicAgreement::OnAgree() 
{
	// TODO: Add your control notification handler code here
    if(IsDlgButtonChecked(IDC_AGREE))
        GetDlgItem(IDOK)->EnableWindow();
    else
        GetDlgItem(IDOK)->EnableWindow(FALSE);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\kpprop.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	KPProp.h

Abstract:
    
    This Module contains the implementation of CKeyPackProperty class
    (Property sheet for KeyPacks)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/
#include "stdafx.h"
#include "LicMgr.h"
#include "KPProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKeyPackProperty property page

IMPLEMENT_DYNCREATE(CKeyPackProperty, CPropertyPage)

CKeyPackProperty::CKeyPackProperty() : CPropertyPage(CKeyPackProperty::IDD)
{
    //{{AFX_DATA_INIT(CKeyPackProperty)
    m_TotalLicenses = _T("");
    m_ProductName = _T("");
    m_ProductId = _T("");
    m_MinorVersion = _T("");
    m_MajorVersion = _T("");
    m_KeypackStatus = _T("");
    m_KeyPackId = _T("");
    m_ExpirationDate = _T("");
    m_ChannelOfPurchase = _T("");
    m_BeginSerial = _T("");
    m_AvailableLicenses = _T("");
    m_ActivationDate = _T("");
    m_KeyPackType = _T("");
    //}}AFX_DATA_INIT
}

CKeyPackProperty::~CKeyPackProperty()
{
}

void CKeyPackProperty::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CKeyPackProperty)
    DDX_Text(pDX, IDC_TOTAL_LICENSES, m_TotalLicenses);
    DDX_Text(pDX, IDC_PRODUCT_NAME, m_ProductName);
    DDX_Text(pDX, IDC_PRODUCT_ID, m_ProductId);
    DDX_Text(pDX, IDC_MINOR_VERSION, m_MinorVersion);
    DDX_Text(pDX, IDC_MAJOR_VERSION, m_MajorVersion);
    DDX_Text(pDX, IDC_KEYPACK_STATUS, m_KeypackStatus);
    DDX_Text(pDX, IDC_KEYPACK_ID, m_KeyPackId);
    DDX_Text(pDX, IDC_EXPIRATION_DATE, m_ExpirationDate);
    DDX_Text(pDX, IDC_CHANNEL_OF_PURCHASE, m_ChannelOfPurchase);
    DDX_Text(pDX, IDC_BEGIN_SERIAL, m_BeginSerial);
    DDX_Text(pDX, IDC_AVAILABLE_LICENSES, m_AvailableLicenses);
    DDX_Text(pDX, IDC_ACTIVATION_DATE, m_ActivationDate);
    DDX_Text(pDX, IDC_KEYPACK_TYPE, m_KeyPackType);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CKeyPackProperty, CPropertyPage)
    //{{AFX_MSG_MAP(CKeyPackProperty)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyPackProperty message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\kpprop.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#if !defined(AFX_KEYPACKPROPERTY_H__3B3F2ECF_8C69_11D1_8AD5_00C04FB6CBB5__INCLUDED_)
#define AFX_KEYPACKPROPERTY_H__3B3F2ECF_8C69_11D1_8AD5_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000
// KPProp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CKeyPackProperty dialog

class CKeyPackProperty : public CPropertyPage
{
    DECLARE_DYNCREATE(CKeyPackProperty)

// Construction
public:
    CKeyPackProperty();
    ~CKeyPackProperty();

// Dialog Data
    //{{AFX_DATA(CKeyPackProperty)
    enum { IDD = IDD_KEYPACK_PROPERTYPAGE };
    CString    m_TotalLicenses;
    CString    m_ProductName;
    CString    m_ProductId;
    CString    m_MinorVersion;
    CString    m_MajorVersion;
    CString    m_KeypackStatus;
    CString    m_KeyPackId;
    CString    m_ExpirationDate;
    CString    m_ChannelOfPurchase;
    CString    m_BeginSerial;
    CString    m_AvailableLicenses;
    CString    m_ActivationDate;
    CString    m_KeyPackType;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CKeyPackProperty)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CKeyPackProperty)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYPACKPROPERTY_H__3B3F2ECF_8C69_11D1_8AD5_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\licmgr.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LicMgr.cpp

Abstract:
    
    This Module declaration of CLicMgrApp class
    (The Application class.)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_LICMGR_H__72451C6B_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_LICMGR_H__72451C6B_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols



/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp:
// See LicMgr.cpp for the implementation of this class
//

class CLicMgrApp : public CWinApp
{
public:
    CString m_Server;
    CLicMgrApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLicMgrApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CLicMgrApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LICMGR_H__72451C6B_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\licagrmt.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LicAgrmet.h

Abstract:
    
    This Module contains the declaration  of CLicAgreement Dialog class
    (Dialog box used for Displaying License Agreement.)

Author:

    Arathi Kundapur (v-akunda) 17-Feb-1998

Revision History:

--*/

#if !defined(AFX_LICAGRMT_H__65A6A35D_9E41_11D1_8510_00C04FB6CBB5__INCLUDED_)
#define AFX_LICAGRMT_H__65A6A35D_9E41_11D1_8510_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000
// LicAgrmt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLicAgreement dialog

class CLicAgreement : public CDialog
{
// Construction
public:
	CLicAgreement(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CLicAgreement)
	enum { IDD = IDD_LIC_AGREEMENT };
	CString	m_License;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLicAgreement)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLicAgreement)
	afx_msg void OnAgree();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LICAGRMT_H__65A6A35D_9E41_11D1_8510_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\licmgr.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LicMgr.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrApp class.
    (The Application class)

Author:

    Arathi Kundapur (v-akunda) 22-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "LSMgrDoc.h"
#include "LtView.h"
#include "cmdln.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp

BEGIN_MESSAGE_MAP(CLicMgrApp, CWinApp)
    //{{AFX_MSG_MAP(CLicMgrApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp construction

CLicMgrApp::CLicMgrApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLicMgrApp object

CLicMgrApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp initialization

BOOL CLicMgrApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();            // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();    // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    SetRegistryKey(_T("Local AppWizard-Generated Applications"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CLicMgrDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CLicMgrLeftView));
    AddDocTemplate(pDocTemplate);

    // Parse command line for standard shell commands, DDE, file open
    CLicMgrCommandLine cmdInfo;
    ParseCommandLine(cmdInfo);
    m_Server = cmdInfo.m_FileName;
  //  cmdInfo.m_strFileName = _T("");

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();
    m_pMainWnd->PostMessage(WM_ENUMERATESERVER);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CLicMgrApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\lsmgrdoc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LsMgrDoc.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrDoc class
    (The Document class)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "defines.h"
#include "LicMgr.h"
#include "LSMgrDoc.h"
#include "LSServer.h"
#include "MainFrm.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc

IMPLEMENT_DYNCREATE(CLicMgrDoc, CDocument)

BEGIN_MESSAGE_MAP(CLicMgrDoc, CDocument)
    //{{AFX_MSG_MAP(CLicMgrDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc construction/destruction

CLicMgrDoc::CLicMgrDoc()
{
   
    // TODO: add one-time construction code here
    m_NodeType = NODE_NONE;
    m_pAllServers = NULL;
       
}

CLicMgrDoc::~CLicMgrDoc()
{
    if(m_pAllServers)
    {
        delete m_pAllServers;
        m_pAllServers = NULL;
    }
}

BOOL CLicMgrDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)

    return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc serialization

void CLicMgrDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrDoc diagnostics

#ifdef _DEBUG
void CLicMgrDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CLicMgrDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG


HRESULT CLicMgrDoc::EnumerateKeyPacks(CLicServer *pServer,DWORD dwSearchParm,BOOL bMatchAll)
{
    ASSERT(pServer);
    HRESULT hResult = S_OK;

    if(pServer == NULL)
        return E_FAIL;

    if(TRUE == pServer->IsExpanded())
        return ALREADY_EXPANDED;

    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    RPC_STATUS status;
    LSKeyPack keypack;
     
    CString Server;
    hBinding = pServer->GetContext();
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
            Server = pServer->GetIpAddress();
        else
               Server = pServer->GetName();
        hBinding=ConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }

    memset(&keypack, 0, sizeof(keypack));
    keypack.dwLanguageId = GetUserDefaultUILanguage();
    status = LSKeyPackEnumBegin(hBinding, dwSearchParm, bMatchAll, &keypack);
    if(status != ERROR_SUCCESS)
    { 
        hResult = status;
        goto cleanup;
    }
    else
    {
        do
        {
            status = LSKeyPackEnumNext(hBinding, &keypack);
            if(status == ERROR_SUCCESS)
            {
                DBGMSG( L"LICMGR:CLicMgrDoc::EnumerateKeyPacks - LSKeyPackEnumNext\n" , 0 );

                CKeyPack * pKeyPack = new CKeyPack(keypack);
                if(pKeyPack == NULL)
                {
                    hResult = E_OUTOFMEMORY;
                    goto cleanup;
                }
                pServer->AddKeyPack(pKeyPack);
            }
        } while(status == ERROR_SUCCESS);

        LSKeyPackEnumEnd(hBinding);
        pServer->Expand(TRUE);
    } 

cleanup:
    //put cleanup code here. 
    if(hBinding)
        LSDisconnect(&hBinding);
        
    return hResult;



}

HRESULT 
CLicMgrDoc::EnumerateLicenses(
    CKeyPack *pKeyPack,
    DWORD dwSearchParm,
    BOOL bMatchAll
    )
/*++

--*/
{
    ASSERT(pKeyPack);

    if(NULL == pKeyPack)
    {
        return E_FAIL;
    }

    CLicServer *pServer = pKeyPack->GetServer();

    ASSERT(pServer);
    if(NULL == pKeyPack)
    {
        return E_FAIL;
    }

    HRESULT hResult = S_OK;

    if(TRUE == pKeyPack->IsExpanded())
    {
        return ALREADY_EXPANDED;
    }

    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    DWORD status = ERROR_SUCCESS;
    LSLicenseEx  sLicense;
    CString Server;
   

    hBinding = pServer->GetContext();
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
        {
            Server = pServer->GetIpAddress();
        }
        else
        {
            Server = pServer->GetName();
        }

        hBinding=ConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }
    
    memset(&sLicense, 0, sizeof(LSLicenseEx));
    sLicense.dwKeyPackId = pKeyPack->GetKeyPackStruct().dwKeyPackId;
    TLSLicenseEnumBegin( hBinding, dwSearchParm,bMatchAll ,(LPLSLicenseSearchParm) &sLicense, &status);
    if(status != ERROR_SUCCESS)
    { 
        hResult = status;
        goto cleanup;
    }
    else
    {
        
        do {
                memset(&sLicense, 0, sizeof(LSLicenseEx));
                sLicense.dwKeyPackId = pKeyPack->GetKeyPackStruct().dwKeyPackId;
                TLSLicenseEnumNextEx(hBinding,&sLicense,&status);
                if(status == ERROR_SUCCESS)
                {
                    CLicense * pLicense = new CLicense(sLicense);
                    if(NULL == pLicense)
                    {
                        hResult = E_OUTOFMEMORY;
                        goto cleanup;
                    }
                    
                    pKeyPack->AddIssuedLicense(pLicense);
                }
            } while(status == ERROR_SUCCESS);

        TLSLicenseEnumEnd(hBinding,&status);

        pKeyPack->Expand(TRUE);
    } 

cleanup:
    //put cleanup code here
    if(hBinding)
    {
        LSDisconnect(&hBinding);
    }

    return hResult;

}


HRESULT 
CLicMgrDoc::ConnectToServer(
    CString& Server, 
    CString& Scope, 
    SERVER_TYPE& ServerType    
    )
/*++

--*/
{
    PCONTEXT_HANDLE hBinding = NULL;
    HRESULT hResult = ERROR_SUCCESS;
    RPC_STATUS status;
    TCHAR      szServerScope[LSERVER_MAX_STRING_SIZE];
    TCHAR      szMachineName[LSERVER_MAX_STRING_SIZE];

    ULONG uSize;
	DWORD dwVersion = 0;
    PBYTE pbData = NULL;
    DWORD cbData = 0;

    hBinding = ConnectToLsServer(Server.GetBuffer(Server.GetLength()));
   
    if(hBinding == NULL)
    {
       hResult = E_FAIL;
       goto cleanup;
    }

    uSize = sizeof(szMachineName) / sizeof(szMachineName[0]);
    memset(szMachineName, 0, sizeof(szMachineName));

    status = LSGetServerName(hBinding,szMachineName,&uSize);
    if(status == RPC_S_OK)
    {
        Server = szMachineName;
    }

    uSize = sizeof(szServerScope) / sizeof(szServerScope[0]);
    memset(szServerScope, 0, sizeof(szServerScope));

    status = LSGetServerScope(hBinding, szServerScope,&uSize);
    if(status == RPC_S_OK)
    {
        Scope = szServerScope;
    }
    else
    {
        Scope.LoadString(IDS_UNKNOWN);
    }
	//Get whether this is a TS4 server or TS5Enforced or TS5NonEnforced
	//Use TLSGetVersion

	status = TLSGetVersion (hBinding, &dwVersion);
	if(status == RPC_S_OK)
	{
		if(dwVersion & 0x40000000)
		{
			ServerType = SERVER_TS5_ENFORCED;

        }
		else
		{
			ServerType = SERVER_TS5_NONENFORCED;
		}
	}
	else if(status  == RPC_S_UNKNOWN_IF)
	{
		ServerType = SERVER_TS4;
		Scope = Server ;       
	}
    else
	{
		hResult = E_FAIL;        
	}

cleanup:

    if(pbData != NULL)
    {
        midl_user_free(pbData);
    }

    if(hBinding)
    {
        LSDisconnect(&hBinding);
    }

    return hResult;

}

HRESULT CLicMgrDoc::ConnectWithCurrentParams()
{
    CLicMgrApp *pApp = (CLicMgrApp*)AfxGetApp();
    CMainFrame * pWnd = (CMainFrame *)pApp->m_pMainWnd ;

    HRESULT hResult = ERROR_SUCCESS;
    CString Scope;
    CString IpAddress;

    CString Server = pApp->m_Server;
    
    if(NULL == m_pAllServers)
         m_pAllServers = new CAllServers(_T(""));

    if(NULL == m_pAllServers)
    {
        hResult = E_OUTOFMEMORY;
        goto cleanup;
    }

    pWnd->SendMessage(WM_ADD_ALL_SERVERS,0,(LPARAM)m_pAllServers);
    
    if(!Server.IsEmpty())
    {
        if(TRUE == IsServerInList(Server))
        {
            hResult = E_DUPLICATE;    
        }

        if( hResult == ERROR_SUCCESS )
        {            
            pWnd->ConnectServer( Server );
        }
        /* Why did we have this here?

        IpAddress = Server;
        hResult = ConnectToServer(
                                Server,
                                Scope,
                                ServerType                           
                            );

        if(ERROR_SUCCESS == hResult)
        {
            CAllServers * pAllServers = m_pAllServers;
            CLicServer *pServer1 = NULL;
            if(IpAddress != Server)
            {
                if(TRUE == IsServerInList(Server))
                {
                    hResult = E_DUPLICATE; 
                    goto cleanup;
                }

                pServer1 = new CLicServer(Server,ServerType,Scope,IpAddress);
            }
            else
            {
                pServer1 = new CLicServer(Server,ServerType,Scope);
            }
            if(pServer1)
            {
                pAllServers->AddLicServer(pServer1);
                pWnd->SendMessage(WM_ADD_SERVER,0,(LPARAM)pServer1);
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        */

    }
cleanup:
    //Add any cleanup code required here.
    return hResult;

}

HRESULT CLicMgrDoc::AddLicenses(PLICSERVER pServer,LPLSKeyPack pKeyPack,UINT nLicenses)
{
    //Though the name of the function says add keypack, it adds licenses

    HRESULT hResult = E_FAIL;
    if(NULL == pServer || NULL == pKeyPack)
        return hResult;

    if(LSKEYPACKTYPE_TEMPORARY == pKeyPack->ucKeyPackType || 
        LSKEYPACKTYPE_SELECT == pKeyPack->ucKeyPackType ||
        LSKEYPACKTYPE_FREE == pKeyPack->ucKeyPackType )
    {
       hResult = ERROR_UNLIMITED_KEYPACK;
       return hResult;
    }

    RPC_STATUS status;
    PCONTEXT_HANDLE hBinding = NULL;
    LSKeyPack skeypack;
   
    hBinding = pServer->GetContext();

    CString Server;
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
            Server = pServer->GetIpAddress();
        else
            Server = pServer->GetName();
        hBinding=ConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }

    }

    skeypack = *pKeyPack;
    skeypack.dwTotalLicenseInKeyPack = nLicenses;
    skeypack.ucKeyPackStatus = LSKEYPACKSTATUS_ADD_LICENSE;
    status=LSKeyPackAdd(hBinding, &skeypack);
    if(ERROR_SUCCESS == status)
    {
        *pKeyPack = skeypack;
    }

    hResult = status;

cleanup:
     if(hBinding)
        LSDisconnect(&hBinding);
    return hResult;
}

void CLicMgrDoc:: TimeToString(DWORD *ptime, CString& rString)
{
    TCHAR m_szTime[MAX_PATH];
    time_t time;

    rString.Empty();

    ASSERT(ptime);
    if(NULL == ptime)
        return;

    //
    // Times are stored in the ANSI time_t style in the database,
    // however they are type cast to a DWORD (unsigned long). Because
    // time_t is 64 bit on a 64 bit machine, and because it is a signed
    // value, we must be careful here to make sure that the sign of the
    // value is not lost as the value goes from 32 to 64 bit.
    //

    time = (time_t)(LONG)(*ptime);

    LPTSTR lpszTime = NULL;

    //Getting the local time as the time is stored as GMT
    //in the license server database.

    struct tm * pTm = localtime(&time);
    if(NULL == pTm)
        return;

    SYSTEMTIME SystemTime;

    SystemTime.wYear      = (WORD)(pTm->tm_year + 1900);
    SystemTime.wMonth     = (WORD)(pTm->tm_mon  + 1);
    SystemTime.wDayOfWeek = (WORD)pTm->tm_wday;
    SystemTime.wDay       = (WORD)pTm->tm_mday;
    SystemTime.wHour      = (WORD)pTm->tm_hour;
    SystemTime.wMinute    = (WORD)pTm->tm_min;
    SystemTime.wSecond    = (WORD)pTm->tm_sec;
    SystemTime.wMilliseconds = 0;

    int RetLen;
    TCHAR DateFormat[MAX_PATH];
    TCHAR TimeFormat[MAX_PATH];

    RetLen = ::GetLocaleInfo(LOCALE_USER_DEFAULT,
                             LOCALE_SLONGDATE,
                             DateFormat,
                             sizeof(DateFormat)/sizeof(TCHAR));
    ASSERT(RetLen!=0);

    RetLen = ::GetLocaleInfo(LOCALE_USER_DEFAULT,
                             LOCALE_STIMEFORMAT,
                             TimeFormat,
                             sizeof(TimeFormat)/sizeof(TCHAR));
    ASSERT(RetLen!=0);

    RetLen = ::GetDateFormat(LOCALE_USER_DEFAULT,
                             0,                      /* dwFlag */
                             &SystemTime,
                             DateFormat,             /* lpFormat */
                             m_szTime,
                             sizeof(m_szTime)/sizeof(TCHAR));
    if (RetLen == 0)
        return;

    _tcscat(m_szTime, _T(" "));  /* Separator of date and time */

    lpszTime = &m_szTime[lstrlen(m_szTime)];
    RetLen = ::GetTimeFormat(LOCALE_USER_DEFAULT,
                             0,                          /* dwFlag */
                             &SystemTime,
                             TimeFormat,                 /* lpFormat */
                             lpszTime,
                             sizeof(m_szTime)/sizeof(TCHAR) - lstrlen(m_szTime));
    if (RetLen == 0)
        return;

    rString = m_szTime;
    return;
}


BOOL CLicMgrDoc::IsServerInList(CString & Server)
{
    ASSERT(m_pAllServers);
    if(NULL == m_pAllServers)
        return FALSE;
    BOOL bServerInList = FALSE;

    LicServerList * pServerList = m_pAllServers->GetLicServerList();
    
    //Assumption: ServerName is unique

    POSITION pos = pServerList->GetHeadPosition();
    while(pos)
    {
        CLicServer *pLicServer = (CLicServer *)pServerList->GetNext(pos);
        ASSERT(pLicServer);
        if(NULL == pLicServer)
            continue;
        
        if((0 == Server.CompareNoCase(pLicServer->GetName())) || (0 == Server.CompareNoCase(pLicServer->GetIpAddress())))
        {
            bServerInList = TRUE;
            break;
        }
     }
    return bServerInList;

}

HRESULT CLicMgrDoc::RemoveLicenses(PLICSERVER pServer,LPLSKeyPack pKeyPack,UINT nLicenses)
{
 
    HRESULT hResult = E_FAIL;
    if(NULL == pServer || NULL == pKeyPack)
        return hResult;

    if(LSKEYPACKTYPE_TEMPORARY == pKeyPack->ucKeyPackType || 
        LSKEYPACKTYPE_SELECT == pKeyPack->ucKeyPackType ||
        LSKEYPACKTYPE_FREE == pKeyPack->ucKeyPackType )
    {
       hResult = ERROR_UNLIMITED_KEYPACK;
       return hResult;
    }

    RPC_STATUS status;
    PCONTEXT_HANDLE hBinding = NULL;
    LSKeyPack skeypack;
   
    hBinding = pServer->GetContext();

    CString Server;
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
            Server = pServer->GetIpAddress();
        else
            Server = pServer->GetName();
        hBinding=ConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }

    }

    skeypack = *pKeyPack;
    if(nLicenses > skeypack.dwTotalLicenseInKeyPack)
    {
        hResult = E_FAIL;
        goto cleanup;
    }
    skeypack.dwTotalLicenseInKeyPack = nLicenses;
    skeypack.ucKeyPackStatus = LSKEYPACKSTATUS_REMOVE_LICENSE;
    status=LSKeyPackAdd(hBinding, &skeypack);

    if(ERROR_SUCCESS == status || LSERVER_I_REMOVE_TOOMANY == status)
    {
        *pKeyPack = skeypack;
    }

    hResult = status;

cleanup:
     if(hBinding)
        LSDisconnect(&hBinding);
    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\lsmgrdoc.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LSMgrDoc.h 

Abstract:
    
      This Module defines the Document class for the License Manager

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_LICMGRDOC_H__72451C71_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_LICMGRDOC_H__72451C71_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#include "LSServer.h"    // Added by ClassView
#include <afxmt.h>
#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

class CAllServers;
class CLicMgrDoc : public CDocument
{
protected: // create from serialization only
    CLicMgrDoc();
    DECLARE_DYNCREATE(CLicMgrDoc)

// Attributes
public:
   
// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLicMgrDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    //}}AFX_VIRTUAL

// Implementation
public:

    BOOL 
    IsServerInList(
        CString& Server
    );

    HRESULT 
    ConnectWithCurrentParams();

    HRESULT 
    ConnectToServer(
        CString& Server, 
        CString& Scope, 
        SERVER_TYPE& ServerType
    );

    HRESULT 
    EnumerateKeyPacks(
        CLicServer *pServer,
        DWORD dwSearchParm,
        BOOL bMatchAll
    );

    HRESULT 
    EnumerateLicenses(
        CKeyPack *pKeyPack,
        DWORD dwSearchParm,
        BOOL bMatchAll
    );

    virtual ~CLicMgrDoc();

    NODETYPE 
    GetNodeType()
    { 
        return m_NodeType;
    };

    void 
    SetNodeType(
        NODETYPE nodetype
        )
    {
        m_NodeType=nodetype;
    };

    CAllServers * 
    GetAllServers()
    {
        return m_pAllServers;
    };

    HRESULT 
    AddLicenses(
        PLICSERVER pServer,
        LPLSKeyPack pKeyPack,
        UINT nLicenses
    );

    HRESULT 
    RemoveLicenses(
        PLICSERVER pServer,
        LPLSKeyPack pKeyPack,
        UINT nLicenses
    );

    void 
    TimeToString(
        DWORD *ptime, 
        CString& rString
    );

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

private:
    CAllServers * m_pAllServers;
    CWinThread *m_pBackgroundThread;
    CCriticalSection m_AllServersCriticalSection;
    NODETYPE m_NodeType;
protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CLicMgrDoc)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LICMGRDOC_H__72451C71_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\lsprop.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// LSProp.cpp : implementation file
//

#include "stdafx.h"
#include "LicMgr.h"
#include "LSProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicensePropertypage property page

IMPLEMENT_DYNCREATE(CLicensePropertypage, CPropertyPage)

CLicensePropertypage::CLicensePropertypage() : CPropertyPage(CLicensePropertypage::IDD)
{
    //{{AFX_DATA_INIT(CLicensePropertypage)
    m_ExpiryDate = _T("");
    m_IssueDate = _T("");
    m_LicenseStatus = _T("");
    m_MachineName = _T("");
    m_UserName = _T("");
    //}}AFX_DATA_INIT
}

CLicensePropertypage::~CLicensePropertypage()
{
}

void CLicensePropertypage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLicensePropertypage)
    DDX_Text(pDX, IDC_EXPIRY_DATE, m_ExpiryDate);
    DDX_Text(pDX, IDC_ISSUE_DATE, m_IssueDate);
    DDX_Text(pDX, IDC_LICENSE_STATUS, m_LicenseStatus);
    DDX_Text(pDX, IDC_MACHINE_NAME, m_MachineName);
    DDX_Text(pDX, IDC_USER_NAME, m_UserName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLicensePropertypage, CPropertyPage)
    //{{AFX_MSG_MAP(CLicensePropertypage)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicensePropertypage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\lsprop.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#if !defined(AFX_LICENSEPROPERTYPAGE_H__00F79DCE_8DDF_11D1_8AD7_00C04FB6CBB5__INCLUDED_)
#define AFX_LICENSEPROPERTYPAGE_H__00F79DCE_8DDF_11D1_8AD7_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000
// LSProp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLicensePropertypage dialog

class CLicensePropertypage : public CPropertyPage
{
    DECLARE_DYNCREATE(CLicensePropertypage)

// Construction
public:
    CLicensePropertypage();
    ~CLicensePropertypage();

// Dialog Data
    //{{AFX_DATA(CLicensePropertypage)
    enum { IDD = IDD_LICENSE_PROPERTYPAGE };
    CString    m_ExpiryDate;
    CString    m_IssueDate;
    CString    m_LicenseStatus;
    CString    m_MachineName;
    CString    m_UserName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CLicensePropertypage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CLicensePropertypage)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLicensePropertypage_H__00F79DCE_8DDF_11D1_8AD7_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\lsserver.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LsServer.cpp

Abstract:
    
    This Module contains the implementation of CKeyPack, CLicense,
    CLicServer, CAllServers classes

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include <stdafx.h>
#include "resource.h"
#include "defines.h"
#include "LSServer.h"

///////////////////////////////////////////////////////////
int GetStatusPosition( CLicense *pLic );

CKeyPack::CKeyPack(
    LSKeyPack &KeyPack
    )
/*++


--*/
{
    m_hTreeItem = NULL;
    m_bIsExpanded = FALSE;
    m_pLicServer = NULL;
    m_KeyPack = KeyPack;
    return;
}

//---------------------------------------------------------
CKeyPack::~CKeyPack()
{
    PurgeCache();
}

//---------------------------------------------------------
void 
CKeyPack::AddIssuedLicense(
    CLicense * pIssuedLicense
    )
/*++

--*/
{
    if(NULL == pIssuedLicense)
    {
        return;
    }

    CString MachineName = pIssuedLicense->GetLicenseStruct().szMachineName;
    if(MachineName.IsEmpty())
    {
        MachineName.LoadString(IDS_UNKNOWN);
        lstrcpy(pIssuedLicense->GetLicenseStruct().szMachineName,(LPCTSTR)MachineName);
    }

    pIssuedLicense->SetKeyPack(this);
    m_IssuedLicenseList.AddTail(pIssuedLicense);

    return;
}

//---------------------------------------------------------
void
CKeyPack::PurgeCache()
{
    CLicense *pLicense = NULL;

    POSITION pos = m_IssuedLicenseList.GetHeadPosition();
    while(pos)
    {
        pLicense = (CLicense *)m_IssuedLicenseList.GetNext(pos);
        ASSERT(pLicense);
        if(pLicense)
        {
            delete pLicense;
            pLicense = NULL;
        }
    }

    m_IssuedLicenseList.RemoveAll();

    m_bIsExpanded = FALSE;
}

//---------------------------------------------------------
HRESULT
CKeyPack::RefreshIssuedLicenses(
    LSLicense* pLicenses, /* = NULL */
    DWORD dwFreshParm,  /* = 0 */
    BOOL bMatchAll /* = FALSE */
    )
/*++

    None of the parameter is supported yet.

--*/
{
    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    DWORD status = ERROR_SUCCESS;
    LSLicenseEx  sLicense;
    CString Server;
    CLicServer *pServer = GetServer();
    HRESULT hResult = S_OK;

    ASSERT(pServer);
    if(NULL == pServer)
    {
        return E_FAIL;
    }

    PurgeCache();
   
    hBinding = pServer->GetContext();
    if(NULL == hBinding)
    {
        if(pServer->UseIpAddress())
        {
            Server = pServer->GetIpAddress();
        }
        else
        {
            Server = pServer->GetName();
        }

        hBinding = ConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }

    status = LSKeyPackEnumBegin(
                            hBinding,
                            LSKEYPACK_EXSEARCH_DWINTERNAL,
                            FALSE,
                            &m_KeyPack
                        );

    if(status != ERROR_SUCCESS)
    {
        hResult = status;
        goto cleanup;
    }

    status = LSKeyPackEnumNext(
                            hBinding,
                            &m_KeyPack
                        );

    LSKeyPackEnumEnd(hBinding);

    if(status != ERROR_SUCCESS)
    {
        hResult = status;
        goto cleanup;
    }    
   
    memset(&sLicense, 0, sizeof(LSLicenseEx));

    sLicense.dwKeyPackId = m_KeyPack.dwKeyPackId;
    TLSLicenseEnumBegin( 
                            hBinding, 
                            LSLICENSE_SEARCH_KEYPACKID,
                            FALSE,
                            (LPLSLicenseSearchParm)&sLicense,
                            &status
                        );

    if(status != ERROR_SUCCESS)
    { 
        hResult = status;
        goto cleanup;
    }
 
    do {
        memset(&sLicense, 0, sizeof(LSLicenseEx));
        TLSLicenseEnumNextEx(
                                hBinding,
                                &sLicense,
                                &status
                            );

        if(status == ERROR_SUCCESS)
        {    
            CLicense * pLicense = new CLicense(sLicense);
            if(NULL == pLicense)
            {
                hResult = E_OUTOFMEMORY;
                goto cleanup;
            }
    
            AddIssuedLicense(pLicense);
        }
    } while(status == ERROR_SUCCESS);

    TLSLicenseEnumEnd(hBinding, &status);
    
    m_bIsExpanded = TRUE;

cleanup:

    //put cleanup code here
    if(hBinding)
    {
        LSDisconnect(&hBinding);
    }

    return hResult;
}

////////////////////////////////////////////////////////////

void 
CLicServer::AddKeyPack(
    CKeyPack* pKeyPack
    )
/*++

--*/
{
    if(NULL == pKeyPack)
        return;
    CString DisplayName;
  //  CString For;
 //   CString Platform;
    LSKeyPack &sKeypack = pKeyPack->GetKeyPackStruct();
  /*  if(LSKEYPACKTYPE_TEMPORARY == sKeypack.ucKeyPackType)
        DisplayName.LoadString(IDS_TEMPORARY);
    else*/
    DisplayName = sKeypack.szProductDesc;   
  //  For.LoadString(IDS_FOR);
   // Platform.LoadString(IDS_PLATFORM1 + sKeypack.dwPlatformType - PLATFORM_WINNT_40);
  //  DisplayName = DisplayName + _T(" ");
  //  DisplayName = DisplayName + For;
  //  DisplayName = DisplayName + _T(" ");
  //  DisplayName = DisplayName + Platform;
    pKeyPack->SetDisplayName(DisplayName);
    m_KeyPackList.AddTail(pKeyPack);
    pKeyPack->SetServer(this);
    return;
}

///////////////////////////////////////////////////////////
CLicense::CLicense(LSLicenseEx &License)
{
    m_pKeyPack = NULL;
    m_License = License;
    return;
}

//---------------------------------------------------------
CLicense::~CLicense()
{
}

///////////////////////////////////////////////////////////
CLicServer::CLicServer(
    CString& Name,
    SERVER_TYPE ServerType, 
    CString& Scope,
    CString& IpAddress,
    PCONTEXT_HANDLE hBinding
    )
/*++


--*/
{
    m_ServerName = Name;
    m_ServerScope = Scope;
    m_IpAddress = IpAddress;

    if(!m_IpAddress.IsEmpty())
    {
        m_bUseIpAddress = TRUE;
    }
    else
    {
        m_bUseIpAddress = FALSE;
    }

	m_ServerType = ServerType;
	if(ServerType == SERVER_TS4)
	{
	   CString Temp;
	   Temp.LoadString(IDS_TS4);
	   m_DisplayName = m_ServerName + L" (" + Temp + L") ";
	}
	else
	{
		m_DisplayName = m_ServerName;
	}

    m_hTreeItem = NULL;
    m_hContext = hBinding;
    m_bIsExpanded = FALSE;
    m_dwRegStatus = ( DWORD )-1;

    m_bAdmin = FALSE;
    m_fDownloadedLicenses = FALSE;

    m_wizcon = ( WIZCONNECTION )-1;
}    

///////////////////////////////////////////////////////////
void 
CAllServers::AddLicServer(
    CLicServer* pLicServer
    )
/*++

--*/
{
    if(NULL == pLicServer)
    {
        return;
    }

    m_LicServerList.AddTail(pLicServer);

    return;
}

//---------------------------------------------------------
CAllServers::CAllServers(
    CString Name
    )
/*++

--*/
{
    m_hTreeItem = NULL;
    if(Name.IsEmpty())
        m_Name.LoadString(IDS_TREEROOT);
    else
        m_Name = Name;
    return;
};

CAllServers::~CAllServers()
{
   CLicServer *pServer = NULL;
   POSITION pos = m_LicServerList.GetHeadPosition();
   while(pos)
   {
        pServer = (CLicServer *)m_LicServerList.GetNext(pos);
        ASSERT(pServer);
        if(pServer)
        {
            delete pServer;
            pServer = NULL;
        }
    }
   m_LicServerList.RemoveAll();
}

PCONTEXT_HANDLE CLicServer::GetContext()
{
    return m_hContext;

}

void CLicServer::SetContext(PCONTEXT_HANDLE hContext)
{
    m_hContext = hContext;
}


CLicServer::~CLicServer()
{
    PurgeCache();
}


void
CLicServer::PurgeCache()
{
    CKeyPack *pKeyPack = NULL;
    POSITION pos = m_KeyPackList.GetHeadPosition();
    while(pos)
    {
        pKeyPack = (CKeyPack *)m_KeyPackList.GetNext(pos);
        ASSERT(pKeyPack);
        if(pKeyPack)
        {
            delete pKeyPack;
            pKeyPack = NULL;
        }
   
    }

    m_KeyPackList.RemoveAll();
    m_bIsExpanded = FALSE;
}

//-------------------------------------------------------------
HRESULT
CLicServer::RefreshCachedKeyPack()
/*++


--*/    
{
    HRESULT hResult = S_OK;

    PCONTEXT_HANDLE hBinding = NULL;
    BOOL bContext = FALSE;
    POSITION pos;
    CKeyPack *pKeyPack;
     
    CString Server;
    hBinding = GetContext();

    if(NULL == hBinding)
    {
        if(UseIpAddress())
        {
            Server = GetIpAddress();
        }
        else
        {
            Server = GetName();
        }

        hBinding = ConnectToLsServer(Server.GetBuffer(Server.GetLength()));
        if(hBinding == NULL)
        {
            hResult = CONNECTION_FAILED;
            goto cleanup;
        }
    }

    //
    // Code has too many other dependencies so 
    // we only refresh licenses issued
    //
    pKeyPack = NULL;
    pos = m_KeyPackList.GetHeadPosition();

    while(pos)
    {
        pKeyPack = (CKeyPack *)m_KeyPackList.GetNext(pos);
        ASSERT(pKeyPack);
        if(pKeyPack)
        {
            pKeyPack->RefreshIssuedLicenses();
        }
    }

cleanup:

    //put cleanup code here. 
    if(hBinding)
    {
        LSDisconnect(&hBinding);
    }
        
    return hResult;
}


//-----------------------------------------------------------------------------------------
// returns the license status position.
// used for sorting licenses by status.
//-----------------------------------------------------------------------------------------
int GetStatusPosition( CLicense *pLic )
{
    int val;

    ASSERT( pLic != NULL );

    switch( pLic->GetLicenseStruct().ucLicenseStatus )
    {
        case LSLICENSE_STATUS_ACTIVE:
        //case LSLICENSE_STATUS_PENDING_ACTIVE:
        case LSLICENSE_STATUS_CONCURRENT:
            
            val = 0;
            
            break;

        //case LSLICENSE_STATUS_REVOKE:
        //case LSLICENSE_STATUS_REVOKE_PENDING:
            
        //    val = 1;
            
        //    break;

        case LSLICENSE_STATUS_TEMPORARY:
            
            val = 2;

            break;

        case LSLICENSE_STATUS_UNKNOWN:

            val = 3;

            break;

        case LSLICENSE_STATUS_UPGRADED:

            val = 4;
    }

    return val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\ltview.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	LtView.h 

Abstract:
    
    This Module define the CLicMgrLeftView class( The view class used for the left pane in 
    the splitter window.

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/


#if !defined(AFX_LICMGRLEFTVIEW_H__72451C73_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_LICMGRLEFTVIEW_H__72451C73_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#include "lrwizapi.h"

class CLicServer;
class CLicMgrLeftView : public CTreeView
{
protected: // create from serialization only
    CLicMgrLeftView();
    DECLARE_DYNCREATE(CLicMgrLeftView)

// Attributes
public:
    CLicMgrDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLicMgrLeftView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
	void SetSelection(LPARAM lParam,NODETYPE NodeType);
    
    CImageList m_ImageList;
    HTREEITEM AddItemToTree(HTREEITEM hParent, CString szText, HTREEITEM hInsAfter, int iImage, LPARAM lParam);
    virtual ~CLicMgrLeftView();
    void AddServerKeyPacks(CLicServer *pServer);
    int AddIconToImageList(int iconID);
    void BuildImageList();
    void UI_initmenu( CMenu *pMenu , NODETYPE nt );

    void OnServerConnect( );
    void OnRefreshAllServers( );
    void OnRefreshServer( );

    void SetRightClickedItem( HTREEITEM ht );

    
    HTREEITEM GetRightClickedItem( )
    {
        return m_ht;
    }

    DWORD WizardActionOnServer( WIZACTION wa , PBOOL );
    
    void OnDownloadKeepPack();
    void OnRegisterServer();
    void OnRepeatLastDownload();
    void OnReactivateServer( );
    void OnDeactivateServer( );

    void OnServerProperties( );
    void OnGeneralHelp( );
    void SetActiveServer( CLicServer * );


#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

private:

    HTREEITEM m_ht;
    
// Generated message map functions
protected:
    //{{AFX_MSG(CLicMgrLeftView)
    afx_msg LRESULT OnAddServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDeleteServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnUpdateServer(WPARAM wParam, LPARAM lParam);
    afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnProperties();
    afx_msg LRESULT OnAddAllServers(WPARAM wParam, LPARAM lParam);
    afx_msg void OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnAddNewKeyPack();
    afx_msg LRESULT OnAddKeyPack(WPARAM wParam, LPARAM lParam);
    afx_msg void OnDestroy();
	afx_msg void OnKeydown(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRightClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnLeftClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint pt );
    
    

	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LicMgrLeftView.cpp
inline CLicMgrDoc* CLicMgrLeftView::GetDocument()
   { return (CLicMgrDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LICMGRLEFTVIEW_H__72451C73_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\ltview.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
  
Module Name:

    LtView.cpp

Abstract:
    
    This Module contains the implementation of CLicMgrLeftView class
    (The View class used for the Left pane of the splitter)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/
#include "stdafx.h"
#include "LicMgr.h"
#include "defines.h"
#include "LSMgrDoc.h"
#include "LtView.h"
#include "TreeNode.h"
#include "LSServer.h"
#include "mainfrm.h"
#include "addkp.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView

IMPLEMENT_DYNCREATE(CLicMgrLeftView, CTreeView)

BEGIN_MESSAGE_MAP(CLicMgrLeftView, CTreeView)
    //{{AFX_MSG_MAP(CLicMgrLeftView)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemexpanding)
    ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnKeydown)
    ON_NOTIFY_REFLECT(NM_RCLICK , OnRightClick )
    ON_NOTIFY_REFLECT(NM_CLICK , OnLeftClick )
    ON_COMMAND(ID_ADD_LICENSES, OnAddNewKeyPack)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CTreeView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CTreeView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CTreeView::OnFilePrintPreview)
    ON_MESSAGE(WM_ADD_SERVER, OnAddServer)
    ON_MESSAGE(WM_DELETE_SERVER, OnDeleteServer)
    ON_MESSAGE(WM_UPDATE_SERVER, OnUpdateServer)
    ON_MESSAGE(WM_ADD_ALL_SERVERS, OnAddAllServers)
    ON_MESSAGE(WM_ADD_KEYPACK, OnAddKeyPack)

    
    // all server menus
    ON_WM_CONTEXTMENU( )

    ON_COMMAND( ID_ALLSVR_CONNECT , OnServerConnect )
    ON_COMMAND( ID_ALLSVR_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_ALLSVR_HELP , OnGeneralHelp )
    
    // server menuitems

    // ON_COMMAND( ID_LPK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LPK_REFRESH , OnRefreshServer )
    ON_COMMAND( ID_LPK_REFRESHALL , OnRefreshAllServers )    
    ON_COMMAND( ID_LPK_DOWNLOADLICENSES , OnDownloadKeepPack )

    ON_COMMAND( ID_SVR_ACTIVATESERVER , OnRegisterServer )
    ON_COMMAND( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LPK_ADVANCED_REACTIVATESERVER , OnReactivateServer )
    ON_COMMAND( ID_LPK_ADVANCED_DEACTIVATESERVER , OnDeactivateServer )    
    ON_COMMAND( ID_LPK_PROPERTIES , OnServerProperties )
    ON_COMMAND( ID_LPK_HELP , OnGeneralHelp )

    // license pak items

    // ON_COMMAND( ID_LICPAK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LICPAK_REFRESH , OnRefreshServer )
    // ON_COMMAND( ID_LICPAK_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_LICPAK_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_LICPAK_REPEATDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LICPAK_HELP , OnGeneralHelp )    


    
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView construction/destruction

CLicMgrLeftView::CLicMgrLeftView()
{
    // TODO: add construction code here
   
    m_ht = ( HTREEITEM )NULL;
}

CLicMgrLeftView::~CLicMgrLeftView()
{
 }

BOOL CLicMgrLeftView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView drawing

void CLicMgrLeftView::OnDraw(CDC* pDC)
{
    CLicMgrDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    // TODO: add draw code for native data here
}

void CLicMgrLeftView::OnInitialUpdate()
{
    CTreeView::OnInitialUpdate();
    GetTreeCtrl().ModifyStyle(0,TVS_HASLINES|TVS_LINESATROOT|TVS_HASBUTTONS|TVS_SHOWSELALWAYS);
    BuildImageList();
       
    // TODO: You may populate your TreeView with items by directly accessing
    //  its tree control through a call to GetTreeCtrl().
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView printing

BOOL CLicMgrLeftView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CLicMgrLeftView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CLicMgrLeftView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView diagnostics

#ifdef _DEBUG
void CLicMgrLeftView::AssertValid() const
{
    CTreeView::AssertValid();
}

void CLicMgrLeftView::Dump(CDumpContext& dc) const
{
    CTreeView::Dump(dc);
}

CLicMgrDoc* CLicMgrLeftView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CLicMgrDoc)));
    return (CLicMgrDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLicMgrLeftView message handlers

HTREEITEM CLicMgrLeftView::AddItemToTree(HTREEITEM hParent, CString Text, HTREEITEM hInsAfter, int iImage, LPARAM lParam)
{
    HTREEITEM hItem = NULL;
    TV_ITEM tvItem = {0};
    TV_INSERTSTRUCT tvInsert;

    ASSERT(lParam);
    if(NULL == lParam)
        return hItem;

    tvItem.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvItem.pszText        = Text.GetBuffer(Text.GetLength());
    tvItem.cchTextMax     = Text.GetLength();
    tvItem.iImage         = iImage;
    tvItem.iSelectedImage = iImage;
    tvItem.lParam          = lParam;

    tvInsert.item         = tvItem;
    tvInsert.hInsertAfter = hInsAfter;
    tvInsert.hParent      = hParent;

    hItem = GetTreeCtrl().InsertItem(&tvInsert);

   // GetTreeCtrl().Expand(GetTreeCtrl().GetRootItem(), TVE_EXPAND);
    return hItem;


}

LRESULT CLicMgrLeftView::OnAddServer(WPARAM wParam, LPARAM lParam)
{   
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;
    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

    HTREEITEM hServer = NULL;
    HTREEITEM hItem = NULL;
    CTreeNode* pNode = NULL;

    HTREEITEM hRoot = GetTreeCtrl().GetRootItem();
    if(!hRoot)
        goto cleanup;

    // First make sure the server isn't already in the tree
    // Get the first server under the domain
    hItem = GetTreeCtrl().GetNextItem(hRoot, TVGN_CHILD);
    while(hItem) {
        // Get the data attached to the tree item
        CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hItem);
        if(node) {
            // Is this the server we want to add
            CLicServer *pServer = (CLicServer*)node->GetTreeObject();
            if(pServer == (CLicServer*)lParam) return 0;
        }
        hItem = GetTreeCtrl().GetNextItem(hItem, TVGN_NEXT);
    }

    // Add the server to the tree
    // Create a CTreeNode object with info about this tree node
    pNode = new CTreeNode(NODE_SERVER, pServer);
    if(pNode) 
    {
        int iImage = 0;

        if( pServer->GetServerType()  == SERVER_TS5_ENFORCED )
        {
            DWORD dwStatus = pServer->GetServerRegistrationStatus();
        
            if( dwStatus == LSERVERSTATUS_REGISTER_INTERNET || dwStatus == LSERVERSTATUS_REGISTER_OTHER )
            {
                iImage = 3;
            }
            else if( dwStatus == LSERVERSTATUS_WAITFORPIN )
            { 
                iImage = 4;
            }
            else if( dwStatus == LSERVERSTATUS_UNREGISTER ) 
            {
                iImage = 5;
            }
            else
            {
                iImage = 6;
            }
        }
        
        hServer = AddItemToTree(hRoot, pServer->GetDisplayName(), TVI_SORT,  iImage , (LPARAM)pNode);
        if(!hServer) delete pNode;
        // The server wants to know his tree item handle
        pServer->SetTreeItem(hServer);
    }

cleanup:
    return lResult;                                                                  
                                                                               
} // OnAddServer


LRESULT CLicMgrLeftView::OnAddKeyPack(WPARAM wParam, LPARAM lParam)
{   
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    CLicServer *pServer = (CLicServer*)wParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

    CKeyPack *pKeyPack = (CKeyPack*)lParam;
    ASSERT(pKeyPack);
    if(NULL == pKeyPack)
        return lResult;

    HTREEITEM hKeyPackItem = NULL;
    TV_ITEM Item;
    memset((void *)&Item,0,sizeof(Item));

    Item.mask = TVIF_HANDLE;
    HTREEITEM hServer = pServer->GetTreeItem();
    if(NULL == hServer)
        return lResult;
    Item.hItem = hServer;



    if(FALSE == GetTreeCtrl().GetItem(&Item))
        return lResult;

    if(Item.state & TVIS_EXPANDED)
    {
        CTreeNode *pNode = new CTreeNode(NODE_KEYPACK, pKeyPack);
        if(pNode)
        {
            hKeyPackItem = AddItemToTree(hServer, (LPCTSTR)pKeyPack->GetDisplayName(), hServer, 2, (LPARAM)pNode);
            if(!hKeyPackItem)
                delete pNode;
        }
        pKeyPack->SetTreeItem(hKeyPackItem);
    }
    
    return lResult;                                                                  
                                                                               
} // OnAddKeyPack




LRESULT CLicMgrLeftView::OnAddAllServers(WPARAM wParam, LPARAM lParam)
{   
    LRESULT lResult = 0;
    HTREEITEM hItem = NULL;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;
    CTreeNode* pNode = NULL;
    CAllServers *pAllServer = (CAllServers*)lParam;
    if(!pAllServer) 
        goto cleanup ;
   
    hItem = pAllServer->GetTreeItem();
    if(NULL != hItem)
        goto cleanup;

       
    // Create a CTreeNode object with info about this tree node
    pNode = new CTreeNode(NODE_ALL_SERVERS, pAllServer);
    if(pNode) 
    {
        HTREEITEM hAllServers = AddItemToTree(NULL, pAllServer->GetName(), TVI_SORT,0 , (LPARAM)pNode);
        if(!hAllServers) delete pNode;
        // The server wants to know his tree item handle
        pAllServer->SetTreeItem(hAllServers);
        //Set the Selection to this item
        GetTreeCtrl().SelectItem(hAllServers);
    }

    
    GetTreeCtrl().Expand(GetTreeCtrl().GetRootItem(), TVE_EXPAND);
cleanup:
    return lResult ;                                                                  
                                                                               
} // OnAddAllServers


void CLicMgrLeftView::AddServerKeyPacks(CLicServer *pServer)
{
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;
    POSITION pos;
    KeyPackList *pKeyPackList = NULL;
    HTREEITEM hLastNode = NULL;

   ASSERT(pServer);
   if(NULL == pServer)
      return;
   HTREEITEM hServer = pServer->GetTreeItem();
   if(NULL == hServer)
       goto cleanup;          //Server Not in the Tree.

   hLastNode= hServer;

   // Get a pointer to the server's list of installed KeyPacks
   pKeyPackList = pServer->GetKeyPackList();
   // Iterate through the KeyPack list
   pos = pKeyPackList->GetHeadPosition();
   while(pos)
   {
        CKeyPack *pKeyPack = (CKeyPack *)pKeyPackList->GetNext(pos);
        CTreeNode *pNode = new CTreeNode(NODE_KEYPACK, pKeyPack);
        if(pNode)
        {
            hLastNode = AddItemToTree(hServer, (LPCTSTR)pKeyPack->GetDisplayName(), hLastNode, 2, (LPARAM)pNode);
            if(!hLastNode)
                delete pNode;
        }
        pKeyPack->SetTreeItem(hLastNode);
   }
cleanup:
   return;

}  // end AddKeyPacks

void CLicMgrLeftView::BuildImageList()
{
    m_ImageList.Create(16, 16, TRUE, 18, 0);
    AddIconToImageList(IDI_ALL_SERVERS);
    AddIconToImageList(IDI_SERVER);
    AddIconToImageList(IDI_KEYPACK);
    AddIconToImageList(IDI_SERVERREG );
    AddIconToImageList(IDI_SERVERM );
    AddIconToImageList(IDI_SERVERX );
    AddIconToImageList(IDI_SERVERQ );

    GetTreeCtrl().SetImageList(&m_ImageList, TVSIL_NORMAL);

}  // end BuildImageList

int CLicMgrLeftView::AddIconToImageList(int iconID)
{
    HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
       return m_ImageList.Add(hIcon);
   

}  

void CLicMgrLeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    // TODO: Add your control notification handler code here

    //Check if the node selected is All-Servers,Server or the KeyPack.
    //Accordingly change the right pane view.
    CTreeCtrl& TreeCtrl = GetTreeCtrl();
    HTREEITEM hCurr = TreeCtrl.GetSelectedItem();
    if(NULL == hCurr)
    {
        return;
    }
    CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(hCurr);
    if(NULL == pNode)
    {
        return;
    }
    CLicServer *pLicServer = NULL;
    CKeyPack * pKeyPack = NULL;

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;

    switch(pNode->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            AfxGetMainWnd()->SendMessage(WM_SEL_CHANGE,NODE_ALL_SERVERS,NULL);
            break;
        case NODE_SERVER:
            pLicServer = (CLicServer *)pNode->GetTreeObject();
            if(NULL == pLicServer)
                break;
            if(FALSE == pLicServer->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateKeyPacks(pLicServer,LSKEYPACK_SEARCH_LANGID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pLicServer);
                    if(pLicServer && pLicServer->GetTreeItem())
                    {
                        TreeCtrl.SelectItem(TreeCtrl.GetParentItem(pLicServer->GetTreeItem()));
                    }
                    break;
                }
                AddServerKeyPacks(pLicServer);
               
            }
            else
            {
                if(!pLicServer->GetKeyPackList()->IsEmpty())
                {
                    if(!TreeCtrl.ItemHasChildren(hCurr))
                        AddServerKeyPacks(pLicServer);
                }

            }
            AfxGetMainWnd()->SendMessage(WM_SEL_CHANGE,NODE_SERVER,(LPARAM)pLicServer);
            break;
        case NODE_KEYPACK:
            pKeyPack = (CKeyPack *)pNode->GetTreeObject();
            ASSERT(pKeyPack);
            if(NULL == pKeyPack)
                break;
            if(FALSE == pKeyPack->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateLicenses(pKeyPack,LSLICENSE_SEARCH_KEYPACKID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pKeyPack->GetServer());
                    if(pKeyPack && pKeyPack->GetTreeItem())
                    {
                        TreeCtrl.SelectItem(TreeCtrl.GetParentItem(pKeyPack->GetTreeItem()));
                    }
                    break;
                }
                          
            }
            AfxGetMainWnd()->SendMessage(WM_SEL_CHANGE,NODE_KEYPACK,(LPARAM)pNode->GetTreeObject());
            break;
    }
    *pResult = 0;
}

void CLicMgrLeftView::OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    // TODO: Add your control notification handler code here
    
    *pResult = 0;
}

void CLicMgrLeftView::OnAddNewKeyPack() 
{
    // TODO: Add your command handler code here
    HTREEITEM hTreeItem = GetTreeCtrl().GetSelectedItem();
   // CAddKeyPack KeyPack;
    if(NULL == hTreeItem)
        return;
    CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(hTreeItem);
    if(NULL == pNode)
        return;
    if(NODE_SERVER == pNode->GetNodeType())
        ((CMainFrame *)AfxGetMainWnd())->AddKeyPackDialog((PLICSERVER)pNode->GetTreeObject());
    else
    {
        if(NODE_KEYPACK == pNode->GetNodeType())
        {
            CKeyPack * pKeyPack = (CKeyPack *)pNode->GetTreeObject();
            if(NULL == pKeyPack)
                return;
            ((CMainFrame *)AfxGetMainWnd())->AddKeyPackDialog(pKeyPack->GetServer());
        }
    }
        
   return;
}

void CLicMgrLeftView::OnDestroy() 
{
    //Get the Root Item
    HTREEITEM hRoot = GetTreeCtrl().GetRootItem();
    if(!hRoot)
        return;
    HTREEITEM hServerItem = GetTreeCtrl().GetNextItem(hRoot,TVGN_CHILD);
    while(hServerItem)
    {
        // Get the data attached to the tree item 
        CTreeNode *pServerNode = (CTreeNode*)GetTreeCtrl().GetItemData(hServerItem);
        if(pServerNode)
        {
            // Is this the server we want to add
            HTREEITEM hKeyPackItem = GetTreeCtrl().GetNextItem(hServerItem,TVGN_CHILD);
            while(hKeyPackItem)
            {
                CTreeNode *pKeyPackNode = (CTreeNode*)GetTreeCtrl().GetItemData(hKeyPackItem);
                if(pKeyPackNode)
                    delete pKeyPackNode;
                hKeyPackItem = GetTreeCtrl().GetNextItem(hKeyPackItem,TVGN_NEXT);
            }
            delete pServerNode;
           
        }
        hServerItem = GetTreeCtrl().GetNextItem(hServerItem, TVGN_NEXT);
    }
    CTreeNode * pRootNode = (CTreeNode*)GetTreeCtrl().GetItemData(hRoot);
    if(pRootNode)
        delete pRootNode;

    return;
}

LRESULT CLicMgrLeftView::OnDeleteServer(WPARAM wParam, LPARAM lParam)
{   
    
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;
    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

   
    HTREEITEM hServer = pServer->GetTreeItem();

    DBGMSG( L"CLicMgrLeftView_OnDeleteServer GetTreeItem ret 0x%x\n" , hServer );

    if(hServer == NULL)
        return lResult;

    CTreeNode *pNode = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);

    DBGMSG( L"CLicMgrLeftView_OnDeleteServer GetItemData ret 0x%x\n" , pNode );
    
    if(pNode)
        delete pNode;   

    GetTreeCtrl().DeleteItem(hServer);    
    

    return lResult;                                                                  
                                                                               
} // OnDeleteServer

LRESULT CLicMgrLeftView::OnUpdateServer(WPARAM wParam, LPARAM lParam)
{   
    
    LRESULT lResult = 0;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    BOOL bIsExpanded = FALSE;
    BOOL bIsSelected = FALSE;
    BOOL bIsChild = FALSE;
    HTREEITEM hSelectedItem = NULL;
    CKeyPack * pSelectedPack = NULL;

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;

   
    HTREEITEM hServer = pServer->GetTreeItem();
    if(hServer == NULL)
        return lResult;

    // check to see if we need to remove any keypacks
    // Get a pointer to the server's list of installed KeyPacks
    // Get the data attached to the tree item 
    CTreeNode *pServerNode = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);

    if( pServerNode != NULL )
    {        
        HTREEITEM hKeyPackItem = GetTreeCtrl().GetNextItem(hServer,TVGN_CHILD);
        while( hKeyPackItem != NULL )
        {
            CTreeNode *pKeyPackNode = (CTreeNode*)GetTreeCtrl().GetItemData(hKeyPackItem);

            if( pKeyPackNode != NULL )
            {
                DBGMSG( L"CLicMgrLeftView!OnUpdateServer removing a licpak\n" , 0 );
                delete pKeyPackNode;
            }

            hKeyPackItem = GetTreeCtrl().GetNextItem(hKeyPackItem,TVGN_NEXT);
        }

        delete pServerNode;
    }

    TV_ITEM Item;
    memset((void *)&Item,0,sizeof(Item));

    Item.mask = TVIF_HANDLE | TVIF_STATE;
    Item.hItem = hServer;

    if(FALSE == GetTreeCtrl().GetItem(&Item))
        return lResult;

    if(Item.state & TVIS_EXPANDED)
        bIsExpanded = TRUE;

    if(Item.state & TVIS_SELECTED)
        bIsSelected = TRUE;
    else
        hSelectedItem = GetTreeCtrl().GetSelectedItem();
    if(hSelectedItem)
    {
        if(hServer == GetTreeCtrl().GetParentItem(hSelectedItem))
        {
            CString ProdDesc = GetTreeCtrl().GetItemText(hSelectedItem);
            KeyPackList * pkeyPackList = pServer->GetKeyPackList();
            POSITION pos = pkeyPackList->GetHeadPosition();
            while(pos)
            {
                CKeyPack * pKeyPack = (CKeyPack *)pkeyPackList->GetNext(pos);
                if(NULL == pKeyPack)
                {
                   continue;
                }
                LSKeyPack sKeyPack = pKeyPack->GetKeyPackStruct();
        
                if(0 == ProdDesc.CompareNoCase(sKeyPack.szProductDesc))
                {
                   pSelectedPack = pKeyPack;
                   break;
                }
            }
           bIsChild = TRUE;
        }
    }

    GetTreeCtrl().DeleteItem(hServer);
    SendMessage(WM_ADD_SERVER,0,(LPARAM)pServer);
    AddServerKeyPacks(pServer);

    hServer = pServer->GetTreeItem();

    if(bIsExpanded)
        GetTreeCtrl().Expand(hServer, TVE_EXPAND);
    if(bIsSelected)
        GetTreeCtrl().SelectItem(hServer);
    else
    {
        //Not good, find an alternative for this....
        if(bIsChild)
        {
            if(pSelectedPack)
                GetTreeCtrl().SelectItem(pSelectedPack->GetTreeItem());
            else
            {
                hSelectedItem = GetTreeCtrl().GetChildItem(hServer);
                if(hSelectedItem)
                    GetTreeCtrl().SelectItem(hSelectedItem);
            }            
        }
    }

    return lResult;                                                                  
                                                                               
} // OnUpdateServer






void CLicMgrLeftView::SetSelection(LPARAM lParam,NODETYPE NodeType)
{
    if(NULL == lParam)
        return;
   
    HTREEITEM hItem = NULL;


    if(NODE_ALL_SERVERS == NodeType)
        hItem = ((CAllServers *)lParam)->GetTreeItem();
    else if(NODE_SERVER == NodeType)
        hItem = ((CLicServer *)lParam)->GetTreeItem();
    else if(NODE_KEYPACK == NodeType)
        hItem = ((CKeyPack *)lParam)->GetTreeItem();

    if(hItem)
            GetTreeCtrl().SelectItem(hItem);

    return;

}

void CLicMgrLeftView::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LV_KEYDOWN* pLVKeyDown = (LV_KEYDOWN*)pNMHDR;
    // TODO: Add your control notification handler code here
    if(pLVKeyDown->wVKey == VK_TAB)
    {
        CMainFrame * pMainFrame  = ((CMainFrame *)AfxGetMainWnd());
        pMainFrame->SelectView(LISTVIEW);
    }

    
    *pResult = 0;
}


//-----------------------------------------------------------------------------------------
afx_msg void CLicMgrLeftView::OnLeftClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    CPoint pt;
    
    GetCursorPos( &pt );

    ScreenToClient( &pt );

    DBGMSG( L"LICMGR@CLicMgrLeftView::OnLeftClick\n" , 0 );

    HTREEITEM hTreeItem = GetTreeCtrl( ).GetSelectedItem( ); //GetTreeCtrl().HitTest( pt , &flag ); 

    if( hTreeItem != NULL )
    { 
        CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(hTreeItem);       
        
        if(NULL == pNode)
        {
            return;
        }

        ClientToScreen( &pt );

        NODETYPE nt = pNode->GetNodeType();

        if(NODE_SERVER == nt )
        {
            DBGMSG( L"\tServer Node selected\n", 0  );

            SetActiveServer( static_cast< CLicServer * >( pNode->GetTreeObject() ) );

        }
        else if( nt == NODE_KEYPACK )
        {
            CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

            if( pKeyPack != NULL )
            {
                SetActiveServer( pKeyPack->GetServer( ) );
            }
        }        
        else
        {
#ifdef DBG
            if( NODE_ALL_SERVERS == nt )
            {
                DBGMSG( L"\tAll servers selected\n" , 0 );    
            }
#endif
            
            SetActiveServer( NULL );
        }
    }
    else
    {
        DBGMSG( L"\tTreeview item returned NULL\n" , 0 );

        SetActiveServer( NULL );
    }


}

//-----------------------------------------------------------------------------------------
afx_msg void CLicMgrLeftView::OnContextMenu( CWnd* pWnd, CPoint pt )
{
    CMenu menu;

    CMenu *pContextmenu = NULL;
        
    DBGMSG( L"LICMGR@CLicMgrLeftView::OnContextMenu\n" , 0 );
        
    DBGMSG( L"\tpoint x = %d " , pt.x );
    
    DBGMSG( L"y = %d\n" , pt.y );

    UINT flag;    

    HTREEITEM hTreeItem;
    
    CTreeCtrl& treectrl = GetTreeCtrl();

    // maybe keyboard selected this item

    if(pt.x == -1 && pt.y == -1)
    {   
        hTreeItem = treectrl.GetSelectedItem( );

        if( hTreeItem != NULL )
        {
            RECT rect;

            treectrl.GetItemRect( hTreeItem , &rect , FALSE );

		    pt.x = rect.left + (rect.right - rect.left)/2;
		    
            pt.y = rect.top + (rect.bottom - rect.top)/2;
	   }
    }
    else
    {
        // otherwise we're invoked by the mouse
        ScreenToClient( &pt );

        hTreeItem = treectrl.HitTest( pt , &flag );
    }

    if( hTreeItem != NULL )
    { 
        CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(hTreeItem);
        
        if(NULL == pNode)
        {
            return;
        }

        SetRightClickedItem( hTreeItem );

        ClientToScreen( &pt );

        // GetTreeCtrl().SelectItem( hTreeItem );

        NODETYPE nt = pNode->GetNodeType();

        if(NODE_SERVER == nt )
        {
            DBGMSG( L"\tServer Node selected\n", 0  );
          
            menu.LoadMenu( IDR_MENU_LPK );

            pContextmenu = menu.GetSubMenu( 0 );
            
        }
        else if( NODE_KEYPACK == nt )
        {
            DBGMSG( L"\tLicense pack selected\n" , 0 );

            menu.LoadMenu( IDR_MENU_LPK );

            pContextmenu = menu.GetSubMenu( 1 );
         
        }
        else if( NODE_ALL_SERVERS == nt )
        {
            DBGMSG( L"\tAll servers selected\n" , 0 );
            
            menu.LoadMenu( IDR_MENU_LPK );

            pContextmenu = menu.GetSubMenu( 3 );
                     
        }
        else
        {
            DBGMSG( L"\tIn left pane no item selected\n" , 0 );

            return;
        }


        UI_initmenu( pContextmenu , nt );


        if( pContextmenu != NULL )
        {
            pContextmenu->TrackPopupMenu( TPM_LEFTALIGN , pt.x , pt.y , this );
        }

    }
    else
    {
        hTreeItem = GetTreeCtrl( ).GetSelectedItem( );

        SetRightClickedItem( hTreeItem );
    }

}


//-----------------------------------------------------------------------------------------
afx_msg void CLicMgrLeftView::OnRightClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    CPoint pt;

    CMenu menu;

    CMenu *pContextmenu = NULL;

    GetCursorPos( &pt );

    OnContextMenu( NULL , pt );

    return;
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::UI_initmenu( CMenu *pMenu , NODETYPE nt )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->UI_initmenu( pMenu , nt );
    }
   
}

//-----------------------------------------------------------------------------------------       
void CLicMgrLeftView::OnServerConnect( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->ConnectServer( );
    }

}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRefreshAllServers( )
{
   CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->OnRefresh( );
    }
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRefreshServer( )
{
   CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

   CLicServer *pServer = NULL;

    if( pMainFrame != NULL )
    {
        CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData( GetRightClickedItem() );

        if( pNode == NULL )
        {
            return;
        }

        if( pNode->GetNodeType() == NODE_SERVER )
        {
            pServer = static_cast< CLicServer * >( pNode->GetTreeObject() );
        }
        else if( pNode->GetNodeType() == NODE_KEYPACK )
        {
            CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

            if( pKeyPack != NULL )
            {
                pServer = pKeyPack->GetServer( );
            }
        }

        if( pServer != NULL )
        {
            pMainFrame->RefreshServer( pServer );
        }        
    }

}
    
//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnDownloadKeepPack()
{
    BOOL bRefresh = FALSE;    

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLKP , &bRefresh );
    
    if( bRefresh )
    {
        // need to review this

        OnRefreshServer( );
    }
  
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnDownloadKeepPack StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRegisterServer()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnRegisterServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnRepeatLastDownload()
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_DOWNLOADLASTLKP , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnRepeatLastDownload StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnReactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_REREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnReactivateServer StartWizard returned 0x%x\n" , dwStatus );
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnDeactivateServer( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_UNREGISTERLS , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnDeactivateServer StartWizard returned 0x%x\n" , dwStatus );    
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnServerProperties( )
{
    BOOL bRefresh;

    DWORD dwStatus = WizardActionOnServer( WIZACTION_SHOWPROPERTIES , &bRefresh );
    
    DBGMSG( L"LICMGR : CLicMgrLeftView::OnServerProperties StartWizard returned 0x%x\n" , dwStatus );    
    
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::OnGeneralHelp( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );
    
    if( pMainFrame != NULL )
    {
        pMainFrame->OnHelp( );
    }
}

//-----------------------------------------------------------------------------------------
DWORD CLicMgrLeftView::WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        return pMainFrame->WizardActionOnServer( wa , pbRefresh , TREEVIEW );
    }

    return ERROR_INVALID_PARAMETER;
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::SetActiveServer( CLicServer *pServer )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

#ifdef DBG

    if( pServer != NULL )
    {
        DBGMSG( L"CLicMgrLeftView::SetActiveServer %s\n" , pServer->GetName( ) );
    }

#endif

    if( pMainFrame != NULL )
    {
        pMainFrame->SetActiveServer( pServer );
    }
}

//-----------------------------------------------------------------------------------------
void CLicMgrLeftView::SetRightClickedItem( HTREEITEM ht )
{
    m_ht = ht;
    
    CTreeNode *pNode = (CTreeNode *)GetTreeCtrl().GetItemData(ht);       
    
    if(NULL == pNode)
    {
        SetActiveServer( NULL );

        return;
    }

    NODETYPE nt = pNode->GetNodeType();

    
    if(NODE_SERVER == nt )
    {    
        SetActiveServer( static_cast< CLicServer * >( pNode->GetTreeObject() ) );

    }
    else if( nt == NODE_KEYPACK )
    {
        CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

        if( pKeyPack != NULL )
        {
            SetActiveServer( pKeyPack->GetServer( ) );
        }
    }
    else
    {
        SetActiveServer( NULL );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\mainfrm.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
  
Module Name:

    MainFrm.cpp

Abstract:
    
    This Module contains the implementation of CMainFrame class
    (The Frame Window of the application)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include <lm.h>
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "MainFrm.h"
#include "RtList.h"
#include "lSmgrdoc.h"
#include "LtView.h"
#include "cntdlg.h"
#include "addkp.h"
#include "treenode.h"
#include "ntsecapi.h"
//#include "lrwizapi.h"
#include "TlsHunt.h"
#include "htmlhelp.h"



#define DELETE_AND_ADDTO_ERROR DeleteServer(pLicServerList,TempPos,pLicServer);\
                               if(!ErrorServers.IsEmpty()) \
                                   ErrorServers = ErrorServers + _T(","); \
                                ErrorServers = ErrorServers + Name;



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_MESSAGE(WM_ENUMERATESERVER, OnEnumerateServer)
    ON_MESSAGE(WM_SEL_CHANGE, OnSelChange)
    ON_MESSAGE(WM_ADD_ALL_SERVERS, OnAddAllServers)
    ON_MESSAGE(WM_ADD_SERVER, OnAddServer)
    ON_MESSAGE(WM_ADD_KEYPACK, OnAddKeyPack)
    ON_COMMAND(ID_LARGE_ICONS, OnLargeIcons)
    ON_COMMAND(ID_SMALL_ICONS, OnSmallIcons)
    ON_COMMAND(ID_LIST, OnList)
    ON_COMMAND(ID_DETAILS, OnDetails)
    ON_COMMAND(ID_EXIT, OnExit)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_HELP_FINDER, OnHelp)
    ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
    ON_COMMAND(ID_CONNECT_SERVER, OnConnectServer)
    ON_COMMAND(ID_REGISTRATION, OnRegistration)
    ON_COMMAND(ID_KEY_HELP , OnHelp )
    ON_UPDATE_COMMAND_UI( ID_REGISTRATION, OnUpdateAddNewKeyPack)
    ON_UPDATE_COMMAND_UI( ID_ACTION_DOWNLOADLICENSES, OnUpdateDownloadlicenses )
    ON_UPDATE_COMMAND_UI( ID_ACTION_ADVANCED_REPEATLASTDOWNLOAD , OnUpdateRepeatLastDownload )
    ON_UPDATE_COMMAND_UI( ID_ACTION_ADVANCED_REREGISTERSERVER , OnUpdateReregisterserver )
    ON_UPDATE_COMMAND_UI( ID_ACTION_ADVANCED_UNREGISTERSERVER , OnUpdateUnregisterserver )
    ON_UPDATE_COMMAND_UI( ID_VIEW_PROPERTIES , OnUpdateProperties )

    ON_COMMAND( ID_REFRESH, OnRefreshServer )
    ON_COMMAND( ID_VIEW_REFRESHALL , OnRefresh )
    ON_UPDATE_COMMAND_UI( ID_REFRESH , OnUpdateRefresh )

    ON_COMMAND( ID_ACTION_DOWNLOADLICENSES , OnDownLoadLicenses )    
    ON_COMMAND( ID_ACTION_ADVANCED_REPEATLASTDOWNLOAD , OnRepeatLastDownLoad )
    ON_COMMAND( ID_ACTION_ADVANCED_REREGISTERSERVER ,  OnReRegisterServer )
    ON_COMMAND( ID_ACTION_ADVANCED_UNREGISTERSERVER , OnUnRegisterServer )

    ON_COMMAND( ID_VIEW_PROPERTIES , OnProperties )

    //}}AFX_MSG_MAP
    

END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_pRightView= NULL;
    m_pLeftView = NULL;
    m_pServer = NULL;
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

#if 0
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

#endif

    // Remove this if you don't want tool tips or a resizeable toolbar
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

    // Delete these three lines if you don't want the toolbar to be dockable
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);
    return 0;
}
void CMainFrame::OnHelp()
{
    TCHAR * pHtml = L"ts_lice_topnode.htm";
    HtmlHelp(AfxGetMainWnd()->m_hWnd, L"tslic.chm", HH_DISPLAY_TOPIC,(DWORD_PTR)pHtml);
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    cs.style &= ~FWS_ADDTOTITLE;
    return CFrameWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{
    m_SplitterWnd.CreateStatic(this,1,2); //1 row, 2 columns
    m_SplitterWnd.CreateView(0,0,(CRuntimeClass *)pContext->m_pNewViewClass,CSize(150,150),pContext);
    m_SplitterWnd.CreateView(0,1,RUNTIME_CLASS(CRightList),CSize(0,0),pContext);
    m_pRightView = (CView *)m_SplitterWnd.GetPane(0, 1);
    m_pLeftView = (CLicMgrLeftView *)m_SplitterWnd.GetPane(0, 0);
    
    return TRUE;
}

LRESULT CMainFrame::OnSelChange(WPARAM wParam, LPARAM lParam)
{
   LRESULT lResult = 0;
   m_pRightView->SendMessage(WM_SEL_CHANGE,wParam,lParam);
   return lResult;
   
}



void CMainFrame::OnLargeIcons() 
{
    PressButton(ID_LARGE_ICONS,TRUE);
    PressButton(ID_SMALL_ICONS,FALSE);
    PressButton(ID_LIST,FALSE);
    PressButton(ID_DETAILS,FALSE);
    m_pRightView->SendMessage(WM_COMMAND,ID_LARGE_ICONS,0);

    
}

void CMainFrame::OnSmallIcons() 
{
    PressButton(ID_LARGE_ICONS,FALSE);
    PressButton(ID_SMALL_ICONS,TRUE);
    PressButton(ID_LIST,FALSE);
    PressButton(ID_DETAILS,FALSE);
    m_pRightView->SendMessage(WM_COMMAND,ID_SMALL_ICONS,0);
    
}

void CMainFrame::OnList() 
{
    PressButton(ID_LARGE_ICONS,FALSE);
    PressButton(ID_SMALL_ICONS,FALSE);
    PressButton(ID_LIST,TRUE);
    PressButton(ID_DETAILS,FALSE);
    m_pRightView->SendMessage(WM_COMMAND,ID_LIST,0);
    
}

void CMainFrame::OnDetails() 
{
    PressButton(ID_LARGE_ICONS,FALSE);
    PressButton(ID_SMALL_ICONS,FALSE);
    PressButton(ID_LIST,FALSE);
    PressButton(ID_DETAILS,TRUE);
    m_pRightView->SendMessage(WM_COMMAND,ID_DETAILS,0);
    
}

void CMainFrame::OnExit() 
{
    SendMessage(WM_CLOSE,0,0);    
}


LRESULT CMainFrame::OnAddAllServers(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    m_pLeftView->SendMessage(WM_ADD_ALL_SERVERS,wParam,lParam);
    return lResult;
}
LRESULT CMainFrame::OnAddServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT  lResult = 0;
    m_pLeftView->SendMessage(WM_ADD_SERVER,wParam,lParam);
    m_pRightView->SendMessage(WM_ADD_SERVER,wParam,lParam);
    return lResult;
}

LRESULT CMainFrame::OnAddKeyPack(WPARAM wParam, LPARAM lParam)
{
    LRESULT  lResult = 0;
    m_pLeftView->SendMessage(WM_ADD_KEYPACK,wParam,lParam);
    m_pRightView->SendMessage(WM_ADD_KEYPACK,wParam,lParam);
    return lResult;
}

void CMainFrame::OnAppAbout() 
{
    CString AppName;
    AppName.LoadString(IDS_APP_NAME);
    ::ShellAbout((HWND)m_hWnd,(LPCTSTR)AppName,
                 NULL,NULL); 

    
}

void CMainFrame::OnRegistration()
{
    CWnd* cWnd = AfxGetMainWnd();
    HWND hWnd=cWnd->GetSafeHwnd();
    DWORD status;
    CString TempString;
    CString Server;
    CLicServer* pServer = NULL;
    WCHAR szServer[MAX_COMPUTERNAME_LENGTH + 1];

    BOOL bRefresh;



    try
    {
        if(ERROR_SUCCESS != GetActiveServer(&pServer))
        {
            DBGMSG( L"LICMGR : OnRegistration no active servers\n",0 );

            return;
        }

    	if(SERVER_TS5_ENFORCED == pServer->GetServerType())
    	{
            DBGMSG( L"LICMGR : OnRegistration on enforced server\n",0 );

            if( !pServer->IsUserAdmin( ) )
            {
                AfxMessageBox( IDS_E_ACCESSDENIED );
                // ::MessageBox( GetSafeHwnd( ) , L"Unable to perform operation: Access denied" , L"Terminal Services Licensing" , MB_OK|MB_ICONINFORMATION );

                return;
            }

    		if(pServer->UseIpAddress())
            {
    			Server = pServer->GetIpAddress();
            }
    		else
            {
    			Server = pServer->GetName();
            }

    		lstrcpy(szServer, (LPCTSTR)Server);

            DWORD dwStatus = pServer->GetServerRegistrationStatus( );

            DBGMSG( L"LICMGR:CMainFrame::OnRegistration calling StartWizard\n", 0 );
            
            StartWizard( hWnd , WIZACTION_REGISTERLS , szServer , &bRefresh );

            //DBGMSG( L"LICMGR:CMainFrame::OnRegistration - StartWizard returned 0x%x\n" , status );    		           

            if( IsLicenseServerRegistered( hWnd , szServer , &status ) == ERROR_SUCCESS )
            {
                pServer->SetServerRegistrationStatus( status );
            }
            
            if( dwStatus != status )
            {
                RefreshServer(pServer);               
            }
    		

  		UpdateWindow();

    	}
    	else
    	{
            DBGMSG( L"LICMGR : OnRegistration on non-enforced server\n",0 );
            
            // AddKeyPackDialog(NULL);
    	}

    } 
    catch (...)
    {
    	// validation failed - user already alerted, fall through
    
    	// Note: DELETE_EXCEPTION_(e) not required
    }
}

//////////////////////////////////////////////////////////////////////////////

BOOL
CMainFrame::ConnectServer(
    LPCTSTR pszServer
    )
/*++


++*/
{
    CConnectDialog ConnectDialog;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
        return FALSE;

    HRESULT hResult = ERROR_SUCCESS;
    SERVER_TYPE ServerType;

    CString Scope;    

    if(pszServer == NULL)
    {
        if(ConnectDialog.DoModal() != IDOK)
        {
            return FALSE;
        }

        //
        // Empty string - local machine
        //
        if(ConnectDialog.m_Server.IsEmpty())
        {
            TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
            DWORD dwBufSize = MAX_COMPUTERNAME_LENGTH + 1;
            memset(szComputerName, 0, sizeof(szComputerName));

            GetComputerName(szComputerName, &dwBufSize);
            ConnectDialog.m_Server = szComputerName;
        }
    }
    else
    {
        //
        // Minimize code change
        //
        ConnectDialog.m_Server = pszServer;
    }

    SetCursor(LoadCursor(NULL,IDC_WAIT));
    if(TRUE == pDoc->IsServerInList(ConnectDialog.m_Server))
    {
        //AfxMessageBox(IDS_DUPLICATE_SERVER);
        return FALSE;
    }    

//HUEIHUEI - Check if server is registered


    //
    // Do a NT4 RPC connect to make sure the license server
    // can accept our calls.
    //
    CString IpAddress(ConnectDialog.m_Server);     

    hResult = pDoc->ConnectToServer(
                                ConnectDialog.m_Server, 
                                Scope,
                                ServerType                                                                
                            );

    if(ERROR_SUCCESS != hResult)
    {
        CDialog ErrorDialog(IDD_CONNECT_ERROR,this);
        ErrorDialog.DoModal();
    
    }
    else
    {
        CAllServers * pAllServers = pDoc->GetAllServers();
        CLicServer *pServer1 = NULL;
        if(IpAddress != ConnectDialog.m_Server)
        {
            if(TRUE == pDoc->IsServerInList(ConnectDialog.m_Server))
            {
                return TRUE;
            }
            pServer1 = new CLicServer(
                                    ConnectDialog.
                                    m_Server,
                                    ServerType,
                                    Scope,
                                    IpAddress
                                );
        }
        else
        {
            pServer1= new CLicServer(
                                    ConnectDialog.
                                    m_Server,
                                    ServerType,
                                    Scope
                                );

        }
        if(pServer1)
        {
            DWORD dwStatus;

            // check for admin
            
            pServer1->SetAdmin( IsUserAdmin( pServer1->GetName() ) );                                
            

            if( pServer1->IsUserAdmin( ) )
            {
                if( IsLicenseServerRegistered( GetSafeHwnd() , ( LPCTSTR )pServer1->GetName() , &dwStatus ) == ERROR_SUCCESS )
                {
                    pServer1->SetServerRegistrationStatus( dwStatus );
                }
            }


            CLicMgrDoc * pDoc = (CLicMgrDoc *)(GetActiveView()->GetDocument());

            pDoc->EnumerateKeyPacks( pServer1 , LSKEYPACK_SEARCH_LANGID , TRUE );

            WIZCONNECTION WizConType;

            if( GetConnectionType( GetSafeHwnd() , pServer1->GetName() , &WizConType ) == ERROR_SUCCESS )
            {
                DBGMSG( L"ConnectServer - GetConnectionType obtained %d" , WizConType );               

                pServer1->SetConType( WizConType );
            }
            
            pAllServers->AddLicServer(pServer1);

            SendMessage(WM_ADD_SERVER,0,(LPARAM)pServer1);

            // after the send message is called all servers will have their keypacks cached.
            
            pServer1->SetDownLoadLics( IsDownLoadedPacks( pServer1 ) );

        }
        else
        {
            return FALSE;
        }
    }    

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////

void 
CMainFrame::OnConnectServer()
{
    ConnectServer();
}


HRESULT CMainFrame::AddKeyPackDialog(CLicServer * pServer)
{
    HRESULT hResult = ERROR_SUCCESS;
    CString TempString;
    CString Server;

    //if pServer is null,Then the message is from Listview.
    //Get the current server from the treeview.
    SetCursor(LoadCursor(NULL,IDC_WAIT));
    if(NULL == pServer)
    {
        if(ERROR_SUCCESS != GetActiveServer(&pServer))
        {
            hResult = E_FAIL;
            return hResult;
        }
        
    }

    //Server = pServer->GetName();
    CLicMgrDoc * pDoc = (CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        hResult = E_FAIL;
        return hResult;
    }
    KeyPackList * pKeypackList = pServer->GetKeyPackList();
    if(NULL == pKeypackList)
    {
        hResult = E_FAIL;
        return hResult;
    }
    //If Server is not enumerated enumerate now.
    if(!pServer->IsExpanded())
    {
        HRESULT hResult = pDoc->EnumerateKeyPacks(pServer,LSKEYPACK_SEARCH_LANGID, TRUE);
        if(hResult != S_OK)
        {
           hResult = E_FAIL;
           return hResult;
        }
    
        POSITION pos1 = pKeypackList->GetHeadPosition();
        while(pos1)
        {
            CKeyPack *pKeyPack = (CKeyPack *)pKeypackList->GetNext(pos1);
            hResult = pDoc->EnumerateLicenses(pKeyPack,LSLICENSE_SEARCH_KEYPACKID, TRUE);
            if(hResult != S_OK)
            {
                hResult = E_FAIL;
                return hResult;
            }
        }
    }

    CAddKeyPack KeyPack(pKeypackList,IsUserAdmin(Server));
    KeyPack.DoModal();
    return hResult;
}

void CMainFrame::OnUpdateAddNewKeyPack(CCmdUI* pCmdUI) 
{
    BOOL bEnable = FALSE;

    HRESULT hrStatus;

    // we have to force another check here

    bEnable = IsServerRegistered( &hrStatus );

    if( FAILED( hrStatus ) )
    {
        pCmdUI->Enable(bEnable);
    }
    else
    {
        pCmdUI->Enable( !bEnable );
    }
   
}


HRESULT 
CMainFrame::AddLicensestoList(
    CKeyPack * pKeyPack, 
    CListCtrl * pListCtrl,
    BOOL bRefresh
    )
/*++

--*/
 {
    CLicServer *pServer = NULL;
    CString Error;
    HRESULT hr;


    ASSERT(pKeyPack);
    ASSERT(pListCtrl);
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);

    if(NULL == pKeyPack || NULL == pListCtrl || NULL == pDoc)
    {
        return E_FAIL;
    }

    if(TRUE == bRefresh)
    {
        if((hr = pKeyPack->RefreshIssuedLicenses()) != S_OK)
        {
            EnumFailed(hr,pKeyPack->GetServer());

            return E_FAIL;
        }
    }

    IssuedLicenseList * pIssuedLicenseList = pKeyPack->GetIssuedLicenseList();
    ASSERT(pIssuedLicenseList);
    if(NULL == pIssuedLicenseList)
    {
        return E_FAIL;
    }

    LSKeyPack sKeyPack = pKeyPack->GetKeyPackStruct();

    int nIndex = 0;
    int nSubitemIndex = 1;
    CString TempString;
    POSITION pos;

    LV_ITEM lvI;
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    lvI.iSubItem = 0; 
    lvI.iImage = 2;  
    
    pos = pIssuedLicenseList->GetHeadPosition();
    while(pos)
    {

        lvI.iItem = nIndex;
        nSubitemIndex = 1;
        CLicense  * pLicense = pIssuedLicenseList->GetNext(pos);
        ASSERT(pLicense);
        if(NULL == pLicense)
        {
            continue;
        }

        LSLicenseEx sLicense = pLicense->GetLicenseStruct();
        lvI.lParam = (LPARAM)pLicense;
        TempString = sLicense.szMachineName;
        lvI.pszText = TempString.GetBuffer(TempString.GetLength());
        lvI.cchTextMax =lstrlen(lvI.pszText + 1);
        nIndex = pListCtrl->InsertItem(&lvI);
        
        //Set the Issue date.

        pDoc->TimeToString(&sLicense.ftIssueDate, TempString);
        if(TempString.IsEmpty())
        {
            TempString.LoadString(IDS_UNKNOWN);
        }

        pListCtrl->SetItemText(nIndex,nSubitemIndex,(LPCTSTR)TempString);
        nSubitemIndex++;


        //Set the expiry date.

        if(0x7FFFFFFF != sLicense.ftExpireDate)
        {
            TempString.LoadString(IDS_DASH);
            pDoc->TimeToString(&sLicense.ftExpireDate, TempString);
            if(TempString.IsEmpty())
            {
                TempString.LoadString(IDS_UNKNOWN);
            }
        }
        else
        {
            TempString.LoadString(IDS_DASH);
        }
       
        pListCtrl->SetItemText(nIndex,nSubitemIndex,(LPCTSTR)TempString);

        nSubitemIndex++;

        // adding status text to license's status column

        switch( sLicense.ucLicenseStatus )
        {
            case LSLICENSE_STATUS_UNKNOWN:
                TempString.LoadString( IDS_LICENSESTATUS_UNKNOWN );
                break;

            case LSLICENSE_STATUS_TEMPORARY:
                TempString.LoadString( IDS_LICENSESTATUS_TEMPORARY );
                break;

            case LSLICENSE_STATUS_ACTIVE:
            //case LSLICENSE_STATUS_PENDING_ACTIVE:
            case LSLICENSE_STATUS_CONCURRENT:
                TempString.LoadString( IDS_LICENSESTATUS_ACTIVE );
                break;

            case LSLICENSE_STATUS_UPGRADED:
                TempString.LoadString( IDS_LICENSESTATUS_UPGRADED );
                break;

            //case LSLICENSE_STATUS_REVOKE:
            //case LSLICENSE_STATUS_REVOKE_PENDING:
            //    TempString.LoadString( IDS_LICENSESTATUS_REVOKE );
                    
        }

        if( TempString.IsEmpty() )
        {
            TempString.LoadString(IDS_UNKNOWN);
        }
       
        pListCtrl->SetItemText(nIndex,nSubitemIndex,(LPCTSTR)TempString);
        nIndex ++;

    }

    return S_OK;

}

void CMainFrame :: PressButton(UINT uId, BOOL bPress)
{
    CToolBarCtrl& ToolBarCtrl = m_wndToolBar.GetToolBarCtrl();
    ToolBarCtrl.PressButton(uId,bPress);
}

/////////////////////////////////////////////////////////////////////
LRESULT
CMainFrame::OnEnumerateServer(WPARAM wParam, LPARAM lParam)
{
    CTlsHunt huntDlg;

    huntDlg.DoModal();

    if( wParam == 0 && 
        huntDlg.IsUserCancel() == FALSE && 
        huntDlg.GetNumServerFound() == 0 )
    {
        AfxMessageBox(IDS_NOSERVERINDOMAIN);
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////

void 
CMainFrame :: ConnectAndDisplay()
{
    CLicMgrApp *pApp = (CLicMgrApp*)AfxGetApp();
    ASSERT(pApp);
    CLicMgrDoc *pDoc = (CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pApp || NULL == pDoc)
        return;

    HRESULT hResult = ERROR_SUCCESS;

    CString LicServer;
    CString Server = pApp->m_Server;
    if(!Server.IsEmpty())
    {
        //Server Specified in the command line. Connect to it.        
        hResult = pDoc->ConnectWithCurrentParams();
    }
    else
    {
        ActivateFrame();
        //
        // Save a copy of what we have.
        //
        LicServer = pApp->m_Server;
        pApp->m_Server = _TEXT("");

        hResult = pDoc->ConnectWithCurrentParams();

        pApp->m_Server = LicServer;
        hResult = ERROR_SUCCESS;
    }

    switch(hResult)
    {
    case E_FAIL:
        AfxMessageBox(IDS_CONNECT_SERVER_FAILED);
        break;
    case E_OUTOFMEMORY:
        AfxMessageBox(IDS_NO_MEMORY);
        SendMessage(WM_CLOSE,0,0);
        break;
    case E_DUPLICATE:
        AfxMessageBox(IDS_DUPLICATE_SERVER);
        break;
    }
    return;
   
}

HRESULT CMainFrame :: GetLicServer(CString * pLicServer)
{
    HRESULT hResult = ERROR_SUCCESS;
    if(NULL == pLicServer)
        return hResult;
    HKEY hKey = NULL;
    DWORD lSize = MAX_PATH;
    ULONG lDataType = REG_SZ;
    TCHAR szString[MAX_PATH] = {0};
    long lResult;
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TERMSERVICE_PARAMETER_KEY,0,KEY_READ,&hKey);
    if(ERROR_SUCCESS != lResult)
    {
        hResult = E_FAIL;
        goto cleanup;
    }
    lResult = RegQueryValueEx(hKey,USE_LICSENSE_SERVER,0,&lDataType,(unsigned char *)szString,&lSize);
    if(ERROR_SUCCESS != lResult)
    {
        hResult = E_FAIL;
        goto cleanup;
    }
    if(szString[0] != 1)
    {
        hResult = E_FAIL;
        goto cleanup;
    }
    lDataType = REG_SZ;
    lSize = MAX_PATH;
    lResult = RegQueryValueEx(hKey,LICSENSE_SERVER,0,&lDataType,(unsigned char *)szString,&lSize);
    if(ERROR_SUCCESS != lResult)
    {
        hResult = E_FAIL;
        goto cleanup;
    }
    else
        *pLicServer = szString;

cleanup:
    if(hKey)
        RegCloseKey(hKey);
    return hResult;


}

void CMainFrame::OnRefresh() 
{
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }

    HRESULT hResult = ERROR_SUCCESS;
    CString ErrorServers;
    CString Error;
    
    CWaitCursor Wait;

    CAllServers *pAllServers = pDoc->GetAllServers();
    ASSERT(pAllServers);
    if(NULL == pAllServers)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }

    LicServerList * pLicServerList = pAllServers->GetLicServerList();
    ASSERT(pLicServerList);
    if(NULL == pLicServerList)
    {
        AfxMessageBox(IDS_INTERNAL_ERROR);
        return;
    }
    POSITION pos = pLicServerList->GetHeadPosition();

    OnEnumerateServer(
        (pos == NULL) ? 0 : 1,  // show error dialog if nothing in the list
        0
        );

    Wait.Restore();
    while(pos)
    {
        // Connect to each server and check if the information in the cache is current. If not update the information.
        // If the connection to the server cannot be establised,add them to the list to display to the user.

        POSITION TempPos = pos;
        CLicServer * pLicServer = pLicServerList->GetNext(pos);
        ASSERT(pLicServer);
        if(NULL == pLicServer)
        {
            continue;
        }

        CString Name = pLicServer->GetName();
        
        //Call Refresh Server
        hResult = RefreshServer(pLicServer);

        
    }

    if(!ErrorServers.IsEmpty())
    {
        Error.LoadString(IDS_REFRESH_SERVERS_ERROR);
        Error = Error + ErrorServers;
        AfxMessageBox(Error);
    }

    return;
   
}

void CMainFrame::DeleteServer(LicServerList * pLicServerList, POSITION TempPos, CLicServer * pLicServer)
{
    if(NULL == pLicServerList || NULL == pLicServer)
        return;

    m_pLeftView->SendMessage(WM_DELETE_SERVER,0,(LPARAM)pLicServer);
    m_pRightView->SendMessage(WM_DELETE_SERVER,0,(LPARAM)pLicServer);
    
    pLicServerList->RemoveAt(TempPos);
    delete pLicServer;
    pLicServer = NULL;

}

void CMainFrame::SetTreeViewSel(LPARAM lParam, NODETYPE NodeType)
{
  if(NULL == lParam || NULL == m_pLeftView)
      return;
  ((CLicMgrLeftView *)m_pLeftView)->SetSelection(lParam, NodeType);
  SetActiveView(m_pLeftView);
  return;
}

HRESULT CMainFrame::AddLicenses(CKeyPack * pKeyPack,UINT nLicenses)
{
    HRESULT hResult = ERROR_SUCCESS;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc || NULL == pKeyPack)
    {
        hResult = E_FAIL;
        return hResult;
    }
    LPLSKeyPack psKeyPack;
    psKeyPack = &pKeyPack->GetKeyPackStruct();

    hResult = pDoc->AddLicenses(pKeyPack->GetServer(),psKeyPack,nLicenses);
    if(ERROR_SUCCESS != hResult)
    {
       return hResult;
    }
    m_pRightView->SendMessage(WM_UPDATE_SERVER,0,(LPARAM)pKeyPack->GetServer());
    return hResult;
}

HRESULT CMainFrame::RemoveLicenses(CKeyPack * pKeyPack,UINT nLicenses)
{
    HRESULT hResult = ERROR_SUCCESS;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc || NULL == pKeyPack)
    {
        hResult = E_FAIL;
        return hResult;
    }
    LPLSKeyPack psKeyPack;
    psKeyPack = &pKeyPack->GetKeyPackStruct();

    hResult = pDoc->RemoveLicenses(pKeyPack->GetServer(),psKeyPack,nLicenses);
    if(ERROR_SUCCESS != hResult && LSERVER_I_REMOVE_TOOMANY != hResult)
    {
        return hResult;
    }
    m_pRightView->SendMessage(WM_UPDATE_SERVER,0,(LPARAM)pKeyPack->GetServer());
    return hResult;
}

void InitLsaString(PLSA_UNICODE_STRING LsaString, LPWSTR String ) 
{ 
    DWORD StringLength; 
 
    if (String == NULL)
    { 
        LsaString->Buffer = NULL; 
        LsaString->Length = 0; 
        LsaString->MaximumLength = 0; 
        return; 
    } 
 
    StringLength = lstrlen(String); 
    LsaString->Buffer = String; 
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR); 
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR); 
} 


NTSTATUS 
OpenPolicy(
    LPWSTR ServerName, 
    DWORD DesiredAccess, 
    PLSA_HANDLE PolicyHandle 
    ) 
/*++


--*/
{ 
    LSA_OBJECT_ATTRIBUTES ObjectAttributes; 
    LSA_UNICODE_STRING ServerString; 
    PLSA_UNICODE_STRING Server = NULL; 
 
   
    // Always initialize the object attributes to all zeroes. 
    
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes)); 
 
    if (ServerName != NULL) 
    { 
       // Make a LSA_UNICODE_STRING out of the LPWSTR passed in 
        InitLsaString(&ServerString, ServerName); 
        Server = &ServerString; 
    } 
 
    
    // Attempt to open the policy. 
   
    return LsaOpenPolicy(Server, &ObjectAttributes, DesiredAccess, PolicyHandle ); 
} 

BOOL CMainFrame::IsUserAdmin(CString& Server)
{
    BOOL IsUserAdmin = FALSE;
    LSA_HANDLE PolicyHandle = NULL;
    NTSTATUS Status;

    Status = OpenPolicy(Server.GetBuffer(Server.GetLength()),POLICY_SERVER_ADMIN,&PolicyHandle);

    DBGMSG( L"LICMGR@CMainFrame::IsUserAdmin OpenPolicy returned 0x%x\n" , Status );

    if(Status == 0)
        IsUserAdmin = TRUE;

    if(PolicyHandle)
        LsaClose(PolicyHandle);
    return IsUserAdmin;
}

void CMainFrame::EnumFailed(HRESULT reason, CLicServer * pLicServer)
{
    DBGMSG( L"CMainFrame_EnumFailed\n" , 0 );

    ASSERT(pLicServer);
    if(NULL == pLicServer)
        return;
    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;

    CString Error;
    CString Server;
    POSITION pos;
    BOOL bFoundServer = FALSE;

    LicServerList * pLicServerList = NULL;
    POSITION temppos = NULL;

    switch(reason)
    {
    case CONNECTION_FAILED:

        DBGMSG( L"\tCONNECTION_FAILED\n" , 0 );
        
        Server = pLicServer->GetName();
        Error.Format(IDS_CONNECT_ERROR,Server);
        AfxMessageBox(Error);

        pLicServerList = (pDoc->GetAllServers())->GetLicServerList();
        if(NULL == pLicServerList)
            break;
        //Find the position of the server in the List;
        pos = pLicServerList->GetHeadPosition();
        while(pos)
        {
            temppos = pos;
            CLicServer *pServer = (CLicServer *)pLicServerList->GetNext(pos);
            ASSERT(pServer);
            if(NULL == pServer)
                continue;
        
            if((0 == Server.CompareNoCase(pServer->GetName())) || (0 == Server.CompareNoCase(pServer->GetIpAddress())))
            {
                bFoundServer = TRUE;
                break;
            }
        }
        if(bFoundServer)
            DeleteServer(pLicServerList,temppos,pLicServer);
        break;

    case LSERVER_E_SERVER_BUSY:
        DBGMSG( L"\tLSERVER_E_SERVER_BUSY\n" , 0 );
        AfxMessageBox(IDS_SERVER_BUSY);
        break;

    case LSERVER_E_OUTOFMEMORY:
        DBGMSG( L"\tLSERVER_E_OUTOFMEMORY\n" , 0 );
        AfxMessageBox(IDS_SERVER_OUTOFMEMORY);
        break;

    case LSERVER_E_INTERNAL_ERROR:
        DBGMSG( L"\tLSERVER_E_INTERNAL_ERROR\n" , 0 );
        AfxMessageBox(IDS_SERVER_INTERNAL_ERROR);
        pLicServerList = (pDoc->GetAllServers())->GetLicServerList();
        if(NULL == pLicServerList)
            break;
        //Find the position of the server in the List;
        pos = pLicServerList->GetHeadPosition();
        while(pos)
        {
            temppos = pos;
            CLicServer *pServer = (CLicServer *)pLicServerList->GetNext(pos);
            ASSERT(pServer);
            if(NULL == pServer)
                continue;
        
            if((0 == Server.CompareNoCase(pServer->GetName())) || (0 == Server.CompareNoCase(pServer->GetIpAddress())))
            {
                bFoundServer = TRUE;
                break;
            }
        }
        if(bFoundServer)
            DeleteServer(pLicServerList,temppos,pLicServer);
        break;

    case E_OUTOFMEMORY:
        DBGMSG( L"\tE_OUTOFMEMORY\n" , 0 );
        AfxMessageBox(IDS_NO_MEMORY);
        break;
    default:
        break;


    }

}

void CMainFrame::SelectView(VIEW view)
{
    if(view == TREEVIEW)
    {
        SetActiveView(m_pLeftView);
    }
    else 
    {
        SetActiveView(m_pRightView);
    }

}


HRESULT CMainFrame::RefreshServer(CLicServer * pLicServer)
{
    DWORD dwStatus;

    HRESULT hResult = E_FAIL;

    CWaitCursor Wait;
        
    
    if(NULL == pLicServer)
    {
        return E_INVALIDARG;
    }

    DBGMSG( L"LICMGR : CMainFrame::RefreshServer %s\n" , pLicServer->GetName( ) );

    CLicMgrDoc * pDoc =(CLicMgrDoc *)(GetActiveView()->GetDocument());
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return ERROR_INTERNAL_ERROR;
    }

    CString Server;
    if(pLicServer->UseIpAddress())
    {
        Server = pLicServer->GetIpAddress();
    }
    else
    {
        Server = pLicServer->GetName();
    }

    WIZCONNECTION WizConType;

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer setting ConnectionType\n" , 0 );

    if( GetConnectionType( GetSafeHwnd() , Server , &WizConType ) == ERROR_SUCCESS )
    {
        pLicServer->SetConType( WizConType );
    }    

    // check for admin

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer setting admin priv\n" , 0 );

    pLicServer->SetAdmin( IsUserAdmin( Server ) );

    if( !pLicServer->IsUserAdmin( ) )
    {
        return E_ACCESSDENIED;
    }

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer updating server status\n" , 0 );

    if( IsLicenseServerRegistered( GetSafeHwnd( ) , Server , &dwStatus ) == ERROR_SUCCESS )
    {        
        pLicServer->SetServerRegistrationStatus( dwStatus );
    }
    else
    {
        pLicServer->SetServerRegistrationStatus( ( DWORD )-1 );
    }

    //Could connect to the server. check if Info in cache is proper.
    //If server is not expanded leave it like that.
    /* 
    if(!pLicServer->IsExpanded())
    {        
        DBGMSG( L"LICMGR:Cmainframe licserver not expanded\n" , 0 );

        return S_OK;
    }
    */

    KeyPackList * pkeypackList = pLicServer->GetKeyPackList();
    if(NULL == pkeypackList)
    {
        DBGMSG( L"LICMGR:RefreshServer no keypacklist\n",0 );

        return E_FAIL;
    }


    POSITION pos1 = pkeypackList->GetHeadPosition();
    CKeyPack *pKeyPack = NULL;

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer removing keypacks\n" , 0 );

    while(pos1)
    {
        pKeyPack = (CKeyPack *)pkeypackList->GetNext(pos1);
        ASSERT(pKeyPack);
        if(pKeyPack)
        {
            delete pKeyPack;
            pKeyPack = NULL;    
        }
    }


    pkeypackList->RemoveAll();

    pLicServer->Expand(FALSE);
    
    DBGMSG( L"LICMGR:CMainFrame::RefreshServer enumerating keypacks\n" , 0 );

    hResult = pDoc->EnumerateKeyPacks(
                                    pLicServer,
                                    LSKEYPACK_SEARCH_LANGID, 
                                    TRUE
                                );
    if(hResult != S_OK)
    {
        EnumFailed( hResult , pLicServer );

        return hResult;
    }

    /*
    pos1 = pkeypackList->GetHeadPosition();
    BOOL bFlag = FALSE;
    while(pos1)
    {
        CKeyPack *pKeyPack = (CKeyPack *)pkeypackList->GetNext(pos1);
        hResult = pDoc->EnumerateLicenses(
                                        pKeyPack,
                                        LSLICENSE_SEARCH_KEYPACKID, 
                                        TRUE
                                    );

        if(hResult != S_OK)
        {
            return hResult;
        }
    }
    */

    DBGMSG( L"LICMGR:CMainFrame::RefreshServer checking for keypacks\n" , 0 );

    pLicServer->SetDownLoadLics( IsDownLoadedPacks( pLicServer ) );

    m_pLeftView->SendMessage(WM_UPDATE_SERVER,0,(LPARAM)pLicServer);

    m_pRightView->SendMessage(WM_UPDATE_SERVER,0,(LPARAM)pLicServer);

    return hResult;


}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateDownloadlicenses( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateDownloadlicenses\n" , 0 );

    CLicServer *pServer = NULL;

    HRESULT hr;

    GetActiveServer( &pServer );
    
    pCmdUI->Enable( FALSE );
    
    if( pServer != NULL )
    {
        if( pServer->GetServerType( ) == SERVER_TS5_ENFORCED )
        {
            pCmdUI->Enable( IsServerRegistered( &hr ) );
        }
        else
        {
            pCmdUI->Enable( TRUE );
        }
    }
    else
    {
        pCmdUI->Enable( FALSE );
    }

}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateRepeatLastDownload( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateRepeatLastDownload\n" , 0 );                

    HRESULT hr;

    CLicServer * pLicServer = NULL;

    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer->GetConType( ) != CONNECTION_WWW )
        {
            if( IsServerRegistered( &hr ) )
            {        
                pCmdUI->Enable( IsLicensesDownLoaded() );

                return;
            }
        }
    }

    pCmdUI->Enable( FALSE );
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateReregisterserver( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateReregisterserver\n" , 0 );                

    HRESULT hr;

    CLicServer * pLicServer = NULL;

    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer->GetConType( ) != CONNECTION_WWW )
        {
             pCmdUI->Enable( IsServerRegistered( &hr ) );

             return;
        }
    }

    pCmdUI->Enable( FALSE );

}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateUnregisterserver( CCmdUI * pCmdUI )
{
    DBGMSG( L"LICMGR@CMainFrame::OnUpdateUnregisterserver\n" , 0 );
    
    HRESULT hr;
    
    CLicServer * pLicServer = NULL;

    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer->GetConType( ) != CONNECTION_WWW )
        {
             pCmdUI->Enable( IsServerRegistered( &hr ) );

             return;
        }
    }

    pCmdUI->Enable( FALSE );
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateRefresh( CCmdUI *pCmdUI )
{
    CLicServer * pLicServer = NULL;

    if( FAILED( GetActiveServer( &pLicServer ) ) )
    {
        pCmdUI->Enable( FALSE );
    }
    else
    {
        pCmdUI->Enable( TRUE );
    }
}

//--------------------------------------------------------------------
void CMainFrame::OnUpdateProperties( CCmdUI *pCmdUI )
{    
    CLicServer * pLicServer = NULL;
    
    GetActiveServer( &pLicServer );
    
    pCmdUI->Enable( FALSE );
    
    if( pLicServer != NULL && pLicServer->GetServerType( ) == SERVER_TS5_ENFORCED )
    {
        pCmdUI->Enable( TRUE );
    }    
}

//--------------------------------------------------------------------
void CMainFrame::OnRefreshServer( )
{
    CLicServer * pLicServer = NULL;

    if( FAILED( GetActiveServer( &pLicServer ) ) )
    {
        // nothing to refresh

        return;
    }

    RefreshServer( pLicServer );
}


//--------------------------------------------------------------------
BOOL CMainFrame::IsServerRegistered( HRESULT *phrStatus )
{
    BOOL bEnable = FALSE;

    ASSERT( phrStatus != NULL );

    DWORD dwServerStatus = ERROR_SUCCESS;
    
    CLicServer * pLicServer = NULL;        

    *phrStatus = GetActiveServer( &pLicServer );
    
    if( pLicServer != NULL )
    {   
        if( pLicServer->GetServerType() == SERVER_TS5_ENFORCED )
        {
            dwServerStatus = pLicServer->GetServerRegistrationStatus( );            
        }
        else
        {
            *phrStatus = E_FAIL; // fail all non enforced server 
        }       
        
    }    
    
    if( dwServerStatus == LSERVERSTATUS_REGISTER_INTERNET ||
        dwServerStatus == LSERVERSTATUS_REGISTER_OTHER )
    {
        bEnable = TRUE;
    }
    else
    {
        bEnable = FALSE;
    }

    DBGMSG( L"LICMGR@CMainFrame::IsServerRegistered -- status returned 0x%x\n" , dwServerStatus );            

    return bEnable;
}

//--------------------------------------------------------------------
// used by views
//--------------------------------------------------------------------
void CMainFrame::UI_initmenu( CMenu *pMenu , NODETYPE nt )
{
    HRESULT hr;

    CLicServer *pServer;
       
    GetActiveServer( &pServer );


    if( pMenu == NULL )
    {
        return;
    }

    UINT uMF = MF_GRAYED | MF_DISABLED;

    if( pServer != NULL )
    {
        if( pServer->GetConType() != CONNECTION_WWW )
        {
            DBGMSG( L"LICMGR:UI_initmenu server contype is not www\n" , 0 );

            uMF = MF_ENABLED;
        }
    }

    BOOL bEnable = IsServerRegistered( &hr );

    if( nt == NODE_SERVER )
    {   
        if( bEnable )
        {
            if( FAILED( hr ) )
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_ENABLED );
            }
            else
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_GRAYED | MF_DISABLED );
            }            

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_REACTIVATESERVER , uMF );

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_DEACTIVATESERVER , uMF );

            pMenu->EnableMenuItem( ID_LPK_PROPERTIES , MF_ENABLED );

            if( IsLicensesDownLoaded() )
            {
                pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_ENABLED );

                pMenu->EnableMenuItem( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , uMF );
            }
            else
            {
                pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_ENABLED );

                pMenu->EnableMenuItem( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , MF_GRAYED | MF_DISABLED  );
            }

        }
        else 
        {
            if( SUCCEEDED( hr ) )
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_ENABLED );
            }
            else
            {
                pMenu->EnableMenuItem( ID_SVR_ACTIVATESERVER , MF_DISABLED | MF_GRAYED );
            }

            if( pServer != NULL )
            {
                if( pServer->GetServerType( ) == SERVER_TS5_ENFORCED )
                {
                    pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_GRAYED | MF_DISABLED  );

                    pMenu->EnableMenuItem( ID_LPK_PROPERTIES , MF_ENABLED );
                    
                }
                else
                {
                    pMenu->EnableMenuItem( ID_LPK_DOWNLOADLICENSES , MF_ENABLED );

                    pMenu->EnableMenuItem( ID_LPK_PROPERTIES , MF_GRAYED | MF_DISABLED );
                }
            }

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , MF_GRAYED | MF_DISABLED  );    
            
            pMenu->EnableMenuItem( ID_LPK_ADVANCED_REACTIVATESERVER , MF_GRAYED | MF_DISABLED );

            pMenu->EnableMenuItem( ID_LPK_ADVANCED_DEACTIVATESERVER , MF_GRAYED | MF_DISABLED );

            
        }
        
    }
    else if( nt == NODE_KEYPACK )
    {

        if( bEnable )
        {
            if( IsLicensesDownLoaded() )
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_ENABLED );
                pMenu->EnableMenuItem( ID_LICPAK_REPEATDOWNLOAD , uMF );
            }
            else
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_ENABLED );
                pMenu->EnableMenuItem( ID_LICPAK_REPEATDOWNLOAD , MF_GRAYED | MF_DISABLED  );
            }
        }
        else 
        {
            if( pServer != NULL && pServer->GetServerType() == SERVER_TS5_ENFORCED )
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_GRAYED | MF_DISABLED  );                
            }
            else
            {
                pMenu->EnableMenuItem( ID_LICPAK_DOWNLOADLICENSES , MF_ENABLED  );                
            }

            pMenu->EnableMenuItem( ID_LICPAK_REPEATDOWNLOAD , MF_GRAYED | MF_DISABLED  );            
        }
        
    }
    else if( nt == NODE_ALL_SERVERS )
    {
        pMenu->EnableMenuItem( ID_ALLSVR_REFRESHALL , MF_ENABLED );
        
    }
    /*
    else if( nt == NODE_NONE )
    {
        // this can only mean licenses
        
        if( !IsLicensesDownLoaded( ) )
        {
        pMenu->EnableMenuItem( ID_LIC_DOWNLOADLICENSES , MF_GRAYED | MF_DISABLED );
        }
    }
    */

}

//------------------------------------------------------------------------------------
void CMainFrame::OnDownLoadLicenses( )
{
    BOOL bF;

    CLicServer *pLicServer = NULL;

    GetActiveServer( &pLicServer );

    if( pLicServer != NULL )
    {
        if( pLicServer->GetServerType() == SERVER_TS5_ENFORCED )
        {
            DWORD dw = WizardActionOnServer( WIZACTION_DOWNLOADLKP , &bF , NOVIEW );

            DBGMSG( L"LICMGR : OnDownLoadLicenses returned 0x%x\n " , dw );
        }
        else
        {
            AddKeyPackDialog(NULL);
        }
    }
    
}

//------------------------------------------------------------------------------------
void CMainFrame::OnRepeatLastDownLoad( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_DOWNLOADLASTLKP , &bF , NOVIEW );

    DBGMSG( L"LICMGR : OnRepeatLastDownLoad returned 0x%x\n " , dw );
}
   
//------------------------------------------------------------------------------------
void CMainFrame::OnReRegisterServer( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_REREGISTERLS , &bF , NOVIEW );

    DBGMSG( L"LICMGR : OnReRegisterServer returned 0x%x\n " , dw );
}

//------------------------------------------------------------------------------------
void CMainFrame::OnUnRegisterServer( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_UNREGISTERLS , &bF , NOVIEW );

    DBGMSG( L"LICMGR : OnUnRegisterServer returned 0x%x\n " , dw );

}

//------------------------------------------------------------------------------------
void CMainFrame::OnProperties( )
{
    BOOL bF;

    DWORD dw = WizardActionOnServer( WIZACTION_SHOWPROPERTIES , &bF , NOVIEW );

    DBGMSG( L"LICMGR : CMainFrame -- OnProperties returned 0x%x\n", dw );
}

//------------------------------------------------------------------------------------
BOOL CMainFrame::IsLicensesDownLoaded( )
{
    CLicServer * pLicServer = NULL;
    
    if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
    {
        if( pLicServer != NULL )
        {
            if( pLicServer->GetConType( ) != CONNECTION_PHONE )
            {
                DBGMSG( L"Licmgr CMainFrame::IsLicensesDownLoaded GetConnectionType internet - www base\n" , 0 );
                
                return pLicServer->IsLicsDownloaded( );
            }
            else
            {
                return FALSE;
            }            
        }
    }

    return FALSE;
}

//------------------------------------------------------------------------------------
DWORD CMainFrame::WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh , VIEW vt )
{
    CLicMgrLeftView * pLeftView = (CLicMgrLeftView *)m_pLeftView;

    CTreeCtrl& TreeCtrl = pLeftView->GetTreeCtrl();

    CRightList * pRightView = (CRightList *)m_pRightView;

    CLicServer *pServer = NULL;

    if( vt == TREEVIEW )
    {

        CTreeNode *pNode = (CTreeNode *)TreeCtrl.GetItemData( pLeftView->GetRightClickedItem() );

        if( pNode->GetNodeType() == NODE_SERVER )
        {
            pServer = static_cast< CLicServer * >( pNode->GetTreeObject() );
        }
        else if( pNode->GetNodeType( ) == NODE_KEYPACK )
        {
            CKeyPack *pKeyPack = static_cast< CKeyPack *>( pNode->GetTreeObject() );

            if( pKeyPack != NULL )
            {
                pServer = pKeyPack->GetServer( );
            }
        }
    }
    else if( vt == LISTVIEW )
    {
        CListCtrl& listctrl = pRightView->GetListCtrl();
        
        CLicMgrDoc * pDoc = ( CLicMgrDoc * )( GetActiveView()->GetDocument( ) );
        
        ASSERT(pDoc);
        
        if(NULL == pDoc)
        {
            return ERROR_INVALID_PARAMETER;
        }
       
        int nSelected = listctrl.GetNextItem(-1, LVNI_SELECTED);

        if( -1 != nSelected)
        {
            DWORD_PTR dCurrSel = listctrl.GetItemData( nSelected );

            if( NODE_ALL_SERVERS == pDoc->GetNodeType() )
            {  
                pServer = reinterpret_cast< CLicServer * >( dCurrSel );
            }        
            else if( pDoc->GetNodeType() == NODE_SERVER )
            {
                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack *>( dCurrSel );

                if( pKeyPack != NULL )
                {
                    pServer = pKeyPack->GetServer( );
                }
            }
            else if( pDoc->GetNodeType( ) == NODE_KEYPACK )
            {
                CLicense * pLicense = reinterpret_cast< CLicense * >( dCurrSel );

                pServer = ( pLicense->GetKeyPack() )->GetServer( );
            }
        }
    }
    else if( vt == NOVIEW )
    {
        CLicServer * pLicServer = NULL;
        
        if( SUCCEEDED( GetActiveServer( &pLicServer ) ) )
        {
            pServer = pLicServer;
        }
    }


    if( pServer != NULL )
    {            
        DWORD dw = ERROR_SUCCESS;
        
        // check for admin 
        if( !pServer->IsUserAdmin( ) )
        {
            AfxMessageBox( IDS_E_ACCESSDENIED );
            //::MessageBox( GetSafeHwnd( ) , L"Unable to perform operation: Access denied" , L"Terminal Services Licensing" , MB_OK|MB_ICONINFORMATION );

            return ERROR_ACCESS_DENIED;
        }

        if( wa != WIZACTION_REGISTERLS )
        {
            if( pServer->GetServerType() == SERVER_TS5_ENFORCED )
            {
                DBGMSG( L"LICMGR:CMainFrame::WizardActionOnServer calling StartWizard\n", 0 );

                dw = StartWizard( GetSafeHwnd( ) , wa , (LPCTSTR)pServer->GetName( ) , pbRefresh );

                DBGMSG( L"StartWizard ( central call ) returned 0x%x\n", dw );

                DBGMSG( L"StartWizard ( central call ) refresh = %s\n", *pbRefresh ? L"true" : L"false" );

                if( *pbRefresh )
                {
                    RefreshServer( pServer );
                }
            }
            else
            {
                if( wa == WIZACTION_DOWNLOADLKP )
                {
                    AddKeyPackDialog(NULL);
                }
            }
        }

        
        switch( wa  )
        {           

        case WIZACTION_REGISTERLS:

            // this handles non-enforced as well.
            OnRegistration( );
            break;

        case WIZACTION_UNREGISTERLS : 
            
            if( dw == ERROR_SUCCESS )
            {
                pServer->SetDownLoadLics( FALSE );
            }

            // FALL THROUGH

        case WIZACTION_REREGISTERLS :
            {
                DWORD dwStatus;

                if( IsLicenseServerRegistered( GetSafeHwnd( ) , (LPCTSTR)pServer->GetName( ) , &dwStatus ) == ERROR_SUCCESS )
                {
                    pServer->SetServerRegistrationStatus( dwStatus );
                }
            }
            break;
        }

        return dw;            
    }

    return ERROR_INVALID_PARAMETER;
}

//------------------------------------------------------------------------------------    
BOOL CMainFrame::IsDownLoadedPacks( CLicServer *pServer )
{
    UINT counter = 0;

    if( pServer != NULL )
    {
        KeyPackList *pKeyPackList = pServer->GetKeyPackList( );

        if( pKeyPackList != NULL )
        {
            POSITION pos = pKeyPackList->GetHeadPosition();
            
            while(pos)
            {
                CKeyPack *pKeyPack = (CKeyPack *)pKeyPackList->GetNext(pos);

                if( pKeyPack != NULL )
                {
                    if( pKeyPack->GetKeyPackStruct().ucKeyPackType != LSKEYPACKTYPE_TEMPORARY &&
                        pKeyPack->GetKeyPackStruct().ucKeyPackType != LSKEYPACKTYPE_FREE )
                    {
                        counter++;

                        DBGMSG( L"LICMGR:CMainFrame found %d keypack(s)\n" , counter );
                    }
                }
            }

            if( counter >= 1 )
            {
                DBGMSG( L"LICMGR : CMainFrame IsDownLoadedPacks returns true\n" ,0 );
                return TRUE;
            }
        }
    }

    DBGMSG( L"LICMGR : CMainFrame IsDownLoadedPacks returns false \n" ,0 );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\mainfrm.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:    

    MainFrm.h 

Abstract:
    
    This Module defines the CMainFrame(The Frame Window of the application) class

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#if !defined(AFX_MAINFRM_H__72451C6F_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_MAINFRM_H__72451C6F_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#include "lrwizapi.h"
class CLicServer;
class CKeyPack;
class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
public:
    void 
    EnumFailed(
        HRESULT reason, 
        CLicServer * pLicServer
    );

    BOOL 
    IsUserAdmin(
        CString& Server
    );

    void 
    SetTreeViewSel(
        LPARAM lParam,
        NODETYPE NodeType
    );

    void 
    DeleteServer(
        LicServerList * pLicServerList,
        POSITION TempPos, 
        CLicServer * pLicServer
    );

    HRESULT 
    AddLicensestoList(
        CKeyPack * pKeyPack,
        CListCtrl * pListCtrl, 
        BOOL bRefresh
    );

    HRESULT 
    AddKeyPackDialog(
        CLicServer * pServer
    );

    HRESULT 
    GetLicServer(
        CString * pLicServer
    );

    void 
    PressButton(
        UINT uId, 
        BOOL bPress
    );

    HRESULT 
    AddLicenses(
        CKeyPack * pKeyPack,
        UINT nLicenses
    );

    HRESULT 
    RemoveLicenses(
        CKeyPack * pKeyPack,
        UINT nLicenses
    );

    HRESULT 
    GetActiveServer(
        CLicServer ** ppServer
        )
    {
        *ppServer = m_pServer;

        if( m_pServer == NULL )
        {
            return E_FAIL;
        }

        return S_OK;
    }

    BOOL IsDownLoadedPacks( CLicServer *pServer );

    HRESULT 
    RefreshServer(
        CLicServer * pLicServer
    );

    void SelectView(VIEW);

    void ConnectAndDisplay();

    CSplitterWnd m_SplitterWnd;

    BOOL 
    ConnectServer(
        LPCTSTR pszServer=NULL
    );

    BOOL IsServerRegistered( 
        HRESULT *phrStatus
    );

    
    BOOL IsLicensesDownLoaded( );
    

    void UI_initmenu( CMenu *pMenu , NODETYPE nt );

    DWORD WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh , VIEW );

    void OnRefresh();
    void OnHelp( );
    void OnRefreshServer( );

    void OnDownLoadLicenses( );
    void OnRepeatLastDownLoad( );
    void OnReRegisterServer( );
    void OnUnRegisterServer( );

    void SetActiveServer( CLicServer *pServer )
    {
        m_pServer = pServer;        
    }

private:

    CLicServer *m_pServer;
    // BOOL m_fDownloadedLicenses;    

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    CView * m_pRightView;
    CView * m_pLeftView;
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LRESULT OnSelChange(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddAllServers(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAddKeyPack(WPARAM wParam, LPARAM lParam);
    afx_msg void OnLargeIcons();
    afx_msg void OnSmallIcons();
    afx_msg void OnList();
    afx_msg void OnDetails();
    afx_msg void OnExit();
    afx_msg void OnAppAbout();
    afx_msg void OnConnectServer();
    afx_msg void OnUpdateAddNewKeyPack(CCmdUI * pCmdUI);
    afx_msg void OnRegistration();    
    afx_msg void OnProperties( );
    afx_msg LRESULT OnEnumerateServer(WPARAM wParam, LPARAM lParam);       
    afx_msg void OnUpdateDownloadlicenses( CCmdUI * pCmdUI );
    afx_msg void OnUpdateRepeatLastDownload( CCmdUI * pCmdUI ); 
    afx_msg void OnUpdateReregisterserver( CCmdUI * pCmdUI );
    afx_msg void OnUpdateUnregisterserver( CCmdUI * pCmdUI );
    afx_msg void OnUpdateRefresh( CCmdUI *pCmdUI );
    afx_msg void OnUpdateProperties( CCmdUI *pCmdUI );
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};    

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__72451C6F_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\lsserver.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

    LSServer.h 

Abstract:
    
    This Module defines the CKeyPack, CLicense, CLicServer and CAllServers classes for the License Manager

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#ifndef _LICSERVER_H_
#define _LICSERVER_H_

#include <afxtempl.h> 

#include <lrwizapi.h>
//struct LSLicens

class CLicServer;
class CLicense;

typedef CList<CLicense *,CLicense *> IssuedLicenseList;

////////////////////////////////////////////////////////////

class CKeyPack: public CObject
{
private:

    HTREEITEM m_hTreeItem;
    BOOL m_bIsExpanded;
    CString m_DisplayName; //Have added this field as the KeyPackId 
                           //does not make much sense to the user.
    LSKeyPack m_KeyPack;
    CLicServer *m_pLicServer;
    IssuedLicenseList m_IssuedLicenseList;

public:
    void
    PurgeCache();

    void 
    SetTreeItem(
        HTREEITEM hTreeItem
        ) 
    {
        m_hTreeItem = hTreeItem;
    };

    HTREEITEM 
    GetTreeItem()
    {
        return m_hTreeItem;
    };

    ~CKeyPack();
    CKeyPack(LSKeyPack &KeyPack);

    LSKeyPack& 
    GetKeyPackStruct()
    {
        return m_KeyPack;
    };

    IssuedLicenseList *
    GetIssuedLicenseList()
    {
        return &m_IssuedLicenseList;
    };

    HRESULT
    RefreshIssuedLicenses(
        LSLicense* pLicenses = NULL,
        DWORD dwFreshParm = 0,
        BOOL bMatchAll = FALSE
    );

    void 
    AddIssuedLicense(
        CLicense * pIssuedLicense
    );

    CLicServer *
    GetServer()
    {
        return m_pLicServer;
    };

    void 
    SetServer(
        CLicServer *pLicServer
        )
    {
        m_pLicServer = pLicServer;
    };

    BOOL 
    IsExpanded ()
    {
        return m_bIsExpanded;
    };

    void 
    Expand(BOOL bExpand)
    { 
        m_bIsExpanded = bExpand;
    };

    CString 
    GetDisplayName()
    {
        return m_DisplayName;
    };

    void 
    SetDisplayName(
        CString DisplayName
        )
    { 
        m_DisplayName = DisplayName;
    };
};

typedef CKeyPack * PKEYPACK;


class CLicense: public CObject
{
private:
    LSLicenseEx m_License;
    CKeyPack *m_pKeyPack;

public:


    ~CLicense();
    CLicense(LSLicenseEx& License);

    LSLicenseEx& 
    GetLicenseStruct()
    {
        return m_License;
    };

    CKeyPack *
    GetKeyPack()
    {
        return m_pKeyPack;
    };

    void 
    SetKeyPack(
        CKeyPack *pKeyPack
        )
    {
        m_pKeyPack = pKeyPack;
    };
};

typedef CLicense * PLICENSE;

typedef CList<CKeyPack *,CKeyPack *> KeyPackList;

////////////////////////////////////////////////////////////

class CLicServer : public CObject
{
private:
    CString m_ServerName;
    CString m_ServerScope;
    CString m_IpAddress;
	SERVER_TYPE m_ServerType;
	CString m_DisplayName;
    HTREEITEM m_hTreeItem;
    KeyPackList m_KeyPackList;
    BOOL m_bIsExpanded;
    BOOL m_bUseIpAddress;
    PCONTEXT_HANDLE m_hContext;
    DWORD m_dwRegStatus;
    BOOL m_fDownloadedLicenses;
    BOOL m_bAdmin;
    WIZCONNECTION m_wizcon;


public:

    void 
    SetContext(
        PCONTEXT_HANDLE hContext
    );

    PCONTEXT_HANDLE 
    GetContext();

    CLicServer(
        CString& Name, 
        SERVER_TYPE ServerType,
        CString& Scope = (CString)_T(""),
        CString& IpAddress = (CString)_T(""),
        PCONTEXT_HANDLE hBinding = NULL
    );

    // destructor
    ~CLicServer();

    
    DWORD GetServerRegistrationStatus()
    {
        return m_dwRegStatus;
    }

    void
    SetServerRegistrationStatus(
        DWORD  dwStatus
        )
    /*++

    --*/
    {
        m_dwRegStatus = dwStatus;
    }
    
    HTREEITEM 
    GetTreeItem() 
    { 
        return m_hTreeItem; 
    }

    // Sets the tree item handle
    void 
    SetTreeItem(
        HTREEITEM handle
        ) 
    { 
        m_hTreeItem = handle; 
    }

    CString& 
    GetName() 
    { 
        return m_ServerName;
    };

	CString& 
    GetDisplayName()
    {
        return m_DisplayName;
    };

    CString& 
    GetIpAddress()
    {
        return m_IpAddress;
    };

	SERVER_TYPE 
    GetServerType()
    {
        return m_ServerType;
    };

    KeyPackList * 
    GetKeyPackList()
    {
        return &m_KeyPackList;
    };

    void 
    AddKeyPack(
        CKeyPack * pKeyPack
    );

    BOOL 
    IsExpanded ()
    {
        return m_bIsExpanded;
    };

    BOOL 
    UseIpAddress()
    {
        return m_bUseIpAddress;
    };

    void 
    Expand (
        BOOL bExpand
        )
    { 
        m_bIsExpanded = bExpand;
    };

    CString& 
    GetScope() 
    { 
        return m_ServerScope;
    };

    HRESULT
    RefreshCachedKeyPack();

    void
    PurgeCache();

    void SetDownLoadLics( BOOL bF )
    {
        m_fDownloadedLicenses = bF;
    }

    void SetConType( WIZCONNECTION x )
    {
        m_wizcon = x ;
    }

    WIZCONNECTION GetConType( ) const
    {
        return m_wizcon;
    }


    BOOL IsLicsDownloaded( void )
    {
        return m_fDownloadedLicenses;
    }

    void SetAdmin( BOOL  b )
    {
        m_bAdmin = b;
    }

    BOOL IsUserAdmin( )
    {
        return m_bAdmin;
    }
};


typedef CLicServer * PLICSERVER;

typedef CList<CLicServer *,CLicServer *> LicServerList;

////////////////////////////////////////////////////////////
class CAllServers : public CObject
{
private:

    HTREEITEM m_hTreeItem;
    LicServerList m_LicServerList;
    CString m_Name;

public:
    
    CAllServers(CString Name);   

    // destructor
    ~CAllServers();
    
    HTREEITEM 
    GetTreeItem() 
    {   
        return m_hTreeItem; 
    }

    // Sets the tree item handle
    void 
    SetTreeItem(
        HTREEITEM handle
        ) 
    /*++

    --*/
    { 
        m_hTreeItem = handle; 
    }

    LicServerList *
    GetLicServerList()
    {
        return &m_LicServerList;
    };

    void 
    AddLicServer(CLicServer * pLicServer);

    CString& 
    GetName() 
    { 
        return m_Name;
    };
};


#endif //_LICSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\remlic.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
 
Module Name:

    RemLic.cpp

Abstract:
    
    This Module contains the implementation of the CRemoveLicenses Dialog class
    (Dialog box used for adding keypacks)

Author:

    Arathi Kundapur (v-akunda) 22-Feb-1998

Revision History:

--*/


#include "stdafx.h"
#include "licmgr.h"
#include "defines.h"
#include "lsserver.h"
#include "addkp.h"
#include "RemLic.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRemoveLicenses dialog


CRemoveLicenses::CRemoveLicenses(CWnd* pParent /*=NULL*/)
    : CDialog(CRemoveLicenses::IDD, pParent)
{
    //{{AFX_DATA_INIT(CRemoveLicenses)
        // NOTE: the ClassWizard will add member initialization here
    m_LicensePack = _T("");
    m_NumLicenses = 0;
    m_pAddKeyPack = NULL;
    //}}AFX_DATA_INIT
}

CRemoveLicenses::CRemoveLicenses(CAddKeyPack * pAddKeyPack,CWnd* pParent /*=NULL*/)
    : CDialog(CRemoveLicenses::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddLicenses)
    m_LicensePack = _T("");
    m_NumLicenses = 0;
    m_pAddKeyPack = pAddKeyPack;
    //}}AFX_DATA_INIT
}


void CRemoveLicenses::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRemoveLicenses)
    DDX_Control(pDX, IDC_SPIN_LICNESES, m_SpinCtrl);
    DDX_Control(pDX, IDC_LICNESE_PACK, m_LicenseCombo);
    DDX_CBString(pDX, IDC_LICNESE_PACK, m_LicensePack);
    DDX_Text(pDX, IDC_NUM_LICENSES, m_NumLicenses);
    DDV_MinMaxDWord(pDX, m_NumLicenses, 0, 9999);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemoveLicenses, CDialog)
    //{{AFX_MSG_MAP(CRemoveLicenses)
    ON_CBN_SELCHANGE(IDC_LICNESE_PACK, OnSelchangeLicnesePack)
    ON_BN_CLICKED(IDC_HELP4, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRemoveLicenses message handlers

BOOL CRemoveLicenses::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
    CString ProdDesc;

    if(NULL == m_pAddKeyPack)
        return FALSE;

    int nCount = m_pAddKeyPack->m_LicenseCombo.GetCount( );
    for(int i = 0; i < nCount; i++)
    {
        m_pAddKeyPack->m_LicenseCombo.GetLBText(i,ProdDesc);
        m_LicenseCombo.AddString(ProdDesc);
    }

    m_LicenseCombo.SetCurSel(m_pAddKeyPack->m_LicenseCombo.GetCurSel());

    m_SpinCtrl.SetBase(10);
    m_SpinCtrl.SetRange(1,MAX_LICENSES);
    m_SpinCtrl.SetPos(1);

    OnSelchangeLicnesePack();

    
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CRemoveLicenses::OnSelchangeLicnesePack() 
{
    // TODO: Add your control notification handler code here
    UpdateData();
    UINT uMaxLicenses = 0;
    //Get the Current Selection.

    int nSelection = m_LicenseCombo.GetCurSel( );

    //Get the Product Description.

    CString ProdDesc;

    m_LicenseCombo.GetLBText(nSelection,ProdDesc);

    //Search and pickup the keypack with this product description.
    //Set the Edit box to display the total licenses.

    POSITION pos = m_pAddKeyPack->m_pKeyPackList->GetHeadPosition();
    while(pos)
    {
        CKeyPack *pKeyPack = (CKeyPack *)m_pAddKeyPack->m_pKeyPackList->GetNext(pos);
        if(NULL == pKeyPack)
            break;
        LSKeyPack sKeyPack = pKeyPack->GetKeyPackStruct();
        
        if(0 == ProdDesc.CompareNoCase(sKeyPack.szProductDesc))
        {
           uMaxLicenses = sKeyPack.dwNumberOfLicenses;
           break;
        }
     }
   
    if(uMaxLicenses < MAX_LICENSES)
    {
        m_SpinCtrl.SetRange(1,uMaxLicenses);
    }
    else
    {
        m_SpinCtrl.SetRange(1,MAX_LICENSES);
    }
    GetDlgItem(IDOK)->EnableWindow(uMaxLicenses); 
    GetDlgItem(IDC_NUM_LICENSES)->EnableWindow(uMaxLicenses); 
    if(0 == uMaxLicenses)
        m_NumLicenses = 0;
    else
        m_NumLicenses = 1;
    UpdateData(FALSE);
    return;
    
}

void CRemoveLicenses::OnHelp() 
{
    // TODO: Add your control notification handler code here
    AfxGetApp()->WinHelp(IDC_HELP4,HELP_CONTEXT );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\remlic.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++


  
Module Name:

	RemLic.h

Abstract:
    
    This Module defines the CRemoveLicenses Dialog class
    (Dialog box used for Removing Licenses)

Author:

    Arathi Kundapur (v-akunda) 22-Feb-1998

Revision History:

--*/

#if !defined(AFX_REMLIC_H__610F173F_A990_11D1_84DD_00C04FB6CBB5__INCLUDED_)
#define AFX_REMLIC_H__610F173F_A990_11D1_84DD_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000
// RemLic.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRemoveLicenses dialog

class CRemoveLicenses : public CDialog
{
// Construction
private:
	CAddKeyPack * m_pAddKeyPack;

public:
	CRemoveLicenses(CWnd* pParent = NULL);   // standard constructor
    CRemoveLicenses(CAddKeyPack *pAddKeyPack,CWnd* pParent = NULL);


// Dialog Data
	//{{AFX_DATA(CRemoveLicenses)
	enum { IDD = IDD_REMOVE_LICENSES };
    CSpinButtonCtrl	m_SpinCtrl;
    CComboBox m_LicenseCombo;
	CString	m_LicensePack;
	DWORD	m_NumLicenses;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRemoveLicenses)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRemoveLicenses)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeLicnesePack();
    afx_msg void OnHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMLIC_H__610F173F_A990_11D1_84DD_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//LicMgr.pch will be the pre-compiled header
//stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\servprop.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
  
Module Name:

	ServProp.cpp

Abstract:
    
    This Module contains the implementation of CServerProperties Dialog class
    (The Dialog used to disply server properties)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "LicMgr.h"
#include "ServProp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServerProperties property page

IMPLEMENT_DYNCREATE(CServerProperties, CPropertyPage)

CServerProperties::CServerProperties() : CPropertyPage(CServerProperties::IDD)
{
    //{{AFX_DATA_INIT(CServerProperties)
    m_ServerName = _T("");
    m_Scope = _T("");
    //}}AFX_DATA_INIT
}

CServerProperties::~CServerProperties()
{
}

void CServerProperties::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServerProperties)
    DDX_Text(pDX, IDC_SCOPE, m_Scope);
    DDX_Text(pDX, IDC_SERVER_NAME, m_ServerName);
    
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerProperties, CPropertyPage)
    //{{AFX_MSG_MAP(CServerProperties)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerProperties message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__72451C6D_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
#define AFX_STDAFX_H__72451C6D_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_

#if _MSC_VER >= 1000
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>            // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#ifdef DBG

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[250]; \
    wsprintf( tchErr , x , y ); \
    OutputDebugString( tchErr ); \
    }

#else

#define DBGMSG( x , y )

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__72451C6D_887E_11D1_8AD1_00C04FB6CBB5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\license\licmgr\rtlist.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*++
  
Module Name:

    RtList.cpp

Abstract:
    
    This Module contains the implementation of CRightList class
    (The View class used for the Right pane of the splitter)

Author:

    Arathi Kundapur (v-akunda) 11-Feb-1998

Revision History:

--*/

#include "stdafx.h"
#include "LicMgr.h"
#include "defines.h"
#include "LSServer.h"
#include "RtList.h"
#include "Mainfrm.h"



#include "LSmgrdoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern int GetStatusPosition( CLicense *pLic );
/////////////////////////////////////////////////////////////////////////////
// CRightList

IMPLEMENT_DYNCREATE(CRightList, CListView)

CRightList::CRightList()
{

}

CRightList::~CRightList()
{
   m_ImageListLarge.DeleteImageList();
   m_ImageListSmall.DeleteImageList();
}


BEGIN_MESSAGE_MAP(CRightList, CListView)
    //{{AFX_MSG_MAP(CRightList)
    ON_MESSAGE(WM_SEL_CHANGE, OnSelChange)
    ON_COMMAND(ID_LARGE_ICONS, OnLargeIcons)
    ON_COMMAND(ID_SMALL_ICONS, OnSmallIcons)
    ON_COMMAND(ID_LIST, OnList)
    ON_COMMAND(ID_DETAILS, OnDetails)
    ON_MESSAGE(WM_ADD_SERVER, OnAddServer)
    ON_MESSAGE(WM_DELETE_SERVER, OnDeleteServer)
    ON_MESSAGE(WM_UPDATE_SERVER, OnUpdateServer)
    ON_MESSAGE(WM_ADD_KEYPACK, OnAddKeyPack)
    ON_COMMAND(ID_ADD_LICENSES, OnAddNewKeyPack)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
    ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeydown)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
    ON_NOTIFY_REFLECT(NM_CLICK , OnLeftClick )

    
    // server menuitems
        
    // all server menus
    ON_WM_CONTEXTMENU()
    // ON_COMMAND( ID_LPK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LPK_REFRESHALL , OnRefreshAllServers )
   
    // server menuitems

    // ON_COMMAND( ID_LPK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LPK_REFRESH , OnRefreshServer )
    ON_COMMAND( ID_LPK_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_LPK_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_SVR_ACTIVATESERVER , OnRegisterServer )
    ON_COMMAND( ID_LPK_ADVANCED_REPEATLASTDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LPK_ADVANCED_REACTIVATESERVER , OnReactivateServer )
    ON_COMMAND( ID_LPK_ADVANCED_DEACTIVATESERVER , OnDeactivateServer )
    ON_COMMAND( ID_LPK_PROPERTIES , OnServerProperties )
    ON_COMMAND( ID_LPK_HELP , OnGeneralHelp )

    // license pak items

    // ON_COMMAND( ID_LICPAK_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LICPAK_REFRESH , OnRefreshServer )
    // ON_COMMAND( ID_LICPAK_REFRESHALL , OnRefreshAllServers )
    ON_COMMAND( ID_LICPAK_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_LICPAK_REPEATDOWNLOAD , OnRepeatLastDownload )
    ON_COMMAND( ID_LICPAK_HELP , OnGeneralHelp )

    

    // license pak items
    
    // license items

    /*  removed from spec
    
    ON_COMMAND( ID_LIC_CONNECT , OnServerConnect )
    ON_COMMAND( ID_LIC_REFRESH , OnRefreshServer )
    ON_COMMAND( ID_LIC_DOWNLOADLICENSES , OnDownloadKeepPack )
    ON_COMMAND( ID_LIC_HELP , OnGeneralHelp )

    */
     
        
    //}}AFX_MSG_MAP
    
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRightList drawing

void CRightList::OnDraw(CDC* pDC)
{
    CDocument* pDoc = GetDocument();
    // TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CRightList diagnostics

#ifdef _DEBUG
void CRightList::AssertValid() const
{
    CListView::AssertValid();
}

void CRightList::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRightList message handlers

LRESULT CRightList::OnSelChange(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    BOOL bChangeColumns = FALSE;

    CLicMgrDoc * pDoc = (CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    CLicServer * pLicServer = NULL;
    CKeyPack * pKeyPack = NULL;
        
    CListCtrl& ListCtrl = GetListCtrl();
    ListCtrl.DeleteAllItems();
    NODETYPE CurNodeType = ((CLicMgrDoc *)GetDocument())->GetNodeType();

     if(CurNodeType != (NODETYPE)wParam)
     {
          bChangeColumns = TRUE;
          pDoc->SetNodeType((NODETYPE)wParam);
     }

     switch(wParam)
     {
        case NODE_ALL_SERVERS:
            if(bChangeColumns)
                SetServerColumns();
            AddServerstoList();

            SetActiveServer( NULL );
            
            break;

        case NODE_SERVER:
            pLicServer = (CLicServer *)lParam;
            ASSERT(pLicServer);
            if(NULL == pLicServer)
                break;
            if(bChangeColumns)
                SetKeyPackColumns();
         /*   if(FALSE == pLicServer->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateKeyPacks(pLicServer,LSKEYPACK_SEARCH_LANGID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pLicServer);
                    break;
                }
            
            }*/
            SetActiveServer( pLicServer );

            AddKeyPackstoList((CLicServer *)lParam);
            SetCursor(LoadCursor(NULL,IDC_ARROW));
            break;

         case NODE_KEYPACK:
            pKeyPack = (CKeyPack *)lParam;
            ASSERT(pKeyPack);
            if(NULL == pKeyPack)
                break;
            if(bChangeColumns)
                SetLicenseColumns();
            /*if(FALSE == pKeyPack->IsExpanded())
            {
                SetCursor(LoadCursor(NULL,IDC_WAIT));
                HRESULT hResult = pDoc->EnumerateLicenses(pKeyPack,LSLICENSE_SEARCH_KEYPACKID, TRUE);
                if(hResult != S_OK)
                {
                    ((CMainFrame *)AfxGetMainWnd())->EnumFailed(hResult,pKeyPack->GetServer());
                    break;
                }
            
            }*/

            SetActiveServer( pKeyPack->GetServer( ) );

            ((CMainFrame *)AfxGetMainWnd())->AddLicensestoList(
                                                        (CKeyPack *)lParam,
                                                        &ListCtrl, 
                                                        FALSE
                                                    );
            SetCursor(LoadCursor(NULL,IDC_ARROW));
            break;
        }

    return lResult;
}


HRESULT CRightList::AddServerstoList()
{
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();

    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return E_FAIL;
    }


    //Get the List Control
    CListCtrl& ListCtrl = GetListCtrl();

    CString TempString;
    CString StatusString;

    LicServerList * licserverlist = NULL;
    int nIndex = 0;

    CAllServers *pAllServer = pDoc->GetAllServers();
    if(NULL == pAllServer)
    {
        goto cleanup;
    }

    licserverlist =  pAllServer->GetLicServerList();

    LV_ITEM lvI;
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    // lvI.iImage = 0;

    POSITION pos;
    pos = licserverlist->GetHeadPosition();
    while(pos)
    {
        //Display the Server Name

        DWORD dwServerStatus;

        lvI.iItem = nIndex;
        lvI.iSubItem = 0;
        CLicServer * pLicServer = licserverlist->GetNext(pos);
        lvI.lParam = (LPARAM)pLicServer;
        TempString = pLicServer->GetName();
        lvI.pszText = TempString.GetBuffer(TempString.GetLength());
        lvI.cchTextMax =lstrlen(lvI.pszText + 1);

        dwServerStatus = pLicServer->GetServerRegistrationStatus();
            

        if(pLicServer->GetServerType() == SERVER_TS5_ENFORCED)
        {
            if( dwServerStatus == LSERVERSTATUS_REGISTER_INTERNET 
                ||
               dwServerStatus == LSERVERSTATUS_REGISTER_OTHER  )
            {
                StatusString.LoadString(IDS_SERVER_REGISTERED);

                lvI.iImage = 3;
            }
            else if( dwServerStatus == LSERVERSTATUS_WAITFORPIN )
            {
                StatusString.LoadString(IDS_SERVER_WAITFORPIN);

                lvI.iImage = 4;
            }
            else if( dwServerStatus == LSERVERSTATUS_UNREGISTER )
            {
                lvI.iImage = 5;

                StatusString.LoadString(IDS_SERVER_UNREGISTER);
            }
            else
            {
                lvI.iImage = 6;

                StatusString.LoadString( IDS_UNKNOWN );
            }

        }
        else
        {
            StatusString.LoadString(IDS_SERVER_NOTREQUIRE);
            
            lvI.iImage = 0;            
        }

        //
        // Display registration status
        //

        nIndex = ListCtrl.InsertItem(&lvI);

        // ListCtrl.SetItemText(nIndex,1,(LPCTSTR)pLicServer->GetScope());
        ListCtrl.SetItemText(nIndex, 1, (LPCTSTR)StatusString);
        nIndex ++;
    }

    ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);

cleanup:
    return S_OK;

}

//----------------------------------------------------------------------
HRESULT 
CRightList::AddKeyPackstoList(
    CLicServer * pServer,
    BOOL bRefresh
    )
/*++

Abstract:


Parameter:

    bRefresh : TRUE if refresh licenses, FALSE otherwise.

--*/
{
    ASSERT(pServer);
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);

    if(NULL == pDoc || NULL == pServer)
    {
        return E_FAIL;
    }

    CListCtrl& ListCtrl = GetListCtrl();
    ULONG nIndex = 0;
    POSITION pos;
    int nSubItemIndex = 1;
    CString TempString;
    DWORD dwLicenses = 0;
    
    if(bRefresh == TRUE)
    {
        if(pServer->RefreshCachedKeyPack() != S_OK)
        {
            return E_FAIL;
        }
    }

    KeyPackList * keypacklist = pServer->GetKeyPackList();

    ULONG nNumKeyPacks = (ULONG)keypacklist->GetCount();

    if(0 == nNumKeyPacks)
    {
       goto cleanup;
    }

    pos = keypacklist->GetHeadPosition();

    for(nIndex = 0; nIndex < nNumKeyPacks; nIndex++)
    {
        CKeyPack * pKeyPack = keypacklist->GetNext(pos);
        if(NULL == pKeyPack)
        {
            continue;
        }

        AddKeyPack(ListCtrl, nIndex, pKeyPack);
    }

    ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);

cleanup:

    return S_OK;
}

HRESULT CRightList::SetServerColumns()
{
     CListCtrl& ListCtrl = GetListCtrl();
     for(int index = 0; index < MAX_COLUMNS; index++)
     {
      ListCtrl.DeleteColumn(0);
     }
    LV_COLUMN lvC;
    CString ColumnText;
    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM ;
    lvC.fmt = LVCFMT_LEFT;
    lvC.cx = 125;
    for(index = 0; index < NUM_SERVER_COLUMNS; index ++)
    {
        lvC.iSubItem = index;
        ColumnText.LoadString(IDS_SERVER_COLUMN1 + index);
        lvC.pszText = ColumnText.GetBuffer(ColumnText.GetLength());
        GetListCtrl().InsertColumn(index, &lvC);
    }

 return S_OK;
}


HRESULT CRightList::SetKeyPackColumns()
{
     CListCtrl& ListCtrl = GetListCtrl();
     for(int index = 0; index < MAX_COLUMNS; index++)
     {
      ListCtrl.DeleteColumn(0);
     }
     LV_COLUMN lvC;
     CString ColumnText;
     lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM ;
     lvC.fmt = LVCFMT_LEFT;
     lvC.cx = KEYPACK_DISPNAME_WIDTH;     
     for(index = 0; index < NUM_KEYPACK_COLUMNS; index ++)
     {
        lvC.iSubItem = index;
        ColumnText.LoadString(IDS_KEYPACK_COLUMN1 + index);
        lvC.pszText = ColumnText.GetBuffer(ColumnText.GetLength());
        ListCtrl.InsertColumn(index, &lvC);
        lvC.cx = KEYPACK_OTHERS_WIDTH;
     }

     return S_OK;
}

HRESULT CRightList::SetLicenseColumns()
{
    CListCtrl& ListCtrl = GetListCtrl();
    for(int index = 0; index < MAX_COLUMNS; index++)
    {
        ListCtrl.DeleteColumn(0);
    }
    LV_COLUMN lvC;
    CString ColumnText;
    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM ;
    lvC.fmt = LVCFMT_LEFT;
    lvC.cx = 125;
    for(index = 0; index < NUM_LICENSE_COLUMNS; index ++)
    {
        lvC.iSubItem = index;
        ColumnText.LoadString(IDS_LICENSE_COLUMN1 + index);
        lvC.pszText = ColumnText.GetBuffer(ColumnText.GetLength());
        ListCtrl.InsertColumn(index, &lvC);

    }

 return S_OK;
}



void CRightList::OnInitialUpdate() 
{
    CListView::OnInitialUpdate();

    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;

    //Create and set the image lists
     m_ImageListSmall.Create( SM_BITMAP_WIDTH,SM_BITMAP_HEIGHT,TRUE, 7, 7);

     m_ImageListLarge.Create( LG_BITMAP_WIDTH,LG_BITMAP_HEIGHT,TRUE, 7, 7);

     HICON hIcon = NULL;

     DWORD rgdwIDs[] = { IDI_SERVER , IDI_KEYPACK , IDI_LICENSE , IDI_SERVERREG , IDI_SERVERM , IDI_SERVERX , IDI_SERVERQ , (DWORD)-1 };

     int index = 0;

     while( rgdwIDs[ index ] != ( DWORD )-1 )
     {
         hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE( rgdwIDs[ index ] ) );

         if (NULL == hIcon)
         {
             ASSERT(!"LoadIcon Failed");
             continue;
         }

         m_ImageListSmall.Add(hIcon);
         m_ImageListLarge.Add(hIcon);
         
         /*
         if ((m_ImageListSmall.Add(hIcon) == -1) || (m_ImageListLarge.Add(hIcon) == -1))
             {
                 continue;    
             }
         }
         */

         ++index;
     }

     GetListCtrl().SetImageList(&m_ImageListSmall,LVSIL_SMALL);
     GetListCtrl().SetImageList(&m_ImageListLarge,LVSIL_NORMAL);  

     //Set the style
     GetListCtrl().ModifyStyle(0,LVS_REPORT | LVS_AUTOARRANGE | LVS_SINGLESEL | LVS_SORTASCENDING,0);

     GetListCtrl().SendMessage( LVM_SETEXTENDEDLISTVIEWSTYLE , LVS_EX_FULLROWSELECT , LVS_EX_FULLROWSELECT  );

     //Select details view by default
     CMenu *pMenu = pMainFrame->GetMenu();
     if(pMenu)
        pMenu->CheckMenuRadioItem(ID_DETAILS,ID_LIST, ID_DETAILS,MF_BYCOMMAND);
     pMainFrame->PressButton(ID_DETAILS,TRUE);

     //Display the server
     pMainFrame->ConnectAndDisplay();

}

void CRightList::OnLargeIcons() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_LIST|LVS_REPORT | LVS_SMALLICON,LVS_ICON,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_LARGE_ICONS,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,TRUE);
    pMainFrame->PressButton(ID_SMALL_ICONS,FALSE);
    pMainFrame->PressButton(ID_LIST,FALSE);
    pMainFrame->PressButton(ID_DETAILS,FALSE);
    return;
 
    
}

void CRightList::OnSmallIcons() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_LIST|LVS_ICON | LVS_REPORT,LVS_SMALLICON,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_SMALL_ICONS,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,FALSE);
    pMainFrame->PressButton(ID_SMALL_ICONS,TRUE);
    pMainFrame->PressButton(ID_LIST,FALSE);
    pMainFrame->PressButton(ID_DETAILS,FALSE);
    return;
   
    
}

void CRightList::OnList() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_REPORT|LVS_ICON | LVS_SMALLICON,LVS_LIST,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_LIST,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,FALSE);
    pMainFrame->PressButton(ID_SMALL_ICONS,FALSE);
    pMainFrame->PressButton(ID_LIST,TRUE);
    pMainFrame->PressButton(ID_DETAILS,FALSE);
    return;
}

void CRightList::OnDetails() 
{
    // TODO: Add your command handler code here
    CListCtrl &ListCtrl = GetListCtrl();
    ListCtrl.ModifyStyle(LVS_LIST|LVS_ICON | LVS_SMALLICON,LVS_REPORT,0);
    CMenu *pMenu = AfxGetMainWnd()->GetMenu();
    if(pMenu)
        pMenu->CheckMenuRadioItem(ID_LARGE_ICONS,ID_LIST,ID_DETAILS,MF_BYCOMMAND);
    CMainFrame *pMainFrame = (CMainFrame *)AfxGetMainWnd();
    ASSERT(pMainFrame);
    if(NULL == pMainFrame)
        return;
    pMainFrame->PressButton(ID_LARGE_ICONS,FALSE);
    pMainFrame->PressButton(ID_SMALL_ICONS,FALSE);
    pMainFrame->PressButton(ID_LIST,FALSE);
    pMainFrame->PressButton(ID_DETAILS,TRUE);
    return;
}

LRESULT CRightList::OnAddServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return lResult;
    }

    if(NODE_ALL_SERVERS != pDoc->GetNodeType())
    {
        return lResult;
    }

    CListCtrl& ListCtrl = GetListCtrl();

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
    {
        return lResult;
    }

    LV_ITEM lvI;
    
    lvI.iImage = 0;

    if( pServer->GetServerType() == SERVER_TS5_ENFORCED )
    {

        DWORD dwStatus = pServer->GetServerRegistrationStatus( );

        if( dwStatus == LSERVERSTATUS_REGISTER_INTERNET || dwStatus == LSERVERSTATUS_REGISTER_OTHER )
        {
            lvI.iImage = 3;
        }
        else if( dwStatus == LSERVERSTATUS_WAITFORPIN )
        { 
            lvI.iImage = 4;
        }
        else if( dwStatus == LSERVERSTATUS_UNREGISTER )
        {
            lvI.iImage = 5;
        }
        else
        {
            lvI.iImage = 6;
        }
    }
    
    

    CString Name;
    int nIndex = GetListCtrl().GetItemCount();

    // Insert Server Name;
    
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    lvI.iSubItem = 0;
    //lvI.iImage = 0;
    lvI.iItem = nIndex;
    lvI.lParam = (LPARAM)pServer;
    Name = pServer->GetName();
    lvI.pszText = Name.GetBuffer(Name.GetLength());
    lvI.cchTextMax =lstrlen(lvI.pszText + 1);
    nIndex = ListCtrl.InsertItem(&lvI);

    //Insert Server Scope

    //ListCtrl.SetItemText(nIndex,1,pServer->GetScope());

    CString TempString;

    if(pServer->GetServerType() == SERVER_TS5_ENFORCED)
    {
        if(pServer->GetServerRegistrationStatus() ==  LSERVERSTATUS_REGISTER_INTERNET 
            ||
           pServer->GetServerRegistrationStatus() == LSERVERSTATUS_REGISTER_OTHER  )
        {
            VERIFY(TempString.LoadString(IDS_SERVER_REGISTERED) == TRUE);
        }
        else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_WAITFORPIN )
        {
            VERIFY(TempString.LoadString(IDS_SERVER_WAITFORPIN) == TRUE);
        }
        else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_UNREGISTER )
        {
            VERIFY(TempString.LoadString(IDS_SERVER_UNREGISTER) == TRUE);
        }
        else
        {
            VERIFY(TempString.LoadString(IDS_UNKNOWN ) == TRUE);
        }

    }
    else
    {
        VERIFY(TempString.LoadString(IDS_SERVER_NOTREQUIRE) == TRUE);
    }

    ListCtrl.SetItemText(nIndex, 1, (LPCTSTR)TempString);

    if(nIndex == 0)
    {
        ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);
    }

    return lResult;
} // OnAddServer

LRESULT CRightList::OnAddKeyPack(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    
    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    if(NODE_SERVER != pDoc->GetNodeType())
         return lResult;
    

    CListCtrl& ListCtrl = GetListCtrl();
    int nIndex = ListCtrl.GetItemCount();

    CKeyPack *pKeyPack = (CKeyPack*)lParam;
    ASSERT(pKeyPack);
    if(NULL == pKeyPack)
        return lResult;

    AddKeyPack(ListCtrl,nIndex,pKeyPack);
    if(nIndex == 0)
        ListCtrl.SetItemState(0,LVIS_SELECTED,LVIS_SELECTED);


    return lResult;
 
} // OnAddKeyPack


void CRightList::OnAddNewKeyPack() 
{
    // TODO: Add your command handler code here
    HRESULT hResult = ERROR_SUCCESS;
    CListCtrl& listctrl = GetListCtrl();
    CLicMgrDoc * pDoc = (CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;

    //Get the selected item
    int nSelected = listctrl.GetNextItem(-1, LVNI_SELECTED);
    if(-1 == nSelected)
    {
        if(NODE_SERVER == pDoc->GetNodeType())
        hResult = ((CMainFrame *)AfxGetMainWnd())->AddKeyPackDialog(NULL);
        return;
    }
    
    //Get the Data associated with the item.
    #ifdef _WIN64
    DWORD_PTR dCurrSel;
    #else
    DWORD dCurrSel;
    #endif

    dCurrSel = listctrl.GetItemData(nSelected);
    if(LB_ERR == dCurrSel)
        return;

    pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return;

    if(NODE_ALL_SERVERS == pDoc->GetNodeType())
        hResult = ((CMainFrame *)AfxGetMainWnd())->AddKeyPackDialog((PLICSERVER)dCurrSel);
    else
    {
        if(NODE_SERVER == pDoc->GetNodeType())
        {
            CKeyPack * pKeyPack = (CKeyPack *)dCurrSel;
            if(NULL == pKeyPack)
                return;
            hResult = ((CMainFrame *)AfxGetMainWnd())->AddKeyPackDialog(pKeyPack->GetServer());
        }
    }
    
    return;
}


void CRightList::AddKeyPack(CListCtrl& ListCtrl,int nIndex, CKeyPack * pKeyPack)
{
    if(NULL == pKeyPack)
    {
        return;
    }

    LSKeyPack sKeyPack;
    int nSubItemIndex = 1;
    DWORD dwLicenses = 0;

    CLicMgrDoc * pDoc = (CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return;
    }

    CString TempString;
    DWORD dwIssuedLicenses = 0;
    
    LV_ITEM lvI;
    lvI.mask = LVIF_TEXT |LVIF_IMAGE |LVIF_STATE | LVIF_PARAM;
    lvI.state = 0;
    lvI.stateMask =0;
    lvI.iItem = 0;
    lvI.iSubItem = 0;
    lvI.iImage = 1;
    lvI.iItem = nIndex;
    lvI.lParam = (LPARAM)pKeyPack;

    TempString = pKeyPack->GetDisplayName();
    lvI.pszText = TempString.GetBuffer(TempString.GetLength());
    lvI.cchTextMax =lstrlen(lvI.pszText + 1);
    nIndex = ListCtrl.InsertItem(&lvI);

    sKeyPack = pKeyPack->GetKeyPackStruct();

    //Set the KeyPack Type.

    if(NUM_KEYPACK_TYPE <= sKeyPack.ucKeyPackType)
    {
         TempString.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN );
    }
    else
    {
        if(LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType)
        {
            TempString.LoadString(IDS_LSKEYPACKTYPE_FREE );
        }
        else
        {
            TempString.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN+ sKeyPack.ucKeyPackType);
        }
    }

    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);
    nSubItemIndex++;

    //Set the Activation date, Now called Registered on

#ifdef SPANISH
        
    if(LSKEYPACKTYPE_TEMPORARY != sKeyPack.ucKeyPackType)
    {
        TempString = pDoc->TimeToString(&sKeyPack.dwActivateDate);
        if(TempString.IsEmpty())
        {
            TempString.LoadString(IDS_UNKNOWN);
        }
    }
    else
    {
        TempString.LoadString(IDS_DASH);
    }

    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);
    nSubItemIndex++;
#endif

      //Set Total licenses.

//
// HueiWang 7/7/98 - per marketing request
//
    if(LSKEYPACKTYPE_TEMPORARY == sKeyPack.ucKeyPackType)
    {
        TempString.LoadString(IDS_DASH);
    }
    else 
    {
        if(LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType)
        {
            TempString.LoadString(IDS_UNLIMITED);
        }
        else
        {
            TempString.Format(_T("%d"),sKeyPack.dwTotalLicenseInKeyPack); 
        }
    }
    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    nSubItemIndex++;

    //Set Available licenses.

    if(LSKEYPACKTYPE_TEMPORARY == sKeyPack.ucKeyPackType)
    {
        TempString.LoadString(IDS_DASH);
    }
    else
    {
        if( LSKEYPACKSTATUS_RETURNED == sKeyPack.ucKeyPackStatus ||
            LSKEYPACKSTATUS_REVOKED == sKeyPack.ucKeyPackStatus )
        {
            TempString.Format(_T("%d"), 0);
        }
        else if(LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType)
        {
            TempString.LoadString(IDS_UNLIMITED);
        }
        else
        {
            TempString.Format(_T("%d"),sKeyPack.dwNumberOfLicenses); 
        }
    }
    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    nSubItemIndex++;

    //Set Issued licenses.

    if(LSKEYPACKTYPE_TEMPORARY == sKeyPack.ucKeyPackType ||
       LSKEYPACKTYPE_FREE == sKeyPack.ucKeyPackType )
    {
        dwLicenses = sKeyPack.dwNumberOfLicenses;
    }
    else
    {
        dwLicenses = sKeyPack.dwTotalLicenseInKeyPack - sKeyPack.dwNumberOfLicenses;
    }

    TempString.Format(_T("%d"),dwLicenses);
    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    nSubItemIndex++;

    TempString.Empty( );

    switch( sKeyPack.ucKeyPackStatus )
    {
        case LSKEYPACKSTATUS_UNKNOWN:
            TempString.LoadString( IDS_KEYPACKSTATUS_UNKNOWN );
            break;

        case LSKEYPACKSTATUS_TEMPORARY:
            TempString.LoadString( IDS_KEYPACKSTATUS_TEMPORARY );
            break;

        case LSKEYPACKSTATUS_ACTIVE:
        case LSKEYPACKSTATUS_PENDING:
        //case LSKEYPACKSTATUS_RESTORE:
            TempString.LoadString( IDS_KEYPACKSTATUS_ACTIVE );
            break;

        case LSKEYPACKSTATUS_RETURNED:
            TempString.LoadString( IDS_KEYPACKSTATUS_RETURNED );
            break;

        case LSKEYPACKSTATUS_REVOKED:
            TempString.LoadString( IDS_KEYPACKSTATUS_REVOKED );
            break;
    }

    if( TempString.IsEmpty() )
    {
        TempString.LoadString(IDS_UNKNOWN);
    }

    ListCtrl.SetItemText(nIndex,nSubItemIndex,(LPCTSTR)TempString);

    return;
}


LRESULT CRightList::OnDeleteServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;

    DBGMSG( L"CRightList_OnDeleteServer\n" , 0 );

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
        return lResult;

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
        return lResult;
    CListCtrl& ListCtrl = GetListCtrl();
    if(0 == ListCtrl.GetItemCount())
        return lResult;

    
    int nIndex = 0;        
    CKeyPack * pKeyPack = NULL;
    LV_ITEM Item;
    ZeroMemory((LPVOID)&Item,sizeof(Item));
    
    switch(pDoc->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            DBGMSG( L"\tNODE_ALL_SERVERS\n",0 );
            LV_FINDINFO FindInfo;
            FindInfo.flags = LVFI_PARAM;
            FindInfo.psz = NULL;
            FindInfo.lParam = (LPARAM)pServer;

            nIndex = ListCtrl.FindItem(&FindInfo);
            if(-1 == nIndex)
                return lResult;

            ListCtrl.DeleteItem(nIndex);
            break;
        case NODE_SERVER:
            DBGMSG( L"\tNODE_SERVER\n",0 );
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
                break;
            pKeyPack = (CKeyPack *)Item.lParam;
            if(NULL == pKeyPack)
                break;
            if(pServer == pKeyPack->GetServer())
                ListCtrl.DeleteAllItems();

            break;
        case NODE_KEYPACK:
            DBGMSG( L"\tNODE_KEYPACK\n",0 );
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
                break;
            CLicense * pLicense = (CLicense *)Item.lParam;
            if(NULL == pLicense)
                break;
            pKeyPack = pLicense->GetKeyPack();
            if(NULL == pKeyPack)
                break;
            if(pServer == pKeyPack->GetServer())
                ListCtrl.DeleteAllItems();

            break;

    }

    
    return lResult;
 
} // OnDeleteServer

LRESULT CRightList::OnUpdateServer(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    int item;

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
    ASSERT(pDoc);
    if(NULL == pDoc)
    {
        return lResult;
    }

    CLicServer *pServer = (CLicServer*)lParam;
    ASSERT(pServer);
    if(NULL == pServer)
    {
        return lResult;
    }

    CListCtrl& ListCtrl = GetListCtrl();
    if(0 == ListCtrl.GetItemCount())
    {
        return lResult;
    }
    
    int nIndex = 0;
    CKeyPack * pKeyPack = NULL;
    LV_ITEM Item;
    ZeroMemory((LPVOID)&Item,sizeof(Item));

    Item.mask = LVIF_IMAGE;

    
    
    switch(pDoc->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            // HUEIHUEI : Find the server and update its status
            if(ListCtrl.GetSelectedCount() > 1)
            {
                break;
            }
            for( item = 0; item < ListCtrl.GetItemCount( ); ++item )
            {
                if( ListCtrl.GetItemState( item , LVNI_SELECTED ) != LVNI_SELECTED )
                {
                    continue;
                }
            
                // update status of registration
                
                CString TempString;

                if(pServer->GetServerType() == SERVER_TS5_ENFORCED)
                {
                    if(pServer->GetServerRegistrationStatus() ==  LSERVERSTATUS_REGISTER_INTERNET 
                        ||
                       pServer->GetServerRegistrationStatus() == LSERVERSTATUS_REGISTER_OTHER  )
                    {
                        TempString.LoadString(IDS_SERVER_REGISTERED);

                        Item.iImage = 3;
                    }
                    else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_WAITFORPIN )
                    {
                        TempString.LoadString( IDS_SERVER_WAITFORPIN );

                        Item.iImage = 4;
                    }
                    else if( pServer->GetServerRegistrationStatus() == LSERVERSTATUS_UNREGISTER ) 
                    {
                        TempString.LoadString(IDS_SERVER_UNREGISTER);

                        Item.iImage = 5;
                    }
                    else
                    {                        
                        TempString.LoadString(IDS_UNKNOWN);

                        Item.iImage = 6;
                    }

                }
                else
                {
                    TempString.LoadString(IDS_SERVER_NOTREQUIRE);
                }

                Item.iItem = item;

                ListCtrl.SetItem( &Item );

                ListCtrl.SetItemText(item, 1, (LPCTSTR)TempString);
            }

            break;

        case NODE_SERVER:
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
            {
                break;
            }

            pKeyPack = (CKeyPack *)Item.lParam;
            if(NULL == pKeyPack)
            {
                break;
            }

            if(pServer == pKeyPack->GetServer())
            {
                ListCtrl.DeleteAllItems();
                AddKeyPackstoList(pServer, TRUE);
            }
            break;

        case NODE_KEYPACK:
            Item.iItem = 0;
            Item.mask = LVIF_PARAM;
            nIndex = ListCtrl.GetItem(&Item);
            if(-1 == nIndex)
            {
                break;
            }

            CLicense * pLicense = (CLicense *)Item.lParam;
            if(NULL == pLicense)
            {
                break;
            }

            pKeyPack = pLicense->GetKeyPack();
            if(NULL == pKeyPack)
            {
                break;
            }

            if(pServer == pKeyPack->GetServer())
            {
                ListCtrl.DeleteAllItems();
                ((CMainFrame *)AfxGetMainWnd())->AddLicensestoList(pKeyPack, &ListCtrl, TRUE);
            }

            break;

    }

    return lResult;
} // OnUpdateServer

//-----------------------------------------------------------------------------------------------------
void CRightList::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
{
    // TODO: Add your control notification handler code here
     // TODO: Add your control notification handler code here
    CListCtrl& listctrl = GetListCtrl();

    //Get the selected item
    int nSelected = listctrl.GetNextItem(-1, LVNI_SELECTED);
    if(-1 == nSelected)
        return;

    //Get the Data associated with the item.
    #ifdef _WIN64
    DWORD_PTR dCurrSel;
    #else
    DWORD dCurrSel;
    #endif

    dCurrSel = listctrl.GetItemData(nSelected);
    if(LB_ERR == dCurrSel)
        return;

    switch(((CLicMgrDoc *)GetDocument())->GetNodeType())
    {
        case NODE_ALL_SERVERS:
            ((CMainFrame *)AfxGetMainWnd())->SetTreeViewSel(dCurrSel,NODE_SERVER);
            break;
        case NODE_SERVER:
            ((CMainFrame *)AfxGetMainWnd())->SetTreeViewSel(dCurrSel,NODE_KEYPACK);
            break;
     }
    
    *pResult = 0;
}

//-----------------------------------------------------------------------------------------------------
void CRightList::OnKeydown(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;
    // TODO: Add your control notification handler code here
    CMainFrame * pMainFrame  = ((CMainFrame *)AfxGetMainWnd());
    if(pLVKeyDow->wVKey == VK_RETURN)
    {
        OnDblclk(pNMHDR,pResult);
        pMainFrame->SelectView(LISTVIEW);
    }
    if(pLVKeyDow->wVKey == VK_TAB)
    {
        pMainFrame->SelectView(TREEVIEW);
    }

    
    *pResult = 0;
}

/*
 *  Column Sorting.
 */

BOOL    fColSortDir[MAX_COLUMNS * NODE_NONE];

int CALLBACK CompareAllServers(LPARAM, LPARAM, LPARAM);
int CALLBACK CompareServer(LPARAM, LPARAM, LPARAM);
int CALLBACK CompareKeyPack(LPARAM, LPARAM, LPARAM);

VOID
CRightList::OnColumnClick(
    NMHDR*      pNMHDR,
    LRESULT*    pResult
    )
{
    NM_LISTVIEW*    pnmlv = (NM_LISTVIEW*)pNMHDR;
    NODETYPE        curType = ((CLicMgrDoc*)GetDocument())->GetNodeType();

    switch(curType) {
    case NODE_ALL_SERVERS:
        GetListCtrl().SortItems(CompareAllServers, pnmlv->iSubItem);
        break;

    case NODE_SERVER:
        GetListCtrl().SortItems(CompareServer, pnmlv->iSubItem);
        break;

    case NODE_KEYPACK:
        GetListCtrl().SortItems(CompareKeyPack, pnmlv->iSubItem);
        break;
    }

    fColSortDir[curType * MAX_COLUMNS + pnmlv->iSubItem] = 
        !fColSortDir[curType * MAX_COLUMNS + pnmlv->iSubItem];
}

/*
 *  Compare Functions.
 */


int CALLBACK
CompareAllServers(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
    )
{
    CLicServer* pItem1  = (CLicServer*)lParam1;
    CLicServer* pItem2  = (CLicServer*)lParam2;
    int         retVal  = 0;
    int         iCol    = (NODE_ALL_SERVERS * MAX_COLUMNS) + (int)lParamSort;
    int         dir;

    switch(lParamSort) {

    case 0:
    case 1:
        retVal = pItem1->GetName().CompareNoCase(pItem2->GetName());
        break;

    default:
        return(0);
    }

    dir = fColSortDir[iCol] ? 1 : -1;

    return(dir * retVal);
}

int CALLBACK
CompareServer(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
    )
{
    CKeyPack*   pItem1  = (CKeyPack*)lParam1;
    CKeyPack*   pItem2  = (CKeyPack*)lParam2;
    CString     szTemp1;
    CString     szTemp2;
    int         retVal  = 0;
    int         iCol    = (NODE_SERVER * MAX_COLUMNS) + (int)lParamSort;
    int         dir;
    int         tmp1, tmp2;

    switch(lParamSort) {

    case 0:
        retVal = _tcsicmp(pItem1->GetDisplayName(), pItem2->GetDisplayName());
        break;

    case 1:
        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if (tmp1 >= NUM_KEYPACK_TYPE) {
            szTemp1.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN);
        } else if(tmp1 == LSKEYPACKTYPE_FREE) {
            szTemp1.LoadString(IDS_LSKEYPACKTYPE_FREE);
        } else {
            szTemp1.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN + tmp1);
        }

        if (tmp2 >= NUM_KEYPACK_TYPE) {
            szTemp2.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN);
        } else if(tmp2 == LSKEYPACKTYPE_FREE) {
            szTemp2.LoadString(IDS_LSKEYPACKTYPE_FREE);
        } else {
            szTemp2.LoadString(IDS_LSKEYPACKTYPE_UNKNOWN + tmp2);
        }

        retVal = _tcsicmp(szTemp1, szTemp2);
        break;

    case 2:
        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if (tmp1 == LSKEYPACKTYPE_FREE) {
            retVal = 1;
        } else if (tmp1 == LSKEYPACKTYPE_TEMPORARY) {
            retVal = -1;
        } else {
            if (tmp2 == LSKEYPACKTYPE_FREE) {
                retVal = -1;
            } else if (tmp2 == LSKEYPACKTYPE_TEMPORARY) {
                retVal = 1;
            } else {
                retVal = pItem1->GetKeyPackStruct().dwTotalLicenseInKeyPack -
                         pItem2->GetKeyPackStruct().dwTotalLicenseInKeyPack;
            }
        }
        break;

    case 3:
        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if (tmp1 == LSKEYPACKTYPE_FREE) {
            retVal = 1;
        } else if (tmp1 == LSKEYPACKTYPE_TEMPORARY) {
            retVal = -1;
        } else {
            if (tmp2 == LSKEYPACKTYPE_FREE) {
                retVal = -1;
            } else if (tmp2 == LSKEYPACKTYPE_TEMPORARY) {
                retVal = 1;
            } else {
                retVal = pItem1->GetKeyPackStruct().dwNumberOfLicenses -
                         pItem2->GetKeyPackStruct().dwNumberOfLicenses;
            }
        }
        break;

    case 4:
        DWORD   sort1, sort2;

        tmp1 = pItem1->GetKeyPackStruct().ucKeyPackType;
        tmp2 = pItem2->GetKeyPackStruct().ucKeyPackType;

        if ((tmp1 == LSKEYPACKTYPE_TEMPORARY) || (tmp1 == LSKEYPACKTYPE_FREE)) {
            sort1 = pItem1->GetKeyPackStruct().dwNumberOfLicenses;
        } else {
            sort1 = pItem1->GetKeyPackStruct().dwTotalLicenseInKeyPack -
                    pItem1->GetKeyPackStruct().dwNumberOfLicenses;
        }

        if ((tmp2 == LSKEYPACKTYPE_TEMPORARY) || (tmp2 == LSKEYPACKTYPE_FREE)) {
            sort2 = pItem2->GetKeyPackStruct().dwNumberOfLicenses;
        } else {
            sort2 = pItem2->GetKeyPackStruct().dwTotalLicenseInKeyPack -
                    pItem2->GetKeyPackStruct().dwNumberOfLicenses;
        }

        retVal = sort1 - sort2;
        break;

    default:
        return(0);
    }

    dir = fColSortDir[iCol] ? 1 : -1;

    return(dir * retVal);
}

int CALLBACK
CompareKeyPack(
    LPARAM  lParam1,
    LPARAM  lParam2,
    LPARAM  lParamSort
    )
{
    CLicense*   pItem1  = (CLicense*)lParam1;
    CLicense*   pItem2  = (CLicense*)lParam2;
    int         retVal  = 0;
    int         iCol    = (NODE_KEYPACK * MAX_COLUMNS) + (int)lParamSort;
    int         dir;

    switch(lParamSort) {

    case 0:
        retVal = _tcsicmp(pItem1->GetLicenseStruct().szMachineName,
                          pItem2->GetLicenseStruct().szMachineName);
        break;

    case 1:
        retVal = pItem1->GetLicenseStruct().ftIssueDate -
                 pItem2->GetLicenseStruct().ftIssueDate;
        break;

    case 2:
        retVal = pItem1->GetLicenseStruct().ftExpireDate -
                 pItem2->GetLicenseStruct().ftExpireDate;
        break;

    default:
        return(0);
    }

    dir = fColSortDir[iCol] ? 1 : -1;

    return(dir * retVal);
}

afx_msg void CRightList::OnLeftClick( NMHDR* pNMHDR, LRESULT* pResult )
{
    CPoint pt;

    DWORD_PTR itemData;   

    GetCursorPos( &pt );

    ScreenToClient( &pt );
    UINT flag;

    CListCtrl& listctrl = GetListCtrl();

    int iItem = listctrl.HitTest( pt , &flag );

    itemData = listctrl.GetItemData( iItem );

    if( itemData == LB_ERR )
    {        
        int iItem = listctrl.GetNextItem(-1, LVNI_SELECTED | LVNI_FOCUSED );

        if( iItem != LB_ERR )
        {
            itemData = listctrl.GetItemData( iItem );
        }
        else
        {
            DBGMSG( L"\tno item selected\n", 0  );
            
            return;
        }
    }

    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
            
    if(NULL == pDoc)
    {
        return;
    }
    
    NODETYPE nt = pDoc->GetNodeType();

    switch( nt )
    {
        case NODE_ALL_SERVERS:
            {                
                CLicServer *pServer = reinterpret_cast< CLicServer* >( itemData );

                SetActiveServer( pServer );

                if( NULL == pServer )
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    break;
                }

                DBGMSG( L"\tServer item selected\n", 0  );                
            }
            break;

        case NODE_SERVER:
            {   
                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack * >( itemData );

                if(NULL == pKeyPack)
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    SetActiveServer( NULL );

                    break;
                }

                SetActiveServer( pKeyPack->GetServer( ) );

                DBGMSG( L"\tLicense pak item selected\n", 0  );
            }

            break;        

        case NODE_KEYPACK:
            {   
                CLicense * pLicense = reinterpret_cast< CLicense * >( itemData );

                if( pLicense != NULL )
                {
                    CKeyPack *pKeyPack = pLicense->GetKeyPack( );

                    if( pKeyPack != NULL )
                    {
                        SetActiveServer( pKeyPack->GetServer( ) );                

                        break;
                    }
                }

                SetActiveServer( NULL );


            }
            
            break;    
    }
}

//------------------------------------------------------------------------
afx_msg void CRightList::OnContextMenu( CWnd* pWnd, CPoint pt ) 
{
    CMenu menu;

    CMenu *pContextMenu = NULL;
    
    DWORD_PTR itemData;   

    DBGMSG( L"LICMGR @ CRightList::OnContextMenu\n" , 0 );
        
    DBGMSG( L"\tpoint x = %d " , pt.x );
    
    DBGMSG( L"y = %d\n" , pt.y );

    UINT flag;
    
    int nItem = -1;

    CListCtrl& listctrl = GetListCtrl();

    // maybe keyboard selected this item

    if(pt.x == -1 && pt.y == -1)
    {   
        if( listctrl.GetSelectedCount( ) > 0 )
        {
            RECT rect;

            nItem = listctrl.GetNextItem( nItem , LVNI_SELECTED );

            if( nItem != ( int )LB_ERR )
            {
                listctrl.GetItemRect( nItem , &rect , LVIR_BOUNDS );

		        pt.x = rect.left + (rect.right - rect.left)/2;
		        
                pt.y = rect.top + (rect.bottom - rect.top)/2;
		        
            }
        }
    }
    else
    {
        // otherwise we're invoked by the mouse
        ScreenToClient( &pt );

        nItem = listctrl.HitTest( pt , &flag );
    }
    
    itemData = listctrl.GetItemData( nItem );


    CLicMgrDoc * pDoc =(CLicMgrDoc *)GetDocument();
            
    if(NULL == pDoc)
    {
        return;
    }

    ClientToScreen( &pt );

    NODETYPE nt = pDoc->GetNodeType();

    switch( nt )
    {
        case NODE_ALL_SERVERS:
            {                
                CLicServer *pServer = reinterpret_cast< CLicServer* >( itemData );

                SetActiveServer( pServer );

                if( NULL == pServer )
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    break;
                }

                DBGMSG( L"\tServer item selected\n", 0  );

                menu.LoadMenu( IDR_MENU_LPK );

                pContextMenu = menu.GetSubMenu( 0 );

                nt = NODE_SERVER;
 
            }
            break;

        case NODE_SERVER:
            {                
                nt = NODE_KEYPACK;

                CKeyPack *pKeyPack = reinterpret_cast< CKeyPack * >( itemData );

                if(NULL == pKeyPack)
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    // SetActiveServer( NULL );

                    break;
                }

                SetActiveServer( pKeyPack->GetServer( ) );

                DBGMSG( L"\tLicense pak item selected\n", 0  );

                menu.LoadMenu( IDR_MENU_LPK );

                pContextMenu = menu.GetSubMenu( 1 );
                
            }

            break;

        

        case NODE_KEYPACK:
            {   
                CLicense * pLicense = reinterpret_cast< CLicense * >( itemData );

                if( pLicense == NULL )
                {
                    DBGMSG( L"\tno item selected\n", 0  );
                    
                    // SetActiveServer( NULL  );

                    break;
                }


                CKeyPack *pKeyPack = pLicense->GetKeyPack( );

                if( pKeyPack != NULL )
                {
                    SetActiveServer( pKeyPack->GetServer( ) );
                }
                else
                {
                    // impossible! a license with out a home
                    ASSERT( 0 );
                }

                /*
                nt = NODE_NONE; // its safe

                CLicense * pLicense = reinterpret_cast< CLicense * >( itemData );

                if( pLicense == NULL )
                {
                    DBGMSG( L"\tno item selected\n", 0  );

                    break;
                }

                DBGMSG( L"\tLicense item selected\n", 0  );

                menu.LoadMenu( IDR_MENU_LPK );

                pContextMenu = menu.GetSubMenu( 2 );

                */
                
            }
            
            break;
        
    }


    UI_initmenu( pContextMenu , nt );

    if( pContextMenu != NULL )
    {
        pContextMenu->TrackPopupMenu( TPM_LEFTALIGN , pt.x , pt.y , this );
    }

}
          
//----------------------------------------------------------------------------
void CRightList::UI_initmenu( CMenu *pMenu , NODETYPE nt )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->UI_initmenu( pMenu , nt );
    }
   
}

//----------------------------------------------------------------------------
DWORD CRightList::WizardActionOnServer( WIZACTION wa , PBOOL pbRefresh )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        return pMainFrame->WizardActionOnServer( wa , pbRefresh , LISTVIEW );
    }

    return ERROR_INVALID_PARAMETER;
}


//-----------------------------------------------------------------------------------------       
void CRightList::OnServerConnect( )
{
    CMainFrame *pMainFrame = static_cast< CMainFrame * >( AfxGetMainWnd() );

    if( pMainFrame != NULL )
    {
        pMainFrame->ConnectServer( );
    }

}

//-----------------------------------------------------------------------------------------
void CRightList::OnRefreshAllServers( )
{
   CMainFrame *pMainFram