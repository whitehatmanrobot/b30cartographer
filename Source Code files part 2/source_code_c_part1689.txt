e,
    IN EPropertyAccess  &Access
    )
{
    DBGMSG( DBG_TRACE, ( "TLocationPropertySheet::CheckPropertyAccess\n" ) );

    //
    // Assume no access.
    //
    Access = kPropertyAccessNone;

    //
    // Need a directory object interface to query for the effective attributes.
    //
    IDirectoryObject *pDsObj = NULL;

    //
    // Get the directory object interface.
    //
    HRESULT hr = ADsOpenObject( const_cast<LPTSTR>( static_cast<LPCTSTR>(_strDsObjectName)),
                                NULL,
                                NULL,
                                ADS_SECURE_AUTHENTICATION,
                                IID_IDirectoryObject,
                                reinterpret_cast<LPVOID*>( &pDsObj ) );

    if( SUCCEEDED(hr) )
    {
        DWORD           cAttrs      = 0;
        PADS_ATTR_INFO  pAttrs      = NULL;
        LPCTSTR         szNames[2]  = {gszName, gszAllowed};

        //
        // Query for this objects attributes.
        //
        hr = pDsObj->GetObjectAttributes( (LPTSTR*)szNames, 2, &pAttrs, &cAttrs );

        if( SUCCEEDED(hr) )
        {
            //
            // The object was opened and we were able to read the attributes then
            // We assume we have read access.
            //
            Access = kPropertyAccessRead;

            for (UINT i = 0; i < cAttrs; i++)
            {
                DBGMSG( DBG_TRACE, ( "Allowed Name " TSTR "\n", pAttrs[i].pszAttrName ) );

                if (!_tcsicmp( pAttrs[i].pszAttrName, gszAllowed ))
                {
                    for (UINT j = 0; j < pAttrs[i].dwNumValues; j++)
                    {
                        DBGMSG( DBG_TRACE, ( "Allowed attribute (effective): %d " TSTR "\n", pAttrs[i].pADsValues[j].dwType, pAttrs[i].pADsValues[j].CaseIgnoreString ) );

                        if (!_tcsicmp( pAttrs[i].pADsValues[j].CaseIgnoreString, gszLocation ))
                        {
                            //
                            // We found the location property in the attribute list,
                            // by this fact we now know we can write this property.
                            //
                            Access = kPropertyAccessWrite;
                        }
                    }
                }
            }

            //
            // Release the writeable attribute memory.
            //
            if( pAttrs )
            {
                FreeADsMem( pAttrs );
            }
        }

        //
        // Release the directory object interface.
        //
        pDsObj->Release();
    }

    return TRUE;
}


LPTSTR
TLocationPropertySheet::
ByteOffset(
    IN LPDSOBJECTNAMES  pObject,
    IN UINT             uOffset
    )
{
    return reinterpret_cast<LPTSTR>( reinterpret_cast<LPBYTE>( pObject ) + uOffset );
}

BOOL
TLocationPropertySheet::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bRetval;

    switch( uMsg )
    {
        case WM_INITDIALOG:
            bRetval = Handle_InitDialog( wParam, lParam );
            break;

        case WM_COMMAND:
            bRetval = Handle_Command( wParam, lParam );
            break;

        case WM_NOTIFY:
            bRetval = Handle_Notify( wParam, lParam );
            vSetDlgMsgResult( bRetval );
            break;

        case WM_HELP:
            bRetval = Handle_Help( uMsg, wParam, lParam );
            break;

        case WM_CONTEXTMENU:
            bRetval = Handle_Help( uMsg, wParam, lParam );
            break;

        default:
            bRetval = FALSE;
            break;
    }

    return bRetval;
}

BOOL
TLocationPropertySheet::
Handle_InitDialog(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TStatusB bStatus;

    //
    // Get the location property from the object.  We ignore the return
    // value because the Get will fail if the property is not set.
    //
    bStatus DBGCHK = _Ds.Get( _pDsObject, gszLocation, _strLocation );

    //
    //
    // If we have write access then allow browsing the location tree,
    // otherwise disable the button
    //
    if( (kPropertyAccessWrite != _PropertyAccess) || !TPhysicalLocation::bLocationEnabled() )
    {
        EnableWindow( GetDlgItem(_hDlg, _uBrowseID), FALSE );
    }

    //
    // Set the location text in the UI.
    //
    bStatus DBGCHK = bSetEditText( _hDlg, _uLocationEditID, _strLocation );

    //
    // If we only have read access to the location property then
    // set the location edit control to read only.
    //
    if( _PropertyAccess == kPropertyAccessRead )
    {
        SendDlgItemMessage( _hDlg, _uLocationEditID, EM_SETREADONLY, TRUE, 0);
    }

    //
    // Set the location limit text.
    //
    SendDlgItemMessage( _hDlg, _uLocationEditID, EM_SETLIMITTEXT, kPrinterLocationBufMax, 0 );

    return TRUE;
}


BOOL
TLocationPropertySheet::
Handle_Help(
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PrintUIHelp( uMsg, _hDlg, wParam, lParam );
    return TRUE;
}

BOOL
TLocationPropertySheet::
Handle_Command(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL bRetval = TRUE;

    UINT uID = GET_WM_COMMAND_ID( wParam, lParam );

    if( uID == _uLocationEditID )
    {
        //
        // If the user changed the text in the location edit control then
        // enable the apply button.
        //
        if( GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE )
        {
            PropSheet_Changed( GetParent( _hDlg ), _hDlg );
        }
    }
    else if( uID == _uBrowseID )
    {
        BrowseLocations ();
    }
    else
    {
        bRetval = FALSE;
    }

    return bRetval;
}

BOOL
TLocationPropertySheet::
Handle_Notify(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL    bRetval = TRUE;
    LPNMHDR pnmh    = (LPNMHDR)lParam;

    switch( pnmh->code )
    {
        case PSN_APPLY:
        {
            DBGMSG( DBG_TRACE, ( "TLocationPropertySheet::Handle_Notify PSN_APPLY\n" ) );
            LPPSHNOTIFY lppsn = (LPPSHNOTIFY )lParam; 

            TStatusB bStatus;

            bStatus DBGNOCHK = TRUE;

            //
            // Check if we have write access, not much to do if we only have read access.
            //
            if( _PropertyAccess == kPropertyAccessWrite )
            {
                UINT u, uLen;
                TString strLocation;

                bStatus DBGCHK = bGetEditText( _hDlg, _uLocationEditID, strLocation );

                // make all separators the same character
                strLocation.bReplaceAll( TEXT('\\'), TEXT('/') );

StartOver:
                // remove the duplicated separators
                uLen = strLocation.uLen();
                for( u = 0; (u+1)<uLen; u++ )
                {
                    if( TEXT('/') == strLocation[u] &&
                        TEXT('/') == strLocation[u+1] )
                    {
                        // duplicated separator - delete & start all over
                        strLocation.bDeleteChar(u);
                        goto StartOver;
                    }
                }

                // remove the leading separator
                uLen = strLocation.uLen();
                if( uLen && TEXT('/') == strLocation[0] )
                {
                    strLocation.bDeleteChar(0);
                }

                // remove the trailing separator
                uLen = strLocation.uLen();
                if( uLen && TEXT('/') == strLocation[uLen-1] )
                {
                    strLocation.bDeleteChar(uLen-1);
                }

                if( _tcscmp( _strLocation, strLocation ) && bStatus )
                {
                    bStatus DBGCHK = _Ds.Put( _pDsObject, gszLocation, strLocation );
                }

                if (bStatus)
                {
                    //
                    // DS put succeeded. Just save the last valid location.
                    //
                    _strLocation.bUpdate( strLocation );

                    //
                    // Since we may have modified the location - update UI.
                    //
                    bSetEditText( _hDlg, _uLocationEditID, strLocation );
                }
            }

            //
            // Something failed let the user know.
            //
            if (!bStatus)
            {
                //
                // If the lParam is true the OK/Close button was used to
                // dismiss the dialog.  Let the dialog exit in this case.
                //
                if( lppsn->lParam == TRUE )
                {
                    if( iMessage( _hDlg,
                                  IDS_ERR_LOCATION_PROP_TITLE,
                                  IDS_ERR_WANT_TO_EXIT,
                                  MB_YESNO|MB_ICONSTOP,
                                  kMsgNone,
                                  NULL ) == IDYES )
                    {
                        bStatus DBGCHK = TRUE;
                    }
                }
                else
                {
                    iMessage( _hDlg,
                              IDS_ERR_LOCATION_PROP_TITLE,
                              IDS_ERR_GENERIC,
                              MB_OK|MB_ICONSTOP,
                              kMsgGetLastError,
                              NULL );
                }
            }

            bRetval = bStatus ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
            break;
        }

        default:
        {
            bRetval = FALSE;
            break;
        }
    }

    return bRetval;
}

BOOL
TLocationPropertySheet::
GetObjectInterface(
    IN      LPCTSTR strDsObject,
    IN OUT  IADs    **ppDsObject
    )
{
    //
    // Get the adsi object interface pointer.
    //
    HRESULT hr = ADsOpenObject( const_cast<LPTSTR>( strDsObject ),
                                NULL,
                                NULL,
                                ADS_SECURE_AUTHENTICATION,
                                IID_IADs,
                                reinterpret_cast<LPVOID*>( ppDsObject ) );

    return SUCCEEDED( hr );
}

BOOL
TLocationPropertySheet::
GetDefaultSiteName(
    IN TString &strSiteName
    )
{
    TStatusB bStatus;

    //
    // Get the current objects site name.  If the current
    // object is a site object we just read the site name
    //
    if( !_tcsicmp( _strDsObjectClass, gszSite ) )
    {
        bStatus DBGCHK = _Ds.Get( _pDsObject, gszName, strSiteName );
    }
    else if ( !_tcsicmp( _strDsObjectClass, gszSubnet ) )
    {
        //
        // To get the default site name for a subnet object
        // we need to build a path to the site object and read the
        // the name property from the site.
        //
        TString strSiteObjectName;

        bStatus DBGCHK = _Ds.Get( _pDsObject, gszSiteObject, strSiteObjectName );

        if( bStatus )
        {
            TString strSiteObjectPath;
            TString strLDAPPrefix;

            //
            // Build the site object path.
            //
            bStatus DBGCHK = _Ds.GetLDAPPrefix( strLDAPPrefix )             &&
                             strSiteObjectPath.bUpdate( strLDAPPrefix )     &&
                             strSiteObjectPath.bCat( strSiteObjectName );

            if( bStatus )
            {
                IADs *pDsSiteObject = NULL;

                //
                // Get the site object interface pointer.
                //
                bStatus DBGCHK = GetObjectInterface( strSiteObjectPath, &pDsSiteObject );

                if( bStatus )
                {
                    //
                    // Read the site name from the site object.
                    //
                    bStatus DBGCHK = _Ds.Get( pDsSiteObject, gszName, strSiteName );
                }

                if( pDsSiteObject )
                {
                    pDsSiteObject->Release();
                }
            }
        }

        bStatus DBGNOCHK = FALSE;
    }
    else
    {
        bStatus DBGNOCHK = FALSE;
    }

    return bStatus;
}

VOID
TLocationPropertySheet::
BrowseLocations(
    VOID
    )
{
    TFindLocDlg *pFindLocDlg = new TFindLocDlg(TFindLocDlg::kLocationShowHelp);

    if( VALID_PTR(pFindLocDlg) )
    {
        TString strLocation;
        TStatusB bStatus;

        bGetEditText ( _hDlg, _uLocationEditID, strLocation );

        bStatus DBGCHK = pFindLocDlg->bDoModal(_hDlg, &strLocation);

        if (bStatus)
        {
            bStatus DBGCHK = pFindLocDlg->bGetLocation(strLocation);

            if (bStatus && !strLocation.bEmpty())
            {
                //
                // Check to append a trailing slash
                //
                UINT uLen = strLocation.uLen();
                if( uLen && gchSeparator != static_cast<LPCTSTR>(strLocation)[uLen-1] )
                {
                    static const TCHAR szSepStr[] = { gchSeparator };
                    bStatus DBGCHK = strLocation.bCat( szSepStr );
                }

                bStatus DBGCHK = bSetEditText( _hDlg, _uLocationEditID, strLocation );
            }
        }
    }

    if( pFindLocDlg )
    {
        delete pFindLocDlg;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\notify.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    notify.cxx

Abstract:

    Handles object updates and notifications from the printing system.

Author:

    Albert Ting (AlbertT)  15-Sept-1994

Revision History:

    Lazar Ivanov (LazarI)  Nov-20-2000, major redesign

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "notify.hxx"

/********************************************************************

    Public functions.

********************************************************************/

TNotify::
TNotify(
    VOID
    )

/*++

Routine Description:

    Constructs a Notify object that can be used to watch several
    event handles.

Arguments:

Return Value:

Notes:

--*/

{
    DBGMSG( DBG_NOTIFY, ( "Notify.Notify: ctr %x\n", this ));

    //
    // Initialize member fields.
    //
    CSGuard._bSuspended = FALSE;
    _dwSleepTime = kSleepTime;
    _shEventProcessed = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // _shEventProcessed is our valid check.
    //
}

VOID
TNotify::
vDelete(
    VOID
    )

/*++

Routine Description:

    Mark the object as pending deletion.

Arguments:

Return Value:

--*/

{
    //
    // Notify all objects on linked list.
    //
    {
        CCSLock::Locker lock(_CritSec);

        CSGuard._pNotifyWork = NULL;
        TWait *pWait = NULL;

        for(;;)
        {
            pWait = CSGuard.Wait_pHead();
            if( !pWait )
            {
                break;
            }

            // we are about to shutdown -- no handles should be
            // registered at this time.
            SPLASSERT(0 == pWait->_cNotifyWork);

            // if our wait is not suspended then we need to suspend it first
            // to ensure only our request will be processed during this time 
            // this will help us avoid deadlocks when WaitForMultipleObjects
            // fails for some reason (due to invalid handles for example) and 
            // never get to the point of processing the exit request.
            if( !CSGuard._bSuspended )
            {
                CSGuard._eOperation = kEopSuspendRequest;
                vSendRequest(pWait);
                WaitForSingleObject(_shEventProcessed, INFINITE);
            }

            // TWait should be suspended at this point (i.e. waiting only for 
            // commands). now just request exit...
            CSGuard._eOperation = kEopExitRequest;
            vSendRequest(pWait);
            WaitForSingleObject(_shEventProcessed, INFINITE);

            // Before destoying pWait we should wait the background 
            // (worker) thread to finish.
            WaitForSingleObject(pWait->_shThread, INFINITE);

            // at this point the background thread is exiting and this pWait
            // object will never be accessed again, so it is safe to delete.
            pWait->Wait_vDelinkSelf(); 
            delete pWait;
        }
    }
}


VOID
TNotify::
vSendRequest(
    TWait* pWait
    )

/*++

Routine Description:

    Send a request to the pWait thread.  The pWait thread will pickup
    our notification, process it, then shend a handshake.

Arguments:


Return Value:


--*/

{
    SetEvent( pWait->_ahNotifyArea[0] );
}

/*++

Routine Description:

    executes an operation on a wait object
    we need to suspend the object first to
    ensure no deadlocking.

Arguments:


Return Value:


--*/

VOID
TNotify::
vExecuteOperation(
    MNotifyWork* pNotifyWork,
    TWait* pWait,
    EOPERATION eOp
    )
{
    SPLASSERT(_CritSec.bInside());
    if( pWait && eOp )
    {
        //
        // The TWait will look in these globals to determine which
        // pNotifyWork it should register.
        //
        CSGuard._pNotifyWork = pNotifyWork;

        // if our wait is not suspended then we need to suspend it first
        // (temporarily) to ensure only our request will be processed during
        // this time this will also help us avoid deadlocks when WaitForMultipleObjects
        // fails for some reason (due to invalid handles for example) and
        // never get to the point of registering the object.
        if( !CSGuard._bSuspended )
        {
            CSGuard._eOperation = kEopSuspendRequest;
            vSendRequest(pWait);
            WaitForSingleObject(_shEventProcessed, INFINITE);
        }

        // the Wait obj should be suspended at this point and ready to
        // accept registration requests.
        //
        // We must perform a handshake to ensure that only one register
        // occurs at a time.  We will sit in the critical section until
        // the worker signals us that they are done.
        //
        CSGuard._eOperation = eOp;
        vSendRequest(pWait);
        WaitForSingleObject(_shEventProcessed, INFINITE);

        // release the Wait from suspended mode after the registration
        // request is handled
        if( !CSGuard._bSuspended )
        {
            CSGuard._eOperation = kEopResumeRequest;
            vSendRequest(pWait);
            WaitForSingleObject(_shEventProcessed, INFINITE);
        }
    }
}

/*++

Routine Description:

    finds a wait object which has a free slot.
    if not found - create new one

Arguments:


Return Value:


--*/

STATUS
TNotify::
sFindOrCreateWaitObject(
    TWait **ppWait
    )
{
    SPLASSERT(_CritSec.bInside());
    SPLASSERT(ppWait);

    TWait* pWait = NULL;

    TStatus Status(DBG_WARN);
    Status DBGCHK = ERROR_SUCCESS;

    //
    // Traverse through all the TWaits
    // to find the first one that has free slot.
    //
    TIter Iter;
    for( CSGuard.Wait_vIterInit(Iter), Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        pWait = CSGuard.Wait_pConvert(Iter);
        if( FALSE == pWait->bFull() )
        {
            // found a wait with an empty slot
            break;
        }
    }

    //
    // If the iter is valid, we broke out of the loop because
    // we found one.  If it's not valid, we need to create
    // a new wait object.
    //
    if( !Iter.bValid( ))
    {
        //
        // We need to create a new wait object.
        //
        pWait = new TWait(this);

        if( !VALID_PTR(pWait) )
        {
            Status DBGCHK = GetLastError();
            SPLASSERT((STATUS)Status);

            delete pWait;
            pWait = NULL;
        }
        else
        {
            //
            // If we are in suspended mode then we need to suspend the new
            // TWait object before start registering the handles.
            //
            if( CSGuard._bSuspended )
            {
                CSGuard._eOperation = kEopSuspendRequest;
                vSendRequest(pWait);
                WaitForSingleObject(_shEventProcessed, INFINITE);
            }
        }
    }

    *ppWait = pWait;
    return Status;
}

STATUS
TNotify::
sRegister(
    MNotifyWork* pNotifyWork
    )

/*++

Routine Description:

    Registers a notification work item with the system.  It may
    already be watched; in this case, the notification is modified
    (this may occur if the event handle needs to change).

Arguments:

    pNotifyWork - Item that should be modified.

Return Value:

    STATUS - ERROR_SUCCESS = success, else error.

--*/

{
    TStatus Status(DBG_WARN);
    Status DBGCHK = ERROR_SUCCESS;

    {
        CCSLock::Locker lock(_CritSec);

        //
        // If registering, make sure the event is OK.
        //
        if( pNotifyWork->hEvent() == INVALID_HANDLE_VALUE || !pNotifyWork->hEvent() )
        {
            SPLASSERT( FALSE );
            return ERROR_INVALID_PARAMETER;
        }

        if( NULL == pNotifyWork->_pWait )
        {
            //
            // This is a new item requesting to be registered.
            // find a free slot in the TWait object.
            //
            TWait* pWait = NULL;
            Status DBGCHK = sFindOrCreateWaitObject(&pWait);

            if( ERROR_SUCCESS == Status && pWait )
            {
                //
                // If success then register the handle
                //
                vExecuteOperation(pNotifyWork, pWait, kEopRegister);

                //
                // Hook up the wait object
                //
                pNotifyWork->_pWait = pWait;
            }
        }
        else
        {
            //
            // We are already hooked up on on a wait object,
            // just modify the handle if necessary
            //
            vExecuteOperation(pNotifyWork, pNotifyWork->_pWait, kEopModify);
        }
    }

    return Status;
}


STATUS
TNotify::
sUnregister(
    MNotifyWork* pNotifyWork
    )

/*++

Routine Description:

    Unregister a work item to be watched by the system.

Arguments:

    pNotifyWork - Item that should be modified.

Return Value:

    STATUS - ERROR_SUCCESS = success, else error.

--*/

{
    {
        CCSLock::Locker lock(_CritSec);

        //
        // Only do this if the TNotifyWork is registered.
        //
        if( pNotifyWork->_pWait )
        {
            vExecuteOperation(pNotifyWork, pNotifyWork->_pWait, kEopUnregister);

            //
            // We are now unregistered, remove _pWait.
            //
            pNotifyWork->_pWait = NULL;

        }
        else
        {
            //
            // Deleting handle, but it doesn't exist.
            //
            DBGMSG(DBG_NOTIFY, ("Notify.sUnregister: %x Del NotifyWork %x not on list\n",
                this, pNotifyWork));
        }
    }

    return ERROR_SUCCESS;
}

BOOL
TNotify::
bSuspendCallbacks(
    VOID
    )
/*++

Routine Description:

    This function is suspending temporarily the notify callbacks
    from the background threads, which are listening for a printer
    notifications and force them to enter in special mode for
    listening register/unregister requests only. We need
    this functionality in order to avoid deadlocks caused between
    the TFolder::bFolderRefresh() and the callback functions -
    vProcessNotifyWork() invoked from the background threads both
    of which are trying to grab the TFolder critical section.

Arguments:

    None

Return Value:

    TRUE - callbacks suspended
    FALSE - otherwise

--*/
{
    CCSLock::Locker lock(_CritSec);
    SPLASSERT(_csResumeSuspend.bInside());
    SPLASSERT(!CSGuard._bSuspended);

    CSGuard._eOperation = kEopSuspendRequest;

    TIter Iter;
    TWait* pWait = NULL;
    for( CSGuard.Wait_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        pWait = CSGuard.Wait_pConvert(Iter);
        vSendRequest(pWait);
        WaitForSingleObject(_shEventProcessed, INFINITE);
    }

    CSGuard._bSuspended = TRUE;
    return TRUE;
}

VOID
TNotify::
vResumeCallbacks(
    VOID
    )
/*++

Routine Description:

    Resume the callbacks suspended from bSuspendCallbacks(). For more
    information see bSuspendCallbacks's description.

Arguments:

    None

Return Value:

    TRUE - callbacks suspended
    FALSE - otherwise

--*/
{
    CCSLock::Locker lock(_CritSec);
    SPLASSERT(_csResumeSuspend.bInside());
    SPLASSERT(CSGuard._bSuspended);

    CSGuard._eOperation = kEopResumeRequest;

    TIter Iter;
    TWait* pWait = NULL;
    for( CSGuard.Wait_vIterInit(Iter), Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        pWait = CSGuard.Wait_pConvert(Iter);
        vSendRequest(pWait);
        WaitForSingleObject(_shEventProcessed, INFINITE);
    }

    CSGuard._bSuspended = FALSE;
}

/********************************************************************

    Private functions

********************************************************************/

VOID
TNotify::
vRefZeroed(
    VOID
    )

/*++

Routine Description:

    Virtual definition for MRefCom.  When the refcount has reached
    zero, we want to delete ourselves.

Arguments:

Return Value:

--*/

{
    if( bValid( )){
        delete this;
    }
}


TNotify::
~TNotify(
    VOID
    )

/*++

Routine Description:

    Delete TNotify.

Arguments:

Return Value:

--*/
{
    DBGMSG(DBG_NOTIFY, ("Notify.Notify: dtr %x\n", this));

    SPLASSERT(CSGuard.Wait_bEmpty());
}

/********************************************************************

    TWait

********************************************************************/

TNotify::
TWait::
TWait(
    TNotify* pNotify
    ) :
    _pNotify(pNotify),
    _cNotifyWork(0)

/*++

Routine Description:

    Construct TWait.

    TWaits are built when new object need to be watched.  We
    need several TWaits since only 31 handles can be watched
    per TWait.

Arguments:

    pNotify - Owning TNotify.

Return Value:

--*/

{
    SPLASSERT( pNotify->_CritSec.bInside( ));
    SPLASSERT( pNotify );

    DWORD dwIgnore;

    //
    // Create our trigger event to add and remove events.
    //
    _ahNotifyArea[0] = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // _ahNotifyArea[0] is our valid check.
    //
    if( !_ahNotifyArea[0] )
    {
        return;
    }

    _shThread = TSafeThread::Create(NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE)vRun,
                                    this,
                                    0,
                                    &dwIgnore);

    if( !_shThread )
    {
        goto Fail;
    }

    //
    // Add ourselves to the linked list.
    //
    pNotify->CSGuard.Wait_vAdd(this);
    return;

Fail:
    //
    // _ahNotifyArea[0] is our valid check, so clear it here.
    //
    CloseHandle(_ahNotifyArea[0]);
    _ahNotifyArea[0] = NULL;
}


TNotify::
TWait::
~TWait(
    VOID
    )

/*++

Routine Description:

    Destory TWait.
    Should be called once everything has been unregistered.

Arguments:

Return Value:

--*/

{
    if( _ahNotifyArea[0] )
    {
        CloseHandle(_ahNotifyArea[0]);
    }
}

VOID
TNotify::
TWait::
vProcessOperation(
    VOID
    )

/*++

Routine Description:

    Process registration/unregistration of handles.
    Note: doesn't reset cAwake, so callee must reset.

    This routine MUST be called when someone else is holding the
    critical section, since we access data here.  This routine will
    be called when another thread needs to register/unregister, so
    it grabs the critical section, sets the correct state, then sets
    the event which calls us.  When we are done, we set another event
    and the calling thread releases the critical section.

    This routine doesn't not move items across the cAwake boundary, so
    the callee must reset and watch all events (e.g., we may unregister
    an event that was awake, and we replace it with one that wasn't).

Arguments:

    None.

Return Value:

--*/

{
    MNotifyWork* pNotifyWork = pNotify()->CSGuard._pNotifyWork;

    //
    // Switch based on operation.
    //
    switch( pNotify()->CSGuard._eOperation )
    {
    case kEopRegister:

        //
        // Add it to our list.
        //
        SPLASSERT(_cNotifyWork < kNotifyWorkMax);
        SPLASSERT(NULL == pNotifyWork->_pWait);

        if( _cNotifyWork < kNotifyWorkMax )
        {
            DBGMSG( DBG_NOTIFY,
                    ( "Wait.vProcessOperation: %x Register %x (%d)\n",
                      pNotify(), this, _cNotifyWork ));

            //
            // Add to the list by putting it at the end.
            //
            phNotifys()[_cNotifyWork] = pNotifyWork->hEvent();
            _apNotifyWork[_cNotifyWork] = pNotifyWork;
            ++_cNotifyWork;
        }

        break;

    case kEopModify:
    case kEopUnregister:

        UINT i = 0;

        //
        // Find the index of the MNotifyWork in TWait.
        //
        for( i = 0; i< _cNotifyWork; ++i )
        {
            if( _apNotifyWork[i] == pNotifyWork )
            {
                break;
            }
        }

        DBGMSG( DBG_NOTIFY,
                ( "Wait.bNotify: %x update hEvent on index %d %x (%d)\n",
                  this, i, phNotifys()[i], _cNotifyWork ));

        SPLASSERT( i != _cNotifyWork );
        if( i < _cNotifyWork )
        {
            if( pNotify()->CSGuard._eOperation == kEopModify )
            {
                //
                // Update hEvent only.  This is necessary because the client
                // may have very quickly deleted and re-added with a new
                // event.  In this case, we must do the update.
                //
                phNotifys()[i] = pNotifyWork->hEvent();

            }
            else
            {
                //
                // We are going to reset after this anyway, so don't
                // worry about moving items across the cAwake
                // boundary.
                //

                //
                // Fill in the last element into the hole.
                //
                DBGMSG( DBG_NOTIFY,
                        ( "Wait.vProcessOperation: %x removing index %d %x (%d)\n",
                          this, i, phNotifys()[i], _cNotifyWork ));

                //
                // Predecrement since array is zero-based.
                //
                --_cNotifyWork;

                phNotifys()[i] = phNotifys()[_cNotifyWork];
                _apNotifyWork[i] = _apNotifyWork[_cNotifyWork];
            }
        }
        break;
    }
}


VOID
TNotify::
TWait::
vRun(
    TWait* pWait
    )
{
    DWORD dwWait;
    DWORD cObjects;
    DWORD cAwake;
    DWORD dwTimeout = INFINITE;
    MNotifyWork* pNotifyWork;
    TNotify* pNotify = pWait->pNotify().pGet();

    DBGMSG( DBG_NOTIFY, ( "Wait.vRun start %x\n", pWait ));

Reset:

    cAwake =
    cObjects = pWait->_cNotifyWork;

    dwTimeout = INFINITE;

    for( ; ; )
    {
        DBGMSG( DBG_NOTIFY,
                ( "WaitForMultpleObjects: 1+%d %x timeout %d cObjects %d\n"
                  "%x %x %x %x %x %x %x %x %x\n"
                  "%x %x %x %x %x %x %x %x %x\n",
                  cAwake,
                  pNotify,
                  dwTimeout,
                  cObjects,
                  pWait->_apNotifyWork[0],
                  pWait->_apNotifyWork[1],
                  pWait->_apNotifyWork[2],
                  pWait->_apNotifyWork[3],
                  pWait->_apNotifyWork[4],
                  pWait->_apNotifyWork[5],
                  pWait->_apNotifyWork[6],
                  pWait->_apNotifyWork[7],
                  pWait->_apNotifyWork[8],
                  pWait->phNotifys()[0],
                  pWait->phNotifys()[1],
                  pWait->phNotifys()[2],
                  pWait->phNotifys()[3],
                  pWait->phNotifys()[4],
                  pWait->phNotifys()[5],
                  pWait->phNotifys()[6],
                  pWait->phNotifys()[7],
                  pWait->phNotifys()[8] ));

        //
        // Wait on multiple NotifyWork notification handles.
        // (Including our trigger event.)
        //
        dwWait = WaitForMultipleObjects(
                     cAwake + 1,
                     pWait->_ahNotifyArea,
                     FALSE,
                     dwTimeout);


        if( dwWait == WAIT_FAILED )
        {
            // that means we ended up with WAIT_FAILED, this should
            // never happen, so just break if we are running under a debugger
            RIP(false);

            // handle this in the case where we are not under a debugger
            Sleep( pNotify->_dwSleepTime );
            goto Reset;
        }

        //
        // This is a liitle noise, which help us to repro the
        // race condition of bug #321606.
        //
        // if( rand() % 2 )
        //     Sleep( 4 + rand() % 20 );

        if( dwWait == WAIT_TIMEOUT )
        {
            DBGMSG( DBG_NOTIFY,
                    ( "Notify.vRun: %x TIMEOUT, cAwake old %d cObjects %d (%d)\n",
                       pNotify, cAwake, cObjects, pWait->_cNotifyWork ));

            //
            // We had a notification recently, but we didn't want to spin,
            // so we took it out of the list.  Add everyone back in.
            //
            goto Reset;
        }

        if( dwWait == WAIT_OBJECT_0 )
        {
            //
            // We are not suspended now, so resume requests shouldn't occur here.
            //
            SPLASSERT(pNotify->CSGuard._eOperation != TNotify::kEopResumeRequest);

            if( pNotify->CSGuard._eOperation == TNotify::kEopSuspendRequest )
            {
                //
                // Someone has requested us to suspend the callbacks and
                // and wait on the trigger event for the register/unregister
                // requests only.
                //
                SetEvent(pNotify->_shEventProcessed);

                for( ;; )
                {
                    if( WAIT_OBJECT_0 == WaitForSingleObject(pWait->_ahNotifyArea[0], INFINITE) )
                    {
                        //
                        // We are in suspended mode already, so suspend requests shouldn't occur here.
                        //
                        SPLASSERT(pNotify->CSGuard._eOperation != TNotify::kEopSuspendRequest);

                        if( pNotify->CSGuard._eOperation == TNotify::kEopExitRequest )
                        {
                            //
                            // We've been asked to exit the thead. This should only happen
                            // when there are no more handles to wait on.
                            //
                            SPLASSERT( !pWait->_cNotifyWork );

                            DBGMSG( DBG_NOTIFY, ( "Wait.vRun exits %x\n", pWait ));
                
                            SetEvent(pNotify->_shEventProcessed);
                            return; // exit thread!
                        }

                        if( pNotify->CSGuard._eOperation == TNotify::kEopResumeRequest )
                        {
                            //
                            // Resume watching all event handles.
                            //
                            SetEvent(pNotify->_shEventProcessed);
                            goto Reset;
                        }

                        pWait->vProcessOperation();
                        SetEvent(pNotify->_shEventProcessed);
                    }
                    else
                    {
                        DBGMSG( DBG_ERROR,
                                ( "Notify.Run: WaitForSingleObject failed %x %d\n",
                                  pNotify, GetLastError( )));

                        goto Reset;
                    }
                }
            }
            //
            // We have a genuine register event.  The thread that triggered
            // this event holds the critical section, so we don't need to
            // grab it.  When we set _shEventProcessed, the requester will
            // release it.
            //
            pWait->vProcessOperation();
            SetEvent(pNotify->_shEventProcessed);

            DBGMSG( DBG_NOTIFY,
                    ( "Notify.vRun: %x ProcessOperation, cAwake old %d cObjects %d (%d)\n",
                      pNotify, cAwake, cObjects, pWait->_cNotifyWork ));

            goto Reset;
        }

        if( dwWait < WAIT_OBJECT_0 + cObjects + 1 )
        {
            dwWait -= WAIT_OBJECT_0;
            SPLASSERT( dwWait != 0 );

            //
            // dwWait is one over the number of the item that triggered
            // since we put our own handle in slot 0.
            //
            --dwWait;

            //
            // NotifyWork has notification, process it.
            //
            pWait->_apNotifyWork[dwWait]->vProcessNotifyWork(pNotify);

            //
            // Once we handle a notification on a NotifyWork, we
            // don't want to watch the handle immediately again,
            // since we may spin in a tight loop getting notifications.
            // Instead, ignore the handle and sleep for a bit.
            //
            if( dwTimeout == INFINITE )
            {
                dwTimeout = pNotify->_dwSleepTime;
            }

            DBGMSG( DBG_NOTIFY,
                    ( "Wait.vRun: %x index going to sleep %d work %x handle %x (%d)\n",
                      pWait, dwWait,
                      pWait->_apNotifyWork[dwWait],
                      pWait->phNotifys()[dwWait],
                      pWait->_cNotifyWork ));

            //
            // Swap it to the end so that we can decrement
            // cObjects and not watch it for a while.
            //
            HANDLE hNotify = pWait->phNotifys()[dwWait];
            pNotifyWork = pWait->_apNotifyWork[dwWait];

            //
            // Another one has gone to sleep.  Decrement it now.
            //
            --cAwake;

            //
            // Now swap the element that needs to sleep with the
            // element that's at the end of the list.
            //
            pWait->phNotifys()[dwWait] = pWait->phNotifys()[cAwake];
            pWait->_apNotifyWork[dwWait] = pWait->_apNotifyWork[cAwake];

            pWait->phNotifys()[cAwake] = hNotify;
            pWait->_apNotifyWork[cAwake] = pNotifyWork;

        }
        else
        {
            DBGMSG( DBG_ERROR,
                    ( "Notify.Run: WaitForMultipleObjects failed %x %d\n",
                      pNotify, GetLastError( )));

            // that means we ended up with WAIT_ABANDONED + N, this should
            // never happen, so just break if we are running under a debugger
            RIP(false);

            Sleep( pNotify->_dwSleepTime );
            goto Reset;
        }
    }
}

/////////////////////////////////////////////////////
// MNotifyWork
//

MNotifyWork::
~MNotifyWork(
    VOID
    )
{
    // must be unregistered
    RIP(NULL == _pWait);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\ntfyjob.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1995
All rights reserved

Module Name:

    ntfyjob.h

Abstract:

    List of fields supported for printer notifications (jobs).  These
    must match JOB_NOTIFY_FIELD_* in winspool.h (order included).

Author:

    Albert Ting (AlbertT) 29-Sept-94

Environment:

    User Mode -Win32

Revision History:

--*/

//      Name,                Attributes,           Router,                   Localspl,                 Offsets

DEFINE( PRINTER_NAME       , TABLE_ATTRIB_COMPACT                     , TABLE_STRING            , TABLE_JOB_PRINTERNAME   , pIniPrinter )
DEFINE( MACHINE_NAME       , TABLE_ATTRIB_COMPACT                     , TABLE_STRING            , TABLE_STRING            , pMachineName )
DEFINE( PORT_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_JOB_PORT          , pIniPort )
DEFINE( USER_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pUser )
DEFINE( NOTIFY_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pNotify )
DEFINE( DATATYPE           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pDatatype )
DEFINE( PRINT_PROCESSOR    , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_PRINTPROC         , pIniPrintProc )
DEFINE( PARAMETERS         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pParameters )
DEFINE( DRIVER_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_DRIVER            , pIniDriver )
DEFINE( DEVMODE            , TABLE_ATTRIB_COMPACT                     , TABLE_DEVMODE           , TABLE_DEVMODE           , pDevMode )
DEFINE( STATUS             , 0                                        , TABLE_DWORD             , TABLE_JOB_STATUS        , Status )
DEFINE( STATUS_STRING      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pStatus )
DEFINE( SECURITY_DESCRIPTOR, TABLE_ATTRIB_COMPACT                     , TABLE_SECURITYDESCRIPTOR, TABLE_SECURITYDESCRIPTOR, pSecurityDescriptor )
DEFINE( DOCUMENT           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_STRING            , TABLE_STRING            , pDocument )
DEFINE( PRIORITY           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , Priority )
DEFINE( POSITION           , 0                                        , TABLE_DWORD             , TABLE_JOB_POSITION      , signature )
DEFINE( SUBMITTED          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_TIME              , TABLE_TIME              , Submitted )
DEFINE( START_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , StartTime )
DEFINE( UNTIL_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , UntilTime )
DEFINE( TIME               , TABLE_ATTRIB_COMPACT                     , TABLE_DWORD             , TABLE_DWORD             , Time )
DEFINE( TOTAL_PAGES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cPages )
DEFINE( PAGES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cPagesPrinted )
DEFINE( TOTAL_BYTES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , Size )
DEFINE( BYTES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY, TABLE_DWORD             , TABLE_DWORD             , cbPrinted )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\ntfyprn.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1995
All rights reserved

Module Name:

    ntfyprn.dat

Abstract:

    List of fields supported for printer notifications.  These
    must match PRINTER_NOTIFY_FIELD_* in winspool.h (order included).

Author:

    Albert Ting (AlbertT) 29-Sept-94

Environment:

    User Mode -Win32

Revision History:

--*/

//      Name,                Attributes,           Router,                   Localspl,                 Offsets

DEFINE( SERVER_NAME        , TABLE_ATTRIB_COMPACT                                          , TABLE_STRING            , TABLE_PRINTER_SERVERNAME, signature )
DEFINE( PRINTER_NAME       , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pName )
DEFINE( SHARE_NAME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pShareName )
DEFINE( PORT_NAME          , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_PRINTER_PORT      , signature )
DEFINE( DRIVER_NAME        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_DRIVER            , pIniDriver )
DEFINE( COMMENT            , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pComment )
DEFINE( LOCATION           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pLocation )
DEFINE( DEVMODE            , TABLE_ATTRIB_COMPACT                                          , TABLE_DEVMODE           , TABLE_DEVMODE           , pDevMode )
DEFINE( SEPFILE            , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pSepFile )
DEFINE( PRINT_PROCESSOR    , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_PRINTPROC         , pIniPrintProc )
DEFINE( PARAMETERS         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pParameters )
DEFINE( DATATYPE           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_STRING            , pDatatype )
DEFINE( SECURITY_DESCRIPTOR, TABLE_ATTRIB_COMPACT                                          , TABLE_SECURITYDESCRIPTOR, TABLE_SECURITYDESCRIPTOR, pSecurityDescriptor )
DEFINE( ATTRIBUTES         , 0                                                             , TABLE_DWORD             , TABLE_DWORD             , Attributes )
DEFINE( PRIORITY           , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , Priority )
DEFINE( DEFAULT_PRIORITY   , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , DefaultPriority )
DEFINE( START_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , StartTime )
DEFINE( UNTIL_TIME         , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , UntilTime )
DEFINE( STATUS             , 0                                                       , TABLE_DWORD                   , TABLE_DWORD             , Status )
DEFINE( STATUS_STRING      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_STRING            , TABLE_NULLSTRING        , signature )
DEFINE( CJOBS              , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cJobs )
DEFINE( AVERAGE_PPM        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , AveragePPM )
DEFINE( TOTAL_PAGES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_ZERO              , signature )
DEFINE( PAGES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cTotalPagesPrinted )
DEFINE( TOTAL_BYTES        , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_ZERO              , signature )
DEFINE( BYTES_PRINTED      , TABLE_ATTRIB_COMPACT|TABLE_ATTRIB_DISPLAY                     , TABLE_DWORD             , TABLE_DWORD             , cTotalBytes )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\ntfytab.h ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1995
All rights reserved

Module Name:

    ntfytab.h

Abstract:

    Table definitions for ntfy*.h.  There must not be any structure
    definitions here since this is included in winspl.idl.  The midl
    compiler generates winspl.h which would include these definions, and
    some files include both ntfytab.h and winspl.h (causing duplicate
    definitions).  This file should hold just #defines.

Author:

    Albert Ting (AlbertT) 04-Oct-94

Environment:

    User Mode -Win32

Revision History:

--*/

#ifndef _NTFYTAB_H
#define _NTFYTAB_H

#define TABLE_NULL                0x0
#define TABLE_DWORD               0x1
#define TABLE_STRING              0x2
#define TABLE_DEVMODE             0x3
#define TABLE_TIME                0x4
#define TABLE_SECURITYDESCRIPTOR  0x5
#define TABLE_PRINTPROC           0x6
#define TABLE_DRIVER              0x7

#define TABLE_ZERO                0xf0
#define TABLE_NULLSTRING          0xf1
#define TABLE_SPECIAL             0xff

#define TABLE_JOB_STATUS          0x100
#define TABLE_JOB_POSITION        0x101
#define TABLE_JOB_PRINTERNAME     0x102
#define TABLE_JOB_PORT            0x103

#define TABLE_PRINTER_DRIVER      0x200
#define TABLE_PRINTER_PORT        0x201
#define TABLE_PRINTER_SERVERNAME  0x202

//
// Must match above #defines (act TABLE_* acts as an index
// to the below array).
//
#define NOTIFY_DATATYPES \
{ \
    0,                     \
    0,                     \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    TABLE_ATTRIB_DATA_PTR, \
    0                      \
}

#define TABLE_ATTRIB_DATA_PTR  0x2


#define kInvalidNotifyField ((WORD)-1)
#define kInvalidNotifyType ((WORD)-1)
//
// index = PRINTER_NOTIFY_TYPE
// value = bytes from PRINTER_NOTIFY_INFO_DATA to actual data.
// (Job has 4 bytes for JobId).
//
//#define NOTIFY_PRINTER_DATA_OFFSETS { 0, 4 }

#define NOTIFY_TYPE_MAX             0x02
#define PRINTER_NOTIFY_NEXT_INFO    0x01

//
// COMPACT   = Data is a DWORD (TABLE_ATTRIB_DATA_PTR must not be set)
//             Router will overwrite and compact old data.
// DISPLAY   = This attribute is displayable in PrintUI
//
#define TABLE_ATTRIB_COMPACT   0x1
#define TABLE_ATTRIB_DISPLAY   0x2


//
// The reply system can support different types of callbacks.
// These types are defined here and are used for RPC marshalling.
//
#define REPLY_PRINTER_CHANGE  0x0


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\permc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1997
All rights reserved.

Module Name:

    permc.cxx

Abstract:

    Per Machine Connections

Author:

    Ramanathan Venkatapathy (3/18/97)

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "permc.hxx"
#include "rundll.hxx"

VOID
vAddPerMachineConnection(
    IN LPCTSTR  pServer,
    IN LPCTSTR  pPrinterName,
    IN LPCTSTR  pProvider,
    IN BOOL     bQuiet
    )
/*++
Function Description: This function calls AddPerMachineConnection API. If the call fails
                      and quiet mode is not set, a message box gives the last error.

Parameters: pServer,pPrinterName,pPrintServer,pProvider - arguments for the
                                                          AddPerMachineConnection API call.
            bQuiet - flag for quiet mode. This is set if /q option is used.

Return Value: NONE.

--*/
{
    LPCTSTR pPrintServer;
    LPCTSTR pPrinter;
    TCHAR szScratch[kPrinterBufMax];

    //
    // Split the printer name into its components.
    //
    vPrinterSplitFullName( szScratch, pPrinterName, &pPrintServer, &pPrinter );


    if (!AddPerMachineConnection(pServer,pPrinterName,pPrintServer,pProvider)
        && !bQuiet) {
            iMessage( NULL,
                      IDS_RUNDLL_TITLE,
                      IDS_ERR_ADD_MACHINE_CONNECTION,
                      MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                      kMsgGetLastError,
                      NULL );
    }
}

VOID
vDeletePerMachineConnection(
    IN LPCTSTR  pServer,
    IN LPCTSTR  pPrinterName,
    IN BOOL     bQuiet
    )
/*++
Function Description: This function calls DeletePerMachineConnection API. If the call fails
                      and quiet mode is not set, a message box gives the last error.

Parameters: pServer,pPrinterName - arguments for the DeletePerMachineConnection API call.
            bQuiet - flag for quiet mode. This is set if /q option is used.

Return Value: NONE.

--*/
{

   if (!DeletePerMachineConnection(pServer,pPrinterName)
       && !bQuiet) {
           iMessage( NULL,
                     IDS_RUNDLL_TITLE,
                     IDS_ERR_DELETE_MACHINE_CONNECTION,
                     MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                     kMsgGetLastError,
                     NULL );
   }

}

VOID
vEnumPerMachineConnections(
    IN LPCTSTR  pServer,
    IN LPCTSTR  pszFileName,
    IN BOOL     bQuiet
    )
/*++
Function Description: This function calls the EnumPerMachineConnection API to enumerate
                      the per machine printer connections at pServer.

Parameters: pServer - pointer to the name of the machine on which the per machine connections
                      are to be enumerated.
            pszFileName - pointer to the file name where the connection data is to be dumped.
                          If it is NULL or szNULL, the data is displayed in a EditBox.
            bQuiet - flag indicating quiet mode. It is set by using the /q option.

Return Values: NONE.
--*/
{
    DWORD cbBuf = 0;
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD dwWritten;
    PPRINTER_INFO_4  pPrinterEnum=NULL;
    DWORD index;
    TStatusB  bStatus;
    HANDLE hOutputFile = NULL;
    TCHAR  szNewLine[] = TEXT("\r\n");

    bStatus  DBGNOCHK = TRUE;

    TRunDllDisplay PrEnum(NULL, pszFileName,
                                (pszFileName && *pszFileName) ? TRunDllDisplay::kFile
                                                              : TRunDllDisplay::kEditBox);

    bStatus DBGCHK = VALID_OBJ( PrEnum );

    if (bStatus) {

       if (!(pszFileName && *pszFileName)) {

          TString strTemp;
          if (bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_ERR_RUNDLL_MACHINE_CONNECTION )) {

               bStatus DBGCHK = PrEnum.SetTitle( strTemp );
          }
       }
    }

    if (bStatus) {

       cbBuf = 1000;
       if (!(pPrinterEnum = (PPRINTER_INFO_4) AllocMem(cbBuf))) {
           bStatus DBGCHK = FALSE;
       }
    }

    if (bStatus) {
       while (!(bStatus DBGCHK = EnumPerMachineConnections(pServer,(LPBYTE)pPrinterEnum,cbBuf,
                                                           &cbNeeded,&cReturned)) &&
              (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

            FreeMem(pPrinterEnum);
            if (!(pPrinterEnum = (PPRINTER_INFO_4) AllocMem(cbNeeded))) {
               bStatus DBGCHK = FALSE;
               break;
            }
            cbBuf = cbNeeded;
       }
    }

    if (bStatus) {
       for (index=0;cReturned;cReturned--,index++) {
          if (!PrEnum.WriteOut(TEXT("Printer Name: ")) ||
              !PrEnum.WriteOut(pPrinterEnum[index].pPrinterName) ||
              !PrEnum.WriteOut(szNewLine) ||
              !PrEnum.WriteOut(TEXT("Server Name: ")) ||
              !PrEnum.WriteOut(pPrinterEnum[index].pServerName) ||
              !PrEnum.WriteOut(szNewLine) ||
              !PrEnum.WriteOut(szNewLine)) {

               bStatus DBGCHK = FALSE;
               break;
          }
       }
    }

    if (bStatus) {
       PrEnum.bDoModal();
    }

    if (pPrinterEnum) {
       FreeMem(pPrinterEnum);
    }

    if (!bStatus && !bQuiet) {
       iMessage( NULL,
                 IDS_RUNDLL_TITLE,
                 IDS_ERR_ENUM_MACHINE_CONNECTION,
                 MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                 GetLastError() != ERROR_SUCCESS ? kMsgGetLastError : kMsgNone,
                 NULL );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\parser.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999
All rights reserved.

Module Name:

    parse.cxx

Abstract:

    Command line parser.

Author:

    Steve Kiraly (SteveKi)  04-Mar-1997

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "parser.hxx"

/*++

Routine Name:

    Memory allocations.

Routine Description:

    Uses new and delete when a C++ file.
    
Arguments:

    Normal allocation routines.

Return Value:

    N/A

--*/
static inline PVOID private_alloc( UINT size )
{
    return new BYTE [ size ];
}

static inline VOID private_free( PVOID pvoid )
{
    delete [] pvoid;
}

/*++

Routine Name:

    StringToArgv

Routine Description:

    Coverts a commandline string to an array of pointers 
    to string.
    
Arguments:

    TCHAR *string  - pointer to command line string.
    TCHAR *pac     - pointer to an int on return will contain the 
                     number of strins in the arrary of pointes.
    TCHAR **string - pointer to where to return a pointer to the 
                     array of pointers to strings.

Return Value:

    TRUE if success, FALSE error occurred.

Notes:

--*/
BOOL
StringToArgv(
    const TCHAR   *str,
          UINT    *pac,
          TCHAR ***pppav,
          BOOL     bParseExeName
    )
{
	TCHAR    *word          = NULL;
	TCHAR    *w             = NULL;
	TCHAR    *program_name  = NULL;
    TCHAR  **av             = NULL;
    LPTSTR   string         = NULL;
    UINT     ac             = 0;
    UINT     numslash;
    BOOL     inquote;
    BOOL     copychar;
    BOOL     retval         = TRUE;
    TString  strString;

    //
    // The pointers passed in must be valid.
    //
    if( !str || !pac || !pppav )
    {
        SPLASSERT( FALSE );
        return FALSE;
    } 

    //
    // Process any file redirection.
    //
    vProcessCommandFileRedirection( str, strString );

    //
    // Cast the string to a usable string pointer.
    //
    string = const_cast<LPTSTR>( static_cast<LPCTSTR>( strString ) );

    // 
    // Allocate the word buffer, this the maximum size in case there is 
    // just one extreamly long argument.
    //
    word = (LPTSTR) private_alloc( sizeof (TCHAR) * (lstrlen (string) + 1) );

    if( word )
    {
        //
        // If we are to get the parse the program name from the provided command line.
        //        
        if( bParseExeName )
        {
            retval = IsolateProgramName( string, word, &string );

            //
            // If program name found.
            //
            if( retval )
            {
                //
                // Add the program name to the argv list.
                //
                retval = AddStringToArgv( &av, word );

                if( retval )
                {
                    ac++;
                }
            }
        }
    }
    else
    {
        retval = FALSE;
    }

	for ( ; retval && *string; ac++ )
    {
	    //
		// Skip any leading spaces.
		//
		for (; *string && _istspace(*string); string++);

		//
		// Get a word out of the string 
		//
		for (copychar = 1, inquote = 0, w = word; *string; copychar = 1)
        {
            //
            // Rules: 2N backslashes + "    ==> N backslashes and begin/end quote
            //        2N+1 backslashes + "  ==> N backslashes + literal "
            //        N backslashes         ==> N backslashes 
            //
            for( numslash = 0; *string == TEXT('\\'); string++ )
            {
                //
                // count number of backslashes for use below 
                //
                numslash++;
            }

            if (*string == TEXT('"'))
            {
                //
                // if 2N backslashes before, start/end quote, otherwise
                // copy literally 
                //
                if (numslash % 2 == 0)
                {
                    if (inquote)
                    {
                        //
                        // Double quote inside quoted string 
                        // skip first quote char and copy second 
                        //
                        if (*(string+1) == TEXT('"') )
                        {
                            string++;       
                        }
                        else                
                        {
                            copychar = 0;
                        }
                    }
                    else
                    {
                        //
                        // don't copy quote 
                        //
                        copychar = 0;       
                    }

                    inquote = !inquote;

                }

                //
                // Divide numslash by two 
                //
                numslash /= 2;              

            }

            // 
            // Copy the slashes 
            //
            for( ; numslash; numslash--)
            {
                *w++ = TEXT('\\');
            }

            //
            // If at the end of the command line or 
            // a space has been found.
            //
            if( !*string || (!inquote && _istspace(*string)))
            {
                break;
            }

            //
            // copy character into argument 
            //
            if (copychar)
            {
                *w++ = *string;
            }

            string++;
        }

		//
		// Terminate the word
		//
		*w = 0;

        retval = AddStringToArgv( &av, word );

	}

    //
    // Free up the word buffer.
    //
    if( word )
    {
    	private_free( word );
    }

    if( retval )
    {
        *pac = ac;
        *pppav = av;
    }

#if DBG
    vDumpArgList( ac, av );
#endif

	return retval;
}

/*++

Routine Name:

    ReleaseArgv

Routine Description:

    Releases the argv pointer to an array of pointers to 
    strings.  
    
Arguments:

    TCHAR **av - pointer to an arrary of pointers to strings.

Return Value:

    Nothing.

Notes:

    This routine releases the strings as well as the arrary of 
    pointers to strings.

--*/
VOID
ReleaseArgv( 
    TCHAR **av 
    )
{
    TCHAR **tav;

    if( av )
    {
        for( tav = av; *tav; tav++ )
        {
            if( *tav )
            {
                private_free( *tav );
            }
        }
        private_free( av );
    }
}


/*++

Routine Name:

    IsolateProgramName

Routine Description:

    Extracts the program name from the specified string.  
    This routing is used because the program name follows 
    a differenct parsing technique from the other command
    line arguments.
    
Arguments:

    TCHAR *p    - pointer to a string which contains the program name.
    TCHAR *program_name - pointer buffer where to place the extracted 
                  program.
    TCHAR **string - pointer to where to return a pointer where the 
                  program name ended.  Used as the start of the string
                  for nay remaing command line arguments.

Return Value:

    TRUE if success, FALSE error occurred.

Notes:

    This routine is very specific to the NTFS file nameing
    format.

--*/
BOOL
IsolateProgramName( 
    const TCHAR *p,
          TCHAR *program_name, 
          TCHAR **string
    )
{
    BOOL retval = FALSE;
    TCHAR c;
    
    //
    // All the arguments must be valid.
    //        
    if( p && program_name && *string )
    {
        retval = TRUE;
    }
    
    //
    // Skip any leading spaces.
    //
    for( ; retval && *p && _istspace(*p); p++ );
    
    //
    // A quoted program name is handled here. The handling is much
    // simpler than for other arguments. Basically, whatever lies
    // between the leading double-quote and next one, or a terminal null
    // character is simply accepted. Fancier handling is not required
    // because the program name must be a legal NTFS/HPFS file name.
    //
    if (retval && *p == TEXT('"'))
    {
        //
        // scan from just past the first double-quote through the next
        // double-quote, or up to a null, whichever comes first 
        //
        while ((*(++p) != TEXT('"')) && (*p != TEXT('\0')))
        {
            *program_name++ = *p;
        }

        //
        // append the terminating null 
        //
        *program_name++ = TEXT('\0');

        //
        // if we stopped on a double-quote (usual case), skip over it 
        //
        if (*p == TEXT('"'))
        {
            p++;
        }
    }
    else
    {
        //
        // Not a quoted program name 
        //
        do {
           *program_name++ = *p;
           c = (TCHAR) *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
           *(program_name - 1) = TEXT('\0');
        }
    }

    if( retval )
    {
        *string = const_cast<TCHAR *>( p );
    }                

    return retval;

}

/*++

Routine Name:

    AddStringToArgv

Routine Description:

    Adds a string to a array of pointers to strings.  
    
Arguments:

    TCHAR ***argv - pointer where to return the new array 
                    of pointer to strings.
    TCHAR *word   - pointer to word or string to add to the array.


Return Value:

    TRUE if success, FALSE error occurred.

Notes:

    Realloc is not used here because a user of this code 
    may decide to do allocations with new and delete rather
    that malloc free.  Both the new array pointer and string 
    pointer must be valid for this routine to do anything.  
    The array pointer can point to null but the pointer cannot 
    be null.

--*/
BOOL
AddStringToArgv( 
    TCHAR ***argv, 
    TCHAR *word 
    )
{
    BOOL retval   = FALSE;
    UINT count;
    TCHAR **targv = NULL;
    TCHAR **tmp   = NULL;
    TCHAR **nargv = NULL;
    TCHAR *w      = NULL;

    if( argv && word )
    {
        //
        // Allocate the word buffer plus the null.
        //
        w = (TCHAR *)private_alloc( ( lstrlen( word ) + 1 ) * sizeof(TCHAR) );

        if( w )
        {
            //
            // Copy the word.
            //
    	    lstrcpy( w, word );

            //
            // Count the current size of the argv.
            //
	        for( count = 1, targv = *argv; targv && *targv; targv++, count++ );

            nargv = (TCHAR **)private_alloc( ( count + 1 ) * sizeof(TCHAR *) );

            if( nargv )    
            {
                //
                // Copy the orig argv to the new argv.
                //
                for( tmp = nargv, targv = *argv; targv && *targv; *nargv++ = *targv++ );

                //
                // Set the new string pointer.
                //
                *nargv++ = w;

                //
                // Mark the end.
                //
                *nargv = 0;

                //
                // Free the original argv
                //
                private_free( *argv );

                //
                // Set the return pointer.
                //
                *argv = tmp;

                retval = TRUE;
            }
        }
    }

    if( !retval )
    {
        if( w )
            private_free(w);

        if( nargv )
            private_free(nargv);
    }

    return retval;
}



/********************************************************************

    Code for commad file redirection.

********************************************************************/

/*++

Routine Name:

    vProcessCommandFileRedirection

Routine Description:


Arguments:   


Return Value:

    Nothing.

--*/
VOID
vProcessCommandFileRedirection( 
    IN      LPCTSTR pszCmdLine,
    IN OUT  TString &strCmdLine
    )
{
    DBGMSG( DBG_TRACE, ( "vProcessCommandFileRedirection\n" ) );
    DBGMSG( DBG_TRACE, ( "Pre vProcessCommandFileRedirection "TSTR"\n", pszCmdLine ) );

    SPLASSERT( pszCmdLine );

    TCHAR       szFilename [MAX_PATH];
    TCHAR       szBuffer [MAX_PATH];
    LPTSTR      pSrc         = const_cast<LPTSTR>( pszCmdLine );
    LPTSTR      pDst         = szBuffer;
    UINT        nBufferSize  = COUNTOF( szBuffer );
    TStatusB    bStatus;

    for( ; pSrc && *pSrc; )
    {
        //
        // Look for the escape character. If found - look for 
        // the special characters.
        //
        if( *pSrc == TEXT('\\') && *(pSrc+1) == TEXT('@') )
        {
            //
            // Copy the special character skipping the escape.
            //
            *pDst++ = *(pSrc+1);

            //
            // Skip two characters in the source buffer
            //
            pSrc += 2;

            //
            // Flush the buffer if it's full.
            //
            bStatus DBGCHK = bFlushBuffer( szBuffer, nBufferSize, &pDst, strCmdLine, FALSE );
        }
        //
        // Look for an redirected file sentinal.
        //
        else if( *pSrc == TEXT('@') )
        {
            //
            // Flush the current working buffer.
            //
            bStatus DBGCHK = bFlushBuffer( szBuffer, nBufferSize, &pDst, strCmdLine, TRUE );

            //
            // Isolate the file name following the sentinal, note this 
            // requires special parsing for NTFS file names.
            //
            if( IsolateProgramName( pSrc+1, szFilename, &pSrc ) )
            {
                AFileInfo FileInfo;

                //
                // Read the file into the a single buffer.
                //
                if( bReadCommandFileRedirection( szFilename, &FileInfo ) )
                {
                    //
                    // Tack on the file information to the command line.
                    //
                    bStatus DBGCHK = strCmdLine.bCat( FileInfo.pszOffset );
                }

                //
                // Release the file information.
                //
                if( FileInfo.pData )                    
                {
                    private_free( FileInfo.pData );
                }
            }
        }
        else
        {
            //
            // Copy the string to working buffer.
            //
            *pDst++ = *pSrc++;

            //
            // Flush the buffer if it's full.
            //
            bStatus DBGCHK = bFlushBuffer( szBuffer, nBufferSize, &pDst, strCmdLine, FALSE );
        }
    }

    //
    // Flush any remaining items into the command line string.
    //
    bStatus DBGCHK = bFlushBuffer( szBuffer, nBufferSize, &pDst, strCmdLine, TRUE );

    DBGMSG( DBG_TRACE, ( "Post vProcessCommandFileRedirection "TSTR"\n", (LPCTSTR)strCmdLine ) );
}

/*++

Routine Name:

    bFlushBuffer

Routine Description:

    Flushed the working buffer for builing the complete 
    redirected command string.

Arguments:   

    pszBuffer       - Pointer to working buffer. 
    nSize           - Total size in bytes of working buffer.  
    pszCurrent      - Current pointer into working buffer,      
    strDestination  - Reference to destination string buffer.
    bForceFlush     - TRUE force buffer flush, FALSE flush if full.

Return Value:

    TRUE buffer flushed successfully, FALSE error occurred.

--*/
BOOL
bFlushBuffer( 
    IN      LPCTSTR  pszBuffer, 
    IN      UINT     nSize,
    IN OUT  LPTSTR  *pszCurrent, 
    IN OUT  TString &strDestination, 
    IN      BOOL     bForceFlush
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    //
    // If something is in the buffer.
    //
    if( *pszCurrent != pszBuffer )
    {
        //
        // If the destination buffer is full.
        // nsize - 2 because the pointers are zero base and the 
        // we need one extra slot for the null terminator.
        //
        if( ( *pszCurrent > ( pszBuffer + nSize - 2 ) ) || bForceFlush )
        {
            //
            // Null terminate the working buffer.
            //
            **pszCurrent = 0;

            //
            // Tack on the string to the destination string.
            //                
            bStatus DBGCHK = strDestination.bCat( pszBuffer );

            //
            // Reset the current buffer pointer.
            //
            *pszCurrent = const_cast<LPTSTR>( pszBuffer );
        }
    }
    return bStatus;
}

/*++

Routine Name:

    bReadCommandFileRedirection

Routine Description:

    Read the filename into a single string. This in my 
    opinion is a hack, but does the job.  I made the assumption
    the commad file will always be less than 16k in size.
    Because the file size assumption was made it became feasable 
    to just read the file into one potentialy huge buffer.  Note 
    the file is not broken up into separate lines the new lines are 
    modified inplace to spaces.  The StringToArgv will parse the  
    line into an argv list ignoring spaces where appropriate.

Arguments:   
    szFilename  - pointer to the redirected filename.
    pFileInfo   - pointe to file information structure.

Return Value:

    TRUE function complete ok.  FALSE error occurred.

--*/
BOOL
bReadCommandFileRedirection( 
    IN LPCTSTR    szFilename,
    IN AFileInfo *pFileInfo
    ) 
{
    DBGMSG( DBG_TRACE, ( "bReadCommandFileRedirection\n" ) );
    DBGMSG( DBG_TRACE, ( "szFilename "TSTR"\n", szFilename ) );

    HANDLE  hFile       = INVALID_HANDLE_VALUE;
    BOOL    bReturn     = FALSE;
    DWORD   dwBytesRead = 0;
    DWORD   dwFileSize  = 0;
    LPTSTR  pszUnicode  = NULL;

#ifdef UNICODE

    enum { kByteOrderMark = 0xFEFF, 
           kMaxFileSize   = 16*1024 };

    memset( pFileInfo, 0, sizeof( AFileInfo ) );

    //
    // Open the redirected file.
    //
    hFile = CreateFile ( szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );                       

    if( hFile != INVALID_HANDLE_VALUE )
    {
        // 
        // Validate the file size.
        //
        dwFileSize = GetFileSize( hFile, NULL );
        
        //
        // We fail the call if the file is bigger than a reasonable 
        // file size.  This was a decision made to make
        // reading the file into a contiguous buffer a reasonable
        // approach.
        //
        if( dwFileSize <= kMaxFileSize )
        {
            //
            // Allocate buffer to hold entire file plus a null terminator.
            //
            pFileInfo->pData = (PVOID)private_alloc( dwFileSize + sizeof( TCHAR ) );

            if( pFileInfo->pData )
            {           
                //
                // Read the file into one huge buffer.
                //
                bReturn = ReadFile( hFile, pFileInfo->pData, dwFileSize, &dwBytesRead, NULL );

                //
                // If the read succeeded.
                //
                if( bReturn && dwBytesRead == dwFileSize )
                {
                    //
                    // Assume failure.
                    //                            
                    bReturn = FALSE;

                    //
                    // Check for the byte order mark, This mark allows use to 
                    // read both ansi and unicode file.
                    //
                    if( *(LPWORD)pFileInfo->pData != kByteOrderMark )
                    {
                        DBGMSG( DBG_TRACE, ( "Ansi file found\n" ) );

                        //
                        // Null terminate the file.
                        //
                        *((LPBYTE)pFileInfo->pData + dwBytesRead) = 0;

                        pszUnicode = (LPTSTR)private_alloc( ( strlen( (LPSTR)pFileInfo->pData ) + 1 ) * sizeof(TCHAR) );

                        if( pszUnicode )
                        {
                            if( AnsiToUnicodeString( (LPSTR)pFileInfo->pData, pszUnicode, 0 ) )
                            {
                                //
                                // Release the ansi string, and assign the unicode string.
                                // then set the offset.
                                //
                                private_free( pFileInfo->pData );
                                pFileInfo->pData        = pszUnicode;
                                pFileInfo->pszOffset    = pszUnicode;
                                bReturn                 = TRUE;
                            }
                        }
                    }
                    else
                    {
                        DBGMSG( DBG_TRACE, ( "Unicode file found\n" ) );

                        //
                        // Null terminate file string.
                        //
                        *((LPBYTE)pFileInfo->pData + dwBytesRead) = 0;
                        *((LPBYTE)pFileInfo->pData + dwBytesRead+1) = 0;

                        //
                        // Set the file offset to just after the byte mark.
                        //
                        pFileInfo->pszOffset = (LPTSTR)((LPBYTE)pFileInfo->pData + sizeof( WORD ) );
                        bReturn = TRUE;
                    }

                    if( bReturn )
                    {
                        //
                        // Replace carriage returns and line feeds with spaces.
                        // The spaces will be removed when the command line is 
                        // converted to an argv list.
                        //
                        vReplaceNewLines( pFileInfo->pszOffset );
                    }
                }
            }       
        }
        else
        {
            DBGMSG( DBG_WARN, ( "Redirected file too large %d.\n", dwFileSize ) );
        }
        CloseHandle( hFile );
    }
    
    //
    // If something failed release all allocated resources.
    //        
    if( !bReturn )
    {
        private_free( pFileInfo->pData );
        private_free( pszUnicode );
        pFileInfo->pData        = NULL;
        pFileInfo->pszOffset    = NULL;
    }

#endif

    return bReturn;
}

/*++

Routine Name:

    vReplaseCarriageReturnAndLineFeed

Routine Description:

    Replace carriage returns and line feeds with spaces.

Arguments:   

    pszLine - pointer to line buffer where to replace carriage
              returns and line feed characters.

Return Value:

    Nothing.

--*/
VOID
vReplaceNewLines( 
    IN LPTSTR pszLine
    )
{
    DBGMSG( DBG_TRACE, ( "vReplaceNewLines\n" ) );

    for( LPTSTR p = pszLine; p && *p; ++p )
    {
        if( *p == TEXT('\n') || *p == TEXT('\r') )
        {
            *p = TEXT(' ');
        }
    }
}

/*++

Routine Name:

    AnsiToUnicodeString

Routine Description:

    Converts an ansi string to unicode.

Arguments:   

    pAnsi        -  Ansi string to convert.
    pUnicode     -  Unicode buffer where to place the converted string.
    StringLength -  Ansi string argument length, this may be null 
                    then length will be calculated.

Return Value:

    Return value from MultiByteToWideChar.

--*/
INT 
AnsiToUnicodeString( 
    IN LPSTR pAnsi, 
    IN LPWSTR pUnicode, 
    IN DWORD StringLength OPTIONAL
    )
{
    INT iReturn;

    if( StringLength == 0 )
    {
        StringLength = strlen( pAnsi );
    }

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  -1,
                                  pUnicode,
                                  StringLength + 1 );
    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}

/*++

Routine Name:

    vDumpArgList

Routine Description:

    Dumps the arg list to the debugger.

Arguments:   

    ac          - Count of strings in the argv list.
    av          - Pointer to an array of pointers to strings, 
                  which I call an argv list.

Return Value:

    Return value from MultiByteToWideChar.

--*/

#if DBG

VOID
vDumpArgList( 
    UINT    ac, 
    TCHAR **av 
    )
{
    DBGMSG( DBG_TRACE, ( "vDumpArgList\n" ) );

    for( UINT i = 0; ac; --ac, ++av, ++i )
    {
        DBGMSG( DBG_TRACE, ( "%d - "TSTR"\n", i, *av ) );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\physloc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    location.cxx

Abstract:

    This module provides all the functions for determining the
    machines current physical location.

Author:

    Steve Kiraly (SteveKi) 13-July-1998

Revision History:

    Steve Kiraly (SteveKi) 13-July-1998 Genesis

--*/

#include <precomp.hxx>
#pragma hdrstop

#include "dsinterf.hxx"
#include "persist.hxx"
#include "physloc.hxx"

const IN_ADDR c_LoopBackAddress = { 127,0,0,1 };

/*++

Name:

    TPhysicalLocation

Description:

    TPhysicalLocation constructor.

Arguments:

    None.

Return Value:

    Nothing.

Notes:

--*/
TPhysicalLocation::
TPhysicalLocation(
    VOID
    ) : m_fInitalized( FALSE ),
        m_eDiscoveryType( kDiscoveryTypeUnknown ),
        m_IpHlpApi( gszIpHlpApiLibrary ),
        m_GetIpAddrTable( NULL ),
        m_SecExt( gszSecurityLibrary ),
        m_GetComputerObjectName( NULL ),
        m_GetUserNameEx( NULL ),
        m_NetApi( gszNetApiLibrary ),
        m_DsAddressToSiteNames( NULL ),
        m_NetApiBufferFree( NULL ),
        m_WinSock( gszWinSockLibrary ),
        m_inet_ntoa( NULL )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::ctor.\n" ) );

    //
    // Check if the Ip helper library was loaded.
    //
    if (m_IpHlpApi.bValid())
    {
        m_GetIpAddrTable = reinterpret_cast<pfGetIpAddrTable>( m_IpHlpApi.pfnGetProc( "GetIpAddrTable" ) );
    }

    //
    // Check if the security library was loaded.
    //
    if (m_SecExt.bValid())
    {
        m_GetComputerObjectName = reinterpret_cast<pfGetComputerObjectName>( m_SecExt.pfnGetProc( "GetComputerObjectNameW" ) );
        m_GetUserNameEx         = reinterpret_cast<pfGetUserNameEx>( m_SecExt.pfnGetProc( "GetUserNameExW" ) );
    }

    //
    // Check if the netapi library was loaded.
    //
    if (m_NetApi.bValid())
    {
        m_DsAddressToSiteNames  = reinterpret_cast<pfDsAddressToSiteNames>( m_NetApi.pfnGetProc( "DsAddressToSiteNamesExW" ) );
        m_NetApiBufferFree      = reinterpret_cast<pfNetApiBufferFree>( m_NetApi.pfnGetProc( "NetApiBufferFree" ) );
    }

    //
    // Check if the winsock library was loaded.
    //
    if (m_WinSock.bValid())
    {
        m_inet_ntoa = reinterpret_cast<LPFN_INET_NTOA>( m_WinSock.pfnGetProc( "inet_ntoa" ) );
    }

    //
    // All the function pointers must be valid for this class to be in
    // the initialized state.
    //
    if (m_GetIpAddrTable && m_GetComputerObjectName && m_GetUserNameEx && m_DsAddressToSiteNames && m_NetApiBufferFree && m_inet_ntoa)
    {
        m_fInitalized = TRUE;
    }
}

/*++

Name:

    TPhysicalLocation

Description:

    TPhysicalLocation destructor.

Arguments:

    None.

Return Value:

    Nothing.

Notes:

--*/
TPhysicalLocation::
~TPhysicalLocation(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::dtor.\n" ) );
}

/*++

Name:

    bValid

Description:

    This routine indicates if the TPhysicalLocation class is
    in a consistent state, i.e. usable.

Arguments:

    None.

Return Value:

    TRUE usable state, FALSE not usable.

Notes:

--*/
BOOL
TPhysicalLocation::
bValid(
    VOID
    ) const
{
    return m_fInitalized;
}

/*++

Name:

    Discover

Description:

    The discover routine is where all the work is done.  We attempt
    to fetch the physical location string from various sources in a
    pre defined order.  If any of the steps completes the search is
    terminated.  The current order is to look in the HKLM policy key,
    this machines location property in the DS

Arguments:

    None.

Return Value:

    TRUE usable state, FALSE not usable.

Notes:

--*/
BOOL
TPhysicalLocation::
Discover(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::Discover.\n" ) );

    //
    // Invalidate the current location information.
    //
    Invalidate();

    //
    // Read the group policy setting if it exists.
    //
    if (ReadGroupPolicyLocationSetting( m_strLocation ))
    {
        m_eDiscoveryType = kDiscoveryTypePolicy;
    }

    //
    // If a DS is available and the group policy did not have any
    // location information then continue looking for location information.
    //
    if (m_Ds.bIsDsAvailable() && m_eDiscoveryType == kDiscoveryTypeUnknown)
    {
        if (ReadMachinesLocationProperty( m_strLocation ))
        {
            m_eDiscoveryType = kDiscoveryTypeMachine;
        }
        else if (ReadSubnetLocationProperty( m_strLocation ))
        {
            m_eDiscoveryType = kDiscoveryTypeSubnet;
        }
        else if (ReadSiteLocationProperty( m_strLocation ))
        {
            m_eDiscoveryType = kDiscoveryTypeSite;
        }
    }

    return m_eDiscoveryType != kDiscoveryTypeUnknown;
}

/*++

Name:

    GetExact

Description:

    Returns the excact location string found by a call to the discover method.

Arguments:

    strLocation - reference to a string object where to return the string.

Return Value:

    TRUE search string returned, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
GetExact(
    IN TString &strLocation
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::GetExact.\n" ) );

    return strLocation.bUpdate( m_strLocation );
}

/*++

Name:

    GetSearch

Description:

    Returns a string that is valid for a search.  It widens the scope if the
    current location string is one fetched for this machine.

Arguments:

    strLocation - reference to a string object where to return the search string.

Return Value:

    TRUE search string returned, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
GetSearch(
    IN TString &strLocation
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::GetSearch.\n" ) );

    TStatusB bStatus;

    if (m_eDiscoveryType == kDiscoveryTypeMachine || m_eDiscoveryType == kDiscoveryTypePolicy)
    {
        bStatus DBGCHK = WidenScope( m_strLocation, 1, strLocation );

        //
        // If the scope could not be widen then use the current location string.
        //
        if (!bStatus)
        {
            bStatus DBGCHK = strLocation.bUpdate( m_strLocation );
        }
    }
    else
    {
        bStatus DBGCHK = strLocation.bUpdate( m_strLocation );
    }

    if( bStatus )
    {
        UINT uLen = strLocation.uLen();
        if( uLen && gchSeparator != static_cast<LPCTSTR>(strLocation)[uLen-1] )
        {
            //
            // Put the final slash after successfully
            // widening the location scope
            //
            static const TCHAR szSepStr[] = { gchSeparator };
            bStatus DBGCHK = strLocation.bCat( szSepStr );
        }
    }

    return bStatus;
}

/*++

Name:

    Invalidate

Description:

    Invalidates the location string.  After this call the location string
    is not valid until the disover method is called.

Arguments:

    None.

Return Value:

    Nothing.

Notes:

--*/
VOID
TPhysicalLocation::
Invalidate(
    VOID
    )
{
    m_eDiscoveryType = kDiscoveryTypeUnknown;
    m_strLocation.bUpdate( NULL );
}

/*++

Name:

    ReadGroupPolicyLocationSetting

Description:

    Reads the location string from the local registry that was written
    by the group policy editor.

Arguments:

    None.

Return Value:

    TRUE the location string was read, FALSE error occured or string not available.

Notes:

--*/
BOOL
TPhysicalLocation::
ReadGroupPolicyLocationSetting(
    IN OUT TString &strLocationX
    )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::ReadGroupPolicyLocationSetting.\n" ) );

    //
    // Open the registry key where the physical location is stored
    // by the group policy code.
    //
    TPersist Reg( gszGroupPolicyPhysicalLocationPath, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

    TStatusB bStatus;

    //
    // Was the key opened, i.e. does it exist?
    //
    bStatus DBGCHK = Reg.bValid();

    if (bStatus)
    {
        TString strLocation;

        //
        // Read the location string from the registry.
        //
        bStatus DBGCHK = Reg.bRead( gszGroupPolicyPhysicalLocationKey, strLocation );

        //
        // If the string was read and it is not blank then make a local copy of the
        // location string and we are done.
        //
        if (bStatus && !strLocation.bEmpty())
        {
            bStatus DBGCHK = strLocationX.bUpdate( strLocation );
        }
    }

    return bStatus;
}

/*++

Name:

    ReadUserLocationProperty

Description:

    Reads the location string from the current users object in the
    DS.

Arguments:

    None.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
ReadUserLocationProperty(
    IN OUT TString &strLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::ReadUserLocationProperty.\n" ) );

    TCHAR       szName[INTERNET_MAX_HOST_NAME_LENGTH+1];
    DWORD       dwSize = COUNTOF( szName );
    TStatusB    bStatus;

    bStatus DBGCHK = m_GetUserNameEx(NameFullyQualifiedDN, szName, &dwSize);

    if (bStatus)
    {
        TString strUserPath;
        TString strLDAPPrefix;

        bStatus DBGCHK = m_Ds.GetLDAPPrefixPerUser( strLDAPPrefix )   &&
                         strUserPath.bCat( strLDAPPrefix )     &&
                         strUserPath.bCat( szName );

        if (bStatus)
        {
            bStatus DBGCHK = m_Ds.ReadStringProperty( strUserPath, gszUserLocationPropertyName, strLocation );
        }
    }

    return bStatus;
}


/*++

Name:

    ReadMachinesLocationProperty

Description:

    Reads the location string from the machine object in the DS.

Arguments:

    None.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
ReadMachinesLocationProperty(
    IN OUT TString &strLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::ReadMachinesLocationProperty.\n" ) );

    LPTSTR      pszName = NULL;
    DWORD       dwSize  = 0;
    TStatusB    bStatus;

    bStatus DBGCHK = m_GetComputerObjectName(NameFullyQualifiedDN, NULL, &dwSize);

    if( bStatus && dwSize )
    {
        pszName = new TCHAR[dwSize+1];

        if( pszName )
        {
            bStatus DBGCHK = m_GetComputerObjectName(NameFullyQualifiedDN, pszName, &dwSize);

            if (bStatus)
            {
                TString  strComputerPath;
                TString  strLDAPPrefix;

                bStatus DBGCHK = m_Ds.GetLDAPPrefix( strLDAPPrefix )    &&
                                 strComputerPath.bCat( strLDAPPrefix )  &&
                                 strComputerPath.bCat( pszName );

                if (bStatus)
                {
                    bStatus DBGCHK = m_Ds.ReadStringProperty( strComputerPath, gszMachineLocationPropertyName, strLocation );
                }
            }

            delete [] pszName;
        }
    }

    if( bStatus )
    {
        DBGMSG( DBG_TRACE, ( "TPhysicalLocation::ReadMachinesLocationProperty " TSTR ".\n", pszName ) );
    }

    return bStatus;
}

/*++

Name:

    ReadSubnetLocationProperty

Description:

    Reads the location string from the subnet objet for this
    machine. This routine searches the list of IP address IP masks
    and finds a subnet object in the DS that closly matches this
    machine.

Arguments:

    None.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
ReadSubnetLocationProperty(
    IN OUT TString &strLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::ReadSubnetLocationProperty.\n" ) );

    TString     strSubnetPath;
    TString     strLDAPPrefix;
    TSubnets    Subnets;
    TStatusB    bStatus;

    bStatus DBGCHK = GetSubnetObjectNames( Subnets );

    if (bStatus)
    {
        for( UINT i = 0; i < Subnets.NumEntries(); i++ )
        {
            bStatus DBGCHK = m_Ds.GetLDAPPrefix( strLDAPPrefix )     &&
                             strSubnetPath.bUpdate( strLDAPPrefix )  &&
                             strSubnetPath.bCat( Subnets.Table(i) );

            if (bStatus)
            {
                bStatus DBGCHK = m_Ds.ReadStringProperty( strSubnetPath, gszSubnetLocationPropertyName, strLocation );

                if (bStatus && !strLocation.bEmpty())
                {
                    break;
                }
            }
        }
    }

    return bStatus;
}

/*++

Name:

    ReadSiteLocationProperty

Description:

    Reads the location string from the site object.  This routine
    searches the list of IP address and finds a site nearest this
    machines ip adress.  All of the searching code actually occurrs
    in the DSAddressToSiteNames api.

Arguments:

    None.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
ReadSiteLocationProperty(
    IN OUT TString &strLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TPhysicalLocation::ReadSiteLocationProperty.\n" ) );

    PMIB_IPADDRTABLE    pAddrTable = NULL;
    TStatusB            bStatus;
    TString             strSiteName;
    TString             strSubnetName;
    TString             strSubnetPath;
    IN_ADDR             IpNetAddr;

    //
    // Get the DS name.
    //
    bStatus DBGCHK = GetIpAddressTable( &pAddrTable );

    if (bStatus)
    {
        bStatus DBGNOCHK = FALSE;

        //
        // Look for a site that has a location string that corresponds
        // to the the first ipaddress in the list of ip addresses.
        //
        for (UINT i = 0; i < pAddrTable->dwNumEntries; i++)
        {
            //
            // Skip the loopback or unassigned interfaces
            //
            if ((pAddrTable->table[i].dwAddr != 0) && (pAddrTable->table[i].dwAddr != c_LoopBackAddress.s_addr))
            {
                IpNetAddr.s_addr = pAddrTable->table[i].dwAddr;

                DBGMSG( DBG_TRACE, ( "IP Address %s\n", m_inet_ntoa( IpNetAddr ) ) );

                //
                // Attempt to translate this ip address to either a site path or subnet path.
                //
                bStatus DBGNOCHK = AddrToSite( pAddrTable->table[i].dwAddr, strSiteName, strSubnetName );

                if (bStatus)
                {
                    //
                    // If a near match subnet was found use this first.
                    //
                    if (!strSubnetName.bEmpty())
                    {
                        bStatus DBGCHK = GetSubnetLocationString( strSubnetName, strLocation );
                    }

                    //
                    // If the location string was not found on the subnet then attempt to
                    // get the location on the site object.
                    //
                    if (!strSiteName.bEmpty() && strLocation.bEmpty())
                    {
                        bStatus DBGCHK = GetSiteLocationString( strSiteName, strLocation );
                    }

                    //
                    // If a location string was found exit the loop, the first ipaddress wins.
                    //
                    if (strLocation.bEmpty())
                    {
                        bStatus DBGNOCHK = FALSE;
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }
    }

    delete [] pAddrTable;

    return bStatus;
}

/*++

Name:

    GetSubnetLocationString

Description:

    Reads the location string from the subnet object.  This routine
    converts the subnet name to an adsi path then reads the location
    property fron this subnet object.

Arguments:

    pszSubnetName   - pointer string which contains the subnet name.
    strSiteLocation - reference to string object where to return the subnet
                      location string.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
GetSubnetLocationString(
    IN      LPCTSTR pszSubnetName,
    IN OUT  TString &strSubnetLocation
    )
{
    TString strSubnetPath;
    TString strConfig;
    TString strLDAPPrefix;
    TStatusB bStatus;
    TCHAR szSubnetName[MAX_PATH];

    //
    // Sites are located in the configuration container.
    //
    bStatus DBGCHK = m_Ds.GetConfigurationContainer( strConfig );

    if (bStatus)
    {
        //
        // Escape the / in the subnet name.
        //
        for ( LPTSTR p = szSubnetName; pszSubnetName && *pszSubnetName; )
        {
            if (*pszSubnetName == _T('/'))
            {
                *p++ = _T('\\');
            }

            *p++ = *pszSubnetName++;
        }

        *p = NULL;

        //
        // Build the site adsi object path.
        //
        bStatus DBGCHK = m_Ds.GetLDAPPrefix( strLDAPPrefix )             &&
                         strSubnetPath.bCat( strLDAPPrefix )             &&
                         strSubnetPath.bCat( gszCNEquals )               &&
                         strSubnetPath.bCat( szSubnetName )              &&
                         strSubnetPath.bCat( gszComma )                  &&
                         strSubnetPath.bCat( gszSubnetContainter)        &&
                         strSubnetPath.bCat( gszComma )                  &&
                         strSubnetPath.bCat( strConfig );

        DBGMSG( DBG_TRACE, ( "Subnet Path " TSTR ".\n", (LPCTSTR)strSubnetPath ) );

        if (bStatus)
        {
            //
            // Read the site location property.
            //
            bStatus DBGCHK = m_Ds.ReadStringProperty( strSubnetPath, gszSubnetLocationPropertyName, strSubnetLocation );
        }
    }

    return bStatus;
}

/*++

Name:

    GetSiteLocationString

Description:

    Reads the location string from the site object.  This routine
    converts the site name to an adsi path then reads the location
    property fron this site object.

Arguments:

    pszSiteName     - pointer string which contains the site name.
    strSiteLocation - reference to string object where to return the site
                      location string.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
GetSiteLocationString(
    IN      LPCTSTR pszSiteName,
    IN OUT  TString &strSiteLocation
    )
{
    TString strConfig;
    TString strSitePath;
    TString strLDAPPrefix;
    TStatusB bStatus;

    //
    // Sites are located in the configuration container.
    //
    bStatus DBGCHK = m_Ds.GetConfigurationContainer( strConfig );

    if (bStatus)
    {
        //
        // Build the site adsi object path.
        //
        bStatus DBGCHK = m_Ds.GetLDAPPrefix( strLDAPPrefix )           &&
                         strSitePath.bCat( strLDAPPrefix )             &&
                         strSitePath.bCat( gszCNEquals )               &&
                         strSitePath.bCat( pszSiteName )               &&
                         strSitePath.bCat( gszComma )                  &&
                         strSitePath.bCat( gszSitesContainter)         &&
                         strSitePath.bCat( gszComma )                  &&
                         strSitePath.bCat( strConfig );

        DBGMSG( DBG_TRACE, ( "Site Path " TSTR ".\n", (LPCTSTR)strSitePath ) );

        if (bStatus)
        {
            //
            // Read the site location property.
            //
            bStatus DBGCHK = m_Ds.ReadStringProperty( strSitePath, gszSiteLocationPropertyName, strSiteLocation );
        }
    }

    return bStatus;
}

/*++

Name:

    TPhysicalLocation::vTrimSlash

Description:

    Removes trailing slashes from the given string

Arguments:

    strLocation - string to shorten

Return Value:

    None

Notes:

--*/
VOID
TPhysicalLocation::
vTrimSlash (
    IN OUT TString &strLocation
    )
{
    UINT    uLen;
    LPTSTR  szTrimSlash;

    uLen = strLocation.uLen();

    while (uLen && *(static_cast<LPCTSTR>(strLocation)+uLen-1) == gchSeparator)
    {
       uLen--;
    };

    if (uLen)
    {
        szTrimSlash = new TCHAR[uLen+1];

        if (szTrimSlash)
        {
            _tcsncpy (szTrimSlash, strLocation, uLen);

            *(szTrimSlash+uLen) = 0;

            strLocation.bUpdate (szTrimSlash);

            delete [] szTrimSlash;
        }
    }
    else
    {
        strLocation.bUpdate (gszNULL);
    }
}

/*++

Name:

    AddrToSite

Description:

    Converts a single ip address to a site name.

Arguments:

    dwAddr          - the IP address.
    strSiteName     - return the site name here.
    strSubnetName   - return the subnet name here.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

    DsAddressToSiteNamesEx only returns the nearest subnet when there are multiple
    sites defined in the DS.

--*/
BOOL
TPhysicalLocation::
AddrToSite(
    IN DWORD    dwAddr,
    IN TString  &strSiteName,
    IN TString  &strSubnetName
    )
{
    DWORD           dwStatus        = ERROR_SUCCESS;
    SOCKET_ADDRESS  SockAddr        = {0};
    SOCKADDR_IN     SockAddrIn      = {0};
    PWSTR           *ppSiteNames    = NULL;
    PWSTR           *ppSubnetNames  = NULL;
    TStatusB        bStatus;

    //
    // Create a socket from an IP address.
    //
    SockAddr.iSockaddrLength    = sizeof(SOCKADDR_IN);
    SockAddr.lpSockaddr         = (LPSOCKADDR)&SockAddrIn;

    SockAddrIn.sin_family       = AF_INET;
    SockAddrIn.sin_port         = 0;

    memcpy( &SockAddrIn.sin_addr, &dwAddr, sizeof(dwAddr) );

    //
    // If a no zero address was given then attempt to find a site
    // that this address belongs to.
    //
    if (dwAddr)
    {
        dwStatus = m_DsAddressToSiteNames( NULL, 1, &SockAddr, &ppSiteNames, &ppSubnetNames );

        if (dwStatus == ERROR_SUCCESS)
        {
            if (ppSiteNames)
            {
                DBGMSG( DBG_TRACE, ( "SiteName " TSTR "\n", DBGSTR( ppSiteNames[0] ) ) );

                bStatus DBGCHK = strSiteName.bUpdate( ppSiteNames[0] );

                m_NetApiBufferFree( ppSiteNames );
            }

            if (ppSubnetNames)
            {
                DBGMSG( DBG_TRACE, ( "SubnetName " TSTR "\n", DBGSTR( ppSubnetNames[0] ) ) );

                bStatus DBGCHK = strSubnetName.bUpdate( ppSubnetNames[0] );

                m_NetApiBufferFree( ppSubnetNames );
            }
        }
    }

    return dwStatus == ERROR_SUCCESS;
}


/*++

Name:

    GetIpAddressTable

Description:

    Returns an array of Ip address for this machine.  The caller
    must free the array using the delete operator.

Arguments:

    ppAddrTable - Pointer were to return a pointer to the array of
                  ip addresses.

Return Value:

    TRUE success, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
GetIpAddressTable(
    PMIB_IPADDRTABLE    *ppAddrTable
    )
{
    SPLASSERT( ppAddrTable );

    DWORD               dwTableSize = 0;
    PMIB_IPADDRTABLE    pAddrTable  = NULL;
    DWORD               dwStatus    = ERROR_SUCCESS;
    BOOL                bRet        = FALSE;

    dwStatus = m_GetIpAddrTable(NULL, &dwTableSize, FALSE);

    if (dwStatus == ERROR_INSUFFICIENT_BUFFER)
    {
        pAddrTable = (PMIB_IPADDRTABLE)new BYTE[dwTableSize];

        if (pAddrTable)
        {
            dwStatus = m_GetIpAddrTable(pAddrTable, &dwTableSize, FALSE);

            if (dwStatus == ERROR_SUCCESS)
            {
                *ppAddrTable = pAddrTable;
                bRet = TRUE;
            }
            else
            {
                delete [] pAddrTable;
            }
        }
        else
        {
            // new has failed
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return bRet;
}

/*++

Name:

    GetSubnetObjectNames

Description:

    Returns a list of subnet objects for this machine.  Since the machine
    may have multiple ip address the same goes for the subnets.

Arguments:

    Subnets - Refrence to subnet Class that will contain on return a
              list of subnet objects.

Return Value:

    TRUE subnet object returned, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
GetSubnetObjectNames(
    IN TSubnets &Subnets
    )
{
    TString     strConfig;
    TStatusB    bStatus;

    //
    // Get the path to the configuration container.
    //
    bStatus DBGCHK = m_Ds.GetConfigurationContainer( strConfig );

    if (bStatus)
    {
        TSubnets Subnets2;
        TString  strSubnetObject;

        //
        // Get the subnet names.
        //
        bStatus DBGCHK = GetSubnetNames( Subnets2 );

        //
        // Transform the subnet names into subnet object names.
        //
        for( UINT i = 0; i < Subnets2.NumEntries(); i++ )
        {
            bStatus DBGCHK = strSubnetObject.bUpdate( gszCNEquals )       &&
                             strSubnetObject.bCat( Subnets2.Table(i) )      &&
                             strSubnetObject.bCat( gszComma )             &&
                             strSubnetObject.bCat( gszSubnetContainter )  &&
                             strSubnetObject.bCat( gszComma )             &&
                             strSubnetObject.bCat( strConfig );
            if (bStatus)
            {
                DBGMSG( DBG_TRACE, ( "SubnetObject " TSTR ".\n", (LPCTSTR)strSubnetObject ) );

                //
                // Add the subnet object entry.
                //
                if (!(bStatus DBGCHK = Subnets.AddEntry( strSubnetObject )))
                {
                    break;
                }
            }
        }
    }

    return bStatus;
}


/*++

Name:

    GetSubnetNames

Description:

    Return a list of subnet strings for this machine, a machine may
    be on multiple subnet since they may have multiple ip addresses.

Arguments:

    TSubnet & - refrence to class of Subnets.

Return Value:

    TRUE subnets were returned, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
GetSubnetNames(
    IN TSubnets &Subnets
    )
{
    TStatusB            bStatus;
    PMIB_IPADDRTABLE    pAddrTable  = NULL;
    TString             strSubnet;

    Subnets.ClearAll();

    bStatus DBGCHK = GetIpAddressTable( &pAddrTable );

    if (bStatus && pAddrTable )
    {
        for (UINT i = 0; i < pAddrTable->dwNumEntries; i++)
        {
            //
            // Skip the loopback or unassigned interfaces
            //
            if((pAddrTable->table[i].dwAddr != 0) && (pAddrTable->table[i].dwAddr != c_LoopBackAddress.s_addr))
            {
                IN_ADDR IpSubnetAddr;

                IpSubnetAddr.s_addr = pAddrTable->table[i].dwAddr & pAddrTable->table[i].dwMask;

                LPSTR pszIpAddress = m_inet_ntoa( IpSubnetAddr );

                //
                // Format the subnet mask to match the way subnet objects are
                // in the DS.  XX.XX.XX.XX/SS  where SS are the number of significant
                // bit in the subnet mask.
                //
                bStatus DBGCHK = strSubnet.bFormat( _T("%S\\/%d"),
                                                    pszIpAddress ? pszIpAddress : "",
                                                    NumSetBits( pAddrTable->table[i].dwMask ) );

                if (bStatus)
                {
                    //
                    // Add the subnet entry to the list of subnets.
                    //
                    bStatus DBGCHK = Subnets.AddEntry( strSubnet );
                }
            }
        }
    }

    delete [] pAddrTable;

    return bStatus;
}

/*++

Name:

    WidenScope

Description:

    This routine expands the scope of the specified physical location string.
    The physical location string uses / as scope separators.  For example
    if the physical location string on a computer object is
    "/Redmond/Main Campus/Building 26 North/Floor 1/Office 1438"
    after calling this routine with a count of 1 the new physical location
    string will be "/Redmond/Main Campus/Building 26 North/Floor 1"
    Thus it has expanded the scope this computer object is in.

Arguments:

    pszString   - pointer to physical location string to widen
    uCount      - number of scopes to widen the scope by, must be 1 or greater
    strString   - refrence to string object where to return the new widened scope.

Return Value:

    TRUE the scope was widened, FALSE error occurred.

Notes:

--*/
BOOL
TPhysicalLocation::
WidenScope(
    IN      LPCTSTR pszString,
    IN      UINT    uCount,
    IN OUT  TString &strString
    ) const
{
    TStatusB    bStatus;
    bStatus     DBGNOCHK = FALSE;

    if (uCount && pszString && *pszString)
    {
        UINT uLen = _tcslen( pszString );

        LPTSTR pszTemp = new TCHAR [uLen+1];

        if (pszTemp)
        {
            _tcscpy( pszTemp, pszString );

            //
            // Search from the end of the string to the beginning
            // counting the number of separators, terminate when the
            // desired count is reached.
            //
            for( LPTSTR p = pszTemp + uLen - 1; p != pszTemp; p-- )
            {
                if (*p == gchSeparator)
                {
                    if (!--uCount)
                    {
                        *p = NULL;
                        bStatus DBGCHK = strString.bUpdate( pszTemp );
                        break;
                    }
                }
            }
        }

        delete [] pszTemp;
    }

    return bStatus;
}


/*++

Name:

    NumSetBits

Description:

    Determines the number of set bits in the specified value.

Arguments:

    DWORD Value - Value to count set bits.

Return Value:

    Number of set bits in the value.

Notes:

--*/
UINT
TPhysicalLocation::
NumSetBits(
    IN DWORD Value
    )
{
    UINT Count = 0;

    //
    // Start with the high order bit set and shift the bit
    // to the right.  This routine could be made very generic
    // if a pointer to the value and the size in bytes of the
    // value was accepted.
    //
    for( DWORD i = 1 << ( sizeof(Value) * 8 - 1 ); i; i >>= 1 )
    {
        Count += (Value & i) ? 1 : 0;
    }

    return Count;
}

/*++

Name:

    TSubnets

Description:

    Constructor.

Arguments:

    None.

Return Value:

    Nothing.

Notes:

--*/
TPhysicalLocation::TSubnets::
TSubnets(
    VOID
    ) : m_uNumEntries( 0 ),
        m_pstrTable( NULL )
{
}

/*++

Name:

    TSubnets

Description:

    Destructor.

Arguments:

    None.

Return Value:

    Nothing.

Notes:

--*/
TPhysicalLocation::TSubnets::
~TSubnets(
    VOID
    )
{
    delete [] m_pstrTable;
}

/*++

Name:

    ClearAll

Description:

    Release the all the subnet entries.

Arguments:

    None.

Return Value:

    Nothing.

Notes:

--*/
VOID
TPhysicalLocation::TSubnets::
ClearAll(
    VOID
    )
{
    m_uNumEntries = 0;
    delete [] m_pstrTable;
    m_pstrTable = NULL;
}

/*++

Name:

    NumEntries

Description:

    Return the total number of valid entries.

Arguments:

    None.

Return Value:

    Number of subnet entries.

Notes:

--*/
UINT
TPhysicalLocation::TSubnets::
NumEntries(
    VOID
    )
{
    return m_uNumEntries;
}

/*++

Name:

    Table

Description:

    Return the string using the speified index.

Arguments:

    Index - Zero based index of which string to return.

Return Value:

    Refrence to string.

Notes:

--*/
TString &
TPhysicalLocation::TSubnets::
Table(
    UINT Index
    )
{
    SPLASSERT( m_pstrTable || Index < m_uNumEntries);
    return m_pstrTable[Index];
}

/*++

Name:

    AddEntry

Description:

    Add a new subnet entry into the array of subnet strings.

Arguments:

    pszNew - pointer to new subnet string to add.

Return Value:

    TRUE new subnet string was added, FALSE error.

Notes:

--*/
BOOL
TPhysicalLocation::TSubnets::
AddEntry(
    IN LPCTSTR pszNew
    )
{
    TStatusB bStatus;

    //
    // Assume failure.
    //
    bStatus DBGNOCHK = FALSE;

    //
    // Allocate the new array of strings.  Yes this
    // is not the most efficent code but it works.
    // Maybe a string list would be a better
    // choice if I had one or the time to implement one.
    //
    TString *pTemp = new TString [m_uNumEntries+1];

    if (pTemp)
    {
        //
        // Assume success this is needed when the first
        // string is added.
        //
        bStatus DBGNOCHK = TRUE;

        //
        // Copy the strings to the new array of strings.
        //
        for( UINT i = 0; i < m_uNumEntries; i++ )
        {
            if (!(bStatus DBGCHK = pTemp[i].bUpdate( m_pstrTable[i] )))
            {
                break;
            }
        }

        //
        // Add the new string.
        //
        if (bStatus)
        {
            bStatus DBGCHK = pTemp[i].bUpdate( pszNew );

            if( bStatus )
            {
                delete [] m_pstrTable;
                m_pstrTable = pTemp;
                m_uNumEntries++;
            }
        }

        //
        // If something failed free the temp string array.
        //
        if( !bStatus )
        {
            delete [] pTemp;
        }
    }

    return bStatus;
}

/*++

Name:
    TPhysicalLocation::bLocationEnabled

Description:
    Checks policy bit to determine if physical location support is enabled


Arguments:
    None

Return Value:
    TRUE if enabled, FALSE otherwise

Notes:
    Support is disabled by default

--*/

BOOL
TPhysicalLocation::
bLocationEnabled(
    VOID
    )
{
    TStatusB bStatus;
    BOOL     bRet = FALSE;

    TPersist PersistPolicy( gszSpoolerPolicy, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

    if( VALID_OBJ( PersistPolicy ) )
    {
        bStatus DBGNOCHK = PersistPolicy.bRead( gszUsePhysicalLocation, bRet );
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\password.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998
All rights reserved

Module Name:

    password.c

Abstract:


Author:

Environment:

    User Mode -Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <lm.h>
#include "client.h"

#ifdef OLD_CODE

#define DLG_NETWORK_PASSWORD        500
#define IDD_ENTER_PASSWORD_TEXT     501
#define IDD_NETWORK_PASSWORD_SLE    502
#define IDD_NETWORK_PASSWORD_HELP   503

#define IDH_500_501 8912768 // Enter Network Password: "Enter password for %s:" (Static)
#define IDH_500_502 8912786 // Enter Network Password: "" (Edit)
#define ID_HELP_NETWORK_PASSWORD   IDH_500_501


DWORD RemoveFromReconnectList(LPTSTR pszRemotePath) ;
DWORD AddToReconnectList(LPTSTR pszRemotePath) ;

BOOL APIENTRY
NetworkPasswordDialog(
   HWND   hWnd,
   UINT   usMsg,
   WPARAM wParam,
   LONG   lParam
   );

DLG_NETWORK_PASSWORD DIALOG 65, 17, 247, 61
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION "Enter Network Password"
FONT 8, "MS Shell Dlg"
BEGIN
    LTEXT           "Enter password for %s:", IDD_ENTER_PASSWORD_TEXT, 10,
                    18, 170, 8
    LTEXT           "&Password:", -1, 10, 36, 37, 8
    EDITTEXT        IDD_NETWORK_PASSWORD_SLE, 50, 34, 132, 12, ES_PASSWORD |
                    ES_AUTOHSCROLL
    PUSHBUTTON      "OK", IDOK, 201, 6, 40, 14
    PUSHBUTTON      "Cancel", IDCANCEL, 201, 23, 40, 14
    PUSHBUTTON      "&Help", IDD_NETWORK_PASSWORD_HELP, 201, 40, 40, 14
END

#endif


HMODULE hmoduleMpr = NULL;
FARPROC pfnWNetAddConnection2 = NULL;
FARPROC pfnWNetCancelConnection2 = NULL;
FARPROC pfnWNetOpenEnum = NULL;
FARPROC pfnWNetEnumResource = NULL;
FARPROC pfnWNetCloseEnum = NULL;

BOOL NetworkPasswordInitDialog( HWND hWnd, LPTSTR pServerShareName );
BOOL NetworkPasswordOK( HWND hWnd );
BOOL NetworkPasswordCancel( HWND hWnd );
BOOL NetworkPasswordHelp( HWND hWnd );

#ifdef UNICODE
#define WNETADDCONNECTION2_NAME "WNetAddConnection2W"
#define WNETOPENENUM_NAME       "WNetOpenEnumW"
#define WNETENUMRESOURCE_NAME   "WNetEnumResourceW"
#define WNETCLOSEENUM_NAME      "WNetCloseEnum"
#else
#define WNETADDCONNECTION2_NAME "WNetAddConnection2A"
#define WNETOPENENUM_NAME       "WNetOpenEnumA"
#define WNETENUMRESOURCE_NAME   "WNetEnumResourceA"
#define WNETCLOSEENUM_NAME      "WNetCloseEnum"
#endif

BOOL APIENTRY
NetworkPasswordDialog(
   HWND   hWnd,
   UINT   usMsg,
   WPARAM wParam,
   LONG   lParam
   )
{
    switch (usMsg)
    {
    case WM_INITDIALOG:
        return NetworkPasswordInitDialog( hWnd, (LPTSTR)lParam );

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            return NetworkPasswordOK(hWnd);

        case IDCANCEL:
            return NetworkPasswordCancel(hWnd);

        case IDD_NETWORK_PASSWORD_HELP:
            NetworkPasswordHelp( hWnd );
            break;
        }

        break;
    }

    if( usMsg == WM_Help )
        NetworkPasswordHelp( hWnd );

    return FALSE;
}


/*
 *
 */
BOOL NetworkPasswordInitDialog(
    HWND   hWnd,
    LPTSTR pServerShareName
)
{
    TCHAR PasswordText[MAX_PATH];
    TCHAR ResourceText[64];

    /* Get the resource text, which includes a replaceable parameter:
     */
    GetDlgItemText( hWnd, IDD_ENTER_PASSWORD_TEXT,
                    ResourceText, COUNTOF(ResourceText) );

    wsprintf( PasswordText, ResourceText, pServerShareName );

    SetDlgItemText( hWnd, IDD_ENTER_PASSWORD_TEXT, PasswordText );

    SetWindowLongPtr( hWnd, GWLP_USERDATA, (INT_PTR)pServerShareName );

    return TRUE;
}


/*
 *
 */
BOOL NetworkPasswordOK(
    HWND hWnd
)
{
    TCHAR       Password[MAX_PATH];
    LPTSTR      pServerShareName = NULL;
    NET_API_STATUS Status;
    HANDLE      hPrinter = NULL;
    NETRESOURCE NetResource;

    ZERO_OUT( &NetResource );

    if( GetDlgItemText( hWnd, IDD_NETWORK_PASSWORD_SLE,
                        Password, COUNTOF(Password) ) )
    {

        pServerShareName = (LPTSTR)GetWindowLongPtr( hWnd, GWLP_USERDATA );

        NetResource.lpRemoteName = pServerShareName;
        NetResource.lpLocalName  = NULL;
        NetResource.lpProvider   = NULL;
        NetResource.dwType       = RESOURCETYPE_PRINT;

        if( !hmoduleMpr )
        {
            if( hmoduleMpr = LoadLibrary( TEXT("mpr.dll") ) )
            {
                if( !( pfnWNetAddConnection2 =
                           GetProcAddress( hmoduleMpr,
                                           WNETADDCONNECTION2_NAME ) ) ||
                    !( pfnWNetOpenEnum =
                           GetProcAddress( hmoduleMpr,
                                           WNETOPENENUM_NAME) ) ||
                    !( pfnWNetEnumResource =
                           GetProcAddress( hmoduleMpr,
                                           WNETENUMRESOURCE_NAME) ) ||
                    !( pfnWNetCloseEnum =
                           GetProcAddress( hmoduleMpr,
                                           WNETCLOSEENUM_NAME) ) )
                {
                    pfnWNetAddConnection2 = NULL ;
                    pfnWNetOpenEnum = NULL ;
                    pfnWNetEnumResource = NULL ;
                    pfnWNetCloseEnum = NULL ;
                    FreeLibrary( hmoduleMpr );
                    hmoduleMpr = NULL;
                }
            }
        }

        if( pfnWNetAddConnection2 )
        {
            Status = (*pfnWNetAddConnection2)( &NetResource, Password, NULL,
                                               CONNECT_UPDATE_PROFILE );

            if (Status == NO_ERROR)
                (void) AddToReconnectList(NetResource.lpRemoteName) ;

        }
        else
        {
            Status = GetLastError( );
        }


        if( Status != NO_ERROR )
        {
            DBGMSG( DBG_WARNING, ( "WNetAddConnection2 %s failed: Error %d\n",
                    pServerShareName, GetLastError( ) ) );
        }


        if( ( Status != NO_ERROR )
          ||( !OpenPrinter( pServerShareName, &hPrinter, NULL ) ) )
        {
            ReportFailure( hWnd, IDS_MESSAGE_TITLE, IDS_COULDNOTCONNECTTOPRINTER );
            return TRUE;
        }
    }

    EndDialog( hWnd, (INT)hPrinter );

    return TRUE;
}


/*
 *
 */
BOOL NetworkPasswordCancel(
    HWND hWnd
)
{
    EndDialog( hWnd, 0 );

    return TRUE;
}


/*
 *
 */
BOOL NetworkPasswordHelp(
    HWND hWnd
)
{
    ShowHelp( hWnd, HELP_CONTEXT, ID_HELP_NETWORK_PASSWORD );

    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////

#define SZ_PRINTER_RECONNECTIONS TEXT("Printers\\RestoredConnections")

/*
 * forward declare local functions
 */
DWORD OpenReconnectKey(PHKEY phKey) ;
DWORD AddToReconnectListEx(LPTSTR pszRemotePath,
                           LPTSTR pszProviderName,
                           LPTSTR pszUserContext) ;
DWORD CreateMultiSzValue(PBYTE   *ppszzMultiSzValue,
                         LPDWORD  pcbMultiSzValue,
                         LPTSTR   psz1,
                         LPTSTR   psz2) ;
DWORD GetProviderName(LPTSTR pszRemoteName,
                      LPTSTR *ppszProvider) ;


/*
 * Function:    AddToReconnectList
 * Description: adds the net path to list of print connections to
 *              restore (saved in registry). calls AddToReconnectListEx
 *              to do the real work.
 * Parameters:  pszRemotePath - the path to save.
 * Returns:     0 if success, Win32 error otherwise
 */
DWORD AddToReconnectList(LPTSTR pszRemotePath)
{
    LPTSTR pszProvider ;
    DWORD err ;

    //
    // get the provider name corresponding to this remote path.
    //
    if ((err = GetProviderName(pszRemotePath, &pszProvider)) == ERROR_SUCCESS)
    {
        err = AddToReconnectListEx(pszRemotePath,
                                   pszProvider,
                                   NULL) ;     // printman doesnt do connect as

        LocalFree(pszProvider) ;
    }
    return err ;
}

/*
 * Function:    AddToReconnectListEx
 * Description: adds the netpath, providername, usercontext to list
 *              of print connections to restore (saved in registry).
 * Parameters:  pszRemotePath   - the path to save (cannot be NULL)
 *              pszProviderName - network provider to use (cannot be NULL)
 *              pszUserContext  - what user context (can be NULL)
 * Returns:     0 if success, Win32 error otherwise
 */
DWORD AddToReconnectListEx(LPTSTR pszRemotePath,
                           LPTSTR pszProviderName,
                           LPTSTR pszUserContext)
{
    BYTE *pszzMultiSzValue = NULL ;
    UINT  cbMultiSzValue = 0 ;
    HKEY  hKey ;
    DWORD err ;

    //
    // check parameters
    //
    if (!pszRemotePath || !*pszRemotePath)
        return ERROR_INVALID_PARAMETER ;

    if (!pszProviderName || !*pszProviderName)
        return ERROR_INVALID_PARAMETER ;

    //
    // open registry and create the MULTI_SZ
    //
    if (err = OpenReconnectKey(&hKey))
        return (err) ;

    if (err = CreateMultiSzValue(&pszzMultiSzValue,
                                 &cbMultiSzValue,
                                 pszProviderName,
                                 pszUserContext))
    {
        RegCloseKey(hKey) ;
        return err ;
    }

    //
    // set it!
    //
    err = RegSetValueEx(hKey,
                        pszRemotePath,
                        0,
                        REG_MULTI_SZ,
                        pszzMultiSzValue,
                        cbMultiSzValue) ;

    LocalFree( (HLOCAL) pszzMultiSzValue ) ;
    RegCloseKey(hKey) ;
    return err ;
}

/*
 * Function:    RemoveFromReconnectList
 * Description: removes netpath from the list of print connections to
 *              restore (saved in registry).
 * Parameters:  pszRemotePath - the path to remove
 * Returns:     0 if success, Win32 error otherwise
 */
DWORD RemoveFromReconnectList(LPTSTR pszRemotePath)
{
    HKEY  hKey ;
    DWORD err ;

    if (err = OpenReconnectKey(&hKey))
        return (err) ;

    err = RegDeleteValue(hKey,
                         pszRemotePath) ;

    RegCloseKey(hKey) ;
    return err ;
}



/*
 * Function:    OpenReconectKey
 * Description: opens the portion of registry containing the
 *              print reconnect info.
 * Parameters:  phKey - address to return the opened key.
 * Returns:     0 if success, Win32 error otherwise
 */
DWORD OpenReconnectKey(PHKEY phKey)
{
    DWORD err ;

    if (!phKey)
        return ERROR_INVALID_PARAMETER ;

    err = RegCreateKey(HKEY_CURRENT_USER,
                       SZ_PRINTER_RECONNECTIONS,
                       phKey) ;

    if (err != ERROR_SUCCESS)
        *phKey = 0 ;

    return err ;
}

/*
 * Function:    CreateMultiSzValue
 * Description: creates a MULTI_SZ value from two strings.
 *              allocates memory with LocalAlloc for the multi_sz string.
 *              caller should free this.
 * Parameters:  ppszzMultiSzValue - used to return the multi_sz
 *              pcbMultiSzValue - used to return number of bytes used
 *              psz1 - first string (must be non empty string)
 *              psz2 - second string
 * Returns:     0 if success, Win32 error otherwise
 */
DWORD CreateMultiSzValue(PBYTE   *ppszzMultiSzValue,
                         LPDWORD  pcbMultiSzValue,
                         LPTSTR   psz1,
                         LPTSTR   psz2)
{
    DWORD cch1, cch2 ;
    LPTSTR pszTmp ;

    //
    // figure out the size needed
    //
    cch1 = psz1 ? _tcslen(psz1) : 0 ;
    if (cch1 == 0)
         return ERROR_INVALID_PARAMETER ;

    if (!psz2)
         psz2 = TEXT("") ;
    cch2  = _tcslen(psz2) ;

    //
    // allocate the string
    //
    *pcbMultiSzValue =  (cch1 + 1  +
                         cch2 + 1 +
                         1 ) * sizeof(TCHAR) ;
    if (!(pszTmp = (LPTSTR) LocalAlloc(LPTR, *pcbMultiSzValue)))
        return ERROR_NOT_ENOUGH_MEMORY ;

    //
    //
    //
    *ppszzMultiSzValue = (PBYTE)pszTmp ;
    _tcscpy(pszTmp, psz1) ;
    pszTmp += (cch1 + 1) ;
    _tcscpy(pszTmp, psz2) ;
    pszTmp += (cch2 + 1) ;
    *pszTmp = 0 ;

    return ERROR_SUCCESS ;
}

/*
 * Function:    GetProviderName
 * Description: from a connected remote path, find what provider has it.
 *              LocalAlloc is called to allocate the return data.
 *              caller should free this.
 * Parameters:  pszRemotePath - the remote path of interest.
 *              ppszProvider - used to return pointer to allocated string
 * Returns:     0 is success, Win32 error otherwise
 */
DWORD GetProviderName(LPTSTR pszRemoteName, LPTSTR *ppszProvider)
{
    DWORD err ;
    DWORD cEntries ;
    DWORD dwBufferSize ;
    BYTE *lpBuffer ;
    HANDLE hEnum = 0 ;

    if (!pszRemoteName)
        return ERROR_INVALID_PARAMETER ;

    if (!pfnWNetOpenEnum  || !pfnWNetEnumResource || !pfnWNetCloseEnum)
        return ERROR_PATH_NOT_FOUND ;

    //
    // init the return pointer to NULL and open up the enumeration
    //
    *ppszProvider = NULL ;

    err = (*pfnWNetOpenEnum)(RESOURCE_CONNECTED,
                             RESOURCETYPE_PRINT,
                             0,
                             NULL,
                             &hEnum) ;
    if (err != WN_SUCCESS)
        return err ;

    //
    // setup the return buufer and call the enum.
    // we always try for as many as we can.
    //
    cEntries = 0xFFFFFFFF ;
    dwBufferSize = 4096 ;
    lpBuffer  = LocalAlloc(LPTR,
                           dwBufferSize) ;
    if (!lpBuffer)
    {
        (void) (*pfnWNetCloseEnum)(hEnum) ;
        return (GetLastError()) ;
    }

    err = (*pfnWNetEnumResource)(hEnum,
               &cEntries,
               lpBuffer,
               &dwBufferSize ) ;
    do
    {
        switch(err)
        {
            case NO_ERROR:
            {
                DWORD i ;
                LPNETRESOURCE lpNetResource = (LPNETRESOURCE) lpBuffer ;
                LPTSTR pszProvider ;

                for (i = 0; i < cEntries ; i++, lpNetResource++)
                {
                    if (lstrcmpi(lpNetResource->lpRemoteName, pszRemoteName)==0)
                    {
                        //
                        // found one. the first will do.
                        //
                        if (!(lpNetResource->lpProvider))
                        {
                            //
                            // no provider string, pretend we didnt find it
                            //
                            (void) (*pfnWNetCloseEnum)(hEnum) ;
                            LocalFree( (HLOCAL) lpBuffer ) ;
                            return(ERROR_PATH_NOT_FOUND) ;
                        }
                        else
                        {
                            //
                            // have provider string
                            //
                            pszProvider = (LPTSTR) LocalAlloc( LPTR,
                                 (_tcslen(lpNetResource->lpProvider)+1) *
                                         sizeof(TCHAR)) ;
                            if (!pszProvider)
                            {
                                err = GetLastError() ;
                                (void) (*pfnWNetCloseEnum)(hEnum) ;
                                LocalFree( (HLOCAL) lpBuffer ) ;
                                return(err) ;
                            }
                        }

                        _tcscpy(pszProvider, lpNetResource->lpProvider) ;
                        (void) (*pfnWNetCloseEnum)(hEnum) ;
                        LocalFree( (HLOCAL) lpBuffer ) ;
                        *ppszProvider = pszProvider ;
                        return NO_ERROR ;
                    }
                }

            cEntries = 0xFFFFFFFF ;
                err = (*pfnWNetEnumResource)(hEnum,
                           &cEntries,
                           lpBuffer,
                           &dwBufferSize ) ;
                break ;
            }

            case WN_NO_MORE_ENTRIES:
                break ;

            default:
                break ;
        }

    } while (err == NO_ERROR) ;

    (void) (*pfnWNetCloseEnum)(hEnum) ;
    LocalFree( (HLOCAL) lpBuffer ) ;
    return ERROR_PATH_NOT_FOUND ;       // all other error map to this
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\portdlg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    portdlg.cxx

Abstract:

    Printer Port Add / Delete and Monitor Add / Delete dialogs

Author:

    Steve Kiraly (SteveKi)  11/06/95

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "drvsetup.hxx"
#include "portdlg.hxx"
#include "portslv.hxx"


/*++

Routine Name:

    TAddPort

Routine Description:

    Constructs the add port dialog.

Arguments:
    hWnd            -   parent window handle
    strServerName   -   Print server name, NULL if local machine
    bAdministrator  -   Administrator flag TRUE if we
--*/
TAddPort::
TAddPort(
    IN const HWND   hWnd,
    IN LPCTSTR      pszServerName,
    IN const BOOL   bAdministrator
    ) : _hWnd( hWnd ),
        _bAdministrator( bAdministrator ),
        _bValid( FALSE ),
        _hPSetupMonitorInfo( NULL ),
        _pPSetup( NULL ),
        _pszServerName( pszServerName ),
        _bPortAdded( FALSE )
{
    DBGMSG( DBG_TRACE, ( "TAddPort::ctor\n") );

    //
    // Load the setup library.
    //
    _pPSetup = new TPSetup;
    if( !VALID_PTR( _pPSetup ) ) {
        DBGMSG( DBG_WARN, ( "_pPSetup failed instantiation with %d.\n", GetLastError() ) );
        return;
    }

    //
    // Create the setup monitor handle.
    //
    _hPSetupMonitorInfo = _pPSetup->PSetupCreateMonitorInfo( pszServerName, _hDlg);
    if( !_hPSetupMonitorInfo ){
        DBGMSG( DBG_WARN, ( "_pPSetup.PSetupCreateMonitorInfo failed with %d.\n", GetLastError() ) );
        return;
    }

    _bValid = TRUE;
}

/*++

Routine Name:

    TAddPort

Routine Description:

    Destructor releases add port resources.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TAddPort::
~TAddPort(
    )
{
    DBGMSG( DBG_TRACE, ( "TAddPort::dtor\n") );

    //
    // Release the monitor info handle.
    //
    if( _hPSetupMonitorInfo )
        _pPSetup->PSetupDestroyMonitorInfo( _hPSetupMonitorInfo );

    //
    // Unload the setup library.
    //
    if( _pPSetup )
        delete _pPSetup;
}

/*++

Routine Name:

    bValid

Routine Description:

    Returns object validity

Arguments:

    None.

Return Value:

    Current object state.

--*/
BOOL
TAddPort::
bValid(
    VOID
    )
{
    return _bValid;
}

/*++

Routine Name:

    bDoModal

Routine Description:

    Eexcutes the modal dialog.

Arguments:

    None.

Return Value:

    TRUE port was added successfully
    FALSE port was not added.

--*/
BOOL
TAddPort::
bDoModal(
    VOID
    )
{
    //
    // Create a modal dialog.
    //
    return (BOOL)DialogBoxParam( ghInst,
                          MAKEINTRESOURCE( kResourceId ),
                          _hWnd,
                          MGenericDialog::SetupDlgProc,
                          (LPARAM)this );
}


/*++

Routine Name:

    bSetUI

Routine Description:

    Sets the data on the UI.

Arguments:

    None.

Return Value:

    TRUE data placed on UI.
    FALSE error occurred.

--*/
BOOL
TAddPort::
bSetUI(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAddPort::bSetUI\n") );

    //
    // Create local copies of the control ID's this saves
    // some execution time and alot of typing.
    //
    _hctlMonitorList = GetDlgItem( _hDlg, IDC_ADD_PORT_MONITOR_LIST );
    _hctlBrowse      = GetDlgItem( _hDlg, IDC_ADD_PORT_BROWSE );
    _bPortAdded      = FALSE;

    SPLASSERT( _hctlMonitorList );
    SPLASSERT( _hctlBrowse );

    //
    // Reset the monitor list box contents.
    //
    ListBox_ResetContent( _hctlMonitorList );

    //
    // Fill the list box with the list of installed monitors.
    //
    BOOL bStatus;
    TCHAR pszName[kStrMax];
    DWORD dwSize = COUNTOF( pszName );

    for( UINT i = 0 ; ; i++ ){

        bStatus = _pPSetup->PSetupEnumMonitor( _hPSetupMonitorInfo,
                                                i,
                                                pszName,
                                                &dwSize );
        if( bStatus ) {

            DBGMSG( DBG_TRACE, ( "Adding Monitor " TSTR " \n", pszName ) );

            //
            // Hide the fax monitor, users are not allowed to
            // add fax ports.
            //
            if( _tcsicmp( pszName, FAX_MONITOR_NAME ) )
            {
                ListBox_AddString( _hctlMonitorList, pszName );
            }

            dwSize = COUNTOF( pszName );

        } else {

            break;

        }
    }

    //
    // If we are an administrator selection the first monitor in the list.
    //
    if( _bAdministrator ){
        ListBox_SetCurSel( _hctlMonitorList, 0 );
    }

    //
    // Disable the controls if not an administrator.
    //
    vEnableCtl( _hDlg, IDC_ADD_PORT_MONITOR_LIST,   _bAdministrator );
    vEnableCtl( _hDlg, IDC_ADD_PORT_BROWSE,         _bAdministrator );
    vEnableCtl( _hDlg, IDC_ADD_PORT_TEXT,           _bAdministrator );
    vEnableCtl( _hDlg, IDC_ADD_PORT,                _bAdministrator );

    //
    // We cannot add new port monitors remotly, this is a monitor setup
    // and spooler limitation.
    //
    if( _pszServerName ){
        vEnableCtl( _hDlg, IDC_ADD_PORT_BROWSE,     FALSE );
    }

    return TRUE;
}

/*++

Routine Name:

    bReadUI

Routine Description:

    Reads the data from the UI.

Arguments:

    None.

Return Value:

    TRUE UI data read successfully.
    FALSE failure reading UI data.

--*/
BOOL
TAddPort::
bReadUI(
    VOID
    )
{
    TCHAR pszName[kStrMax];
    BOOL bStatus = TRUE;

    DBGMSG( DBG_TRACE, ( "TAddPort::bReadUI\n") );

    //
    // Ge the currently selected item.
    //
    UINT uSel = ListBox_GetCurSel( _hctlMonitorList );

    //
    // Get the name of the currently selected item.
    //
    if( ListBox_GetText( _hctlMonitorList, uSel, pszName ) == LB_ERR ){

        DBGMSG( DBG_WARN, ( "Monitor find string failed.\n" ) );

        vShowUnexpectedError( _hDlg, IDS_ERR_MONITOR_TITLE );

        bStatus = FALSE;

    } else {

        //
        // Save the selected monitor name.
        //
        bStatus = _strMonitorName.bUpdate( pszName );

    }

    return bStatus;

}

/*++

Routine Name:

    bSaveUI

Routine Description:

    Saves the UI data, this routien will do an AddPort call
    with the montior selected in the list box.

Arguments:

    None.

Return Value:

    Return value of the AddPort api call.

--*/
BOOL
TAddPort::
bSaveUI(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAddPort::bSavetUI\n") );
    DBGMSG( DBG_TRACE, ( "Adding port to Monitor " TSTR "\n", (LPCTSTR)_strMonitorName ) );

    TStatusB bStatus;

    //
    // Add the port using the selected montior.
    //
    bStatus DBGCHK = AddPort(
                        (LPTSTR)_pszServerName,
                        _hDlg,
                        (LPTSTR)(LPCTSTR)_strMonitorName );
    if( !bStatus ){

        //
        // If not a cancel request then display error message.
        //
        if( GetLastError() != ERROR_CANCELLED ){

            DBGMSG( DBG_WARN, ( "Error adding port with %d.\n", GetLastError() ) );

            extern MSG_ERRMAP gaMsgErrMapPorts[];

            iMessage( _hDlg,
                      IDS_ERR_MONITOR_TITLE,
                      IDS_ERR_ADD_PORT,
                      MB_OK|MB_ICONSTOP,
                      kMsgGetLastError,
                      gaMsgErrMapPorts );

            return FALSE;
        }

    } else {

        //
        // Indicate at least one port has been added.  This
        // flag will be used to indicate to the caller if the ports
        // list needs to be refreshed.
        //
        _bPortAdded = TRUE;

        //
        // A port has changed modify the cancel button to close.
        //
        TString strClose;
        if( strClose.bLoadString( ghInst, IDS_TEXT_CLOSE ) ){
            SetWindowText( GetDlgItem( _hDlg, IDCANCEL ), strClose );
        }

        //
        // The followng code modfies the default button
        // style because on return from adding a port
        // the Ok has the default button style.
        // i.e. has a bold border.
        //
        // Make the OK button a normal button state.
        //
        SendMessage( GetDlgItem( _hDlg, IDC_ADD_PORT ),
                    BM_SETSTYLE,
                    MAKEWPARAM( BS_PUSHBUTTON, 0 ),
                    MAKELPARAM( TRUE, 0 ) );

        //
        // Set the focus to the cancel button.
        //
        SetFocus( GetDlgItem( _hDlg, IDCANCEL ) );

        //
        // Change the cancel button to the default button.
        //
        SendMessage( GetDlgItem( _hDlg, IDCANCEL ),
                    BM_SETSTYLE,
                    MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                    MAKELPARAM( TRUE, 0 ) );

    }

    return TRUE;
}

/*++

Routine Name:

    bAddNewMonitor

Routine Description:

    Handles destroying the current monitor list and
    calling setup to get a new monitor potentialy form
    another dirve or network resources.

Arguments:

    None.

Return Value:

    TRUE if new monitor updated and UI reflects this.
    FALSE error occured UI remains unchanged.

--*/
BOOL
TAddPort::
bAddNewMonitor(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TAddPort::bAddNewMonitor\n") );

    //
    // Get a new monitor form a location or disk.
    //
    if( !_pPSetup->PSetupInstallMonitor(_hDlg ) ) {

        //
        // If the user canceled the request.
        //
        if( GetLastError() == ERROR_CANCELLED ){
            DBGMSG( DBG_TRACE, ( "Monitor install cancel request.\n" ) );
            return TRUE;
        }

        //
        // Some other error occured.
        //
        return FALSE;
    }

    //
    // Release the old monitor info
    //
    if( _hPSetupMonitorInfo )
        _pPSetup->PSetupDestroyMonitorInfo( _hPSetupMonitorInfo );

    //
    // Update current monitor info.
    //
    _hPSetupMonitorInfo = _pPSetup->PSetupCreateMonitorInfo( _pszServerName, _hDlg );

    if (!_hPSetupMonitorInfo)
    {
        DBGMSG( DBG_WARN, ( "PSetupCreateMonitorInfo failed with %d.\n", GetLastError() ) );
    }

    //
    // Refresh the UI with the new montiors.
    //
    bSetUI();

    //
    // The followng code modfies the default button
    // style because on return from the user
    // hitting the browse button it has become the default
    // button. i.e. has a bold border.
    // Make the new button a normal button state.
    //
    SendMessage( GetDlgItem( _hDlg, IDC_ADD_PORT_BROWSE ),
                BM_SETSTYLE,
                MAKEWPARAM( BS_PUSHBUTTON, 0 ),
                MAKELPARAM( TRUE, 0 ) );

    //
    // Change the focus to the ok button.
    //
    SetFocus( GetDlgItem( _hDlg, IDC_ADD_PORT ) );

    //
    // Change the ok button to the default button.
    //
    SendMessage( GetDlgItem( _hDlg, IDC_ADD_PORT ),
                BM_SETSTYLE,
                MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                MAKELPARAM( TRUE, 0 ) );

    return TRUE;
}

/*++

Routine Name:

    bHandleMesage

Routine Description:

    Dialog message handler.

Arguments:

    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam

Return Value:

    TRUE message was handled.
    FALSE message was not handled.

--*/
BOOL
TAddPort::
bHandleMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{

    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_INITDIALOG:
        bStatus = bSetUI ();
        bStatus = TRUE;
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        bStatus = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam )){

        //
        // Cancel add port
        //
        case IDCANCEL:
            EndDialog( _hDlg, _bPortAdded );
            bStatus = TRUE;
            break;

        //
        // OK will add a port.
        //
        case IDC_ADD_PORT:
            bReadUI();
            bSaveUI();
            bStatus = TRUE;
            break;

        //
        // Browse for new monitor.
        //
        case IDC_ADD_PORT_BROWSE:
            bStatus = bAddNewMonitor();
            bStatus = TRUE;
            break;

        //
        // Handle a list box event.
        //
        case IDC_ADD_PORT_MONITOR_LIST:
            switch ( GET_WM_COMMAND_CMD( wParam, lParam ) ){

            //
            // This forces an OK event.
            //
            case LBN_DBLCLK:
                PostMessage( _hDlg, WM_COMMAND, MAKEWPARAM( IDC_ADD_PORT, 0 ), lParam );
                bStatus = TRUE;
                break;

            }
            break;

        default:
            bStatus = FALSE;
            break;
        }

    default:
        bStatus = FALSE;
        break;

    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\portslv.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
All rights reserved.

Module Name:

    portslv.hxx

Abstract:

    Ports List View header

Author:

    Albert Ting (AlbertT)  17-Aug-1995
    Steve Kiraly (SteveKi) 29-Mar-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "portslv.hxx"

#if DBG
//#define DBG_PORTSINFO                  DBG_INFO
#define DBG_PORTSINFO                    DBG_NONE
#endif

MSG_ERRMAP gaMsgErrMapPorts[] = {
    ERROR_NOT_SUPPORTED, IDS_ERR_PORT_NOT_IMPLEMENTED,
    ERROR_ALREADY_EXISTS, IDS_ERR_PORT_ALREADY_EXISTS,
    0, 0
};

/********************************************************************

    Ports List view class.

********************************************************************/

TPortsLV::
TPortsLV(
    VOID
    ) : _bSelectionState( TRUE ),
        _bSingleSelection( TRUE ),
        _bTwoColumnMode( FALSE ),
        _iSelectedItem( -1 ),
        _ColumnSortState( kPortHeaderMax ),
        _uCurrentColumn( 0 ),
        _bAllowSelectionChange( FALSE ),
        _bHideFaxPorts( FALSE )
{
    vCreatePortDataList();
}

TPortsLV::
~TPortsLV(
    VOID
    )
{
    vDestroyPortDataList();
}

BOOL
TPortsLV::
bReloadPorts(
    IN LPCTSTR pszServerName,
    IN BOOL bSelectNewPort
    )
/*++

Routine Description:

    Read in the remote ports and put them in the listview.  If level
    2 fails, we will try 1.

Arguments:

    pszServerName - Pointer to server name.
    bSelectNewPort - Indicates if a new port is to be located and selected.
                     TRUE select new port, FALSE do not located new port.

Return Value:

    TRUE if ports list loaded, FALSE if error occurred.

--*/

{
    TStatusB bStatus( DBG_WARN, ERROR_INSUFFICIENT_BUFFER, ERROR_INVALID_LEVEL );

    DWORD           cbPorts = 0; 
    PPORT_INFO_2    pPorts  = NULL;
    DWORD           cPorts  = 0;
    DWORD           dwLevel = 2;

    //
    // Preserve the current check state.
    //
    TCHAR szPortList[kPortListMax];
    vGetPortList( szPortList, COUNTOF( szPortList ) );

    //
    // Enumerate the port starting at level 2.
    //
    bStatus DBGCHK = VDataRefresh::bEnumPortsMaxLevel( pszServerName, 
                                                       &dwLevel, 
                                                       (PVOID *)&pPorts, 
                                                       &cbPorts, 
                                                       &cPorts );

    //
    // If the ports list cannot be enumerated fail with an error.
    //
    if( !bStatus ){
        DBGMSG( DBG_WARN, ( "PortsLV.bReloadPorts: can't alloc %d %d\n", cbPorts, GetLastError( )));
        return FALSE;
    }

    //
    // If option to select newly added port was selected.
    //
    TString strNewPort;
    if( bSelectNewPort ){

        //
        // Located the newly added port.
        //
        bSelectNewPort = bLocateAddedPort( strNewPort, pPorts, cPorts, dwLevel );
        if( bSelectNewPort ){
            DBGMSG( DBG_TRACE, ("New port found " TSTR "\n", (LPCTSTR)strNewPort ) );
        }
    }

    //
    // Get the printers
    //
    PRINTER_INFO_2 *pPrinterInfo2   = NULL;
    DWORD           cPrinterInfo2   = 0;
    DWORD           cbPrinterInfo2  = 0;
    DWORD           dwFlags         = PRINTER_ENUM_NAME;
    
    bStatus DBGCHK = VDataRefresh::bEnumPrinters( 
                                                  dwFlags,
                                                  (LPTSTR)pszServerName,
                                                  2,
                                                  (PVOID *)&pPrinterInfo2,
                                                  &cbPrinterInfo2,
                                                  &cPrinterInfo2 );

    //
    // Delete current ports if they exist.
    //
    bStatus DBGCHK = ListView_DeleteAllItems( _hwndLV );

    //
    // Clear the item count.
    //
    _cLVPorts = 0;

    //
    // Delete all the port data items.
    //
    vDestroyPortDataList();

    TString strDescription;

    //
    // Add LPT?: ports
    //
    strDescription.bLoadString( ghInst, IDS_TEXT_PRINTERPORT );
    vInsertPortsByMask(
        cPorts, 
        pPorts, 
        cPrinterInfo2, 
        pPrinterInfo2,
        dwLevel,
        TEXT("lpt?:"),
        strDescription
        );

    //
    // Add COM?: ports
    //
    strDescription.bLoadString( ghInst, IDS_TEXT_SERIALPORT );
    vInsertPortsByMask(
        cPorts, 
        pPorts, 
        cPrinterInfo2, 
        pPrinterInfo2,
        dwLevel,
        TEXT("com?:"),
        strDescription
        );

    //
    // Add FILE: ports
    //
    strDescription.bLoadString( ghInst, IDS_TEXT_PRINTTOFILE );
    vInsertPortsByMask(
        cPorts, 
        pPorts, 
        cPrinterInfo2, 
        pPrinterInfo2,
        dwLevel,
        TEXT("file:"),
        strDescription
        );

    //
    // Add all the rest
    //
    vInsertPortsByMask(
        cPorts, 
        pPorts, 
        cPrinterInfo2, 
        pPrinterInfo2,
        dwLevel,
        NULL,
        NULL
        );

    //
    // Restore the previous check state.
    //
    vCheckPorts( szPortList );

    //
    // Select and check the newly added port.
    //
    if( bSelectNewPort ){

        //
        // Check off other selected ports
        //
        INT iItem = -1;

        do
        {
            iItem = ListView_GetNextItem( _hwndLV, iItem, LVNI_SELECTED );

            if( iItem != -1 )
            {
                ListView_SetItemState( _hwndLV, 
                                       iItem,
                                       0, 
                                       LVIS_SELECTED | LVIS_FOCUSED );
            }
        } while( iItem != -1 );

        //
        // New port is added select and scroll it into view.
        //
        vItemClicked( iSelectPort( strNewPort ) );
    }

    //
    // This arrays of numbers represents the percentages of
    // each column width from the total LV width. The sum 
    // of all numbers in the array should be equal to 100 
    // (100% = the total LV width)
    //
    static UINT arrColW2[] = { 50, 50 };
    static UINT arrColW3[] = { 18, 35, 47 };

    //
    // Adjust columns ...
    //
    if( !_bTwoColumnMode )
    {
        vAdjustHeaderColumns( _hwndLV, COUNTOF(arrColW3), arrColW3 );
    }
    else
    {
        vAdjustHeaderColumns( _hwndLV, COUNTOF(arrColW2), arrColW2 );
    }

    //
    // Release the enum ports and enum printer memory.
    //
    FreeMem( pPorts );
    FreeMem( pPrinterInfo2 );

    return TRUE;
}


BOOL
TPortsLV::
bLocateAddedPort( 
    IN LPCTSTR pszServerName,
    IN TString &strNewPort
    )
/*++

Routine Description:

    Located the first port which is not in the port list view.

Arguments:

    strPort - New port which has been added.

Return Value:

    TRUE success, FALSE error occurred.

--*/
{
    TStatusB        bStatus;
    DWORD           cbPorts = 0; 
    PPORT_INFO_2    pPorts  = NULL;
    DWORD           cPorts  = 0;
    DWORD           dwLevel = 2;

    //
    // Enumerate the port starting at level 2.
    //
    bStatus DBGCHK = VDataRefresh::bEnumPortsMaxLevel( pszServerName, 
                                                       &dwLevel, 
                                                       (PVOID *)&pPorts, 
                                                       &cbPorts, 
                                                       &cPorts );

    //
    // If the ports list cannot be enumerated fail with an error.
    //
    if( bStatus )
    {
        //
        // Located the newly added port.
        //
        bStatus DBGCHK = bLocateAddedPort( strNewPort, pPorts, cPorts, dwLevel );

        if( bStatus )
        {
            DBGMSG( DBG_TRACE, ("New port found " TSTR "\n", (LPCTSTR)strNewPort ) );
        }
    }

    //
    // Release the port memory.
    //
    FreeMem( pPorts );

    return bStatus;
}


BOOL
TPortsLV::
bLocateAddedPort(
    IN OUT  TString     &strPort,
    IN      PPORT_INFO_2 pPorts,
    IN      DWORD        cPorts,
    IN      DWORD        dwLevel
    )
/*++

Routine Description:

    Located the first port which is not in the port list view.

Arguments:

    strPort - New port which has been added.
    pPorts  - Points to a ports enum structure array.
    cPorts  - Number of elements in the ports enum array.
    dwLevel - Level of the ports enum structure array.

Return Value:

    TRUE success, FALSE error occurred.

--*/
{
    TStatusB bStatus;
    LPTSTR pszPort;

    bStatus DBGNOCHK = FALSE;

    //
    // Go through all the ports.
    //
    for( UINT i=0; i<cPorts; ++i ){

        if( dwLevel == 2 ){

            //
            // If we are to hide the fax ports then 
            // ignore newly added fax ports.
            //
            if( _bHideFaxPorts && bIsFaxPort( pPorts[i].pPortName, pPorts[i].pMonitorName ) )
            {
                DBGMSG( DBG_TRACE, ( "PortsLV.bLocateAddedPort: fax device being skipped.\n" ) );
                continue;
            }

            pszPort = pPorts[i].pPortName;

        } else {
            pszPort = ((PPORT_INFO_1)pPorts)[i].pName;
        }

        //
        // Look for a portname which is not in the list view.
        //
        if( iFindPort( pszPort ) < 0 ){

            //
            // Update the passed in string object.
            //
            bStatus DBGCHK = strPort.bUpdate( pszPort );
            break;
        }
    }
    return bStatus;
}

VOID
TPortsLV::
vSelectPort(
    IN LPCTSTR pszPort
    )
{
    SPLASSERT( pszPort );
    iSelectPort( pszPort );
}

VOID
TPortsLV::
vEnable(
    IN BOOL bRetainSelection
    )
{
    if( bRetainSelection )
    {
        if( _iSelectedItem != -1 )
        {
            ListView_SetItemState( _hwndLV, 
                                   _iSelectedItem,
                                   LVIS_SELECTED | LVIS_FOCUSED,
                                   LVIS_SELECTED | LVIS_FOCUSED );

            ListView_EnsureVisible( _hwndLV,
                                    _iSelectedItem,
                                    FALSE );
        }
    }
    EnableWindow( _hwndLV, TRUE );
}

VOID
TPortsLV::
vDisable(
    IN BOOL bRetainSelection
    )
{
    if( bRetainSelection )
    {
        _iSelectedItem = ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED );

        if( _iSelectedItem != -1 )
        {
            ListView_SetItemState( _hwndLV, 
                                   _iSelectedItem,
                                   0, 
                                   LVIS_SELECTED | LVIS_FOCUSED );
        }
    }
    EnableWindow( _hwndLV, FALSE );
}

VOID
TPortsLV::
vCheckPorts(
    IN OUT LPTSTR pszPortString CHANGE
    )

/*++

Routine Description:

    Set the ports in the listview based on the printers port string.

Arguments:

    pszPortName - List of ports, comma delimited.  When this is returns,
        pszPortName is the same on entry, but it's modified inside this
        function.

Return Value:

--*/

{
    //
    // We will walk though the port string, replacing commas with
    // NULLs, but we'll change them back.
    //
    LPTSTR psz = pszPortString;
    SPLASSERT( psz );

    LPTSTR pszPort;
    INT iItem;
    INT iItemFirst = kMaxInt;

    while( psz && *psz ){

        pszPort = psz;
        psz = _tcschr( psz, TEXT( ',' ));

        if( psz ){
            *psz = 0;
        }

        iItem = iCheckPort( pszPort );
        if( iItem == -1 ){
            DBGMSG( DBG_WARN,
                    ( "PortsLV.vCheckPort: Port "TSTR" not checked.\n", pszPort ));
        }

        if( iItem < iItemFirst ){
            iItemFirst = iItem;
        }

        if( psz ){
            *psz = TEXT( ',' );
            ++psz;
        }
    }

    if( iItemFirst == kMaxInt ){

        DBGMSG( DBG_PORTSINFO, ( "PortsLV.vCheckPorts: No ports selected.\n" ));
        iItemFirst = 0;
    }

    //
    // Select the first item and make sure it is visible.
    //
    ListView_SetItemState( _hwndLV,
                           iItemFirst,
                           LVIS_SELECTED | LVIS_FOCUSED,
                           LVIS_SELECTED | LVIS_FOCUSED );

    ListView_EnsureVisible( _hwndLV,
                            iItemFirst,
                            FALSE );

}

VOID
TPortsLV::
vSelectItem(
    INT iItem
    )

/*++

Routine Description:

    Selects an item in the ListView.

Arguments:

    iItem - Index of item to select.

Return Value:

--*/

{
    ListView_SetItemState( _hwndLV,
                           iItem,
                           LVIS_SELECTED,
                           LVIS_SELECTED );
}

BOOL
TPortsLV::
bSetUI(
    IN HWND     hwndLV,
    IN BOOL     bTwoColumnMode,
    IN BOOL     bSelectionState,
    IN BOOL     bAllowSelectionChange,
    IN HWND     hwnd,
    IN WPARAM   wmDoubleClickMsg,
    IN WPARAM   wmSingleClickMsg,
    IN WPARAM   wmDeleteKeyMsg
    )
{
    _hwndLV                 = hwndLV;
    _bTwoColumnMode         = bTwoColumnMode;
    _bSelectionState        = bSelectionState;
    _bAllowSelectionChange  = bAllowSelectionChange;
    _wmDoubleClickMsg       = wmDoubleClickMsg;
    _wmSingleClickMsg       = wmSingleClickMsg;                                 
    _wmDeleteKeyMsg         = wmDeleteKeyMsg;                                 
    _hwnd                   = hwnd;

    SPLASSERT( _hwndLV );

    if( _bSelectionState ){

        //
        // Add check boxes.
        //
        HIMAGELIST himlState = ImageList_Create( 16, 16, TRUE, 2, 0 );

        //
        // !! LATER !!
        // Should be created once then shared.
        //
        if( !himlState ){
            DBGMSG( DBG_ERROR, ( "PortsLV.bSetUI: ImageList_Create failed %d\n",
                    GetLastError( )));
            return FALSE;
        }

        //
        // Load the bitmap for the check states.
        //
        HBITMAP hbm =  LoadBitmap( ghInst, MAKEINTRESOURCE( IDB_CHECKSTATES ));

        if( !hbm ){
            DBGMSG( DBG_ERROR, ( "PortsLV.bSetUI: LoadBitmap failed %d\n",
                    GetLastError( )));
            return FALSE;
        }

        //
        // Add the bitmaps to the image list.
        //
        ImageList_AddMasked( himlState, hbm, RGB( 255, 0, 0 ));

        SendMessage( _hwndLV, LVM_SETIMAGELIST, LVSIL_STATE, (LPARAM)himlState );

        DeleteObject( hbm );

    }

    INT iNumColumns = _bTwoColumnMode ? 2 : kPortHeaderMax;

    //
    // Initialize the LV_COLUMN structure.
    //
    LV_COLUMN lvc;
    lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt     = LVCFMT_LEFT;
    lvc.cx      = kPortHeaderWidthDefault;

    RECT rc;
    if( !GetClientRect( _hwndLV, &rc )){

        DBGMSG( DBG_WARN, ( "PortsLV.bSetUI: GetClientRect failed %d\n", GetLastError( )));
        return FALSE;
    }

    //
    // Calculate the column width, less the scroll bar width.
    //
    lvc.cx = ( ( rc.right - rc.left ) - GetSystemMetrics( SM_CYVSCROLL ) ) / iNumColumns;

    TStatusB bStatus;
    TString strHeader;

    for( INT iCol = 0; iCol < iNumColumns; ++iCol ){

        bStatus DBGCHK = strHeader.bLoadString( ghInst, IDS_PHEAD_BEGIN + iCol );
        lvc.pszText = (LPTSTR)(LPCTSTR)strHeader;
        lvc.iSubItem = iCol;

        if( ListView_InsertColumn( _hwndLV, iCol, &lvc ) == -1 ){

            DBGMSG( DBG_WARN, ( "PortsLV.bSetUI: LV_Insert failed %d\n", GetLastError( )));

            return FALSE;
        }
    }

    //
    // Enable full row selection.
    //
    DWORD dwExStyle = ListView_GetExtendedListViewStyle( _hwndLV );
  	ListView_SetExtendedListViewStyle( _hwndLV, dwExStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP );

    //
    // !!LATER!!
    // We should read an override flag from the registry.
    //
    _bHideFaxPorts = TRUE;

    return TRUE;
}

VOID
TPortsLV::
vAddPortToListView(
    IN LPCTSTR pszName,
    IN LPCTSTR pszMonitor,
    IN LPCTSTR pszDescription,
    IN LPCTSTR pszPrinters
    )
{
    if( !pszName || !pszName[0] ){
        DBGMSG( DBG_WARN, 
                ( "PortsLV.vAddPortToListView: pszName "TSTR" invalid\n", 
                DBGSTR( pszName )));
        return;
    }

    //
    // If we are to hide the fax ports and this is a fax 
    // port then just return with out adding the port to 
    // the list view.
    //
    if( _bHideFaxPorts && bIsFaxPort( pszName, pszMonitor ) )
    {
        DBGMSG( DBG_TRACE, ( "PortsLV.vAddPortToListView: fax device being removed.\n" ) );
        return;
    }

    //
    // Add this port to the port data list.
    //
    TPortData *pPortData = AddPortDataList( pszName, pszMonitor, pszDescription, pszPrinters );

    LV_ITEM lvi;

    if( _bSelectionState ){
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
    } else {
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
    }

    lvi.state       = kStateUnchecked;
    lvi.pszText     = (LPTSTR)pszName;
    lvi.iItem       = _cLVPorts;
    lvi.iSubItem    = 0;
    lvi.lParam      = (LPARAM)pPortData;

    ListView_InsertItem( _hwndLV, &lvi );
    ListView_SetItemText( _hwndLV, _cLVPorts, 1, (LPTSTR)pszDescription );

    if( !_bTwoColumnMode )
    {
        ListView_SetItemText( _hwndLV, _cLVPorts, 2, (LPTSTR)pszPrinters );
    }

    ++_cLVPorts;
}


VOID
TPortsLV::
vDeletePortFromListView(
    IN LPCTSTR pszName
    )
{

    //
    // Locate the port in the list view.
    //
    INT iItem = iFindPort ( pszName );

    if( iItem != -1 ){

        //
        // Delete this port from the port data list.
        //
        DeletePortDataList( pszName );

        ListView_DeleteItem( _hwndLV, iItem );

        //
        // Select next item.  If the item we just deleted is the last item,
        // we need to select the previous one.
        //
        // If we deleted the last item, leave it as is.
        //
        if( ListView_GetItemCount( _hwndLV ) == iItem && 
            iItem > 0 ) {
            --iItem;
        }

        ListView_SetItemState( _hwndLV, 
                               iItem, 
                               LVIS_SELECTED | LVIS_FOCUSED,
                               LVIS_SELECTED | LVIS_FOCUSED );
    }
}

INT
TPortsLV::
iFindPort(
    IN LPCTSTR pszPort
    )
/*++

Routine Description:

    Located the specified port name in the list view.

Arguments:

    pszPort - Port name to locate.

Return Value:

    iItem id if found, -1 if item was not found.

--*/
{
    SPLASSERT( pszPort );

    LV_FINDINFO lvfi;

    lvfi.flags = LVFI_STRING;
    lvfi.psz = pszPort;

    INT iItem = ListView_FindItem( _hwndLV, -1, &lvfi );

    if( iItem == -1 ){
        DBGMSG( DBG_WARN, ( "PortsLV.iFindPort: port "TSTR" not found\n", pszPort ));
    }

    return iItem;
}


INT
TPortsLV::
iCheckPort(
    IN LPCTSTR pszPort
    )
/*++

Routine Description:

    Places the check mark next to a port in the list view.

Arguments:

    pszPort - Port to check.

Return Value:

    iItem checked, -1 == error.

--*/
{
    //
    // Locate the port in the list view.
    //
    INT iItem = iFindPort ( pszPort );

    if( iItem != -1 ){

        //
        // Set the item selection state.
        //
        ListView_SetItemState( _hwndLV,
                               iItem,
                               kStateChecked,
                               kStateMask );

        //
        // Try and make as many ports visible as possible.
        //
        ListView_EnsureVisible( _hwndLV,
                                iItem,
                                FALSE );
    }

    return iItem;
}

INT
TPortsLV::
iSelectPort(
    IN LPCTSTR pszPort
    )
/*++

Routine Description:

    Select the port in the list view.

Arguments:

    pszPort - Port to check.

Return Value:

    iItem checked, -1 == error.

--*/
{
    //
    // Locate the port in the list view.
    //
    INT iItem = iFindPort ( pszPort );

    if( iItem != -1 ){

        //
        // Select the port specified by pszPort.
        //
        ListView_SetItemState( _hwndLV,
                               iItem,
                               LVIS_SELECTED | LVIS_FOCUSED,
                               LVIS_SELECTED | LVIS_FOCUSED );
        //
        // Try and make as many ports visible as possible.
        //
        ListView_EnsureVisible( _hwndLV,
                                iItem,
                                FALSE );
    }

    return iItem;
}

VOID
TPortsLV::
vGetPortList(
        OUT LPTSTR pszPortList,
    IN      COUNT cchPortList
    )
{
    INT cPorts = 0;
    DWORD i;

    LV_ITEM lvi;

    LPTSTR pszPort = pszPortList;
    DWORD cchSpaceLeft = cchPortList - 1;
    DWORD cchLen;
    lvi.iSubItem = 0;

    DWORD cItems = ListView_GetItemCount( _hwndLV );

    for( pszPortList[0] = 0, i=0; i<cItems; ++i ){

        if( ListView_GetItemState( _hwndLV, i, kStateMask ) & kStateChecked ){

            lvi.pszText = pszPort;
            lvi.cchTextMax = cchSpaceLeft;

            cchLen = (DWORD)SendMessage( _hwndLV,
                                         LVM_GETITEMTEXT,
                                         (WPARAM)i,
                                         (LPARAM)&lvi );

            if( cchLen + 1 > cchSpaceLeft ){

                DBGMSG( DBG_WARN, ( "PortsLV.iGetPorts: Out of string space!\n" ));
                return;
            }

            pszPort += cchLen;
            cchSpaceLeft -= cchLen+1;

            *pszPort = TEXT( ',' );
            ++pszPort;
            ++cPorts;
        }
    }

    //
    // If we had any ports, back up to remove the last comma.
    //
    if( cPorts ){
        --pszPort;
    }

    //
    // Null terminate.
    //
    *pszPort = 0;

}

BOOL
TPortsLV::
bReadUI(
    OUT TString &strPortString,
    IN  BOOL    bSelectedPort
    )
{
    TCHAR szPortList[kPortListMax];
    szPortList[0] = 0;

    //
    // If we are in single select mode just return
    // the selected port.
    //
    if( bSelectedPort )
    {
        (VOID)bGetSelectedPort( szPortList, COUNTOF( szPortList ) );
    }
    else
    {
        //
        // Get the list of check ports from the list view.
        //
        vGetPortList( szPortList, COUNTOF( szPortList ) );
    }

    //
    // Update the port list.
    //
    return strPortString.bUpdate( szPortList );

}

VOID
TPortsLV::
vItemClicked(
    IN INT iItem
    )

/*++

Routine Description:

    User clicked in listview.  Check if item state should
    be changed.

    The item will also be selected.

Arguments:

    iItem - Item that has been clicked.

Return Value:

--*/

{
    if( iItem == -1 ){
        DBGMSG( DBG_WARN, ( "PortsLV.vItemClicked: -1 passed in\n" ));
        return;
    }

    //
    // If in single selection mode clear all items checked and only
    // check the specified item.
    //
    if( _bSingleSelection ){

        DWORD cItems = ListView_GetItemCount( _hwndLV );

        for( UINT i=0; i<cItems; ++i ){

            if( ListView_GetItemState( _hwndLV, i, kStateMask ) & kStateChecked ){

                if( iItem == (INT)i ){
                    continue;
                } else {

                    ListView_SetItemState( _hwndLV,
                                           i,
                                           kStateUnchecked,
                                           kStateMask );
                }
            }
        }
    }

    //
    // Retrieve the old state, toggle it, then set it.
    //
    DWORD dwState = ListView_GetItemState( _hwndLV,
                                           iItem,
                                           kStateMask );

    //
    // When we are in single select mode we want to always check 
    // the currently selected item.
    //
    if( !_bSingleSelection )
    {
        dwState = ( dwState == kStateChecked ) ?
                      kStateUnchecked | LVIS_SELECTED | LVIS_FOCUSED :
                      kStateChecked | LVIS_SELECTED | LVIS_FOCUSED;
    }
    else
    {
        dwState = kStateChecked | LVIS_SELECTED | LVIS_FOCUSED;
    }

    //
    // Set the new item state.
    //
    ListView_SetItemState( _hwndLV,
                           iItem,
                           dwState,
                           kStateMask | LVIS_SELECTED | LVIS_FOCUSED );

}

COUNT
TPortsLV::
cSelectedPorts(
    VOID
    )
/*++

Routine Description:

    Returns the number of items which have a check mark
    next to them.

Arguments:

    None.

Return Value:

    Return the number of checked items.

--*/
{
    DWORD cItems = ListView_GetItemCount( _hwndLV );
    COUNT cItemsSelected = 0;
    DWORD i;

    for( i = 0; i < cItems; ++i )
    {
        if( ListView_GetItemState( _hwndLV, i, kStateMask ) & kStateChecked )
        {
            ++cItemsSelected;
        }
    }

    return cItemsSelected;
}

COUNT
TPortsLV::
cSelectedItems(
    VOID
    )
/*++

Routine Description:

    Returns the number of items which are currently selected.

Arguments:

    None.

Return Value:

    Return the number of selected items.

--*/
{
    DWORD cItems = ListView_GetItemCount( _hwndLV );
    COUNT cItemsSelected = 0;
    DWORD i;

    for( i = 0; i < cItems; ++i )
    {
        if( ListView_GetItemState( _hwndLV, i, LVIS_SELECTED ) & LVIS_SELECTED )
        {
            ++cItemsSelected;
        }
    }

    return cItemsSelected;
}

VOID
TPortsLV::
vRemoveAllChecks(
    VOID
    )
/*++

Routine Description:

    Removes all the check marks for the list view.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    DWORD cItems = ListView_GetItemCount( _hwndLV );
    COUNT cItemsSelected = 0;
    DWORD i;

    for( i=0; i<cItems; ++i ){

        if( ListView_GetItemState( _hwndLV, i, kStateMask ) & kStateChecked ){

            ListView_SetItemState( _hwndLV,
                                   i,
                                   kStateUnchecked,
                                   kStateMask );
        }
    }
}

VOID
TPortsLV::
vSetFocus(
    VOID
    )
{
    SetFocus( _hwndLV );
}

BOOL
TPortsLV::
bGetSelectedPort(
    OUT LPTSTR pszPort,
    IN  COUNT cchPort
    )

/*++

Routine Description:

    Retrieve the currently selected port in the list view.

Arguments:

    pszPort - TCHAR array to receive port

    cchPort - COUNTOF port string.
    
Return Value:

    TRUE - success, FALSE = fail.

--*/

{
    INT iItem = ListView_GetNextItem( _hwndLV,
                                      -1,
                                      LVNI_SELECTED );
    if( iItem == -1 ){

        DBGMSG( DBG_WARN,
                ( "PrinterPort.bGetSelectedPort: Unable to retrieve next selected item %d\n",
                  GetLastError( )));
        return FALSE;
    }

    ListView_GetItemText( _hwndLV,
                          iItem,
                          0,
                          pszPort,
                          cchPort );
    return TRUE;
}

BOOL
TPortsLV::
bGetSelectedPort(
    OUT LPTSTR pszPort,
    IN  COUNT cchPort,
    INT *pItem
    )

/*++

Routine Description:

    Retrieve the currently selected port in the list view.

Arguments:

    pszPort - TCHAR array to receive port

    cchPort - COUNTOF port string.

    iItem - Index of the item with which to begin the search
    
Return Value:

    TRUE - success, FALSE = fail.
    iItem will be set to the new found index.

--*/

{
    INT iItem = *pItem;

    iItem = ListView_GetNextItem( _hwndLV,
                                  iItem,
                                  LVNI_SELECTED );
    if( iItem == -1 ){

        DBGMSG( DBG_WARN,
                ( "PrinterPort.bGetSelectedPort: Unable to retrieve next selected item %d\n",
                  GetLastError( )));
        return FALSE;
    }

    ListView_GetItemText( _hwndLV,
                          iItem,
                          0,
                          pszPort,
                          cchPort );

    *pItem = iItem;

    return TRUE;
}

BOOL
TPortsLV::
bHandleNotifyMessage(
    LPARAM lParam
    )
{
    BOOL bStatus = TRUE;
    LPNMHDR pnmh = (LPNMHDR)lParam;

    switch( pnmh->code )
    {
    case NM_DBLCLK:

        vHandleItemClicked( lParam );

        if( _wmDoubleClickMsg )                                 
        {
            PostMessage( _hwnd, WM_COMMAND, _wmDoubleClickMsg, 0 );
        }
        break;

    case NM_CLICK:

        vHandleItemClicked( lParam );

        if( _wmSingleClickMsg )                                 
        {
            PostMessage( _hwnd, WM_COMMAND, _wmSingleClickMsg, 0 );
        }
        break;

    case LVN_KEYDOWN:
        {
            LV_KEYDOWN* plvnkd = (LV_KEYDOWN *)lParam;

            if( _bSelectionState && _bAllowSelectionChange )
            {
                //
                // !! LATER !!
                //
                // Is this the best way to check whether the ALT
                // key is _not_ down?
                //
                if( plvnkd->wVKey == TEXT( ' ' ) &&
                    !( GetKeyState( VK_LMENU ) & 0x80000000 ) &&
                    !( GetKeyState( VK_RMENU ) & 0x80000000 ))
                {
                    vItemClicked( ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED ));
                }
            }

            //
            // If the delete key was used then post a message to 
            // appropriate window with the specified message.
            //
            if(plvnkd->wVKey == VK_DELETE )
            {
                if( _wmDeleteKeyMsg )                                 
                {
                    PostMessage( _hwnd, WM_COMMAND, _wmDeleteKeyMsg, 0 );
                }
            }
        }
        break;

    case LVN_COLUMNCLICK:
        {
            NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
            (VOID)bListViewSort( pNm->iSubItem );
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}


VOID
TPortsLV::
vHandleItemClicked( 
    IN LPARAM lParam 
    )
{
    if( _bSelectionState && _bAllowSelectionChange )
    {
        LV_HITTESTINFO lvhti;
        DWORD dwPos = GetMessagePos();
        POINTS &pt = MAKEPOINTS(dwPos);

        lvhti.pt.x = pt.x;
        lvhti.pt.y = pt.y;

        MapWindowPoints( HWND_DESKTOP, _hwndLV, &lvhti.pt, 1 );

        INT iItem = ListView_HitTest( _hwndLV, &lvhti );

        if( iItem != -1 )
        {
            vItemClicked( iItem );
        }
    }
}

VOID
TPortsLV::
vInsertPortsByMask( 
    IN UINT cPorts,
    IN PORT_INFO_2 pPorts[],
    IN UINT cPrinters,
    IN PRINTER_INFO_2 pPrinters[],
    IN DWORD dwLevel,
    IN LPCTSTR pszTemplate,
    IN LPCTSTR pszDescription
    )
{
    TString         strPrinters;

    //
    // Go through the ports and add them.
    //
    for( UINT i=0; i<cPorts; ++i )
    {
        if( dwLevel == 2 )
        {
            //
            // Check if this port has been added
            //
            if( NULL == pPorts[i].pPortName )
            {
                continue;
            }

            //
            // Check if the port name matches the template
            //
            if( pszTemplate && !bMatchTemplate( pszTemplate, pPorts[i].pPortName ) )
            {
                continue;
            }

            //
            // Assign proper description 
            //
            LPCTSTR pszDescr = pszDescription;
            if( !pszDescr )
            {
                pszDescr = pPorts[i].pDescription;
            }

            //
            // If we have printers on this machine.
            //
            if( pPrinters && cPrinters )
            {
                vPrintersUsingPort( strPrinters, pPrinters, cPrinters, pPorts[i].pPortName );
            }                

            vAddPortToListView( pPorts[i].pPortName, pPorts[i].pMonitorName, pszDescr, strPrinters  );

            //
            // Mark the port as added
            //
            pPorts[i].pPortName = NULL;
        }
        else
        {
            //
            // Check if this port has been added
            //
            if( NULL == ((PPORT_INFO_1)pPorts)[i].pName )
            {
                continue;
            }

            //
            // Check if the port name matches the template
            //
            if( pszTemplate && !bMatchTemplate( pszTemplate, ((PPORT_INFO_1)pPorts)[i].pName ) )
            {
                continue;
            }

            //
            // If we have printers on this machine.
            //
            if( pPrinters && cPrinters )
            {
                vPrintersUsingPort( strPrinters, pPrinters, cPrinters, ((PPORT_INFO_1)pPorts)[i].pName );
            }                

            vAddPortToListView( ((PPORT_INFO_1)pPorts)[i].pName, gszNULL, gszNULL, strPrinters );

            //
            // Mark the port as added
            //
            ((PPORT_INFO_1)pPorts)[i].pName = NULL;
        }
    }
}

BOOL
TPortsLV::
bDeletePorts(
    IN HWND     hDlg,
    IN LPCTSTR  pszServer
    )
/*++

Routine Description:

    Delete selected ports for given print server.

Arguments:

    hDlg - dialog handle for port tab.
    pszServer - print server name.

Return Value:

    True if at least one port is deleted, false otherwise.

--*/

{
    TStatusB    bStatus;
    TCHAR       szPortName[TPortsLV::kPortNameMax];
    COUNT       cItems;
    INT         iItem = -1;
    INT         i;
    BOOL        bFailed = FALSE;
    BOOL        bDeleted = FALSE;

    //
    // Check whether multi ports are selected
    //
    cItems = cSelectedItems();

    if(cItems == 0)
    {
        return FALSE;
    }

    //
    // Get the first selected port name to compose the warning message
    //
    bStatus DBGCHK = bGetSelectedPort( szPortName, COUNTOF( szPortName ) );

    if( IDYES == iMessage( hDlg,
                           IDS_DELETE_PORT_TITLE,
                           cItems > 1 ? IDS_DELETE_PORTN : IDS_DELETE_PORT,
                           MB_YESNO | MB_ICONQUESTION,
                           kMsgNone,
                           NULL,
                           szPortName ))
    {
        //
        // Try to delete all selected items 
        //
        for( i = 0; i < (INT)cItems ; i++ )
        {
            //
            // Get each selected port name
            //
            bStatus DBGCHK = bGetSelectedPort( szPortName, COUNTOF( szPortName ), &iItem );

            SPLASSERT( bStatus );
            SPLASSERT( iItem != -1 );
            
            //
            // Attempt to delete the selected port.
            //
            bStatus DBGCHK = DeletePort( (LPTSTR)pszServer, hDlg, szPortName );

            if( bStatus )
            {
                //
                // Succeeded, refresh the ports UI by deleting the port.
                //
                vDeletePortFromListView( szPortName );

                //
                // Decrease the iItem because deleting one item in the list
                //
                iItem--;
                bDeleted = TRUE;
            } 
            else 
            {
                if( GetLastError() != ERROR_CANCELLED )
                {
                    bFailed = TRUE;
                }
            }
        }

        //
        // Only show an error message if the did not cancel the
        // the action.
        //
        if( bFailed )
        {
            iMessage( hDlg,
                      IDS_DELETE_PORT_TITLE,
                      cItems > 1 ? IDS_ERR_DELETE_PORTN : IDS_ERR_DELETE_PORT,
                      MB_OK | MB_ICONEXCLAMATION,
                      kMsgGetLastError,
                      gaMsgErrMapPorts);
        }

        bStatus DBGNOCHK = bDeleted;
    }
    else
    {
        bStatus DBGNOCHK = FALSE;
    }

    return bStatus;
}

BOOL
TPortsLV::
bConfigurePort(
    IN HWND     hDlg,
    IN LPCTSTR  pszServer
    )
{
    static MSG_ERRMAP aMsgErrMapPorts[] = {
        ERROR_INVALID_PARAMETER, IDS_ERR_PORT_DOES_NOT_EXIST,
        0, 0
    };

    TStatusB bStatus;
    TCHAR szPortName[TPortsLV::kPortNameMax];

    bStatus DBGCHK = bGetSelectedPort( szPortName, COUNTOF( szPortName ) );

    if( bStatus )
    {
        bStatus DBGCHK = ConfigurePort( (LPTSTR)pszServer,
                                        hDlg,
                                        szPortName );

        if( !bStatus )
        {
            if( GetLastError() != ERROR_CANCELLED )
            {
                iMessage( hDlg,
                          IDS_CONFIGURE_PORT_TITLE,
                          IDS_ERR_CONFIG_PORT,
                          MB_OK | MB_ICONEXCLAMATION,
                          kMsgGetLastError,
                          aMsgErrMapPorts );
            }
        }
    } 
    else 
    {
        DBGMSG( DBG_WARN, ( "PrinterPorts.vConfigure: failed %d\n", GetLastError( )));
    }

    return bStatus;
}

VOID
TPortsLV::
vPrintersUsingPort(
    IN OUT  TString        &strPrinters,
    IN      PRINTER_INFO_2 *pPrinterInfo,
    IN      DWORD           cPrinterInfo,
    IN      LPCTSTR         pszPortName
    )
/*++

Routine Description:

    Builds a comma separated string of all the printers
    using the specified port.

Arguments:

    strPrinters - TString refrence where to return resultant string.
    pPrinterInfo - Pointer to a printer info level 2 structure array.
    cPrinterInfo - Number of printers in the printer info 2 array.
    pszPortName - Pointer to string or port name to match.

Return Value:

    Nothing.

Notes:
    If no printer is using the specfied  port the string refrence
    will contain an empty string.

--*/
{
    SPLASSERT( pPrinterInfo );
    SPLASSERT( pszPortName );

    LPTSTR psz;
    LPTSTR pszPort;
    LPTSTR pszPrinter;
    UINT i;
        
    //
    // Clear the current printer buffer.
    //
    TStatusB bStatus;
    bStatus DBGCHK = strPrinters.bUpdate( NULL );

    //
    // Traverse the printer info array.
    //
    for( i = 0; i < cPrinterInfo; i++ ){

        for( psz = pPrinterInfo[i].pPortName; psz && *psz; ){

            //
            // Look for a comma if found terminate the port string.
            //
            pszPort = psz;
            psz = _tcschr( psz, TEXT( ',' ) );

            if( psz ){
                *psz = 0;
            }

            //
            // Check for a port match.
            //
            if( !_tcsicmp( pszPort, pszPortName ) ){

                //
                // Point to printer name.
                //
                pszPrinter = pPrinterInfo[i].pPrinterName;

                //
                // Strip the server name here.
                //
                if( pPrinterInfo[i].pPrinterName[0] == TEXT( '\\' ) &&
                    pPrinterInfo[i].pPrinterName[1] == TEXT( '\\' ) ){

                    //
                    // Locate the printer name.
                    //
                    pszPrinter = _tcschr( pPrinterInfo[i].pPrinterName+2, TEXT( '\\' ) );
                    pszPrinter = pszPrinter ? pszPrinter+1 : pPrinterInfo[i].pPrinterName;

                }

                //
                // If this is the first time do not place a comma separator.
                //
                if( !strPrinters.bEmpty() ){

                    bStatus DBGCHK = strPrinters.bCat( TEXT( ", " ) );

                    if( !bStatus ){
                        DBGMSG( DBG_WARN, ( "Error cat string line: %d file : %s.\n", __LINE__, __FILE__ ) );
                        break;
                    }
                }

                //
                // Tack on the printer name
                //
                bStatus DBGCHK = strPrinters.bCat( pszPrinter );

                if( !bStatus ){
                    DBGMSG( DBG_WARN, ( "Error cat string line : %d file : %s.\n", __LINE__, __FILE__ ) );
                    break;
                }
            }

            //
            // Replace the previous comma.
            //
            if( psz ){
                *psz = TEXT( ',' );
                ++psz;
            }
        }
    }
}

VOID
TPortsLV::
vSetSingleSelection(
    IN BOOL bSingleSelection
    )
/*++

Routine Description:

    Set the list view into single selection mode.

Arguments:

    bSingleSelection - TRUE single selection, FALSE multi selection.

Return Value:

    Nothing.

--*/
{
    _bSingleSelection = bSingleSelection;
}

BOOL
TPortsLV::
bGetSingleSelection(
    VOID
    )
/*++

Routine Description:

    Get the current list view selection mode.

Arguments:

    None.

Return Value:

    TURE in single selection mode, FALSE in multi selection mode.

--*/
{
    return _bSingleSelection;
}

VOID
TPortsLV::
vCreatePortDataList(
    VOID
    )
/*++

Routine Description:

    Initialize the port data list.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    DBGMSG( DBG_TRACE, ( "PortsLV::vCreatePortDataList\n" ) );

    PortDataList_vReset();
}

VOID
TPortsLV::
vDestroyPortDataList(
    VOID
    )
/*++

Routine Description:

    Destroy the port data list.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    DBGMSG( DBG_TRACE, ( "PortsLV::vDestroyPortDataList\n" ) );

    TIter Iter;
    TPortData *pPortData;

    for( PortDataList_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); )
    {
        pPortData = PortDataList_pConvert( Iter );
        Iter.vNext();
        delete pPortData;
    }
}

BOOL
TPortsLV::
bListViewSort(
    IN UINT uColumn
    )
/*++

Routine Description:

    This function is called to sort the items.  The current
    column indes is specified to indicated witch column to 
    sort.

Arguments:

    Column index to sort.

Return Value:

    TRUE list is sorted, FALSE error occurred.

--*/
{
    DBGMSG( DBG_TRACE, ( "PortsLV::bListViewSort Column %d\n", uColumn ) );

    //
    // Set the surrent column number.
    //
    _uCurrentColumn = uColumn;

    //
    // Tell the list view to sort.
    //
    TStatusB bStatus;
    bStatus DBGCHK = ListView_SortItems( _hwndLV, iCompareProc, (LPARAM)this );

    //
    // Toggle the specified column sort state.
    //
    _ColumnSortState.bToggle( uColumn );

    return bStatus;
}

INT 
CALLBACK 
TPortsLV::
iCompareProc(
    IN LPARAM lParam1, 
    IN LPARAM lParam2, 
    IN LPARAM RefData
    )
/*++

Routine Description:

    List view defined compare routine.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    TPortData   *pPortData1 = reinterpret_cast<TPortData *>( lParam1 );
    TPortData   *pPortData2 = reinterpret_cast<TPortData *>( lParam2 );
    TPortsLV    *pPortsLV   = reinterpret_cast<TPortsLV *>( RefData );
    INT         iResult     = 0;
    LPCTSTR     strName1    = NULL;
    LPCTSTR     strName2    = NULL;

    if( pPortsLV && pPortData1 && pPortData2 )
    {
        BOOL bStatus = TRUE;

        switch( pPortsLV->_uCurrentColumn )
        {

        case 0:
            strName1 = pPortData1->_strName;
            strName2 = pPortData2->_strName;
            break;

        case 1:
            strName1 = pPortData1->_strDescription;
            strName2 = pPortData2->_strDescription;
            break;

        case 2:
            strName1 = pPortData1->_strPrinters;
            strName2 = pPortData2->_strPrinters;
            break;

        default:
            bStatus = FALSE;
            break;
    
        }

        if( bStatus )
        {
            if( pPortsLV->_ColumnSortState.bRead( pPortsLV->_uCurrentColumn ) )
                iResult = _tcsicmp( strName2, strName1 );
            else
                iResult = _tcsicmp( strName1, strName2 );
        }
    }

    return iResult;
}

TPortsLV::TPortData *
TPortsLV::
AddPortDataList(
    IN LPCTSTR pszName,
    IN LPCTSTR pszMonitor,
    IN LPCTSTR pszDescription,
    IN LPCTSTR pszPrinters
    )
/*++

Routine Description:

    Add port to port data list.

Arguments:

    pszName         - pointer to port name.
    pszDescription  - pointer to description string.
    pszPrinters     - pointer to printers using this port string.

Return Value:

    TRUE port added to data list, FALSE error occurred.

--*/
{
    DBGMSG( DBG_TRACE, ( "PortsLV::AddPortDataList\n" ) );

    //
    // Allocate the port data.
    //
    TPortData *pPortData = new TPortData( pszName, pszMonitor, pszDescription, pszPrinters );

    //
    // If valid object created.
    //
    if( VALID_PTR( pPortData ) )
    {
        //
        // Add the port data to the list.
        //
        PortDataList_vAppend( pPortData );
    }
    else
    {
        //
        // The object may have been allocated, however failed construction.
        //
        delete pPortData;
        pPortData = NULL;
    }

    return pPortData;
}

BOOL
TPortsLV::
DeletePortDataList(
    IN LPCTSTR pszName
    )
/*++

Routine Description:

    Delete the specified port from the port data list.

Arguments:

    pszName - pointer to port name.

Return Value:

    TRUE port delete, FALSE error occurred.

--*/
{
    DBGMSG( DBG_TRACE, ( "PortsLV::DeletePortDataList\n" ) );

    BOOL bStatus = FALSE;
    TIter Iter;

    for( PortDataList_vIterInit( Iter ), Iter.vNext(); Iter.bValid(); Iter.vNext() )
    {
        TPortData *pPortData = PortDataList_pConvert( Iter );

        if( pPortData->_strName == pszName )
        {
            DBGMSG( DBG_TRACE, ( "PortsLV::DeletePortDataList Port "TSTR" deleted\n", pszName ) );
            delete pPortData;
            bStatus = TRUE;
            break;
        }                
    }

    return bStatus;
}

/********************************************************************

    Port Data helper class.

********************************************************************/

TPortsLV::TPortData::
TPortData(
    IN LPCTSTR pszName,
    IN LPCTSTR pszMonitor,
    IN LPCTSTR pszDescription,
    IN LPCTSTR pszPrinters
    )
{
    DBGMSG( DBG_TRACE, ( "PortsLV::TPortData ctor\n" ) );
    _strName.bUpdate( pszName );
    _strMonitor.bUpdate( pszMonitor );
    _strDescription.bUpdate( pszDescription );
    _strPrinters.bUpdate( pszPrinters );
}

TPortsLV::TPortData::
~TPortData(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "PortsLV::TPortData dtor\n" ) );
    //
    // If we are linked then remove ourself.
    //
    if( PortData_bLinked() )
    {
        PortData_vDelinkSelf();
    }
}

BOOL
TPortsLV::TPortData::
bValid(
    VOID
    )
{
    return VALID_OBJ( _strName ) &&
           VALID_OBJ( _strMonitor ) &&
           VALID_OBJ( _strDescription ) &&
           VALID_OBJ( _strPrinters );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\persist.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998
All rights reserved.

Module Name:

    persist.cxx

Abstract:

    Persistent store class.

Author:

    Steve Kiraly (SteveKi)  05/12/97

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "persist.hxx"

/********************************************************************

    Persistant store class.

********************************************************************/

TPersist::
TPersist(
    IN LPCTSTR pszSection,
    IN UINT    ioFlags,
    IN HKEY    hOpenedKey
    ) : strSection_( pszSection ),
        hKey_( NULL ),
        dwStatus_( ERROR_SUCCESS )
{
    SPLASSERT( pszSection );
    SPLASSERT( hOpenedKey );

    DWORD dwDisposition = 0;
    UINT  uAccessIndex  = 0;

    static DWORD adwAccess []  = { 0, KEY_READ, KEY_WRITE, KEY_ALL_ACCESS };

    uAccessIndex = ioFlags & ( kRead | kWrite );

    if( uAccessIndex )
    {
        if( ioFlags & kCreate )
        {
            dwStatus_ = RegCreateKeyEx( hOpenedKey,
                                       strSection_,
                                       0,
                                       NULL,
                                       0,
                                       adwAccess[ uAccessIndex ],
                                       NULL,
                                       &hKey_,
                                       &dwDisposition );
        }
        else if( ioFlags & kOpen )
        {
            dwStatus_ = RegOpenKeyEx( hOpenedKey,
                                     strSection_,
                                     0,
                                     adwAccess[ uAccessIndex ],
                                     &hKey_ );
        }
    }
}

TPersist::
~TPersist(
    VOID
    )
{
    if( hKey_ )
    {
        RegCloseKey( hKey_ );
    }
}

BOOL
TPersist::
bValid(
    VOID
    ) const
{
    //
    // A valid hKey and a valid section name is the class valid check.
    //
    return hKey_ != NULL && strSection_.bValid();
}

DWORD 
TPersist::
dwLastError(
    VOID
    ) const
{
    return dwStatus_;
}

BOOL
TPersist::
bRead( 
    IN      LPCTSTR  pValueName, 
    IN OUT  DWORD    &dwValue 
    ) 
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );

    DWORD dwType    = REG_DWORD;
    DWORD dwSize    = sizeof( dwValue );

    dwStatus_ = RegQueryValueEx( hKey_,
                                 pValueName,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>( &dwValue ),
                                 &dwSize );

    return dwStatus_ == ERROR_SUCCESS && dwType == REG_DWORD;
}

BOOL
TPersist::
bRead( 
    IN      LPCTSTR  pValueName, 
    IN OUT  BOOL     &bValue 
    ) 
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );

    DWORD dwType    = REG_DWORD;
    DWORD dwSize    = sizeof( bValue );

    dwStatus_ = RegQueryValueEx( hKey_,
                                 pValueName,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>( &bValue ),
                                 &dwSize );

    return dwStatus_ == ERROR_SUCCESS && dwType == REG_DWORD;
}

BOOL
TPersist::
bRead( 
    IN      LPCTSTR  pValueName, 
    IN OUT  TString  &strValue 
    ) 
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );

    TCHAR szBuffer[kHint];
    DWORD dwType    = REG_SZ;
    BOOL  bStatus   = FALSE;
    DWORD dwSize    = sizeof( szBuffer );

    dwStatus_ = RegQueryValueEx( hKey_,
                                 pValueName,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>( szBuffer ),
                                 &dwSize );

    if( dwStatus_ == ERROR_MORE_DATA && dwType == REG_SZ && dwSize )
    {
        LPTSTR pszBuff = new TCHAR[ dwSize ];

        if( pszBuff )
        {
            dwStatus_ = RegQueryValueEx( hKey_,
                                        pValueName,
                                        NULL,
                                        &dwType,
                                        reinterpret_cast<LPBYTE>( pszBuff ),
                                        &dwSize );
        }
        else
        {
            dwStatus_ = ERROR_NOT_ENOUGH_MEMORY;
        }

        if( dwStatus_ == ERROR_SUCCESS )
        {
            bStatus = strValue.bUpdate( pszBuff );
        }

        delete [] pszBuff;

    }
    else
    {
        if( dwStatus_ == ERROR_SUCCESS && dwType == REG_SZ )
        {
            bStatus = strValue.bUpdate( szBuffer );
        }
    }

    return bStatus;
}

BOOL
TPersist::
bRead( 
    IN      LPCTSTR  pValueName, 
    IN OUT  PVOID    pValue, 
    IN      DWORD    cbSize, 
    IN      LPDWORD  pcbNeeded  OPTIONAL
    ) 
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );
    SPLASSERT( pValue );

    DWORD dwType    = REG_BINARY;
    BOOL  bStatus   = FALSE;
    DWORD dwSize    = cbSize;

    dwStatus_ = RegQueryValueEx( hKey_,
                                 pValueName,
                                 NULL,
                                 &dwType,
                                 reinterpret_cast<LPBYTE>( pValue ),
                                 &dwSize );

    if( dwStatus_ == ERROR_MORE_DATA && pcbNeeded )
    {
        *pcbNeeded = dwSize;
    }

    return dwStatus_ == ERROR_SUCCESS && dwType == REG_BINARY && dwSize == cbSize;
}

BOOL
TPersist::
bWrite( 
    IN       LPCTSTR  pValueName, 
    IN const DWORD    dwValue 
    )
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );

    dwStatus_ = RegSetValueEx( hKey_,
                               pValueName,
                               0,
                               REG_DWORD,
                               reinterpret_cast<const BYTE *>( &dwValue ),
                               sizeof( dwValue ) );

    return dwStatus_ == ERROR_SUCCESS;
}

BOOL
TPersist::
bWrite( 
    IN       LPCTSTR  pValueName, 
    IN       LPCTSTR  pszValue 
    )
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );

    dwStatus_ = RegSetValueEx( hKey_,
                               pValueName,
                               0,
                               REG_SZ,
                               reinterpret_cast<const BYTE *>( pszValue ),
                               _tcslen( pszValue ) * sizeof( TCHAR ) + sizeof( TCHAR ) );

    return dwStatus_ == ERROR_SUCCESS;
}

BOOL
TPersist::
bWrite( 
    IN       LPCTSTR  pValueName, 
    IN const PVOID    pValue, 
    IN       DWORD    cbSize 
    )
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );
    SPLASSERT( pValue );

    dwStatus_ = RegSetValueEx( hKey_,
                               pValueName,
                               0,
                               REG_BINARY,
                               reinterpret_cast<const BYTE *>( pValue ),
                               cbSize );

    return dwStatus_ == ERROR_SUCCESS;
}

BOOL
TPersist::
bRemove( 
    IN LPCTSTR  pValueName
    ) 
{
    SPLASSERT( bValid() );
    SPLASSERT( pValueName );

    dwStatus_ = RegDeleteValue( hKey_, pValueName );

    return dwStatus_ == ERROR_SUCCESS;
}

BOOL
TPersist::
bRemoveKey( 
    IN LPCTSTR  pKeyName
    ) 
{
    SPLASSERT( bValid() );
    SPLASSERT( pKeyName );

    dwStatus_ = dwRecursiveRegDeleteKey( hKey_, pKeyName );

    return dwStatus_ == ERROR_SUCCESS;
}

DWORD
TPersist::
dwRecursiveRegDeleteKey( 
    IN HKEY     hKey, 
    IN LPCTSTR  pszSubkey 
    ) const
{
    HKEY hSubkey = NULL;

    DWORD dwStatus = RegOpenKeyEx( hKey, 
                                   pszSubkey, 
                                   0,
                                   KEY_ALL_ACCESS, 
                                   &hSubkey );

    while ( dwStatus == ERROR_SUCCESS )
    {
        TCHAR szSubkey[ MAX_PATH ];
        DWORD cbSubkeySize = COUNTOF( szSubkey );
        
        dwStatus = RegEnumKeyEx( hSubkey, 
                                 0, 
                                 szSubkey, 
                                 &cbSubkeySize,
                                 0, 
                                 0, 
                                 0, 
                                 0 );

        if( dwStatus == ERROR_NO_MORE_ITEMS )
            break;

        if( dwStatus != ERROR_SUCCESS )
            return dwStatus;

        dwStatus = dwRecursiveRegDeleteKey( hSubkey, szSubkey );
    }

    if( hSubkey )
    {
        RegCloseKey( hSubkey );
    }

    dwStatus = RegDeleteKey( hKey, pszSubkey );

    return dwStatus;
}


#if DBG 

VOID
TestPersistClass(
    VOID
    )
{
    TStatusB bStatus;
    TString strValue;
    DWORD   dwValue             = 0xDEADBEEF; 
    LPCTSTR pszValue            = TEXT( "TestValueData" );
    DWORD   cbNeeded            = 0;
    TCHAR   szValue[MAX_PATH];

    for( UINT i = 0; i < COUNTOF( szValue )-1; i++ )
        szValue[i] = TEXT('A');
    szValue[i] = 0;

    {
        TPersist Persist( TEXT( "Printers\\Settings\\Test" ), TPersist::kCreate|TPersist::kWrite );

        if( VALID_OBJ( Persist ) )
        {
            bStatus DBGCHK = Persist.bWrite( TEXT("Test Value dword"), dwValue );
            bStatus DBGCHK = Persist.bWrite( TEXT("Test Value string"), TEXT("Test") );
            bStatus DBGCHK = Persist.bWrite( TEXT("Test Value binary"), szValue, sizeof( szValue ) );
        }
    }

    {
        TPersist Persist( TEXT( "Printers\\Settings\\Test" ), TPersist::kOpen|TPersist::kRead );

        if( VALID_OBJ( Persist ) )
        {
            bStatus DBGCHK = Persist.bRead( TEXT("Test Value dword"), dwValue );
            DBGMSG( DBG_TRACE, ("Test value dword %x\n", dwValue ) );

            bStatus DBGCHK = Persist.bRead( TEXT("Test Value string"), strValue );
            DBGMSG( DBG_TRACE, ("Test value string " TSTR "\n", (LPCTSTR)strValue ) );


            DBGMSG( DBG_TRACE, ("1Test value binary\n" ) );
            bStatus DBGCHK = Persist.bRead( TEXT("Test Value binary"), szValue, sizeof( szValue ) - 1 );

            if( bStatus )
            {
                DBGMSG( DBG_TRACE, ("1Test value binary succeeded\n" ) );
                DBGMSG( DBG_TRACE, ("-"TSTR"-\n", szValue) );
            }
            else
            {
                DBGMSG( DBG_TRACE, ("1Test value binary failed with %d\n", Persist.dwLastError() ) );
            }

                   
            DBGMSG( DBG_TRACE, ("2Test value binary\n" ) );
            bStatus DBGCHK = Persist.bRead( TEXT("Test Value binary"), szValue, sizeof( szValue ) );

            if( bStatus )
            {
                DBGMSG( DBG_TRACE, ("2Test value binary succeeded\n" ) );
                DBGMSG( DBG_TRACE, ("-"TSTR"-\n", szValue) );
            }
            else
            {
                DBGMSG( DBG_TRACE, ("2Test value binary failed with %d\n", Persist.dwLastError() ) );
            }


            DBGMSG( DBG_TRACE, ("3Test value binary\n" ) );
            bStatus DBGCHK = Persist.bRead( TEXT("Test Value binary"), szValue, sizeof( szValue )-8, &cbNeeded );

            if( bStatus )
            {
                DBGMSG( DBG_TRACE, ("3Test value binary succeeded\n" ) );
                DBGMSG( DBG_TRACE, ("-"TSTR"-\n", szValue) );
            }
            else
            {
                DBGMSG( DBG_TRACE, ("3Test value binary cbNeeded %d LastError %d\n", cbNeeded, Persist.dwLastError() ) );
            }

        }
    }

    {
        TPersist Persist( TEXT( "Printers\\Settings\\Test" ), TPersist::kOpen|TPersist::kRead|TPersist::kWrite );

        if( VALID_OBJ( Persist ) )
        {
            bStatus DBGCHK = Persist.bRemove( TEXT("dead") );
            if( !bStatus )
                DBGMSG( DBG_TRACE, ("Remove of " TSTR " failed LastError %d\n", TEXT("dead"), Persist.dwLastError() ) );

            bStatus DBGCHK = Persist.bRemove( TEXT("Test Value dwordx") );
            if( !bStatus )
                DBGMSG( DBG_TRACE, ("Remove of " TSTR " failed LastError %d\n", TEXT("Test Value dwordx"), Persist.dwLastError() ) );

            bStatus DBGCHK = Persist.bRemove( TEXT("Test Value dword") );
            if( !bStatus )
                DBGMSG( DBG_TRACE, ("Remove of " TSTR " failed LastError %d\n", TEXT("Test Value dword"), Persist.dwLastError() ) );

            bStatus DBGCHK = Persist.bRemove( TEXT("Test Value string") );
            if( !bStatus )
                DBGMSG( DBG_TRACE, ("Remove of " TSTR " failed LastError %d\n", TEXT("Test Value string"), Persist.dwLastError() ) );

            bStatus DBGCHK = Persist.bRemove( TEXT("Test Value binary") );
            if( !bStatus )
                DBGMSG( DBG_TRACE, ("Remove of " TSTR " failed LastError %d\n", TEXT("Test Value binary"), Persist.dwLastError() ) );

            bStatus DBGCHK = Persist.bRemoveKey( TEXT("Test") );
            if( !bStatus )
                DBGMSG( DBG_TRACE, ("Remove key of " TSTR " failed LastError %d\n", TEXT("Test"), Persist.dwLastError() ) );

        }
    }

    {
        TPersist Persist( TEXT( "Printers\\Settings" ), TPersist::kOpen|TPersist::kRead|TPersist::kWrite );

        if( VALID_OBJ( Persist ) )
        {
            bStatus DBGCHK = Persist.bRemoveKey( TEXT("Test") );
            if( !bStatus )
                DBGMSG( DBG_TRACE, ("Remove key of " TSTR " failed LastError %d\n", TEXT("Test"), Persist.dwLastError() ) );

        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\prids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by printui.rc
//
#define IDM_PRINTER_INSTALL             100
#define IDM_PRINTER_COMMAND_FIRST       101
#define IDM_PRINTER_PAUSE               101
#define IDM_PRINTER_PURGE               102
#define IDM_PRINTER_SET_DEFAULT         103
#define IDM_PRINTER_SHARING             104
#define IDM_REFRESH                     105
#define IDM_PRINTER_PROPERTIES          106
#define IDM_PRINTER_CLOSE               107
#define IDM_PRINTER_DOCUMENT_DEFAULTS   108
#define IDM_PRINTER_WORKOFFLINE         109
#define IDM_PRINTER_COMMAND_LAST        109
#define IDA_INSPECT                     128
#define POPUP_DRAGDROP_PRINT            131
#define IDI_PRINTER_ERROR               132
#define POPUP_TRAYNOTIFY_PRINTERS       133
#define IDB_PRNPLUG                     134
#define ID_HELP_PERMISSIONS_MAIN_DLG    160
#define ID_HELP_PERMISSIONS_ADD_USER_DLG 170
#define ID_HELP_SERVERVIEWER            180
#define ID_HELP_AUDITING_MAIN_DLG       190
#define ID_HELP_AUDITING_ADD_USER_DLG   195
#define IDM_JOB_PAUSE                   200
#define IDM_JOB_RESUME                  201
#define IDM_JOB_RESTART                 202
#define IDM_JOB_CANCEL                  203
#define IDM_JOB_PROPERTIES              204
#define ID_HELP_PERMISSIONS_LOCAL_GROUP 210
#define ID_HELP_PERMISSIONS_GLOBAL_GROUP 220
#define ID_HELP_PERMISSIONS_FIND_ACCOUNT 230
#define ID_HELP_AUDITING_LOCAL_GROUP    240
#define ID_HELP_AUDITING_GLOBAL_GROUP   250
#define ID_HELP_AUDITING_FIND_ACCOUNT   260
#define ID_HELP_TAKE_OWNERSHIP          270
#define IDM_STATUS_BAR                  300
#define IDM_HELP_CONTENTS               400
#define IDM_HELP_ABOUT                  401
#define MH_PRINTER                      402
#define MENU_PRINTQUEUE                 403
#define ACCEL_PRINTQUEUE                404
#define POPUP_DRAGDROP_MOVE             404
#define IDI_PRINTER                     420
#define IDI_SEC_PERMS                   421
#define IDI_SEC_AUDIT                   422
#define IDI_SEC_OWNER                   423
#define IDI_DOCUMENT                    424
#define IDI_SERVER                      425
#define IDB_WATERMARK                   426
#define IDB_BANNER                      427
#define IDB_CHECKSTATES                 428
#define IDB_WIZBMP                      429
#define IDB_BROWSE                      430
#define IDA_SEARCH                      431
#define IDR_MF_LOGO                     432
#define IDI_GLOBE                       433
#define DLG_DRIVER_DETAILS              501
#define DLG_RUNDLL                      502
#define DLG_ASYNC                       503
#define DLG_ADDITIONAL_DRIVERS          504
#define DLG_END_TESTPAGE                505
#define DLG_DOC_JOB_GENERAL             506
#define DLG_PRINTER_GENERAL             507
#define DLG_PRINTER_PORTS               508
#define DLG_PRINTER_JOB_SCHEDULING      509
#define DLG_PRINTER_SHARING             510
#define DLG_PRINTER_ADD_PORT            511
#define DLG_PRINTER_SEPARATOR_PAGE      512
#define DLG_PRINTER_PROCESSORS          513
#define DLG_FORMS                       516
#define DLG_SERVER_SETTINGS             517
#define DLG_SERVER_PORTS                518
#define DLG_SERVER_DRIVERS              519
#define DLG_WIZ_DRIVER_INTRO            520
#define DLG_WIZ_NAME                    521
#define DLG_WIZ_SHARE                   522
#define DLG_WIZ_TEST_PAGE               523
#define DLG_WIZ_NET                     524
#define DLG_WIZ_TYPE                    525
#define DLG_WIZ_INTRO                   526
#define DLG_WIZ_LOCATE                  527
#define DLG_WIZ_DRIVER_ARCHITECTURE     528
#define DLG_WIZ_PORT                    529
#define DLG_WIZ_DRIVEREXISTS            530
#define DLG_WIZ_DRIVER_END              531
#define DLG_WIZ_FINISH                  532
#define DLG_WIZ_COMMENT                 533
#define DLG_DEVMGR_SETTINGS             534
#define DLG_MESSAGE_BOX                 535
#define DLG_CONNECTTO                   536
#define DLG_PRINTER_LOCATION            537
#define DLG_BROWSE_LOC                  538
#define IDC_SERVER_SPOOL_DIRECTORY      1008
#define IDC_DOWNLEVEL_TEXT              1009
#define IDC_DOWNLEVEL_LINE              1010
#define IDC_SERVER_REMOTE_JOB_ERRORS    1011
#define IDC_SERVER_LOCAL_JOB_NOTIFY     1012
#define IDC_SERVER_JOB_NOTIFY           1013
#define IDC_SERVER_NETWORK_JOB_NOTIFY   1014
#define IDC_SERVER_EVENT_LOGGING_ERROR  1015
#define IDC_SERVER_EVENT_LOGGING_WARN   1016
#define IDC_SERVER_EVENT_LOGGING_INFO   1017
#define IDC_PER_USER_DOCUMENT_DEFAULTS  1031
#define IDC_CANCEL                      1032
#define IDC_DS_SEARCH                   1033
#define IDC_NET_BROWSE                  1034
#define IDC_URL_BROWSE                  1035
#define IDC_DRIVER_NAME                 1045
#define IDC_PRINTER_NAME                1046
#define IDC_TEXT_COMMENT                1049
#define IDC_TEXT_LOCATION               1050
#define IDC_TEXT_DRIVER                 1051
#define IDC_POOLED_PRINTING             1052
#define IDC_SPOOL_DATATYPE              1053
#define IDC_DRIVER_DETAIL_NAME          1054
#define IDC_PUBLISHED                   1064
#define IDC_ADD_DRIVER                  1080
#define IDC_REMOVE_DRIVER               1081
#define IDC_MORE_DETAILS                1091
#define IDC_DRIVERS                     1092
#define IDC_RUNDLL_TEXT                 1098
#define IDC_RUNDLL_TITLE                1099
#define IDC_PRINTER_NAME_SUMMARY        1100
#define IDC_PORT_NAME_SUMMARY           1101
#define IDC_MODEL_NAME_SUMMARY          1102
#define IDC_SET_AS_DEFAULT_SUMMARY      1103
#define IDC_SHARE_NAME_SUMMARY          1104
#define IDC_UPDATE_DRIVER               1105
#define IDC_PRINT_TEST_PAGE_SUMMARY     1105
#define IDC_CONNECTION_SUMMARY          1106
#define IDC_LOCATION_SUMMARY            1107
#define IDC_COMMENT_SUMMARY             1108
#define IDC_PORT_DOUBLE_CLICKED         1109
#define IDC_ADDITIONAL_DRIVERS          1112
#define IDC_DRIVER_VERSION              1127
#define IDC_DRIVER_ENVIRONMENT          1128
#define IDC_DRIVER_PATH                 1129
#define IDC_DRIVER_FILE_LIST_VIEW       1133
#define IDC_ARCHITECTURE_LIST           1134
#define IDC_DRIVER_LANGUAGE_MONITOR     1136
#define IDC_DRIVER_DEFAULT_DATA_TYPE    1137
#define IDC_SERVER_PROPERTIES           1140
#define IDC_PRINTERS_FOLDER             1141
#define IDC_GLOBAL_DOCUMENT_DEFAULTS    1145
#define IDC_CONNECT_TO_URL              1147
#define IDC_ADDITIONAL_DRIVERS_TEXT     1148
#define IDC_PORTS_TEXT                  1154
#define IDC_DRIVER_SELECTION_SUMMARY    1158
#define IDC_MAIN_TITLE                  1164
#define IDC_ADD_PRINTER_DESC            1165
#define IDC_SERVER_NAME                 1166
#define IDC_DS_OPERATION_PENDING        1168
#define IDC_DRIVER_INTRO_TEXT2          1170
#define IDC_DRIVER_INTRO_TEXT1          1171
#define IDC_PRINTER_NAME_TEXT           1174
#define IDC_PORT_NAME_TEXT              1175
#define IDC_MODEL_NAME_TEXT             1176
#define IDC_SET_AS_DEFAULT_TEXT         1177
#define IDC_SHARE_NAME_TEXT             1178
#define IDC_CLICK_TO_ADD_TEXT           1179
#define IDC_PRINT_TEST_PAGE_TEXT        1180
#define IDC_COMPLETION_TEXT             1181
#define IDC_CONNECTION_TEXT             1182
#define IDC_CON_COMMENT_TEXT            1183
#define IDC_CON_COMMENT_SUMMARY         1184
#define IDC_CON_LOCATION_TEXT           1185
#define IDC_CON_LOCATION_SUMMARY        1186
#define IDC_CON_SET_DEFAULT_TEXT        1187
#define IDC_CON_SET_DEFAULT_SUMMARY     1188
#define IDC_CON_COMPLETION_TEXT         1189
#define IDC_CON_CLICK_TO_ADD_TEXT       1190
#define IDC_ADDITIONAL_DRIVERS_TEXT2    1193
#define IDC_ADDITIONAL_DRIVERS_TEXT3    1194
#define IDC_PRINTER_ICON                3000
#define IDC_NAME                        3001
#define IDC_DRIVER_NEW                  3003
#define IDC_COMMENT                     3005
#define IDC_LOCATION                    3006
#define IDC_TEST                        3007
#define IDC_SEPARATOR                   3008
#define IDC_PRINT_PROC                  3009
#define IDC_DOCUMENT_ICON               3013
#define IDC_TO_TEXT                     3014
#define IDC_BROWSE_LOCATION             3015
#define IDC_PORTS                       3100
#define IDC_PORT_CREATE                 3101
#define IDC_PORT_DELETE                 3102
#define IDC_PROPERTIES                  3103
#define IDC_ENABLE_BIDI                 3105
#define IDC_ALWAYS                      3200
#define IDC_START                       3201
#define IDC_SPOOL                       3220
#define IDC_PRINT_DIRECT                3221
#define IDC_SPOOL_ALL                   3222
#define IDC_SPOOL_PRINT_FASTER          3223
#define IDC_DEVQUERYPRINT               3224
#define IDC_PRINT_SPOOLED_FIRST         3225
#define IDC_KEEP_PRINTED_JOBS           3226
#define IDC_SHARED_OFF                  3227
#define IDC_SHARED                      3228
#define IDC_SHARED_NAME                 3302
#define IDC_LOCAL                       3510
#define IDC_NET                         3511
#define IDC_RADIO_YES                   3520
#define IDC_RADIO_NO                    3521
#define IDC_DRIVEREXISTS_KEEP_OLD       3550
#define IDC_DRIVEREXISTS_USE_NEW        3551
#define IDC_DRIVEREXISTS_TEXT           3552
#define IDC_SET_DEFAULT                 3555
#define IDC_DIVIDER0                    3557
#define IDC_DOC_JOB_SIZE_TEXT           3558
#define IDC_DOC_JOB_PAGES_TEXT          3559
#define IDC_DOC_JOB_DATATYPE_TEXT       3560
#define IDC_DOC_JOB_PROCCESSOR_TEXT     3561
#define IDC_DOC_JOB_OWNER_TEXT          3562
#define IDC_DOC_JOB_AT_TEXT             3563
#define IDC_DOC_JOB_NOTIFY_TEXT         3564
#define IDC_DOC_JOB_LOW_TEXT            3565
#define IDC_DOC_JOB_HIGH_TEXT           3566
#define IDC_DOC_JOB_CURR_TEXT           3567
#define IDC_DOC_JOB_TIME_TEXT           3568
#define IDC_DIVIDER1                    3569
#define IDC_DIVIDER2                    3570
#define IDC_DIVIDER3                    3571
#define IDC_DIVIDER4                    3572
#define IDC_DIVIDER5                    3573
#define IDC_DIVIDER6                    3574
#define IDC_DIVIDER7                    3575
#define IDC_GBOX_CONNECTO               3576
#define IDC_PHYSICAL_LOCATION           3577
#define IDC_GLOBE_ICON                  3578
#define IDC_DIVIDER8                    3579
#define IDC_TEXT_PHYSICAL_LOCATION      3580
#define IDC_BROWSE_PHYSICAL_LOCATION    3581
#define IDC_DOC_JOB_START               4201
#define IDC_DOC_JOB_SIZE                4219
#define IDC_DOC_JOB_TITLE               4220
#define IDC_DOC_JOB_AT                  4222
#define IDC_DOC_JOB_PROCCESSOR          4223
#define IDC_DOC_JOB_DATATYPE            4224
#define IDC_DOC_JOB_PAGES               4225
#define IDC_DOC_JOB_OWNER               4226
#define IDC_DOC_JOB_PRIORITY            4229
#define IDC_DOC_JOB_NOTIFY              4230
#define IDC_DOC_JOB_PRIORITY_CONTROL    4231
#define IDC_DOC_JOB_ALWAYS              4232
#define IDC_ADD_PORT_MONITOR_LIST       4303
#define IDC_ADD_PORT_BROWSE             4305
#define IDC_ADD_PORT_TEXT               4307
#define IDC_ADD_PORT                    4308
#define IDC_PRIORITY_TEXT               4313
#define IDC_SCHEDULE_GBOX               4314
#define IDC_SERVER_LINE                 4315
#define IDC_SPOOL_FOLDER_TEXT           4316
#define IDC_SERVER_PORTS_TEXT           4317
#define IDC_SHARING_GBOX                4318
#define IDC_SERVER_DRIVER_TEXT          4319
#define IDC_SERVER_JOB_NOTIFY_COMPUTER  4320
#define IDC_SEPARATOR_PAGE_BROWSE       4400
#define IDC_SEPARATOR_PAGE_EDIT         4401
#define IDC_SEPARATOR_PAGE_TEXT         4403
#define IDC_SEPARATOR_PAGE_DESC         4404
#define IDC_PRINT_PROCESSOR_LIST        4500
#define IDC_PRINT_DATATYPE_LIST         4501
#define IDC_PRINT_DATATYPE_TEXT         4503
#define IDC_PRINT_PROCESSOR_TEXT        4504
#define IDC_PRINT_PROCESSOR_DESC        4505
#define IDC_ITEM_SELECTED               4506
#define IDC_START_TIME                  4507
#define IDC_UNTIL_TIME                  4508
#define IDC_DOC_JOB_START_TIME          4509
#define IDC_DOC_JOB_UNTIL_TIME          4510
#define IDC_PRINTERS_FOLDER_TEXT        4511
#define IDC_SERVER_ICON                 4513
#define IDC_TEXT_CHOSEN                 4548
#define IDC_WIZ_BROWSE_LOCATION         4549
#define IDC_WIZ_TEXT_COMMENT            4550
#define IDC_WIZ_TEXT_LOCATION           4551
#define IDC_WIZ_COMMENT                 4552
#define IDC_WIZ_LOCATION                4553
#define IDC_WIZ_COMMENT_LOCATION_TEXT   4554
#define IDC_LOCATION_TEXT               4555
#define IDC_COMMENT_TEXT                4556
#define IDC_MONITOR_LIST                4557
#define IDC_PORT_OTHER                  4558
#define IDC_PORT_EXISTING               4559
#define IDC_MONITOR_TEXT                4568
#define IDC_DRIVER_NAME_TEXT            4569
#define IDC_DRIVER_VERSION_TEXT         4570
#define IDC_DRIVER_ENVIRONMENT_TEXT     4571
#define IDC_DRIVER_LANGUAGE_MONITOR_TEXT 4572
#define IDC_DRIVER_DEFAULT_DATA_TYPE_TEXT 4573
#define IDC_DRIVER_PATH_TEXT            4574
#define IDC_SHARING_DISABLED            4576
#define IDC_DRIVER_PROPERTIES           4577
#define IDD_BROWSE_PRINTER              4578
#define IDD_BROWSE_SELECT_LB            4579
#define IDD_BROWSE_DESCRIPTION_TX       4581
#define IDD_BROWSE_DESCRIPTION          4582
#define IDD_BROWSE_STATUS_TX            4583
#define IDD_BROWSE_STATUS               4584
#define IDD_BROWSE_DOCUMENTS_TX         4585
#define IDD_BROWSE_DOCUMENTS            4586
#define IDD_BROWSE_ERROR                4587
#define IDD_BROWSE_DEFAULTEXPAND        4588
#define IDD_PRINTER_NAME_TX             4589
#define IDD_BROWSE_SELECT_LB_TX         4590
#define IDD_SIMPLE_SHARE_ENABLE_WARNING 4591
#define IDD_FM_TX_FORMS_DESC            4601
#define IDD_FM_LB_FORMS                 4602
#define IDD_FM_EF_NAME                  4603
#define IDD_FM_TX_WIDTH                 4604
#define IDD_FM_EF_WIDTH                 4605
#define IDD_FM_TX_HEIGHT                4606
#define IDD_FM_EF_HEIGHT                4607
#define IDD_FM_TX_LEFT                  4608
#define IDD_FM_EF_LEFT                  4609
#define IDD_FM_TX_RIGHT                 4610
#define IDD_FM_EF_RIGHT                 4611
#define IDD_FM_TX_TOP                   4612
#define IDD_FM_EF_TOP                   4613
#define IDD_FM_TX_BOTTOM                4614
#define IDD_FM_EF_BOTTOM                4615
#define IDD_FM_PB_SAVEFORM              4616
#define IDD_FM_PB_DELFORM               4617
#define IDD_FM_RB_METRIC                4620
#define IDD_FM_RB_ENGLISH               4621
#define IDD_FM_CK_NEW_FORM              4622
#define IDD_FM_TX_NEW_FORM              4623
#define IDD_FM_PAPER_SIZE               4624
#define IDD_FM_PRINTER_AREA             4625
#define IDD_FM_TX_UNITS                 4627
#define IDD_FM_DESC_GBOX                4628
#define IDC_TEXT_PRIORITY               4629
#define IDC_PRIORITY_UPDOWN             4630
#define IDC_PRIORITY                    4631
#define IDC_TEXT_MODEL                  4632
#define IDC_MODEL_NAME                  4633
#define IDC_GBOX_FEATURES               4634
#define IDC_COLOR                       4635
#define IDC_DUPLEX                      4636
#define IDC_STAPLE                      4637
#define IDC_SPEED                       4638
#define IDC_RESOLUTION                  4639
#define IDC_PAPER_SIZE                  4640
#define IDC_PAPER_SIZE_LIST             4641
#define IDC_LOCTREE                     4650
#define IDC_LOCTREE_ERR                 4651
#define IDC_CHOSEN_LOCATION             4652
#define IDC_BROWSELOC_ANIM              4653
#define IDC_STATIC_PRINTER_NAME         4654
#define IDC_CONNECT_TO_NET              4655
#define IDC_LOCATION_HELP               4656
#define IDC_STATIC_PRINTER_URL          4661
#define IDC_BROWSELINK_BTN              4664
#define IDC_KICKOFF_PNP_REFRESH         4665
#define IDC_PHYSICAL_COMPUTER_LOCATION  4666
#define IDC_TEXT_COMPUTER_LOCATION      4668
#define IDC_DETECT_ANIMATE              4670
#define IDC_DETECT_STATUS               4671
#define IDC_TEST_PAGE_QUESTION          4672
#define IDC_TEXT_DETECT_INFO            4673
#define IDC_ICON_DETECT_PRINTER         4674
#define IDC_RESTART_WIZARD              4675
#define IDC_FORMNAME_LABEL              4676
#define IDC_PORTS_INFO_TEXT             4678
#define IDC_IMAGE_PRNPLUG               4679
#define IDC_ICON_INFO                   4680
#define IDC_SHARING_ENABLED_GROUPBOX    4681
#define IDC_LABEL_SHARENAME             4682
#define IDC_SHARING_INFOTEXT            4683
#define IDC_TEXT_USB                    4684
#define IDC_RB_RUN_THE_WIZARD           4685
#define IDC_RB_ENABLE_FILE_SHARING      4686
#define IDD_LISTVIEW                    9000
#define IDD_STATUSBAR                   9001
#define IDD_STATUS                      9002
#define DLG_WIZ_BROWSE                  10003
#define DLG_COMPUTER_LOCATION           10004
#define DLG_WIZ_DETECT                  10005
#define DLG_WIZ_PORT_NEW                10006
#define IDS_STATUS_DELETING             14336
#define IDS_STATUS_PAPER_JAM            14337
#define IDS_STATUS_PAPER_OUT            14338
#define IDS_STATUS_MANUAL_FEED          14339
#define IDS_STATUS_PAPER_PROBLEM        14340
#define IDS_STATUS_OFFLINE              14341
#define IDS_STATUS_IO_ACTIVE            14342
#define IDS_STATUS_BUSY                 14343
#define IDS_STATUS_PRINTING             14344
#define IDS_STATUS_OUTPUT_BIN_FULL      14345
#define IDS_STATUS_NOT_AVAILABLE        14346
#define IDS_STATUS_WAITING              14347
#define IDS_STATUS_PROCESSING           14348
#define IDS_STATUS_INITIALIZING         14349
#define IDS_STATUS_WARMING_UP           14350
#define IDS_STATUS_TONER_LOW            14351
#define IDS_STATUS_NO_TONER             14352
#define IDS_STATUS_PAGE_PUNT            14353
#define IDS_STATUS_USER_INTERVENTION    14354
#define IDS_STATUS_OUT_OF_MEMORY        14355
#define IDS_STATUS_DOOR_OPEN            14356
#define IDS_STATUS_SERVER_UNKNOWN       14357
#define IDS_STATUS_POWER_SAVE           14358
#define IDS_STATUS_PAUSED               14359
#define IDS_STATUS_ERROR                14360
#define IDS_STATUS_SPOOLING             14361
#define IDS_STATUS_PRINTED              14362
#define IDS_STATUS_COMPLETE             14363
#define IDS_APPNAME                     14848
#define IDS_DESC                        14849
#define IDS_WINDOWS                     14850
#define IDS_DELETE_PORTN                14851
#define IDS_PRINTER                     14852
#define IDS_DELETE_PORT                 14853
#define IDS_DELETE_PORT_TITLE           14854
#define IDS_JOB_SIZE                    14855
#define IDS_PRTPROP_UNIQUE_FORMAT       14856
#define IDS_CENTIMETERS                 14858
#define IDS_INCHES                      14859
#define IDS_SB_OPEN                     14864
#define IDS_SB_INITIALIZE               14865
#define IDS_SB_REFRESH                  14866
#define IDS_SB_POLL                     14867
#define IDS_SB_JOBS                     14868
#define IDS_SB_ERROR                    14869
#define IDS_SB_COMMAND                  14870
#define IDS_SB_INVALID_PRINTER_NAME     14871
#define IDS_SB_ACCESS_DENIED            14872
#define IDS_SB_OPEN_ERROR               14873
#define IDS_DRIVER_CHANGE               14874
#define IDS_DRIVER_INSTALLED            14875
#define IDS_SEC_NOACCESS                14931
#define IDS_SEC_PRINT                   14932
#define IDS_SEC_ADMINISTERDOCUMENTS     14933
#define IDS_SEC_ADMINISTER              14934
#define IDS_SEC_AUDIT_PRINT             14935
#define IDS_SEC_AUDIT_ADMINISTER        14936
#define IDS_SEC_AUDIT_DELETE            14937
#define IDS_SEC_CHANGE_PERMISSIONS      14938
#define IDS_SEC_TAKE_OWNERSHIP          14939
#define IDS_PHEAD_BEGIN                 14944
#define IDS_PHEAD_PORT                  14944
#define IDS_PHEAD_DESCRIPTION           14945
#define IDS_PHEAD_PRINTERS              14946
#define IDS_SEPARATOR_PAGE_DESC         14960
#define IDS_SEPARATOR_PAGE_EXT          14961
#define IDS_SEPARATOR_PAGE_ALL          14962
#define IDS_SEPARATOR_PAGE_ALL_EXT      14963
#define IDS_SERVER_PROPERTIES_TITLE     14964
#define IDS_SERVER_SETTINGS_CHANGED     14965
#define IDS_SERVER_SETTINGS_CHANGED_REMOTE     14966
#define IDS_SERVER_PRINTER_NAME_TITLE   14970
#define IDS_SERVER_NO_PRINTER_DEFINED   14971
#define IDS_DRIVER_HEAD_NAME            14980
#define IDS_DRIVER_HEAD_ENVIRONMENT     14981
#define IDS_DRIVER_HEAD_VERSION         14982
#define IDS_DRIVER_HEAD_INSTALLED       14983
#define IDS_STATS_HEAD_NAME             14990
#define IDS_STATS_HEAD_UP_TIME          14991
#define IDS_STATS_HEAD_START_TIME       14992
#define IDS_STATS_HEAD_CURRENT_JOBS     14993
#define IDS_STATS_HEAD_AVERAGE_JOB_SIZE 14994
#define IDS_STATS_HEAD_TOTAL_JOBS       14995
#define IDS_STATS_HEAD_PRINTED_BYTES    14996
#define IDS_TEXT_PRINTERPORT            14997
#define IDS_TEXT_SERIALPORT             14998
#define IDS_TEXT_PRINTTOFILE            14999
#define IDS_ERR_DOC_PROP_TITLE          15104
#define IDS_ERR_DOC_PROP                15105
#define IDS_ERR_SAVE_PRINTER            15107
#define IDS_ERR_GENERIC                 15108
#define IDS_ERR_ACCESS_DENIED           15109
#define IDS_ERR_REMOVE_PRINTER_TITLE    15111
#define IDS_ERR_REMOVE_PRINTER_CONNECTION 15112
#define IDS_ERR_REMOVE_PRINTER          15113
#define IDS_ERR_ADD_PRINTER_TITLE       15114
#define IDS_ERR_INSTALL_DRIVER          15115
#define IDS_ERR_DRIVER_SELECTION        15116
#define IDS_ERR_ERROR_SAVING            15117
#define IDS_ERR_ONLY_ONE_PORT           15119
#define IDS_ERR_NO_PORTS                15120
#define IDS_ERR_CONFIG_PORT             15121
#define IDS_ERR_NO_PRINTER_NAME         15122
#define IDS_ERR_LONG_PRINTER_NAME       15123
#define IDS_ERR_BAD_PRINTER_NAME        15124
#define IDS_ERR_NO_SHARE_NAME           15125
#define IDS_ERR_SECURITY                15126
#define IDS_ERR_PRINTER_PROP_TITLE      15127
#define IDS_ERR_PRINTER_PROP            15128
#define IDS_ERR_NO_DEVICE_OPTIONS       15129
#define IDS_ERR_SET_DEFAULT_PRINTER     15130
#define IDS_ERR_DOC_JOB_PROPERTY_JOB_NA 15131
#define IDS_ERR_DOC_JOB_PROPERTY_TITLE  15132
#define IDS_ERR_DOC_JOB_PROPERTY_MODIFY 15133
#define IDS_ERR_DOC_JOB_PROPERTY_TIME   15134
#define IDS_ADD_PRINTER_TITLE           15135
#define IDS_ERR_PROP_DRIVER_EXISTS      15136
#define IDS_ERR_PRINTER_SEPARATOR_PAGE  15137
#define IDS_ERR_PRINTER_ADD_PORT        15138
#define IDS_ERR_PRINTER_PROCESSORS      15139
#define IDS_ERR_PRINTER_ADD_MONITOR     15140
#define IDS_ERR_SEPARATOR_PAGE_NOEXISTS 15141
#define IDS_ERR_INVALID_PRINTER_STATE   15142
#define IDS_ERR_INVALID_SHARENAME       15143
#define IDS_ERR_DUPLICATE_SHARE         15144
#define IDS_ERR_FORMS_TITLE             15145
#define IDS_ERR_FORMS_COULDNOTADDFORM   15146
#define IDS_ERR_FORMS_COULDNOTDELETEFORM 15147
#define IDS_ERR_FORMS_COULDNOTSETFORM   15148
#define IDS_ERR_FORMS_NAMECONFLICT      15149
#define IDS_ERR_DELETE_PORT             15150
#define IDS_ERR_SERVER_SETTINGS_INVALID_DIR 15151
#define IDS_ERR_SERVER_SETTINGS_SAVE    15152
#define IDS_ERR_MONITOR_TITLE           15153
#define IDS_ERR_PRINTER_PROP_NONE       15154
#define IDS_ERR_DELETE_PORTN            15155
#define IDS_ADD_PRINTER_TITLE_REMOTE    15156
#define IDS_ADD_PRINTER_INTRO_REMOTE    15157
#define IDS_ADD_PRINTER_DESC_REMOTE     15158
#define IDS_ADD_DRIVER_TITLE_REMOTE     15159
#define IDS_ADD_DRIVER_INTRO_REMOTE     15160
#define IDS_TP_TESTPAGENAME             15165
#define IDS_TP_TIMESNEWROMAN            15166
#define IDS_TP_HEADER                   15167
#define IDS_TP_CONGRATULATIONS          15168
#define IDS_TP_PRINTERISINSTALLED       15169
#define IDS_TP_FONTNAMEINFOTEXT         15170
#define IDS_TP_PRINTERNAME              15171
#define IDS_TP_PORTNAME                 15172
#define IDS_TP_PRINTERMODEL             15173
#define IDS_TP_DRV_NAME                 15174
#define IDS_TP_DATA_FILE                15175
#define IDS_TP_CONFIG_FILE              15176
#define IDS_TP_DRV_VERSION              15177
#define IDS_TP_COLOR                    15178
#define IDS_TP_MONO                     15179
#define IDS_TP_DEPENDENTLIST            15180
#define IDS_TP_VERSIONANDGPC            15181
#define IDS_TP_VERSIONONLY              15182
#define IDS_TP_GPCONLY                  15183
#define IDS_TP_NOVERSIONINFO            15184
#define IDS_TP_DATATYPE                 15185
#define IDS_TP_TESTPAGECAPTION          15187
#define IDS_TP_TESTPAGEEND              15189
#define IDS_TP_SHARE_NAME               15191
#define IDS_TP_LOCATION                 15192
#define IDS_TP_COMMENT                  15193
#define IDS_TP_ENVIRONMENT              15194
#define IDS_TP_MONITOR                  15196
#define IDS_TP_DEFAULT_DATATYPE         15197
#define IDS_ERR_MONITOR_INSTALL         15198
#define IDS_ERR_SHARING_EXTRA_DRIVER_FAILED 15201
#define IDS_ERR_PLATFORM_VERSION        15202
#define IDS_ERR_ADD_DEFAULT_DRIVER      15203
#define IDS_ENVIRONMENT_ALPHA           15204
#define IDS_ENVIRONMENT_X86             15205
#define IDS_ENVIRONMENT_MIPS            15206
#define IDS_ENVIRONMENT_PPC             15207
#define IDS_ENVIRONMENT_WIN95           15208
#define IDS_ERR_SERVER_SETTINGS_NOT_AVAILABLE 15209
#define IDS_TYPE_REMOTE_SERVER          15210
#define IDS_ERR_MAKE_CONNECTION         15211
#define IDS_ERR_INSTALLING_EXTRA_DRIVERS 15212
#define IDS_ERR_ADD_PORT                15213
#define IDS_ERR_TESTPAGE                15215
#define IDS_ERR_NO_DEVICE_SEC_OPTIONS   15216
#define IDS_ERR_CHANGE_DRIVER           15217
#define IDS_ERR_PRINTER_NAME_CONFLICT   15218
#define IDS_ERR_PRINTER_NOT_FOUND_TITLE 15219
#define IDS_ERR_PRINTER_NOT_FOUND       15220
#define IDS_DSPTEMPLATE_WITH_ON         15221
#define IDS_TP_MACHINENAME              15222
#define IDS_TEXT_PROPERTIES             15223
#define IDS_TEXT_CLOSE                  15224
#define IDS_ERR_SERVER_PROP_CANNOT_VIEW 15225
#define IDS_ERR_SHARE_NAME_NOT_DOS      15226
#define IDS_DEFAULT_SHARE               15227
#define IDS_WARN_TRAILINGSPACES_IN_PRINTERNAME 15228
#define IDS_ERR_NO_DRIVER_INSTALLED     15229
#define IDS_ERR_INVALID_CHAR_SHARENAME  15230
#define IDS_ERR_PORT_SEL_CHANGE         15231
#define IDS_ERR_NO_DRIVER_NO_DEVICE_OPTIONS 15232
#define IDS_ERR_ADD_PRINTER_WINDOW      15233
#define IDS_STATUS_RESTART              15234
#define IDS_ERR_NOT_IMPLEMENTED         15235
#define IDS_ERR_DUPLICATED_DS_ITEM      15236
#define IDS_ENVIRONMENT_IA64            15237
#define IDS_DSPTEMPLATE_NETCRAWLER      15238
#define IDS_DEFAULT_PORT                15243
#define IDS_ERR_ADD_PRINTER_CONNECTION  15245
#define IDS_ERR_ADD_ONLY_PRINTERS       15246
#define IDS_DRIVER_WIZ_TITLE            15248
#define IDS_ERR_ATLEAST_ONE_VERSION     15249
#define IDS_SERVER_SETTINGS_TITLE       15250
#define IDS_ERR_ALL_DRIVER_NOT_INSTALLED 15251
#define IDS_DRIVER_DETAILS_TITLE        15252
#define IDS_DRIVER_ADD_NEEDS_APPLY      15253
#define IDS_ERR_DRIVERS_NOT_REFRESHED   15254
#define IDS_ERR_WANT_TO_EXIT            15255
#define IDS_DRIVER_UPDATE_NEEDS_APPLY   15257
#define IDS_ERR_ALL_DRIVER_NOT_REMOVED  15258
#define IDS_DRIVER_FILE_HEAD_NAME       15300
#define IDS_DRIVER_FILE_HEAD_FILE       15301
#define IDS_DRIVER_HELP_FILE            15302
#define IDS_DRIVER_CONFIG_FILE          15303
#define IDS_DRIVER_DATA_FILE            15304
#define IDS_DRIVER_PATH                 15305
#define IDS_DRIVER_DEPENDENT_FILE       15306
#define IDS_ERR_ADD_PRINTER_INF_INSTALL 15307
#define IDS_CONTEXT_WEB_OPEN            15308
#define IDS_CONTEXT_WEB_OPEN_CMD_STRING 15309
#define IDS_ERR_WEB_TITLE               15310
#define IDS_ERR_PRINTER_WEBVIEW_SUPPORT 15311
#define IDS_CONNECTING_TO_PRINTER       15312
#define IDS_ERR_PRINTER_WEBVIEW_SHARE   15313
#define IDS_ERR_ALL_DRIVER_NOT_UPDATED  15314
#define IDS_APW_SETUP_PAGE_INSTRUCT     15315
#define IDS_APDW_SETUP_PAGE_INSTRUCT    15316
#define IDS_ERR_ADD_MACHINE_CONNECTION  15317
#define IDS_ERR_DELETE_MACHINE_CONNECTION 15318
#define IDS_ERR_ENUM_MACHINE_CONNECTION 15319
#define IDS_ERR_RUNDLL_MACHINE_CONNECTION 15320
#define IDS_WORK_OFFLINE                15321
#define IDS_ERR_WEB_SERVICE_NOT_STARTED 15322
#define IDS_ERR_REMOVE_DS_PRINTER       15323
#define IDS_ERR_DELETE_PRINTER_DRIVER   15324
#define IDS_ERR_DELETE_PRINTER_DRIVERN  15325
#define IDS_ERR_UPDATE_PRINTER_DRIVER   15326
#define IDS_ERR_UPDATE_PRINTER_DRIVERN  15327
#define IDS_ERR_PORT_NOT_IMPLEMENTED    15328
#define IDS_CONFIGURE_PORT_TITLE        15329
#define IDS_DS_SEARCH_DIR_NAME          15330
#define IDS_ERR_MISSING_PRINTER_NAME    15333
#define IDS_ERR_LIST_IN_DIRECTORY       15334
#define IDS_ERR_ADD_DRV_ERROR           15335
#define IDS_ERR_PORT_DOES_NOT_EXIST     15336
#define IDS_DRIVER_NOTINSTALLED         15337
#define IDS_ADDITIONAL_DRIVER_TITLE     15338
#define IDS_ERR_DRIVER_NOT_INSTALLED    15339
#define IDS_WIZ_TITLE                   15340
#define IDS_WIZ_SUBTITLE                15341
#define IDS_ERR_RUNDLL_INVALID_COMMAND  15342
#define IDS_ERR_MISSING_PRINTER_URL     15344
#define IDS_LARGEFONTNAME               15345
#define IDS_LARGEFONTSIZE               15346
#define IDS_WIZ_PORT_TITLE              15347
#define IDS_WIZ_PORT_SUBTITLE           15348
#define IDS_WIZ_DRIVEREXISTS_TITLE      15349
#define IDS_WIZ_DRIVEREXISTS_SUBTITLE   15350
#define IDS_WIZ_NAME_TITLE              15351
#define IDS_WIZ_NAME_SUBTITLE           15352
#define IDS_WIZ_SHARE_TITLE             15353
#define IDS_WIZ_SHARE_SUBTITLE          15354
#define IDS_WIZ_LOCATE_TITLE            15357
#define IDS_WIZ_LOCATE_SUBTITLE         15358
#define IDS_WIZ_ARCH_TITLE              15359
#define IDS_WIZ_ARCH_SUBTITLE           15360
#define IDS_WIZ_TEST_PAGE_TITLE         15361
#define IDS_WIZ_TEST_PAGE_SUBTITLE      15362
#define IDS_WIZ_TYPE_TITLE              15363
#define IDS_WIZ_TYPE_SUBTITLE           15364
#define IDS_WIZ_NET_TITLE               15365
#define IDS_WIZ_NET_SUBTITLE            15366
#define IDS_DS_PENDING_TEXT             15367
#define IDS_DRIVER_INTRO_TEXT           15368
#define IDS_ERR_DOCUMENT_PROP           15369
#define IDS_NOT_SHARED                  15370
#define IDS_YES                         15371
#define IDS_NO                          15372
#define IDS_WIZ_BROWSE_TITLE            15373
#define IDS_WIZ_BROWSE_SUBTITLE         15374
#define IDS_COMPLETING_TEXT             15375
#define IDS_TP_TIMEDATE                 15376
#define IDS_SEPARATOR_PAGE_TITLE        15377
#define IDS_WIZ_COMMENT_TITLE           15378
#define IDS_WIZ_COMMENT_SUBTITLE        15379
#define IDS_PRINTER_PREFERENCES         15380
#define IDS_ERR_ADDITIONAL_DRIVERS      15381
#define IDS_DOCUMENT_DEFAULT_TITLE_FORMAT 15382
#define IDS_ERR_WITH_HELP1              15383
#define IDS_COLOR                       15384
#define IDS_DUPLEX                      15385
#define IDS_STAPLE                      15386
#define IDS_SPEED                       15387
#define IDS_RESOLUTION                  15388
#define IDS_SPEED_UNITS                 15389
#define IDS_RESOLUTION_UNITS            15390
#define IDS_FEATURE_UNKNOWN             15391
#define IDS_TP_HELP_FILE                15392
#define IDS_PRINTER_PROPERTIES_TITLE_FORMAT 15394
#define IDS_PRINTER_SUREPURGE           15395
#define IDS_PRINTERS_TITLE              15396
#define IDS_SERVER_PROPERTIES_CHANGESPOOLFOLDER_WARN 15397
#define IDS_TEXT_DETECT_SUCCESS         15398
#define IDS_TEXT_USB                    15399
#define IDS_TEXT_DETECT_FAILURE         15400
#define IDS_WIZ_DETECT_TITLE            15401
#define IDS_WIZ_DETECT_SUBTITLE         15402
#define IDS_ERRMAP_SPOOL_FILE_NOT_FOUND 15403
#define IDS_ERRMAP_SPL_NO_STARTDOC      15404
#define IDS_ERRMAP_NO_SPOOL_SPACE       15405
#define IDS_ERRMAP_UNKNOWN_PRINTPROCESSOR 15406
#define IDS_ERRMAP_RPC_S_SERVER_UNAVAILABLE 15407
#define IDS_ERRMAP_DISK_FULL            15408
#define IDS_ERRMAP_NETWORK_ACCESS_DENIED 15409
#define IDS_ERRMAP_NET_WRITE_FAULT      15410
#define IDS_ERRMAP_NOT_SUPPORTED        15411
#define IDS_ERRMAP_OUTOFMEMORY          15412
#define IDS_ERR_INSTALLPRINTER          15413
#define IDS_ERRMAP_FILE_CORRUPT         15414
#define IDS_ERR_PORT_ALREADY_EXISTS     15415
#define IDS_ERR_LOCATION_PROP_TITLE     15416
#define IDS_BAD_KMDRIVER                15417
#define IDS_PRINT_NOTCONNECTED          15418
#define IDS_NODRIVERUI_BAD_KMDRIVER     15419
#define IDS_INCOMPATIBLEDRIVER          15420
#define IDS_FRIENDLY_ACCESSDENIED       15421
#define IDS_TOOLTIP_TRAY                15422
#define IDS_BALLOON_TITLE_JOB_FAILED    15423
#define IDS_BALLOON_TITLE_JOB_PRINTED   15424
#define IDS_BALLOON_TEXT_JOB_PRINTED    15425
#define IDS_BALLOON_TEXT_JOB_FAILED     15426
#define IDS_BALLOON_TEXT_JOB_PRINTED_NOPAGES 15427
#define IDS_TEXT_ELLIPSES               15428
#define IDS_TRAY_TEXT_ERROR             15429
#define IDS_FORMS_INVALIDNUMBER         15430
#define IDS_ERRMAP_PRINTER_ALREADY_EXISTS 15431
#define IDS_QUEUE_FORWARD_SLASH         15432
#define IDS_QUEUE_SURE_CANCEL           15433
#define IDS_ERROR_INVALID_ARG           15434
#define IDS_ERROR_DRIVER_DOESNT_EXISTS  15435
#define IDS_TEXT_RECOMMENDED            15436
#define IDS_BALLOON_TITLE_JOB_FAILED_OOP 15437
#define IDS_TEXT_NA                     15438
#define IDS_APDW_SETUP_PAGE_TITLE       15439
#define IDS_APW_SETUP_PAGE_TITLE        15440
#define IDS_APW_TEXT_CONNECT_TO_THIS_PRINTER 15441
#define IDS_CREDUI_CANNOT_DELETE_CREDENTIALS 15442
#define IDS_CREDUI_QUESTION_OWERWRITE_CREDENTIALS 15443
#define IDS_CREDUI_QUESTION_INSUFFICIENT_CREDENTIALS 15444
#define IDS_PRINTER_DRIVER_BLOCKED      15445
#define IDS_TEXT_SHARING_NOT_ENABLED    15446
#define IDC_ENABLE_SHARING              15447
#define IDS_ARCH_INTEL                  16040
#define IDS_ARCH_MIPS                   16041
#define IDS_ARCH_ALPHA                  16042
#define IDS_ARCH_POWERPC                16043
#define IDS_ARCH_UNKNOWN                16044
#define IDS_ARCH_IA64                   16046
#define IDS_VERSION_WINDOWS_95          16050
#define IDS_VERSION_NT_31               16051
#define IDS_VERSION_35X                 16052
#define IDS_VERSION_351                 16053
#define IDS_VERSION_40                  16054
#define IDS_VERSION_40_50               16055
#define IDS_VERSION_50                  16056
#define IDS_VERSION_51                  16057
#define IDS_VERSION_WINDOWS_ME          16058
#define IDS_VERSION_50_51               16059
#define IDS_RUNDLL_SET_PAUSE            16501
#define IDS_RUNDLL_SET_RESUME           16502
#define IDS_RUNDLL_SET_PURGE            16503
#define IDS_RUNDLL_SET_QUEUED           16504
#define IDS_RUNDLL_SET_DIRECT           16505
#define IDS_RUNDLL_SET_DEFAULT          16506
#define IDS_RUNDLL_SET_SHARED           16507
#define IDS_RUNDLL_SET_HIDDEN           16508
#define IDS_RUNDLL_SET_NETWORK          16509
#define IDS_RUNDLL_SET_LOCAL            16510
#define IDS_RUNDLL_SET_ENABLEDEVQ       16511
#define IDS_RUNDLL_SET_KEEPPRINTEDJOBS  16512
#define IDS_RUNDLL_SET_DOCOMPLETEFIRST  16513
#define IDS_RUNDLL_SET_WORKOFFLINE      16514
#define IDS_RUNDLL_SET_ENABLEBIDI       16515
#define IDS_RUNDLL_SET_RAWONLY          16516
#define IDS_RUNDLL_SET_PUBLISHED        16517
#define IDS_RUNDLL_SET_PRINTERNAME      16518
#define IDS_RUNDLL_SET_SHARENAME        16519
#define IDS_RUNDLL_SET_PORTNAME         16520
#define IDS_RUNDLL_SET_DRIVERNAME       16521
#define IDS_RUNDLL_SET_COMMENT          16522
#define IDS_RUNDLL_SET_LOCATION         16523
#define IDS_RUNDLL_SET_SEPFILE          16524
#define IDS_RUNDLL_SET_PRINTPROCESSOR   16525
#define IDS_RUNDLL_SET_DATATYPE         16526
#define IDS_RUNDLL_SET_PARAMETERS       16527
#define IDS_RUNDLL_SET_ATTRIBUTES       16528
#define IDS_RUNDLL_SET_PRIORITY         16529
#define IDS_RUNDLL_SET_DEFAULTPRIORITY  16530
#define IDS_RUNDLL_SET_STARTTIME        16531
#define IDS_RUNDLL_SET_UNTILTIME        16532
#define IDS_RUNDLL_SET_STATUS           16533
#define IDS_RUNDLL_TITLE                16900
#define IDS_RUNDLL_ERROR                16901
#define IDS_RUNDLL_USAGE                16902
#define IDS_RUNDLL_SET_ATTRIBUTE_TITLE  16903
#define IDS_RUNDLL_SET_ATTRIBUTE_USAGE  16904
#define IDS_RUNDLL_STRING               16905
#define IDS_RUNDLL_INTEGER              16906
#define IDS_RUNDLL_START                16907
#define IDS_RUNDLL_END                  16908
#define IDS_RUNDLL_SEP                  16909
#define IDS_RUNDLL_FORMAT               16910
#define IDS_RUNDLL_HELP1                16911
#define IDS_RUNDLL_HELP2                16912
#define IDS_RUNDLL_DISPLAY_FORMAT1      16913
#define IDS_RUNDLL_DISPLAY_FORMAT2      16914
#define IDS_RUNDLL_DISPLAY_TITLE        16915
#define IDS_RUNDLL_OPTION0              17010
#define IDS_RUNDLL_OPTION1              17011
#define IDS_RUNDLL_OPTION2              17012
#define IDS_RUNDLL_OPTION3              17013
#define IDS_RUNDLL_OPTION4              17014
#define IDS_RUNDLL_OPTION5              17015
#define IDS_RUNDLL_OPTION6              17016
#define IDS_RUNDLL_OPTION7              17017
#define IDS_RUNDLL_OPTION8              17018
#define IDS_RUNDLL_OPTION9              17019
#define IDS_RUNDLL_OPTION10             17020
#define IDS_RUNDLL_OPTION11             17021
#define IDS_RUNDLL_OPTION12             17022
#define IDS_RUNDLL_OPTION13             17023
#define IDS_RUNDLL_OPTION14             17024
#define IDS_RUNDLL_OPTION15             17025
#define IDS_RUNDLL_OPTION16             17026
#define IDS_RUNDLL_OPTION17             17027
#define IDS_RUNDLL_OPTION18             17028
#define IDS_RUNDLL_OPTION19             17029
#define IDS_RUNDLL_OPTION20             17030
#define IDS_RUNDLL_OPTION21             17031
#define IDS_RUNDLL_OPTION22             17032
#define IDS_RUNDLL_OPTION23             17033
#define IDS_RUNDLL_OPTION24             17034
#define IDS_RUNDLL_OPTION25             17035
#define IDS_RUNDLL_OPTION26             17036
#define IDS_RUNDLL_OPTION27             17037
#define IDS_RUNDLL_OPTION28             17038
#define IDS_RUNDLL_OPTION29             17039
#define IDS_RUNDLL_OPTION30             17040
#define IDS_RUNDLL_OPTION31             17041
#define IDS_RUNDLL_OPTION32             17042
#define IDS_RUNDLL_OPTION33             17043
#define IDS_RUNDLL_OPTION34             17044
#define IDS_RUNDLL_OPTION35             17045
#define IDS_RUNDLL_OPTION36             17046
#define IDS_RUNDLL_OPTION37             17047
#define IDS_RUNDLL_OPTION38             17048
#define IDS_RUNDLL_OPTION39             17049
#define IDS_RUNDLL_OPTION40             17050
#define IDS_RUNDLL_OPTION41             17051
#define IDS_RUNDLL_OPTION42             17052
#define IDS_RUNDLL_OPTION43             17053
#define IDS_RUNDLL_OPTION44             17054
#define IDS_RUNDLL_OPTION45             17055
#define IDS_RUNDLL_OPTION46             17056
#define IDS_RUNDLL_OPTION47             17057
#define IDS_RUNDLL_OPTION_END           17057
#define IDS_RUNDLL_EXAMPLE0             17100
#define IDS_RUNDLL_EXAMPLE1             17101
#define IDS_RUNDLL_EXAMPLE2             17102
#define IDS_RUNDLL_EXAMPLE3             17103
#define IDS_RUNDLL_EXAMPLE4             17104
#define IDS_RUNDLL_EXAMPLE5             17105
#define IDS_RUNDLL_EXAMPLE6             17106
#define IDS_RUNDLL_EXAMPLE7             17107
#define IDS_RUNDLL_EXAMPLE8             17108
#define IDS_RUNDLL_EXAMPLE9             17109
#define IDS_RUNDLL_EXAMPLE10            17110
#define IDS_RUNDLL_EXAMPLE11            17111
#define IDS_RUNDLL_EXAMPLE12            17112
#define IDS_RUNDLL_EXAMPLE13            17113
#define IDS_RUNDLL_EXAMPLE14            17114
#define IDS_RUNDLL_EXAMPLE15            17115
#define IDS_RUNDLL_EXAMPLE16            17116
#define IDS_RUNDLL_EXAMPLE17            17117
#define IDS_RUNDLL_EXAMPLE18            17118
#define IDS_RUNDLL_EXAMPLE19            17119
#define IDS_RUNDLL_EXAMPLE20            17120
#define IDS_RUNDLL_EXAMPLE21            17121
#define IDS_RUNDLL_EXAMPLE22            17122
#define IDS_RUNDLL_EXAMPLE23            17123
#define IDS_RUNDLL_EXAMPLE24            17124
#define IDS_RUNDLL_EXAMPLE25            17125
#define IDS_RUNDLL_EXAMPLE_END          17125
#define IDS_RUNDLL_SET_EXAMPLE1         17301
#define IDS_RUNDLL_SET_EXAMPLE2         17302
#define IDS_RUNDLL_SET_EXAMPLE3         17303
#define IDS_RUNDLL_SET_EXAMPLE4         17304
#define IDS_RUNDLL_SET_EXAMPLE5         17305
#define IDS_RUNDLL_SET_EXAMPLE6         17306
#define IDS_RUNDLL_SET_EXAMPLE7         17307
#define IDS_RUNDLL_SET_EXAMPLE8         17308
#define IDS_RUNDLL_SET_EXAMPLE_END      17308
#define IDS_CONNECTTOPRINTER            18000
#define IDS_COULDNOTCONNECTTOPRINTER    18001
#define IDS_PAUSED                      18002
#define IDS_ERROR                       18003
#define IDS_PENDING_DELETION            18004
#define IDS_READY                       18005
#define IDS_INSUFFPRIV_CREATEPRINTER    18007
#define IDS_MUSTSUPPLYVALIDNAME         18008
#define IDS_INSTALLDRIVER               18009
#define IDS_ERRORRUNNINGSPLSETUP        18010
#define IDS_CANNOTOPENPRINTER           18011
#define IDS_CONFIRMINSTALLDRIVER        18012
#define IDS_ERROR_UNKNOWN_DRIVER        18013
#define IDS_WORKING                     18014
#define IDS_PRINTER_IS_LOCAL            18015
#define IDS_CONFIRMINSTALLKNOWNDRIVER   18016
#define IDS_PROMPTFORINF                18017
#define IDS_COULDNOTSTARTBROWSETHREAD   18019
#define IDS_CONFIRMUNKNOWNDRIVER        18020
#define IDS_APW_SETUP_PAGE_INSTRUCT_HYDRA 18021
#define IDS_LOCTREEROOT                 18022
#define IDS_CONFIRMKNOWNDRIVER          18023
#define IDS_NO_LOCATION                 18024
#define IDS_PRINTER_PREFERENCES_DEFAULT 18026
#define IDS_APW_SETUP_PAGE_SUBTITLE     18027
#define IDS_APDW_SETUP_PAGE_SUBTITLE    18028
#define IDS_RESTRICTIONS                18029
#define IDM_DRAGDROP_PRINT              18029
#define IDS_RESTRICTIONSTITLE           18030
#define IDM_DRAGDROP_CANCEL             18030
#define IDM_DRAGDROP_MOVE               18031
#define IDM_TRAYNOTIFY_DEFAULT          18033
#define IDM_TRAYNOTIFY_PRNFOLDER        18034
#define IDM_TRAYNOTIFY_REFRESH          18035
#define IDM_HELP_TROUBLESHOOTER         18036
#define IDS_COULDNOTCONNECTTOPRINTER_BLOCKED_HELP 18037
#define IDS_NULLSTR                     18038
#define IDS_INSUFFICENT_PRIVILLEGE      18039
#define IDC_NONE                        -1

#ifndef IDC_STATIC                      
#define IDC_STATIC                      -1
#endif

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         18040
#define _APS_NEXT_CONTROL_VALUE         4684
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\prhlpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       prhlpids.h
//
//--------------------------------------------------------------------------

// This file was not created with DBHE.  I cut and pasted material from a "dummy" file so I could set up this file in a way that helps me find information.

#define IDH_NOHELP     ((DWORD) -1)       // Disables Help for a control (for help compiles)
//#define IDH_NOHELP   (DWORD(-1))        //for UI builds?


// Printer Properties dialog/General tab // "General" Dialog Box (#507)

#define IDH_PPGENL_PRINTER_NAME           1000       // General: "Printer name" (Static) (Edit) (ctrl id 3000, 3001)
#define IDH_PPGENL_LOCATION               1010       // General: "" (Edit), "&Location:" (Static) (ctrl id 1050, 3006)
#define IDH_PPGENL_LOC_BROWSE             1015       // General: "&Browse..." (Button) (ctrl id 3015)
#define IDH_PPGENL_COMMENT                1020       // General: "" (Edit), "&Comment:" (Static) (ctrl id 1049, 3005)
#define IDH_PPGENL_PRINT_TEST_PAGE        1110       // General: "Print &Test Page" (Button) (ctrl id 3007)
#define IDH_PPGENL_PREFERENCES_PERSONAL   1100       // General: "Settin&gs..." (Button) (ctrl id 1031)
#define IDH_PPGENL_COLOR                  1040       // General: "Color:" (Static) (ctrl id 4635)
#define IDH_PPGENL_DUPLEX                 1050       // General: "Double-sided:" (Static) (ctrl id 4636)
#define IDH_PPGENL_MAXRESOLUTION          1080       // General: "Maximum resolution:" (Static) (ctrl id 4639)
#define IDH_PPGENL_MODEL                  1030       // General: "M&odel:" (Static) (Edit) (ctrl id 4632, 4633)
#define IDH_PPGENL_PAPERSIZE              1090       // General: "Paper sizes:" (Static) (Edit)(ctrl id 4640, 4641)
#define IDH_PPGENL_SPEED                  1070       // General: "Speed:" (Static) (ctrl id 4638)
#define IDH_PPGENL_STAPLE                 1060       // General: "Staple:" (Static) (ctrl id 4637)

// "Print Processor" Dialog Box (#513)

#define IDH_PPADV_PRINT_PROCESSOR_LIST            1520       // Print Processor: "Print processor:" (Static) (ListBox) (ctrl id 4504, 4500)
#define IDH_PPADV_PRINT_PROCESSOR_DATATYPE_LIST   1530       // Print Processor: "" (ListBox), "Default datatype:" (Static) (ctrl id 4501, 4503)


// "Separator Page" Dialog Box (#512)

#define IDH_PPADV_SEPARATOR_PAGE_BROWSE   1510       // Separator Page: "&Browse..." (Button) (ctrl id 4400)
#define IDH_PPADV_SEPARATOR_PAGE_NAME     1500       // Separator Page: "" (Edit) (ctrl id 4401)
#define IDH_PPADV_SEPARATOR_PAGE_NAME     1500       // Separator Page: "Separator page:" (Static) (ctrl id 4403)


// Printer Properties dialog/Ports tab // "Ports" Dialog Box (#508) (See #518--much is the same)

#define IDH_PPGENL_PRINTER_NAME          1000       // Ports: "Printer name" (Static) (ctrl id 3000, 3001)
#define IDH_PORTS_LIST                   1200       // Ports: "" (SysListView32) (ctrl id 3100)
#define IDH_PORTS_ADD                    1210       // Ports: "Add Por&t..." (Button) (ctrl id 3101)
#define IDH_PP_PORTS_ENABLE_POOLING      1250       // Ports: "E&nable printer pooling" (Button) (ctrl id 1052)
#define IDH_PORTS_DELETE                 1220       // Ports: "&Delete Port" (Button) (ctrl id 3102)
#define IDH_PORTS_CONFIGURE              1230       // Ports: "&Configure Port..." (Button) (ctrl id 3103)
#define IDH_PORTS_ENABLE_BIDIRECTIONAL   1240       // Ports: "&Enable bidirectional support" (Button) (ctrl id 3105)


// "Printer Ports" Dialog Box (#511)

#define IDH_PRINTERPORTS_NEW_PORT_MONITOR   1570       // Printer Ports: "&New Port Monitor..." (Button) (ListBox) (ctrl id 4305, 4303)
#define IDH_PRINTERPORTS_AVAILABLE_LIST     1560       // Printer Ports: "&Available printer ports:" (Static) (ctrl id 4307)
#define IDH_PRINTERPORTS_NEW_PORT           1580       // Printer Ports: "New &Port..." (Button) (ctrl id 4308)


// Printer Properties dialog/Advanced tab // "Advanced" Dialog Box (#509)  (see also #506, General)

#define IDH_PPADV_START_PRINTING_IMMEDIATELY       1390       // Scheduling: "Start printing &immediately" (Button) (ctrl id 3223)
#define IDH_PPADV_ALWAYS                           1300       // Scheduling: "Al&ways" (Button) (ctrl id 3200)
#define IDH_PPADV_HOLD_MISMATCHED                  1410       // Scheduling: "&Hold mismatched documents" (Button) (ctrl id 3224)
#define IDH_PPADV_FROM_TO                          1310       // Scheduling: "&From" (Button) and Scheduling: "To" (Static) (ctrl id 3201, 3014)
#define IDH_PPADV_PRINT_SPOOLED_DOCS_FIRST         1420       // Scheduling: "P&rint spooled documents first" (Button) (ctrl id 3225)
#define IDH_PPADV_KEEP_PRINTED_JOBS                1430       // Scheduling: "&Keep documents after they have printed" (Button) (ctrl id 3226)
#define IDH_PPADV_FROM_TO_START                    1320       // Scheduling: "" (SysDateTimePick32) (ctrl id 4507)
#define IDH_PPADV_CURRENT_PRIORITY                 1340       // Scheduling: "10" (Static) (ctrl id 4312, 3218=old?) (ctrl id 4629, 4631, 4630)
#define IDH_PPADV_FROM_TO_END                      1330       // Scheduling: "" (SysDateTimePick32) (ctrl id 4508)
#define IDH_PPADV_SPOOL_PRINT_DOCS                 1370       // Scheduling: "&Spool print documents so program finishes printing faster" (Button) (ctrl id 3220)
#define IDH_PPADV_PRINT_DIRECTLY                   1400       // Scheduling: "Print &directly to the printer" (Button) (ctrl id 3221)
#define IDH_PPADV_SPOOL_ALL                        1380       // Scheduling: "S&tart printing after last page is spooled" (Button) (ctrl id 3222)
#define IDH_PPADV_NEW_DRIVER                       1360       // General: "&New Driver..." (Button) (ctrl id 3003)
#define IDH_PPADV_SEPARATOR_PAGE                   1470       // General: "&Separator Page..." (Button) (ctrl id 3008)
#define IDH_PPADV_DRIVER                           1350       // General: "Dr&iver:" (Static) (ComboBox) (ctrl id 1051, 1045)
#define IDH_PPADV_ADVPRINT_FEATURES                1440       // Advanced: "&Enable advanced printing features" (Button)
#define IDH_PPADV_PRINTING_DEFAULTS                1450       // General: "Setti&ngs..." (Button) (ctrl id 4406, 1145)
#define IDH_PPADV_PRINT_PROCESSOR                  1460       // General: "P&rint Processor..." (Button) (ctrl id 3009)

//#define IDH_PPADV_PRINT_PROCESSOR_ALWAYS_SPOOL   1140       // Print Processor: "&Always spool RAW datatype" (Button) (ctrl id 1053) (gone now?)


// Printer Properties dialog/Sharing tab // "Sharing" Dialog Box (#510)

#define IDH_PPSHARED_NOT                  1150       // Sharing: "N&ot shared" (Button) (ctrl id 3227, 4576)
#define IDH_PPSHARED_AS                   1160       // Sharing: "&Shared as:" (Button) (ctrl id 3228)
//#define IDH_PPGENL_PRINTER_NAME         1000       // Uses help from General dialog #507 (ctrl id 3000, 3001)
#define IDH_PPSHARED_NAME                 1170       // Sharing: "" (Edit) (ctrl id 3302)
#define IDH_PPSHARED_ADDITIONAL_DRIVERS   1190       // Sharing: "A&dditional Drivers..." (Button) (ctrl id 1140)
#define IDH_PPSHARED_LIST_IN_DIRECTORY    1180       // Sharing: (ctrl id 1064)



// "Additional Drivers" Dialog Box (#504)

#define IDH_PPSHARED_ADDITIONAL_DRIVERS_LIST   1425       // Additional Drivers: "List1" (SysListView32) (ctrl id 1134)


// Printer Document Properties dialog/General tab // "General" Dialog Box (#506)

#define IDH_DPGENL_JOB_SIZE              1910       // General: "" (Static) (ctrl id 3558, 4219)
#define IDH_DPGENL_JOB_TITLE             1900       // General: "" (Static) (ctrl id 4220)
#define IDH_DPGENL_JOB_SUBMITTED         1960       // General: "" (Static) (ctrl id 3563, 4222)
#define IDH_DPGENL_JOB_PROCESSOR         1940       // General: "" (Static) (ctrl id 3561, 4223)
#define IDH_DPGENL_JOB_DATATYPE          1930       // General: "" (Static) (ctrl id 3560, 4224)
#define IDH_DPGENL_JOB_START_END         2000       // General: "Only &from" (Button) (ctrl id 4201, 3568)
#define IDH_DPGENL_JOB_PAGES             1920       // General: "" (Static) (ctrl id 3559, 4225)
#define IDH_DPGENL_JOB_OWNER             1950       // General: "" (Static) (ctrl id 3562, 4226)
//#define IDH_PPADV_CURRENT_PRIORITY     1340       // Uses help from Advanced dialog #509 (ctrl id on THIS tab 3567, 4229)
#define IDH_DPGENL_JOB_NOTIFY            1970       // General: "" (Edit) (ctrl id 3564, 4230)
#define IDH_DPGENL_JOB_START_END_FROM    2010       // General: "" (SysDateTimePick32) (ctrl id 4509)
#define IDH_DPGENL_JOB_PRIORITY_SLIDER   1980       // General: "TracBar1" (msctls_trackbar32) (ctrl id 4231, 3565, 3566)
#define IDH_DPGENL_JOB_START_END_TO      2020       // General: "" (SysDateTimePick32) (ctrl id 4510)
#define IDH_DPGENL_JOB_ALWAYS            1990       // General: "No time &restriction" (Button) (ctrl id 4232)


// Print Server Properties dialog/Forms tab // "Forms" Dialog Box (#516)

#define IDH_PSFORMS_WIDTH          1670       // Forms: "&Width:" (Static), (Edit) (ctrl id 4604, 4605)
#define IDH_PSFORMS_HEIGHT         1680       // Forms: "&Height:" (Static), (Edit) (ctrl id 4606, 4607)
#define IDH_PSFORMS_LEFT           1690       // Forms: "&Left:" (Static), (Edit) (ctrl id 4608, 4609)
#define IDH_PSFORMS_RIGHT          1700       // Forms: "&Right:" (Static), (Edit) (ctrl id 4610, 4611)
#define IDH_PSFORMS_TOP            1710       // Forms: "&Top:" (Static), (Edit) (ctrl id 4612, 4613)
#define IDH_PSFORMS_BOTTOM         1720       // Forms: "&Bottom:" (Static), (Edit) (ctrl id 4614, 4615)
#define IDH_PSFORMS_SAVEFORM       1730       // Forms: "&Save Form" (Button) (ctrl id 4616)
#define IDH_PSFORMS_DELETE         1620       // Forms: "&Delete" (Button) (ctrl id 4617)
#define IDH_PSFORMS_UNIT_METRIC    1650       // Forms: "&Metric" (Button) (ctrl id 4620)
#define IDH_PSFORMS_UNIT_ENGLISH   1660       // Forms: "&English" (Button) (ctrl id 4621)
#define IDH_PSFORMS_CREATE_NEW     1640       // Forms: "&Create a New Form" (Button) (ctrl id 4622)
#define IDH_PSFORMS_SERVER_NAME    1600       // Forms: "Forms on:" (Static), "Static" (Static) (ctrl id 1166)
#define IDH_PSFORMS_LIST           1610       // Forms: "" (ListBox) (ctrl id 4602)
#define IDH_PSFORMS_NAME           1630       // Forms: "" (Edit) (ctrl id 4603)

#define IDH_LPRMON_HLP             900//legacy topic// I don't know where this control is found


// Print Server Properties dialog/Ports tab  // "Ports" Dialog Box (#518)

//#define IDH_PSFORMS_SERVER_NAME        1600       // Uses help topic from Forms dialog #516 (ctrl id 1166)
#define IDH_PORTS_LIST                   1200       // Ports: "" (SysListView32), &Ports on this server  (ctrl id 3100, 4317)
#define IDH_PORTS_ADD                    1210       // Ports: "Add Por&t..." (Button) (ctrl id 3101)
#define IDH_PORTS_DELETE                 1220       // Ports: "&Delete Port" (Button) (ctrl id 3102)
#define IDH_PORTS_CONFIGURE              1230       // Ports: "&Configure Port..." (Button) (ctrl id 3103)
#define IDH_PORTS_ENABLE_BIDIRECTIONAL   1240       // Ports: "&Enable bidirectional support" (Button) (ctrl id 3105)


// Print Server Properties dialog/Drivers tab  // "Drivers" Dialog Box (#519)

#define IDH_PSDRIVERS_UPDATE           1780       // Drivers: "&Update" (Button) (ctrl id 1105)
#define IDH_PSDRIVERS_PROPERTIES       1790       // Drivers: "Prop&erties..." (Button) (ctrl id 1091)
#define IDH_PSDRIVERS_INSTALLED_LIST   1750       // Drivers: "" (SysListView32) (Static) (ctrl id 1092, 4319)
//#define IDH_PSFORMS_SERVER_NAME      1600       // Uses help topic from Forms dialog #516 (ctrl id 1166)
#define IDH_PSDRIVERS_ADD              1760       // Drivers: "A&dd..." (Button) (ctrl id 1080)
#define IDH_PSDRIVERS_REMOVE           1770       // Drivers: "&Remove" (Button) (ctrl id 1081)


// "Driver Properties" Dialog Box (#501)

#define IDH_PSDRIVERS_PROP_ENVIRONMENT    2070       // Driver Properties: "" (Edit) (Static) (ctrl id 1128, 4571)
#define IDH_PSDRIVERS_PROP_PATH           2100       // Driver Properties: "" (Edit) (Static) (ctrl id 1129, 4574)
#define IDH_PSDRIVERS_PROP_INFOLIST       2110       // Driver Properties: "List1" (SysListView32) (ctrl id 1133)
#define IDH_PSDRIVERS_PROP_LANGUAGE_MON   2080       // Driver Properties: "" (Edit) (Static) (ctrl id 1136, 4572)
#define IDH_PSDRIVERS_PROP_DATATYPE       2090       // Driver Properties: "" (Edit) (Static) (ctrl id 1137, 4573)
#define IDH_PSDRIVERS_PROP_NAME           2050       // Driver Properties: "" (Edit) (Static) (ctrl id 1054, 4569)
#define IDH_PSDRIVERS_PROP_BTN            2120       // Driver Properties: "Properties..." (Button) (ctrl id 4577)
#define IDH_PSDRIVERS_PROP_VERSION        2060       // Driver Properties: "" (Edit) (Static) (ctrl id 1127, 4570)


// Print Server Properties dialog/Advanced tab  // "Advanced" Dialog Box (#517)

#define IDH_PSADV_REMOTE_JOB_NOTIFY             1850       // Advanced: "No&tify when remote documents are printed" (Button) (ctrl id 1013)
#define IDH_PSADV_REMOTE_DOCS_NOTIFY_COMPUTER   1860       // Advanced: "No&tify computer rather than user when remote documents are printed" (Button) (ctrl id 4320)
#define IDH_PSADV_LOG_SPOOLER_ERRORS            1810       // Advanced: "Log spooler &error events" (Button) (ctrl id 1015)
#define IDH_PSADV_LOG_SPOOLER_WARNINGS          1820       // Advanced: "Log spooler &warning events" (Button) (ctrl id 1016)
#define IDH_PSADV_LOG_SPOOLER_INFORMATION       1830       // Advanced: "Log spooler &information events" (Button) (ctrl id 1017)
//#define IDH_PSFORMS_SERVER_NAME               1600       // Uses help topic from Forms dialog #516 (ctrl id 1166)
#define IDH_PSADV_SPOOL_FOLDER                  1800       // Advanced: "" (Edit), &Spool folder (ctrl id 4316, 1008)
#define IDH_PSADV_REMOTE_JOB_ERRORS_BEEP        1840       // Advanced: "&Beep on errors of remote documents" (Button) (ctrl id 1011)
#define IDH_PSADV_JOB_BALLOON_NOTIFY_LOCAL      1870       // Advanced: "Show informational notifications for &local printers" (Button) (ctrl id 1012)
#define IDH_PSADV_JOB_BALLOON_NOTIFY_REMOTE     1875       // Advanced: "Show informational notifications for netw&ork printers" (Button) (ctrl id 1014)
#define IDH_PSADV_REMOTE_JOB_NOTIFY_HEADING     1879       // Advanced: "Printer notifications for downlevel clients:" (Button) (ctrl id 1009)


// "Settings" Dialog Box //from Device Manager in MMC (#534)

#define IDH_MMC_DM_SETTINGS_PRINTERS_FOLDER   2301       // Settings: "&Printers Folder" (Button) (ctrl id 1141)
#define IDH_MMC_DM_SETTINGS_MANAGE_PRINTER    2300       // Settings: "Please go to the printers folder to manage your printer." (Static) (ctrl id 4511)
//#define IDH_PPGENL_PRINTER_NAME             1000       // General: "Printer name" (Static) (Edit) (ctrl id 3000, 3001)


// Connect to Printer dialog // (#536) //called from the Add Printer Wizard and through Notepad, Wordpad, and Paint

#define IDH_CTP_PRINTER                     76000       // Connect to Printer: "&Printer:" (Static) and (Edit) (ctrl id 4589, 4578)
#define IDH_CTP_SHARED_PRINTERS             76010       // Connect to Printer: "&Shared Printers:" (Static) and (ListBox) (ctrl id 4590, 4579)
#define IDH_CTP_EXPAND_DEFAULT              76020       // Connect to Printer: "&Expand by Default" (Button) (ctrl id 4588)
#define IDH_CTP_PRINTER_INFO_DESCRIPTION    76030       // Connect to Printer: "Comment:" (Static) (ctrl id 4581, 4582)
#define IDH_CTP_PRINTER_INFO_STATUS         76040       // Connect to Printer: "Status:" (Static) (ctrl id 4583, 4584)
#define IDH_CTP_PRINTER_INFO_DOCS_WAITING   76050       // Connect to Printer: "Documents Waiting:" (Static) (ctrl id 4585, 4586)


// Location dialog // (#537) //Part of Location Lite in the DS...
#define IDH_LOCLITE_LOCATION     77000       // Location: "" (Edit) "&Location:" (Static) (ctrl ids 3580, 3577)
#define IDH_LOCLITE_LOC_BROWSE   77010       // Location: "&Browse..." (Button) (ctrl id 3581)


// Browse for Location dialog // (#538) //Part of Location Lite in the DS...
#define IDH_BROWSE_LOCATION_APPROPRIATE_TREE   77050       // Browse For Location: "Tree1" (SysTreeView32) (ctrl id 4650)
#define IDH_BROWSE_LOCATION_SELECTED           77060       // Browse For Location: "" (Edit), "Selected location: " (Static) (ctrl id 4652, 4548)


// Location dialog // (#10004) //Part of Location Lite in the DS...
#define IDH_LOCLITE_COMPUTER_LOCATION       77020       // Location: "" (Edit) "&Location:" (Static) (ctrl ids 4666, 4668)
//#define IDH_LOCLITE_COMPUTER_LOC_BROWSE   77030       // Location: "&Browse..." (Button) (ctrl id 3581)



const DWORD g_aHelpIDs[]=
{
        425,       IDH_NOHELP,       // Drivers, Advanced (Static)
       1008,       IDH_PSADV_SPOOL_FOLDER,       // Advanced: "" (Edit)
       1009,       IDH_PSADV_REMOTE_JOB_NOTIFY_HEADING,       // Advanced: "Printer notifications for downlevel clients:" (Button)
       1011,       IDH_PSADV_REMOTE_JOB_ERRORS_BEEP,       // Advanced: "&Beep on errors of remote documents" (Button)
       1012,       IDH_PSADV_JOB_BALLOON_NOTIFY_LOCAL,       // Advanced: "Show informational notifications for &local printers" (Button)
       1013,       IDH_PSADV_REMOTE_JOB_NOTIFY,       // Advanced: "No&tify when remote documents are printed" (Button)
       1014,       IDH_PSADV_JOB_BALLOON_NOTIFY_REMOTE,       // Advanced: "Show informational notifications for netw&ork printers" (Button)
       1015,       IDH_PSADV_LOG_SPOOLER_ERRORS,       // Advanced: "Log spooler &error events" (Button)
       1016,       IDH_PSADV_LOG_SPOOLER_WARNINGS,       // Advanced: "Log spooler &warning events" (Button)
       1017,       IDH_PSADV_LOG_SPOOLER_INFORMATION,       // Advanced: "Log spooler &information events" (Button)
       1031,       IDH_PPGENL_PREFERENCES_PERSONAL,       // General: "Printing Preferences..." (Button)
       1045,       IDH_PPADV_DRIVER,       // Advanced: "" (ComboBox)
       1049,       IDH_PPGENL_COMMENT,       // General: "&Comment:" (Static)
       1050,       IDH_PPGENL_LOCATION,       // General: "&Location:" (Static)
       1051,       IDH_PPADV_DRIVER,       // Advanced: "Driver:" (Static)
       1052,       IDH_PP_PORTS_ENABLE_POOLING,       // Ports: "E&nable printer pooling" (Button)
       1053,       IDH_PPADV_ADVPRINT_FEATURES,       // Advanced: "&Enable advanced printing features" (Button)
       1054,       IDH_PSDRIVERS_PROP_NAME,       // Driver Properties: "" (Edit)
       1064,       IDH_PPSHARED_LIST_IN_DIRECTORY,       // Sharing: "" (Button)
       1080,       IDH_PSDRIVERS_ADD,       // Drivers: "A&dd..." (Button)
       1081,       IDH_PSDRIVERS_REMOVE,       // Drivers: "&Remove" (Button)
       1091,       IDH_PSDRIVERS_PROPERTIES,       // Drivers: "Prop&erties..." (Button)
       1092,       IDH_PSDRIVERS_INSTALLED_LIST,       // Drivers: "" (SysListView32)
       1105,       IDH_PSDRIVERS_UPDATE,       // Drivers: "&Update" (Button)
       1127,       IDH_PSDRIVERS_PROP_VERSION,       // Driver Properties: "" (Edit)
       1128,       IDH_PSDRIVERS_PROP_ENVIRONMENT,       // Driver Properties: "" (Edit)
       1129,       IDH_PSDRIVERS_PROP_PATH,       // Driver Properties: "" (Edit)
       1133,       IDH_PSDRIVERS_PROP_INFOLIST,       // Driver Properties: "List1" (SysListView32)
       1134,       IDH_PPSHARED_ADDITIONAL_DRIVERS_LIST,       // Additional Drivers: "List1" (SysListView32)
       1136,       IDH_PSDRIVERS_PROP_LANGUAGE_MON,       // Driver Properties: "" (Edit)
       1137,       IDH_PSDRIVERS_PROP_DATATYPE,       // Driver Properties: "" (Edit)
       1140,       IDH_PPSHARED_ADDITIONAL_DRIVERS,       // Sharing: "A&dditional Drivers..." (Button)
       1141,       IDH_MMC_DM_SETTINGS_PRINTERS_FOLDER,       // Settings: "&Printers Folder" (Button)
       1145,       IDH_PPADV_PRINTING_DEFAULTS,       // Advanced: "Printing Defaults..." (Button)
       1154,       IDH_NOHELP,       // Ports: "&Print to the following port(s). Documents will print to the first free checked port." (Static)
       1166,       IDH_PSFORMS_SERVER_NAME,       // Forms, Ports, Drivers,Advanced: "Server name" (Static)
       1193,       IDH_NOHELP,       // Sharing: "If this printer is shared with users running different versions of Windows then you will need to install additional drivers for it." (Static)
       1194,       IDH_NOHELP,       // Additional Drivers: "You may install additional drivers so that users on the following systems can download them automatically when they connect." (Static)
       3000,       IDH_NOHELP,       // General, Ports, Sharing, Settings tabs/ printer icon (Static) //Settings
       3001,       IDH_PPGENL_PRINTER_NAME,       // General, Ports, Sharing, Settings: "Printer name" (Static) //Settings
       3003,       IDH_PPADV_NEW_DRIVER,       // Advanced: "Ne&w Driver..." (Button)
       3005,       IDH_PPGENL_COMMENT,       // General: "" (Edit)
       3006,       IDH_PPGENL_LOCATION,       // General: "" (Edit)
       3007,       IDH_PPGENL_PRINT_TEST_PAGE,       // General: "Print &Test Page" (Button)
       3008,       IDH_PPADV_SEPARATOR_PAGE,       // Advanced: "&Separator Page..." (Button)
       3009,       IDH_PPADV_PRINT_PROCESSOR,       // Advanced: "P&rint Processor..." (Button)
       3013,       IDH_NOHELP,       // General: "" (Static)
       3014,       IDH_PPADV_FROM_TO,       // Advanced: "To" (Static)
       3015,       IDH_PPGENL_LOC_BROWSE,       // General: "&Browse..." (Button)
       3100,       IDH_PORTS_LIST,       // Ports: "" (SysListView32)
       3101,       IDH_PORTS_ADD,       // Ports: "Add Por&t..." (Button) x 2
       3102,       IDH_PORTS_DELETE,       // Ports: "&Delete Port" (Button) x 2
       3103,       IDH_PORTS_CONFIGURE,       // Ports: "&Configure Port..." (Button) x 2
       3105,       IDH_PORTS_ENABLE_BIDIRECTIONAL,       // Ports: "&Enable bidirectional support" (Button) x 2
       3200,       IDH_PPADV_ALWAYS,       // Advanced: "Al&ways available" (Button)
       3201,       IDH_PPADV_FROM_TO,       // Advanced: "Available from" (Button)
       3220,       IDH_PPADV_SPOOL_PRINT_DOCS,       // Advanced: "&Spool print documents so program finishes printing faster" (Button)
       3221,       IDH_PPADV_PRINT_DIRECTLY,       // Advanced: "Print &directly to the printer" (Button)
       3222,       IDH_PPADV_SPOOL_ALL,       // Advanced: "S&tart printing after last page is spooled" (Button)
       3223,       IDH_PPADV_START_PRINTING_IMMEDIATELY,       // Advanced: "Start printing &immediately" (Button)
       3224,       IDH_PPADV_HOLD_MISMATCHED,       // Advanced: "&Hold mismatched documents" (Button)
       3225,       IDH_PPADV_PRINT_SPOOLED_DOCS_FIRST,       // Advanced: "P&rint spooled documents first" (Button)
       3226,       IDH_PPADV_KEEP_PRINTED_JOBS,       // Advanced: "&Keep printed documents" (Button)
       3227,       IDH_PPSHARED_NOT,       // Sharing: "N&ot shared" (Button)
       3228,       IDH_PPSHARED_AS,       // Sharing: "&Shared as:" (Button)
       3302,       IDH_PPSHARED_NAME,       // Sharing: "" (Edit)
       3557,       IDH_NOHELP,       // Ports, (??General, Sharing, Scheduling: "" (Static) //Settings)
       3558,       IDH_DPGENL_JOB_SIZE,       // General: "Size:" (Static)
       3559,       IDH_DPGENL_JOB_PAGES,       // General: "Pages:" (Static)
       3560,       IDH_DPGENL_JOB_DATATYPE,       // General: "Datatype:" (Static)
       3561,       IDH_DPGENL_JOB_PROCESSOR,       // General: "Processor:" (Static)
       3562,       IDH_DPGENL_JOB_OWNER,       // General: "Owner:" (Static)
       3563,       IDH_DPGENL_JOB_SUBMITTED,       // General: "Submitted:" (Static)
       3564,       IDH_DPGENL_JOB_NOTIFY,       // General: "&Notify:" (Static)
       3565,       IDH_DPGENL_JOB_PRIORITY_SLIDER,       // General: "Lowest" (Static)
       3566,       IDH_DPGENL_JOB_PRIORITY_SLIDER,       // General: "Highest" (Static)
       3567,       IDH_PPADV_CURRENT_PRIORITY,       // General: "Current priority:" (Static)
       3568,       IDH_DPGENL_JOB_START_END,       // General: "To" (Static)
       3569,       IDH_NOHELP,       // Advanced: "" (Static)
       3570,       IDH_NOHELP,       // Advanced: "" (Static)
       3571,       IDH_NOHELP,       // General: "" (Static)
       3572,       IDH_NOHELP,       // Ports: "" (Static)
       3573,       IDH_NOHELP,       // General: "" (Static)
       3574,       IDH_NOHELP,       // Sharing: "" (Static)
       3575,       IDH_NOHELP,       // Settings: "" (Static)
       3576,       IDH_NOHELP,       // Connect to Printer: "Printer Information" (Button)
       3577,       IDH_LOCLITE_LOCATION,       // Location: "" (Edit)
       3578,       IDH_NOHELP,       // Location: "" (Static)
       3579,       IDH_NOHELP,       // Location: "" (Static)
       3580,       IDH_LOCLITE_LOCATION,       // Location: "&Location:" (Static)
       3581,       IDH_LOCLITE_LOC_BROWSE,       // Location: "&Browse..." (Button)
       4201,       IDH_DPGENL_JOB_START_END,       // General: "Only &from" (Button)
       4219,       IDH_DPGENL_JOB_SIZE,       // General: "" (Static)
       4220,       IDH_DPGENL_JOB_TITLE,       // General: "" (Static)
       4222,       IDH_DPGENL_JOB_SUBMITTED,       // General: "" (Static)
       4223,       IDH_DPGENL_JOB_PROCESSOR,       // General: "" (Static)
       4224,       IDH_DPGENL_JOB_DATATYPE,       // General: "" (Static)
       4225,       IDH_DPGENL_JOB_PAGES,       // General: "" (Static)
       4226,       IDH_DPGENL_JOB_OWNER,       // General: "" (Static)
       4229,       IDH_PPADV_CURRENT_PRIORITY,       // General: "" (Static)
       4230,       IDH_DPGENL_JOB_NOTIFY,       // General: "" (Edit)
       4231,       IDH_DPGENL_JOB_PRIORITY_SLIDER,       // General: "TracBar1" (msctls_trackbar32)
       4232,       IDH_DPGENL_JOB_ALWAYS,       // General: "No time &restriction" (Button)
       4303,       IDH_PRINTERPORTS_AVAILABLE_LIST,       // Printer Ports: "" (ListBox)
       4305,       IDH_PRINTERPORTS_NEW_PORT_MONITOR,       // Printer Ports: "&New Port Type..." (Button)
       4307,       IDH_PRINTERPORTS_AVAILABLE_LIST,       // Printer Ports: "&Available port types:" (Static)
       4308,       IDH_PRINTERPORTS_NEW_PORT,       // Printer Ports: "New &Port..." (Button)
       4309,       IDH_NOHELP,       // Scheduling: "Available:" (Static)
       4313,       IDH_NOHELP,       // General: "&Priority:" (Button)
       4314,       IDH_NOHELP,       // General: "&Schedule:" (Button)
       4315,       IDH_NOHELP,       // Advanced: "" (Static)
       4316,       IDH_PSADV_SPOOL_FOLDER,       // Advanced: "&Spool folder:" (Static)
       4317,       IDH_PORTS_LIST,       // Ports: "&Ports on this server" (Static)
       4318,       IDH_NOHELP,       // Sharing: "Drivers for different versions of Windows" (Button)
       4319,       IDH_PSDRIVERS_INSTALLED_LIST,       // Drivers: "Installed printer drivers:" (Static)
       4320,       IDH_PSADV_REMOTE_DOCS_NOTIFY_COMPUTER,       // Advanced: "No&tify computer rather than user when remote documents are printed" (Button)
       4400,       IDH_PPADV_SEPARATOR_PAGE_BROWSE,       // Separator Page: "&Browse..." (Button)
       4401,       IDH_PPADV_SEPARATOR_PAGE_NAME,       // Separator Page: "" (Edit)
       4403,       IDH_PPADV_SEPARATOR_PAGE_NAME,       // Separator Page: "Separator page:" (Static)
       4404,       IDH_NOHELP,       // Separator Page: "Separator pages are used at the beginning of each document to make it easy to find a document among others at the printer." (Static)
       4500,       IDH_PPADV_PRINT_PROCESSOR_LIST,       // Print Processor: "" (ListBox)
       4501,       IDH_PPADV_PRINT_PROCESSOR_DATATYPE_LIST,       // Print Processor: "" (ListBox)
       4503,       IDH_PPADV_PRINT_PROCESSOR_DATATYPE_LIST,       // Print Processor: "Default datatype:" (Static)
       4504,       IDH_PPADV_PRINT_PROCESSOR_LIST,       // Print Processor: "Print processor:" (Static)
       4505,       IDH_NOHELP,       // Print Processor: "Selecting a different print processor may result in different options being available for default datatypes. If your service does not specify a datatype the selection below will be used." (Static)
       4507,       IDH_PPADV_FROM_TO_START,       // Advanced: "" (SysDateTimePick32)
       4508,       IDH_PPADV_FROM_TO_END,       // Advanced: "" (SysDateTimePick32)
       4509,       IDH_DPGENL_JOB_START_END_FROM,       // General: "" (SysDateTimePick32)
       4510,       IDH_DPGENL_JOB_START_END_TO,       // General: "" (SysDateTimePick32)
       4511,       IDH_MMC_DM_SETTINGS_MANAGE_PRINTER,       // Settings: "Please go to the printers folder to manage your printer." (Static)
       4513,       IDH_NOHELP,       // Ports: "" (Static)
       4548,       IDH_BROWSE_LOCATION_SELECTED,       // Browse For Location: "Selected location: " (Static)
       4569,       IDH_PSDRIVERS_PROP_NAME,       // Driver Properties: "Name:" (Static)
       4570,       IDH_PSDRIVERS_PROP_VERSION,       // Driver Properties: "Version:" (Static)
       4571,       IDH_PSDRIVERS_PROP_ENVIRONMENT,       // Driver Properties: "Environment:" (Static)
       4572,       IDH_PSDRIVERS_PROP_LANGUAGE_MON,       // Driver Properties: "Language monitor:" (Static)
       4573,       IDH_PSDRIVERS_PROP_DATATYPE,       // Driver Properties: "Default datatype:" (Static)
       4574,       IDH_PSDRIVERS_PROP_PATH,       // Driver Properties: "Driver path:" (Static)
       4576,       IDH_NOHELP,       // Sharing: "Sharing this printer is not supported." (Static)
       15447,      IDH_NOHELP,       // Sharing: "Sharing this printer is not supported." (Static)
       4577,       IDH_PSDRIVERS_PROP_BTN,       // Driver Properties: "Properties..." (Button)
       4578,       IDH_CTP_PRINTER,       // Connect to Printer: "" (Edit)
       4579,       IDH_CTP_SHARED_PRINTERS,       // Connect to Printer: "" (ListBox)
       4581,       IDH_CTP_PRINTER_INFO_DESCRIPTION,       // Connect to Printer: "Comment:" (Static)
       4582,       IDH_CTP_PRINTER_INFO_DESCRIPTION,       // Connect to Printer: "" (Static)
       4583,       IDH_CTP_PRINTER_INFO_STATUS,       // Connect to Printer: "Status:" (Static)
       4584,       IDH_CTP_PRINTER_INFO_STATUS,       // Connect to Printer: "" (Static)
       4585,       IDH_CTP_PRINTER_INFO_DOCS_WAITING,       // Connect to Printer: "Documents Waiting:" (Static)
       4586,       IDH_CTP_PRINTER_INFO_DOCS_WAITING,       // Connect to Printer: "" (Static)
       4587,       IDH_NOHELP,       // Connect to Printer: "" (Static)
       4588,       IDH_CTP_EXPAND_DEFAULT,       // Connect to Printer: "&Expand by Default" (Button)
       4589,       IDH_CTP_PRINTER,       // Connect to Printer: "&Printer:" (Static)
       4590,       IDH_CTP_SHARED_PRINTERS,       // Connect to Printer: "&Shared Printers:" (Static)
       4601,       IDH_NOHELP,       // Forms: "Forms on:" (Static)
       4602,       IDH_PSFORMS_LIST,       // Forms: "" (ListBox)
       4603,       IDH_PSFORMS_NAME,       // Forms: "" (Edit)
       4604,       IDH_PSFORMS_WIDTH,       // Forms: "&Width:" (Static)
       4605,       IDH_PSFORMS_WIDTH,       // Forms: "" (Edit)
       4606,       IDH_PSFORMS_HEIGHT,       // Forms: "&Height:" (Static)
       4607,       IDH_PSFORMS_HEIGHT,       // Forms: "" (Edit)
       4608,       IDH_PSFORMS_LEFT,       // Forms: "&Left:" (Static)
       4609,       IDH_PSFORMS_LEFT,       // Forms: "" (Edit)
       4610,       IDH_PSFORMS_RIGHT,       // Forms: "&Right:" (Static)
       4611,       IDH_PSFORMS_RIGHT,       // Forms: "" (Edit)
       4612,       IDH_PSFORMS_TOP,       // Forms: "&Top:" (Static)
       4613,       IDH_PSFORMS_TOP,       // Forms: "" (Edit)
       4614,       IDH_PSFORMS_BOTTOM,       // Forms: "&Bottom:" (Static)
       4615,       IDH_PSFORMS_BOTTOM,       // Forms: "" (Edit)
       4616,       IDH_PSFORMS_SAVEFORM,       // Forms: "&Save Form" (Button)
       4617,       IDH_PSFORMS_DELETE,       // Forms: "&Delete" (Button)
       4620,       IDH_PSFORMS_UNIT_METRIC,       // Forms: "&Metric" (Button)
       4621,       IDH_PSFORMS_UNIT_ENGLISH,       // Forms: "&English" (Button)
       4622,       IDH_PSFORMS_CREATE_NEW,       // Forms: "&Create a New Form" (Button)
       4623,       IDH_NOHELP,       // Forms: "Define a new form by editing the existing name and measurements.  Then click Save Form." (Static)
       4624,       IDH_NOHELP,       // Forms: "Paper Size:" (Static)
       4625,       IDH_NOHELP,       // Forms: "Printer Area Margins:" (Static)
       4626,       IDH_NOHELP,       // Measurements group box in Forms #516 (DBHE can't *see* this)
       4627,       IDH_NOHELP,       // Forms: "Units:" (Static)
       4628,       IDH_NOHELP,       // Forms: "&Form Description for:   " (Button)
       4629,       IDH_PPADV_CURRENT_PRIORITY,       // Advanced: "Priority:" (Static)
       4630,       IDH_PPADV_CURRENT_PRIORITY,       // Advanced: "Spin1" (msctls_updown32)
       4631,       IDH_PPADV_CURRENT_PRIORITY,       // Advanced: "0" (Edit)
       4632,       IDH_PPGENL_MODEL,       // General: "M&odel:" (Static)
       4633,       IDH_PPGENL_MODEL,       // General: "" (Edit)
       4634,       IDH_NOHELP,       // General: "Features" (Button)
       4635,       IDH_PPGENL_COLOR,       // General: "Color:" (Static)
       4636,       IDH_PPGENL_DUPLEX,       // General: "Double-sided:" (Static)
       4637,       IDH_PPGENL_STAPLE,       // General: "Staple:" (Static)
       4638,       IDH_PPGENL_SPEED,       // General: "Speed:" (Static)
       4639,       IDH_PPGENL_MAXRESOLUTION,       // General: "Maximum resolution:" (Static)
       4640,       IDH_PPGENL_PAPERSIZE,       // General: "Paper sizes:" (Static)
       4641,       IDH_PPGENL_PAPERSIZE,       // General: "" (Edit)
       4650,       IDH_BROWSE_LOCATION_APPROPRIATE_TREE,       // Browse For Location: "Tree1" (SysTreeView32)
       4651,       IDH_NOHELP,       // Browse For Location: "Choose the appropriate location." (Static)
       4652,       IDH_BROWSE_LOCATION_SELECTED,       // Browse For Location: "" (Edit)
       4666,       IDH_LOCLITE_COMPUTER_LOCATION,       // Location: "" (Edit)
       4668,       IDH_LOCLITE_COMPUTER_LOCATION,       // Location: "&Location:" (Static)
       4682,       IDH_PPSHARED_NAME,       // Sharing: "S&hare name" (Static)
       4683,       IDH_NOHELP,  // Sharing: "You can share this printer with other users on your network.... etc." (Static)
       0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\pridsfix.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    prids.h

Abstract:

    Printer Ids.

Author:

    Albert Ting (AlbertT)  22-Jun-1995

Revision History:

--*/

/********************************************************************

    Header translations: 0x3900 -> 0x3a00

    These strings are used in the column headers of the Queue UI.
    Although all of the PRINTER_NOTIFY_* fields are defined here,
    only those that actually visible in the UI are defined in
    the resource file.

********************************************************************/

#define IDS_HEAD            0x3900
#define IDS_HEAD_DELTA      0x80

#define IDS_HEAD_JOB                         IDS_HEAD
#define IDS_HEAD_JOB_PRINTER_NAME            (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_PRINTER_NAME)
#define IDS_HEAD_JOB_MACHINE_NAME            (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_MACHINE_NAME)
#define IDS_HEAD_JOB_PORT_NAME               (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_PORT_NAME)
#define IDS_HEAD_JOB_USER_NAME               (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_USER_NAME)
#define IDS_HEAD_JOB_NOTIFY_NAME             (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_NOTIFY_NAME)
#define IDS_HEAD_JOB_DATATYPE                (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_DATATYPE)
#define IDS_HEAD_JOB_PRINT_PROCESSOR         (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_PRINT_PROCESSOR)
#define IDS_HEAD_JOB_PARAMETERS              (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_PARAMETERS)
#define IDS_HEAD_JOB_DRIVER_NAME             (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_DRIVER_NAME)
#define IDS_HEAD_JOB_DEVMODE                 (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_DEVMODE)
#define IDS_HEAD_JOB_STATUS                  (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_STATUS)
#define IDS_HEAD_JOB_STATUS_STRING           (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_STATUS_STRING)
#define IDS_HEAD_JOB_SECURITY_DESCRIPTOR     (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR)
#define IDS_HEAD_JOB_DOCUMENT                (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_DOCUMENT)
#define IDS_HEAD_JOB_PRIORITY                (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_PRIORITY)
#define IDS_HEAD_JOB_POSITION                (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_POSITION)
#define IDS_HEAD_JOB_SUBMITTED               (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_SUBMITTED)
#define IDS_HEAD_JOB_START_TIME              (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_START_TIME)
#define IDS_HEAD_JOB_UNTIL_TIME              (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_UNTIL_TIME)
#define IDS_HEAD_JOB_TIME                    (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_TIME)
#define IDS_HEAD_JOB_TOTAL_PAGES             (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_TOTAL_PAGES)
#define IDS_HEAD_JOB_PAGES_PRINTED           (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_PAGES_PRINTED)
#define IDS_HEAD_JOB_TOTAL_BYTES             (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_TOTAL_BYTES)
#define IDS_HEAD_JOB_BYTES_PRINTED           (IDS_HEAD_JOB + JOB_NOTIFY_FIELD_BYTES_PRINTED)

#define IDS_HEAD_PRINTER                     (IDS_HEAD_JOB + IDS_HEAD_DELTA)
#define IDS_HEAD_PRINTER_SERVER_NAME         (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_SERVER_NAME)
#define IDS_HEAD_PRINTER_PRINTER_NAME        (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_PRINTER_NAME)
#define IDS_HEAD_PRINTER_SHARE_NAME          (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_SHARE_NAME)
#define IDS_HEAD_PRINTER_PORT_NAME           (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_PORT_NAME)
#define IDS_HEAD_PRINTER_DRIVER_NAME         (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_DRIVER_NAME)
#define IDS_HEAD_PRINTER_COMMENT             (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_COMMENT)
#define IDS_HEAD_PRINTER_LOCATION            (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_LOCATION)
#define IDS_HEAD_PRINTER_DEVMODE             (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_DEVMODE)
#define IDS_HEAD_PRINTER_SEPFILE             (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_SEPFILE)
#define IDS_HEAD_PRINTER_PRINT_PROCESSOR     (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR)
#define IDS_HEAD_PRINTER_PARAMETERS          (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_PARAMETERS)
#define IDS_HEAD_PRINTER_DATATYPE            (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_DATATYPE)
#define IDS_HEAD_PRINTER_SECURITY_DESCRIPTOR (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR)
#define IDS_HEAD_PRINTER_ATTRIBUTES          (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_ATTRIBUTES)
#define IDS_HEAD_PRINTER_PRIORITY            (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_PRIORITY)
#define IDS_HEAD_PRINTER_DEFAULT_PRIORITY    (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY)
#define IDS_HEAD_PRINTER_START_TIME          (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_START_TIME)
#define IDS_HEAD_PRINTER_UNTIL_TIME          (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_UNTIL_TIME)
#define IDS_HEAD_PRINTER_STATUS              (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_STATUS)
#define IDS_HEAD_PRINTER_STATUS_STRING       (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_STATUS_STRING)
#define IDS_HEAD_PRINTER_CJOBS               (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_CJOBS)
#define IDS_HEAD_PRINTER_AVERAGE_PPM         (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_AVERAGE_PPM)
#define IDS_HEAD_PRINTER_TOTAL_PAGES         (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_TOTAL_PAGES)
#define IDS_HEAD_PRINTER_PAGES_PRINTED       (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_PAGES_PRINTED)
#define IDS_HEAD_PRINTER_TOTAL_BYTES         (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_TOTAL_BYTES)
#define IDS_HEAD_PRINTER_BYTES_PRINTED       (IDS_HEAD_PRINTER + PRINTER_NOTIFY_FIELD_BYTES_PRINTED)

#define IDS_DRIVER_BASE                 0x3a20
#define IDS_DRIVER_ALPHA_0              (IDS_DRIVER_BASE + DRIVER_ALPHA_0)
#define IDS_DRIVER_X86_0                (IDS_DRIVER_BASE + DRIVER_X86_0)
#define IDS_DRIVER_MIPS_0               (IDS_DRIVER_BASE + DRIVER_MIPS_0)
#define IDS_DRIVER_WIN95                (IDS_DRIVER_BASE + DRIVER_WIN95)
#define IDS_DRIVER_ALPHA_1              (IDS_DRIVER_BASE + DRIVER_ALPHA_1)
#define IDS_DRIVER_X86_1                (IDS_DRIVER_BASE + DRIVER_X86_1)
#define IDS_DRIVER_MIPS_1               (IDS_DRIVER_BASE + DRIVER_MIPS_1)
#define IDS_DRIVER_PPC_1                (IDS_DRIVER_BASE + DRIVER_PPC_1)
#define IDS_DRIVER_ALPHA_2              (IDS_DRIVER_BASE + DRIVER_ALPHA_2)
#define IDS_DRIVER_X86_2                (IDS_DRIVER_BASE + DRIVER_X86_2)
#define IDS_DRIVER_MIPS_2               (IDS_DRIVER_BASE + DRIVER_MIPS_2)
#define IDS_DRIVER_PPC_2                (IDS_DRIVER_BASE + DRIVER_PPC_2)
#define IDS_DRIVER_X86_3                (IDS_DRIVER_BASE + DRIVER_X86_3)
#define IDS_DRIVER_ALPHA_3              (IDS_DRIVER_BASE + DRIVER_ALPHA_3)
#define IDS_DRIVER_IA64_3               (IDS_DRIVER_BASE + DRIVER_IA64_3)

#define IDS_DRIVER_END                  0x3a3e

#define IDS_MH_PRINTER_PAUSE                (MH_PRINTER + IDM_PRINTER_PAUSE)
#define IDS_MH_PRINTER_INSTALL              (MH_PRINTER + IDM_PRINTER_INSTALL)
#define IDS_MH_PRINTER_PURGE                (MH_PRINTER + IDM_PRINTER_PURGE)
#define IDS_MH_PRINTER_SET_DEFAULT          (MH_PRINTER + IDM_PRINTER_SET_DEFAULT)
#define IDS_MH_PRINTER_SHARING              (MH_PRINTER + IDM_PRINTER_SHARING)
#define IDS_MH_PRINTER_WORKOFFLINE          (MH_PRINTER + IDM_PRINTER_WORKOFFLINE)
#define IDS_MH_REFRESH                      (MH_PRINTER + IDM_REFRESH)
#define IDS_MH_PRINTER_PROPERTIES           (MH_PRINTER + IDM_PRINTER_PROPERTIES)
#define IDS_MH_PRINTER_CLOSE                (MH_PRINTER + IDM_PRINTER_CLOSE)
#define IDS_MH_PRINTER_DOCUMENT_DEFAULTS    (MH_PRINTER + IDM_PRINTER_DOCUMENT_DEFAULTS)
#define IDS_MH_STATUS_BAR                   (MH_PRINTER + IDM_STATUS_BAR)
#define IDS_MH_HELP_CONTENTS                (MH_PRINTER + IDM_HELP_CONTENTS)
#define IDS_MH_HELP_TROUBLESHOOTER          (MH_PRINTER + IDM_HELP_TROUBLESHOOTER)
#define IDS_MH_HELP_ABOUT                   (MH_PRINTER + IDM_HELP_ABOUT)
#define IDS_MH_JOB_PAUSE                    (MH_PRINTER + IDM_JOB_PAUSE)
#define IDS_MH_JOB_RESUME                   (MH_PRINTER + IDM_JOB_RESUME)
#define IDS_MH_JOB_RESTART                  (MH_PRINTER + IDM_JOB_RESTART)
#define IDS_MH_JOB_CANCEL                   (MH_PRINTER + IDM_JOB_CANCEL)
#define IDS_MH_JOB_PROPERTIES               (MH_PRINTER + IDM_JOB_PROPERTIES)
#define IDS_MH_WEB_OPEN                     (MH_PRINTER + IDM_WEB_OPEN)

/********************************************************************

    These ids are fixed and defined by setupapi.h, the are used
    in the add printer wizard to allow the setup api pages to 
    integrated properly with our pages.

********************************************************************/

#define DLG_WIZ_PRE_INTRO                   IDD_DYNAWIZ_FIRSTPAGE
#define DLG_WIZ_PRE_SELECT_DEVICE           IDD_DYNAWIZ_SELECT_PREVPAGE
#define DLG_WIZ_POST_SELECT_DEVICE          IDD_DYNAWIZ_SELECT_NEXTPAGE


/********************************************************************

    Print help trouble shooter tipic id.  This is a fixed id which 
    pss has defined.  It is referred to as the Mapped topic id.

********************************************************************/

#define IDH_PRINTING_TROUBLESHOOTERS_HTM    1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\printui.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999
All rights reserved.

Module Name:

    printui.c

Abstract:

    Singleton class that exists when printer queues are open.

Author:

    Albert Ting (AlbertT)  22-Jun-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#define _GLOBALS
#include "globals.hxx"

#include "time.hxx"
#include "shlobj.h"
#include "folder.hxx"
#include "spllibex.hxx"
#include "spinterf.hxx"

#if DBG
//#define DBG_PUIINFO                  DBG_INFO
#define DBG_PUIINFO                    DBG_NONE
#endif

//
// Singleton PrintLib object.
//
TPrintLib * TPrintLib::_pPrintLib;

extern "C" {

BOOL
DllMain(
    IN HINSTANCE    hInst,
    IN DWORD        dwReason,
    IN LPVOID       lpRes
    );
}

VOID
DllCleanUp(
    VOID
    );

BOOL
DllMain(
    IN HINSTANCE    hInst,
    IN DWORD        dwReason,
    IN LPVOID       lpRes
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

Return Value:

--*/

{
    BOOL bReturn = TRUE;

    switch( dwReason ){
    case DLL_PROCESS_ATTACH:

        ghInst = hInst;

#if DBG
        // init the debug library
        if( FAILED(_DbgInit()) )
        {
            DBGMSG(DBG_WARN, ("DllEntryPoint: Failed to initialize debug library %d\n", GetLastError()));
            bReturn = FALSE;
        }
#endif // DBG

        if( bReturn && !SHFusionInitializeFromModule(ghInst) )
        {
            DBGMSG(DBG_WARN, ("DllEntryPoint: Failed to initialize fusion %d\n", GetLastError()));
            bReturn = FALSE;
        }

        // init (load) winspool.drv
        if( bReturn && FAILED(Winspool_Init()) )
        {
            DBGMSG(DBG_WARN, ("DllEntryPoint: Failed to load winspool.drv %d\n", GetLastError()));
            bReturn = FALSE;
        }

        if( bReturn && !bPrintLibInit() )
        {
            DBGMSG(DBG_WARN, ("DllEntryPoint: Failed to init PrintLib %d\n", GetLastError()));
            bReturn = FALSE;
        }

        if( !bReturn )
        {
            DllCleanUp();
            return FALSE;
        }

        // setup CRT memory leak detection
        CRT_DEBUG_SET_FLAG(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
        CRT_DEBUG_REPORT_TO_STDOUT();

        InitCommonControls();

        //
        // Initialize the custom time edit control class.
        //
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_DATE_CLASSES;
        InitCommonControlsEx(&icc);

        //
        // Initialize the per therad message box counter here
        //
        CMsgBoxCounter::Initialize();

        DisableThreadLibraryCalls( hInst );

        break;

    case DLL_PROCESS_DETACH:

        //
        // Uninitialize the message box counter
        //
        CMsgBoxCounter::Uninitialize();

        VDSConnection::bStaticInitShutdown( TRUE );

        //
        // lpRes is NULL if it's a FreeLibrary, non-NULL if it's
        // process termination.  Don't do cleanup if it's process
        // termination.
        //
        if( !lpRes )
        {
            DllCleanUp();
        }

        break;

    default:
        break;
    }
    return TRUE;
}

VOID 
DllCleanUp(
    VOID
    )
/*++

Routine Description:

    Clean up memory and do the uninitialization.

Arguments:

Return Value:

Notes:

    Each UnInitialize function should take care of the case that Initialize is 
    not called. If Initialize is not called, UnInitialize will do nothing. 

--*/

{
    //
    // Unregister the class.
    //
    UnregisterClass( gszClassName, ghInst );
    UnregisterClass( gszQueueCreateClassName, ghInst );

    delete gpCritSec;
    delete TFolderList::gpFolderLock;
    delete gpTrayLock;

    // unload winspool.drv
    VERIFY(SUCCEEDED(Winspool_Done()));

    SHFusionUninitialize();
#if DBG
    // shutdown the debug library
    VERIFY(SUCCEEDED(_DbgDone()));
#endif // DBG

    return;
}

TPrintLib::
TPrintLib(
    VOID
    ) : TExec( gpCritSec ), _hEventInit( NULL )

/*++

Routine Description:

    Initializes application object.  This is a singleton object.

    This will create the message pump and also the hwndQueueCreate
    window which listens for requests.

Arguments:

Return Value:

Notes:

    _strComputerName is the valid variable.

--*/

{
    SPLASSERT( gpCritSec->bInside( ));

    if( !VALID_BASE( TExec ) )
    {
        return;
    }

    TNotify* pNotify = new TNotify;

    if( !VALID_PTR( pNotify ))
    {
        if( pNotify )
        {
            // at this point pNotify ref count should be one, but since
            // the ref count class is badly designed it is zero. we can't delete
            // the class directly because the destructor is private and 
            // there is not much of a choise left rather than to artificially
            // inc/dec the ref count so the object can get properly destroyed.

            // do not keep weak ref while shutting down
            pNotify->vIncRef(); 

            pNotify->vDelete();

            pNotify->cDecRef();
        }
        return;
    }

    _pNotify.vAcquire( pNotify );
}

TPrintLib::
~TPrintLib(
    VOID
    )

/*++

Routine Description:

   Destroys the printui.

Arguments:


Return Value:


--*/

{
    SPLASSERT( Queue_bEmpty( ));

    if( _hEventInit ){
        CloseHandle( _hEventInit );
    }

    // if pNotify().pGet() is NULL that means the destructor is called
    // twice which means that somebody is deleting the object twice. 
    // let's see who is the culprit here!!!
    RIP(pNotify().pGet());

    if( pNotify().pGet() )
    {
        //
        // We are shutting down.  Tell pNotify that it can start shutting
        // down too.
        //
        pNotify()->vDelete();
        
        // Release the reference. should not be used beyond this point
        pNotify().vRelease();
    }

    //
    // RL_Notify will automatically shut down when the last
    // reference to it has been deleted.
    //
}

BOOL
TPrintLib::
bInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes the print library

Arguments:

    None

Return Value:

--*/

{
    SPLASSERT( gpCritSec->bInside( ));

    //
    // The computer name needs to be formatted as "\\computername."
    //
    if( !bGetMachineName( _strComputerName, FALSE ) ){
        return FALSE;
    }

    //
    // Create init event.  This event is used to synchronize
    // the message pump initialization and this thread.
    //
    _hEventInit = CreateEvent( NULL, FALSE, FALSE, NULL );

    if( !_hEventInit ){
        return FALSE;
    }

    DWORD dwThreadId;
    HANDLE hThread;

    //
    // Start the message pump by spawning a UI thread.
    //
    hThread = TSafeThread::Create( NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)TPrintLib::xMessagePump,
                            this,
                            0,
                            &dwThreadId );

    if( !hThread ){
        return FALSE;
    }

    CloseHandle( hThread );

    //
    // Wait for thread to initialize.
    //
    WaitForSingleObject( _hEventInit, INFINITE );

    CloseHandle( _hEventInit );
    _hEventInit = NULL;

    //
    // _hwndQueueCreate is our valid check.  If it failed, cleanup.
    // This is set by the worker thread (xMessagePump).  We can access
    // it only after _hEventInit has been triggered.
    //
    if( !_hwndQueueCreate ){
        PostThreadMessage( dwThreadId,
                           WM_QUIT,
                           0,
                           0 );
    }

    return bValid();
}

VOID
TPrintLib::
vHandleCreateQueue(
    IN TInfo* pInfo ADOPT
    )

/*++

Routine Description:

    Handle the creation of a new Queue window.

Arguments:

    pInfo - Which queue should be created and extra parms.

Return Value:

--*/

{
    DBGMSG( DBG_PUIINFO, ( "PrintLib.vHandleQueueCreate: received pInfo %x\n", pInfo ));

    //
    // The Add Printer wizard is invoked by double clicking
    // a printer called "WinUtils_NewObject."  I hope no one
    // ever tries to create a printer under this name...
    //
    if( !lstrcmp( gszNewObject, pInfo->_szPrinter )){

        DBGMSG( DBG_WARN,
                ( "PrintLib.lrQueueCreateWndProc: WinUtils_NewObject called here!\n" ));

    } else {

        HWND hwndQueue = NULL;
        TQueue* pQueue = new TQueue(this, pInfo->_szPrinter, pInfo->_hEventClose);

        if( VALID_PTR( pQueue )){

            //
            // don't keep weak refs...
            //
            pQueue->vIncRef(); 

            if( pQueue->bInitialize( pInfo->_hwndOwner,
                                     pInfo->_nCmdShow ) ){

                hwndQueue = pQueue->hwnd();
                ASSERT(hwndQueue);

            } else {

                if( pQueue->hwnd() ) {

                    DestroyWindow( pQueue->hwnd() );
                } 
            }

            //
            // don't need the reference from now on
            //
            pQueue->vDecRefDelete();

        } else {

            delete pQueue;

            //
            // !! LATER !!
            //
            // Put up error message.
            //
        }

        if( hwndQueue ){

            SetForegroundWindow( hwndQueue );
            ShowWindow( hwndQueue, SW_RESTORE );

        } else {

            if( pInfo->_hEventClose ) {

                // in case of failure, set the handle, otherwise the caller 
                // will keep waiting on it forever.
                SetEvent( pInfo->_hEventClose );
            }
        }
    }
    delete pInfo;
}

// very private worker proc
static DWORD WINAPI DefPrinterChanged_WorkerProc(LPVOID lpParameter)
{
    // call back into the folder cache to update the default printer by calling SHChangeNotify.
    TFolder::vDefaultPrinterChanged();
    return 0;
}

LRESULT
CALLBACK
TPrintLib::
lrQueueCreateWndProc(
    IN HWND hwnd,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch( uMsg )
    {
    case WM_SETTINGCHANGE:
        
        // push this work in background as it may hit back in the folder cache and 
        // this should not happen in the UI thread. ask shell to run this in bkgnd.
        // we don't really care if this fails, since that would mean that we are out
        // of resources.
        SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(DefPrinterChanged_WorkerProc),
            NULL, 0, 0, NULL, "printui.dll", 0);
        break;

    case WM_PRINTLIB_NEW:

        SPLASSERT( _pPrintLib );
        _pPrintLib->vHandleCreateQueue( (TInfo*)lParam );
        break;

    case WM_DESTROY_REQUEST:

        DestroyWindow( hwnd );
        break;

    case WM_DESTROY:
        SINGLETHREADRESET(UIThread);
        PostQuitMessage(0);
        break;

    default:
       return DefWindowProc( hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

/********************************************************************

    Public interface functions

********************************************************************/

VOID
vQueueCreateWOW64(
    IN HWND    hwndOwner,
    IN LPCTSTR pszPrinter,
    IN INT     nCmdShow,
    IN LPARAM  lParam
    )

/*++

Routine Description:

    WOW64 version. see vQueueCreate below.

Arguments:

    see vQueueCreate below.

Return Value:

--*/

{
    //
    // This function potentially may load the driver UI so we call a private API 
    // exported by winspool.drv, which will RPC the call to a special 64 bit surrogate 
    // process where the 64 bit driver can be loaded.
    //
    CDllLoader dll(TEXT("winspool.drv"));
    ptr_PrintUIQueueCreate pfnPrintUIQueueCreate = 
        (ptr_PrintUIQueueCreate )dll.GetProcAddress(ord_PrintUIQueueCreate);

    if( pfnPrintUIQueueCreate )
    {
        pfnPrintUIQueueCreate( hwndOwner, pszPrinter, nCmdShow, lParam );
    }
}

VOID
vQueueCreateNative(
    IN HWND    hwndOwner,
    IN LPCTSTR pszPrinter,
    IN INT     nCmdShow,
    IN LPARAM  lParam
    )

/*++

Routine Description:

    Native version. see vQueueCreate below.

Arguments:

    see vQueueCreate below.

Return Value:

--*/

{
    if( lstrlen( pszPrinter ) >= kPrinterBufMax ){

        DBGMSG( DBG_WARN, ( "vQueueCreate: printer name too long "TSTR"\n", pszPrinter ));

        iMessage( hwndOwner,
                  IDS_DESC,
                  IDS_ERR_BAD_PRINTER_NAME,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        return;
    }

    //
    // If this print queue is using the fax driver,
    // then launch the fax queue view.
    //
    if( bIsPrinterFaxDevice( pszPrinter ) )
    {
        vFaxQueueCreate( hwndOwner, pszPrinter, nCmdShow, lParam );
        return;
    }

    //
    // Bring up the win32 queue view.
    //
    vQueueCreateInternal( hwndOwner, pszPrinter, nCmdShow, lParam );
}

VOID
vQueueCreate(
    IN HWND    hwndOwner,
    IN LPCTSTR pszPrinter,
    IN INT     nCmdShow,
    IN LPARAM  lParam
    )

/*++

Routine Description:

    Creates a printer queue.

Arguments:

    lParam - TRUE => fModal.

Return Value:

--*/

{
    if( IsRunningWOW64() )
    {
        vQueueCreateWOW64( hwndOwner, pszPrinter, nCmdShow, lParam );
    }
    else
    {
        vQueueCreateNative( hwndOwner, pszPrinter, nCmdShow, lParam );
    }
}

VOID
vQueueCreateInternal(
    IN HWND    hwndOwner,
    IN LPCTSTR pszPrinter,
    IN INT     nCmdShow,
    IN LPARAM  lParam
    )
{
    TStatusB bSuccess;
    bSuccess DBGNOCHK = TRUE;
    HANDLE hEventClose = NULL;

    //
    // Attempt to find a duplicate queue window.
    //
    HWND prevhwnd;
    if( TQueue::bIsDuplicateWindow( hwndOwner, pszPrinter, &prevhwnd ) ){
        SetForegroundWindow( prevhwnd );
        ShowWindow( prevhwnd, SW_RESTORE );
        return;
    }

    //
    // Initialize TInfo and acquire the gpPrintLib.
    //
    TPrintLib::TInfo* pInfo = new TPrintLib::TInfo;

    if( !VALID_PTR( pInfo )){
        goto Fail;
    }

    //
    // If modal, send in an event to trigger when the window is closed.
    //
    if( lParam ){
        // create a manual reset event
        hEventClose = CreateEvent( NULL, TRUE, FALSE, NULL );
        if( !hEventClose ){
            goto Fail;
        }
    }

    lstrcpy( pInfo->_szPrinter, pszPrinter );
    pInfo->_nCmdShow = nCmdShow;
    pInfo->_hwndOwner = hwndOwner;
    pInfo->_hEventClose = hEventClose;

    //
    // Need to grab the critical section, since this call should
    // be reentrant.
    //
    {
        CCSLock::Locker CSL( *gpCritSec );

        TRefLock<TPrintLib> pPrintLib;
        bSuccess DBGCHK = TPrintLib::bGetSingleton(pPrintLib);

        //
        // Queue creation the first time just passes the TInfo to
        // a worker function that serves as the message pump.  If
        // gpPrintLib has been instantiated, then we'll post a message
        // and return immediately (freeing this thread).
        //
        // If gpPrintLib has not been instantiated, then we create the
        // singleton here.
        //

        if( bSuccess ){

            //
            // Acquire a reference to gpPrintLib so that
            // the pInfo can be posted without worrying about losing
            // gpPrintLib.  This reference will automatically be
            // release when pInfo is destroyed.
            //
            pInfo->PrintLib.vAcquire( pPrintLib.pGet() );

            //
            // Send a message to the UI thread to create a new window.
            // We want all queues to use the same UI thread.
            //

            DBGMSG( DBG_PUIINFO, ( "vQueueCreate: posted pInfo %x\n", pInfo ));
            bSuccess DBGCHK = PostMessage( pPrintLib->hwndQueueCreate(),
                                           WM_PRINTLIB_NEW,
                                           0,
                                           (LPARAM)pInfo );

        }
    }

Fail:

    if( bSuccess ){

        //
        // Success - check if needs to be modal.  If so, wait until
        // window is closed.
        //
        if( lParam ){
            WaitForSingleObject( hEventClose, INFINITE );
        }
    } else {

        //
        // Destroy the pInfo data.  This will automatically decrement
        // the reference count on gpPrintLib (if necessary).
        //
        delete pInfo;
        vShowResourceError( hwndOwner );
    }

    if( hEventClose ){
        CloseHandle( hEventClose );
    }

    return;
}


BOOL
bIsPrinterFaxDevice(
    IN LPCTSTR pszPrinter
    )
/*++

Routine Description:

    Determine if this printer is a fax device.

Arguments:


Return Value:

--*/

{
    TStatusB    bStatus;
    BOOL        bReturn     = FALSE;
    DWORD       dwLastError = ERROR_SUCCESS;
    HANDLE      hPrinter    = NULL;

    bStatus DBGCHK = OpenPrinter( (LPTSTR)pszPrinter, &hPrinter, NULL );

    if( bStatus )
    {
        PPRINTER_INFO_2 pInfo2  = NULL;
        DWORD           cbInfo2 = 0;

        //
        // Get the current printer info 2.
        //
        bStatus DBGCHK = VDataRefresh::bGetPrinter( hPrinter, 2, (PVOID*)&pInfo2, &cbInfo2 );

        if( bStatus )
        {
            if( !_tcscmp( pInfo2->pDriverName, FAX_DRIVER_NAME ) )
            {
                bReturn = TRUE;
            }

            //
            // Release the printer info 2 structure.
            //
            FreeMem( pInfo2 );
        }

        //
        // Close the printer handle.
        //
        ClosePrinter( hPrinter );

    }

    return bReturn;
}

VOID
vFaxQueueCreate(
    IN HWND    hwndOwner,
    IN LPCTSTR pszPrinter,
    IN INT     nCmdShow,
    IN LPARAM  lParam
    )
/*++

Routine Description:

    Creates a printer fax queue view.

Arguments:


Return Value:

--*/
{
    TStatusB bStatus;
    TString strParam;

    //
    // Build the command string.
    //
    bStatus DBGCHK = strParam.bCat(FAX_CLIENT_CONSOLE_IMAGE_NAME);
    if (bStatus)
    {
        //
        // Use our parents startup info.
        //
        STARTUPINFO StartupInfo;
        GetStartupInfo( &StartupInfo );

        PROCESS_INFORMATION ProcessInformation;

        //
        // Create the rundll32 process.
        //
        if (CreateProcess(NULL, (LPTSTR)(LPCTSTR)strParam, NULL, NULL, FALSE,
                          DETACHED_PROCESS, NULL, NULL, &StartupInfo, &ProcessInformation))
        {
            CloseHandle(ProcessInformation.hThread);
            CloseHandle(ProcessInformation.hProcess);
        }

        //
        // If we cannot create the process then the fax queue exe may not be on
        // this machine or in the path, if this happens we will fall back
        // and birng up the Dumb win32 queue view.
        //
        else
        {
            vQueueCreateInternal(hwndOwner, pszPrinter, nCmdShow, lParam);
        }
    }
}

BOOL
bPrintLibInit(
    VOID
    )

/*++

Routine Description:

    Initializes the print library.

Arguments:

Return Value:

--*/

{
    if( !VDSConnection::bStaticInitShutdown( ) )
    {
        return FALSE;
    }

    CAutoPtr<CCSLock> spFolderLock = new CCSLock;
    CAutoPtr<CCSLock> spCritSec = new CCSLock;
    CAutoPtr<CCSLock> spTrayLock = new CCSLock;
    CAutoHandleAccel shAccel = LoadAccelerators(ghInst, (LPCTSTR)MAKEINTRESOURCE(ACCEL_PRINTQUEUE));

    if( !shAccel || !spCritSec || !spFolderLock || !spTrayLock )
    {
        DBGMSG( DBG_WARN, ( "bPrintLibInit: globals creation failed %d\n", GetLastError( )));
        return FALSE;
    }

    WNDCLASS WndClass;

    WndClass.lpszClassName  = gszClassName;
    WndClass.style          = 0L;
    WndClass.lpfnWndProc    = (WNDPROC)&MGenericWin::SetupWndProc;
    WndClass.cbClsExtra     = 0;
    WndClass.cbWndExtra     = sizeof( TPrintLib* );
    WndClass.hInstance      = ghInst;
    WndClass.hIcon          = NULL;
    WndClass.hCursor        = LoadCursor( NULL, IDC_ARROW );  // NULL
    WndClass.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    WndClass.lpszMenuName   = MAKEINTRESOURCE( MENU_PRINTQUEUE );

    if( !RegisterClass(&WndClass) )
    {
        DBGMSG( DBG_WARN, ( "bInitPrintLib: RegisterClass failed %d\n", GetLastError( )));
        return FALSE;
    }

    ZeroMemory(&WndClass, sizeof(WndClass));

    WndClass.lpszClassName = gszQueueCreateClassName;
    WndClass.lpfnWndProc = TPrintLib::lrQueueCreateWndProc;
    WndClass.hInstance = ghInst;

    if( !RegisterClass(&WndClass) )
    {
        DBGMSG( DBG_WARN, ( "bInitPrintLib: RegisterClass 2 failed %d\n", GetLastError( )));
        return FALSE;
    }

    // everything seems to be OK here, initialize globals & detach the local objects
    TFolderList::gpFolderLock = spFolderLock.Detach();
    gpCritSec = spCritSec.Detach();
    gpTrayLock = spTrayLock.Detach();
    ghAccel = shAccel.Detach();

    gcxSmIcon = GetSystemMetrics( SM_CXSMICON );
    gcySmIcon = GetSystemMetrics( SM_CXSMICON );

    return TRUE;
}


/********************************************************************

    Private helper routines.

********************************************************************/


BOOL
TPrintLib::
bGetSingleton(
    TRefLock<TPrintLib> &RefLock
    )

/*++

Routine Description:

    Retrieves the singleton object, and stores it in the global.
    If the singleton has not been created, then it is instantiated
    here.

    Must be called in the critical section.

Arguments:

Return Value:

    TRUE = success (singleton exists), FALSE = fail.

Revision History:

    Lazar Ivanov Jul-2000 (rewrite)

--*/

{
    BOOL bRet = FALSE;

    // must be in the global CS.
    CCSLock::Locker lock(*gpCritSec);
    if( lock )
    {
        if( !_pPrintLib )
        {
            //
            // Initialize _pPrintLib
            //
            TPrintLib *pPrintLib = new TPrintLib();

            if( pPrintLib )
            {
                //
                // We don't want to hold weak reference while initializing.
                //
                pPrintLib->vIncRef();

                //
                // Perform the real initialization - create the UI thread, etc...
                //
                if( pPrintLib->bInitialize() && VALID_PTR(pPrintLib) )
                {
                    //
                    // Everything seems to be OK at this point. 
                    //
                    _pPrintLib = pPrintLib;
                    RefLock.vAcquire(_pPrintLib);
                }
                else
                {
                    //
                    // Something has failed, nobody (except us) should be holding ref to 
                    // pPrintLib at this point, so it will automatically go away when we dec 
                    // ref it.
                    //
                    DBGMSG(DBG_WARN, ("PrintLib.bCreateSingleton: Abnormal termination %d %d\n", pPrintLib, GetLastError()));
                }

                //
                // Release our own ref lock
                //
                pPrintLib->vDecRefDelete();
            }
        }
        else
        {
            //
            // Just acquire a ref to the object
            //
            RefLock.vAcquire(_pPrintLib);
        }
        
        // this would our measure for success
        bRet = (NULL != _pPrintLib);
    }
    else
    {
        // unable to enter the global CS -- this could be only
        // in the case where there is a contention and
        // the kernel is unable to allocate the semaphore
        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRet;
}

STATUS
TPrintLib::
xMessagePump(
    IN TPrintLib *pPrintLib
    )

/*++

Routine Description:

    Main message pump.  The printer windows are architected slightly
    differently than regular explorer windows: there is a single UI
    thread, and multiple worker threads.  This has two main advantages:

    1. Fewer threads even when many printer queues are open (assuming
       NT->NT connections).

    2. The UI virtually never hangs.

    It has this slight disadvantage that sometimes the main UI thread
    is busy (e.g., inserting 2,000 print jobs may take a few seconds)
    in which all print UI windows are hung.

Arguments:

    None.

Return Value:

    Win32 status code.

--*/

{
    MSG msg;
    TStatusB bSuccess;
    bSuccess DBGNOCHK = TRUE;

    //
    // Ensure that functions that must execute in the UI thread don't
    // execute elsewhere.
    //
    SINGLETHREAD(UIThread);

    //
    // Create our window to listen for Queue Creates.
    //
    pPrintLib->_hwndQueueCreate = CreateWindowEx(
                                       0,
                                       gszQueueCreateClassName,
                                       gszQueueCreateClassName,
                                       WS_OVERLAPPED,
                                       0,
                                       0,
                                       0,
                                       0,
                                       NULL,
                                       NULL,
                                       ghInst,
                                       NULL );

    if( !pPrintLib->_hwndQueueCreate ){
        bSuccess DBGCHK = FALSE;
    }

    SetEvent( pPrintLib->_hEventInit );

    if( !bSuccess ){
        return 0;
    }


    while( GetMessage( &msg, NULL, 0, 0 )){

        if( !TranslateAccelerator( ghwndActive,
                                   ghAccel,
                                   &msg )){
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }

    return (STATUS)msg.wParam;
}

VOID
TPrintLib::
vRefZeroed(
    VOID
    )
/*++

Routine Description:

    Virtual definition from class MRefCom.

    The reference count has reached zero; we should cleanup the
    object.  Immediately zero out gpPrintLib then post a message
    instructing it to destory itself.

Arguments:

Return Value:

--*/

{
    TPrintLib *pToDelete = NULL;
    {
        // must be in the global CS
        CCSLock::Locker lock(*gpCritSec);
        if (lock)
        {
            //
            // we need to make this additional check here since
            // somebody might have acquired a reference to us while
            // waiting in the critical section in which case we 
            // shouldn't go away.
            //
            if (0 == _cRef)
            {
                //
                // mark ourselves for destruction and zero out 
                // the global pointer.
                //
                pToDelete = this;
                _pPrintLib = NULL;
                SINGLETHREADRESET(UIThread);
            }
        }
        else
        {
            //
            // unable to enter the global CS -- this could be only
            // in the case where there is a contention and
            // the kernel is unable to allocate the semaphore.
            //
            // not much really we can do in this case except 
            // laving the object alive even if its RefCount 
            // is zero (i.e. leaking the object)
            //
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    if (pToDelete)
    {
        //
        // initiate shutdown. this may take a while since
        // it will require shutting down the background threads,
        // clear all pending work items, etc...
        //
        pToDelete->hDestroy();
    }
}

HRESULT
TPrintLib::
hDestroy(
    VOID
    )
/*++

Routine Description:

    call when the object is marked for destruction
    no further access beyond this point.

Arguments:

    None

Return Value:

    Standard COM error handling

--*/
{
    if (bValid())
    {
        PostMessage(_hwndQueueCreate, WM_DESTROY_REQUEST, 0, 0);

        //
        // We can't immediately delete ourselves because we may have
        // pending work items.  Notify TThreadM that it should start
        // shutdown, then zero the global out so that no one else will
        // try to use us.
        //
        // When TThreadM has shut down the object will automatically go away.
        //
        TThreadM::vDelete();

        // the object shouldn't be accessed beyond this point because
        // Unlock is decrementing the internal refcount and the object 
        // goes away. it may not go away immediately and wait some pending
        // work items to finish, but in general from now on we should 
        // consider ourselves dead.
        TThreadM::Unlock();
    }

    return S_OK;
}

/********************************************************************

    Safe Thread class

********************************************************************/

HANDLE
TSafeThread::
Create(
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, // pointer to thread security attributes
    DWORD                   dwStackSize,            // initial thread stack size, in bytes
    LPTHREAD_START_ROUTINE  lpStartAddress,         // pointer to thread function
    LPVOID                  lpParameter,        // argument for new thread
    DWORD                   dwCreationFlags,    // creation flags
    LPDWORD                 lpThreadId          // pointer to returned thread identifier
    )
{
    HANDLE hThread = NULL;

    //
    // Construct the thread info class.
    //
    CAutoPtr<TSafeThreadInfo> spThreadInfo = new TSafeThreadInfo;
    CAutoHandleNT shEventReady = CreateEvent(NULL, FALSE, FALSE, NULL);

    if( spThreadInfo && shEventReady )
    {

        //
        // Store the thread information.
        //
        spThreadInfo->lpStartAddress = lpStartAddress;
        spThreadInfo->lpParameter    = lpParameter;
        spThreadInfo->hInstance      = ghInst;
        spThreadInfo->hEventReady    = shEventReady;

        //
        // Start the thread to our routine.
        //
        DWORD dwThreadId;
        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)TSafeThread::Start,
                                static_cast<TSafeThreadInfo*>(spThreadInfo),
                                0,
                                &dwThreadId );

        if( hThread )
        {
            //
            // If success wait for the thread to start properly
            //
            WaitForSingleObject( shEventReady, INFINITE );

            //
            // The thread will adopt this object, so we release the ownership.
            //
            spThreadInfo.Detach(); 
        }
    }

    return hThread;
}

DWORD WINAPI
TSafeThread::
Start(
    PVOID pVoid
    )
{
    TSafeThreadInfo *pThreadInfo = (TSafeThreadInfo*)pVoid;
    HINSTANCE        hLibrary    = NULL;

    //
    // If valid instance passed then load the library again.
    //
    if( pThreadInfo->hInstance ){

        //
        // Get the DLL name to do the load.
        //
        TCHAR szDllName[MAX_PATH+1];
        if( GetModuleFileName( pThreadInfo->hInstance, szDllName, MAX_PATH ) ){
            DBGMSG( DBG_THREADM, ("Loading library " TSTR "\n", szDllName ) );
            hLibrary = LoadLibrary( szDllName );
        }
    }

    DBGMSG( DBG_THREADM, ("Thread Starting %x\n", pThreadInfo->lpStartAddress ) );

    if( pThreadInfo->hEventReady )
    {
        SetEvent( pThreadInfo->hEventReady );
    }

    pThreadInfo->lpStartAddress( pThreadInfo->lpParameter );

    DBGMSG( DBG_THREADM, ("Thread ending %x\n", pThreadInfo->lpStartAddress ) );

    //
    // Ensure we release the thread info.
    //
    delete pThreadInfo;

    //
    // If library was loaded then unload and exit the thread.
    //
    if( hLibrary ){
        DBGMSG( DBG_THREADM, ("Releasing library \n") );
        FreeLibraryAndExitThread( hLibrary, 0 );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\printer.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1998
All rights reserved.

Module Name:

    printer.cxx

Abstract:

    Handles object updates and notifications from the printing system.

Author:

    Albert Ting (AlbertT)  7-Nov-1994

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "notify.hxx"
#include "data.hxx"
#include "printer.hxx"

#if DBG
//#define DBG_PRNINFO                  DBG_INFO
#define DBG_PRNINFO                    DBG_NONE
#endif

/********************************************************************

    TPrinter functions.

********************************************************************/


STATUS
TPrinter::
sOpenPrinter(
    IN     LPCTSTR pszPrinter,
    IN OUT PDWORD pdwAccess,
       OUT PHANDLE phPrinter
    )

/*++

Routine Description:

    Opens printer for specified access.

Arguments:

    pszPrinter - Name of printer to open.  szNULL or NULL implies local server.

    pdwAccess - On entry, holds desired access (pointer to 0 indicates
        maximal access).  On successful exit, holds access granted.
        If the call fails, this value is undefined.

    phPrinter - Returns the open printer handle.  On failure, this value
        is set to NULL.

Return Value:

    STATUS - win32 error code or ERROR_SUCCESS if successful.

--*/

{
    STATUS Status = ERROR_SUCCESS;

    TStatusB bOpen( DBG_WARN,
                    ERROR_ACCESS_DENIED,
                    RPC_S_SERVER_UNAVAILABLE,
                    ERROR_INVALID_PRINTER_NAME );
    bOpen DBGNOCHK = FALSE;

    static const DWORD adwAccessPrinter[] = {
        PRINTER_ALL_ACCESS,
        PRINTER_READ,
        READ_CONTROL,
        0,
    };

    static const DWORD adwAccessServer[] = {
        SERVER_ALL_ACCESS,
        SERVER_READ,
        0,
    };

    PRINTER_DEFAULTS Defaults;
    Defaults.pDatatype = NULL;
    Defaults.pDevMode = NULL;

    if( pszPrinter && !pszPrinter[0] ){

        //
        // szNull indicates local server also; change it to
        // NULL since OpenPrinter only likes NULL.
        //
        pszPrinter = NULL;
    }

    //
    // Now determine whether we are opening a server or a printer.
    // This is very messy.  Look for NULL or two beginning
    // backslashes and none thereafter to indicate a server.
    //
    PDWORD pdwAccessTypes;

    if( !pszPrinter ||
        ( pszPrinter[0] == TEXT( '\\' ) &&
          pszPrinter[1] == TEXT( '\\' ) &&
          !_tcschr( &pszPrinter[2], TEXT( '\\' )))){

        pdwAccessTypes = (PDWORD)adwAccessServer;
    } else {
        pdwAccessTypes = (PDWORD)adwAccessPrinter;
    }

    if( *pdwAccess ){

        Defaults.DesiredAccess = *pdwAccess;

        bOpen DBGCHK = OpenPrinter( (LPTSTR)pszPrinter,
                                    phPrinter,
                                    &Defaults );

        if( !bOpen ){
            Status = GetLastError();
        }
    } else {

        //
        // If no access is specified, then attempt to retrieve the
        // maximal access.
        //
        UINT i;

        for( i = 0; !bOpen && pdwAccessTypes[i]; ++i ){

            Defaults.DesiredAccess = pdwAccessTypes[i];

            bOpen DBGCHK = OpenPrinter( (LPTSTR)pszPrinter,
                                        phPrinter,
                                        &Defaults );

            if( bOpen ){

                //
                // Return the access requested by the successful OpenPrinter.
                // On failure, this value is 0 (*pdwAccess undefined).
                //
                *pdwAccess = pdwAccessTypes[i];
                break;
            }

            Status = GetLastError();

            if( ERROR_ACCESS_DENIED != Status )
                break;
        }
    }

    if( !bOpen ){
        SPLASSERT( Status );
        *phPrinter = NULL;
        return Status;
    }

    SPLASSERT( *phPrinter );

    return ERROR_SUCCESS;
}

BOOL
TPrinter::
bSyncRefresh(
    VOID
    )
{
    STATEVAR StateVar = TPrinter::kExecRefreshAll;
    BOOL bTriedOpen = FALSE;


    while( StateVar ){

        DBGMSG( DBG_TRACE, ( "Printer.bSyncRefresh now >> %x %x\n", this, StateVar ));

        if( StateVar & ( kExecDelay | kExecError )){

            if( bTriedOpen ){

                svClose( kExecClose );
                return FALSE;
            }
            StateVar &= ~( kExecDelay | kExecError );
        }

        if( StateVar & kExecReopen ){

            StateVar = svReopen( StateVar );

            //
            // Only try reopening the printer once.
            //
            bTriedOpen = TRUE;

        } else if( StateVar & kExecRequestExit ){

            StateVar = svRequestExit( StateVar );

        } else if( StateVar & kExecNotifyStart ){

            StateVar = svNotifyStart( StateVar );

        } else if( StateVar & kExecRefreshAll ){

            StateVar = svRefresh( StateVar );

        } else {

            DBGMSG( DBG_ERROR,
                    ( "Printer.bSyncRefresh: Unknown command %x %x\n",
                      this, StateVar ));
            return FALSE;
        }

        DBGMSG( DBG_EXEC, ( "Printer.bSyncRefresh: %x return state %x\n", this, StateVar ));
    }

    return TRUE;
}

/********************************************************************

    Creation and deletion for clients

********************************************************************/

TPrinter*
TPrinter::
pNew(
    IN MPrinterClient* pPrinterClient,
    IN LPCTSTR pszPrinter,
    IN DWORD dwAccess
    )

/*++

Routine Description:

    Create the printer object.  Clients should call this routine
    instead of the ctr for printers.

    Called from UI thread only.

Arguments:

    pPrinterClient - UI Client that stores info, generally the queue.

    pszPrinter - Printer to be opened.

    dwAccess - Access level requested.

Return Value:

    TPrinter*, NULL = failure (call GetLastError()).

--*/

{
    SPLASSERT( pszPrinter );

    TPrinter* pPrinter = new TPrinter( pPrinterClient,
                                       pszPrinter,
                                       dwAccess );

    if( !VALID_PTR( pPrinter )){

        delete pPrinter;
        return NULL;
    }

    DBGMSG( DBG_PRNINFO,
            ( "Printer.pNew: returned %x for "TSTR" %d\n",
              pPrinter, DBGSTR( pszPrinter ), dwAccess ));

    return pPrinter;
}

VOID
TPrinter::
vDelete(
    VOID
    )

/*++

Routine Description:

    Mark the printer object for deletion.

    Called from UI thread only.

Arguments:

Return Value:

Notes:

    When the printer object is marked for deletion, the object
    will delete itself when there are no more commands left
    to be processed.

    Called from UI thread only.

--*/

{
    {
        CCSLock::Locker CSL( *gpCritSec );

        //
        // Disassociate the printer from the list view queue.  Must
        // be called inside critical section, since worker threads might
        // be trying to change state.
        //
        PrinterGuard._pPrinterClient = NULL;
    }

    //
    // Mark ourselves for deletion by adding the REQUESTEXIT job.  This
    // will allow the currently queued jobs to execute.
    //
    // Also note that bJobAdd is guarenteed to return TRUE for this
    // EXIT request.  vExecExitComplete may be called now, or when
    // the current job has completed.
    //
    _pPrintLib->bJobAdd( this, kExecRequestExit );
}

/********************************************************************

    Internal private functions for creation and destruction.  Outside
    clients should use pNew and vDelete.

********************************************************************/

TPrinter::
TPrinter(
    IN MPrinterClient* pPrinterClient,
    IN LPCTSTR pszPrinter,
    IN DWORD dwAccess
    ) : _pData( NULL ), 
        _dwAccess( 0 ), 
        _eJobStatusStringType( kMultipleJobStatusString )
/*++

Routine Description:

    Create the printer object.

    Called from UI thread only.

Arguments:

    pPrinterClient - MPrinterClient that wants the data.

    pszPrinter - Name of printer to open.

    dwAccess - Access required (0 == highest access level).

Return Value:

--*/

{
    ASSERT(pPrinterClient);
    UNREFERENCED_PARAMETER( dwAccess );

    TStatusB bStatus;
    bStatus DBGCHK = pPrinterClient->bGetPrintLib(_pPrintLib);

    if( bStatus ){

        //
        // Initialize ExecGuard.
        //
        ExecGuard._hPrinter = NULL;

        //
        // Initialize PrinterGuard.
        //
        PrinterGuard._hEventCommand = NULL;
        PrinterGuard._pPrinterClient = pPrinterClient;

        if( pszPrinter ){
            PrinterGuard._strPrinter.bUpdate( pszPrinter );
        }
    }

    //
    // _strPrinter is our bValid check.
    //
}

TPrinter::
~TPrinter(
    VOID
    )
{
    //
    // There shouldn't be any pending jobs in the command linked
    // list.
    //
    SPLASSERT( PrinterGuard.Selection_bEmpty( ));
    SPLASSERT( !ExecGuard._hPrinter );
    SPLASSERT( !PrinterGuard._hEventCommand );

    //
    // The pData may not be valid.  For example, if we close a printer
    // window right before the svNotifyStart, this pointer may be NULL.
    //
    if( _pData ){
        _pData->vDelete();
    }
}


VOID
TPrinter::
vExecExitComplete(
    VOID
    )

/*++

Routine Description:

    The exit request: cleanup ourselves, then delete everything.
    We may not be in the UI thread, but UIGuard is safe since we
    have already deleted the UI portion of this object.

Arguments:


Return Value:

--*/

{
    delete this;
}

/********************************************************************

    Command handling

    Add to the Command linked list any pending requests.

********************************************************************/

VOID
TPrinter::
vCommandQueue(
    IN TSelection* pSelection ADOPT
    )

/*++

Routine Description:

    Queue a command for execution.

Arguments:

    CommandType - Type of command, either PRINTER or JOB

    dwCommand - CommandType specific job DWORD

    Id - CommandType specific ID

Return Value:

--*/

{
    SINGLETHREAD(UIThread);
    SPLASSERT( pSelection );

    {
        //
        // Append to the list of work items.
        //
        CCSLock::Locker CSL( *gpCritSec );
        PrinterGuard.Selection_vAppend( pSelection );
    }

    if( _pPrintLib->bJobAdd( this, kExecCommand )){

        //
        // Command successfully queued, request a wakeup.
        //
        vCommandRequested();

        //
        // pSelection successfully adopted by PrinterGuard.Selection
        // linked list.  NULL it here so we don't free it.
        //
        pSelection = NULL;

    } else {

        DBGMSG( DBG_WARN,
                ( "Printer.vQueueCommand: Exec->bJobAdd failed %d\n",
                  GetLastError( )));

        vErrorStatusChanged( 1 );

        //
        // Delink the item if it is linked.
        //
        {
            CCSLock::Locker CSL( *gpCritSec );

            if( pSelection->Selection_bLinked( )){
                pSelection->Selection_vDelinkSelf();
            }
        }
    }

    //
    // Delete pSelection if not adopted by PrinterGuard.Selection.
    //
    delete pSelection;
}


VOID
TPrinter::
vCommandRequested(
    VOID
    )

/*++

Routine Description:

    A command was requested, so trigger PrinterGuard._hEventCommand.
    If the worker thread is polling, it will be asleep now.  By triggering
    this event, we can force an immediate retry.

Arguments:


Return Value:

--*/

{
    CCSLock::Locker CSL( *gpCritSec );

    if( PrinterGuard._hEventCommand ){
        SetEvent( PrinterGuard._hEventCommand );
    }
}

/********************************************************************

    Virtual functions for TExecWork.

    Executed from worker threads; must be multithread safe.

********************************************************************/

VOID
TPrinter::
vExecFailedAddJob(
    VOID
    )

/*++

Routine Description:

    Occurs when we can't add another job to TExec.

Arguments:


Return Value:

--*/

{
    //
    // !! LATER !!
    //
    // Tune this error.  1 is not a good error...
    //
    vErrorStatusChanged( 1 );
}

STATEVAR
TPrinter::
svExecute(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Very simple state machine.  We examine the bits of the DWORD and
    execute the appropriate action.  The more important bits are
    placed first so that they have priority.

    Not called from UI thread.

Arguments:

    StateVar - Current state of the Printer.

Return Value:

    Ending state of the printer.

--*/

{
    SINGLETHREADNOT(UIThread);

    DBGMSG( DBG_EXEC, ( "Printer.svExecute: %x Sequence begin.\n", this ));

    if( !StateVar ){
        return 0;
    }

    BOOL bTriedOpen = FALSE;

    while( StateVar ){

        DBGMSG( DBG_EXEC, ( "Printer.svExecute now >> %x %x\n", this, StateVar ));

        if( StateVar & kExecExit ){

            //
            // Quit case, return kExecExit to allow vExecExitComplete() to
            // run, which cleans up everything.
            //
            return kExecExit;

        } else if( StateVar & kExecError ){

            svClose( kExecClose );

            //
            // Don't do anymore work until the user hits refresh.
            //
            return 0;

#ifdef SLEEP_ON_MINIMIZE
        } else if( StateVar & kExecAwake ){

            StateVar = svAwake( StateVar );

        } else if( StateVar & kExecSleep && !( StateVar & kExecCommand )){

            //
            // Only go to sleep if we have no commands pending.
            //
            StateVar = svSleep( StateVar );
#endif
        } else if( StateVar & kExecDelay ){

            if( bTriedOpen ){
                StateVar = svDelay( StateVar );
            } else {
                StateVar &= ~kExecDelay;
            }

        } else if( StateVar & kExecReopen ){

            StateVar = svReopen( StateVar );

            //
            // Only try reopening the printer once.
            //
            bTriedOpen = TRUE;

        } else if( StateVar & kExecCommand ){

            StateVar = svCommand( StateVar );

        } else if( StateVar & kExecRequestExit ){

            StateVar = svRequestExit( StateVar );

        } else if( StateVar & kExecNotifyStart ){

            StateVar = svNotifyStart( StateVar );

        } else if( StateVar & kExecRefreshAll ){

            StateVar = svRefresh( StateVar );

        } else {

            DBGMSG( DBG_ERROR,
                    ( "Printer.svExecute: Unknown command %x %x\n",
                      this, StateVar ));
        }

        DBGMSG( DBG_EXEC, ( "Printer.svExecute %x return state %x\n", this, StateVar ));

        //
        // Get any pending work items so that we can process them
        // now.  This is necessary because we may have multiple jobs
        // that must execute before we close ourselves.
        //
        // Plus, if kExecExit was set while we were busy, then we
        // want to pick it up so we quit soon.
        //
        StateVar |= _pPrintLib->svClearPendingWork( this );

        DBGMSG( DBG_EXEC, ( "Printer.svExecute %x updated %x\n", this, StateVar ));
    }

    //
    // Clear the status bar panes.
    //
    vConnectStatusChanged( kConnectStatusNull );

    return 0;
}


STATEVAR
TPrinter::
svReopen(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Open or reopen the printer.

    Not called from the UI thread, since this may take a while.

    Note: _strPrinter does _not_ need to be guarded by PrinterGuard
    in this case since only ExecGuard threads write to it.  Since
    we are in ExecGuard now, there is no need to grab PrinterGuard.

Arguments:

Return Value:

--*/

{
    SINGLETHREADNOT(UIThread);

    //
    // Close if necessary.
    //
    svClose( kExecClose );

    //
    // Update status.
    //
    vConnectStatusChanged( kConnectStatusOpen );

    TCHAR szPrinter[kPrinterBufMax];
    LPTSTR pszPrinter = pszPrinterName( szPrinter );

    STATUS Status = TPrinter::sOpenPrinter( pszPrinter,
                                            &_dwAccess,
                                            &ExecGuard._hPrinter );
    if( Status ){

        //
        // Ensure hPrinter is NULL.
        //
        SPLASSERT( !ExecGuard._hPrinter );

        DBGMSG( DBG_WARN, ( "Printer.sOpen: failed to open %ws: %d\n",
                            DBGSTR( (LPCTSTR)PrinterGuard._strPrinter ),
                            Status ));

        //
        // If the error is invalid printer name, immediately punt
        // and don't retry unless the user requests a refresh.
        //
        // Do the same for access denied.  We'll get here only if
        // the spooler hasn't cached the printer.  If it has, then
        // this will succeed (since it's async), and the FFPCN will
        // fail.
        //
        CONNECT_STATUS ConnectStatus;

        switch( Status ){
        case ERROR_INVALID_PRINTER_NAME:

            ConnectStatus = kConnectStatusInvalidPrinterName;
            break;

        case ERROR_ACCESS_DENIED:

            ConnectStatus = kConnectStatusAccessDenied;
            break;

        default:

            ConnectStatus = kConnectStatusOpenError;
            break;
        }

        vConnectStatusChanged( ConnectStatus );
        return kExecError;

        //
        // !! POLICY !!
        //
        // Should we sleep, then retry, or just punt?
        // If we want to sleep then retry, we should return the
        // following state value.
        //
        // return StateVar | kExecDelay;
        //
    } 

    //
    // Read the SingleJobStatusString printer value.  This 
    // fix is for FAX support.  The fax software does not 
    // want multiple status strings tacked together with
    // '-' when a job error occurrs.
    //

    DWORD dwStatus;
    DWORD dwType    = REG_DWORD;
    DWORD dwValue   = 0;
    DWORD cbNeeded  = 0;

    dwStatus = GetPrinterData( ExecGuard._hPrinter,
                               (LPTSTR)gszUISingleJobStatus,
                               &dwType,
                               (LPBYTE)&dwValue,
                               sizeof( DWORD ),
                               &cbNeeded );                         

    //
    // Assume multiple job status string,  This is the default.
    //
    _eJobStatusStringType = kMultipleJobStatusString;

    //
    // If the printer data was fetched and the value read is one
    // of the known values then set the new status string type.
    //        
    if( dwStatus == ERROR_SUCCESS &&
        cbNeeded == sizeof( DWORD ) &&
        ( dwValue == kMultipleJobStatusString ||
          dwValue == kSingleJobStatusString ) )
    {
        _eJobStatusStringType = (EJobStatusString)dwValue;
    } 

    //
    // Success, start the notification process.
    //
    return (StateVar | kExecNotifyStart) & ~(kExecReopen | kExecDelay | kExecError);
}

STATEVAR
TPrinter::
svDelay(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    An error occurred.  Put a simple message in the status bar and sleep
    for a while.  We create a trigger event in case we want to abort
    the sleep and retry immediately.

    Not called from UI thread.

Arguments:

Return Value:

    StateVar - kExecDelay will be removed.

--*/

{
    SINGLETHREADNOT(UIThread);

    //
    // Create a handle event so that new commands will cause
    // us to immediately try and reopen.
    //
    HANDLE hEvent = CreateEvent( NULL,
                                 FALSE,
                                 FALSE,
                                 NULL );

    if( hEvent ){

        {
            CCSLock::Locker CSL( *gpCritSec );
            PrinterGuard._hEventCommand = hEvent;
        }

        //
        // Update status.
        //
        vConnectStatusChanged( kConnectStatusPoll );

        WaitForSingleObject( hEvent, kSleepRetry );

        {
            CCSLock::Locker CSL( *gpCritSec );
            PrinterGuard._hEventCommand = NULL;
        }
        CloseHandle( hEvent );

    } else {

        //
        // Failed to create event, just sleep for a bit.
        //
        Sleep( kSleepRetry );
    }

    //
    // !! LATER !!
    //
    // Use TSleepN to avoid using a thread while we are
    // sleeping.
    //
    return StateVar & ~kExecDelay;
}

STATEVAR
TPrinter::
svClose(
    IN STATEVAR StateVar
    )
{
    SINGLETHREADNOT(UIThread);

    svNotifyEnd( kExecNotifyEnd );

    if( ExecGuard._hPrinter && !ClosePrinter( ExecGuard._hPrinter )) {

        STATUS Status = GetLastError();

        DBGMSG( DBG_WARN, ( "Printer.sClose: failed to close %ws: %d\n",
                            DBGSTR( (LPCTSTR)PrinterGuard._strPrinter ),
                            Status ));
    }

    //
    // Reset the notifications count.
    //
    if( _pData ){

        INFO Info;
        Info.dwData = 0;
        vContainerChanged( kContainerClearItems, Info );

        _pData->vDelete();
        _pData = NULL;
    }

    ExecGuard._hPrinter = NULL;
    return StateVar & ( kExecExit | kExecCommand );
}


STATEVAR
TPrinter::
svCommand(
    IN STATEVAR StateVar
    )
{
    SINGLETHREADNOT(UIThread);

    BOOL bSuccess = TRUE;
    BOOL bReopen = FALSE;

    //
    // Update status.
    //
    vConnectStatusChanged( kConnectStatusCommand );

    while( bSuccess ){

        TSelection* pSelection;

        //
        // Get a single request.
        //
        {
            CCSLock::Locker CSL( *gpCritSec );

            pSelection = PrinterGuard.Selection_pHead();

            if( pSelection ){
                pSelection->Selection_vDelinkSelf();
            }
        }

        if( !pSelection ){

            //
            // Done with work.
            //
            break;
        }

        switch( pSelection->_CommandType ){
        case TSelection::kCommandTypeJob:
        {
            //
            // Need to do multiple SetJobs.
            //
            COUNT i;

            for( i=0; i < pSelection->_cSelected; ++i ){

                bSuccess = SetJob( ExecGuard._hPrinter,
                                   pSelection->_pid[i],
                                   0,
                                   NULL,
                                   pSelection->_dwCommandAction );
                if( !bSuccess ){
                    break;
                }

                //
                // Check if a refresh is pending and execute it.
                //
                StateVar |= _pPrintLib->svClearPendingWork( this );

                if( StateVar & kExecRefresh ){

                    //
                    // We need to check explicity for refreshes, since
                    // a ton of changes may come in at once, and
                    // we should keep the UI somewhat current.
                    //
                    StateVar = svRefresh( StateVar );
                }

            }
            break;
        }
        case TSelection::kCommandTypePrinter:

            bSuccess = SetPrinter( ExecGuard._hPrinter,
                                   0,
                                   NULL,
                                   pSelection->_dwCommandAction );

            break;

        case TSelection::kCommandTypePrinterAttributes:
            {
                //
                // First read the current printer info5 state. Then update
                // this structure with the new attribute the set the new 
                // attribute state.  Printer info 5 is a little more efficent
                // than using a printer info2.
                //
                PPRINTER_INFO_5 pInfo5  = NULL;
                DWORD           cbInfo5 = 0;

                bSuccess = VDataRefresh::bGetPrinter( ExecGuard._hPrinter, 5, (PVOID*)&pInfo5, &cbInfo5 );

                if( bSuccess )
                {
                    pInfo5->Attributes = pSelection->_dwCommandAction;

                    bSuccess = SetPrinter( ExecGuard._hPrinter, 5, (PBYTE)pInfo5, 0 );

                    FreeMem( pInfo5 );
                }
            }

            break;

        default:

            DBGMSG( DBG_WARN, 
                    ( "Printer.svCommand: unknown command %x %d %d\n", 
                    pSelection, pSelection->_CommandType, 
                    pSelection->_dwCommandAction ));
            break;
        }

        if( !bSuccess ){

            DBGMSG( DBG_WARN,
                    ( "Printer.svCommand: Type %d Command %d to hPrinter %x failed %d\n",
                      pSelection->_CommandType,
                      pSelection->_dwCommandAction,
                      ExecGuard._hPrinter,
                      GetLastError( )));
        }

        //
        // Free the pSelection.
        //
        delete pSelection;
    }

    if( bSuccess ){

        //
        // Successfully executed commands, clear error string
        // in status bar.
        //
        vErrorStatusChanged( ERROR_SUCCESS );

    } else {

        //
        // Currently we punt on the old command.  Should we requeue it?
        //

        //
        // An error occurred; bomb out of all.
        //
        STATUS dwError = GetLastError();
        SPLASSERT( dwError );

        vErrorStatusChanged( dwError );

        //
        // If we encountered an invalid handle, we should reopen
        // the printer.
        //
        if( dwError == ERROR_INVALID_HANDLE ){
            StateVar |= kExecReopen;
        }

        //
        // !! POLICY !!
        //
        // We don't re-execute jobs--delete any pending jobs.
        //
        {
            CCSLock::Locker CSL( *gpCritSec );

            TSelection* pSelection;
            TIter Iter;

            for( PrinterGuard.Selection_vIterInit( Iter ), Iter.vNext();
                 Iter.bValid(); ){

                pSelection = PrinterGuard.Selection_pConvert( Iter );
                Iter.vNext();

                pSelection->Selection_vDelinkSelf();
                delete pSelection;
            }
        }
    }

    return StateVar & ~kExecCommand;
}

STATEVAR
TPrinter::
svRequestExit(
    IN STATEVAR StateVar
    )
{
    //
    // Close up everything.
    //
    svClose( StateVar | kExecClose );

    //
    // kExecExit forces a cleanup.
    //
    return kExecExit;
}

STATEVAR
TPrinter::
svRefresh(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Refresh the printer queue.

Arguments:


Return Value:


--*/

{
    SINGLETHREADNOT(UIThread);

    //
    // If the printer has not been initialized, reopen it now.
    //
    if( !ExecGuard._hPrinter || !_pData ){
        return kExecReopen;
    }

    //
    // Get the printer name
    //
    TCHAR szPrinter[kPrinterBufMax];
    LPTSTR pszPrinter = pszPrinterName( szPrinter );

    //
    // Update state.
    //
    vConnectStatusChanged( kConnectStatusRefresh );

    //
    // _pData->svRefresh is responsible for calling pPrinter's
    // vItemChanged or pPrinter->vAllItemsChanged.
    //
    StateVar = _pData->svRefresh( StateVar );

    return StateVar;
}



STATEVAR
TPrinter::
svNotifyStart(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Start the notification process.

Arguments:

Return Value:

--*/

{
    SINGLETHREADNOT(UIThread);

    DBGMSG( DBG_NOTIFY,
            ( "Printer.svNotifyStart: %x %ws\n",
              this, DBGSTR( (LPCTSTR)PrinterGuard._strPrinter )));

    vConnectStatusChanged( kConnectStatusInitialize );

    //
    // If we have an extablished _pData (e.g., non-NULL), then just
    // pass along the request.
    //
    // If we don't have one yet, we need to create one.
    //
    StateVar = _pData ?
                   _pData->svNotifyStart( StateVar ) :
                   VData::svNew( this, StateVar, _pData );

    if( StateVar & kExecDelay ){

        //
        // Error occurred--if it's Access Denied, then fail.
        // This happens when the spooler caches the printer:
        // OpenPrinter succeeds even though the user has no access.
        // The first "real" action fails.
        //
        if( GetLastError() == ERROR_ACCESS_DENIED ){
            vConnectStatusChanged( kConnectStatusAccessDenied );
            return kExecError;
        }
    }

    //
    // If we succeeded, the kExecRegister will be set, so we can
    // register it then return.
    //
    if( StateVar & kExecRegister ){

        SPLASSERT( _pData );

        TStatus Status;
        Status DBGCHK = _pPrintLib->pNotify()->sRegister( _pData );

        if( Status != ERROR_SUCCESS ){

            //
            // Failed to register; delay then reopen printer.  We could
            // just try and re-register later, but this should be a very
            // rare event, so do the least amount of work.
            //
            DBGMSG( DBG_WARN,
                    ( "Printer.svNotifyStart: sRegister %x failed %d\n",
                      this, Status ));

            StateVar |= kExecDelay | kExecReopen;
        }

        //
        // No longer need to register.  In the future, if we need to
        // register, we will set the bit on again.
        //
        StateVar &= ~kExecRegister;

    } else {

        DBGMSG( DBG_TRACE,
                ( "Printer.svNotifyStart: %x pData->svNotifyStart failed %d %d\n",
                  this, GetLastError(), StateVar ));
    }

    return StateVar;
}


STATEVAR
TPrinter::
svNotifyEnd(
    IN STATEVAR StateVar
    )

/*++

Routine Description:

    Shut down the notification process.

    Note: _strPrinter does _not_ need to be guarded by PrinterGuard
    in this case since only ExecGuard threads write to it.  Since
    we are in ExecGuard now, there is no need to grab PrinterGuard.

Arguments:

Return Value:

--*/

{
    SINGLETHREADNOT(UIThread);
    DBGMSG( DBG_NOTIFY,
            ( "Printer.svNotifyEnd: %x %ws\n",
              this, DBGSTR( (LPCTSTR)PrinterGuard._strPrinter )));

    if( _pData ){
        return _pData->svNotifyEnd( StateVar );
    }

    return StateVar & ~kExecNotifyEnd;
}

/********************************************************************

    Status updates

********************************************************************/

VOID
TPrinter::
vErrorStatusChanged(
    IN DWORD dwStatus
    )

/*++

Routine Description:

    Error state of _user_ command failed.  (If the user executes a
    command then leaves, they want to know the result of the command.
    If we change this when we execute one of our own commands, the
    previous result is lost.)

Arguments:

    dwStatus - GetLastError() code.

Return Value:

--*/

{
    INFO Info;
    Info.dwData = dwStatus;

    vContainerChanged( kContainerErrorStatus, Info );
}


VOID
TPrinter::
vConnectStatusChanged(
    IN CONNECT_STATUS ConnectStatus
    )

/*++

Routine Description:

    The connection status of the printer changed (opening, intializing,
    refreshing, etc.).

Arguments:

    dwStatus - New IDS_* of connection status.

Return Value:

--*/

{
    INFO Info;
    Info.dwData = ConnectStatus;

    vContainerChanged( kContainerConnectStatus, Info );
}


/********************************************************************

    TPrinterClientRef

********************************************************************/

TPrinter::
TPrinterClientRef::
TPrinterClientRef(
    const TPrinter* pPrinter
    )
{
    CCSLock::Locker CSL( *gpCritSec );

    _pPrinterClient = pPrinter->PrinterGuard._pPrinterClient;

    if( !_pPrinterClient ){
        return;
    }

    _pPrinterClient->vIncRef();
}


TPrinter::
TPrinterClientRef::
~TPrinterClientRef(
    VOID
    )
{
    if( _pPrinterClient ){
        _pPrinterClient->cDecRef();
    }
}

/********************************************************************

    MDataClient definitions.

********************************************************************/

VOID
TPrinter::
vContainerChanged(
    CONTAINER_CHANGE ContainerChange,
    INFO Info
    )
{
    TPrinterClientRef PrinterClientRef( this );

    if( !PrinterClientRef.bValid( )){
        return;
    }

    switch( ContainerChange ){
    case kContainerServerName:
    case kContainerName:

        {
            CCSLock::Locker CSL( *gpCritSec );

            TStatusB bStatus;

            bStatus DBGCHK = ( ContainerChange == kContainerServerName ) ?
                PrinterGuard._strServer.bUpdate( Info.pszData ) :
                PrinterGuard._strPrinter.bUpdate( Info.pszData );

            if( !bStatus ){

                //
                // Failed, execute a refesh with delay.
                //
                ContainerChange = kContainerStateVar;
                Info.dwData = kExecDelay | kExecRefreshAll;
                goto Fail;
            }
        }

        PrinterClientRef.ptr()->vContainerChanged( kContainerName,
                                                   kInfoNull );
        break;

    default:

Fail:

        PrinterClientRef.ptr()->vContainerChanged( ContainerChange, Info );
        break;
    }
}

VOID
TPrinter::
vItemChanged(
    ITEM_CHANGE ItemChange,
    HITEM hItem,
    INFO Info,
    INFO InfoNew
    )
{
    if( PrinterGuard._pPrinterClient ){
        PrinterGuard._pPrinterClient->vItemChanged( ItemChange,
                                                    hItem,
                                                    Info,
                                                    InfoNew );
    }
}


VOID
TPrinter::
vSaveSelections(
    VOID
    )
{
    if( PrinterGuard._pPrinterClient ){
        PrinterGuard._pPrinterClient->vSaveSelections();
    }
}

VOID
TPrinter::
vRestoreSelections(
    VOID
    )
{
    if( PrinterGuard._pPrinterClient ){
        PrinterGuard._pPrinterClient->vRestoreSelections();
    }
}

BOOL
TPrinter::
bGetPrintLib(
    TRefLock<TPrintLib> &refLock
    ) const
{
    ASSERT(pPrintLib().pGet());
    if (pPrintLib().pGet())
    {
        refLock.vAcquire(pPrintLib().pGet());
        return TRUE;
    }
    return FALSE;
}


VDataNotify*
TPrinter::
pNewNotify(
    MDataClient* pDataClient
    ) const
{
    TPrinterClientRef PrinterClientRef( this );

    if( PrinterClientRef.bValid( )){
        return PrinterClientRef.ptr()->pNewNotify( pDataClient );
    }
    return NULL;
}

VDataRefresh*
TPrinter::
pNewRefresh(
    MDataClient* pDataClient
    ) const
{
    TPrinterClientRef PrinterClientRef( this );

    if( PrinterClientRef.bValid( )){
        return PrinterClientRef.ptr()->pNewRefresh( pDataClient );
    }
    return NULL;
}

LPTSTR
TPrinter::
pszPrinterName(
    OUT LPTSTR pszPrinterBuffer CHANGE
    ) const

/*++

Routine Description:

    Retrieves the fully qualified name of the printer (\\server\printer or
    just printer for local printers).

Arguments:

    pszPrinterBuffer - Uninitialized buffer that receives the printer name.
        Must be at least kPrinterBufMax in length.

Return Value:

    Pointer to name of printer (generally pointer to pszPrinterBuffer).

--*/

{
    pszPrinterBuffer[0] = 0;

    CCSLock::Locker CSL( *gpCritSec );

    //
    // If we have a server name in TPrinter, prepend it to the
    // printer name if it's different.  We could just always prepend
    // it, since localspl.dll correctly grabs it, but then the
    // title bar displays the fully qualified name.
    //
    if( ((LPCTSTR)PrinterGuard._strServer)[0] &&
        _pPrintLib->strComputerName( ) != PrinterGuard.strServer( )){

        lstrcpy( pszPrinterBuffer, PrinterGuard._strServer );

        //
        // We assume that the machine - printer separator
        // is always a backslash.
        //
        lstrcat( pszPrinterBuffer, TEXT( "\\" ));
    }

    lstrcat( pszPrinterBuffer, PrinterGuard._strPrinter );
    return pszPrinterBuffer;
}

LPTSTR
TPrinter::
pszServerName(
    OUT LPTSTR pszServerBuffer CHANGE
    ) const

/*++

Routine Description:

    Retrieves the fully qualified name of the server.  May be NULL
    for local servers.

Arguments:

    pszServerBuffer - Uninitialized buffer that receives the server name.
        Must be at least kServerMax in length.

Return Value:

    Pointer to name of printer (generally pointer to pszServerBuffer).

--*/

{
    LPTSTR pszServer = NULL;

    CCSLock::Locker CSL( *gpCritSec );

    //
    // If we have a server name that is different from gpPrintLib,
    // then return it.  Otherwise return NULL which indicates the
    // local server.
    //
    if( ((LPCTSTR)PrinterGuard._strServer)[0] &&
        _pPrintLib->strComputerName( ) != PrinterGuard.strServer( )){

        lstrcpy( pszServerBuffer, PrinterGuard._strServer );

        pszServer = pszServerBuffer;
    }

    return pszServer;
}

HANDLE
TPrinter::
hPrinter(
    VOID
    ) const

/*++

Routine Description:

    Return the handle to the common printer handle.  Note that
    the callee must not use any RPC calls that do not return in a
    timely fashion (like WPC or FFPCN that uses WPC).

Arguments:

Return Value:

--*/

{
    SINGLETHREADNOT(UIThread);
    return ExecGuard._hPrinter;
}

HANDLE
TPrinter::
hPrinterNew(
    VOID
    ) const

/*++

Routine Description:

    Returns a new printer handle.  hPrinter() returns a common one,
    this returns one that is new and orphaned.

Arguments:

Return Value:

    hPrinter - Must be ClosePrinter'd by callee().
    NULL - failure.

--*/

{
    TStatusB bStatus;
    LPTSTR pszPrinter;
    TCHAR szPrinter[kPrinterBufMax];
    HANDLE hPrinter;

    pszPrinter = pszPrinterName( szPrinter );

    if( pszPrinter && !pszPrinter[0] ){
        //
        // szNull indicates local server also; change it to
        // NULL since OpenPrinter only likes NULL.
        //
        pszPrinter = NULL;
    }

    bStatus DBGCHK = OpenPrinter( pszPrinter,
                                  &hPrinter,
                                  NULL );

    if( !bStatus ){
        return NULL;
    }

    return hPrinter;
}


/********************************************************************

    Default MPrinterClient definitions.

********************************************************************/

COUNT
MPrinterClient::
cSelected(
    VOID
    ) const
{
    DBGMSG( DBG_WARN, ( "PrinterClient.cSelected: unimplemented\n" ));
    return kInvalidCountValue;
}

HANDLE
MPrinterClient::
GetFirstSelItem(
    VOID
    ) const
{
    DBGMSG( DBG_WARN, ( "PrinterClient.GetFirstSelItem: unimplemented\n" ));
    return NULL;
}

HANDLE
MPrinterClient::
GetNextSelItem(
    HANDLE hItem
    ) const
{
    UNREFERENCED_PARAMETER( hItem );

    DBGMSG( DBG_WARN, ( "PrinterClient.GetNextSelItem: unimplemented\n" ));
    return NULL;
}

IDENT
MPrinterClient::
GetId(
    HANDLE hItem
    ) const
{
    UNREFERENCED_PARAMETER( hItem );

    DBGMSG( DBG_WARN, ( "PrinterClient.GetId: unimplemented\n" ));
    return kInvalidIdentValue;
}

VOID
MPrinterClient::
vSaveSelections(
    VOID
    )
{
}


VOID
MPrinterClient::
vRestoreSelections(
    VOID
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\propmgr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998
All rights reserved.

Module Name:

    PropMgr.cxx

Abstract:

    Property Sheet Manager 

Author:

    Steve Kiraly (SteveKi)  13-Feb-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "propmgr.hxx"

/********************************************************************

    All printer property windows.

********************************************************************/

TPropertySheetManager::
TPropertySheetManager(
    VOID
    ) : _bValid( TRUE ),
        _hWnd( NULL )
{
    DBGMSG( DBG_TRACE, ( "TPropertySheetManager ctor\n") );
    ZeroMemory( &_CPSUIInfo, sizeof( _CPSUIInfo ) );
}   

TPropertySheetManager::
~TPropertySheetManager(
    VOID
    ) 
{
    DBGMSG( DBG_TRACE, ( "TPropertySheetManager dtor\n") );
}

BOOL
TPropertySheetManager::
bValid(
    VOID
    )
{
    return _bValid;
}

//
// This is needed since compstui has a bug 
// where it returns either -1 or NULL for an 
// invalid handle.
//
BOOL
TPropertySheetManager::
bValidCompstuiHandle(
    IN LONG_PTR hHandle
    )
{
    return hHandle && hHandle != -1;  
}

/*++

Routine Name:

    bDisplayPages

Routine Description:

    Loads the compstui module and displays the pages.
    See \nt\public\oak\inc\compstui.h file for details

Arguments:

    HWND        - Handle to parent window.
    pResult     - The result returned from COMPSTUI

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TPropertySheetManager::
bDisplayPages(
    IN  HWND hWnd,
    OUT LONG *pResult
    )
{
    typedef LONG
    (APIENTRY *PF_COMPROPSHEETUI)(
        HWND            hWndOwner,
        PFNPROPSHEETUI  pfnPropSheetUI,
        LPARAM          lParam,
        LPDWORD         pResult
        );

    DWORD dwResult          = CPSUI_CANCEL;
    LONG lResult            = FALSE;
    BOOL bStatus            = FALSE;
    PF_COMPROPSHEETUI pfn   = NULL;    
    _hWnd                   = hWnd;

    DBGMSG( DBG_TRACE, ( "TPropertySheetManager bDisplayPages\n") );

    //
    // Load the library and get the entrypoint.
    //
    TLibrary lib( TEXT( COMMON_UI ) );

    //
    // Ensure the library was loaded and the
    // proc address was fetch with out errors.
    //
    if( !VALID_OBJ( lib ) ||
        !(pfn = (PF_COMPROPSHEETUI)lib.pfnGetProc( COMMON_PROPERTY_SHEETUI ) ) ){

        bStatus = FALSE;

    } else {

        //
        // Bring up the actual property sheets.
        //
        lResult = (*pfn)( _hWnd, 
                        CPSUIFunc, 
                        (LPARAM)this, 
                        &dwResult );

        //
        // Set return value if the the sheets failed
        // it is up to the derived class to capture its error value.
        //
        if( lResult <= 0 ){

            DBGMSG( DBG_ERROR, ( "Display Pages failed %d Result %d GLE %d.\n", lResult, dwResult, GetLastError() ) );
            bStatus = FALSE;

        } else {

            bStatus = TRUE;

            if( pResult )
            {
                // return the actual result from compstui
                *pResult = static_cast<LONG>(dwResult);
            }

        }
    }

    //
    // Return status.
    //
    return bStatus;

}

/********************************************************************

    Private member functions.

********************************************************************/

LONG
TPropertySheetManager::
lReasonInit(
    IN PPROPSHEETUI_INFO pCPSUIInfo,
    IN LPARAM lParam
    )
{
    LONG lResult = FALSE;

    pCPSUIInfo->UserData = lParam;

    //
    // Build the property sheets pages.
    //
    if( bBuildPages( pCPSUIInfo ) ){
        lResult = TRUE;
    }

    return lResult;
}

LONG
TPropertySheetManager::
lReasonGetInfoHeader(
    IN PPROPSHEETUI_INFO pCPSUIInfo, 
    IN PPROPSHEETUI_INFO_HEADER pPSUInfoHeader
    )
{
    LONG lResult = FALSE;

    //
    // Make a copy of the compstui entry point.  This is needed for 
    // future calls to compstui, like freeing pages etc.
    //
    CopyMemory( &_CPSUIInfo, pCPSUIInfo, sizeof( _CPSUIInfo ) );

    //
    // Set the property sheet info header.
    //
    if( bSetHeader( pCPSUIInfo, pPSUInfoHeader ) ){

        lResult = TRUE;
    }

    return lResult;
}

LONG
TPropertySheetManager::
lReasonSetResult(
    IN PPROPSHEETUI_INFO pCPSUIInfo, 
    IN PSETRESULT_INFO pSetResultInfo
    )
{
    return bSaveResult( pCPSUIInfo, pSetResultInfo );
}

LONG
TPropertySheetManager::
lReasonGetIcon( 
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    return dwGetIcon( pCPSUIInfo );
}

LONG
TPropertySheetManager::
lReasonDestroy( 
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    LONG lResult = FALSE;

    //
    // Release any sheet specific data.
    //                
    if( bDestroyPages( pCPSUIInfo ) ){
        pCPSUIInfo->UserData = NULL;
        lResult = TRUE;
    }

    return lResult;
}

/*++

Routine Name:

    CPSUIFunc

Routine Description:

    Callback function used by compstui.

Arguments:

    See \nt\public\oak\inc\compstui.h file

Return Value:

    TRUE success, FALSE error occurred.

--*/
LONG
CALLBACK
TPropertySheetManager::
CPSUIFunc(
    PPROPSHEETUI_INFO   pCPSUIInfo,
    LPARAM              lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TPropertySheetManager CPSUIFunc\n") );

    SPLASSERT ( pCPSUIInfo );

    LONG                    lResult     = -1;
    TPropertySheetManager   *pSheets    = NULL;

    //
    // Only valid common ui defined entry requests are acknowledged.
    //
    if( pCPSUIInfo ){

        switch( pCPSUIInfo->Reason ){

        case PROPSHEETUI_REASON_INIT:

            DBGMSG( DBG_TRACE, ( "TPropertySheetManager PROPSHEETUI_REASON_INIT\n") );
            pSheets = (TPropertySheetManager *)lParam;
            SPLASSERT( pSheets );
            lResult = pSheets->lReasonInit( pCPSUIInfo, lParam );
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:

            DBGMSG( DBG_TRACE, ( "TPropertySheetManager PROPSHEETUI_REASON_GET_INFO_HEADER\n") );
            pSheets = (TPropertySheetManager *)pCPSUIInfo->UserData;
            SPLASSERT( pSheets );
            lResult = pSheets->lReasonGetInfoHeader( pCPSUIInfo, (PPROPSHEETUI_INFO_HEADER)lParam );
            break;

        case PROPSHEETUI_REASON_SET_RESULT:

            DBGMSG( DBG_TRACE, ( "TPropertySheetManager PROPSHEETUI_REASON_SET_RESULT\n") );
            pSheets = (TPropertySheetManager *)pCPSUIInfo->UserData;
            SPLASSERT( pSheets );
            lResult = pSheets->lReasonSetResult( pCPSUIInfo, (PSETRESULT_INFO)lParam );
            break;

        case PROPSHEETUI_REASON_GET_ICON:

            DBGMSG( DBG_TRACE, ( "TPropertySheetManager PROPSHEETUI_REASON_GET_ICON\n") );
            pSheets = (TPropertySheetManager *)pCPSUIInfo->UserData;
            SPLASSERT( pSheets );
            lResult = pSheets->lReasonGetIcon( pCPSUIInfo );
            break;

        case PROPSHEETUI_REASON_DESTROY:

            DBGMSG( DBG_TRACE, ( "TPropertySheetManager PROPSHEETUI_REASON_DESTROY\n") );
            pSheets = (TPropertySheetManager *)pCPSUIInfo->UserData;
            SPLASSERT( pSheets );
            lResult = pSheets->lReasonDestroy( pCPSUIInfo );
            break;

        default:
            DBGMSG( DBG_TRACE, ( "TPropertySheetManager unknown common ui command.\n") );
            break;
        }
    }

    return lResult;
}

/********************************************************************

    Protected member functions, provided for non pure virtuals.  

********************************************************************/

/*++

Routine Name:

    dwGetIcon

Routine Description:

    Return the Icon this module is associated with.  If no icon is
    associated then a NULL can be returned.

Arguments:

   pCPSUIInfo - Pointer to commonui property sheet info header, 

Return Value:

    TRUE success, FALSE error occurred.

--*/
DWORD
TPropertySheetManager::
dwGetIcon(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TPropertySheetManager dwGetIcon\n") );
    UNREFERENCED_PARAMETER( pCPSUIInfo );
    return NULL;
}

/*++

Routine Name:

    bDestroyPages

Routine Description:

    Destroy any compstui specific data information.

Arguments:

   pCPSUIInfo - Pointer to commonui property sheet info header, 
   pSetResultInfo - Pointer to result info header

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TPropertySheetManager::
bDestroyPages(
    IN PPROPSHEETUI_INFO pPSUIInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TPropertySheetManager bDestroyPages\n") );
    UNREFERENCED_PARAMETER( pPSUIInfo );
    return TRUE;
}

/*++

Routine Name:

    bSaveResult

Routine Description:

    Save the result from the previous handler to our parent.

Arguments:

   pCPSUIInfo - Pointer to commonui property sheet info header, 
   pSetResultInfo - Pointer to result info header

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TPropertySheetManager::
bSaveResult( 
    IN PPROPSHEETUI_INFO pCPSUIInfo, 
    IN PSETRESULT_INFO pSetResultInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TPropertySheetManager bSaveResult\n") );
    pCPSUIInfo->Result = pSetResultInfo->Result;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\prndata.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    prndata.cxx

Abstract:

    Type safe printer data class

Author:

    Steve Kiraly (SteveKi)  24-Aug-1998

Revision History:

--*/
#include <precomp.hxx>
#pragma hdrstop

#include "prndata.hxx"

TPrinterDataAccess::
TPrinterDataAccess(
    IN LPCTSTR          pszPrinter,
    IN EResourceType    eResourceType,
    IN EAccessType      eAccessType
    )
{
    DBGMSG( DBG_TRACE, ("TPrinterDataAccess::TPrinterDataAccess\n") );

    InitializeClassVariables();

    PRINTER_DEFAULTS Access = {0, 0, PrinterAccessFlags( eResourceType, eAccessType ) };

    //
    // Null string indicate the local server.
    //
    pszPrinter = (pszPrinter && *pszPrinter) ? pszPrinter : NULL;

    if (OpenPrinter( const_cast<LPTSTR>( pszPrinter ), &m_hPrinter, &Access))
    {
        m_eAccessType = eAccessType;
    }
}

TPrinterDataAccess::
TPrinterDataAccess(
    IN HANDLE           hPrinter
    )
{
    DBGMSG( DBG_TRACE, ("TPrinterDataAccess::TPrinterDataAccess\n") );

    InitializeClassVariables();
    m_hPrinter          = hPrinter;
    m_bAcceptedHandle   = TRUE;
}

TPrinterDataAccess::
~TPrinterDataAccess(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ("TPrinterDataAccess::~TPrinterDataAccess\n") );

    if( !m_bAcceptedHandle && m_hPrinter )
    {
        ClosePrinter( m_hPrinter );
    }
}

BOOL
TPrinterDataAccess::
Init(
    VOID
    ) const
{
    return m_hPrinter != NULL;
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszValue,
    IN OUT  BOOL    &bData
    )
{
    return GetDataHelper( NULL, pszValue, kDataTypeBool, &bData, sizeof( BOOL ), NULL );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszValue,
    IN OUT  DWORD   &dwData
    )
{
    return GetDataHelper( NULL, pszValue, kDataTypeDword, &dwData, sizeof( DWORD ), NULL );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszValue,
    IN OUT  TString &strString
    )
{
    return GetDataStringHelper( NULL, pszValue, strString );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszValue,
    IN OUT  TString **ppstrString,
    IN OUT  UINT    &nItemCount
    )
{
    return GetDataMuliSzStringHelper( NULL, pszValue, ppstrString, nItemCount );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszValue,
    IN OUT  PVOID   pData,
    IN      UINT    nSize
    )
{
    return GetDataHelper( NULL, pszValue, kDataTypeStruct, pData, nSize, NULL );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN OUT  BOOL    &bData
    )
{
    return GetDataHelper( pszKey, pszValue, kDataTypeBool, &bData, sizeof( BOOL ), NULL );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN OUT  DWORD   &dwData
    )
{
    return GetDataHelper( pszKey, pszValue, kDataTypeDword, &dwData, sizeof( DWORD ), NULL );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN OUT  TString &strString
    )
{
    return GetDataStringHelper( pszKey, pszValue, strString );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN OUT  PVOID   pData,
    IN      UINT    nSize
    )
{
    return GetDataHelper( pszKey, pszValue, kDataTypeStruct, pData, nSize, NULL );
}

HRESULT
TPrinterDataAccess::
Get(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN OUT  TString **ppstrString,
    IN OUT  UINT    &nItemCount
    )
{
    return GetDataMuliSzStringHelper( pszKey, pszValue, ppstrString, nItemCount );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszValue,
    IN      BOOL    bData
    )
{
    return SetDataHelper( NULL, pszValue, kDataTypeBool, &bData, sizeof( BOOL ) );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszValue,
    IN      DWORD   dwData
    )
{
    return SetDataHelper( NULL, pszValue, kDataTypeDword, &dwData, sizeof( DWORD ) );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszValue,
    IN      TString &strString
    )
{
    return SetDataHelper( NULL,
                          pszValue,
                          kDataTypeString,
                          reinterpret_cast<PVOID>( const_cast<LPTSTR>( static_cast<LPCTSTR>( strString ) ) ),
                          (strString.uLen() + 1) * sizeof( TCHAR ) );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszValue,
    IN      PVOID   pData,
    IN      UINT    nSize
    )
{
    return SetDataHelper( NULL, pszValue, kDataTypeStruct, pData, nSize );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN      PVOID   pData,
    IN      UINT    nSize
    )
{
    return SetDataHelper( pszKey, pszValue, kDataTypeStruct, pData, nSize );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN      BOOL    bData
    )
{
    return SetDataHelper( pszKey, pszValue, kDataTypeBool, &bData, sizeof( BOOL ) );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN      DWORD   dwData
    )
{
    return SetDataHelper( pszKey, pszValue, kDataTypeDword, &dwData, sizeof( DWORD ) );
}

HRESULT
TPrinterDataAccess::
Set(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN      TString &strString
    )
{
    return SetDataHelper( pszKey,
                          pszValue,
                          kDataTypeString,
                          reinterpret_cast<PVOID>( const_cast<LPTSTR>( static_cast<LPCTSTR>( strString ) ) ),
                          (strString.uLen() + 1) * sizeof( TCHAR ) );
}

HRESULT
TPrinterDataAccess::
Delete(
    IN      LPCTSTR pszValue
    )
{
    return DeleteDataHelper( NULL, pszValue );
}

HRESULT
TPrinterDataAccess::
Delete(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue
    )
{
    return DeleteDataHelper( pszKey, pszValue );
}

HRESULT
TPrinterDataAccess::
GetDataSize(
    IN      LPCTSTR pszValue,
    IN      DWORD   dwType,
    IN      DWORD   &nSize
    )
{
    return GetDataSizeHelper( NULL, pszValue, dwType, &nSize );
}

VOID
TPrinterDataAccess::
RelaxReturnTypeCheck(
    IN      BOOL    bCheckState
    )
{
    m_bRelaxReturnedTypeCheck = bCheckState;
}

//
// Private functions.
//

VOID
TPrinterDataAccess::
InitializeClassVariables(
    VOID
    )
{
    m_hPrinter                  = NULL;
    m_eAccessType               = kAccessUnknown;
    m_bAcceptedHandle           = FALSE;
    m_bRelaxReturnedTypeCheck   = FALSE;
}

ACCESS_MASK
TPrinterDataAccess::
PrinterAccessFlags(
    IN EResourceType   eResourceType,
    IN EAccessType     eAccessType
    ) const
{
    static const DWORD adwAccessPrinter[] =
    {
        PRINTER_ALL_ACCESS,
        PRINTER_READ,
        0,
    };

    static const DWORD adwAccessServer[] =
    {
        SERVER_ALL_ACCESS,
        SERVER_READ,
        0,
    };

    DWORD   dwAccess    = 0;
    UINT    uAccessType = eAccessType > 3 ? 2 : eAccessType;

    switch( eResourceType )
    {
        case kResourceServer:
            dwAccess = adwAccessServer[uAccessType];
            break;

        case kResourcePrinter:
            dwAccess = adwAccessPrinter[uAccessType];
            break;

        case kResourceUnknown:
        default:
            break;
    }

    return dwAccess;
}

DWORD
TPrinterDataAccess::
ClassTypeToRegType(
    IN EDataType eDataType
    ) const
{
    static const DWORD adwRegTypes[] =
    {
        REG_DWORD,
        REG_DWORD,
        REG_SZ,
        REG_BINARY,
        REG_MULTI_SZ,
    };

    UINT uDataType = eDataType;

    return adwRegTypes[eDataType];
}

TPrinterDataAccess::EDataType
TPrinterDataAccess::
RegTypeToClassType(
    IN DWORD dwDataType
    ) const
{
    static const ClassTypeMap aClassMap[] =
    {
        {REG_DWORD,     kDataTypeBool},
        {REG_DWORD,     kDataTypeDword},
        {REG_SZ,        kDataTypeString},
        {REG_BINARY,    kDataTypeStruct}
    };

    EDataType eReturnDataType = kDataTypeUnknown;

    for( UINT i = 0; i < sizeof(aClassMap) / sizeof(ClassTypeMap); i++ )
    {
        if (aClassMap[i].Reg == dwDataType)
        {
            eReturnDataType = aClassMap[i].Class;
            break;
        }
    }

    return eReturnDataType;
}

HRESULT
TPrinterDataAccess::
GetDataSizeHelper(
    IN LPCTSTR      pszKey,
    IN LPCTSTR      pszValue,
    IN DWORD        dwType,
    IN LPDWORD      pdwNeeded
    )
{
    return GetDataHelper( pszKey,
                          pszValue,
                          RegTypeToClassType( dwType ),
                          NULL,
                          0,
                          pdwNeeded );
}

HRESULT
TPrinterDataAccess::
GetDataHelper(
    IN LPCTSTR      pszKey,
    IN LPCTSTR      pszValue,
    IN EDataType    eDataType,
    IN PVOID        pData,
    IN UINT         nSize,
    IN LPDWORD      pdwNeeded
    )
{
    DWORD   dwNeeded    = 0;
    DWORD   dwType      = ClassTypeToRegType( eDataType );
    DWORD   dwStatus    = ERROR_SUCCESS;

    SPLASSERT( pszValue );

    if (pszKey)
    {
#if _WIN32_WINNT >= 0x0500
        dwStatus = GetPrinterDataEx( m_hPrinter,
                                     const_cast<LPTSTR>( pszKey ),
                                     const_cast<LPTSTR>( pszValue ),
                                     &dwType,
                                     reinterpret_cast<PBYTE>( pData ),
                                     nSize,
                                     &dwNeeded );
#else
        dwStatus = ERROR_INVALID_PARAMETER;
#endif
    }
    else
    {
        dwStatus = GetPrinterData( m_hPrinter,
                                   const_cast<LPTSTR>( pszValue ),
                                   &dwType,
                                   reinterpret_cast<PBYTE>( pData ),
                                   nSize,
                                   &dwNeeded );
    }

    if (!m_bRelaxReturnedTypeCheck && dwType != ClassTypeToRegType( eDataType ))
    {
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    if (pdwNeeded && dwStatus == ERROR_MORE_DATA)
    {
        *pdwNeeded = dwNeeded;
        dwStatus = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32( dwStatus );
}

HRESULT
TPrinterDataAccess::
SetDataHelper(
    IN LPCTSTR      pszKey,
    IN LPCTSTR      pszValue,
    IN EDataType    eDataType,
    IN PVOID        pData,
    IN UINT         nSize
    )
{
    SPLASSERT( pszValue );
    SPLASSERT( pData );

    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwType   = ClassTypeToRegType( eDataType );

    if (pszKey)
    {
#if _WIN32_WINNT >= 0x0500

        dwStatus = SetPrinterDataEx( m_hPrinter,
                                     const_cast<LPTSTR>( pszKey ),
                                     const_cast<LPTSTR>( pszValue ),
                                     dwType,
                                     reinterpret_cast<PBYTE>( pData ),
                                     nSize );
#else
        dwStatus = ERROR_INVALID_PARAMETER;
#endif
    }
    else
    {
        dwStatus = SetPrinterData( m_hPrinter,
                                   const_cast<LPTSTR>( pszValue ),
                                   dwType,
                                   reinterpret_cast<PBYTE>( pData ),
                                   nSize );
    }

    //
    // SetPrinterData may return an error code that is successful but
    // not ERROR_SUCCESS.
    //
    if( dwStatus == ERROR_SUCCESS_RESTART_REQUIRED )
    {
        return MAKE_HRESULT( 0, FACILITY_WIN32, dwStatus );
    }

    return HRESULT_FROM_WIN32( dwStatus );
}

HRESULT
TPrinterDataAccess::
DeleteDataHelper(
    IN LPCTSTR      pszKey,
    IN LPCTSTR      pszValue
    )
{
    SPLASSERT( pszValue );

    DWORD dwStatus = ERROR_SUCCESS;

    if (pszKey)
    {
#if _WIN32_WINNT >= 0x0500

        SPLASSERT( !pszKey );

        dwStatus = DeletePrinterDataEx( m_hPrinter,
                                        const_cast<LPTSTR>( pszKey ),
                                        const_cast<LPTSTR>( pszValue ) );

#endif
    }
    else
    {
        dwStatus = DeletePrinterData( m_hPrinter,
                                      const_cast<LPTSTR>( pszValue ) );
    }

    return HRESULT_FROM_WIN32( dwStatus );

}

HRESULT
TPrinterDataAccess::
GetDataStringHelper(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN OUT  TString &strString
    )
{
    SPLASSERT( pszValue );

    DWORD nSize = 0;

    HRESULT hr = GetDataSizeHelper( pszKey, pszValue, REG_SZ, &nSize );

    if (SUCCEEDED( hr ))
    {
        auto_ptr<TCHAR> pData = new TCHAR[nSize+1];

        if (pData.get())
        {
            hr = GetDataHelper( pszKey, pszValue, kDataTypeString, pData.get(), nSize, NULL );

            if (SUCCEEDED( hr ))
            {
                hr = strString.bUpdate( pData.get() ) ? S_OK : E_FAIL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}


HRESULT
TPrinterDataAccess::
GetDataMuliSzStringHelper(
    IN      LPCTSTR pszKey,
    IN      LPCTSTR pszValue,
    IN OUT  TString **ppstrString,
    IN      UINT    &nItemCount
    )
{
    SPLASSERT( pszValue );
    SPLASSERT( ppstrString );

    //
    // Get the size of the multi-sz string.
    //
    DWORD nSize = 0;

    if( ppstrString )
    {
        *ppstrString = NULL;
    }

    HRESULT hr = GetDataSizeHelper( pszKey, pszValue, REG_MULTI_SZ, &nSize );

    if(SUCCEEDED(hr))
    {
        //
        // Allocate the multi-sz string buffer.
        //
        auto_ptr<TCHAR> pszMultiSzString = new TCHAR [nSize+1];

        if (pszMultiSzString.get())
        {
            //
            // Get the actual data now.
            //
            hr = GetDataHelper( pszKey, pszValue, kDataTypeStruct, pszMultiSzString.get(), nSize*sizeof(TCHAR), NULL );

            if( SUCCEEDED(hr) )
            {
                //
                // Count the number of strings.
                //
                nItemCount = 0;

                for( LPCTSTR psz = pszMultiSzString.get(); psz && *psz; psz += _tcslen( psz ) + 1 )
                {
                    nItemCount++;
                }

                //
                // Not much to do if there are no strings.
                //
                if( nItemCount )
                {
                    //
                    // Allocate an array of string objects.
                    //
                    *ppstrString = new TString[nItemCount];

                    if( *ppstrString )
                    {
                        //
                        // Copy the multi-sz string into the array strings.
                        //
                        UINT i = 0;
                        for( psz = pszMultiSzString.get(); psz && *psz; psz += _tcslen( psz ) + 1, i++ )
                        {
                            if( !(*ppstrString)[i].bUpdate( psz ) )
                            {
                                break;
                            }
                        }

                        //
                        // Set the return value.
                        //
                        hr = ( i != nItemCount ) ? E_FAIL : S_OK;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Something failed then abandon the whole
    // operation and relase the string and nuke the count.
    //
    if(FAILED(hr))
    {
        delete [] *ppstrString;
        *ppstrString = NULL;
        nItemCount = 0;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\procdlg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    F:\nt\private\windows\spooler\printui.pri\procdlg.cxx

Abstract:

    Print Processor dialog.

Author:

    Steve Kiraly (SteveKi)  11/10/95

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "procdlg.hxx"
#include "psetup.hxx"
#include "drvver.hxx"

/********************************************************************

    Print Processor Dialog class

********************************************************************/

/*++

Routine Name:

    TPrintProcessor

Routine Description:

    Contstucts the print processor dialog.

Arguments:

    hWnd                - Parent window handle
    strServerName       - Currnet printer server name
    strPrintProcessor   - Current print processor
    strDatatype         - Current datatype

Return Value:

    Nothing.  bValid() inidicated valid object.

--*/
TPrintProcessor::
TPrintProcessor(
    IN HWND     hWnd,
    IN LPCTSTR  pszServerName,
    IN TString  &strPrintProcessor,
    IN TString  &strDatatype,
    IN BOOL     bAdministrator
    ) : _hWnd( hWnd ),
        _pPrintProcessors( NULL ),
        _cPrintProcessors( 0 ),
        _hctlPrintProcessorList( 0 ),
        _hctlDatatypeList( 0 ),
        _bAdministrator( bAdministrator ),
        _bValid( FALSE ),
        _pszServerName( pszServerName )
{
    DBGMSG( DBG_TRACE, ( "TPrintProcessor::ctor\n") );
    DBGMSG( DBG_TRACE, ( "ServerName         = " TSTR "\n", DBGSTR( (LPCTSTR)pszServerName ) ) );
    DBGMSG( DBG_TRACE, ( "PrintProcessorName = " TSTR "\n", (LPCTSTR)strPrintProcessor ) );
    DBGMSG( DBG_TRACE, ( "DataType           = " TSTR "\n", (LPCTSTR)strDatatype ) );

    //
    // Update the string oobjects.
    //
    if( !_strPrintProcessor.bUpdate( strPrintProcessor ) ||
        !_strDatatype.bUpdate( strDatatype ) ){

        DBGMSG( DBG_WARN, ( "String update failed with %d\n", GetLastError() ) );
        return;
    }

    //
    // Do loading for this object.
    //
    if( !bLoad( ) ){
        return;
    }

    _bValid = TRUE;

}

/*++

Routine Name:

    ~TPrintProcessor

Routine Description:

    Destructs the print processor dialog.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TPrintProcessor::
~TPrintProcessor(
    )
{
    DBGMSG( DBG_TRACE, ( "TPrintProcessor::dtor\n") );

    FreeMem( _pPrintProcessors );
}

/*++

Routine Name:

    bValid

Routine Description:

    Returns valid object indicator.

Arguments:

    None.

Return Value:

    Nothing.

--*/
BOOL
TPrintProcessor::
bValid(
    VOID
    )
{
    return _bValid;
}

/*++

Routine Name:

    bDoModal

Routine Description:

    Start modal execution of dialog.

Arguments:

    None.

Return Value:

    TRUE dialog ok button chosen.
    FALSE cancel button chosen.

--*/
BOOL
TPrintProcessor::
bDoModal(
    VOID
    )
{
    //
    // Create a modal dialog.
    //
    return (BOOL)DialogBoxParam( ghInst,
                                 MAKEINTRESOURCE( TPrintProcessor::kResourceId ),
                                 _hWnd,
                                 MGenericDialog::SetupDlgProc,
                                 (LPARAM)this );
}

/*++

Routine Name:

    bSetUI

Routine Description:

    Sets the data on the dialog.

Arguments:

    None.

Return Value:

    TRUE data set on UI successfully.
    FALSE error occurred setting UI data.

--*/
BOOL
TPrintProcessor::
bSetUI(
    VOID
    )
{
    //
    // Create local copies of the control ID's this saves
    // some execution time and alot of typing.
    //
    _hctlPrintProcessorList = GetDlgItem( _hDlg, IDC_PRINT_PROCESSOR_LIST );
    _hctlDatatypeList       = GetDlgItem( _hDlg, IDC_PRINT_DATATYPE_LIST );

    //
    // Set the UI controls.
    //
    if( !_hctlPrintProcessorList ||
        !_hctlDatatypeList ||
        !bSetPrintProcessorList() ||
        !bSetDatatypeList() ||
        !bDataTypeAssociation( TRUE ) ){

        DBGMSG( DBG_WARN, ( "bSetUI failed %d\n", GetLastError( )));
        return FALSE;
    }

    //
    // If not an administrator disable the controls.
    //
    vEnableCtl( _hDlg, IDC_PRINT_PROCESSOR_LIST,    _bAdministrator );
    vEnableCtl( _hDlg, IDC_PRINT_DATATYPE_LIST,     _bAdministrator );
    vEnableCtl( _hDlg, IDC_SPOOL_DATATYPE,          _bAdministrator );
    vEnableCtl( _hDlg, IDOK,                        _bAdministrator );
    vEnableCtl( _hDlg, IDC_PRINT_PROCESSOR_DESC,    _bAdministrator );
    vEnableCtl( _hDlg, IDC_PRINT_PROCESSOR_TEXT,    _bAdministrator );
    vEnableCtl( _hDlg, IDC_PRINT_DATATYPE_TEXT,     _bAdministrator );

    return TRUE;
}

/*++

Routine Name:

    bReadUI

Routine Description:

    Reads the UI data back into the public members.

Arguments:

    None.

Return Value:

    TRUE data read ok.
    FALSE error reading UI data.

--*/
BOOL
TPrintProcessor::
bReadUI(
    VOID
    )
{
    UINT uSel;
    TCHAR szName[kPrinterBufMax];

    //
    // If we do not have administrator privilages.
    //
    if ( !_bAdministrator )
        return FALSE;

    //
    // Read the selected print proccessor form the list box.
    //
    uSel = ListBox_GetCurSel( _hctlPrintProcessorList );
    if(( uSel == LB_ERR ) ||
        ( ListBox_GetText( _hctlPrintProcessorList, uSel, szName ) == LB_ERR ) ||
        !_strPrintProcessor.bUpdate( szName )){

        DBGMSG( DBG_WARN, ( "Read print processor listbox failed %d\n", GetLastError( )));
        return FALSE;
    }

    //
    // Read the selected datatype form the list box.
    //
    uSel = ListBox_GetCurSel( _hctlDatatypeList );
    if(( uSel == LB_ERR ) ||
        ( ListBox_GetText( _hctlDatatypeList, uSel, szName ) == LB_ERR ) ||
        !_strDatatype.bUpdate( szName )){

        DBGMSG( DBG_WARN, ( "Read datatype listbox failed %d\n", GetLastError( )));
        return FALSE;
    }

    //
    // Trace message to display UI data.
    //
    DBGMSG( DBG_TRACE, ( "PrintProcessorName = " TSTR "\n", (LPCTSTR)strPrintProcessor() ) );
    DBGMSG( DBG_TRACE, ( "DataType           = " TSTR "\n", (LPCTSTR)strDatatype() ) );

    return TRUE;
}


/*++

Routine Name:

    bSetPrintProcessorList

Routine Description:

    Fills the print processors list box.

Arguments:

    None.

Return Value:

    TRUE list box fill successfully.
    FALSE if error occurred.

--*/
BOOL
TPrintProcessor::
bSetPrintProcessorList(
    VOID
    )
{
    //
    // Reset the list box in case we are called to refresh.
    //
    ListBox_ResetContent( _hctlPrintProcessorList );

    //
    // Build list of print processors.
    //
    UINT i;
    for( i = 0; i < _cPrintProcessors; i++ ){
        ListBox_InsertString( _hctlPrintProcessorList, -1, (LPARAM)_pPrintProcessors[i].pName );
        ListBox_SetItemData( _hctlPrintProcessorList, i, 0 );
    }


    //
    // Set the highlight on the current print processor.
    //
    UINT uSel;
    uSel = ListBox_FindString( _hctlPrintProcessorList, -1, _strPrintProcessor );
    uSel = ( uSel == LB_ERR ) ? 0 : uSel;
    ListBox_SetCurSel( _hctlPrintProcessorList, uSel );

    return TRUE;

}


/*++

Routine Name:

    bSetDatatypeList

Routine Description:

    Fills the datatype list box.

Arguments:

    None.

Return Value:

    TRUE list box fill successfully.
    FALSE if error occurred.

--*/
BOOL
TPrintProcessor::
bSetDatatypeList(
    VOID
    )
{
    BOOL                bStatus         = FALSE;
    TCHAR               pszPrintProcessorName[kPrinterBufMax];
    UINT                uSel;

    //
    // Get the currently selected print processor name.
    //
    uSel = ListBox_GetCurSel( _hctlPrintProcessorList );
    ListBox_GetText( _hctlPrintProcessorList, uSel, pszPrintProcessorName );

    //
    // Enumerate the data types.
    //
    DATATYPES_INFO_1   *pDatatypes      = NULL;
    DWORD               cDatatypes      = 0;
    bStatus = bEnumPrintProcessorDatatypes( (LPTSTR)_pszServerName,
                                    pszPrintProcessorName,
                                    1,
                                    (PVOID *)&pDatatypes,
                                    &cDatatypes );

    if( bStatus ){
        //
        // Reset the list box in case we are called to refresh.
        //
        ListBox_ResetContent( _hctlDatatypeList );

        //
        // Build list of datatypes.
        //
        UINT i;
        for( i = 0; i < cDatatypes; i++ ){
            ListBox_InsertString( _hctlDatatypeList, -1, (LPARAM)pDatatypes[i].pName );
        }
    }

    //
    // Clean up any allocated resources.
    //
    FreeMem( pDatatypes );

    //
    // Select the correct datatype for the slected print processor.
    //
    ListBox_SetCurSel( _hctlDatatypeList,
                        ListBox_GetItemData( _hctlPrintProcessorList,
                        ListBox_GetCurSel( _hctlPrintProcessorList ) ) );

    return bStatus;

}

/*++

Routine Name:

    bDataTypeAssociation

Routine Description:

    The currently selected datatype item is tracted for
    each print processor.  The print processor list box item
    data contains the index of its corresponding datatype.

Arguments:

    TRUE to select the highlight on the default datatype.
    FALSE to the association for the currently selected datatype.

Return Value:

    Always returns success

--*/
BOOL
TPrintProcessor::
bDataTypeAssociation(
    IN BOOL bSetDatatype
    )
{
    //
    // Set the highlight using the current datatype.
    //
    if( bSetDatatype ){

        //
        // Locate and select the index of the default datatype.  The
        // default datatype is the datatype string passed into this object.
        //
        UINT uSel;
        uSel = ListBox_FindString( _hctlDatatypeList, -1, _strDatatype );
        uSel = ( uSel == LB_ERR ) ? 0 : uSel;
        ListBox_SetCurSel( _hctlDatatypeList, uSel );
    }

    //
    // Get the currently selected print processor and set the item data
    // to associated selected data type.
    //
    ListBox_SetItemData( _hctlPrintProcessorList,
                        ListBox_GetCurSel( _hctlPrintProcessorList ),
                        ListBox_GetCurSel( _hctlDatatypeList ) );

    return TRUE;

}

/*++

Routine Name:

    bLoad

Routine Description:

    Gets the list of print processors.

Arguments:

    None.

Return Value:

    TRUE list box fill successfully.
    FALSE if error occurred.

--*/
BOOL
TPrintProcessor::
bLoad(
    VOID
    )
{

    //
    // Get the current driver / version.
    //
    DWORD dwDriverVersion = 0;
    if( !bGetCurrentDriver( _pszServerName, &dwDriverVersion ) ){

        DBGMSG( DBG_WARN, ( "bGetDriverVersion failed.\n" ) );
        return FALSE;
    }

    DBGMSG( DBG_TRACE, ( "Driver Version %d\n", dwDriverVersion ) );

    //
    // Convert the driver / version to spooler usable environment string.
    //
    TString strDriverEnv;
    if( !bGetDriverEnv( dwDriverVersion, strDriverEnv ) ){

        DBGMSG( DBG_WARN, ( "bGetDriverEnv failed.\n" ) );
        return FALSE;
    }

    DBGMSG( DBG_TRACE, ( "Driver Environment " TSTR "\n", (LPCTSTR)strDriverEnv ) );

    //
    // Enumerate the currently installed print processors.
    //
    BOOL bStatus;
    bStatus = bEnumPrintProcessors( (LPTSTR)_pszServerName,
                                    (LPTSTR)(LPCTSTR)strDriverEnv,
                                    1,
                                    (PVOID *)&_pPrintProcessors,
                                    &_cPrintProcessors );

    if( !bStatus ){

        DBGMSG( DBG_ERROR, ( "bEnumPrintProccessors failed = %d\n", GetLastError () ) );
        return FALSE;
    }

    return TRUE;

}

/*++

Routine Name:

    bHandleMesage

Routine Description:

    Dialog message handler.

Arguments:

    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam

Return Value:

    TRUE message was handled.
    FALSE message was not handled.

--*/
BOOL
TPrintProcessor::
bHandleMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    UNREFERENCED_PARAMETER( lParam );

    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_INITDIALOG:
        bSetUI( );
        bStatus = TRUE;
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        bStatus = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam )){

        //
        // Read back the UI data and indicate success.
        //
        case IDOK:
            bStatus = bReadUI();
            EndDialog( _hDlg, bStatus );
            break;

        //
        // Indicate cancel request.
        //
        case IDCANCEL:
            bStatus = TRUE;
            EndDialog( _hDlg, FALSE );
            break;

        //
        // Handle the print processor list change.
        //
        case IDC_PRINT_PROCESSOR_LIST:
            switch ( GET_WM_COMMAND_CMD( wParam, lParam ) ){

            case LBN_SELCHANGE:
                bSetDatatypeList();
                bStatus = TRUE;
                break;
            }
            break;

        //
        // Handle the data type list change.
        //
        case IDC_PRINT_DATATYPE_LIST:
            switch ( GET_WM_COMMAND_CMD( wParam, lParam ) ){

            case LBN_SELCHANGE:
                bDataTypeAssociation( FALSE );
                bStatus = TRUE;
                break;
            }
            break;

        default:
            bStatus = FALSE;
            break;
        }

    default:
        bStatus = FALSE;
        break;

    }

    return bStatus;
}


/*++

Routine Name:

    bEnumPrintProcessors

Routine Description:

    Enumerates the installed print processors.

Arguments:


Return Value:

    TRUE list box fill successfully.
    FALSE if error occurred.

--*/
BOOL
TPrintProcessor::
bEnumPrintProcessors(
    IN      LPTSTR pszServerName,
    IN      LPTSTR pszEnvironment,
    IN      DWORD dwLevel,
    OUT     PVOID *ppvBuffer,
    OUT     PDWORD pcReturned
    )
{
    DWORD dwNeeded;
    DWORD dwReturned;
    PBYTE pBuf = NULL;
    BOOL  bStatus = FALSE;

    //
    // First query spooler for installed print processors.
    //
    if ( !EnumPrintProcessors( pszServerName, pszEnvironment, dwLevel, NULL, 0, &dwNeeded, &dwReturned) ) {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
             ((pBuf = (PBYTE)AllocMem( dwNeeded )) == NULL) ||
             !EnumPrintProcessors( pszServerName,
                          pszEnvironment,
                          dwLevel,
                          pBuf,
                          dwNeeded,
                          &dwNeeded,
                          &dwReturned) ) {

            bStatus = FALSE;
        } else {
            bStatus = TRUE;
        }
    }

    //
    // If success copy back the data.
    //
    if( bStatus ){
        *ppvBuffer  = pBuf;
        *pcReturned = dwReturned;
    }

    return bStatus;
}

/*++

Routine Name:

    bEnumPrintProcessorDatatypes

Routine Description:

    Enumerates the print processors datatypes.

Arguments:


Return Value:

    TRUE list box fill successfully.
    FALSE if error occurred.

--*/
BOOL
TPrintProcessor::
bEnumPrintProcessorDatatypes(
    IN      LPTSTR pszServerName,
    IN      LPTSTR pszPrintProcessor,
    IN      DWORD dwLevel,
    OUT     PVOID *ppvBuffer,
    OUT     PDWORD pcReturned
    )
{
    DWORD dwNeeded;
    DWORD dwReturned;
    PBYTE pBuf = NULL;
    BOOL bStatus = FALSE;

    //
    // First query spooler for installed print processors.
    //
    if ( !EnumPrintProcessorDatatypes( pszServerName, pszPrintProcessor, dwLevel, NULL, 0, &dwNeeded, &dwReturned) ) {

        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
             ((pBuf = (PBYTE)AllocMem( dwNeeded )) == NULL) ||
             !EnumPrintProcessorDatatypes( pszServerName,
                          pszPrintProcessor,
                          dwLevel,
                          pBuf,
                          dwNeeded,
                          &dwNeeded,
                          &dwReturned) ) {

            bStatus = FALSE;
        } else {
            bStatus = TRUE;
        }
    }

    //
    // If success copy back the data.
    //
    if( bStatus ){
        *ppvBuffer  = pBuf;
        *pcReturned = dwReturned;
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\prtprop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    prtprop.cxx

Abstract:

    Holds Printer properties.

Author:

    Albert Ting (AlbertT)  15-Aug-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "lmerr.h"
#include "prshtp.h"
#include "time.hxx"
#include "psetup.hxx"
#include "drvsetup.hxx"
#include "instarch.hxx"
#include "portdlg.hxx"
#include "sepdlg.hxx"
#include "procdlg.hxx"
#include "portslv.hxx"
#include "driverif.hxx"
#include "driverlv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "propmgr.hxx"
#include "prtprops.hxx"
#include "drvsetup.hxx"
#include "archlv.hxx"
#include "detect.hxx"
#include "setup.hxx"
#include "tstpage.hxx"
#include "prtshare.hxx"
#include "drvver.hxx"
#include "docdef.hxx"
#include "persist.hxx"
#include "prndata.hxx"
#include "physloc.hxx"
#include "findloc.hxx"
#include <shgina.h>     // ILocalMachine, ILogonUser

#if DBG
//#define DBG_PROPSINFO                DBG_INFO
#define DBG_PROPSINFO                  DBG_NONE
#endif

/********************************************************************

    Message map used after a set printer call.

********************************************************************/

MSG_ERRMAP gaMsgErrMapSetPrinter[] = {
    ERROR_INVALID_PRINTER_STATE,    IDS_ERR_INVALID_PRINTER_STATE,
    NERR_DuplicateShare,            IDS_ERR_DUPLICATE_SHARE,
    ERROR_INVALID_SHARENAME,        IDS_ERR_INVALID_SHARENAME,
    ERROR_ALREADY_EXISTS,           IDS_ERR_DUPLICATED_DS_ITEM,
    ERROR_IO_PENDING,               IDS_ERR_LIST_IN_DIRECTORY,
    0, 0
};

/********************************************************************

    Forward Decl.

********************************************************************/

INT_PTR
WarningDlgProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

/********************************************************************

    Public interface.

********************************************************************/

VOID
vPrinterPropPagesWOW64(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN INT      nCmdShow,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    WOW64 version.

    see vPrinterPropPages below.

Arguments:

    see vPrinterPropPages below.

Return Value:

--*/

{
    //
    // This function potentially may load the driver UI so we call a private API 
    // exported by winspool.drv, which will RPC the call to a special 64 bit surrogate 
    // process where the 64 bit driver can be loaded.
    //
    CDllLoader dll(TEXT("winspool.drv"));
    ptr_PrintUIPrinterPropPages pfnPrintUIPrinterPropPages = 
        (ptr_PrintUIPrinterPropPages )dll.GetProcAddress(ord_PrintUIPrinterPropPages);

    if( pfnPrintUIPrinterPropPages )
    {
        pfnPrintUIPrinterPropPages( hwnd, pszPrinterName, nCmdShow, lParam );
    }
}

VOID
vPrinterPropPagesNative(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN INT      nCmdShow,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    Native version.

    see vPrinterPropPages below.

Arguments:

    see vPrinterPropPages below.

Return Value:

--*/

{
    BOOL    bModal          = FALSE;
    DWORD   dwSheetIndex    = (DWORD)-1;
    LPCTSTR pszSheetName    = NULL;

    //
    // If this page was launched by name then the lParam points to the tab name.
    //
    if( HIWORD( lParam ) )
    {
        pszSheetName = (LPCTSTR)lParam;
    }

    //
    // Only if the sheet is launched by index can optionaly be modal.
    //
    else
    {
        dwSheetIndex = LOWORD( lParam ) & 0x00FF;
        bModal       = LOWORD( lParam ) & 0xFF00;
    }

    (VOID)dwPrinterPropPagesInternal( hwnd,
                                      pszPrinterName,
                                      pszSheetName,
                                      dwSheetIndex,
                                      nCmdShow,
                                      bModal,
                                      NULL );

}

VOID
vPrinterPropPages(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN INT      nCmdShow,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    This function opens the property sheet of specified printer.

    We can't guarentee that this propset will perform all lengthy
    operations in a worker thread (we synchronously call things like
    ConfigurePort).  Therefore, we spawn off a separate thread to
    handle printer properties.

Arguments:

    hWnd        - Specifies the parent window for errors on creation.

    pszPrinter  - Specifies the printer name (e.g., "My HP LaserJet IIISi").

    nCmdShow    -

    lParam      - Specified either a sheet number or sheet name to open.  If the high
                  word of this parameter is non zero it is assumed that this parameter
                  is a pointer the name of the sheet to open.  Otherwize the this
                  parameter is the zero based index of which sheet to open.

Return Value:

--*/

{
    if( IsRunningWOW64() )
    {
        vPrinterPropPagesWOW64( hwnd, pszPrinterName, nCmdShow, lParam );
    }
    else
    {
        vPrinterPropPagesNative( hwnd, pszPrinterName, nCmdShow, lParam );
    }
}

/*++

Routine Description:

    This function opens the property sheet of specified printer.

    We can't guarentee that this propset will perform all lengthy
    operations in a worker thread (we synchronously call things like
    ConfigurePort).  Therefore, we spawn off a separate thread to
    handle printer properties.

Arguments:

    hWnd        - Specifies the parent window for errors on creation.

    pDataObject - Pointer to an IDataObject passed to my the caller.

Return Value:

    ERROR_SUCCESS UI displayed, ERROR_ACCESS_DENIED failure occurred not UI.

--*/

DWORD
dwPrinterPropPages(
    IN HWND         hwnd,
    IN IDataObject *pDataObject,
    IN PBOOL        pbDisplayed
    )
{
    FORMATETC           fmte            = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM           medium          = { TYMED_NULL, NULL, NULL };
    UINT                cfDsObjectNames = 0;
    LPDSOBJECTNAMES     pObjectNames    = NULL;
    DWORD               dwReturn        = ERROR_ACCESS_DENIED;
    TString             strName;

    //
    // Get the DS object clipboard format.
    //
    fmte.cfFormat = static_cast<USHORT>( RegisterClipboardFormat( CFSTR_DSOBJECTNAMES ) );

    //
    // Get the data from the provided IDataObject
    //
    if( SUCCEEDED(pDataObject->GetData(&fmte, &medium)) )
    {
        //
        // Fetch the object name
        //
        pObjectNames = (LPDSOBJECTNAMES)medium.hGlobal;

        if( pObjectNames )
        {
            for( UINT i = 0 ; i < pObjectNames->cItems ; i++ )
            {
                TStatusB bStatus;

                //
                // Get the Ds object path.
                //
                bStatus DBGCHK = strName.bUpdate( (LPTSTR)(((LPBYTE)pObjectNames)+pObjectNames->aObjects[i].offsetName) );

                if( bStatus )
                {
                    TStatus Status;

                    //
                    // Bring up printer properties.
                    //
                    Status DBGCHK = dwPrinterPropPages( hwnd, strName, NULL );

                    //
                    // Set the return value.
                    //
                    dwReturn = Status;
                }
            }
        }

        //
        // Release the storage medium.
        //
        ReleaseStgMedium( &medium );
    }

    return dwReturn;
}

/*++

Routine Description:

    This function opens the property sheet of specified printer.

    We can't guarentee that this propset will perform all lengthy
    operations in a worker thread (we synchronously call things like
    ConfigurePort).  Therefore, we spawn off a separate thread to
    handle printer properties.

Arguments:

    hWnd        - Specifies the parent window for errors on creation.

    pDataObject - Pointer to an IDataObject passed to my the caller.

Return Value:

    ERROR_SUCCESS UI displayed, ERROR_ACCESS_DENIED failure occurred not UI.

--*/

DWORD
dwPrinterPropPages(
    IN HWND         hwnd,
    IN LPCTSTR      pszDsPath,
    IN PBOOL        pbDisplayed
    )
{
    SPLASSERT( pszDsPath );

    VARIANT             Variant;
    TDirectoryService   Di;
    IADs               *pDsObject       = NULL;
    HRESULT             hr              = E_FAIL;
    DWORD               dwReturn        = ERROR_ACCESS_DENIED;

    //
    // Initialize the displayed flag.
    //
    if( pbDisplayed )
    {
        *pbDisplayed = FALSE;
    }

    if( VALID_OBJ( Di ) )
    {
        //
        // Get the ads object interface pointer.
        //
        hr = Di.ADsGetObject( const_cast<LPTSTR>( pszDsPath ),
                              IID_IADs,
                              reinterpret_cast<LPVOID*>( &pDsObject ) );

        if( SUCCEEDED( hr ) )
        {
            //
            // Initialize the variant for getting the object UNC property.
            //
            VariantInit(&Variant);

            //
            // Get the objects uNCName
            //
            hr = pDsObject->Get( SPLDS_UNC_NAME, &Variant );

            if( SUCCEEDED( hr ) && Variant.vt == VT_BSTR && Variant.bstrVal && Variant.bstrVal[0] )
            {
                VARIANT versionVariant;

                VariantInit(&versionVariant);

                //
                // Get the objects uNCName
                //
                hr = pDsObject->Get( TEXT("versionNumber"), &versionVariant );

                DBGMSG( DBG_TRACE, ( "dwPrinterPropPages: printerObject vesrion %d.\n", versionVariant.lVal ) );

                if( SUCCEEDED( hr ) && versionVariant.vt == VT_I4 && versionVariant.lVal >= 2 )
                {
                    //
                    // At this point we know we will display some UI, either the dialog or an error message.
                    //
                    if( pbDisplayed )
                    {
                        *pbDisplayed = TRUE;
                    }

                    //
                    // Attempt to display the dialog.
                    //
                    dwReturn = dwPrinterPropPagesInternal( hwnd, Variant.bstrVal, 0, 0, SW_SHOW, FALSE, pszDsPath );
                }
                else
                {
                    //
                    // If the caller has requested information as to wether we can display
                    // printer properties then indicate we cannot at this point, otherwise
                    // let the user know with a message box.
                    //
                    if( pbDisplayed )
                    {
                        dwReturn = ERROR_SUCCESS;
                    }
                    else
                    {
                        //
                        // Display an error message indicating that properties cannot be displayed.
                        //
                        iMessage( hwnd,
                                  IDS_ERR_PRINTER_PROP_TITLE,
                                  IDS_ERR_PRINTER_PROP_NONE,
                                  MB_OK|MB_ICONSTOP,
                                  kMsgNone,
                                  NULL );
                    }
                }

                //
                // Release the version variant.
                //
                VariantClear( &versionVariant );
            }

            //
            // Release the variant.
            //
            VariantClear( &Variant );
        }
    }

    //
    // Note this routine could fail and still display UI.
    // For example an an error message generated by printer properties
    // because the thread could not start.
    //
    return dwReturn;
}

/********************************************************************

    Private internal interface.

********************************************************************/

DWORD
dwPrinterPropPagesInternal(
    IN HWND         hwnd,
    IN LPCTSTR      pszPrinterName,
    IN LPCTSTR      pszSheetName,
    IN DWORD        dwSheetIndex,
    IN INT          nCmdShow,
    IN BOOL         bModal,
    IN LPCTSTR      pszDsPath
    )
{
    LPCTSTR pszServer;
    LPCTSTR pszPrinter;
    TCHAR szScratch[kPrinterBufMax];

    //
    // Split the printer name into its components.
    //
    vPrinterSplitFullName( szScratch,
                           pszPrinterName,
                           &pszServer,
                           &pszPrinter );

    //
    // Get the local machine name.
    //
    TString strMachineName;
    TStatusB bStatus;
    bStatus DBGCHK = bGetMachineName( strMachineName );

    //
    // If the server name matches this machine name then strip off the
    // server name form the printer name, when creating the singleton window.
    //
    if( !_tcsicmp( pszServer, strMachineName ) ) {
        pszPrinterName = pszPrinter;
    }

    TPrinterData* pPrinterData = new TPrinterData( pszPrinterName,
                                                   nCmdShow,
                                                   pszSheetName,
                                                   dwSheetIndex,
                                                   hwnd,
                                                   bModal,
                                                   pszDsPath );
    if( !VALID_PTR( pPrinterData )){
        goto Fail;
    }

    //
    // If lparam is greater than 64k then dialog is modal.
    //
    if( bModal ) {

        TPrinterProp::iPrinterPropPagesProc( pPrinterData );
        return ERROR_SUCCESS;

    }

    //
    // Create the thread which handles the UI.  vPrinterPropPages adopts
    // pPrinterData.
    //
    DWORD dwIgnore;
    HANDLE hThread;

    hThread = TSafeThread::Create( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)TPrinterProp::iPrinterPropPagesProc,
                                   pPrinterData,
                                   0,
                                   &dwIgnore );

    if( !hThread ){
        goto Fail;
    }

    CloseHandle( hThread );

    return ERROR_SUCCESS;

Fail:

    if( !pPrinterData ){

        vShowResourceError( hwnd );

    } else {

        iMessage( hwnd,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  IDS_ERR_PRINTER_PROP,
                  MB_OK|MB_ICONSTOP,
                  kMsgGetLastError,
                  NULL );
    }

    delete pPrinterData;

    return ERROR_ACCESS_DENIED;
}

/********************************************************************

    Worker thread that handles printer properties.

********************************************************************/

INT
TPrinterProp::
iPrinterPropPagesProc(
    IN TPrinterData* pPrinterData ADOPT
    )
{
    BOOL    bStatus = FALSE;
    INT     Status  = ERROR_SUCCESS;

    //
    // Register the link window class
    //
    if (LinkWindow_RegisterClass())
    {
        //
        // We are going to use ole.
        //
        CoInitialize( NULL );

        //
        // Increment our reference count.
        //
        pPrinterData->vIncRef();

        //
        // Register this windows with the shell's unique window handler.
        //
        bStatus = pPrinterData->bRegisterWindow( PRINTER_PIDL_TYPE_PROPERTIES );

        if( bStatus ){

            //
            // If the windows is already present.
            //
            if( pPrinterData->bIsWindowPresent() ){
                DBGMSG( DBG_TRACE, ( "iPrinterPropPagesProc: currently running.\n" ) );
                Status = ERROR_SUCCESS;
                bStatus = FALSE;
            }
        }

        if( bStatus ){

            //
            // Create the printer sheets and check if valid.
            //
            TPrinterPropertySheetManager *pPrinterSheets = new TPrinterPropertySheetManager( pPrinterData );

            if( pPrinterSheets ) {

                //
                // Save the pointer to the property sheet manager.
                //
                pPrinterData->pPrinterPropertySheetManager() = pPrinterSheets;

                //
                // Check if we have a valid object.
                //
                if( VALID_PTR( pPrinterSheets )) {

                    //
                    // Note: Display Pages will show any errors message.
                    //
                    bStatus = pPrinterSheets->bDisplayPages();

                } else {

                    vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
                    Status = GetLastError();
                }

            } else {

                vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
                Status = GetLastError();
            }
        }

        //
        // Ensure we release the printer data.
        //
        pPrinterData->cDecRef();

        //
        // Balance the CoInitalize
        //
        CoUninitialize();

        //
        // Unregister the link window class
        //
        LinkWindow_UnregisterClass(ghInst);
    }
    else
    {
        //
        // unable to register the link window class - this is fatal, so we just bail
        //
        DBGMSG(DBG_WARN, ("LinkWindow_RegisterClass() failed - unable to register link window class\n"));
        vShowResourceError(pPrinterData->hwnd());
    }

    return Status;
}

/********************************************************************

    TPrinterData.

********************************************************************/

TPrinterData::
TPrinterData(
    IN LPCTSTR      pszPrinterName,
    IN INT          nCmdShow,
    IN LPCTSTR      pszSheetName,
    IN DWORD        dwSheetIndex,
    IN HWND         hwnd,
    IN BOOL         bModal,
    IN LPCTSTR      pszDsPath
    ) : MSingletonWin( pszPrinterName, hwnd, bModal ),
        _pDevMode( NULL ),
        _bNoAccess( FALSE ),
        _bValid( FALSE ),
        _bErrorSaving( FALSE ),
        _uStartPage( dwSheetIndex ),
        _pszServerName( NULL ),
        _pPrinterPropertySheetManager( NULL ),
        _hPrinter( NULL ),
        _ePrinterPublishState( kUnInitalized ),
        _dwAttributes( 0 ),
        _dwPriority( 0 ),
        _dwStartTime( 0 ),
        _dwUntilTime( 0 ),
        _dwStatus( 0 ),
        _strStartPage( pszSheetName ),
        _bIsFaxDriver( FALSE ),
        _bHideSharingUI( FALSE ),
        _strDsPath( pszDsPath ),
        _eDsAvailableState( kDsUnInitalized ),
        _uMaxActiveCount( 0 ),
        _uActiveCount( 0 ),
        _dwAction( 0 ),
        _bGlobalDevMode( FALSE ),
        _strSheetName( pszSheetName ),
        _bDriverPagesNotLoaded( FALSE ),
        _bApplyEnableState( TRUE ),
        _bPooledPrinting( FALSE ),
        _bServerFullAccess( FALSE ),
        _hwndLastPageSelected( NULL )
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::ctor.\n" ) );

    //
    // Initialize the handle array.
    //
    memset( _hPages, 0, COUNTOF( _hPages ) );

    //
    // Initialize the page hwnd array.
    //
    memset( _hwndPages, 0, COUNTOF( _hwndPages ) );

    //
    // Validate the singleton window.
    //
    _bValid = MSingletonWin::bValid() && _strDsPath.bValid();

    //
    // Check whether it is the default printer state
    //
    _bDefaultPrinter = CheckDefaultPrinter( pszPrinterName ) == kDefault;

}

TPrinterData::
~TPrinterData(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::dtor.\n" ) );

    //
    // Release the printer property sheet manager.
    //
    delete _pPrinterPropertySheetManager;

    //
    // This may catch anyone trying to use the PropertySheetManager after destruction.
    //
    _pPrinterPropertySheetManager = NULL;

    //
    // Unload the printer data.
    //
    vUnload();

}

/*++

Routine Name:

    bRefZeroed

Routine Description:

    Called when the reference count drops to zero.

Arguments:

    Nothing.

Return Value:

    Nothing.

--*/
VOID
TPrinterData::
vRefZeroed(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::vRefZeroed.\n" ) );

    //
    // Since we are reference counting the printer data object
    // we know that it is safe to delete ourselves now.
    //
    delete this;
}

BOOL
TPrinterData::
bAdministrator(
    VOID
    )
{
    return _dwAccess == PRINTER_ALL_ACCESS;
}

BOOL
TPrinterData::
bLoad(
    VOID
    )

/*++

Routine Description:

    Load printer information.  This call can fail because of access
    denied, in which case only the security page should be added
    to the propset.

Arguments:

Return Value:

--*/

{
    //
    // Retrieve icons.
    //
    LoadPrinterIcons(_strPrinterName, &_shLargeIcon, &_shSmallIcon);

    SPLASSERT( _shLargeIcon );
    SPLASSERT( _shSmallIcon );

    //
    // Open the printer.
    //
    TStatusB bStatus( DBG_WARN, ERROR_ACCESS_DENIED );
    bStatus DBGNOCHK = FALSE;

    PPRINTER_INFO_2 pInfo2  = NULL;
    DWORD           cbInfo2 = 0;
    PPRINTER_INFO_7 pInfo7  = NULL;
    DWORD           cbInfo7 = 0;
    PPRINTER_INFO_8 pInfo8  = NULL;
    DWORD           cbInfo8 = 0;
    PPRINTER_INFO_9 pInfo9  = NULL;
    DWORD           cbInfo9 = 0;

    TStatus Status( DBG_WARN );
    _dwAccess = 0;

    //
    // Open the printer.
    //
    Status DBGCHK = TPrinter::sOpenPrinter( _strPrinterName,
                                            &_dwAccess,
                                            &_hPrinter );

    if( Status ){
        _hPrinter = NULL;
        goto Fail;
    }

    //
    // Gather the information.
    //
    bStatus DBGCHK = VDataRefresh::bGetPrinter( _hPrinter,
                                                2,
                                                (PVOID*)&pInfo2,
                                                &cbInfo2 );

    (VOID)_PrinterInfo.bUpdate( pInfo2 );

    if( !bStatus ){
        goto Fail;
    }

    //
    // If we are loading global document default data.
    //
    if( _bGlobalDevMode )
    {
        //
        // Get the global dev mode.
        //
        bStatus DBGCHK = VDataRefresh::bGetPrinter( _hPrinter, 8, (PVOID*)&pInfo8, &cbInfo8 );

        if( bStatus )
        {
            DBGMSG( DBG_TRACE, ("Info level 8\n") );

            pInfo2->pDevMode = pInfo8->pDevMode;
        }
    }
    else
    {
        //
        // Get the per user dev mode.
        //
        bStatus DBGCHK = VDataRefresh::bGetPrinter( _hPrinter, 9, (PVOID*)&pInfo9, &cbInfo9 );

        if( bStatus )
        {
            DBGMSG( DBG_TRACE, ("Info level 9\n") );

            pInfo2->pDevMode = pInfo9->pDevMode;
        }

        //
        // Ignore failure here, this allows printer properties
        // to work on a downlevel machine.
        //
        else
        {
            bStatus DBGNOCHK = TRUE;
        }
    }

    //
    // Make a copy of the devmode.
    //
    if( pInfo2->pDevMode ){

        COUNTB cbDevMode = pInfo2->pDevMode->dmSize + pInfo2->pDevMode->dmDriverExtra;

        _pDevMode = (PDEVMODE)AllocMem( cbDevMode );

        if( !_pDevMode ){
            DBGMSG( DBG_WARN, ( "PrinterData.bLoad: failed to alloc dm %d: %d\n", cbDevMode, GetLastError( )));

            bStatus DBGNOCHK = FALSE;
            goto Fail;
        }
        CopyMemory( _pDevMode, pInfo2->pDevMode, cbDevMode );
    }


    _dwAttributes   = pInfo2->Attributes;
    _dwPriority     = pInfo2->Priority;
    _dwStartTime    = pInfo2->StartTime;
    _dwUntilTime    = pInfo2->UntilTime;
    _dwStatus       = pInfo2->Status;

    //
    // Run through printer_info_2.
    // Check strings for allocation.
    //
    if( !_strPrinterName.bUpdate( pInfo2->pPrinterName ) ||
        !_strCurrentPrinterName.bUpdate( _strPrinterName ) ||
        !_strServerName.bUpdate( pInfo2->pServerName )   ||
        !_strShareName.bUpdate( pInfo2->pShareName )     ||
        !_strDriverName.bUpdate( pInfo2->pDriverName )   ||
        !_strComment.bUpdate( pInfo2->pComment )         ||
        !_strLocation.bUpdate( pInfo2->pLocation )       ||


        !_strPortName.bUpdate( pInfo2->pPortName )       ||
        !_strSepFile.bUpdate( pInfo2->pSepFile )         ||
        !_strPrintProcessor.bUpdate( pInfo2->pPrintProcessor ) ||
        !_strDatatype.bUpdate( pInfo2->pDatatype )){

        DBGMSG( DBG_WARN, ( "PrinterProp.bLoad: String update failed %x %d\n", this, GetLastError( )));

        bStatus DBGNOCHK = FALSE;
    }

    //
    // check whether pool printing is enabled
    //
    _bPooledPrinting = _PrinterInfo._bPooledPrinting;

    //
    // Make a pointer to the server name.  A Null pointer
    // indicates the local machine.
    //
    if( _strServerName.bEmpty() ){
        _pszServerName = NULL;
    } else {
        _pszServerName = (LPCTSTR)_strServerName;
    }

    //
    // Get the current environment string and version number.
    //
    if( !bGetCurrentDriver( _strServerName, &_dwDriverVersion ) ||
        !bGetDriverEnv( _dwDriverVersion, _strDriverEnv ) ){

        DBGMSG( DBG_WARN, ( "Get Driver version and environment failed.\n" ) );
        bStatus DBGNOCHK = FALSE;
        goto Fail;
    }

    DBGMSG( DBG_TRACE, ( "Driver Version %d Environment " TSTR "\n", _dwDriverVersion, (LPCTSTR)_strDriverEnv ) );

    if( bStatus )
    {
        //
        // Get special information about this print queue.
        //
        vGetSpecialInformation();

        //
        // Get the current DS printer state.
        //
        bStatus DBGNOCHK = VDataRefresh::bGetPrinter( _hPrinter,
                                                      7,
                                                      (PVOID*)&pInfo7,
                                                      &cbInfo7 );

        if( bStatus )
        {
            DBGMSG( DBG_TRACE, ("Info level 7 dwAction %x\n", pInfo7->dwAction ) );

            (VOID)_PrinterInfo.bUpdate( pInfo7 );

            bStatus DBGCHK = _strObjectGUID.bUpdate( pInfo7->pszObjectGUID );
            _dwAction = pInfo7->dwAction;
        }

        //
        // We do not fail the bLoad if we cannont get the info level 7 data.
        // This is necessary to support the downlevel case.
        //
        bStatus DBGNOCHK = TRUE;

    }

    if( bStatus )
    {
        //
        // Check whether the user has full priviledge to access the server, the return value
        // will be used when we are trying to install a printer driver
        //
        HANDLE hPrinter = NULL;
        DWORD dwAccess = SERVER_ALL_ACCESS;

        //
        // Open the printer.
        //
        TPrinter::sOpenPrinter( _strServerName,
                                &dwAccess,
                                &hPrinter );

        _bServerFullAccess = hPrinter ? TRUE : FALSE;

        if( hPrinter )
        {
            ClosePrinter( hPrinter );
        }
    }

Fail:
    FreeMem( pInfo2 );
    FreeMem( pInfo7 );
    FreeMem( pInfo8 );
    FreeMem( pInfo9 );

    //
    // If we've failed because access was denied, then return
    // success but set the bNoAccess flag.  This allows the
    // user to see the security tab.
    //
    if( !bStatus && ERROR_ACCESS_DENIED == GetLastError( )){
        _bNoAccess = TRUE;
        return TRUE;
    }
    return bStatus;
}

VOID
TPrinterData::
vUnload(
    VOID
    )

/*++

Routine Description:

    Free associated data in this, so that this can be freed or
    loaded again.

Arguments:

Return Value:

--*/

{
    DBGMSG( DBG_TRACE, ( "TPrinterData::vUnload.\n" ) );

    //
    // Release the deve mode.
    //
    FreeMem( _pDevMode );
    _pDevMode = NULL;

    //
    // Close the printer
    //
    if( _hPrinter ){
        ClosePrinter( _hPrinter );
        _hPrinter = NULL;
    }
}

BOOL
TPrinterData::
bSave(
    BOOL bUpdateDevMode
    )

/*++

Routine Description:

    Save the data store in this.

Arguments:

    bUpdateDevmode flag indicates we should update the devmode.

Return Value:

    TRUE success, FLASE error occurred.

--*/

{
    //
    // If bErrorSaving is set, then somewhere we had an error reading
    // from the dialogs.  This should be very rare.
    //
    if( bErrorSaving( ))
    {
        //
        // Tell the user that we can't save the dialogs.
        // Then just exit?
        //
        return FALSE;
    }

    //
    // Display the wait cursor setprinter may take awhile
    //
    TWaitCursor Cursor;

    //
    // Setup the INFO_2 structure.  First read it, modify it, then
    // free it.
    //
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    //
    // If we are updating the devmode.
    //
    if( bUpdateDevMode )
    {
        //
        // If we are updating the global devmode.
        //
        if( _bGlobalDevMode )
        {
            return bUpdateGlobalDevMode();
        }
        else
        {
            return bUpdatePerUserDevMode();
        }
    }

    //
    // If a printer info 2 change occurred do a set printer.
    //
    if( bCheckForChange( 2 ) )
    {
        TString         strNewName, strTemp;
        BOOL            bDriverHasChanged   = FALSE;
        PPRINTER_INFO_2 pInfo2              = NULL;
        DWORD           cbInfo2             = 0;

        bStatus DBGCHK = VDataRefresh::bGetPrinter( _hPrinter, 2, (PVOID*)&pInfo2, &cbInfo2 );

        if( bStatus )
        {
            // assume the default printer name
            strNewName.bUpdate(_strPrinterName);

            //
            // Check if the driver has changed.  If the driver has chaned then
            // the printer name may have to change if the current printer name
            // is a generated name i.e. similar to the driver name.
            //
            if( _tcsicmp( _strDriverName, _PrinterInfo._strDriverName ) )
            {
                //
                // Indicate the driver changed.
                //
                bDriverHasChanged = TRUE;

                //
                // Turn on BIDI since the spooler enables this if a
                // language monitor is present.  If it isn't it will
                // be ignored by the spooler.
                //
                _dwAttributes |= PRINTER_ATTRIBUTE_ENABLE_BIDI;

                //
                // Update the printer name if neccessary.
                //
                bStatus DBGCHK = bDriverChangedGenPrinterName(&strNewName);
            }

            //
            // If the attributes indicate to allways spool raw then the
            // datatype must also be raw else the printe will not print.
            //
            if( _dwAttributes & PRINTER_ATTRIBUTE_RAW_ONLY )
            {
                DBGMSG( DBG_TRACE, ( "Forcing datatype to raw.\n" ) );
                _strDatatype.bUpdate( _T("RAW") );
            }


            //
            // Transfer pPrinterData to pInfo2.
            //
            pInfo2->pPrinterName    = (LPTSTR)pGetAdjustedPrinterName(
                static_cast<LPCTSTR>(strNewName),
                strTemp);

            pInfo2->pShareName      = (LPTSTR)(LPCTSTR)_strShareName;
            pInfo2->pDriverName     = (LPTSTR)(LPCTSTR)_strDriverName;
            pInfo2->pComment        = (LPTSTR)(LPCTSTR)_strComment;
            pInfo2->pLocation       = (LPTSTR)(LPCTSTR)_strLocation;
            pInfo2->pPortName       = (LPTSTR)(LPCTSTR)_strPortName;
            pInfo2->pSepFile        = (LPTSTR)(LPCTSTR)_strSepFile;
            pInfo2->pPrintProcessor = (LPTSTR)(LPCTSTR)_strPrintProcessor;
            pInfo2->pDatatype       = (LPTSTR)(LPCTSTR)_strDatatype;

            pInfo2->Attributes      = _dwAttributes;
            pInfo2->Priority        = _dwPriority;
            pInfo2->StartTime       = _dwStartTime;
            pInfo2->UntilTime       = _dwUntilTime;

            //
            // Another piece of trivia: the security descriptor must be set
            // to NULL since it might not be the owner.
            //
            pInfo2->pSecurityDescriptor = NULL;

            if( bStatus )
            {
                //
                // Set the printer information.
                //
                bStatus DBGCHK = SetPrinter( _hPrinter, 2, (PBYTE)pInfo2, 0 );
            }

            //
            // Update the _strCurrentPrinterName here because it is needed 
            // to updated before calling bRefreshDriverPages() below.
            //
            if( bStatus )
            {
                //
                // Update the local printer info 2 copy ( needed for the apply button )
                //
                _PrinterInfo.bUpdate( pInfo2 );
                _bPooledPrinting = _PrinterInfo._bPooledPrinting;

                _strCurrentPrinterName.bUpdate( pInfo2->pPrinterName );
                _strPrinterName.bUpdate( pInfo2->pPrinterName );
            }

            //
            // Reload the driver pages.
            //
            if( bStatus && bDriverHasChanged )
            {
                //
                // We are about to insert/remove the dynamic pages - these are
                // the driver pages + shell extension pages, so we need to check 
                // if we are currently in one of them. If we are, then we have to 
                // switch to one of the static pages. It is not mandatory to switch 
                // to the General page one, but it seems reasonable. 
                //
                HWND hwndCurPage = PropSheet_GetCurrentPageHwnd(
                    pPrinterPropertySheetManager()->hGetParentHandle() );

                if( _hwndLastPageSelected != hwndCurPage )
                {
                    //
                    // If we are currently in one of the dynamic pages just switch to the
                    // general page.
                    //
                    PropSheet_SetCurSel( pPrinterPropertySheetManager()->hGetParentHandle(), NULL, 0 );
                }

                //
                // Turn on BIDI bit if it's needed. Update all the dwAttributes members
                // simultaneousely because otherwise the logic which enable/disable the 
                // Apply button will be broken.
                //
                if( bSupportBidi() )
                {
                    _dwAttributes               |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
                    pInfo2->Attributes          |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
                    _PrinterInfo._dwAttributes  |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
                }
                else
                {
                    _dwAttributes               &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
                    pInfo2->Attributes          &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
                    _PrinterInfo._dwAttributes  &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
                }

                //
                // Reload the driver pages.
                //
                bStatus DBGCHK = _pPrinterPropertySheetManager->bRefreshDriverPages();

                //
                // If the driver pages were loaded then, set the new title.
                //
                if( bStatus )
                {
                    _pPrinterPropertySheetManager->vRefreshTitle();
                }
                
                //
                // Recalc the property sheet size in case of
                // monolitic drivers insert a pages with
                // a non-standard size
                //
                PropSheet_RecalcPageSizes( pPrinterPropertySheetManager()->hGetParentHandle() );
            }
        }

        FreeMem( pInfo2 );
    }

    //
    // Update the DS properties if needed
    //
    if( bStatus && bCheckForChange( 7 ) && bIsDsAvailable() )
    {
        PPRINTER_INFO_7 pInfo7 = NULL;
        DWORD           cbInfo7 = 0;

        bStatus DBGCHK = VDataRefresh::bGetPrinter( _hPrinter, 7, (PVOID*)&pInfo7, &cbInfo7 );

        if( bStatus )
        {
            //
            // If we need to publish this printer into the directory.
            //
            switch ( ePrinterPublishState() )
            {
            case kPublish:

                if( _dwAttributes & PRINTER_ATTRIBUTE_SHARED )
                {
                    DBGMSG( DBG_TRACE, ( "Publish printer - Publish.\n" ) );

                    pInfo7->dwAction = DSPRINT_PUBLISH;

                    bStatus DBGCHK = SetPrinter( _hPrinter, 7, (PBYTE)pInfo7, 0 );
                }
                break;

            case kUnPublish:
                {
                    DBGMSG( DBG_TRACE, ( "Publish printer - UnPublish.\n" ) );

                    pInfo7->dwAction = DSPRINT_UNPUBLISH;

                    bStatus DBGCHK = SetPrinter( _hPrinter, 7, (PBYTE)pInfo7, 0 );
                }
                break;

            default:
                DBGMSG( DBG_TRACE, ( "Publish printer - NoAction.\n" ) );
                break;
            }

            //
            // If set printer failed with an any error remap the error
            // to a DS friendly message.  If the error is io pending the spooler
            // will publish in the background therefore we will silently fail.
            //
            if( !bStatus )
            {
                DBGMSG( DBG_TRACE, ( "SetPrinter Info 7 returned %d with %d\n", bStatus, GetLastError() ) );

                if( GetLastError() == ERROR_IO_PENDING )
                {
                    bStatus DBGNOCHK = TRUE;
                    pInfo7->dwAction |= DSPRINT_PENDING;
                    _dwAction |= DSPRINT_PENDING;

                }
                else
                {
                    SetLastError( ERROR_IO_PENDING );
                }
            }
            else
            {
                //
                // Set printer info 7 succeede with out an error, then clear
                // the pending status indicator bit in both our copy and
                // the previous copy.
                //
                pInfo7->dwAction &= ~DSPRINT_PENDING;
                _dwAction &= ~DSPRINT_PENDING;
            }

            if( bStatus )
            {
                //
                // Update the local printer info 7 copy ( needed for the apply button )
                //
                _PrinterInfo.bUpdate( pInfo7 );
            }

            FreeMem( pInfo7 );
        }
    }

    return bStatus;
}

LPCTSTR
TPrinterData::
pGetAdjustedPrinterName(
    IN  LPCTSTR pszPrinterName,
    OUT TString &strTempPrinterName
    ) const
/*++

Routine Description:

    This routine adjusts the printer name in the case of a masq printer or a
    network printer.  If the printer is a msaq printer or a network printer we must
    retain the current server name part of the name.  Preserving the name is necessary
    for the masq printer in     order to continue displaying the masq printer
    as a network connection.  The print folder code looks at the leading \\ to determine
    if the printer should be displayed as a network printer, it does this because
    reading the printers attributes is slow.

Arguments:

    Temp buffer where to store the new printer name, if this is a masq printer.

Return Value:

    Pointer to the adjusted printer name.  The name is not modified if this printer
    is not a masq printer.

--*/
{
    TStatusB bStatus;

    // if this is a masq printer do not change the name.
    if( _dwAttributes & PRINTER_ATTRIBUTE_NETWORK && _dwAttributes & PRINTER_ATTRIBUTE_LOCAL )
    {
        bStatus DBGCHK = strTempPrinterName.bUpdate(_strCurrentPrinterName);
    }
    else if( _dwAttributes & PRINTER_ATTRIBUTE_NETWORK )
    {
        // if this is a network printer then preserve the server name part of the name.
        LPCTSTR pszServer1 = NULL, pszPrinter1 = NULL;
        TCHAR szScratch1[kPrinterBufMax];

        LPCTSTR pszServer2 = NULL, pszPrinter2 = NULL;
        TCHAR szScratch2[kPrinterBufMax];

        // split the printer names into their components.
        vPrinterSplitFullName(szScratch1, _strCurrentPrinterName, &pszServer1, &pszPrinter1);
        vPrinterSplitFullName(szScratch2, pszPrinterName, &pszServer2, &pszPrinter2);

        // if we have wacks in the printer name then it's either an
        // invalid printer name or it's a connection to a masq printer
        // in which case we must revert to the original printer name.
        if( pszServer2 && _tcslen(pszServer2) )
        {
            bStatus DBGCHK = strTempPrinterName.bUpdate(_strCurrentPrinterName);
        }
        else
        {
            bStatus DBGCHK = strTempPrinterName.bUpdate(pszServer1) &&
                             strTempPrinterName.bCat(gszWack) &&
                             strTempPrinterName.bCat(pszPrinter2);
        }
    }
    else
    {
        // normal local printer, i.e. not a masq local printer then just use the name as is.
        bStatus DBGCHK = strTempPrinterName.bUpdate(pszPrinterName);
    }

    return strTempPrinterName;
}

BOOL
TPrinterData::
bDriverChangedGenPrinterName(
    TString *pstrNewName
    ) const
/*++

Routine Description:

    bDriverChangedGenPrinterName

Arguments:

    pstrNewName - pointer where to put the new name.

Return Value:

    TRUE success, FALSE failure.

--*/
{
    TStatusB bStatus;
    ASSERT(pstrNewName);

    //
    // Check if the printer name should change.  We change the printer name if
    // the driver name is a sub string of the current printer name, and it is
    // not a remote printer connection.  There is not an explicit check if it
    // is a remote printer connection since a remote printer connection will have
    // the \\machine\printer name and therefore will never match.
    //
    if( !_tcsnicmp( _strPrinterName, _PrinterInfo._strDriverName, _tcslen( _PrinterInfo._strDriverName ) ) )
    {
        TCHAR szNewName[kPrinterBufMax];

        //
        // Create a new unique printer name. 
        //
        if( NewFriendlyName( static_cast<LPCTSTR>( _strServerName ),
                             const_cast<LPTSTR>( static_cast<LPCTSTR>( _strDriverName ) ),
                             szNewName ) )
        {
            bStatus DBGCHK = pstrNewName->bUpdate( szNewName );
        }
        else
        {
            //
            // if NewFriendlyName fails that means the passed name is 
            // unique itself. i.e. in this case just use the passed 
            // name (the newly selected driver name)
            //
            bStatus DBGCHK = pstrNewName->bUpdate( _strDriverName );
        }
    }
    
    //
    // we didn't really updated the name - the default would be 
    // to use user's choice - i.e. _strPrinterName
    //
    if( 0 == pstrNewName->uLen() )
    {
        bStatus DBGCHK = pstrNewName->bUpdate( _strPrinterName );
    }

    return bStatus;
}

BOOL
TPrinterData::
bSupportBidi(
    VOID
    )

/*++

Routine Description:

    Check whether the current printer supports bidi.  Assumes there
    is a valid hPrinter available.

    Note: this returns false if it can't make the determination.

Arguments:

Return Value:

    TRUE - Bidi supported.
    FALSE - Failed or bidi not supported.

--*/

{
    BOOL bSupport = FALSE;

    PDRIVER_INFO_3  pInfo3  = NULL;
    DWORD           dwInfo3 = 0;

    //
    // Get the printer driver information.
    //
    if( VDataRefresh::bGetPrinterDriver( _hPrinter,
                                         (LPTSTR)(LPCTSTR)_strDriverEnv,
                                         3,
                                         (PVOID*)&pInfo3,
                                         &dwInfo3 )){

        bSupport = pInfo3->pMonitorName && pInfo3->pMonitorName[0];

        FreeMem( pInfo3 );
    }

    return bSupport;
}

TPrinterData::EPublishState
TPrinterData::
ePrinterPublishState(
    TPrinterData::EPublishState eNewPublishState
    )
/*++

Routine Description:

    Sets and Gets the publish state.

Arguments:

    None

Return Value:

    The current publish state.

--*/
{
    //
    // If the publish state is being set.
    //
    if( eNewPublishState != kUnInitalized )
    {
        _ePrinterPublishState = eNewPublishState;
    }
    else
    {
        //
        // If the printer publish state has not been initialized.
        //
        if( _ePrinterPublishState == kUnInitalized )
        {
            //
            // If we are talking to a downlevel server the ds is not available.
            //
            if( ( GetDriverVersion( _dwDriverVersion ) > 2 ) && bIsDsAvailable( ) )
            {
                if( ( _dwAction & DSPRINT_PUBLISH ) || ( _dwAction & DSPRINT_UPDATE ) )
                {
                    _ePrinterPublishState = kPublished;
                }
                else
                {
                    _ePrinterPublishState = kNotPublished;
                }
            }
            else
            {
                _ePrinterPublishState = kNoDsAvailable;
            }
        }
    }

    return _ePrinterPublishState;
}

BOOL
TPrinterData::
bIsDsAvailable(
    VOID
    )
/*++

Routine Description:

    Sets and Gets the publish state.

Arguments:

    None

Return Value:

    The current publish state.

--*/

{
    if( _eDsAvailableState == kDsUnInitalized )
    {
        //
        // Display the wait cursor the DS may take a long time to respond.
        //
        TWaitCursor Cursor;

        TDirectoryService ds;
        _eDsAvailableState = ds.bIsDsAvailable(_strServerName) ? kDsAvailable : kDsNotAvailable;
    }

    return _eDsAvailableState == kDsAvailable;
}

BOOL
TPrinterData::
bCheckForChange(
    IN UINT uLevel
    )
/*++

Routine Description:

    Checkes the data set if it has changed.

Arguments:

    None

Return Value:

    TRUE data has changed, FALSE data is the same.

--*/
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::bCheckForChange\n" ) );

    //
    // If we are not an administrator nothing should change
    // This is a performance optimization, when the user
    // is just looking at the printer.
    //
    if( !bAdministrator() )
    {
        return FALSE;
    }

    BOOL bStatus = FALSE;

    //
    // Assume the data is different.
    //
    if( !bStatus && uLevel == -1 || uLevel == 2 )
    {
        //
        // We check all values with a case sensitive check.  The spooler
        // can determine if upper and lower case characters warrent
        // a printer change event.
        //
        if( !_tcscmp( _strServerName,   _PrinterInfo._strServerName )   &&
            !ComparePrinterName( _strPrinterName,  _PrinterInfo._strPrinterName ) &&
            !_tcscmp( _strDriverName,       _PrinterInfo._strDriverName )       &&
            !_tcscmp( _strComment,          _PrinterInfo._strComment )          &&
            !_tcscmp( _strLocation,         _PrinterInfo._strLocation )         &&
            !_tcscmp( _strPortName,         _PrinterInfo._strPortName )         &&
            !_tcscmp( _strSepFile,          _PrinterInfo._strSepFile )          &&
            !_tcscmp( _strPrintProcessor,   _PrinterInfo._strPrintProcessor )   &&
            !_tcscmp( _strDatatype,         _PrinterInfo._strDatatype )         &&
            _dwAttributes == _PrinterInfo._dwAttributes                         &&
            _dwPriority   == _PrinterInfo._dwPriority                           &&
            _dwStartTime  == _PrinterInfo._dwStartTime                          &&
            _dwUntilTime  == _PrinterInfo._dwUntilTime                          &&
            _bPooledPrinting == _PrinterInfo._bPooledPrinting )
        {
            //
            // Ignore the printer share name if not shared.
            //
            if( uLevel == 2 || _dwAttributes & PRINTER_ATTRIBUTE_SHARED )
            {
                bStatus = _tcscmp( _strShareName,    _PrinterInfo._strShareName );
            }
        }
        else
        {
            bStatus = TRUE;
        }
    }

    //
    // If the data is the same and it is our level
    // then check if the data is different.
    //
    if( !bStatus && uLevel == -1 || uLevel == 7 )
    {
        //
        // Ignore the DS action if not shared.
        //
        if( uLevel == 7 || _dwAttributes & PRINTER_ATTRIBUTE_SHARED )
        {
            //
            // Ignore the ds pending bit.
            //
            if( ( _dwAction & ~DSPRINT_PENDING ) == ( _PrinterInfo._dwAction & ~DSPRINT_PENDING ) )
            {
                bStatus = FALSE;
            }
            else
            {
                bStatus = TRUE;
            }
        }
    }

#if DBG
    if( bStatus )
        DBGMSG( DBG_TRACE, ("Item changed:\n" ));

    if( _tcscmp( _strServerName,   _PrinterInfo._strServerName ) )
        DBGMSG( DBG_TRACE, ("ServerName:   "TSTR " " TSTR "\n", (LPCTSTR)_strServerName,   (LPCTSTR)_PrinterInfo._strServerName ));

    if( ComparePrinterName( _strPrinterName,  _PrinterInfo._strPrinterName ) )
        DBGMSG( DBG_TRACE, ("PrinterName:  "TSTR " " TSTR "\n", (LPCTSTR)_strPrinterName,  (LPCTSTR)_PrinterInfo._strPrinterName ));

    if( _tcscmp( _strShareName,    _PrinterInfo._strShareName ) )
        DBGMSG( DBG_TRACE, ("ShareName:    "TSTR " " TSTR "\n", (LPCTSTR)_strShareName,    (LPCTSTR)_PrinterInfo._strShareName ));

    if( _tcscmp( _strDriverName,   _PrinterInfo._strDriverName ) )
        DBGMSG( DBG_TRACE, ("DriverName:   "TSTR " " TSTR "\n", (LPCTSTR)_strDriverName,   (LPCTSTR)_PrinterInfo._strDriverName ));

    if( _tcscmp( _strComment,      _PrinterInfo._strComment ) )
        DBGMSG( DBG_TRACE, ("CommentName:  "TSTR " " TSTR "\n", (LPCTSTR)_strComment,      (LPCTSTR)_PrinterInfo._strComment ));

    if( _tcscmp( _strLocation,     _PrinterInfo._strLocation ) )
        DBGMSG( DBG_TRACE, ("LocationName: "TSTR " " TSTR "\n", (LPCTSTR)_strLocation,     (LPCTSTR)_PrinterInfo._strLocation ));

    if( _tcscmp( _strPortName,     _PrinterInfo._strPortName ) )
        DBGMSG( DBG_TRACE, ("PortName:     "TSTR " " TSTR "\n", (LPCTSTR)_strPortName,     (LPCTSTR)_PrinterInfo._strPortName ));

    if( _tcscmp( _strSepFile,      _PrinterInfo._strSepFile ) )
        DBGMSG( DBG_TRACE, ("SepFile:      "TSTR " " TSTR "\n", (LPCTSTR)_strSepFile,      (LPCTSTR)_PrinterInfo._strSepFile ));

    if( _tcscmp( _strDatatype,     _PrinterInfo._strDatatype ) )
        DBGMSG( DBG_TRACE, ("Datatype:     "TSTR " " TSTR "\n", (LPCTSTR)_strDatatype,     (LPCTSTR)_PrinterInfo._strDatatype ));

    if( _tcscmp( _strPrintProcessor, _PrinterInfo._strPrintProcessor ) )
        DBGMSG( DBG_TRACE, ("PrintProcessor:     "TSTR " " TSTR "\n", (LPCTSTR)_strPrintProcessor,     (LPCTSTR)_PrinterInfo._strPrintProcessor ));

    if( _dwAttributes != _PrinterInfo._dwAttributes )
        DBGMSG( DBG_TRACE, ("Attributes:   %x %x\n",  _dwAttributes,  _PrinterInfo._dwAttributes ));

    if( _dwPriority   != _PrinterInfo._dwPriority )
        DBGMSG( DBG_TRACE, ("Priority:     %d %d\n",  _dwPriority,    _PrinterInfo._dwPriority ));

    if( _dwStartTime  != _PrinterInfo._dwStartTime )
        DBGMSG( DBG_TRACE, ("StartTime:    %d %d\n",  _dwStartTime,   _PrinterInfo._dwStartTime ));

    if( _dwUntilTime  != _PrinterInfo._dwUntilTime )
        DBGMSG( DBG_TRACE, ("UntilTime:    %d %d\n",  _dwUntilTime,   _PrinterInfo._dwUntilTime ));

    if( _dwAction     != _PrinterInfo._dwAction )
        DBGMSG( DBG_TRACE, ("DsAction:     %x %x\n",  _dwAction,      _PrinterInfo._dwAction ));

#endif

    return bStatus;
}


INT
TPrinterData::
ComparePrinterName(
    IN LPCTSTR pszPrinterName1,
    IN LPCTSTR pszPrinterName2
    )
/*++

Routine Description:

    Compare printer name 1 to printer name 2.  This routine will
    strip the server name and any leading wacks when the comparison
    is done.

Arguments:

    pszPrinterName1 - Pointer to printer name string (can be fully qualified)
    pszPrinterName2 - Pointer to printer name string (can be fully qualified)

Return Value:

    1 Printer name 1 is greater than printer name 2
    0 Printer name 1 and printer name 2 are equal.
    -1 Printer name 1 is less than printer name 2

--*/

{
    SPLASSERT( pszPrinterName1 );
    SPLASSERT( pszPrinterName2 );

    LPCTSTR pszServer1;
    LPCTSTR pszPrinter1;
    TCHAR szScratch1[kPrinterBufMax];

    LPCTSTR pszServer2;
    LPCTSTR pszPrinter2;
    TCHAR szScratch2[kPrinterBufMax];

    //
    // Split the printer names into their components.
    //
    vPrinterSplitFullName( szScratch1, pszPrinterName1, &pszServer1, &pszPrinter1 );
    vPrinterSplitFullName( szScratch2, pszPrinterName2, &pszServer2, &pszPrinter2 );

    //
    // Assume not equal.
    //
    INT iRetval = 1;

    if( pszPrinter1 && pszPrinter2 )
    {
        iRetval = _tcscmp( pszPrinter1, pszPrinter2 );
    }

    return iRetval;
}

BOOL
TPrinterData::
bUpdateGlobalDevMode(
    VOID
    )
/*++

Routine Description:

    Updates the global devmode using printer info 8.

Arguments:

    None

Return Value:

    TRUE data devmode updated, FALSE error occurred.

--*/

{
    DBGMSG( DBG_TRACE, ( "TPrinterData::bUpdateGlobalDevMode\n" ) );

    SPLASSERT( _pDevMode );

    PRINTER_INFO_8  Info8   = {0};
    DWORD           cbInfo8 = 0;
    TStatusB        bStatus;

    //
    // Set the devmode in the printer info 8 structure.
    //
    Info8.pDevMode = _pDevMode;

    //
    // Set the global dev mode.
    //
    bStatus DBGCHK = SetPrinter( _hPrinter, 8, (PBYTE)&Info8, 0 );

    return bStatus;
}

BOOL
TPrinterData::
bUpdatePerUserDevMode(
    VOID
    )
/*++

Routine Description:

    Updates the global devmode using printer info 8.

Arguments:

    None

Return Value:

    TRUE data devmode updated, FALSE error occurred.

--*/

{
    DBGMSG( DBG_TRACE, ( "TPrinterData::bUpdatePerUserDevMode\n" ) );

    SPLASSERT( _pDevMode );

    PRINTER_INFO_9  Info9   = {0};
    DWORD           cbInfo9 = 0;
    TStatusB        bStatus;

    //
    // Set the devmode in the printer info 8 structure.
    //
    Info9.pDevMode = _pDevMode;

    //
    // Set the global dev mode.
    //
    bStatus DBGCHK = SetPrinter( _hPrinter, 9, (PBYTE)&Info9, 0 );

    return bStatus;
}


VOID
TPrinterData::
vGetSpecialInformation(
    VOID
    )
/*++

Routine Description:

    Checked if this device is a fax printer, we read server
    registry key to see if we should display the sharing UI
    for this device.

Arguments:

    None

Return Value:

    Nothing.

--*/
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::vGetSpecialInformation\n" ) );

    if( !_tcscmp( _strDriverName, FAX_DRIVER_NAME ) )
    {
        TStatusB bStatus;

        //
        // Save the fact this is a Fax printer.
        //
        _bIsFaxDriver = TRUE;

        //
        // Create the printer data access class.
        //
        TPrinterDataAccess Data( _strServerName, TPrinterDataAccess::kResourceServer, TPrinterDataAccess::kAccessRead );

        //
        // Relax the return type checking, the spooler just cannot get it right.
        //
        Data.RelaxReturnTypeCheck( TRUE );

        //
        // Initialize the data class.
        //
        bStatus DBGCHK = Data.Init();

        if( bStatus )
        {
            //
            // Assume remote fax is disabled.
            //
            DWORD dwRemoteFax = 1;

            HRESULT hr = Data.Get( SPLREG_REMOTE_FAX, dwRemoteFax );

            if( SUCCEEDED(hr) )
            {
                DBGMSG( DBG_TRACE, ( "TPrinterData::vGetSpecialInformation - RemoteFax %x\n" , dwRemoteFax ) );

                _bHideSharingUI = dwRemoteFax ? FALSE : TRUE;
            }
        }
    }

    //
    // If the printer is a masq printer connected to an http port then hide the sharingUI.
    //
    if( !_bHideSharingUI )
    {
        if( (dwAttributes() & PRINTER_ATTRIBUTE_LOCAL) && (dwAttributes() & PRINTER_ATTRIBUTE_NETWORK) )
        {
            _bHideSharingUI = !_tcsnicmp( _strPortName, gszHttpPrefix0, _tcslen(gszHttpPrefix0) ) ||
                              !_tcsnicmp( _strPortName, gszHttpPrefix1, _tcslen(gszHttpPrefix1) );
        }
    }
}


/********************************************************************

    Printer info data classes.

********************************************************************/

TPrinterData::TPrinterInfo::
TPrinterInfo(
    VOID
    ) : _dwAttributes( 0 ),
        _dwPriority( 0 ),
        _dwStartTime( 0 ),
        _dwUntilTime( 0 ),
        _dwAction( 0 ),
        _bPooledPrinting( FALSE )
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::TPrinterInfo ctor\n" ) );
}

TPrinterData::TPrinterInfo::
~TPrinterInfo(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::TPrinterInfo dtor\n" ) );
}

BOOL
TPrinterData::TPrinterInfo::
bUpdate(
    IN PPRINTER_INFO_2 pInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::TPrinterInfo::bUpdate 2\n" ) );

    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    if( pInfo )
    {
        bStatus DBGCHK = _strServerName.bUpdate( pInfo->pServerName )           &&
                         _strPrinterName.bUpdate( pInfo->pPrinterName )         &&
                         _strShareName.bUpdate( pInfo->pShareName )             &&
                         _strDriverName.bUpdate( pInfo->pDriverName )           &&
                         _strComment.bUpdate( pInfo->pComment )                 &&
                         _strLocation.bUpdate( pInfo->pLocation )               &&
                         _strPortName.bUpdate( pInfo->pPortName )               &&
                         _strSepFile.bUpdate( pInfo->pSepFile )                 &&
                         _strPrintProcessor.bUpdate( pInfo->pPrintProcessor )   &&
                         _strDatatype.bUpdate( pInfo->pDatatype );

        //
        // check whether pool printing is enabled
        //
        if( _tcschr( pInfo->pPortName, TEXT( ',' ) ) )
        {
            _bPooledPrinting = TRUE;
        }
        else
        {
            _bPooledPrinting = FALSE;
        }

        _dwAttributes   = pInfo->Attributes;
        _dwPriority     = pInfo->Priority;
        _dwStartTime    = pInfo->StartTime;
        _dwUntilTime    = pInfo->UntilTime;

    }

    return bStatus;
}

BOOL
TPrinterData::TPrinterInfo::
bUpdate(
    IN PPRINTER_INFO_7 pInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterData::TPrinterInfo::bUpdate 7\n" ) );

    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    if( pInfo )
    {
        bStatus DBGCHK  = _strObjectGUID.bUpdate( pInfo->pszObjectGUID );
        _dwAction       = pInfo->dwAction;
    }

    return bStatus;
}

/********************************************************************

    Printer property base class for generic services to
    all property pages.

********************************************************************/

TPrinterProp::
TPrinterProp(
    TPrinterData* pPrinterData
    ) : _pPrinterData( pPrinterData )
{
}

VOID
TPrinterProp::
vSetIconName(
    VOID
    )

/*++

Routine Description:

    Sets the printer icon to the custom one.

Arguments:

    hDlg - Modifies this dialog.

Return Value:

--*/

{
    //
    // Set the correct icon; destroy the previous one.
    //
    SendDlgItemMessage(_hDlg, IDC_PRINTER_ICON, STM_SETICON, (WPARAM)(HICON)_pPrinterData->shLargeIcon(), 0);

    LPCTSTR pszServer;
    LPCTSTR pszPrinter;
    TCHAR szScratch[kPrinterBufMax];

    //
    // Split the printer name into its components.
    //
    vPrinterSplitFullName( szScratch,
                           _pPrinterData->strPrinterName( ),
                           &pszServer,
                           &pszPrinter );

    //
    // Set the printer name.
    //
    bSetEditText( _hDlg, IDC_NAME, pszPrinter );
}

VOID
TPrinterProp::
vReloadPages(
    VOID
    )
/*++

Routine Description:

    Something changed (driver or security etc.) so we need to completely
    refresh all printer pages.

Arguments:

    None.

Return Value:

    Nothing

Comments:

    This is currently not implemented.

--*/

{

}

BOOL
TPrinterProp::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
/*++

Routine Description:

    Front end for each sheets message handler.

Arguments:

    uMsg    - Window message
    wParam  - wParam
    lParam  - lParam

Return Value:

    TRUE message handled, FALSE message not handled.

--*/
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {
    case WM_INITDIALOG:
        bStatus = bHandle_InitDialog( wParam, lParam );
        break;

    case WM_NOTIFY:
        bStatus = bHandle_Notify( wParam, lParam );
        break;

    case WM_SETTINGCHANGE:
        bStatus = bHandle_SettingChange( wParam, lParam );
        break;

    default:
        bStatus = FALSE;
        break;
    }

    //
    // Allow the derived classes to handle the message.
    //
    bStatus = _bHandleMessage( uMsg, wParam, lParam );

    //
    // We must remember the last non-dynamic page here in order 
    // to know whether we are in our page or one of the dynamic 
    // pages later - (the dynamic pages are the shell extention pages 
    // plus the driver pages).
    //
    if( WM_NOTIFY == uMsg )
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        if( PSN_SETACTIVE == pnmh->code  && 0 == GetWindowLong( _hDlg, DWLP_MSGRESULT ) )
        {
            //
            // If activation is accepted
            //
            _pPrinterData->_hwndLastPageSelected = _hDlg;
        }
    }

    //
    // If the message was handled check if the
    // apply button should be enabled.
    //
    if( bStatus )
    {
        if( _pPrinterData->bCheckForChange() )
        {
            vPropSheetChangedAllPages();
        }
        else
        {
            vPropSheetUnChangedAllPages();
        }
    }

    return bStatus;
}

VOID
TPrinterProp::
vPropSheetChangedAllPages(
    VOID
    )
/*++

Routine Description:

    Indicate that something has changed, we change the state
    for all of our pages since the property sheet code
    stores changed state on a per sheet basis.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    if( _pPrinterData->_bApplyEnableState )
    {
        for ( UINT i = 0; i < COUNTOF( _pPrinterData->_hwndPages ); i++ )
        {
            if( _pPrinterData->_hwndPages[i] )
            {
                PropSheet_Changed( GetParent( _hDlg ), _pPrinterData->_hwndPages[i] );
            }
        }
    }
}

VOID
TPrinterProp::
vPropSheetUnChangedAllPages(
    VOID
    )
/*++

Routine Description:

    Indicate we are back in the original state we change the state
    for all of our pages since the property sheet code
    stores changed or unchanged state on a per sheet basis.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    if( _pPrinterData->_bApplyEnableState )
    {
        for ( UINT i = 0; i < COUNTOF( _pPrinterData->_hwndPages ); i++ )
        {
            if( _pPrinterData->_hwndPages[i] )
            {
                PropSheet_UnChanged( GetParent( _hDlg ), _pPrinterData->_hwndPages[i] );
            }
        }
    }
}

VOID
TPrinterProp::
vSetApplyState(
    IN BOOL bNewApplyState
    )
/*++

Routine Description:

    Sets the current apply state.  If the apply state is disable
    then the apply button is always disabled.

Arguments:

    bNewApplyState - TRUE enabled, FALSE disabled.

Return Value:

    Nothing.

--*/
{
    //
    // Save the current apply enable state.
    //
    _pPrinterData->_bApplyEnableState = bNewApplyState;

    //
    // Either enable or disable the apply state.
    //
    SendMessage( GetParent(_hDlg), bNewApplyState ? PSM_ENABLEAPPLY : PSM_DISABLEAPPLY, 0, 0);
}

BOOL
TPrinterProp::
bHandle_InitDialog(
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
/*++

Routine Description:

    Handles init dialog message.

Arguments:

    wParam  - wParam
    lParam  - lParam

Return Value:

    TRUE message handled, FALSE message not handled.

--*/
{
    //
    // Save the handles to all the activated pages.
    ///
    _pPrinterData->_hwndPages[_pPrinterData->_uMaxActiveCount] = _hDlg;

    //
    // Count the activated pages.
    //
    ++_pPrinterData->_uMaxActiveCount;
    ++_pPrinterData->_uActiveCount;

    //
    // Inform the property sheet manager what are parent handle is.
    //
    _pPrinterData->_pPrinterPropertySheetManager->vSetParentHandle( GetParent( _hDlg ) );

    return TRUE;
}

BOOL
TPrinterProp::
bHandle_Notify(
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
/*++

Routine Description:

    Handles notify messages.

Arguments:

    wParam  - wParam
    lParam  - lParam

Return Value:

    TRUE message handled, FALSE message not handled.

--*/

{
    BOOL    bStatus = TRUE;
    LPNMHDR pnmh    = (LPNMHDR)lParam;

    switch( pnmh->code )
    {
    //
    // The last chance apply message is sent in reverse order page n to page 0.
    //
    // We listen to this message when the apply button state is disabled due
    // to the user changing the printer name.  Since we are the first page
    // in the set of property sheets we can gaurentee that the last PSN_LASTCHANCEAPPLY
    // message will be the last message for all the pages, thus at this time it is
    // safe to the printer.
    //
    case PSN_LASTCHANCEAPPLY:
        DBGMSG( DBG_TRACE, ( "TPrinterProp::bHandleMessage PSN_LASTCHANCEAPPLY\n" ) );
        if(!_pPrinterData->_bApplyEnableState)
        {
            vApplyChanges();
        }
        break;

    //
    // The apply message is sent in forward order page 0 to page n.
    //
    case PSN_APPLY:
        DBGMSG( DBG_TRACE, ( "TPrinterProp::bHandleMessage PSN_APPLY\n" ) );
        if(_pPrinterData->_bApplyEnableState)
        {
            vApplyChanges();
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}


BOOL
TPrinterProp::
bHandle_SettingChange(
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
/*++

Routine Description:

    Handles setting change message.

Arguments:

    wParam  - wParam
    lParam  - lParam

Return Value:

    TRUE message handled, FALSE message not handled.

--*/

{
    HWND hCtrl;
    BOOL bDefaultPrinter;

    //
    // WM_SETTINGCHANGE is posted to every page but we only execute the function once. This
    // is because we change _bDefaultPrinter only once.
    //
    bDefaultPrinter = CheckDefaultPrinter( _pPrinterData->strCurrentPrinterName() ) == kDefault;

    if( _pPrinterData->bDefaultPrinter() ^ bDefaultPrinter )
    {
        //
        //  If the default printer setting is changed and it related to
        //  current printer, change the window icon
        //
        _pPrinterData->bDefaultPrinter() = bDefaultPrinter;

        CAutoHandleIcon shIconLarge, shIconSmall;
        LoadPrinterIcons(_pPrinterData->strCurrentPrinterName(), &shIconLarge, &shIconSmall);

        if( shIconLarge && shIconSmall )
        {
            _pPrinterData->shLargeIcon() = shIconLarge.Detach();
            _pPrinterData->shSmallIcon() = shIconSmall.Detach();

            //
            // Change the printer icon to each page which has printer icon control. 
            //
            for ( UINT i = 0; i < COUNTOF( _pPrinterData->_hwndPages ); i++ )
            {
                if( _pPrinterData->_hwndPages[i] && 
                    (hCtrl = GetDlgItem( _pPrinterData->_hwndPages[i], IDC_PRINTER_ICON )) )
                {
                    SendMessage(hCtrl, STM_SETICON, (WPARAM)(HICON)_pPrinterData->shLargeIcon(), 0);
                    InvalidateRect(hCtrl, NULL, FALSE);
                }
            }
        }
    }

    return FALSE;
}


VOID
TPrinterProp::
vApplyChanges(
    VOID
    )
/*++

Routine Description:

    This routine applies the changes if this is the last active page
    or the caller specified a force flag to do the apply changes now.

Arguments:

    bForceApplyNow - TRUE apply the changes now, FALSE wait for last active page.

Return Value:

    Nothing.

--*/
{
    if (!--_pPrinterData->_uActiveCount)
    {
        //
        // Reset the active page count.
        //
        _pPrinterData->_uActiveCount = _pPrinterData->_uMaxActiveCount;

        //
        // Only save the options if we have rights to change settings.
        //
        if (_pPrinterData->bAdministrator())
        {
            //
            // Save the printer data to the spooler.
            //
            BOOL bStatus = _pPrinterData->bSave();

            if (!bStatus)
            {
                //
                // Display error message to the user.
                //
                iMessage( _hDlg,
                          IDS_ERR_PRINTER_PROP_TITLE,
                          IDS_ERR_SAVE_PRINTER,
                          MB_OK|MB_ICONSTOP,
                          kMsgGetLastError,
                          gaMsgErrMapSetPrinter );

            }
            else
            {
                //
                // Inform the active pages to refresh themselves.
                //
                vNotifyActivePagesToRefresh();

                //
                // Re-enable the apply state.
                //
                _pPrinterData->_bApplyEnableState = TRUE;
            }

            //
            // If settings are saved successfully.
            //
            vSetDlgMsgResult( !bStatus ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR );
        }
    }
}


VOID
TPrinterProp::
vNotifyActivePagesToRefresh(
    VOID
    )
/*++

Routine Description:

    Notify the active pages that they should refresh themselves.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    for ( UINT i = 0; i < COUNTOF( _pPrinterData->_hwndPages ); i++ )
    {
        if( _pPrinterData->_hwndPages[i] )
        {
            PostMessage( _pPrinterData->_hwndPages[i], WM_APP, 0, 0 );
        }
    }
}


/*++

Routine Name:

    vCancelToClose

Routine Description:

    Change the cancel button to close, the user has basically
    made a change that cannot be undone using the cancel button.

Arguments:

    None.

Return Value:

    Nothing.

--*/
VOID
TPrinterProp::
vCancelToClose(
    VOID
    )
{
    PropSheet_CancelToClose( GetParent( _hDlg ) );
}


/********************************************************************

    General.

********************************************************************/

TPrinterGeneral::
TPrinterGeneral(
    TPrinterData* pPrinterData
    ) : TPrinterProp( pPrinterData ),
        _bSetUIDone( FALSE ),
        _pLocationDlg (NULL)
{
}

TPrinterGeneral::
~TPrinterGeneral(
    VOID
    )
{
    delete _pLocationDlg;
}

BOOL
TPrinterGeneral::
bValid(
    VOID
    )
{
    return TPrinterProp::bValid();
}

BOOL
TPrinterGeneral::
bSetUI(
    VOID
    )
{
    // subclass the edit control to workaround a bug
    if( !m_wndComment.IsAttached() )
    {
        VERIFY(m_wndComment.Attach(GetDlgItem(hDlg(), IDC_COMMENT)));
    }

    //
    // Update the fields.
    //
    bSetEditText( _hDlg, IDC_COMMENT,       _pPrinterData->strComment());
    bSetEditText( _hDlg, IDC_LOCATION,      _pPrinterData->strLocation());
    bSetEditText( _hDlg, IDC_MODEL_NAME,    _pPrinterData->strDriverName());

    //
    // When we are not an administrator set the edit controls to read only
    // rather and disabled.  They are easier to read in read only mode.
    //
    SendDlgItemMessage( _hDlg, IDC_COMMENT, EM_SETREADONLY, !_pPrinterData->bAdministrator(), 0);
    SendDlgItemMessage( _hDlg, IDC_LOCATION,EM_SETREADONLY, !_pPrinterData->bAdministrator(), 0);
    SendDlgItemMessage( _hDlg, IDC_NAME,    EM_SETREADONLY, !_pPrinterData->bAdministrator(), 0);

    //
    // We do not support renaming of masq printers, this is done because the leading \\ on
    // masq printers is neccessary for the folder code to determine if the printer is the
    // special masq printer case.  The folder code does this check because to get the printer
    // attributes for every printer would slow down the code excessivly.
    //
    if( _pPrinterData->_dwAttributes & PRINTER_ATTRIBUTE_LOCAL && _pPrinterData->_dwAttributes & PRINTER_ATTRIBUTE_NETWORK )
    {
        SendDlgItemMessage( _hDlg, IDC_NAME, EM_SETREADONLY, TRUE, 0);
    }
    else
    {
        vCheckForSharedMasqPrinter();
    }

    //
    // Create the find dialog.
    //
    _pLocationDlg = new TFindLocDlg;

    if (VALID_PTR(_pLocationDlg) && TPhysicalLocation::bLocationEnabled() && TDirectoryService::bIsDsAvailable())
    {
        EnableWindow (GetDlgItem (_hDlg, IDC_BROWSE_LOCATION), _pPrinterData->bAdministrator());
    }
    else
    {
        //
        // If no DS is available, hide the Browse button and extend the location
        // edit control appropriately
        RECT rcComment;
        RECT rcLocation;
        HWND hLoc;

        hLoc = GetDlgItem (_hDlg, IDC_LOCATION);

        GetWindowRect (GetDlgItem (_hDlg, IDC_COMMENT), &rcComment);

        GetWindowRect (hLoc, &rcLocation);

        SetWindowPos (hLoc,
                      NULL,
                      0,0,
                      rcComment.right-rcComment.left,
                      rcLocation.bottom-rcLocation.top,
                      SWP_NOMOVE|SWP_NOZORDER);

        ShowWindow (GetDlgItem (_hDlg, IDC_BROWSE_LOCATION), SW_HIDE);
    }


    //
    // Set the pinter name limit text.
    //
    SendDlgItemMessage( _hDlg, IDC_NAME, EM_SETLIMITTEXT, kPrinterLocalNameMax, 0 );

    //
    // Set the comment limit text to 255.  A printer with a comment string
    // longer than 255 characters cannot be shared.
    //
    SendDlgItemMessage( _hDlg, IDC_COMMENT, EM_SETLIMITTEXT, kPrinterCommentBufMax, 0 );

    //
    // What the heck lets be consistent and make the location string
    // have a limit.
    //
    SendDlgItemMessage( _hDlg, IDC_LOCATION, EM_SETLIMITTEXT, kPrinterLocationBufMax, 0 );

    //
    // If the driver pages failed to load or the user did not
    // want to load them then hide the devmode editor  UI
    // because you need a driver to show the dev mode editor.
    //
    if( _pPrinterData->_bDriverPagesNotLoaded )
    {
        ShowWindow( GetDlgItem( _hDlg, IDC_PER_USER_DOCUMENT_DEFAULTS ), SW_HIDE );
    }

    //
    // The test page button does not apply for the fax printer.
    //
    if( _pPrinterData->_bIsFaxDriver )
    {
        WINDOWPLACEMENT wndpl;

        wndpl.length = sizeof( wndpl );

        GetWindowPlacement( GetDlgItem( _hDlg, IDC_TEST ), &wndpl );

        SetWindowPlacement( GetDlgItem( _hDlg, IDC_PER_USER_DOCUMENT_DEFAULTS ), &wndpl );

        ShowWindow( GetDlgItem( _hDlg, IDC_TEST ), SW_HIDE );
    }

    //
    // Display the features information.
    //
    vReloadFeaturesInformation();

    //
    // There are a few UI elements that need to be set when
    // we are activated, because of a driver change.  We
    // will artifically do it now.
    //
    vSetActive();

    //
    // Indicate SetUI is done.  This is used to
    // prevent ReadUI from reading junk since edit controls
    // recieve EN_CHANGE messages while in WM_INITDIALOG
    //
    _bSetUIDone = TRUE;

    return TRUE;

}

VOID
TPrinterGeneral::
vReloadFeaturesInformation(
    VOID
    )
{
    TStatusB    bStatus;
    UINT        uValidFeatureCount = 0;

    //
    // Create the printer data access class.
    //
    TPrinterDataAccess Data( _pPrinterData->_hPrinter );

    //
    // Relax the return type checking, BOOL are not REG_DWORD but REG_BINARY
    //
    Data.RelaxReturnTypeCheck( TRUE );

    //
    // Initialize the data class.
    //
    bStatus DBGCHK = Data.Init();

    if( bStatus )
    {
        TString strYes;
        TString strNo;
        TString strTemp;
        TString strTemp1;
        TString strUnknown;
        TString strPPM;
        TString strDPI;

        HRESULT hr;
        BOOL    bValue;
        DWORD   dwValue;
        LPCTSTR pszString;

        bStatus DBGCHK = strUnknown.bLoadString( ghInst, IDS_FEATURE_UNKNOWN );
        bStatus DBGCHK = strYes.bLoadString( ghInst, IDS_YES );
        bStatus DBGCHK = strNo.bLoadString( ghInst, IDS_NO );
        bStatus DBGCHK = strPPM.bLoadString( ghInst, IDS_SPEED_UNITS );
        bStatus DBGCHK = strDPI.bLoadString( ghInst, IDS_RESOLUTION_UNITS );

        hr = Data.Get( SPLDS_DRIVER_KEY, SPLDS_PRINT_COLOR, bValue );
        uValidFeatureCount = SUCCEEDED(hr) ? uValidFeatureCount+1 : uValidFeatureCount;
        bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_COLOR );
        bStatus DBGCHK = strTemp.bCat( gszSpace );
        bStatus DBGCHK = strTemp.bCat( FAILED(hr) ? strUnknown : bValue ? strYes : strNo );
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_COLOR, strTemp );

        hr = Data.Get( SPLDS_DRIVER_KEY, SPLDS_PRINT_DUPLEX_SUPPORTED, bValue );
        uValidFeatureCount = SUCCEEDED(hr) ? uValidFeatureCount+1 : uValidFeatureCount;
        bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_DUPLEX );
        bStatus DBGCHK = strTemp.bCat( gszSpace );
        bStatus DBGCHK = strTemp.bCat( FAILED(hr) ? strUnknown : bValue ? strYes : strNo );
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_DUPLEX, strTemp );

        hr = Data.Get( SPLDS_DRIVER_KEY, SPLDS_PRINT_STAPLING_SUPPORTED, bValue );
        uValidFeatureCount = SUCCEEDED(hr) ? uValidFeatureCount+1 : uValidFeatureCount;
        bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_STAPLE );
        bStatus DBGCHK = strTemp.bCat( gszSpace );
        bStatus DBGCHK = strTemp.bCat( FAILED(hr) ? strUnknown : bValue ? strYes : strNo );
        bSetEditText( _hDlg, IDC_STAPLE, strTemp );

        hr = Data.Get( SPLDS_DRIVER_KEY, SPLDS_PRINT_PAGES_PER_MINUTE, dwValue );
        uValidFeatureCount = SUCCEEDED(hr) ? uValidFeatureCount+1 : uValidFeatureCount;
        bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_SPEED );
        bStatus DBGCHK = strTemp.bCat( gszSpace );
        bStatus DBGCHK = strTemp.bCat( FAILED(hr) ? strUnknown : strTemp1.bFormat( _T("%d %s"), dwValue, (LPCTSTR)strPPM ) ? strTemp1 : gszNULL );
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_SPEED, strTemp );

        hr = Data.Get( SPLDS_DRIVER_KEY, SPLDS_PRINT_MAX_RESOLUTION_SUPPORTED, dwValue );
        uValidFeatureCount = SUCCEEDED(hr) ? uValidFeatureCount+1 : uValidFeatureCount;
        bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_RESOLUTION );
        bStatus DBGCHK = strTemp.bCat( gszSpace );
        bStatus DBGCHK = strTemp.bCat( FAILED(hr) ? strUnknown : strTemp1.bFormat( _T("%d %s"), dwValue, (LPCTSTR)strDPI ) ? strTemp1 : gszNULL );
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_RESOLUTION, strTemp );

        TString *pStrings   = NULL;
        UINT    nCount      = 0;

        hr = Data.Get( SPLDS_DRIVER_KEY, SPLDS_PRINT_MEDIA_READY, &pStrings, nCount );
        uValidFeatureCount = SUCCEEDED(hr) ? uValidFeatureCount+1 : uValidFeatureCount;

        TString strMediaReady;
        if( SUCCEEDED(hr) )
        {
            for( UINT i = 0; i < nCount; i++ )
            {
                DBGMSG( DBG_TRACE, ( "Media ready " TSTR ".\n", (LPCTSTR)pStrings[i] ) );
                bStatus DBGCHK = strMediaReady.bCat( pStrings[i] );

                if( i != (nCount-1) )
                {
                    //
                    // If it is not the last media type, add CRLF symbols at the end
                    //
                    bStatus DBGCHK = strMediaReady.bCat( _T("\r\n" ));
                }
            }
        }

        //
        // We are updating the "Paper Available" regardless of whether
        // the GetPrinterDataEx( ... ) succeeds or fails.
        // 
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_PAPER_SIZE_LIST, strMediaReady );

        delete [] pStrings;
    }

    if( !uValidFeatureCount )
    {
        ShowWindow( GetDlgItem( _hDlg, IDC_COLOR ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_DUPLEX ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_STAPLE ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_SPEED ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_RESOLUTION ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_PAPER_SIZE_LIST ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_GBOX_FEATURES ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_PAPER_SIZE ), SW_HIDE );
    }
}


VOID
TPrinterGeneral::
vReadUI(
    VOID
    )
{
    if( !bGetEditText( _hDlg, IDC_COMMENT,  _pPrinterData->strComment( ))   ||
        !bGetEditText( _hDlg, IDC_LOCATION, _pPrinterData->strLocation( ))  ||
        !bGetEditText( _hDlg, IDC_NAME,     _pPrinterData->strPrinterName( )))
    {
        //
        // If we cannot read from any of the edit controls then set the
        // error flag.
        //
        _pPrinterData->_bErrorSaving = FALSE;

        //
        // Unable to read the text.
        //
        vShowResourceError( _hDlg );

        //
        // Don't swith the page.
        //
        vSetDlgMsgResult( TRUE );
    }
    else
    {
        //
        // Remove any trailing slashes from the location string
        //
        TPhysicalLocation::vTrimSlash (_pPrinterData->strLocation());
    }
}

VOID
TPrinterGeneral::
vSetActive(
    VOID
    )
{
    //
    // Set the icon and printer name.
    //
    vSetIconName();

    //
    // Reload the features information.
    //
    vReloadFeaturesInformation();

    //
    // Set the new printer driver name.
    //
    bSetEditText( _hDlg, IDC_MODEL_NAME, _pPrinterData->strDriverName( ));
}

VOID
TPrinterGeneral::
vKillActive(
    VOID
    )
{
    //
    // Do not validate the printer name if IDC_NAME field is readonly,
    // which means either one of the following:
    //
    // 1. The printer is masq printer
    // 2. The printer is shared masq printer
    //
    if( ES_READONLY & GetWindowLong(GetDlgItem(_hDlg, IDC_NAME), GWL_STYLE) )
        return;

    //
    // Only validate the printer name if we are an administrator
    //
    if( _pPrinterData->bAdministrator() )
    {
        //
        // Strip any trailing white space.
        //
        vStripTrailWhiteSpace( (LPTSTR)(LPCTSTR)_pPrinterData->_strPrinterName );

        //
        // Check if the name is null.
        //
        if( _pPrinterData->_strPrinterName.bEmpty( ) ){

            iMessage( _hDlg,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_NO_PRINTER_NAME,
                      MB_OK|MB_ICONEXCLAMATION,
                      kMsgNone,
                      NULL );

            vSetDlgMsgResult( TRUE );
            return;
        }

        //
        // Validate the printer name for any illegal characters.
        //
        if( !bIsLocalPrinterNameValid( _pPrinterData->strPrinterName( ) ) )
        {
            //
            // Put up error explaining that at least one port must be
            // selected.
            //
            iMessage( _hDlg,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_BAD_PRINTER_NAME,
                      MB_OK|MB_ICONSTOP,
                      kMsgNone,
                      NULL );
            //
            // Don't swith the page.
            //
            vSetDlgMsgResult( TRUE );
        }
    }
}

VOID
TPrinterGeneral::
vCheckForSharedMasqPrinter(
    VOID
    )
{
    //
    // check if it is a shared masq printer - which means that the printer name may
    // contains invalid symbols
    //

    LPCTSTR pszServer;
    LPCTSTR pszPrinter;
    TCHAR szScratch[kPrinterBufMax];

    vPrinterSplitFullName( szScratch,
                          _pPrinterData->strPrinterName( ),
                          &pszServer,
                          &pszPrinter );

    if( !bIsLocalPrinterNameValid( pszPrinter ) )
    {
        SendDlgItemMessage( _hDlg, IDC_NAME, EM_SETREADONLY, TRUE, 0);
    }
}

BOOL
TPrinterGeneral::
_bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TStatusB bStatus;

    bStatus DBGNOCHK = TRUE;

    switch( uMsg ){
    case WM_INITDIALOG:

        bStatus DBGCHK = bSetUI();
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        bStatus DBGCHK = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_CLOSE:

        //
        // Multiline edit controls send WM_CLOSE to dismiss the dialog.
        // Convert it to a property-page friendly message.
        //
        PropSheet_PressButton( GetParent( _hDlg ), PSBTN_CANCEL );
        break;

    case WM_APP:

        vSetActive();
        break;

    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam )){

        case IDC_COMMENT:
        case IDC_LOCATION:
            bStatus DBGNOCHK = GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE;
            break;

        case IDC_NAME:
            {
                bStatus DBGNOCHK = GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE;

                //
                // When the printer name changes we disable the apply button because
                // we have no way to inform the extention tabs the printer name has changed.
                //
                TString str;
                if( bGetEditText( _hDlg, IDC_NAME, str ) )
                {
                    vSetApplyState( !_pPrinterData->ComparePrinterName( str, _pPrinterData->strCurrentPrinterName() ));
                }

                break;
            }

        case IDC_TEST:
            {

                //
                // If this is a masq printer we do need to check the name
                // for trailing spaces. In this case the original share name
                // is actually the port name.
                //
                LPCTSTR  pszOrigShareName = NULL;
                if( _pPrinterData->_dwAttributes & PRINTER_ATTRIBUTE_NETWORK && 
                    _pPrinterData->_dwAttributes & PRINTER_ATTRIBUTE_LOCAL )
                {
                    pszOrigShareName = _pPrinterData->strPortName();
                }

                bPrintTestPage( _hDlg, _pPrinterData->strCurrentPrinterName(), pszOrigShareName );
            }
            break;

        case IDC_PER_USER_DOCUMENT_DEFAULTS:

            vHandleDocumentDefaults( wParam, lParam );
            break;

        case IDC_BROWSE_LOCATION:
            vHandleBrowseLocation();
            break;

        default:

            bStatus DBGNOCHK = FALSE;
            break;

        }
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;

        switch( pnmh->code ){

        case PSN_KILLACTIVE:

            vKillActive();
            break;

        default:
            bStatus DBGNOCHK = FALSE;
            break;
        }
    }
    break;

    default:
        bStatus DBGNOCHK = FALSE;
        break;

    }

    if( bStatus && _bSetUIDone )
    {
        vReadUI();
    }

    return bStatus;
}

VOID
TPrinterGeneral::
vHandleDocumentDefaults(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handle launching document defaults dialog.

Arguments:

    wParam - Parameter passed to by dialog proc.
    lParam - Parameter passed to by dialog proc.

Return Value:

    Nothing.

--*/

{
    (VOID)dwDocumentDefaultsInternal( _hDlg,
                                      _pPrinterData->strCurrentPrinterName(),
                                      SW_SHOW,
                                      0,
                                      0,
                                      FALSE );
}

VOID
TPrinterGeneral::
vHandleBrowseLocation(
    VOID
    )
/*++

Routine Description:

    Handle displaying the location tree dialog.

Arguments:

    wParam - Parameter passed to by dialog proc.
    lParam - Parameter passed to by dialog proc.

Return Value:

    Nothing.

--*/

{
    TStatusB     bStatus;
    TString      strDefault = _pPrinterData->strLocation();

    //
    // bDoModal returns FALSE on Cancel
    //
    bStatus DBGNOCHK = _pLocationDlg->bDoModal(_hDlg, &strDefault);

    if (bStatus)
    {
        TString strLocation;

        bStatus DBGCHK = _pLocationDlg->bGetLocation (strLocation);

        if (bStatus && !strLocation.bEmpty())
        {
            //
            // Check to append a trailing slash 
            //
            UINT uLen = strLocation.uLen();
            if( uLen && gchSeparator != static_cast<LPCTSTR>(strLocation)[uLen-1] )
            {
                static const TCHAR szSepStr[] = { gchSeparator };
                bStatus DBGCHK = strLocation.bCat( szSepStr );
            }

            bStatus DBGCHK = bSetEditText (_hDlg, IDC_LOCATION, strLocation);
        }

        //
        // Set focus to the edit control for location, even if setedittext failed
        // Assumption is that user probably still wants to modify locations
        //
        SetFocus (GetDlgItem (_hDlg, IDC_LOCATION));

        //
        // Place the caret at the end of the text, for appending
        //
        SendDlgItemMessage (_hDlg, IDC_LOCATION, EM_SETSEL, strLocation.uLen(), (LPARAM)-1);
    }

}

/********************************************************************

    Printer Ports.

********************************************************************/

TPrinterPorts::
TPrinterPorts(
    TPrinterData* pPrinterData
    ) : TPrinterProp( pPrinterData ),
        _bAdminFlag( FALSE )
{
}

TPrinterPorts::
~TPrinterPorts(
    VOID
    )
{
}

BOOL
TPrinterPorts::
bValid(
    VOID
    )
{
    return _PortsLV.bValid();
}

BOOL
TPrinterPorts::
bSetUI(
    VOID
    )
{
    //
    // Initalize the class admin flag.  We only allow administring ports
    // on this printer if the user is an admin and the printer is not
    // a masq printer.  Masq printer cannot have their ports reassigned,
    // spooler will fail the call, just to make the UI more user friendly
    // we don't let the user do things that we know will fail.
    //
    _bAdminFlag = _pPrinterData->bAdministrator();

    if( (_pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_LOCAL) && (_pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_NETWORK) )
    {
        _bAdminFlag = FALSE;
    }

    //
    // Initialize the ports list view.
    //
    if( !_PortsLV.bSetUI( GetDlgItem( _hDlg, IDC_PORTS ), FALSE, TRUE, _bAdminFlag, _hDlg, 0, 0, IDC_PORT_DELETE ) )
    {
        return FALSE;
    }

    //
    // If we do not have access then don't enumerate the ports
    //
    if( !_pPrinterData->bNoAccess() )
    {
        //
        // Load the machine's ports into the listview.
        //
        if( !_PortsLV.bReloadPorts( _pPrinterData->pszServerName() ) )
        {
            return FALSE;
        }
    }

    //
    // Select the current printer's ports.
    //
    _PortsLV.vCheckPorts((LPTSTR)(LPCTSTR)_pPrinterData->strPortName( ));

    //
    // Set the ports list view to single selection mode,
    //
    _PortsLV.vSetSingleSelection( !_pPrinterData->bPooledPrinting() );

    //
    // Set the pooled printing mode on the UI.
    //
    vSetCheck( _hDlg, IDC_POOLED_PRINTING, _pPrinterData->bPooledPrinting() );

    //
    // If we do not have admin privilages or we are remotly
    // administering a downlevel machine, then disable
    // adding / deleting / configuring ports.
    //
    if( !_bAdminFlag || ( bIsRemote( _pPrinterData->pszServerName() ) &&
                      GetDriverVersion( _pPrinterData->dwDriverVersion() ) <= 2 ) )
    {
        //
        // Disable things if not administrator.
        //
        vEnableCtl( _hDlg, IDC_PORT_CREATE, FALSE );
        vEnableCtl( _hDlg, IDC_PORT_DELETE, FALSE );
        vEnableCtl( _hDlg, IDC_PROPERTIES,  FALSE );
    }

    //
    // Disable bidi selection if not an administrator.
    // Disable printer pooling if not an administrator.
    //
    vEnableCtl( _hDlg, IDC_ENABLE_BIDI,     _bAdminFlag );
    vEnableCtl( _hDlg, IDC_POOLED_PRINTING, _bAdminFlag );

    //
    // Enable Configure Port for HTTP printer only
    //
    if( (_pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_LOCAL) &&
        (_pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_NETWORK) &&
        
        (!_tcsnicmp( _pPrinterData->strPortName (), gszHttpPrefix0, _tcslen(gszHttpPrefix0) ) ||
         !_tcsnicmp( _pPrinterData->strPortName (), gszHttpPrefix1, _tcslen(gszHttpPrefix1) )))
    {
        vEnableCtl( _hDlg, IDC_PROPERTIES, TRUE );
    }

    //
    // There are a few UI elements that need to be set when
    // we are activated, because of a driver change.  We
    // will artifically do it now.
    //
    vSetActive();

    return TRUE;
}


VOID
TPrinterPorts::
vReadUI(
    VOID
    )

/*++

Routine Description:

    Gets the ports from the listview and create the string.

Arguments:

Return Value:

--*/

{
    //
    // Read bidi options.
    //
    DWORD dwAttributes = _pPrinterData->dwAttributes();

    if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_ENABLE_BIDI )){
        dwAttributes |= PRINTER_ATTRIBUTE_ENABLE_BIDI;
    } else {
        dwAttributes &= ~PRINTER_ATTRIBUTE_ENABLE_BIDI;
    }

    _pPrinterData->_dwAttributes = dwAttributes;

    //
    // Build the ports string as long as we are an admin.
    //
    if( _bAdminFlag && !_PortsLV.bReadUI( _pPrinterData->_strPortName )){

        _pPrinterData->_bErrorSaving = TRUE;
        vShowResourceError( _hDlg );
    }

    return;
}


VOID
TPrinterPorts::
vSetActive(
    VOID
    )
{
    //
    // Set the icon and printer name.
    //
    vSetIconName();

    BOOL bEnable = FALSE;
    BOOL bCheck = FALSE;

    //
    // If the call fails or the monitor name is NULL/szNULL,
    // then disable bidi.
    //
    if( _pPrinterData->bSupportBidi( )){

        bEnable = TRUE;

        //
        // Only set the checkbox if a language monitor is present.
        // (When we change drivers, we always set this attribute
        // bit, even if bidi isn't supported.  The spooler and UI
        // ignore it in this case.)
        //
        bCheck = _pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_ENABLE_BIDI;
    }

    //
    // Set bidi options.
    //
    vSetCheck( _hDlg, IDC_ENABLE_BIDI, bCheck );

    //
    // If we are an administrator and this is the local
    // machine, we can enable the bidi control.
    //
    if( _pPrinterData->bAdministrator( ) ){
        vEnableCtl( _hDlg, IDC_ENABLE_BIDI, bEnable );
    }

    //
    // If the ports list needs to refreshed.
    //
    _PortsLV.bReloadPorts( _pPrinterData->pszServerName(), TRUE );
}


BOOL
TPrinterPorts::
bKillActive(
    VOID
    )

/*++

Routine Description:

    Validate that the printer page is in a consistent state.

Arguments:

Return Value:

    TRUE - Ok to kill active, FALSE = can't kill active, UI displayed.

--*/

{
    COUNT cPorts;

    //
    // If we do not have access or we are not an administrator
    // do not validate the port selection.
    //
    if( _pPrinterData->bNoAccess() || !_bAdminFlag ){
        return TRUE;
    }

    cPorts = _PortsLV.cSelectedPorts();

    //
    // Validate that at least 1 port is selected.
    // Validate more than 1 port is selected if pooled printing is 
    // enabled.
    //
    if( cPorts == 0 )
    {
        //
        // Put up error explaining that at least one port must be
        // selected.
        //
        iMessage( _hDlg,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  IDS_ERR_NO_PORTS,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        _PortsLV.vSetFocus();

        //
        // Don't swith the page.
        //
        vSetDlgMsgResult( TRUE );
    } 
    else if ( (cPorts == 1) && !_PortsLV.bGetSingleSelection() )
    {
        INT iStatus = iMessage( _hDlg,
                            IDS_ERR_PRINTER_PROP_TITLE,
                            IDS_ERR_ONLY_ONE_PORT,
                            MB_OKCANCEL | MB_ICONWARNING,
                            kMsgNone,
                            NULL );
        //
        // If user wants to cancel pool printing.
        //
        if( iStatus == IDOK )
        {
            vSetCheck( _hDlg, IDC_POOLED_PRINTING, FALSE );
            _PortsLV.vSetSingleSelection(TRUE);
            _pPrinterData->bPooledPrinting() = FALSE;

            //
            // Read UI data.
            //
            vReadUI();
        } 
        else 
        {
            _PortsLV.vSetFocus();

            //
            // Don't swith the page.
            //
            vSetDlgMsgResult( TRUE );
        }
    }
    else {

        //
        // Read UI data.
        //
        vReadUI();
    }

    //
    // Routine must return true to see DlgMsgResult corretly.
    //
    return TRUE;
}

BOOL
TPrinterPorts::
_bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handle message.

Arguments:

Return Value:

--*/

{
    TStatusB bStatus;

    bStatus DBGNOCHK = TRUE;

    switch( uMsg ){
    case WM_INITDIALOG:

        bStatus DBGCHK = bSetUI();
        break;

    case WM_APP:

        vSetActive();
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam )){

        case IDC_PORT_DELETE:
            {
                //
                // Delete the selected port.
                //
                HWND hwnd = GetDlgItem( _hDlg, IDC_PORT_DELETE );

                //
                // We will only delete the port if the button is enabled, this check is
                // necessary if the user uses the delete key on the keyboard to delete
                // the port.
                //
                if( IsWindowEnabled( hwnd ) )
                {
                    bStatus DBGNOCHK = _PortsLV.bDeletePorts( _hDlg, _pPrinterData->pszServerName( ));

                    if( bStatus )
                    {
                        SetFocus( hwnd );
                        vCancelToClose();
                    }
                }
            }
            break;

        case IDC_PROPERTIES:

            //
            // Configure the selected port.
            //
            bStatus DBGNOCHK = _PortsLV.bConfigurePort( _hDlg, _pPrinterData->pszServerName( ));
            SetFocus( GetDlgItem( _hDlg, IDC_PROPERTIES ) );
            if( bStatus )
            {
                vCancelToClose();
            }
            break;

        case IDC_PORT_CREATE:
            {
                //
                // Create add ports class.
                //
                TAddPort AddPort( _hDlg,
                                  _pPrinterData->pszServerName(),
                                  _pPrinterData->bAdministrator() );

                //
                // Insure the add port was created successfully.
                //
                bStatus DBGNOCHK = VALID_OBJ( AddPort );

                if( !bStatus ){

                    vShowUnexpectedError( _hDlg, TAddPort::kErrorMessage );

                } else {

                    //
                    // Display the add port, add monitor UI.
                    //
                    bStatus DBGNOCHK = AddPort.bDoModal();

                    if( bStatus ){

                        //
                        // Refresh ports listview.
                        //
                        bStatus DBGNOCHK = _PortsLV.bReloadPorts( _pPrinterData->pszServerName(), TRUE );

                        if( bStatus ){

                            //
                            // A port was added and the list view was reloaded, since this
                            // action cannot be undone we will change the cancel button to
                            // close.
                            //
                            vCancelToClose();
                        }
                    }
                }
            }
            break;

        case IDC_POOLED_PRINTING:
            {
                //
                // Get the current selection state. 
                //
                BOOL bSingleSelection;  // status of the new state
                bSingleSelection = ( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_POOLED_PRINTING ) ? FALSE : TRUE );

                //
                // If we are going from pooled printing to non-pooled printing
                // and the printer is currently being used by multiple ports, inform
                // the user all the port selection will be lost.
                //
                if( bSingleSelection &&
                    _PortsLV.cSelectedPorts() > 1 ){

                    INT iStatus = iMessage( _hDlg,
                                        IDS_ERR_PRINTER_PROP_TITLE,
                                        IDS_ERR_PORT_SEL_CHANGE,
                                        MB_YESNO|MB_ICONEXCLAMATION,
                                        kMsgNone,
                                        NULL );
                    //
                    // If user does not want to do this.
                    //
                    if( iStatus != IDYES ){
                        vSetCheck( _hDlg, IDC_POOLED_PRINTING, TRUE );
                        bSingleSelection = FALSE;
                    } else {
                        //
                        // Remove all the port selections.
                        //
                        _PortsLV.vRemoveAllChecks();
                    }
                }

                //
                // Set the new selection state.
                //
                _PortsLV.vSetSingleSelection( bSingleSelection );
                _pPrinterData->bPooledPrinting() = !bSingleSelection;
            }
            break;

        case IDC_ENABLE_BIDI:
            break;

        default:

            bStatus DBGNOCHK = FALSE;
            break;
        }
        break;

    case WM_NOTIFY:

        //
        // Handle clicking of check boxes in ports listview.
        //
        switch( wParam ){
        case IDC_PORTS:

            //
            // Handle any ports list view messages.
            //
            bStatus DBGNOCHK = _PortsLV.bHandleNotifyMessage( lParam );
            break;

        case 0:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ){

            case PSN_KILLACTIVE:

                bStatus DBGNOCHK = bKillActive();
                break;

            case PSN_APPLY:

                bStatus DBGNOCHK = FALSE;
                break;

            default:

                bStatus DBGNOCHK = FALSE;
                break;
            }
        }
        break;

        default:

            bStatus DBGNOCHK = FALSE;
            break;
        }

        break;

    default:

        bStatus DBGNOCHK = FALSE;
        break;
    }

    //
    // If the message was handled then read the UI to detect
    // if there were any changes.
    //
    if( bStatus )
    {
        vReadUI();
    }

    return bStatus;
}

/********************************************************************

    JobScheduling.

********************************************************************/

TPrinterJobScheduling::
TPrinterJobScheduling(
    TPrinterData* pPrinterData
    ) : TPrinterProp( pPrinterData ),
        _bSetUIDone( FALSE )
{
}

TPrinterJobScheduling::
~TPrinterJobScheduling(
    VOID
    )
{
}

BOOL
TPrinterJobScheduling::
bValid(
    VOID
    )
{
    return TRUE;
}

VOID
TPrinterJobScheduling::
vEnableAvailable(
    IN BOOL bEnable
    )
{
    vEnableCtl( _hDlg, IDC_START_TIME, bEnable );
    vEnableCtl( _hDlg, IDC_UNTIL_TIME, bEnable );
    vEnableCtl( _hDlg, IDC_TO_TEXT, bEnable );
}


VOID
TPrinterJobScheduling::
vSetActive(
    VOID
    )
/*++

Routine Description:

    Routine called when the pages is set active.  This routine
    will refresh the time control if were any local changes.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    (VOID)bSetStartAndUntilTime();
}

BOOL
TPrinterJobScheduling::
bSetStartAndUntilTime(
    VOID
    )
{
    TString strFormatString;
    TStatusB bStatus;

    //
    // Get the time format string without seconds.
    //
    bStatus DBGCHK = bGetTimeFormatString( strFormatString );

    //
    // If we have retrived a valid time format string then use it,
    // else use the default format string implemented by common control.
    //
    if( bStatus )
    {
        DateTime_SetFormat(GetDlgItem( _hDlg, IDC_START_TIME ), static_cast<LPCTSTR>( strFormatString ) );
        DateTime_SetFormat(GetDlgItem( _hDlg, IDC_UNTIL_TIME ), static_cast<LPCTSTR>( strFormatString ) );
    }

    //
    // If the printer is always available.
    //
    BOOL bAlways = ( _pPrinterData->dwStartTime() == _pPrinterData->dwUntilTime( ));

    //
    // Set the start time.
    //
    SYSTEMTIME  StartTime           = { 0 };
    DWORD       dwLocalStartTime    = 0;

    GetLocalTime( &StartTime );

    dwLocalStartTime = ( !bAlways ) ? SystemTimeToLocalTime( _pPrinterData->_dwStartTime ) : 0;

    StartTime.wHour     = static_cast<WORD>( dwLocalStartTime / 60 );
    StartTime.wMinute   = static_cast<WORD>( dwLocalStartTime % 60 );

    DateTime_SetSystemtime(GetDlgItem( _hDlg, IDC_START_TIME ), GDT_VALID, &StartTime );

    //
    // Set the until time.
    //
    SYSTEMTIME  UntilTime           = { 0 };
    DWORD       dwLocalUntilTime    = 0;

    GetLocalTime( &UntilTime );

    dwLocalUntilTime = ( !bAlways ) ? SystemTimeToLocalTime( _pPrinterData->_dwUntilTime ) : 0;

    UntilTime.wHour     = static_cast<WORD>( dwLocalUntilTime / 60 );
    UntilTime.wMinute   = static_cast<WORD>( dwLocalUntilTime % 60 );

    DateTime_SetSystemtime(GetDlgItem( _hDlg, IDC_UNTIL_TIME ), GDT_VALID, &UntilTime );

    return TRUE;
}

BOOL
TPrinterJobScheduling::
bSetUI(
    VOID
    )
{
    //
    // Fill the drivers list.
    //
    bFillAndSelectDrivers();

    //
    // Set bAlways flag.
    //
    BOOL bAlways = ( _pPrinterData->dwStartTime() == _pPrinterData->dwUntilTime( ));

    //
    // Set the start and until times.
    //
    (VOID)bSetStartAndUntilTime();

    //
    // Set Availability radio buttons.
    //
    CheckRadioButton( _hDlg, IDC_ALWAYS, IDC_START, 
        bAlways ? IDC_ALWAYS : IDC_START );

    if( !_pPrinterData->bAdministrator( )){
        vEnableAvailable( FALSE );
    } else {
        vEnableAvailable( !bAlways );
    }

    //
    // Set the current priority.
    //
    SendDlgItemMessage( _hDlg, IDC_PRIORITY, EM_SETLIMITTEXT, 2, 0 );
    SendDlgItemMessage( _hDlg, IDC_PRIORITY_UPDOWN, UDM_SETRANGE, 0, MAKELPARAM( 99, 1 ));
    SendDlgItemMessage( _hDlg, IDC_PRIORITY_UPDOWN, UDM_SETPOS, 0, MAKELPARAM( _pPrinterData->dwPriority(), 0 ) );

    //
    // Set the attribte bit UI.
    //
    DWORD dwAttributes = _pPrinterData->dwAttributes();

    vSetCheck( _hDlg,
               IDC_DEVQUERYPRINT,
               dwAttributes & PRINTER_ATTRIBUTE_ENABLE_DEVQ );

    vSetCheck( _hDlg,
               IDC_PRINT_SPOOLED_FIRST,
               dwAttributes & PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST );

    vSetCheck( _hDlg,
               IDC_KEEP_PRINTED_JOBS,
               dwAttributes & PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS );

    vSetCheck( _hDlg,
               IDC_SPOOL_DATATYPE,
               !(dwAttributes & PRINTER_ATTRIBUTE_RAW_ONLY) );

    //
    // Set spool radio buttons.
    // bQueued -> Spool entire document.
    // both    -> Spool entire document.
    // neither -> Spool and print after first page.
    // bDirect -> Direct.
    //
    BOOL bSpool = !( dwAttributes & PRINTER_ATTRIBUTE_DIRECT ) ||
                  ( dwAttributes & PRINTER_ATTRIBUTE_QUEUED );

    CheckRadioButton( _hDlg, IDC_SPOOL, IDC_PRINT_DIRECT, 
        bSpool ? IDC_SPOOL : IDC_PRINT_DIRECT );

    CheckRadioButton( _hDlg, IDC_SPOOL_ALL, IDC_SPOOL_PRINT_FASTER, 
        ( dwAttributes & PRINTER_ATTRIBUTE_QUEUED ) ? IDC_SPOOL_ALL : IDC_SPOOL_PRINT_FASTER );

    vEnableCtl( _hDlg, IDC_SPOOL_ALL, bSpool );
    vEnableCtl( _hDlg, IDC_SPOOL_PRINT_FASTER, bSpool );
    vEnableCtl( _hDlg, IDC_PRINT_SPOOLED_FIRST, bSpool );
    vEnableCtl( _hDlg, IDC_DEVQUERYPRINT, bSpool );
    vEnableCtl( _hDlg, IDC_KEEP_PRINTED_JOBS, bSpool );
    vEnableCtl( _hDlg, IDC_SPOOL_DATATYPE, bSpool );

    //
    // Enable appropriately.
    //
    static UINT auControl[] = {
        IDC_ALWAYS,
        IDC_START,
        IDC_SPOOL,
        IDC_SPOOL_ALL,
        IDC_SPOOL_PRINT_FASTER,
        IDC_PRINT_DIRECT,
        IDC_DEVQUERYPRINT,
        IDC_PRINT_SPOOLED_FIRST,
        IDC_KEEP_PRINTED_JOBS,
        IDC_SPOOL_DATATYPE,
        IDC_SEPARATOR,
        IDC_PRINT_PROC,
        IDC_GLOBAL_DOCUMENT_DEFAULTS,
        IDC_TEXT_PRIORITY,
        IDC_PRIORITY,
        IDC_PRIORITY_UPDOWN,
        IDC_TEXT_DRIVER,
        IDC_DRIVER_NAME,
        IDC_DRIVER_NEW,
        0
    };

    COUNT i;
    if( !_pPrinterData->bAdministrator( )){
        for( i=0; auControl[i]; ++i ){
            vEnableCtl( _hDlg, auControl[i], FALSE );
        }
    }

    //
    // Set the "New Drivers..." button depending on the value of _bServerFullAccess
    //
    vEnableCtl( _hDlg, IDC_DRIVER_NEW, _pPrinterData->bServerFullAccess() );

    if( _pPrinterData->_bDriverPagesNotLoaded )
    {
        ShowWindow( GetDlgItem( _hDlg, IDC_GLOBAL_DOCUMENT_DEFAULTS ), SW_HIDE );
    }

    //
    // Indicate SetUI is done.  This is used to
    // prevent ReadUI from reading junk since edit controls
    // recieve EN_CHANGE messages while in WM_INITDIALOG
    //
    _bSetUIDone = TRUE;

    return TRUE;
}


VOID
TPrinterJobScheduling::
vReadUI(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Read the priority setting.
    //
    _pPrinterData->_dwPriority = (DWORD)SendDlgItemMessage( _hDlg, IDC_PRIORITY_UPDOWN, UDM_GETPOS, 0, 0 );

    //
    // Get the current attribute.
    //
    DWORD dwAttributes = _pPrinterData->dwAttributes();

    //
    // Mask out attributes we are going to read back.
    //
    dwAttributes &= ~( PRINTER_ATTRIBUTE_ENABLE_DEVQ |
                       PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST |
                       PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS |
                       PRINTER_ATTRIBUTE_QUEUED |
                       PRINTER_ATTRIBUTE_DIRECT );

    if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_DEVQUERYPRINT )){
        dwAttributes |= PRINTER_ATTRIBUTE_ENABLE_DEVQ;
    }

    if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_PRINT_SPOOLED_FIRST )){
        dwAttributes |= PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST;
    }

    if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_KEEP_PRINTED_JOBS )){
        dwAttributes |= PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS;
    }

    if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_SPOOL_DATATYPE )){
        dwAttributes &= ~PRINTER_ATTRIBUTE_RAW_ONLY;
    }else{
        dwAttributes |= PRINTER_ATTRIBUTE_RAW_ONLY;
    }

    //
    // Get radio buttons.  If direct is selected, then ignore
    // all the other spool fields.
    //
    if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_PRINT_DIRECT )){

        //
        // Direct, no spooling options selected.
        //
        dwAttributes |= PRINTER_ATTRIBUTE_DIRECT;

    } else {

        //
        // Spool, print after last page -> QUEUED.
        // Spool, print after first page -> neither.
        //
        if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_SPOOL_ALL )){
            dwAttributes |= PRINTER_ATTRIBUTE_QUEUED;
        }
    }

    _pPrinterData->_dwAttributes = dwAttributes;

    //
    // Get availability time if the printer is always
    // available then set the time to no time restriction.
    //
    if( bGetCheck( _hDlg, IDC_ALWAYS ) ){

        _pPrinterData->_dwStartTime = 0;
        _pPrinterData->_dwUntilTime = 0;

    } else {

        //
        // Get the Start time.
        //
        SYSTEMTIME StartTime;
        DateTime_GetSystemtime( GetDlgItem( _hDlg, IDC_START_TIME ), &StartTime );
        _pPrinterData->_dwStartTime = LocalTimeToSystemTime( StartTime.wHour * 60 + StartTime.wMinute );

        //
        // Get the Until time.
        //
        SYSTEMTIME UntilTime;
        DateTime_GetSystemtime( GetDlgItem( _hDlg, IDC_UNTIL_TIME ), &UntilTime );
        _pPrinterData->_dwUntilTime = LocalTimeToSystemTime( UntilTime.wHour * 60 + UntilTime.wMinute );

        //
        // If the printer start and until time are the same this is
        // exactly the same as always available.
        //
        if( _pPrinterData->_dwStartTime == _pPrinterData->_dwUntilTime )
        {
            _pPrinterData->_dwStartTime = 0;
            _pPrinterData->_dwUntilTime = 0;
        }
    }

    //
    // Read the driver name
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_DRIVER_NAME, _pPrinterData->strDriverName());

    if( !bStatus )
    {
        _pPrinterData->_bErrorSaving = TRUE;
        vShowResourceError( _hDlg );
    }
}

BOOL
TPrinterJobScheduling::
_bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    switch( uMsg ){
    case WM_INITDIALOG:

        bStatus DBGCHK = bSetUI();

        break;

    case WM_APP:

        vSetActive();
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_WININICHANGE:
        vSetActive();
        break;

    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam )){
        case IDC_SPOOL:

            vEnableCtl( _hDlg, IDC_SPOOL_ALL, TRUE );
            vEnableCtl( _hDlg, IDC_SPOOL_PRINT_FASTER, TRUE );
            vEnableCtl( _hDlg, IDC_PRINT_SPOOLED_FIRST, TRUE );
            vEnableCtl( _hDlg, IDC_DEVQUERYPRINT, TRUE );
            vEnableCtl( _hDlg, IDC_KEEP_PRINTED_JOBS, TRUE );
            vEnableCtl( _hDlg, IDC_SPOOL_DATATYPE, TRUE );

            break;

        case IDC_PRINT_DIRECT:

            vEnableCtl( _hDlg, IDC_SPOOL_ALL, FALSE );
            vEnableCtl( _hDlg, IDC_SPOOL_PRINT_FASTER, FALSE );
            vEnableCtl( _hDlg, IDC_PRINT_SPOOLED_FIRST, FALSE );
            vEnableCtl( _hDlg, IDC_DEVQUERYPRINT, FALSE );
            vEnableCtl( _hDlg, IDC_KEEP_PRINTED_JOBS, FALSE );
            vEnableCtl( _hDlg, IDC_SPOOL_DATATYPE, FALSE );
            break;

        case IDC_ALWAYS:

            vEnableAvailable( FALSE );
            break;

        case IDC_START:

            vEnableAvailable( TRUE );
            break;

        case IDC_DEVQUERYPRINT:
        case IDC_PRINT_SPOOLED_FIRST:
        case IDC_KEEP_PRINTED_JOBS:
        case IDC_SPOOL_ALL:
        case IDC_SPOOL_PRINT_FASTER:
        case IDC_SPOOL_DATATYPE:
        case IDC_DRIVER_NAME:
            break;

        case IDC_PRIORITY:
            bStatus DBGNOCHK = GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE;
            break;

        case IDC_SEPARATOR:
            vSeparatorPage();
            break;

        case IDC_PRINT_PROC:
            vPrintProcessor();
            break;

        case IDC_GLOBAL_DOCUMENT_DEFAULTS:
            vHandleGlobalDocumentDefaults( wParam, lParam );
            break;

        case IDC_DRIVER_NEW:
            vHandleNewDriver( wParam, lParam );
            break;

        default:

            bStatus DBGNOCHK = FALSE;
            break;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( wParam )
            {
            case 0:
                {
                    switch( pnmh->code )
                    {
                    case PSN_KILLACTIVE:
                        vReadUI();
                        break;

                    case PSN_SETACTIVE:
                        vSetActive();
                        break;

                    default:
                        bStatus DBGNOCHK = FALSE;
                        break;
                    }
                }
                break;

            case IDC_START_TIME:
            case IDC_UNTIL_TIME:
                {
                    switch( pnmh->code )
                    {
                    case DTN_DATETIMECHANGE:
                        break;

                    default:
                        bStatus DBGNOCHK = FALSE;
                        break;
                    }
                }
                break;

            default:
                bStatus DBGNOCHK = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus DBGNOCHK = FALSE;
        break;
    }

    //
    // If a message was handled read the ui from the dialog
    //
    if( bStatus && _bSetUIDone )
    {
        vReadUI();
    }

    return bStatus;
}

VOID
TPrinterJobScheduling::
vSeparatorPage(
    VOID
    )
{
    //
    // Create separator page dialog.
    //
    TSeparatorPage SeparatorPage( _hDlg,
                                  _pPrinterData->strSepFile(),
                                  _pPrinterData->bAdministrator(),
                                  _pPrinterData->strServerName().bEmpty() );
    //
    // Check if separator page dialog created ok.
    //
    if( !VALID_OBJ( SeparatorPage )){

        iMessage( _hDlg,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  TSeparatorPage::kErrorMessage,
                  MB_OK|MB_ICONHAND,
                  kMsgNone,
                  NULL );

        return;
    }

    //
    // Interact with the separator page.
    //
    if( SeparatorPage.bDoModal() ){

        //
        // Assign back the separator page.
        //
        if( !_pPrinterData->strSepFile().bUpdate( SeparatorPage.strSeparatorPage() ) ){
           vShowResourceError( _hDlg );
        }
    }
}

VOID
TPrinterJobScheduling::
vPrintProcessor(
    VOID
    )
{
    //
    // Create print processor dialog.
    //
    TPrintProcessor PrintProcessor( _hDlg,
                                    _pPrinterData->strServerName(),
                                    _pPrinterData->strPrintProcessor(),
                                    _pPrinterData->strDatatype(),
                                    _pPrinterData->bAdministrator() );
    //
    // Check if print processor dialog was created ok.
    //
    if( !VALID_OBJ( PrintProcessor )){

        iMessage( _hDlg,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  TPrintProcessor::kErrorMessage,
                  MB_OK|MB_ICONHAND,
                  kMsgNone,
                  NULL );

        return;
    }

    //
    // Interact with the print processor page.
    //
    if( PrintProcessor.bDoModal() ){

        //
        // Assign back the print proccesor and data type.
        //
        if( !_pPrinterData->strPrintProcessor().bUpdate( PrintProcessor.strPrintProcessor() ) ||
            !_pPrinterData->strDatatype().bUpdate( PrintProcessor.strDatatype() ) ){

            vShowResourceError( _hDlg );

        }
    }
}

VOID
TPrinterJobScheduling::
vHandleGlobalDocumentDefaults(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Handle launching global document defaults dialog.

Arguments:

    wParam - Parameter passed to by dialog proc.
    lParam - Parameter passed to by dialog proc.

Return Value:

    Nothing.

--*/

{
    (VOID)dwDocumentDefaultsInternal( _hDlg,
                                      _pPrinterData->strCurrentPrinterName(),
                                      SW_SHOW,
                                      0,
                                      0,
                                      TRUE );
}


BOOL
TPrinterJobScheduling::
bFillAndSelectDrivers(
    VOID
    )
{
    TStatusB        bStatus;
    PDRIVER_INFO_2  pDriverInfo2    = NULL;
    DWORD           cDrivers        = 0;
    DWORD           cbDriverInfo2   = 0;
    HWND            hCtlDrivers     = NULL;

    //
    // Enum the printer drivers on this machine.
    //
    bStatus DBGCHK = VDataRefresh::bEnumDrivers( _pPrinterData->pszServerName(),
                                                 _pPrinterData->strDriverEnv(),
                                                 2,
                                                 (PVOID *)&pDriverInfo2,
                                                 &cbDriverInfo2,
                                                 &cDrivers );

    if( !bStatus ){
        DBGMSG( DBG_WARN, ( "bFillAndSelectDrivers bEnumDriver failed with %d\n", GetLastError() ));
        return FALSE;
    }

    //
    // Fill in the driver information.
    //
    hCtlDrivers = GetDlgItem( _hDlg, IDC_DRIVER_NAME );

    ComboBox_ResetContent( hCtlDrivers );

    for( UINT i = 0; i < cDrivers; ++i ){

        //
        // Add only compatible driver versions.
        //
        if( bIsCompatibleDriverVersion( _pPrinterData->dwDriverVersion(), pDriverInfo2[i].cVersion ) )
        {
            //
            // Never add the fax driver, we do not permit user to switch from a printer
            // driver to a fax driver.
            //
            if( _tcscmp( pDriverInfo2[i].pName, FAX_DRIVER_NAME ) )
            {
                //
                // Filter out duplicates. There could be a version 2 and version 3 etc drivers installed.
                // The spooler SetPrinter api does not make a distiction between different
                // driver versions, since it only accepts a printer driver name.
                //
                if( SendMessage( hCtlDrivers, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pDriverInfo2[i].pName ) == CB_ERR )
                {
                    ComboBox_AddString( hCtlDrivers, pDriverInfo2[i].pName );
                }
            }
        }
    }

    //
    // Release the driver information.
    //
    FreeMem( pDriverInfo2 );

    INT iStatus = ComboBox_SelectString( hCtlDrivers,
                                         -1,
                                         _pPrinterData->strDriverName( ));

    //
    // The problem here is that the server many not have the driver
    // for the client enviroment, so we need to jam in the extra driver
    // name if iStatus is -1 (failure case).
    //
    if( iStatus == -1 ){

        DBGMSG( DBG_PROPSINFO, ( "bFillAndSelectDrivers: driver "TSTR" not on server\n", (LPCTSTR)_pPrinterData->strDriverName() ));

        ComboBox_AddString( hCtlDrivers, _pPrinterData->strDriverName( ));

        INT iSelectResult = ComboBox_SelectString( hCtlDrivers,
                                                   -1,
                                                   _pPrinterData->strDriverName( ));

        if( iSelectResult < 0 ){
            DBGMSG( DBG_WARN,( "bFillAndSelectDrivers: driver "TSTR" select failed %d\n", (LPCTSTR)_pPrinterData->strDriverName(), iSelectResult ));
        }
    }

    return TRUE;
}

VOID
TPrinterJobScheduling::
vHandleNewDriver(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TStatusB bStatus;
    TCHAR szDriverName[MAX_PATH];
    UINT cchDriverNameSize = 0;

    //
    // Setup a new driver.
    //
    bStatus DBGCHK = bPrinterSetup( _hDlg,
                                    MSP_NEWDRIVER,
                                    COUNTOF( szDriverName ),
                                    szDriverName,
                                    &cchDriverNameSize,
                                    _pPrinterData->pszServerName() );
    //
    // If new driver installed ok update the combo box.
    //
    if( bStatus )
    {
        //
        // If a new driver was added, check if it already exists in the
        // the list of drivers.
        //
        if( SendDlgItemMessage( _hDlg,
                               IDC_DRIVER_NAME,
                               CB_FINDSTRINGEXACT,
                               (WPARAM)-1,
                               (LPARAM)szDriverName ) == CB_ERR )
        {
            //
            // Add the the new driver to the combo box.
            //
            ComboBox_AddString( GetDlgItem( _hDlg, IDC_DRIVER_NAME ), szDriverName );
        }

        //
        // Select this newly added driver.
        //
        ComboBox_SelectString( GetDlgItem( _hDlg, IDC_DRIVER_NAME ), -1, szDriverName );
    }
}


/********************************************************************

    Sharing.

********************************************************************/

TPrinterSharing::
TPrinterSharing(
    TPrinterData* pPrinterData
    ) : TPrinterProp( pPrinterData ),
        _pPrtShare( NULL ),
        _bHideListed( TRUE ),
        _bSetUIDone( FALSE ),
        _bAcceptInvalidDosShareName( FALSE ),
        _bDefaultPublishState( TRUE ),
        _bSharingEnabled( TRUE )
{
}

TPrinterSharing::
~TPrinterSharing(
    VOID
    )
{
    delete _pPrtShare;
}

BOOL
TPrinterSharing::
bValid(
    VOID
    )
{
    return TPrinterProp::bValid();
}

VOID
TPrinterSharing::
vSharePrinter(
    VOID
    )

/*++

Routine Description:

    User clicked share radio button.  Change the UI appropriately.

Arguments:

Return Value:

--*/

{
    //
    // Set radio button and possibly enable window.
    //
    CheckRadioButton( _hDlg, IDC_SHARED_OFF, IDC_SHARED, IDC_SHARED );

    if( _pPrinterData->bAdministrator()){

        //
        // Set the default share name.
        //
        vSetDefaultShareName();

        vEnableCtl( _hDlg, IDC_DS_OPERATION_PENDING,    TRUE );
        vEnableCtl( _hDlg, IDC_LABEL_SHARENAME,         TRUE );
        vEnableCtl( _hDlg, IDC_SHARED_NAME,             TRUE );
        vEnableCtl( _hDlg, IDC_PUBLISHED,               TRUE );

        //
        // Set the focus to the edit control.
        //
        SetFocus( GetDlgItem( _hDlg, IDC_SHARED_NAME ) );

        //
        // Select the share name exit text.
        //
        Edit_SetSel( GetDlgItem( _hDlg, IDC_SHARED_NAME ), 0, -1 );

        //
        // Set the published check box.
        //
        if( !_bHideListed )
        {
            vSetCheck( _hDlg, IDC_PUBLISHED, _bDefaultPublishState );
        }
    }
}

VOID
TPrinterSharing::
vUnsharePrinter(
    VOID
    )

/*++

Routine Description:

    User clicked don't share radio button.  Change the UI appropriately.

Arguments:

Return Value:

--*/

{
    //
    // Set radio button and disable window.
    //
    CheckRadioButton( _hDlg, IDC_SHARED_OFF, IDC_SHARED, IDC_SHARED_OFF );

    vEnableCtl( _hDlg, IDC_DS_OPERATION_PENDING,    FALSE );
    vEnableCtl( _hDlg, IDC_LABEL_SHARENAME,         FALSE );
    vEnableCtl( _hDlg, IDC_SHARED_NAME,             FALSE );
    vEnableCtl( _hDlg, IDC_PUBLISHED,               FALSE );

    //
    // Clear the published check box.
    //
    if( !_bHideListed )
    {
        vSetCheck( _hDlg, IDC_PUBLISHED, FALSE );
    }
}

VOID
TPrinterSharing::
vSetDefaultShareName(
    VOID
    )
/*++

Routine Description:

    Sets the default share name if use has choosen to share
    this printer.  We will update the share name if
    this is the first time setting the share name.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    TStatusB bStatus;
    TString strShareName;

    //
    // Read the current contents of the edit control.
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_SHARED_NAME, strShareName );

    DBGMSG( DBG_TRACE, ( "strShareName " TSTR "\n", (LPCTSTR)strShareName ) );

    //
    // Create a share name if the current edit field is empty.
    //
    if( strShareName.bEmpty() ){

        //
        // If the share object has not be constructed, then
        // construct it.
        //
        if( !_pPrtShare ){
            _pPrtShare = new TPrtShare( _pPrinterData->pszServerName() );
        }

        //
        // Ensure the share object is still valid.
        //
        if( VALID_PTR( _pPrtShare ) ){

            //
            // Get just the printer name.
            //
            LPCTSTR pszServer;
            LPCTSTR pszPrinter;
            TCHAR szScratch[kPrinterBufMax];

            vPrinterSplitFullName( szScratch,
                                  _pPrinterData->strPrinterName( ),
                                  &pszServer,
                                  &pszPrinter );

            //
            // Create valid unique share name.
            //
            bStatus DBGNOCHK = _pPrtShare->bNewShareName( strShareName, pszPrinter );

            //
            // Set the default share name.
            //
            bStatus DBGCHK = bSetEditText( _hDlg, IDC_SHARED_NAME, strShareName );
        }
    }
}


BOOL
TPrinterSharing::
bSetUI(
    VOID
    )
{
    //
    // Set of controls on this page.
    //
    static UINT auShared[] = { IDC_SHARED_NAME,
                               IDC_SHARED,
                               IDC_SHARED_OFF,
                               IDC_PUBLISHED,
                               IDC_SERVER_PROPERTIES,
                               IDC_LABEL_SHARENAME,
                               IDC_SHARING_ENABLED_GROUPBOX,
                               IDC_SHARING_INFOTEXT,
                               0 };

    static UINT auSharingNotSupported[] = { IDC_NAME,
                                            IDC_SHARING_DISABLED,
                                            IDC_DIVIDER6,
                                            IDC_ENABLE_SHARING,
                                            0 };

    TStatusB bStatus;
    TString strText;
    TString strDirName;

    BOOL bSharingNotSupported = FALSE;

    if( FALSE == _bSharingEnabled && FALSE == _pPrinterData->bHideSharingUI() ) {

        //
        // Change the text of the link control to point the user to the
        // home networking wizard (HNW)
        //
        TString strText;
        bStatus DBGCHK = strText.bLoadString(ghInst, IDS_TEXT_SHARING_NOT_ENABLED);

        if (bStatus) {

            bSetEditText(_hDlg, IDC_SHARING_DISABLED, strText);
        }

    } else {

        //
        // If we're here sharing is either enabled or not supported for 
        // the selected printer. Sharing may not be supported for some
        // special type of printers like fax printers and/or masq 
        // printers (http printers or downlevel printers like win9x, 
        // Novell, Solaris, Linux, etc...)
        //
        bSharingNotSupported = TRUE;
    }

    //
    // If the sharing UI is to be hidded then remove all the controls.
    //
    if( FALSE == _bSharingEnabled || _pPrinterData->bHideSharingUI() ){

        //
        // Hide the sharing controls.
        //
        for( UINT i=0; auShared[i]; ++i ){
            ShowWindow( GetDlgItem( _hDlg, auShared[i] ), SW_HIDE );
        }

        //
        // Show the sharing not supported/enabled controls.
        //
        for( UINT i=0; auSharingNotSupported[i]; ++i ){

            if( bSharingNotSupported && IDC_ENABLE_SHARING == auSharingNotSupported[i] ) {

                //
                // Skip enabling this control.
                //
                continue;
            }

            ShowWindow( GetDlgItem( _hDlg, auSharingNotSupported[i] ), SW_NORMAL );
        }

        //
        // Hide a few controls that are not in the array.
        //
        ShowWindow( GetDlgItem( _hDlg, IDC_SHARING_GBOX ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_ADDITIONAL_DRIVERS_TEXT2 ), SW_HIDE );
    }
    else
    {
        //
        // Show the sharing controls.
        //
        for( UINT i=0; auShared[i]; ++i ){
            ShowWindow( GetDlgItem( _hDlg, auShared[i] ), SW_NORMAL );
        }

        //
        // Hide the sharing not supported/enabled controls.
        //
        for( UINT i=0; auSharingNotSupported[i]; ++i ){
            ShowWindow( GetDlgItem( _hDlg, auSharingNotSupported[i] ), SW_HIDE );
        }

        //
        // Show a few controls that are not in the array.
        //
        ShowWindow( GetDlgItem( _hDlg, IDC_SHARING_GBOX ), SW_NORMAL );
        ShowWindow( GetDlgItem( _hDlg, IDC_ADDITIONAL_DRIVERS_TEXT2 ), SW_NORMAL );
    }

    //
    // Save the origianal share name.
    //
    bStatus DBGCHK = _strShareName.bUpdate( _pPrinterData->strShareName() );

    //
    // Set the printer share name limit.  The limit in win9x is
    // 8.3 == 12+1 chars (including NULL terminator).  The Winnt limit
    // is defined as NNLEN;
    //
    SendDlgItemMessage( _hDlg, IDC_SHARED_NAME, EM_SETLIMITTEXT, kPrinterShareNameMax, 0 );

    //
    // Update the fields.
    //
    bSetEditText( _hDlg, IDC_SHARED_NAME, _pPrinterData->strShareName( ));

    //
    // Get the flag that indicates we need to display the listed in the directory
    // check box.
    //
    _bHideListed = _pPrinterData->ePrinterPublishState() == TPrinterData::kNoDsAvailable;

    //
    // If this is a masq printer do not show the publish UI, we do not allow publishing
    // of masq printer.  The definition of a masq printer is a printer connection that
    // happens to be implemented as a local printer with a re-directed port.  So masq
    // printer should be treated like printer connections a per user resouce.
    //
    if( _pPrinterData->_dwAttributes & PRINTER_ATTRIBUTE_NETWORK && _pPrinterData->_dwAttributes & PRINTER_ATTRIBUTE_LOCAL )
    {
        _bHideListed = TRUE;
    }

    //
    // If we have decided not to hide the listed in the directory then check
    // if the spooler policy bit will allow the user to actually publish the
    // printer.
    //
    if( !_bHideListed )
    {
        //
        // Check this policy only if we are administering a 
        // local printer. Otherwise show the publishing UI would 
        //
        if( !_pPrinterData->_pszServerName )
        {
            //
            // Read the per machine policy bit that the spooler uses for
            // controlling printer publishing.
            //
            TPersist SpoolerPolicy( gszSpoolerPolicy, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

            if( VALID_OBJ( SpoolerPolicy ) )
            {
                BOOL bCanPublish;

                bStatus DBGNOCHK = SpoolerPolicy.bRead( gszSpoolerPublish, bCanPublish );

                if( bStatus )
                {
                    _bHideListed = !bCanPublish;
                }
            }
        }

        //
        // Read the per user default publish policy bit.
        //
        TPersist Policy( gszAddPrinterWizardPolicy, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

        if( VALID_OBJ( Policy ) )
        {
            bStatus DBGNOCHK = Policy.bRead( gszAPWPublish, _bDefaultPublishState );
        }
    }

    //
    // Hide the publish controls if the DS is not loaded or we are viewing
    // a downlevel spooler.
    //
    if( _bHideListed ){

        //
        // Hide the publish check box.
        //
        ShowWindow( GetDlgItem( _hDlg, IDC_PUBLISHED ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_DS_OPERATION_PENDING ), SW_HIDE );

    } else {

        //
        // Load the pending string.
        //
        bStatus DBGCHK = _strPendingText.bLoadString( ghInst, IDS_DS_PENDING_TEXT );
    }

    //
    // Select correct radio button.
    //
    if( _pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_SHARED ){
        vSharePrinter();
    } else {
        vUnsharePrinter();
    }

    //
    // Check the published check box if the printer is published.
    //
    if( _pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_PUBLISHED ){
        vSetCheck( _hDlg, IDC_PUBLISHED, TRUE );
    } else {
        vSetCheck( _hDlg, IDC_PUBLISHED, FALSE );
    }

    //
    // If not an administrator, or the network is not installed
    // disable the edit controls.
    //
    if( !_pPrinterData->bAdministrator( ) || !TPrtShare::bNetworkInstalled() ){

        for( UINT i=0; auShared[i]; ++i ){
            vEnableCtl( _hDlg, auShared[i], FALSE );
        }
    }

    //
    // Set the "Additional Drivers..." button depending on the value of _bServerFullAccess
    //
    vEnableCtl( _hDlg, IDC_SHARING_GBOX, _pPrinterData->bServerFullAccess() );
    vEnableCtl( _hDlg, IDC_ADDITIONAL_DRIVERS_TEXT2, _pPrinterData->bServerFullAccess() );
    vEnableCtl( _hDlg, IDC_SERVER_PROPERTIES, _pPrinterData->bServerFullAccess() );

    //
    // Special case the share name if we are not an administrator make the share name
    // a read only control rather than a grayed out edit control.
    //
    if( !_pPrinterData->bAdministrator( ) || !TPrtShare::bNetworkInstalled() ){
        SendDlgItemMessage( _hDlg, IDC_SHARED_NAME, EM_SETREADONLY, TRUE, 0);
        vEnableCtl( _hDlg, IDC_SHARED_NAME, TRUE );
    }

    //
    // There are a few UI elements that need to be set when
    // we are activated, because of a driver change.  We
    // will artifically do it now.
    //
    vSetActive();

    // Indicate SetUI is done.  This is used to
    // prevent ReadUI from reading junk since edit controls
    // can recieve EN_CHANGE messages before WM_INITDIALOG
    //
    _bSetUIDone = TRUE;

    return TRUE;
}

VOID
TPrinterSharing::
vReadUI(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Check if the printer has been shared.
    //
    if( BST_CHECKED == IsDlgButtonChecked( _hDlg, IDC_SHARED_OFF )){

        //
        // Indicate the printer is not share.
        //
        _pPrinterData->dwAttributes() &= ~PRINTER_ATTRIBUTE_SHARED;

    } else {

        //
        // Indicate printer is shared.
        //
        _pPrinterData->dwAttributes() |= PRINTER_ATTRIBUTE_SHARED;
    }

    //
    // Do nothing with the publish state if the DS is not available.
    //
    if( _pPrinterData->ePrinterPublishState() != TPrinterData::kNoDsAvailable ){

        //
        // Check the current publish state.
        //
        TPrinterData::EPublishState bSelectedPublisheState = bGetCheck( _hDlg, IDC_PUBLISHED ) ?
                                    TPrinterData::kPublished : TPrinterData::kNotPublished;

        //
        // If the printer is not shared then indicate the seleceted state is not
        // published.  This will either result in no action or a unpublish.
        //
        if( !( _pPrinterData->dwAttributes() & PRINTER_ATTRIBUTE_SHARED ) ){
            bSelectedPublisheState = TPrinterData::kNotPublished;
        }

        //
        // If the publish state matched the current state then do nothing.
        //
        if( bSelectedPublisheState == _pPrinterData->ePrinterPublishState() ){

            _pPrinterData->ePrinterPublishState( TPrinterData::kNoAction );

        } else {

            //
            // Update the publish action.
            //
            if( bSelectedPublisheState == TPrinterData::kPublished ){

                _pPrinterData->ePrinterPublishState( TPrinterData::kPublish );

            } else {

                _pPrinterData->ePrinterPublishState( TPrinterData::kUnPublish );

            }
        }

        //
        // Set the new publish action.
        //
        switch ( _pPrinterData->ePrinterPublishState() )
        {
        case TPrinterData::kPublish:
            _pPrinterData->_dwAction = DSPRINT_PUBLISH | _pPrinterData->_dwAction & DSPRINT_PENDING;
            break;

        case TPrinterData::kUnPublish:
            _pPrinterData->_dwAction = DSPRINT_UNPUBLISH | _pPrinterData->_dwAction & DSPRINT_PENDING;
            break;

        case TPrinterData::kNoAction:
        default:
            break;
        }
    }

    //
    // Get the share name from the edit control.
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_SHARED_NAME, _pPrinterData->strShareName() );

    if( !bStatus )
    {
        _pPrinterData->_bErrorSaving = TRUE;
        vShowResourceError( _hDlg );
    }
}

BOOL
TPrinterSharing::
bKillActive(
    VOID
    )

/*++

Routine Description:

    Validate that the share page is in a consistent state.

Arguments:

    None.

Return Value:

    TRUE - Ok to kill active, FALSE = can't kill active, UI displayed.

--*/

{
    BOOL bStatus = TRUE;

    //
    // Read the UI in to the printer data.
    //
    vReadUI();

    //
    // If not shared then just return success.
    //
    if( !( _pPrinterData->_dwAttributes & PRINTER_ATTRIBUTE_SHARED ) )
    {
        return bStatus;
    }

    //
    // If the share name has not changed then do nothing.
    //
    if( _strShareName == _pPrinterData->_strShareName )
    {
        return bStatus;
    }

    //
    // If the share object has not been constructed, then create it.
    //
    if( !_pPrtShare )
    {
        //
        // Construct the share object.
        //
        _pPrtShare = new TPrtShare( _pPrinterData->pszServerName() );

        //
        // Ensure we have a valid share object.
        //
        bStatus = VALID_PTR( _pPrtShare );
    }

    if( bStatus )
    {
        //
        // If the share name is empty.
        //
        if( _pPrinterData->_strShareName.bEmpty() )
        {
            iMessage( _hDlg,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_NO_SHARE_NAME,
                      MB_OK|MB_ICONSTOP,
                      kMsgNone,
                      NULL );

            bStatus = FALSE;
        }
    }

    if( bStatus )
    {
        //
        // If share name is not a valid NT share name, put error message.
        //
        if( _pPrtShare->iIsValidNtShare( _pPrinterData->_strShareName ) != TPrtShare::kSuccess )
        {
            iMessage( _hDlg,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_INVALID_CHAR_SHARENAME,
                      MB_OK|MB_ICONSTOP,
                      kMsgNone,
                      NULL );

            bStatus = FALSE;
        }
    }

    if( bStatus )
    {
        //
        // Check if the share name is a valid DOS share.
        //
        if( !_bAcceptInvalidDosShareName && ( _pPrtShare->iIsValidDosShare( _pPrinterData->_strShareName ) != TPrtShare::kSuccess ) )
        {
            INT iStatus = iMessage( _hDlg,
                                    IDS_ERR_PRINTER_PROP_TITLE,
                                    IDS_ERR_SHARE_NAME_NOT_DOS,
                                    MB_YESNO|MB_ICONEXCLAMATION,
                                    kMsgNone,
                                    NULL );

            if( iStatus != IDYES )
            {
                bStatus = FALSE;
            }
            else
            {
                _bAcceptInvalidDosShareName = TRUE;
            }
        }
    }

    if( bStatus )
    {
        //
        // If the share name confilcts with an existing name.
        // If the previous name was ours and we were shared,
        // do not display the error message.
        //
        if( !_pPrtShare->bIsValidShareNameForThisPrinter( _pPrinterData->_strShareName,
                                                          _pPrinterData->strPrinterName() ))
        {
            iMessage( _hDlg,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_DUPLICATE_SHARE,
                      MB_OK|MB_ICONSTOP,
                      kMsgNone,
                      NULL );

            bStatus = FALSE;
        }
    }

    //
    // Check if it is ok to loose the focus.
    //
    if( !bStatus )
    {
        //
        // Set the focus to the shared as text.
        //
        SetFocus( GetDlgItem( _hDlg, IDC_SHARED_NAME ));

        //
        // Don't switch pages.
        //
        vSetDlgMsgResult( TRUE );

        //
        // Must return true to acknowledge the SetDlgMsgResult error.
        //
        bStatus = TRUE;
    }

    return bStatus;
}

VOID
TPrinterSharing::
vSetActive(
    VOID
    )
/*++

Routine Description:

    Routine called when the pages is set active.  This routine
    will refresh the icon if it has changed.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // Set the icon and printer name.
    //
    vSetIconName();

    //
    // Set the pending status.
    //
    if( _pPrinterData->_dwAction & DSPRINT_PENDING && !_bHideListed )
    {
        bSetEditText( _hDlg, IDC_DS_OPERATION_PENDING, _strPendingText );
    }
    else
    {
        bSetEditText( _hDlg, IDC_DS_OPERATION_PENDING, gszNULL );
    }
}

VOID
TPrinterSharing::
vAdditionalDrivers(
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*++

Routine Description:

    Handle launching server prperties dialog.

Arguments:

    wParam - Parameter passed to by dialog proc.
    lParam - Parameter passed to by dialog proc.

Return Value:

    Nothing.

--*/

{
    BOOL bStatus = FALSE;

    //
    // Create additional drivers dialog.
    //
    TAdditionalDrivers Drivers( _hDlg,
                                _pPrinterData->strServerName(),
                                _pPrinterData->strPrinterName(),
                                _pPrinterData->strDriverName(),
                                _pPrinterData->bAdministrator() );
    //
    // Check if print processor dialog was created ok.
    //
    if( VALID_OBJ( Drivers ))
    {
        bStatus = TRUE;

        if( Drivers.bDoModal() == IDOK )
        {
            vCancelToClose();
        }
    }

    //
    // If an error occurred then display an error message.
    //
    if( !bStatus )
    {
        iMessage( _hDlg,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  IDS_ERR_ADD_DRV_ERROR,
                  MB_OK|MB_ICONHAND,
                  kMsgGetLastError,
                  NULL );
    }
}

BOOL
TPrinterSharing::
_bHandleMessage(
    IN UINT   uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            //
            // First we need to check if sharing is enabled. If sharing isn't 
            // enabled then we direct the user to the home networking wizard 
            // (HNW) to enable sharing.
            //
            BOOL bSharingEnabled;
            if (SUCCEEDED(IsSharingEnabled(&bSharingEnabled)))
            {
                _bSharingEnabled = bSharingEnabled;
            }

            //
            // Load the UI now...
            //
            bSetUI();
        }
        break;

    case WM_SETTINGCHANGE:
        {
            //
            // The home networking wizard (HNW) will send WM_SETTINGCHANGE when
            // sharing options change. We need to check here and reload the UI
            // if necessary.
            //
            BOOL bSharingEnabled;
            if (SUCCEEDED(IsSharingEnabled(&bSharingEnabled)))
            {
                if (_bSharingEnabled != bSharingEnabled)
                {
                    //
                    // The setting has changed - refresh the state and reload the UI.
                    //
                    _bSharingEnabled = bSharingEnabled;
                    bSetUI();
                }
            }
        }
        break;

    case WM_APP:
        vSetActive();
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        PrintUIHelp(uMsg, _hDlg, wParam, lParam);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_SHARED_NAME:
            bStatus DBGNOCHK = GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE;

            //
            // When we change the content of share name, we need to check dos-validate share name again
            //
            if (bStatus)
            {
                _bAcceptInvalidDosShareName = FALSE;
            }

            break;

        case IDC_SHARED_OFF:
            vUnsharePrinter();
            break;

        case IDC_SHARED:
            vSharePrinter();
            break;

        case IDC_SERVER_PROPERTIES:
            vAdditionalDrivers(wParam, lParam);
            break;

        case IDC_PUBLISHED:
            break;

        default:
            bStatus DBGNOCHK = FALSE;
            break;

        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
            case PSN_KILLACTIVE:
                bStatus DBGNOCHK = bKillActive();
                break;

            case NM_RETURN:
            case NM_CLICK:
                if (IDC_SHARING_DISABLED == wParam)
                {
                    //
                    // Launch the home networking wizard (HNW) to enable sharing.
                    //
                    BOOL bRebootRequired = FALSE;
                    bStatus DBGCHK = SUCCEEDED(LaunchHomeNetworkingWizard(_hDlg, &bRebootRequired));

                    if (bStatus && bRebootRequired)
                    {
                        //
                        // Reboot was requested. Note that if the user has made changes in the UI
                        // and hasn't hit the apply button then he'll loose those changes, but 
                        // that should be OK because he still has the option to choose [No],
                        // apply the changes and then restart.
                        //
                        RestartDialogEx(_hDlg, NULL, EWX_REBOOT, 
                            SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);
                    }
                }
                else if ( IDC_ENABLE_SHARING == wParam )
                {
                    UINT iRet = DialogBox( ghInst, MAKEINTRESOURCE(IDD_SIMPLE_SHARE_ENABLE_WARNING), _hDlg, WarningDlgProc );
                    if ( IDC_RB_RUN_THE_WIZARD == iRet )
                    {
                        //
                        // Launch the home networking wizard (HNW) to enable sharing.
                        //
                        BOOL bRebootRequired = FALSE;
                        bStatus DBGCHK = SUCCEEDED(LaunchHomeNetworkingWizard(_hDlg, &bRebootRequired));

                        if (bStatus && bRebootRequired)
                        {
                            //
                            // Reboot was requested. Note that if the user has made changes in the UI
                            // and hasn't hit the apply button then he'll loose those changes, but 
                            // that should be OK because he still has the option to choose [No],
                            // apply the changes and then restart.
                            //
                            RestartDialogEx(_hDlg, NULL, EWX_REBOOT, 
                                SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);
                        }
                    }
                    else if ( IDC_RB_ENABLE_FILE_SHARING == iRet )
                    {
                        ILocalMachine *pLM;

                        HRESULT hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, IID_ILocalMachine, (void**)&pLM);
                        if (SUCCEEDED(hr))
                        {
                            hr = pLM->EnableGuest(ILM_GUEST_NETWORK_LOGON);
                            pLM->Release();

                            if ( HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr )
                            {
                                TString strTitle;
                                TString strMessage;

                                bStatus DBGCHK = strTitle.bLoadString( ghInst, IDS_ERR_ACCESS_DENIED );
                                bStatus DBGCHK = strMessage.bLoadString( ghInst, IDS_INSUFFICENT_PRIVILLEGE );

                                MessageBox( _hDlg, strMessage, strTitle, MB_OK );
                            }

                            //
                            //  Let everybody else know we changed something.
                            //
                            SendNotifyMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, 0);
                        }

                        bStatus DBGNOCHK = SUCCEEDED(hr);
                    }
                    else
                    {
                        bStatus DBGNOCHK = FALSE;
                    }
                }
                else
                {
                    bStatus DBGNOCHK = FALSE;
                }
                break;

            default:
                bStatus DBGNOCHK = FALSE;
                break;
            }
        }
        break;

    default:
        bStatus DBGNOCHK = FALSE;
        break;
    }

    if (bStatus && _bSetUIDone)
    {
        vReadUI();
    }

    return bStatus;
}

/*++

Routine Description:

    Dialog proc for the enabling sharing warning dialog.

Arguments:

    Standard dialog message parameters.

Return Value:

    EndDialog will return IDCANCEL if the user cancelled the dialog. EndDialog 
    will return IDC_RB_RUN_THE_WIZARD if the user selected to run the Wizard.
    EndDialog will return IDC_RB_ENABLE_FILE_SHARING if the user selected to
    bypass the wizard.

--*/
INT_PTR
WarningDlgProc(
    IN HWND hWnd,
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (msg)
    {
    case WM_INITDIALOG:
        {
            //
            //  Load warning icon from USER32.
            //

            HICON hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_WARNING));
            if (hIcon)
            {
                SendDlgItemMessage(hWnd, IDC_ICON_INFO, STM_SETICON, (WPARAM )hIcon, 0L);
            }

            //
            //  Set default radio item.
            //

            SendDlgItemMessage(hWnd, IDC_RB_RUN_THE_WIZARD, BM_SETCHECK, BST_CHECKED, 0);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                UINT iRet = SendDlgItemMessage(hWnd, IDC_RB_RUN_THE_WIZARD, BM_GETCHECK, 0, 0 );
                if ( BST_CHECKED == iRet )
                {
                    EndDialog(hWnd, IDC_RB_RUN_THE_WIZARD );
                }
                else
                {
                    EndDialog(hWnd, IDC_RB_ENABLE_FILE_SHARING );
                }
            }
            break;

        case IDCANCEL:
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                EndDialog(hWnd, IDCANCEL);
                return TRUE;
            }
            break;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\prtsec.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1997
All rights reserved.

Module Name:

    prtsec.cxx

Abstract:

    Print queue administration.

Author:

    Albert Ting (AlbertT)  28-Aug-1995

Environment:

Revision History:

    28-Aug-1995 AlbertT     Munged from prtq32.c.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "time.hxx"
#include "psetup.hxx"
#include "drvsetup.hxx"
#include "instarch.hxx"
#include "portslv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"

#ifdef SECURITY
#ifndef UNICODE
#error "Acledit entrypoints are Unicode only."
#endif

LPCTSTR gpszAclEdit = TEXT( "acledit.dll" );

LPCSTR gpszSedDiscretionaryAclEditor = "SedDiscretionaryAclEditor";
LPCSTR gpszSedSystemAclEditor        = "SedSystemAclEditor";
LPCSTR gpszSedTakeOwnership          = "SedTakeOwnership";


HINSTANCE TPrinterSecurity::ghLibraryAcledit;

TPrinterSecurity::PFNSED_DISCRETIONARY_ACL_EDITOR
TPrinterSecurity::gpfnSedDiscretionaryAclEditor;

TPrinterSecurity::PFNSED_SYSTEM_ACL_EDITOR
TPrinterSecurity::gpfnSedSystemAclEditor;

TPrinterSecurity::PFNSED_TAKE_OWNERSHIP
TPrinterSecurity::gpfnSedTakeOwnership;

BOOL TPrinterSecurity::gbStringsLoaded = FALSE;

GENERIC_MAPPING
TPrinterSecurity::gGenericMappingPrinters = {
    PRINTER_READ,
    PRINTER_WRITE,
    PRINTER_EXECUTE,
    PRINTER_ALL_ACCESS
};

GENERIC_MAPPING
TPrinterSecurity::gGenericMappingDocuments = {
    JOB_READ,
    JOB_WRITE,
    JOB_EXECUTE,
    JOB_ALL_ACCESS
};

SED_HELP_INFO
TPrinterSecurity::gHelpInfoPermissions = {
    NULL,
    {
        ID_HELP_PERMISSIONS_MAIN_DLG,
        0,
        0,
        ID_HELP_PERMISSIONS_ADD_USER_DLG,
        ID_HELP_PERMISSIONS_LOCAL_GROUP,
        ID_HELP_PERMISSIONS_GLOBAL_GROUP,
        ID_HELP_PERMISSIONS_FIND_ACCOUNT
    }
};

SED_HELP_INFO
TPrinterSecurity::gHelpInfoAuditing = {
    NULL,
    {
        ID_HELP_AUDITING_MAIN_DLG,
        0,
        0,
        ID_HELP_AUDITING_ADD_USER_DLG,
        ID_HELP_AUDITING_LOCAL_GROUP,
        ID_HELP_AUDITING_GLOBAL_GROUP,
        ID_HELP_AUDITING_FIND_ACCOUNT
    }
};

SED_HELP_INFO
TPrinterSecurity::gHelpInfoTakeOwnership = {
    NULL,
    {
        ID_HELP_TAKE_OWNERSHIP
    }
};


SED_OBJECT_TYPE_DESCRIPTOR
TPrinterSecurity::gObjectTypeDescriptor = {
    SED_REVISION1,                                // Revision
    TRUE,                                         // IsContainer
    TRUE,                                         // AllowNewObjectPerms
    TRUE,                                         // MapSpecificPermsToGeneric
    &TPrinterSecurity::gGenericMappingPrinters,  // GenericMapping
    &TPrinterSecurity::gGenericMappingDocuments, // GenericMappingNewObjects
    NULL,                                         // ObjectTypeName
    NULL,                                         // HelpInfo
    NULL,                                         // ApplyToSubContainerTitle
    NULL,                                         // ApplyToObjectsTitle
    NULL,                                         // ApplyToSubContainerConfirmation
    NULL,                                         // SpecialObjectAccessTitle
    NULL                                          // SpecialNewObjectAccessTitle
};

//
// Application accesses passed to the discretionary ACL editor
// as well as the Take Ownership dialog.
//
SED_APPLICATION_ACCESS
TPrinterSecurity::gpDiscretionaryAccessGroup[TPrinterSecurity::PERMS_COUNT] = {

    //
    // No Access:
    //
    {
        SED_DESC_TYPE_CONT_AND_NEW_OBJECT,  // Type
        0,                                  // AccessMask1
        0,                                  // AccessMask2
        NULL                                // PermissionTitle
    },

    //
    // Print permission:
    //
    {
        SED_DESC_TYPE_CONT_AND_NEW_OBJECT,
        GENERIC_EXECUTE | GENERIC_READ | GENERIC_WRITE,
        ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED,
        NULL
    },

    //
    // Document Administer permission:
    //
    {
        SED_DESC_TYPE_CONT_AND_NEW_OBJECT,
        STANDARD_RIGHTS_READ,
        GENERIC_ALL,
        NULL
    },

    //
    // Administer permission:
    //
    {
        SED_DESC_TYPE_CONT_AND_NEW_OBJECT,
        GENERIC_ALL,
        GENERIC_ALL,
        NULL
    }
};

//
// Application accesses passed to the system ACL editor:
//
SED_APPLICATION_ACCESS
TPrinterSecurity::gpSystemAccessGroup[TPrinterSecurity::PERMS_AUDIT_COUNT] = {

    //
    // Print permission:
    //
    {
        SED_DESC_TYPE_AUDIT,
        PRINTER_ACCESS_USE,
        ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED,
        NULL
    },

    {
        SED_DESC_TYPE_AUDIT,
        PRINTER_ACCESS_ADMINISTER | ACCESS_SYSTEM_SECURITY,
        ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED,
        NULL
    },

    {
        SED_DESC_TYPE_AUDIT,
        DELETE,
        ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED,
        NULL
    },

    {
        SED_DESC_TYPE_AUDIT,
        WRITE_DAC,
        ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED,
        NULL
    },

    {
        SED_DESC_TYPE_AUDIT,
        WRITE_OWNER,
        ACCESS_MASK_NEW_OBJ_NOT_SPECIFIED,
        NULL
    }
};


/********************************************************************

    Acquire a single privilege.  This routine needs to be rewritten
    if multiple privleges are required at once.

********************************************************************/

class TAcquirePrivilege {

    SIGNATURE( 'acpr' )

public:

    TAcquirePrivilege( LPTSTR pszPrivilegeName );
    ~TAcquirePrivilege();

    BOOL
    bValid(
        VOID
        )
    {
        return _pPrivilegesOld ? TRUE : FALSE;
    }


private:

    enum _CONSTANTS {
        kPrivilegeSizeHint = 256,
        kPrivCount = 1
    };

    HANDLE _hToken;
    PTOKEN_PRIVILEGES _pPrivilegesOld;
};

/********************************************************************

    TAcquirePrivilege

********************************************************************/

TAcquirePrivilege::
TAcquirePrivilege(
    LPTSTR pszPrivilegeName
    ) : _hToken( NULL ), _pPrivilegesOld( NULL )

/*++

Routine Description:

    This adjusts the token to acquire one privilege.

    Note: This is efficient only for acquiring a single privilege.
    For multiple privileges, this routine should be rewritten
    so that the _hToken is reused.

Arguments:

    pszPrivilegeName - Privilege string to acquire.

Return Value:

--*/

{
    if( !OpenThreadToken( GetCurrentThread( ),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          TRUE,
                          &_hToken )){

        SPLASSERT( !_hToken );

        if( GetLastError() == ERROR_NO_TOKEN ){

            //
            // This means we are not impersonating anybody.
            // Get the token out of the process.
            //
            if( !OpenProcessToken( GetCurrentProcess( ),
                                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   &_hToken )){

                SPLASSERT( !_hToken );
                return;
            }
        } else {

            SPLASSERT( !_hToken );
            return;
        }
    }

    //
    // We have a valid _hToken at this point.
    //
    BYTE abyPrivileges[sizeof( TOKEN_PRIVILEGES ) +
                       (( kPrivCount - 1 ) *
                           sizeof( LUID_AND_ATTRIBUTES ))];

    PTOKEN_PRIVILEGES pPrivilegesNew;

    pPrivilegesNew = (PTOKEN_PRIVILEGES)abyPrivileges;
    ZeroMemory( abyPrivileges, sizeof( abyPrivileges ));

    if( !LookupPrivilegeValue( NULL,
                               pszPrivilegeName,
                               &pPrivilegesNew->Privileges[0].Luid )){

        DBGMSG( DBG_WARN,
                ( "AcquirePrivilege.ctr: LookupPrivilegeValue failed: %d\n",
                  GetLastError( )));
        return;
    }

    //
    // Save previous privileges.
    //
    DWORD cbPrivilegesOld = kPrivilegeSizeHint;
    TStatusB bStatus;

Retry:

    _pPrivilegesOld = (PTOKEN_PRIVILEGES)AllocMem( cbPrivilegesOld );

    if( !_pPrivilegesOld ){
        return;
    }

    //
    // Set up the privilege set we will need.
    //
    pPrivilegesNew->PrivilegeCount = kPrivCount;
    //
    // Luid set above.
    //
    pPrivilegesNew->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    bStatus DBGCHK = AdjustTokenPrivileges( _hToken,
                                            FALSE,
                                            pPrivilegesNew,
                                            cbPrivilegesOld,
                                            _pPrivilegesOld,
                                            &cbPrivilegesOld );

    if( !bStatus ){

        FreeMem( _pPrivilegesOld );
        _pPrivilegesOld = NULL;

        if( GetLastError() == ERROR_INSUFFICIENT_BUFFER ){
            goto Retry;
        }

        DBGMSG( DBG_WARN,
                ( "AcquirePrivilege.ctr: AdjustTokenPrivileges failed: Error %d\n",
                  GetLastError( )));

        return;
    }

    //
    // _pPrivilegesOld is our valid check.
    //
}

TAcquirePrivilege::
~TAcquirePrivilege(
    VOID
    )

/*++

Routine Description:

    Restore privileges and free buffer.

    _hToken needs to be close if it is non-NULL.  _pPrivilegeOld
    is our valid check.

Arguments:

Return Value:

--*/

{
    if( _pPrivilegesOld ){

        TStatusB bStatus;

        bStatus DBGCHK = AdjustTokenPrivileges( _hToken,
                                                FALSE,
                                                _pPrivilegesOld,
                                                0,
                                                NULL,
                                                NULL );
        FreeMem( _pPrivilegesOld );
    }

    if( _hToken ){
        CloseHandle( _hToken );
    }
}

/********************************************************************

    Security.

********************************************************************/

BOOL
TPrinterSecurity::
bInitStrings(
    VOID
    )
{
    //
    // Check whether the strings have been loaded.
    //
    if( gbStringsLoaded == TRUE ){
        return TRUE;
    }

    gbStringsLoaded = TRUE;

    gHelpInfoPermissions.pszHelpFileName    = (LPTSTR)gszWindowsHlp;
    gHelpInfoAuditing.pszHelpFileName       = (LPTSTR)gszWindowsHlp;
    gHelpInfoTakeOwnership.pszHelpFileName  = (LPTSTR)gszWindowsHlp;

    gObjectTypeDescriptor.ObjectTypeName = 
        pszLoadString( ghInst, IDS_PRINTER );

    gpDiscretionaryAccessGroup[PERMS_NOACC].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_NOACCESS );

    gpDiscretionaryAccessGroup[PERMS_PRINT].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_PRINT );

    gpDiscretionaryAccessGroup[PERMS_DOCAD].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_ADMINISTERDOCUMENTS );

    gpDiscretionaryAccessGroup[PERMS_ADMIN].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_ADMINISTER );

    gpSystemAccessGroup[PERMS_AUDIT_PRINT].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_AUDIT_PRINT );

    gpSystemAccessGroup[PERMS_AUDIT_ADMINISTER].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_AUDIT_ADMINISTER );

    gpSystemAccessGroup[PERMS_AUDIT_DELETE].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_AUDIT_DELETE );

    gpSystemAccessGroup[PERMS_AUDIT_CHANGE_PERMISSIONS].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_CHANGE_PERMISSIONS );

    gpSystemAccessGroup[PERMS_AUDIT_TAKE_OWNERSHIP].PermissionTitle =
        pszLoadString( ghInst, IDS_SEC_TAKE_OWNERSHIP );

    return TRUE;
}


BOOL
TPrinterSecurity::
bHandleMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( uMsg ){
    case WM_INITDIALOG:

        if( !bInitStrings( )){
            DBGMSG( DBG_ERROR,
                    ( "PrinterSecurity.bHandlMessage: InitStrings failed %d\n",
                      GetLastError( )));
        }

        return TRUE;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return PrintUIHelp( uMsg, _hDlg, wParam, lParam );

    case WM_DESTROY:
        return TRUE;

    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam )){
        case IDC_SEC_PERMS:

            vCallDiscretionaryAclEditor();
            break;

        case IDC_SEC_AUDIT:

            vCallSystemAclEditor();
            break;

        case IDC_SEC_OWNER:

            vCallTakeOwnershipDialog();
            break;
        }
    }

    return FALSE;
}


/********************************************************************

    Load the dll.

********************************************************************/

BOOL
TPrinterSecurity::
bLoadAcledit(
    VOID
    )

/*++

Routine Description:

    Loads acledit and sets pfns.

    Note: Not multithread safe, no unloading done.

Arguments:

Return Value:

    TRUE = success, FALSE = error.

--*/
{
    if( ghLibraryAcledit ){
        return TRUE;
    }

    ghLibraryAcledit = LoadLibrary( gpszAclEdit );

    if( !ghLibraryAcledit ){
        goto Fail;
    }

    gpfnSedDiscretionaryAclEditor =
        (PFNSED_DISCRETIONARY_ACL_EDITOR)GetProcAddress(
            ghLibraryAcledit,
            gpszSedDiscretionaryAclEditor );

    gpfnSedSystemAclEditor =
        (PFNSED_SYSTEM_ACL_EDITOR)GetProcAddress(
            ghLibraryAcledit,
            gpszSedSystemAclEditor );

    gpfnSedTakeOwnership =
        (PFNSED_TAKE_OWNERSHIP)GetProcAddress(
            ghLibraryAcledit,
            gpszSedTakeOwnership );

    if( !gpfnSedDiscretionaryAclEditor ||
        !gpfnSedSystemAclEditor        ||
        !gpfnSedTakeOwnership ){

        FreeLibrary( ghLibraryAcledit );
        ghLibraryAcledit = NULL;
        goto Fail;
    }
    return TRUE;

Fail:
    vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
    return FALSE;
}

/********************************************************************

    Bring up each of the dialogs.

********************************************************************/

VOID
TPrinterSecurity::
vCallDiscretionaryAclEditor(
    VOID
    )

/*++

Routine Description:

    Edit access privileges of print queue.

Arguments:

Return Values:

--*/

{
    HANDLE hPrinterWriteDac = NULL;;
    DWORD dwAccess = WRITE_DAC;
    SED_APPLICATION_ACCESSES ApplicationAccesses;
    DWORD SedStatus;
    TStatusB bStatus;
    TStatus Status;

    Status DBGNOCHK = 0;

    PPRINTER_INFO_3 pInfo3 = NULL;
    DWORD cbInfo3 = 0;

    if( !bLoadAcledit( )){
        goto Fail;
    }

    //
    // Get the security descriptor.
    //
    if( !_pPrinterData->hPrinter( )){

        Status DBGCHK = ERROR_ACCESS_DENIED;
        goto Fail;
    }

    bStatus DBGCHK = VDataRefresh::bGetPrinter( _pPrinterData->hPrinter(),
                                                3,
                                                (PVOID*)&pInfo3,
                                                &cbInfo3 );
    if( !bStatus ){

        SPLASSERT( !pInfo3 );

        Status DBGCHK = GetLastError();
        goto Fail;
    }

    SECURITY_CONTEXT SecurityContext;

    Status DBGCHK = TPrinter::sOpenPrinter( _pPrinterData->strPrinterName(),
                                            &dwAccess,
                                            &hPrinterWriteDac );
    if( Status == ERROR_SUCCESS){
        SPLASSERT( hPrinterWriteDac );
        SecurityContext.hPrinter = hPrinterWriteDac;
    } else {
        SPLASSERT( !hPrinterWriteDac );
        SecurityContext.hPrinter = _pPrinterData->hPrinter();
    }

    SecurityContext.SecurityInformation = DACL_SECURITY_INFORMATION;
    SecurityContext.pPrinterSecurity = this;

    //
    // Pass all the permissions to the ACL editor,
    // and set up the type required:
    //
    ApplicationAccesses.Count = PERMS_COUNT;
    ApplicationAccesses.AccessGroup = gpDiscretionaryAccessGroup;
    ApplicationAccesses.DefaultPermName =
        gpDiscretionaryAccessGroup[PERMS_PRINT].PermissionTitle;

    COUNT i;
    for( i = 0; i < PERMS_COUNT; ++i ){
        ApplicationAccesses.AccessGroup[i].Type =
            SED_DESC_TYPE_CONT_AND_NEW_OBJECT;
    }

    SED_OBJECT_TYPE_DESCRIPTOR Descriptor = gObjectTypeDescriptor;

    Descriptor.AllowNewObjectPerms = TRUE;
    Descriptor.HelpInfo = &gHelpInfoPermissions;

    Status DBGCHK = (*gpfnSedDiscretionaryAclEditor)(
                        _hDlg,
                        ghInst,
                        (LPTSTR)(LPCTSTR)_pPrinterData->strServerName(),
                        &Descriptor,
                        &ApplicationAccesses,
                        (LPTSTR)(LPCTSTR)_pPrinterData->strPrinterName(),
                        SedCallback2,
                        (DWORD)&SecurityContext,
                        pInfo3->pSecurityDescriptor,
                        FALSE,
                        (BOOLEAN)!hPrinterWriteDac,
                        &SedStatus,
                        0 );

Fail:

    if( Status ){
        SetLastError( Status );
        vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
    }

    //
    // Close the printer use to write the Dac.
    //
    if( hPrinterWriteDac ){
        ClosePrinter( hPrinterWriteDac );
    }

    FreeMem( pInfo3 );
}

VOID
TPrinterSecurity::
vCallSystemAclEditor(
    VOID
    )

/*++

Routine Description:

    Edit auditing properties of print queue.

Arguments:

Return Values:

--*/

{
    HANDLE hPrinterSystemAccess = NULL;
    SED_APPLICATION_ACCESSES ApplicationAccesses;
    DWORD SedStatus;
    TStatusB bStatus;
    TStatus Status;

    Status DBGNOCHK = 0;

    if( !bLoadAcledit( )){
        return;
    }

    {
        TAcquirePrivilege AcquirePrivilege( SE_SECURITY_NAME );

        if( !VALID_OBJ( AcquirePrivilege )){
            vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
            return;
        }

        DWORD dwAccess = ACCESS_SYSTEM_SECURITY;
        Status DBGCHK = TPrinter::sOpenPrinter(
                                      _pPrinterData->strPrinterName(),
                                      &dwAccess,
                                      &hPrinterSystemAccess );

        if( Status != ERROR_SUCCESS ){
            vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
            return;
        }
    }

    //
    // Get the security descriptor.
    //
    PPRINTER_INFO_3 pInfo3 = NULL;
    DWORD cbInfo3 = 0;

    bStatus DBGCHK = VDataRefresh::bGetPrinter( hPrinterSystemAccess,
                                                3,
                                                (PVOID*)&pInfo3,
                                                &cbInfo3 );
    if( !bStatus ){
        Status DBGCHK = GetLastError();
        goto Fail;
    }

    SECURITY_CONTEXT SecurityContext;

    SecurityContext.SecurityInformation = SACL_SECURITY_INFORMATION;
    SecurityContext.pPrinterSecurity = this;

    SPLASSERT( hPrinterSystemAccess );
    SecurityContext.hPrinter = hPrinterSystemAccess;

    //
    // Pass only the Print and Administer permissions to the ACL editor,
    // and set up the type required:
    //
    ApplicationAccesses.Count = PERMS_AUDIT_COUNT;
    ApplicationAccesses.AccessGroup = gpSystemAccessGroup;
    ApplicationAccesses.DefaultPermName =
        gpDiscretionaryAccessGroup[PERMS_PRINT].PermissionTitle;

    SED_OBJECT_TYPE_DESCRIPTOR Descriptor = gObjectTypeDescriptor;

    Descriptor.AllowNewObjectPerms = FALSE;
    Descriptor.HelpInfo = &gHelpInfoAuditing;

    Status DBGCHK = (*gpfnSedSystemAclEditor)(
                        _hDlg,
                        ghInst,
                        (LPTSTR)(LPCTSTR)_pPrinterData->strServerName(),
                        &Descriptor,
                        &ApplicationAccesses,
                        (LPTSTR)(LPCTSTR)_pPrinterData->strPrinterName(),
                        SedCallback2,
                        (DWORD)&SecurityContext,
                        pInfo3->pSecurityDescriptor,
                        FALSE,
                        &SedStatus,
                        0 );

Fail:

    if( Status ){
        SetLastError( Status );
        vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
    }

    FreeMem( pInfo3 );

    if( hPrinterSystemAccess ){
        ClosePrinter( hPrinterSystemAccess );
    }
}


VOID
TPrinterSecurity::
vCallTakeOwnershipDialog(
    VOID
    )

/*++

Routine Description:

    Edit ownership of print queue.

    How does a user get to this dialog if they can't get properties
    on a printer?

Arguments:

Return Values:

--*/

{
    SED_APPLICATION_ACCESSES ApplicationAccesses;
    DWORD SedStatus;
    TStatusB bStatus;
    TStatus Status;
    HANDLE hPrinterWriteOwner = NULL;

    Status DBGNOCHK = 0;

    if( !bLoadAcledit( )){
        return;
    }

    //
    // Get the security descriptor.
    //
    PPRINTER_INFO_3 pInfo3 = NULL;
    DWORD cbInfo3 = 0;

    //
    // Attempt to retrieve the previous owner.
    //
    if( _pPrinterData->hPrinter( )){

        bStatus DBGCHK = VDataRefresh::bGetPrinter( _pPrinterData->hPrinter(),
                                                    3,
                                                    (PVOID*)&pInfo3,
                                                    &cbInfo3 );
    }

    {
        TAcquirePrivilege AcquirePrivilege( SE_TAKE_OWNERSHIP_NAME );
        SECURITY_CONTEXT SecurityContext;
        DWORD dwAccess = WRITE_OWNER;

        Status DBGCHK = TPrinter::sOpenPrinter( _pPrinterData->strPrinterName(),
                                                &dwAccess,
                                                &hPrinterWriteOwner );
        if( Status == ERROR_SUCCESS){
            SPLASSERT( hPrinterWriteOwner );
            SecurityContext.hPrinter = hPrinterWriteOwner;
        } else {
            SPLASSERT( !hPrinterWriteOwner );
            SecurityContext.hPrinter = _pPrinterData->hPrinter();
        }

        SecurityContext.SecurityInformation = OWNER_SECURITY_INFORMATION;
        SecurityContext.pPrinterSecurity = this;

        ApplicationAccesses.Count = PERMS_COUNT;
        ApplicationAccesses.AccessGroup = gpDiscretionaryAccessGroup;
        ApplicationAccesses.DefaultPermName =
            gpDiscretionaryAccessGroup[PERMS_PRINT].PermissionTitle;

        COUNT i;
        for( i = 0; i < PERMS_COUNT; ++i ){
            ApplicationAccesses.AccessGroup[i].Type = SED_DESC_TYPE_AUDIT;
        }

        BOOL bCantReadOwner;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;

        bCantReadOwner = pInfo3 ? FALSE : TRUE;
        pSecurityDescriptor = pInfo3 ?
                                  pInfo3->pSecurityDescriptor :
                                  NULL;
        TString strPrinter;
        bStatus DBGCHK = strPrinter.bLoadString( ghInst, IDS_PRINTER );

        Status DBGCHK = (*gpfnSedTakeOwnership)(
                            _hDlg,
                            ghInst,
                            (LPTSTR)(LPCTSTR)_pPrinterData->strServerName(),
                            (LPTSTR)(LPCTSTR)strPrinter,
                            (LPTSTR)(LPCTSTR)_pPrinterData->strPrinterName(),
                            1,
                            SedCallback2,
                            (DWORD)&SecurityContext,
                            pSecurityDescriptor,
                            (BOOLEAN)bCantReadOwner,
                            (BOOLEAN)!hPrinterWriteOwner,
                            &SedStatus,
                            &gHelpInfoTakeOwnership,
                            0 );
    }

    if( hPrinterWriteOwner ){
        ClosePrinter( hPrinterWriteOwner );
    }

    FreeMem( pInfo3 );
}


/********************************************************************

    Security callback routine.

********************************************************************/

DWORD
TPrinterSecurity::
SedCallback2(
    HWND                 hwndParent,
    HANDLE               hInstance,
    DWORD                dwCallBackContext,
    PSECURITY_DESCRIPTOR psdUpdated,
    PSECURITY_DESCRIPTOR pSecDescNewObjects,
    BOOLEAN              bApplyToSubContainers,
    BOOLEAN              bApplyToSubObjects,
    LPDWORD              pdwStatusReturn
    )

/*++

Routine Description:

    Called by acledit to process writes.

Arguments:

    <insert>.

Return Values:

    <insert>.

--*/

{
    UNREFERENCED_PARAMETER( pdwStatusReturn );
    UNREFERENCED_PARAMETER( bApplyToSubObjects );
    UNREFERENCED_PARAMETER( bApplyToSubContainers );
    UNREFERENCED_PARAMETER( pSecDescNewObjects );
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( hwndParent );

    PSECURITY_CONTEXT pSecurityContext;
    SECURITY_DESCRIPTOR  SecurityDescriptorNew;
    PSECURITY_DESCRIPTOR pSelfRelativeSD = NULL;
    DWORD                cbSelfRelativeSD;

    TStatusB bStatus;

    pSecurityContext = (PSECURITY_CONTEXT)dwCallBackContext;
    SPLASSERT( pSecurityContext->hPrinter );

    if( InitializeSecurityDescriptor( &SecurityDescriptorNew,
                                      SECURITY_DESCRIPTOR_REVISION1 ) &&
        BuildNewSecurityDescriptor( &SecurityDescriptorNew,
                                    pSecurityContext->SecurityInformation,
                                    psdUpdated )){

        pSelfRelativeSD = AllocCopySecurityDescriptor( &SecurityDescriptorNew,
                                                       &cbSelfRelativeSD );
    } else {

        DBGMSG( DBG_ERROR, ( "PrinterSecurity.SedCallback2: InitializeSD failedt %d\n",
                             GetLastError( )));
    }

    if( !pSelfRelativeSD ){

        DBGMSG( DBG_WARN,
                ( "PrinterSecurity.SedCallback2: Alloc copy sd failed %d\n",
                  GetLastError( )));

        SPLASSERT( GetLastError( ));

        vShowUnexpectedError( NULL, IDS_ERR_PRINTER_PROP_TITLE );
        return GetLastError();
    }

    PRINTER_INFO_3 PrinterInfo3;

    PrinterInfo3.pSecurityDescriptor = pSelfRelativeSD;

    bStatus DBGCHK = SetPrinter( pSecurityContext->hPrinter,
                                 3,
                                 (PBYTE)&PrinterInfo3,
                                 0 );
    //
    // Free the newly created sd.
    //
    FreeMem( pSelfRelativeSD );

    if( !bStatus ){

        SPLASSERT( GetLastError( ));

        iMessage( NULL,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  IDS_ERR_SAVE_PRINTER,
                  MB_OK|MB_ICONHAND,
                  kMsgGetLastError,
                  NULL );

        return GetLastError();
    }

    //
    // Refresh the property page set.
    //
    pSecurityContext->pPrinterSecurity->vReloadPages();

    return ERROR_SUCCESS;
}


/********************************************************************

    Helpers.

********************************************************************/


BOOL
TPrinterSecurity::
BuildNewSecurityDescriptor(
    PSECURITY_DESCRIPTOR psdNew,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR psdUpdated
    )

/*++

Routine Description:

    Builds new security desriptor.

Arguments:

Return Values:

--*/

{
    BOOL bDefaulted = FALSE;
    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    BOOL bDaclPresent = FALSE;
    PACL pDacl = NULL;
    BOOL bSaclPresent = FALSE;
    PACL pSacl = NULL;
    TStatusB bStatus;

    switch( SecurityInformation ){
    case OWNER_SECURITY_INFORMATION:

        if( GetSecurityDescriptorOwner( psdUpdated,
                                        &pOwnerSid,
                                        &bDefaulted )){

            bStatus DBGCHK = SetSecurityDescriptorOwner( psdNew,
                                                         pOwnerSid,
                                                         bDefaulted );
        }
        break;

    case DACL_SECURITY_INFORMATION:

        if( GetSecurityDescriptorDacl( psdUpdated,
                                       &bDaclPresent,
                                       &pDacl,
                                       &bDefaulted )) {

            bStatus DBGCHK = SetSecurityDescriptorDacl( psdNew,
                                                        bDaclPresent,
                                                        pDacl,
                                                        bDefaulted );
        }
        break;

    case SACL_SECURITY_INFORMATION:

        if( GetSecurityDescriptorSacl( psdUpdated,
                                       &bSaclPresent,
                                       &pSacl,
                                       &bDefaulted )) {

            bStatus DBGCHK = SetSecurityDescriptorSacl( psdNew,
                                                        bSaclPresent,
                                                        pSacl,
                                                        bDefaulted );
        }
        break;

    default:

        DBGMSG( DBG_ERROR, ( "PrinterSecurity.BuildSD: Unknown type %d\n",
                SecurityInformation ));
        return FALSE;
    }

    return bStatus;
}


PSECURITY_DESCRIPTOR
TPrinterSecurity::
AllocCopySecurityDescriptor(
    IN     PSECURITY_DESCRIPTOR pSecurityDescriptor,
       OUT PDWORD pdwLength
    )

/*++

Routine Description:

    Alloc copy of security descriptor.

Arguments:

    pSecurityDescriptor - sd to copy.

    pdwLength - Output length.

Return Value:

    Newly allocated sd.  NULL if failed.

--*/

{
    PSECURITY_DESCRIPTOR psdCopy;
    DWORD dwLength;

    dwLength = GetSecurityDescriptorLength(pSecurityDescriptor);

    psdCopy = AllocMem( dwLength );

    if( psdCopy ){

        MakeSelfRelativeSD( pSecurityDescriptor,
                            psdCopy,
                            &dwLength);

        *pdwLength = dwLength;
    }

    return psdCopy;
}

#endif // def SECURITY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\psetup.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998
All rights reserved.

Module Name:

    PSetup.cxx

Abstract:

    Printer setup class to gain access to the ntprint.dll
    setup code.

Author:

    Steve Kiraly (SteveKi)  19-Jan-1996

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "psetup5.hxx"
#include "drvver.hxx"

/********************************************************************

    Printer setup class.

********************************************************************/

TPSetup::
TPSetup(
    VOID
    ) : _bValid( FALSE ),
        _pPSetup50( NULL )
{
    //
    // Attemp to load the 5.0 version.
    //
    _pPSetup50 = new TPSetup50();

    if( VALID_PTR( _pPSetup50 ) )
    {
        _bValid = TRUE;
        return;
    } else {
        delete _pPSetup50;
        _pPSetup50 = NULL;
    }
}

TPSetup::
~TPSetup(
    VOID
    )
{
    delete _pPSetup50;
}

BOOL
TPSetup::
bValid(
    VOID
    )
{
    return _bValid;
}

/********************************************************************

    Member functions, most of these functions are just a channing
    call to the valid verion of the setup library.

********************************************************************/

HDEVINFO
TPSetup::
PSetupCreatePrinterDeviceInfoList(
    IN HWND hwnd
    )
{
    if( _pPSetup50 )
    {
        return _pPSetup50->PSetupCreatePrinterDeviceInfoList( hwnd );
    }
    return INVALID_HANDLE_VALUE;
}


VOID
TPSetup::
PSetupDestroyPrinterDeviceInfoList(
    IN HDEVINFO h
    )
{
    if( _pPSetup50 )
    {
        _pPSetup50->PSetupDestroyPrinterDeviceInfoList( h );
    }
}

BOOL
TPSetup::
PSetupProcessPrinterAdded(
    IN  HDEVINFO            hDevInfo,
    IN  HANDLE              hLocalData,
    IN  LPCTSTR             pszPrinterName,
    IN  HWND                hwnd
    )
{
    if( _pPSetup50 )
    {
        return _pPSetup50->PSetupProcessPrinterAdded( hDevInfo, (PPSETUP_LOCAL_DATA)hLocalData, pszPrinterName, hwnd );
    }
    return FALSE;
}

BOOL
TPSetup::
bGetSelectedDriverName(
    IN      HANDLE       hLocalData,
    IN OUT  TString     &strDriverName,
    IN      PLATFORM     platform
    ) const
{
    if( _pPSetup50 )
    {
        TStatusB bStatus;
        DRIVER_FIELD DrvField;
        DrvField.Index          = DRIVER_NAME;

        bStatus DBGCHK = _pPSetup50->PSetupGetLocalDataField( (PPSETUP_LOCAL_DATA)hLocalData, platform, &DrvField );

        if( bStatus )
        {
            bStatus DBGCHK = strDriverName.bUpdate( DrvField.pszDriverName );

            _pPSetup50->PSetupFreeDrvField( &DrvField );
        }
        return bStatus;
    }

    return NULL;
}

BOOL
TPSetup::
bGetSelectedPrintProcessorName(
    IN      HANDLE       hLocalData,
    IN OUT  TString     &strPrintProcessor,
    IN      PLATFORM     platform
    ) const
{
    //
    // This is only supported on NT5 version.
    //
    if( _pPSetup50 )
    {
        TStatusB bStatus;
        DRIVER_FIELD DrvField;
        DrvField.Index          = PRINT_PROCESSOR_NAME;

        bStatus DBGCHK = _pPSetup50->PSetupGetLocalDataField( (PPSETUP_LOCAL_DATA)hLocalData, platform, &DrvField );

        if( bStatus )
        {
            bStatus DBGCHK = strPrintProcessor.bUpdate( DrvField.pszPrintProc );

            _pPSetup50->PSetupFreeDrvField( &DrvField );
        }
        return bStatus;
    }
    return NULL;
}

BOOL
TPSetup::
bGetSelectedInfName(
    IN      HANDLE       hLocalData,
    IN OUT  TString     &strInfName,
    IN      PLATFORM     platform
    ) const
{
    if( _pPSetup50 )
    {
        TStatusB bStatus;
        DRIVER_FIELD DrvField;
        DrvField.Index          = INF_NAME;

        bStatus DBGCHK = _pPSetup50->PSetupGetLocalDataField( (PPSETUP_LOCAL_DATA)hLocalData, platform, &DrvField );

        if( bStatus )
        {
            bStatus DBGCHK = strInfName.bUpdate( DrvField.pszInfName );

            _pPSetup50->PSetupFreeDrvField( &DrvField );
        }
        return bStatus;
    }
    return NULL;
}

DWORD
TPSetup::
PSetupInstallPrinterDriver(
    IN HDEVINFO             h,
    IN HANDLE               hLocalData,
    IN LPCTSTR              pszDriverName,
    IN PLATFORM             platform,
    IN DWORD                dwVersion,
    IN LPCTSTR              pszServerName,
    IN HWND                 hwnd,
    IN LPCTSTR              pszPlatformName,
    IN LPCTSTR              pszSourcePath,
    IN DWORD                dwInstallFlags,
    IN DWORD                dwAddDrvFlags,
    OUT TString            *pstrNewDriverName,
    IN BOOL                 bOfferReplacement
    )
{
    DWORD dwRet = ERROR_INVALID_FUNCTION;
    if (_pPSetup50)
    {
        LPTSTR pszNewDriverName = NULL;
        PPSETUP_LOCAL_DATA pLocalData = (PPSETUP_LOCAL_DATA)hLocalData;

        if (!bOfferReplacement)
        {
            // request from ntprint to suppress the driver replacement offering
            dwInstallFlags |= DRVINST_DONT_OFFER_REPLACEMENT;
        }

        // call ntprint.dll ....
        dwRet = _pPSetup50->PSetupInstallPrinterDriver(h, pLocalData, pszDriverName, platform, dwVersion, 
            pszServerName, hwnd, pszPlatformName, pszSourcePath, dwInstallFlags, dwAddDrvFlags, &pszNewDriverName);

        // check to return the replacement driver name (if any)
        if (ERROR_SUCCESS == dwRet && pszNewDriverName && pszNewDriverName[0] && pstrNewDriverName)
        {
            if (!pstrNewDriverName->bUpdate(pszNewDriverName))
            {
                dwRet = ERROR_OUTOFMEMORY;
            }
        }

        if (pszNewDriverName)
        {
            // free up the memory allocated from ntprint
            _pPSetup50->PSetupFreeMem(pszNewDriverName);
        }
    }
    return dwRet;
}

HANDLE
TPSetup::
PSetupGetSelectedDriverInfo(
    IN HDEVINFO  h
    )
{
    HANDLE hHandle = NULL;

    if( _pPSetup50 )
        hHandle = _pPSetup50->PSetupGetSelectedDriverInfo( h );

    return hHandle == NULL ? INVALID_HANDLE_VALUE : hHandle ;
}

HANDLE
TPSetup::
PSetupDriverInfoFromName(
    IN  HDEVINFO    h,
    IN  LPCTSTR     pszModel
    )
{
    HANDLE hHandle = NULL;

    if( _pPSetup50 )
        hHandle = _pPSetup50->PSetupDriverInfoFromName( h, pszModel );

    return hHandle == NULL ? INVALID_HANDLE_VALUE : hHandle ;
}

VOID
TPSetup::
PSetupDestroySelectedDriverInfo(
    IN HANDLE       hLocalData
    )
{
    if( _pPSetup50 )
    {
        _pPSetup50->PSetupDestroySelectedDriverInfo( (PPSETUP_LOCAL_DATA)hLocalData );
    }
}

BOOL
TPSetup::
PSetupIsDriverInstalled(
    IN LPCTSTR      pszServerName,
    IN LPCTSTR      pszDriverName,
    IN PLATFORM     platform,
    IN DWORD        dwMajorVersion
    ) const
{
    if( _pPSetup50 )
    {
        return _pPSetup50->PSetupIsDriverInstalled( pszServerName, pszDriverName, platform, dwMajorVersion );
    }

    return FALSE;
}

INT
TPSetup::
PSetupIsTheDriverFoundInInfInstalled(
    IN  LPCTSTR             pszServerName,
    IN  HANDLE              hLocalData,
    IN  PLATFORM            platform,
    IN  DWORD               dwMajorVersion,
    IN  DWORD               dwMajorVersion2
    ) const
{
    if( _pPSetup50 )
    {
        return _pPSetup50->PSetupIsTheDriverFoundInInfInstalled( pszServerName, (PPSETUP_LOCAL_DATA)hLocalData, platform, dwMajorVersion2 );
    }

    return DRIVER_MODEL_NOT_INSTALLED;
}

BOOL
TPSetup::
PSetupSelectDriver(
    IN HDEVINFO     h,
    IN HWND         hwnd
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupSelectDriver( h );

    return FALSE;
}

BOOL
TPSetup::
PSetupRefreshDriverList(
    IN HDEVINFO h
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupRefreshDriverList( h );

    return FALSE;
}

BOOL
TPSetup::
PSetupPreSelectDriver(
   IN  HDEVINFO     h,
   IN  LPCTSTR      pszManufacturer,
   IN  LPCTSTR      pszModel
   )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupPreSelectDriver( h, pszManufacturer, pszModel );

    return FALSE;
}

HPROPSHEETPAGE
TPSetup::
PSetupCreateDrvSetupPage(
    IN HDEVINFO  h,
    IN HWND    hwnd
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupCreateDrvSetupPage( h, hwnd );

    return NULL;
}

HANDLE
TPSetup::
PSetupCreateMonitorInfo(
    IN LPCTSTR  pszServerName,
    IN HWND     hwnd
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupCreateMonitorInfo( hwnd, pszServerName);

    return NULL;
}

VOID
TPSetup::
PSetupDestroyMonitorInfo(
    IN OUT HANDLE  h
    )
{
    if( _pPSetup50 )
        _pPSetup50->PSetupDestroyMonitorInfo( h );
}

BOOL
TPSetup::
PSetupEnumMonitor(
    IN     HANDLE   h,
    IN     DWORD    dwIndex,
    OUT    LPTSTR   pMonitorName,
    IN OUT LPDWORD  pdwSize
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupEnumMonitor( h, dwIndex, pMonitorName, pdwSize );

    return FALSE;
}

BOOL
TPSetup::
PSetupInstallMonitor(
    IN  HWND        hwnd
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupInstallMonitor( hwnd );

    return FALSE;
}


BOOL
TPSetup::
PSetupBuildDriversFromPath(
    IN  HANDLE      h,
    IN  LPCTSTR     pszDriverPath,
    IN  BOOL        bEnumSingleInf
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupBuildDriversFromPath( h, pszDriverPath, bEnumSingleInf );

    return FALSE;
}

BOOL
TPSetup::
PSetupSetSelectDevTitleAndInstructions(
    IN HDEVINFO    hDevInfo,
    IN LPCTSTR     pszTitle,
    IN LPCTSTR     pszSubTitle,
    IN LPCTSTR     pszInstn
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupSetSelectDevTitleAndInstructions( hDevInfo, pszTitle, pszSubTitle, pszInstn );

    return FALSE;
}

DWORD
TPSetup::
PSetupInstallPrinterDriverFromTheWeb(
    IN  HDEVINFO            hDevInfo,
    IN  HANDLE              pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  LPOSVERSIONINFO     pOsVersionInfo,
    IN  HWND                hwnd,
    IN  LPCTSTR             pszSource
    )
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupInstallPrinterDriverFromTheWeb( hDevInfo, (PPSETUP_LOCAL_DATA)pLocalData, platform, pszServerName, pOsVersionInfo, hwnd, pszSource );

    return ERROR_INVALID_FUNCTION;
}

BOOL
TPSetup::
PSetupIsOemDriver(
    IN      HDEVINFO    hDevInfo,
    IN      HANDLE      pLocalData,
    IN OUT  PBOOL       pbIsOemDriver
    ) const
{
    if( _pPSetup50 )
        return _pPSetup50->PSetupIsOemDriver( hDevInfo, (PPSETUP_LOCAL_DATA)pLocalData, pbIsOemDriver );

    SetLastError( ERROR_INVALID_FUNCTION );
    return FALSE;
}

BOOL
TPSetup::
PSetupSetWebMode(
    IN HDEVINFO    hDevInfo,
    IN BOOL        bWebButtonOn
    )
{
    DWORD dwFlagsSet    = bWebButtonOn ? SELECT_DEVICE_FROMWEB : 0;
    DWORD dwFlagsClear  = bWebButtonOn ? 0 : SELECT_DEVICE_FROMWEB;

    if( _pPSetup50 )
        return _pPSetup50->PSetupSelectDeviceButtons( hDevInfo, dwFlagsSet, dwFlagsClear );

    return FALSE;
}

BOOL
TPSetup::
PSetupShowOem(
    IN HDEVINFO    hDevInfo,
    IN BOOL        bShowOem
    )
{
    DWORD dwFlagsSet    = bShowOem ? SELECT_DEVICE_HAVEDISK : 0;
    DWORD dwFlagsClear  = bShowOem ? 0 : SELECT_DEVICE_HAVEDISK;

    if( _pPSetup50 )
        return _pPSetup50->PSetupSelectDeviceButtons( hDevInfo, dwFlagsSet, dwFlagsClear );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\prtshare.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
All rights reserved.

Module Name:

    prtshare.cxx

Abstract:

    Printer Share class

Author:

    Steve Kiraly (SteveKi)  17-Mar-1996

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "prtshare.hxx"
#include "persist.hxx"

/********************************************************************

    Class statics.

********************************************************************/
LPCTSTR TPrtShare::_gszIllegalDosChars = TEXT( " *?/\\|,;:+=<>[]\"" );
LPCTSTR TPrtShare::_gszIllegalNtChars  = TEXT( ",\\/" );

/*++

Routine Name:

    PrtShare constructor

Routine Description:

    Initializes the printer share object.

Arguments:

    Pointer to the print server name to build a
    share enumeration for.

Return Value:

    Nothing.

--*/

TPrtShare::
TPrtShare(
    IN LPCTSTR pszServerName
    ) : _PrtPrinter( pszServerName ),
        _pNetResBuf( NULL ),
        _dwNetResCount( 0 ),
        _strServerName( pszServerName ),
        _bValid( FALSE ),
        _pfNetShareEnum( NULL ),
        _pfNetApiBufferFree( NULL ),
        _pLibrary( NULL )
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::ctor.\n" ) );

    //
    // Check if members were constructed successfuly.
    //
    if( _strServerName.bValid() &&
        _PrtPrinter.bValid() &&
        bLoad() &&
        bGetEnumData() ){

        _bValid = TRUE;
    }

    //
    // Dump debug information.
    //
#if DBG
    if( _bValid ){
        vPrint();
    }
#endif


}

/*++

Routine Name:

    PrtShare destructor.

Routine Description:

    Releases resources owned by this class.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TPrtShare::
~TPrtShare(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::dtor.\n" ) );
    vDestroy();
    vUnload();
}

/*++

Routine Name:

    bValid

Routine Description:

    Indicates if the object is in a valid state.

Arguments:

    Nothing.

Return Value:

    TRUE object is valid, FALSE object is not valid.

--*/
TPrtShare::
bValid(
    VOID
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::bValid.\n" ) );
    return _bValid;
}

/*++

Routine Name:

    bIsValidShareNameForThisPrinter

Routine Description:

    Indicates if the specified share name is valid for the specified
    share name provided as the first argument.  If the printer name is
    not provided then this routine returns an indication if the name is
    unique.

Arguments:

    pszShareName - Pointer to new share name.
    pszPrinterName - Printer name to check against.

Return Value:

    TRUE if name is a usable sharen name for this printer.
    FALSE if error occurred.

--*/
BOOL
TPrtShare::
bIsValidShareNameForThisPrinter(
    IN LPCTSTR pszShareName,
    IN LPCTSTR pszPrinterName
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::bIsValidShareNameForThisPrinter.\n" ) );

    //
    // Ensure we are in a valid state.
    //
    SPLASSERT( bValid() );
    SPLASSERT( pszShareName );
    SPLASSERT( pszPrinterName );

    BOOL bStatus;

    //
    // Check if the share name is currently in use.
    //
#ifdef _UNICODE
    bStatus = !bIsShareNameUsedW( pszShareName );
#else
    bStatus = !bIsShareNameUsedA( pszShareName );
#endif

    //
    // If we failed to find a match from the network shares.
    // Check for printer name matches, since they are exist in
    // the same namespace.
    //
    if( bStatus ){
        bStatus = _PrtPrinter.bIsValidShareNameForThisPrinter( pszShareName,
                                                               pszPrinterName );
    }

    return bStatus;

}

/*++

Routine Name:

    bRefresh

Routine Description:

    Will refresh the share enumeration structure.

Arguments:

    None.

Return Value:

    TRUE if enumeration was refreshed and object is still valid,
    FALSE if error occurred.

--*/
BOOL
TPrtShare::
bRefresh(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::bRefresh\n" ) );

    //
    // Ensure we are in a valid state.
    //
    SPLASSERT( bValid() );

    //
    // Release the current resources.
    //
    vDestroy();

    //
    // Refresh the share names and the printer names.
    //
    _bValid = bGetEnumData() && _PrtPrinter.bRefresh();

    return _bValid;
}

/*++

Routine Name:

    bNewShareName

Routine Description:

    Creates a new share name from the given name.

Arguments:

    Place where to return the new share name.
    Base share name to create new name from.

Return Value:

    TRUE new unique share name returned, FALSE error occurred.

--*/

BOOL
TPrtShare::
bNewShareName(
    IN  TString &strShareName,
    IN  const TString &strBaseShareName
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::bNewShareName\n" ) );

    //
    // Ensure we are in a valid state.
    //
    SPLASSERT( bValid() );

    UINT i;
    BOOL bStatus = FALSE;
    TCHAR szTempShareName[kPrinterShareNameBufMax];
    TCHAR szShareName[kPrinterShareNameBufMax];

    PTSTR pDst = szTempShareName;
    PTSTR pSrc = (LPTSTR)(LPCTSTR)strBaseShareName;

    //
    // Truncate the base name and filter illegal characters.
    //
    for( i = 0; i < 8 && *pSrc; i++, pSrc++ ){

        //
        // Replace illegal characters with underscore.
        //
        if( _tcschr( _gszIllegalDosChars, *pSrc ) ){
            i--; // Collapse spaces.
        } else {
            *pDst++ = *pSrc;
        }
    }

    //
    // Null terminate.
    //
    *pDst = 0;

    //
    // If the share name does not have length then
    // get the default printer share name.
    //
    if( !_tcslen( szTempShareName ) ){
        bStatus = LoadString( ghInst,
                              IDS_DEFAULT_SHARE,
                              szTempShareName,
                              COUNTOF( szTempShareName ) - 1 );
        if( !bStatus ){
            DBGMSG( DBG_WARN, ( "Unable loaded default share name resource.\n" ) );
            szTempShareName[0] = 0;
        }
    }

    //
    // Copy share name from temp buffer.
    //
    _tcscpy( szShareName, szTempShareName );

    //
    // Generate a share name until it is unique.
    //
    for( i = 2; i < 1000; i++ ){

        //
        // If unique name has been found.
        //
        if( bIsValidShareNameForThisPrinter( szShareName,
                                             strBaseShareName ) ){
            break;
        }

        //
        // Build formated share name.
        //
        wsprintf( szShareName, TEXT( "%s.%d" ), szTempShareName, i );

    }

    //
    // Copy back the share name.
    //
    bStatus = strShareName.bUpdate( szShareName );

    return bStatus;

}

/*++

Routine Name:

    iIsValidDosShare(

Routine Description:

    Indicates the spcified share name is valid.

Arguments:

    Point to share name to check.

Return Value:

    Status indicates the validity of the share name.
    kSuccess - share name is valid.
    kInvalidLength - share name is too long,
    kInvalidChar - share name has invalid characters.
    kInvalidDosFormat - share name does not conform to dos file name.

--*/
INT
TPrtShare::
iIsValidDosShare(
    IN LPCTSTR  pszShareName
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::iIsValidDosShare\n" ) );

    //
    // Ensure we are in a valid state.
    //
    SPLASSERT( bValid() );

    INT     iStatus     = kInvalidLength;
    INT     iExtLen     = 0;
    INT     iExtInc     = 0;
    BOOL    bDotFound   = FALSE;

    //
    // Check the share name pointer.
    //
    if( pszShareName  ){

        //
        // Scan for any illegal characters.
        //
        iStatus = kSuccess;
        for( UINT i = 0; *pszShareName; pszShareName++, i++, iExtLen += iExtInc ){

            //
            // If an illegal character found.
            //
            if( _tcschr( _gszIllegalDosChars, *pszShareName ) ){

                iStatus = kInvalidChar;
                break;

            //
            // Check for the dot.
            //
            } else if( *pszShareName == TEXT( '.' ) ){

                //
                // We exclude leading dots
                //
                if( i == 0 ){
                    iStatus = kInvalidDosFormat;
                    break;
                }

                //
                // If a second dot found, indicate failure.
                //
                if( bDotFound ){
                    iStatus = kInvalidDosFormat;
                    break;
                }

                //
                // Indicate dot found.
                // Set extension count.
                //
                bDotFound = TRUE;
                iExtInc = 1;

            //
            // Check if the extenstion length is greater than three.
            //
            } else if( iExtLen > 3 ) {

                iStatus = kInvalidDosFormat;
                break;

            //
            // Check the share name length
            //
            } else if( i >= kPrinterDosShareNameMax ){

                iStatus = kInvalidLength;
                break;
            }
        }
    }
    return iStatus;
}

/*++

Routine Name:

    iIsValidNtShare(

Routine Description:

    Indicates the spcified share name is valid.

Arguments:

    Point to share name to check.

Return Value:

    Status indicates the validity of the share name.
    kSuccess - share name is valid.
    kInvalidLength - share name is too long,
    kInvalidChar - share name has invalid characters.

--*/
INT
TPrtShare::
iIsValidNtShare(
    IN LPCTSTR  pszShareName
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::iIsValidNtShare\n" ) );

    //
    // Ensure we are in a valid state.
    //
    SPLASSERT( bValid() );

    INT iStatus = kInvalidLength;

    //
    // Check the share name pointer.
    //
    if( pszShareName  ){

        //
        // Scan for any illegal characters.
        //
        iStatus = kSuccess;
        for( UINT i = 0 ; *pszShareName; pszShareName++, i++ ){

            //
            // If an illegal character found.
            //
            if( _tcschr( _gszIllegalNtChars, *pszShareName ) ){

                iStatus = kInvalidChar;
                break;

            //
            // If the share name is too long.
            //
            }  else if( i >= kPrinterShareNameBufMax ){

                iStatus = kInvalidLength;
                break;
            }
        }
    }
    return iStatus;
}

/*++

Routine Name:

    bNetworkInstalled.

Routine Description:

    Checks if the network has been installed and functional.

Arguments:

    Nothing.

Return Value:

    TRUE network is installed, FALSE if network is not installed.

--*/

BOOL
TPrtShare::
bNetworkInstalled(
    VOID
    )
{
    BOOL bNetwork = FALSE;

    TPersist Persist( gszNetworkProvider, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

    if( VALID_OBJ( Persist ) )
    {
        TStatusB bStatus;
        TString strProvider;
        bStatus DBGCHK = Persist.bRead( gszProviderOrder, strProvider );

        DBGMSG( DBG_TRACE, ("Network Provider order " TSTR "\n", (LPCTSTR)strProvider ) );

        if( bStatus && strProvider.uLen() > 1 )
        {
            bNetwork = TRUE;
        }
    }
    return bNetwork;
}

#if DBG

/*++

Routine Name:
    vPrint

Routine Description:

    Displays the net resource structure.

Arguments:

    Nothing.

Return Value:

    Nothing.

--*/
VOID
TPrtShare::
vPrint(
    VOID
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::vPrint\n" ) );

    PSHARE_INFO_0 pShare = (PSHARE_INFO_0)_pNetResBuf;

    for( UINT i = 0; i < _dwNetResCount; i++ ){

        DBGMSG( DBG_TRACE, ( "Share name %ws\n", pShare[i].shi0_netname ) );

    }

    _PrtPrinter.vPrint();
}

#endif

/********************************************************************

    Private member functions.

********************************************************************/

/*++

Routine Name:

    bIsShareNameUsed

Routine Description:

    Checks if the specified share name is in use.

Arguments:

    pszShareName - share name to check.

Return Value:

    TRUE the specified share name is used.
    FALSE share name is not currently used.

--*/
BOOL
TPrtShare::
bIsShareNameUsedW(
    IN PCWSTR pszShareName
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::bIsShareNameUsedW\n" ) );

    PSHARE_INFO_0 pShare = (PSHARE_INFO_0)_pNetResBuf;

    for( UINT i = 0; i < _dwNetResCount; i++ ){

#if 0
        DBGMSG( DBG_TRACE, ( "Comparing share %ws with share %ws\n", pszShareName, pShare[i].shi0_netname ) );
#endif
        //
        // Compare the share names case is ignored.
        //
        if(!_wcsicmp( pszShareName, (PCWSTR)pShare[i].shi0_netname ) ){
            return TRUE;
        }

    }

    return FALSE;
}

/*++

Routine Name:

    bIsShareNameUsed

Routine Description:

    Checks if the specified share name is in use.

Arguments:

    pszShareName - share name to check.

Return Value:

    TRUE the specified share name is used.
    FALSE share name is not currently used.

--*/
BOOL
TPrtShare::
bIsShareNameUsedA(
    IN PCSTR pszShareName
    ) const
{
    INT iLen;
    BOOL bStatus = FALSE;
    WCHAR szwShareName[kPrinterShareNameBufMax];

    iLen = lstrlenA( pszShareName );

    if( iLen ){

        if( iLen == MultiByteToWideChar( CP_THREAD_ACP,
                                         0,
                                         (LPCSTR)pszShareName,
                                         -1,
                                         szwShareName,
                                         COUNTOF( szwShareName ) ) ){

            bStatus = bIsShareNameUsedW( szwShareName );
        }
    }

    if( bStatus ){
        DBGMSG( DBG_WARN, ( "Conversion ANSI sharename failed with %d\n", GetLastError() ) );
    }

    return bStatus;

}

/*++

Routine Name:

    bGetEnumData

Routine Description:

    Retrieve the shared resources.

Arguments:

    Nothing.

Return Value:

    TRUE the share name resources fetched successfuly.
    FALSE error occured and data is not available.

--*/

BOOL
TPrtShare::
bGetEnumData(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::bGetEnumData.\n" ) );

    BOOL bStatus = TRUE;
    LPCTSTR pszServerName = NULL;
    TString strMachineName;

    //
    // If the server name is empty then use the local machine name.
    //
    if( _strServerName.bEmpty() && bGetMachineName( strMachineName ) ){
        pszServerName = (LPTSTR)(LPCTSTR)strMachineName;
    } else {
        pszServerName = (LPTSTR)(LPCTSTR)_strServerName;
    }

    DBGMSG( DBG_TRACE, ( "Enumerating shares for " TSTR "\n", DBGSTR( pszServerName ) ) );

    //
    // We sould never get here with a null function pointer.
    //
    SPLASSERT( _pfNetShareEnum );

    //
    // Enumerate all the shares.
    //
    DWORD dwEntriesRead     = 0;
    DWORD dwTotalEntries    = 0;

    DWORD dwError = _pfNetShareEnum(
                        (LPTSTR)pszServerName,  // Server Name
                        0,
                        &_pNetResBuf,
                        0xffffffff,             // no buffer limit; get them all!
                        &dwEntriesRead,
                        &dwTotalEntries,
                        NULL);                  // no resume handle 'cause we're getting all

    if( dwError != NERR_Success){

        //
        // Just in case NetShareEnum munged it
        //
        _pNetResBuf = NULL;
        _dwNetResCount = 0;

        DBGMSG( DBG_WARN, ( "Error enumerating shares: %x with %d\n", dwError, GetLastError() ) );

    } else {

        //
        // Check if we read partial data.
        //
        SPLASSERT( dwEntriesRead == dwTotalEntries );

        //
        // Set network share resource count.
        //
        _dwNetResCount = dwEntriesRead;
    }

    return bStatus;

}

/*++

    vDestroy

Routine Description:

    Destroys this class and any allocated resources.

Arguments:

    None.

Return Value:

    Nothing.

--*/
VOID
TPrtShare::
vDestroy(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::vDestroy.\n" ) );

    if( _pfNetApiBufferFree ){
        _pfNetApiBufferFree( _pNetResBuf );
    }
    _pNetResBuf     = NULL;
    _dwNetResCount  = 0;

}

/*++

    bLoad

Routine Description:

    Loads the library initializes all procedure addresses

Arguments:

    None.

Return Value:

    TRUE library loaded and usable, FALSE if error occurred.

--*/
BOOL
TPrtShare::
bLoad(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::bLoad.\n" ) );

    BOOL bStatus = FALSE;

    //
    // If the library is not loaded then load it.
    //
    if( !_pLibrary ){

        //
        // Load the library.
        //
        _pLibrary = new TLibrary( TEXT( NETAPI32_LIB ) );

        //
        // If library is load is in a constant state.
        //
        if( VALID_PTR( _pLibrary ) ){

            _pfNetShareEnum        = (PF_NETSHAREENUM)     _pLibrary->pfnGetProc( NETSHAREENUM );
            _pfNetApiBufferFree    = (PF_NETAPIBUFFERFREE) _pLibrary->pfnGetProc( NETAPIBUFFERFREE );

            //
            // Ensure all the procedure address were initialized.
            //
            if( _pfNetShareEnum &&
                _pfNetApiBufferFree ){

                bStatus = TRUE;
            } else {
                DBGMSG( DBG_WARN, ( "TPrtShare::Failed fetching proc address.\n" ) );
            }
        }

        //
        // If something failed return to a consistent state.
        //
        if( !bStatus ){
            vUnload();
        }

    //
    // Return true the library is already loaded.
    //
    } else {
        bStatus = TRUE;
    }

    return bStatus;
}

/*++

    vUnload

Routine Description:

    Unloads the library and release any procedure address

Arguments:

    None.

Return Value:

    Nothing.

--*/
VOID
TPrtShare::
vUnload(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtShare::vUnload.\n" ) );

    delete _pLibrary;
    _pLibrary           = NULL;
    _pfNetShareEnum     = NULL;
    _pfNetApiBufferFree = NULL;
}

/********************************************************************

    Printer and Shares exist in the same name space.  To check for
    a valid printer share name we must look at all the existing
    printers.

********************************************************************/

/*++

    TPrtPrinter

Routine Description:

    Shared Printer constructor.

Arguments:

    Pointer to server name to check.

Return Value:

    Nothing.

--*/
TPrtPrinter::
TPrtPrinter(
    IN LPCTSTR pszServerName
    ) : _bValid( FALSE ),
        _pPrinterInfo2( NULL ),
        _cPrinterInfo2( 0 )
{
    DBGMSG( DBG_TRACE, ( "TPrtPrinter::ctor.\n" ) );
    TStatusB bStatus;

    //
    // Update the server name and gather the
    // printer enumeration data.
    //
    bStatus DBGCHK = _strServerName.bUpdate( pszServerName ) &&
                     bGetEnumData();
    //
    // Set valid class indication.
    //
    _bValid = bStatus;
}

/*++

    TPrtPrinter

Routine Description:

    Shared Printer destructor.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TPrtPrinter::
~TPrtPrinter(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtPrinter::dtor.\n" ) );
    FreeMem( _pPrinterInfo2 );
}

/*++

Routine Name:

    bValid

Routine Description:

    Indicates if the object is in a valid state.

Arguments:

    None.

Return Value:

    TRUE object is valid, FALSE object is not valid.

--*/
BOOL
TPrtPrinter::
bValid(
    VOID
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtPrinter::bValid.\n" ) );
    return _bValid;
}

/*++

Routine Name:

    bRefresh

Routine Description:

    Updates the printer enumeration with the system.

Arguments:

    Nothing.

Return Value:

    TRUE updated was successful, FALSE if error occurred.

--*/
BOOL
TPrtPrinter::
bRefresh(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrtPrinter::bRefresh.\n" ) );

    //
    // Ensure we are in a valid state.
    //
    SPLASSERT( bValid() );

    //
    // Refresh the printer enumeration data.
    //
    _bValid = bGetEnumData();
    return _bValid;
}

/*++

Routine Name:

    bIsValidShareNameForThisPrinter

Routine Description:

    Indicates if the specified share name is valid for the specified
    share name provided as the first argument.  If the printer name is
    not provided then this routine returns an indication if the name is
    unique.

Arguments:

    pszShareName - Printer share name to check.
    pszPrinterName - Printer name to check against.

Return Value:

    TRUE if name is a usable sharen name for this printer.
    FALSE if error occurred.

--*/
BOOL
TPrtPrinter::
bIsValidShareNameForThisPrinter(
    IN LPCTSTR pszShareName,
    IN LPCTSTR pszPrinterName
    ) const
{

    DBGMSG( DBG_TRACE, ( "TPrtPrinter::bIsValidShareNameForThisPrinter.\n" ) );

    BOOL    bStatus     = TRUE;

    //
    // Ensure we are in a valid state.
    //
    SPLASSERT( bValid() );
    SPLASSERT( pszShareName );

    //
    // Traverse all the enumerated shares.
    //
    for( UINT i = 0; i < _cPrinterInfo2; i++ ){

        //
        // If nobody has access to this printer then spooler doesn't really share 
        // the printer out even if it has the shared bit up and eating up a name in 
        // the namespace, so we need to do an additionbal check here to make sure
        // the proposed share name doesn't collide with an existing printer share name.
        //
        if( _pPrinterInfo2[i].pShareName && !_tcsicmp( pszShareName, _pPrinterInfo2[i].pShareName ) ){
            bStatus = FALSE;
            break;
        }

        LPCTSTR pszServer;
        LPCTSTR pszPrinter;
        TCHAR szScratch[kPrinterBufMax];

        //
        // Split the printer name into its components.
        //
        vPrinterSplitFullName( szScratch,
                               _pPrinterInfo2[i].pPrinterName,
                               &pszServer,
                               &pszPrinter );
        //
        // If the share name is a fully qualified name then use the fully
        // qualified printer name.
        //
        if( pszShareName[0] == TEXT( '\\' ) &&
            pszShareName[1] == TEXT( '\\' ) ){

            pszPrinter = _pPrinterInfo2[i].pPrinterName;
        }
#if 0
        DBGMSG( DBG_TRACE, ( "Comparing share " TSTR " with printer " TSTR "\n",  pszShareName, pszPrinter ) );
#endif
        //
        // Compare the share name to the printer name.
        //
        if( !_tcsicmp( pszShareName, pszPrinter ) ){
            bStatus = FALSE;
            break;
        }
    }

    //
    // If the share name is not unique check if happens to be the
    // same as the printer name.  It's ok for the printer name
    // and the share name to be the same.  The spooler allows this.
    //
    if( !bStatus && pszPrinterName ){

        LPCTSTR pszServer;
        LPCTSTR pszPrinter;
        TCHAR szScratch[kPrinterBufMax];

        //
        // Split the printer name into its components.
        //
        vPrinterSplitFullName( szScratch,
                               pszPrinterName,
                               &pszServer,
                               &pszPrinter );
        //
        // If the share name is a fully qualified name then use the fully
        // qualified printer name.
        //
        if( pszShareName[0] == TEXT( '\\' ) &&
            pszShareName[1] == TEXT( '\\' ) ){

            pszPrinter = pszPrinterName;
        }

        DBGMSG( DBG_TRACE, ( "Comparing like share " TSTR " with printer " TSTR "\n",
                             pszShareName, DBGSTR( pszPrinter ) ) );

        //
        // Check if the printer name matches the share name
        //
        if( !_tcsicmp( pszShareName, pszPrinter ) ){
            DBGMSG( DBG_TRACE, ("The printer name matches the share name.\n") );
            bStatus = TRUE;
        }
    }

    return bStatus;

}

/*++

Routine Name:

    bGetEnumData

Routine Description:

    Fetches the printer enumeration data.

Arguments:

    None.

Return Value:

    TRUE enumeration data fetched, FALSE if error occurred.

--*/
BOOL
TPrtPrinter::
bGetEnumData(
    VOID
    )
{

    DBGMSG( DBG_TRACE, ( "TPrtPrinter::bGetEnumData.\n" ) );

    //
    // Release any previously allocated structure.
    //
    FreeMem( _pPrinterInfo2 );

    //
    // Reset the variables.
    //
    _pPrinterInfo2          = NULL;
    _cPrinterInfo2          = 0;
    DWORD cbPrinterInfo2    = 0;

    //
    // Enumerate the current printers.
    //
    TStatusB bEnumStatus;
    bEnumStatus DBGCHK = VDataRefresh::bEnumPrinters(
                            PRINTER_ENUM_NAME,
                            (LPTSTR)(LPCTSTR)_strServerName,
                            2,
                            (PVOID *)&_pPrinterInfo2,
                            &cbPrinterInfo2,
                            &_cPrinterInfo2 );

    return bEnumStatus;

}


#if DBG

/*++

Routine Name:

    vPrint

Routine Description:

    Prints the printer enumeration data.

Arguments:

    None.

Return Value:

    Nothing.

--*/
VOID
TPrtPrinter::
vPrint(
    VOID
    ) const
{
    DBGMSG( DBG_TRACE, ( "TPrtPrinter::vPrint.\n" ) );

    SPLASSERT( bValid() );

    DBGMSG( DBG_TRACE, ( "_pPrinterInfo2 %x.\n", _pPrinterInfo2 ) );
    DBGMSG( DBG_TRACE, ( "_cPrinterInfo2 %d\n",  _cPrinterInfo2 ) );

    for( UINT i = 0; i < _cPrinterInfo2; i++ ){
        DBGMSG( DBG_TRACE, ( "PrinterInfo2.pPrinterName " TSTR "\n", _pPrinterInfo2[i].pPrinterName ) );
    }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\prtprops.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
All rights reserved.

Module Name:

    prtprops.cxx

Abstract:

    Printer Property Sheet

Author:

    Steve Kiraly (SteveKi)  13-Feb-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "time.hxx"
#include "psetup.hxx"
#include "drvsetup.hxx"
#include "instarch.hxx"
#include "portslv.hxx"
#include "driverif.hxx"
#include "driverlv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "prtshare.hxx"
#include "drvsetup.hxx"
#include "archlv.hxx"
#include "detect.hxx"
#include "setup.hxx"
#include "propmgr.hxx"
#include "prtprops.hxx"


/********************************************************************

    All printer property sheet manager.

********************************************************************/

/*++

Routine Name:

    TPrinterPropertySheetManager

Routine Description:

    Constructor.

Arguments:

    Pointer to the printer data.

Return Value:

    Nothing.

--*/
TPrinterPropertySheetManager::
TPrinterPropertySheetManager(
    TPrinterData* pPrinterData
    ) : _General( pPrinterData ),
        _Ports( pPrinterData ),
        _JobScheduling( pPrinterData ),
        _Sharing( pPrinterData ),
        _pPrinterData( pPrinterData ),
        _hDrvPropSheet( NULL ),
        _bValid( TRUE ),
        _hwndParent( NULL )
{
}

/*++

Routine Name:

    ~TPrinterPropertySheetManager

Routine Description:

    Destructor.

Arguments:

    Pointer to the printer data.

Return Value:

    Nothing.

--*/
TPrinterPropertySheetManager::
~TPrinterPropertySheetManager(
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager::dtor.\n" ) );
}


/*++

Routine Name:

    bValid

Routine Description:

    Indicates if the object is in a valid state.

Arguments:

    Nothing.

Return Value:

    TRUE valid object, FALSE invalid object.

--*/
BOOL
TPrinterPropertySheetManager::
bValid(
    VOID
    )
{
    return _General.bValid() && _Ports.bValid() &&
           _JobScheduling.bValid() && _Sharing.bValid() && _bValid;

}

/*++

Routine Name:

    bDisplayPages

Routine Description:

    Display the property sheet pages.

Arguments:

    Nothing.

Return Value:

    TRUE sheets displayed, FALSE error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bDisplayPages(
    VOID
    )
{
    //
    // Load the printer data.
    //
    BOOL bStatus = _pPrinterData->bLoad();

    if( !bStatus ){

        iMessage( NULL,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  IDS_ERR_PRINTER_PROP,
                  MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                  kMsgGetLastError,
                  NULL );

    }

    if( bStatus ){

        if( _pPrinterData->bNoAccess() ){

            //
            // Display the security tab.
            //
            bStatus = bDisplaySecurityTab( _pPrinterData->hwnd() );

        } else
        {

            //
            // Display the property sheets.
            //
            bStatus = TPropertySheetManager::bDisplayPages( _pPrinterData->hwnd() );
        }
    }

    return bStatus;
}

/*++

Routine Name:

    bRefreshDriverPages

Routine Description:

    This routine is called when the driver has been changed.  It will
    release any previous driver pages and then build the new driver
    pages.

Arguments:

    None.

Return Value:

    TRUE if success, FALSE if error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bRefreshDriverPages(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager bRefreshDriverPages\n") );

    //
    // Release the driver pages.
    //
    vReleaseDriverPages( &_CPSUIInfo );

    //
    // Release any shell extension pages.
    //
    _ShellExtPages.vDestroy( &_CPSUIInfo );

    //
    // Build any shell extension pages, if this fails it does not
    // constitute a failure.  We still want to bring up our
    // property pages.
    //
    _ShellExtPages.bCreate( &_CPSUIInfo, _pPrinterData->strCurrentPrinterName() );

    //
    // Check to build the driver specific pages.
    //
    bCheckToBuildDriverPages( &_CPSUIInfo );

    //
    // Always TRUE.
    //
    return TRUE;
}

/*++

Routine Name:

    bGetDriverPageHandle

Routine Description:

    This routine is to get the property sheet handle of the first
    driver property sheet.

Arguments:

    Pointer where to return the driver page handle.

Return Value:

    TRUE if success, FALSE if error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bGetDriverPageHandle(
    IN HPROPSHEETPAGE *phPage
    )
{
    TStatusB bStatus;
    DWORD cPages;
    HPROPSHEETPAGE *phPages;

    bStatus DBGCHK = bGetDriverPageHandles( &_CPSUIInfo, &cPages, &phPages );

    if( bStatus )
    {
        *phPage = phPages[0];
        delete [] phPages;
    }

    return bStatus;
}

/********************************************************************

    Private member functions.

********************************************************************/

/*++

Routine Name:

    bBuildsPages

Routine Description:

    This routine is called from the compstui dispatch
    function in response to the REASON_INIT message.  As a
    side issue this routine will bring up the printer
    property sheets if we have access to display the sheets.  If
    access is denied on the security page will be shown.

Arguments:

    pCPSUIInfo - pointer to compstui info header.

Return Value:

    TRUE if success, FALSE if error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bBuildPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager bBuildPages\n") );

    TStatusB bStatus;
    LONG_PTR hResult;

    UINT    uPages[kMaxGroups];
    HANDLE  hGroups[kMaxGroups];
    UINT    cGroups = 0;

    //
    // Set the default activation context to be V6 prior calling into
    // compstui to create the pages. This will force V6 context unless
    // the callbacks which create the compstui pages specify otherwise
    // on a per page basis.
    //
    bStatus DBGCHK = (BOOL)pCPSUIInfo->pfnComPropSheet(
            pCPSUIInfo->hComPropSheet, 
            CPSFUNC_SET_FUSION_CONTEXT, 
            reinterpret_cast<LPARAM>(g_hActCtx),
            static_cast<LPARAM>(0));

    if( bStatus )
    {
        //
        // Build the spooler pages.
        //
        bStatus DBGCHK = bBuildSpoolerPages( pCPSUIInfo );

        if( bStatus && TPropertySheetManager::bValidCompstuiHandle( reinterpret_cast<LONG_PTR>(pCPSUIInfo->hComPropSheet) ) ){

            //
            // Collect the count of the spooler pages
            //
            hGroups[cGroups] = pCPSUIInfo->hComPropSheet;
            uPages[cGroups] = pCPSUIInfo->pfnComPropSheet( hGroups[cGroups],
                                                           CPSFUNC_GET_PAGECOUNT,
                                                           static_cast<LPARAM>(0),
                                                           static_cast<LPARAM>(0));
            cGroups++;

            //
            // Build any shell extension property pages.
            //
            if( _ShellExtPages.bCreate( pCPSUIInfo, _pPrinterData->strPrinterName() ) ){

                //
                // Collect the count of the shell extention pages
                //
                hGroups[cGroups] = _ShellExtPages.hPropSheet();
                uPages[cGroups] = pCPSUIInfo->pfnComPropSheet( hGroups[cGroups],
                                                               CPSFUNC_GET_PAGECOUNT,
                                                               static_cast<LPARAM>(0),
                                                               static_cast<LPARAM>(0));
                cGroups++;

            }

            //
            // Only load the driver pages if we have access.
            //
            if( !_pPrinterData->bNoAccess() ){

                //
                // Check to build the driver specific pages.
                //
                if( bCheckToBuildDriverPages( pCPSUIInfo ) && TPropertySheetManager::bValidCompstuiHandle( _hDrvPropSheet ) ){

                    //
                    // Collect the count of the driver UI pages
                    //
                    hGroups[cGroups] = reinterpret_cast<HANDLE>(_hDrvPropSheet);
                    uPages[cGroups] = pCPSUIInfo->pfnComPropSheet( hGroups[cGroups],
                                                                   CPSFUNC_GET_PAGECOUNT,
                                                                   static_cast<LPARAM>(0),
                                                                   static_cast<LPARAM>(0));
                    cGroups++;

                }
            }

        }

        if( bStatus ){

            //
            // Find the group to select the page to
            //
            UINT uGrp = 0;
            UINT uStartPage = _pPrinterData->uStartPage();

            while( uGrp < cGroups )
            {
                if( uStartPage < uPages[uGrp] )
                {
                    break;
                }
                else
                {
                    uStartPage -= uPages[uGrp];
                    uGrp++;
                }
            }

            //
            // Set the start page.  We can only set the start page
            // to one of our pages. If this fails it is not fatal.
            //
            if( uGrp < cGroups ){

                CAutoPtr<HPROPSHEETPAGE> sphPages = new HPROPSHEETPAGE[ uPages[uGrp] ];

                if( sphPages ){

                    //
                    // Get the property pages for the selected group.
                    //
                    UINT cPages = pCPSUIInfo->pfnComPropSheet( hGroups[uGrp],
                                                               CPSFUNC_GET_HPSUIPAGES,
                                                               reinterpret_cast<LPARAM>(sphPages.GetPtr()),
                                                               static_cast<LPARAM>(uPages[uGrp]) );

                    if( uStartPage < cPages ){

                        //
                        // Select the page in the appropriate group.
                        //
                        hResult = pCPSUIInfo->pfnComPropSheet( hGroups[uGrp],
                                                               CPSFUNC_SET_HSTARTPAGE,
                                                               reinterpret_cast<LPARAM>(sphPages.GetPtr()[uStartPage]),
                                                               static_cast<LPARAM>(0) );

                        //
                        // Check to validate the result
                        //
                        if( !bValidCompstuiHandle( hResult ) ){
                            DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager CPSFUNC_SET_HSTARTPAGE failed with %d.\n", hResult ) );
                        }
                    }
                }

            } else {

                //
                // Set the start page.  We can only set the start page
                // to one of our pages. If this fails it is not fatal.
                //
                if( !_pPrinterData->strSheetName().bEmpty() ){

                    hResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                           CPSFUNC_SET_HSTARTPAGE,
                                                           (LPARAM)0,
                                                           (LPARAM)(LPCTSTR)_pPrinterData->strSheetName() );
                    if( !bValidCompstuiHandle( hResult ) ){
                        DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager CPSFUNC_SET_HSTARTPAGE failed with %d.\n", hResult ) );
                    }
                }
            }
        }
    }

    return TRUE;
}

/*++

Routine Name:

    bBuildSpoolerPages

Routine Description:

    Builds the spooler related pages.

Arguments:

    pCPSUIInfo - pointer to compstui info header.

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bBuildSpoolerPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;
    LONG_PTR hResult;
    PROPSHEETPAGE  psp;

    //
    // Build the printer property pages.
    //
    struct SheetInitializer {
        TPrinterProp* pSheet;
        INT iDialog;
    };

    SheetInitializer aSheetInit[] = {
        {&_General,          DLG_PRINTER_GENERAL        },
        {&_Sharing,          DLG_PRINTER_SHARING        },
        {&_Ports,            DLG_PRINTER_PORTS          },
        {&_JobScheduling,    DLG_PRINTER_JOB_SCHEDULING },
    };

    ZeroMemory( &psp, sizeof( psp ) );

    for( UINT i = 0; i < COUNTOF( aSheetInit ); ++i ){

        //
        // Printers using the fax driver do not need the ports tab.
        //
        if( _pPrinterData->bIsFaxDriver() ){

            if( aSheetInit[i].iDialog == DLG_PRINTER_PORTS || aSheetInit[i].iDialog == DLG_PRINTER_JOB_SCHEDULING ){
                continue;
            }
        }

        psp.dwSize      = sizeof( psp );
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = ghInst;
        psp.pfnDlgProc  = MGenericProp::SetupDlgProc;
        psp.pszTemplate = MAKEINTRESOURCE( aSheetInit[i].iDialog );
        psp.lParam      = (LPARAM)(MGenericProp*)aSheetInit[i].pSheet;

        hResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                               CPSFUNC_ADD_PROPSHEETPAGE,
                                               (LPARAM)&psp,
                                               NULL );

        if( !bValidCompstuiHandle( hResult ) ){

            DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager CPSFUNC_ADD_PROPSHEETPAGE failed with %d.\n", hResult ) );
            bStatus DBGNOCHK = FALSE;
            break;

        } else {

            DBGMSG( DBG_TRACE, ( "Page added %d %x.\n", i, hResult ) );

            //
            // Save the page handle.
            //
            _pPrinterData->_hPages[i] = hResult;
        }
    }
    return bStatus;
}

/*++

Routine Name:

    bInstallDriverPage

Routine Description:

    Installs the driver pages if they are not on this machine.

Arguments:

    Nothing.

Return Value:

    TRUE success, FALSE error occurred - driver pages we not loaded.

--*/
BOOL
TPrinterPropertySheetManager::
bInstallDriverPage(
    VOID
    )
{
    //
    // Check if we have access on this machine to install a printer
    // driver.  If we do then we ask the user if they want to install
    // the correct printer driver.
    //
    TStatus Status;
    DWORD dwAccess      = SERVER_ALL_ACCESS;
    HANDLE hPrintServer = NULL;
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    //
    // Open the print server
    //
    Status DBGCHK = TPrinter::sOpenPrinter( NULL, &dwAccess, &hPrintServer );

    //
    // If print server was opened and we do have access,
    // then let the user install the driver.
    //
    if( Status == ERROR_SUCCESS ){

        //
        // Ensure we close the printer handle.
        //
        ClosePrinter( hPrintServer );

        //
        // Driver load failed, display error message to user, indicating
        // the device option will not be displayed, and if they want
        // to install the driver.
        //
        if( IDYES == iMessage( _pPrinterData->hwnd(),
                               IDS_ERR_PRINTER_PROP_TITLE,
                               IDS_ERR_NO_DRIVER_INSTALLED,
                               MB_YESNO|MB_ICONEXCLAMATION,
                               kMsgNone,
                               NULL,
                               static_cast<LPCTSTR>(_pPrinterData->strDriverName()) ) ){

            TCHAR szDriverName[kPrinterBufMax];
            UINT cchDriverName = 0;
            _tcscpy( szDriverName, _pPrinterData->strDriverName() );

            //
            // The user indicated they would like to install the driver.
            // A null server name is passed because we want to install
            // the printer drivers on this machine not the remote.
            //
            bStatus DBGCHK = bPrinterSetup( _pPrinterData->hwnd(),
                                            MSP_NEWDRIVER,
                                            COUNTOF( szDriverName ),
                                            szDriverName,
                                            &cchDriverName,
                                            NULL );

            if( GetLastError() == ERROR_CANCELLED )
            {
                //
                // Indicates the driver pages we not loaded.
                //
                bStatus DBGNOCHK = FALSE;
            }
            else
            {
                bStatus DBGNOCHK = TRUE;
            }
        }

    } else {

        bStatus DBGNOCHK = FALSE;

    }

    return bStatus;
}

/*++

Routine Name:

    bRefreshTitle

Routine Description:

   Creates the property sheet title.

Arguments:

   Nothing.

Return Value:

   TRUE success, FALSE error occurred.

--*/
VOID
TPrinterPropertySheetManager::
vRefreshTitle(
    VOID
    )
{
    //
    // Locates the dialog box with the title.
    //
    bCreateTitle();

    SPLASSERT( _hwndParent );

    //
    // Set the main dialogs title.
    //
    SetWindowText( _hwndParent, _strTitle );
}

/*++

Routine Name:

   vSetParentHandle

Routine Description:

   Set the parent window handle.

Arguments:

   handle to parent window, main dialog.

Return Value:

   Nothing.

--*/
VOID
TPrinterPropertySheetManager::
vSetParentHandle(
    IN HWND hwndParent
    )
{
    _hwndParent = hwndParent;
}

/*++

Routine Name:

   hGetParentHandle

Routine Description:

   Get the parent window handle.

Arguments:

   None

Return Value:

   handle to parent window, main dialog

--*/
HWND
TPrinterPropertySheetManager::
hGetParentHandle(
    VOID
    ) const
{
    return _hwndParent;
}

/*++

Routine Name:

    bCreatePropertySheetTitle.

Routine Description:

    Creates the property sheet title.

Arguments:

   Nothing.

Return Value:

   TRUE success, FALSE error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bCreateTitle(
    VOID
    )
{
    TCHAR szBuffer[kStrMax+kPrinterBufMax];
    UINT nSize = COUNTOF( szBuffer );
    TString strProperties;
    TStatusB bStatus;

    //
    // Create the formated property sheet title.
    //
    bStatus DBGCHK = ConstructPrinterFriendlyName( (LPCTSTR)_pPrinterData->strCurrentPrinterName(), szBuffer, &nSize );

    //
    // Load the property word from the resource file.
    //
    bStatus DBGCHK = strProperties.bLoadString( ghInst, IDS_TEXT_PROPERTIES );

    //
    // Construct the property sheet title.
    //
    bStatus DBGCHK = bConstructMessageString( ghInst, _strTitle, IDS_PRINTER_PROPERTIES_TITLE_FORMAT, szBuffer, (LPCTSTR)strProperties );

    return bStatus;
}

/*++

Routine Name:

    bDestroyPages

Routine Description:

    Destroy any compstui specific data information.

Arguments:

   pCPSUIInfo - Pointer to commonui property sheet info header,
   pSetResultInfo - Pointer to result info header

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bDestroyPages(
    IN PPROPSHEETUI_INFO pPSUIInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager bDestroyPages\n") );
    UNREFERENCED_PARAMETER( pPSUIInfo );

    //
    // Release any shell extension information.
    //
    _ShellExtPages.vDestroy( NULL );

    return TRUE;
}

/*++

Routine Name:

    bSetHeader

Routine Description:

    Set the property sheet header information.

Arguments:

   pCPSUIInfo - Pointer to common ui property sheet info header,
   pPSUIInfoHdr - Pointer to propetry sheet header

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bSetHeader(
    IN PPROPSHEETUI_INFO pCPSUIInfo,
    IN PPROPSHEETUI_INFO_HEADER pPSUIInfoHdr
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager bSetHeader\n") );

    UNREFERENCED_PARAMETER( pCPSUIInfo );

    //
    // Create the window title.
    //
    bCreateTitle();

    //
    // Set the property sheet header information.
    //
    pPSUIInfoHdr->cbSize     = sizeof( PROPSHEETUI_INFO_HEADER );
    pPSUIInfoHdr->Flags      = PSUIHDRF_USEHICON;
    pPSUIInfoHdr->pTitle     = (LPTSTR)(LPCTSTR)_strTitle;
    pPSUIInfoHdr->hInst      = ghInst;
    pPSUIInfoHdr->hIcon      = _pPrinterData->shSmallIcon();
    pPSUIInfoHdr->hWndParent = _pPrinterData->hwnd();

    return TRUE;
}

/*++

Routine Name:

    bBuildDriverPages

Routine Description:

    Builds the driver defined property sheets.  Also get the driver
    defined icon.

Arguments:

   pCPSUIInfo - Pointer to common ui property sheet info header,

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
TPrinterPropertySheetManager::
bBuildDriverPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    //
    // Build the device header and instruct compstui to chain the
    // call to the printer driver ui.
    //
    ZeroMemory ( &_dph, sizeof( _dph ) );

    _dph.cbSize         = sizeof( _dph );
    _dph.hPrinter       = _pPrinterData->hPrinter();
    _dph.pszPrinterName = (LPTSTR)(LPCTSTR)_pPrinterData->strCurrentPrinterName();
    _dph.Flags          = ( _pPrinterData->bAdministrator( ) ) ? (WORD)0 : (WORD)DPS_NOPERMISSION;

    //
    // Add the driver defined property sheets.
    //
    _hDrvPropSheet = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                  CPSFUNC_ADD_PFNPROPSHEETUI,
                                                  (LPARAM)DevicePropertySheets,
                                                  (LPARAM)&_dph );
    //
    // Validate the handle returned by compstui.
    //
    if( !bValidCompstuiHandle( _hDrvPropSheet ) ){

        DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager CPSFUNC_ADD_PFNPROPSHEETUI failed with %d.\n", _hDrvPropSheet ) );

        return FALSE;
    }

    return TRUE;
}

/*++

Routine Name:

    bCheckToBuildDriverPages

Routine Description:

    Checks to build the driver pages and asks the user 
    to install a driver locally if necessary.

Arguments:

    pCPSUIInfo - pointer to compstui info header.

Return Value:

    Nothing.

--*/
BOOL
TPrinterPropertySheetManager::
bCheckToBuildDriverPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    //
    // Build the driver specific pages.
    //
    TStatusB bStatus;
    bStatus DBGCHK = bBuildDriverPages( pCPSUIInfo );

    if( !bStatus )
    {
        DWORD dwLastErr = GetLastError();

        if( ERROR_KM_DRIVER_BLOCKED == dwLastErr )
        {
            iMessage( _pPrinterData->hwnd(),
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_NODRIVERUI_BAD_KMDRIVER,
                      MB_OK|MB_ICONINFORMATION,
                      kMsgNone,
                      NULL,
                      static_cast<LPCTSTR>(_pPrinterData->strDriverName()) );
        }
        else
        {
            //
            // Assume the driver doesn't exists - ask the user if they want to install 
            // the printer driver now.
            //
            bStatus DBGCHK = bInstallDriverPage();

            //
            // If the driver was installed attempt to load the
            // driver pages again.  If this fails we silently fail, since
            // we told the user already that only spooler properties
            // will be displayed.
            //
            if( bStatus )
            {
                bStatus DBGCHK = bBuildDriverPages( pCPSUIInfo );

            } else 
            {
                _pPrinterData->_bDriverPagesNotLoaded = TRUE;
            }
        }
    }

    return bStatus;
}

/*++

Routine Name:

    bRelaseDriverPages

Routine Description:

    Release any driver defined pages.

Arguments:

    pCPSUIInfo - pointer to compstui info header.

Return Value:

    Nothing.

--*/
VOID
TPrinterPropertySheetManager::
vReleaseDriverPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    //
    // Insure we have a valid compstui handle.
    //
    if( bValidCompstuiHandle( _hDrvPropSheet ) ) {

        LONG_PTR lResult;
        DWORD dwPageCount;

        //
        // Delete the currently help driver pages.
        //
        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                               CPSFUNC_DELETE_HCOMPROPSHEET,
                                               (LPARAM)_hDrvPropSheet,
                                               (LPARAM)&dwPageCount );
        if( lResult <= 0 ){

            DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager CPSFUNC_REMOVE_PROPSHEETPAGE failed with %d\n", lResult ) );

        } else {

            _hDrvPropSheet = 0;

        }
    }
}

/*++

Routine Name:

    bGetDriverPageHandles

Routine Description:

    Get the pages handle of the driver pages from common ui.

Arguments:

    pCPSUIInfo - pointer to compstui info header.
    pcPages    - pointer where to return the number of pages.
    pphPage    - pointer where to return pointer to array of hpages.

Return Value:

    TRUE success FALSE failure.

--*/
BOOL
TPrinterPropertySheetManager::
bGetDriverPageHandles(
    IN  PPROPSHEETUI_INFO   pCPSUIInfo,
        OUT DWORD          *pcPages,
        OUT HPROPSHEETPAGE **pphPages
    )
{
    DBGMSG( DBG_TRACE, ( "TPrinterPropertySheetManager::bGetDriverPageHandles.\n" ) );

    BOOL bStatus = FALSE;
    ULONG_PTR cPages;
    HPROPSHEETPAGE *phPages;

    cPages = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                          CPSFUNC_GET_PAGECOUNT,
                                          (LPARAM)_hDrvPropSheet,
                                          0 );

    DBGMSG( DBG_TRACE, ( "bGetDriverPageHandles CPSFUNC_GET_PAGECOUNT pages %d.\n", cPages ) );

    if( cPages )
    {
        phPages = new HPROPSHEETPAGE[(UINT)cPages];

        SPLASSERT( phPages );

        if( phPages )
        {
            cPages = pCPSUIInfo->pfnComPropSheet( (HANDLE)_hDrvPropSheet,
                                                  CPSFUNC_GET_HPSUIPAGES,
                                                  (LPARAM)phPages,
                                                  (LPARAM)cPages );

            DBGMSG( DBG_TRACE, ( "bGetDriverPageHandles CPSFUNC_GET_HPSUIPAGES pages %d First handle %x.\n", cPages, phPages[0] ) );

            if( cPages )
            {
                *pcPages = (UINT)cPages;
                *pphPages = phPages;
                bStatus = TRUE;
            }
        }
    }

    return bStatus;
}

/*++

Routine Name:

    bDisplaySecurityTab

Routine Description:

    Displayes only the security tab which is a shell extension.

Arguments:

   hwnd - handle to the parent window.

Return Value:

    Nothing.

--*/
BOOL
TPrinterPropertySheetManager::
bDisplaySecurityTab(
    IN HWND hwnd
    )
{
    LPPROPSHEETHEADER   pPropSheetHeader    = NULL;
    BOOL                bStatus             = FALSE;

    //
    // Allocate a property sheet header to get any shell extension pages.
    //
    if( _ShellExtPages.bCreatePropSheetHeader( &pPropSheetHeader ) )
    {
        //
        // Fill in the property sheet header.
        //
        Printer_AddPrinterPropPages( _pPrinterData->strPrinterName(), pPropSheetHeader );

        //
        // Check if any pages were loaded.  This should not happen, at
        // a minimum the security tab should be displayed.
        //
        if( pPropSheetHeader->nPages )
        {
            //
            // Warn the user they will only see the security tab.
            //
            iMessage( hwnd,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_NO_DEVICE_SEC_OPTIONS,
                      MB_OK|MB_ICONEXCLAMATION,
                      kMsgNone,
                      NULL );
            //
            // Create the property sheet title.
            //
            bCreateTitle();

            //
            // Set the property sheet header information.
            //
            pPropSheetHeader->dwSize      = sizeof( *pPropSheetHeader );
            pPropSheetHeader->hwndParent  = hwnd;
            pPropSheetHeader->dwFlags     = 0;
            pPropSheetHeader->pszIcon     = MAKEINTRESOURCE( IDI_PRINTER );
            pPropSheetHeader->nStartPage  = 0;
            pPropSheetHeader->hInstance   = ghInst;
            pPropSheetHeader->pszCaption  = _strTitle;

            //
            // Display the property sheets.
            //
            if( PropertySheet( pPropSheetHeader ) != -1 )
            {
                bStatus = TRUE;
            }
            else
            {
                vShowResourceError( hwnd );
            }
        }
        else
        {
            //
            // Inform the user an error occurred showing printer properties.
            //
            iMessage( hwnd,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_PRINTER_PROP,
                      MB_OK|MB_ICONSTOP,
                      kMsgGetLastError,
                      NULL );
        }

        //
        // Ensure we release the property sheet header.
        //
        _ShellExtPages.vDestroyPropSheetHeader( pPropSheetHeader );
    }

    return bStatus;
}


/********************************************************************

    Shell Extension property pages - public functions.

********************************************************************/

/*++

Routine Name:

    TShellExtPages

Routine Description:

    Constructor.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TShellExtPages::
TShellExtPages(
    VOID
    ) : _hGroupHandle( 0 )
{
    DBGMSG( DBG_TRACE, ( "TShellExtPages ctor.\n" ) );
}

/*++

Routine Name:

    TShellExtPages

Routine Description:

    Destructor.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TShellExtPages::
~TShellExtPages(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtPages dtor.\n" ) );

    //
    // This should never happen.
    //
    SPLASSERT( !_hGroupHandle );
}

/*++

Routine Name:

    bCreate

Routine Description:

    Creates the shell extension property pages.

Arguments:

    Pointer to common ui information structure.
    Pointer to printer name name to get sheets for.

Return Value:

    TRUE if sheets found, FALSE no sheets found.

--*/
BOOL
TShellExtPages::
bCreate(
    IN PPROPSHEETUI_INFO pCPSUIInfo,
    IN const TString &strPrinterName
    )
{

    DBGMSG( DBG_TRACE, ( "TShellExtPages create.\n" ) );

    BOOL                bStatus             = FALSE;
    LPPROPSHEETHEADER   pPropSheetHeader    = NULL;

    //
    // Allocate a property sheet header to get any shell extension pages.
    //
    if( bCreatePropSheetHeader( &pPropSheetHeader ) ){

        //
        // Get the vender defined prop pages.
        //
        Printer_AddPrinterPropPages( strPrinterName, pPropSheetHeader );

        //
        // Add the shell extension property sheets pages.
        //
        bStatus = bCreatePages( pCPSUIInfo, pPropSheetHeader );

    }

    //
    // Release the property sheet header.  This can be destroyed, because common ui
    // will store the property sheet handles under the concept of a group handle.  See
    // common ui header file for more details.
    //
    vDestroyPropSheetHeader( pPropSheetHeader );

    return bStatus;

}

/*++

Routine Name:

    vDestroy

Routine Description:

    Destroys any information used by the TShellExt object.

Arguments:

    Pointer to common ui information structure.

Return Value:

    Nothing.

--*/
VOID
TShellExtPages::
vDestroy(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtPages vDestroy.\n" ) );

    vDestroyPages( pCPSUIInfo );

}

/*++

Routine Name:

    hPropSheet

Routine Description:

    Returns the prop sheet handle.

Arguments:

    Nothing.

Return Value:

--*/

HANDLE
TShellExtPages::
hPropSheet(
    VOID
    ) const
{
    return reinterpret_cast<HANDLE>(_hGroupHandle);
}

/********************************************************************

    Shell Extension property pages - private functions.

********************************************************************/

BOOL
TShellExtPages::
bCreatePropSheetHeader(
    IN LPPROPSHEETHEADER *ppPropSheetHeader
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtPages bCreatePropSheetHeader.\n" ) );

    PROPSHEETHEADER *pPropSheetHeader   = NULL;
    BOOL            bStatus             = FALSE;
    UINT            uHeaderSize         = 0;

    //
    // Calculate the header size, Header size plus the max size of the array
    // of property sheets handles.
    //
    uHeaderSize = sizeof( PROPSHEETHEADER ) + sizeof( HPROPSHEETPAGE ) * MAXPROPPAGES;

    //
    // Allocate the property sheet header and handle array.
    //
    pPropSheetHeader = (PROPSHEETHEADER *)AllocMem( uHeaderSize );

    //
    // If valid property sheet header and handle array was aquired, then
    // clear the memory, and set up the handle arrary pointer.
    //
    if( pPropSheetHeader ){

        ZeroMemory( pPropSheetHeader, uHeaderSize );

        pPropSheetHeader->phpage = (HPROPSHEETPAGE *)(pPropSheetHeader+1);

        *ppPropSheetHeader = pPropSheetHeader;

        bStatus = TRUE;
    }

    return bStatus;
}


VOID
TShellExtPages::
vDestroyPropSheetHeader(
    IN LPPROPSHEETHEADER pPropSheetHeader
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtPages vDestroyPropSheetHeader.\n" ) );

    FreeMem( pPropSheetHeader );
}


BOOL
TShellExtPages::
bCreatePages(
    IN PPROPSHEETUI_INFO pCPSUIInfo,
    IN LPPROPSHEETHEADER pPropSheetHeader
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtPages bCreatePages.\n" ) );

    BOOL bStatus = TRUE;
    ULONG_PTR hResult;
    INSERTPSUIPAGE_INFO InsertInfo;

    //
    // If there are no shell extenstion pages to create.
    //
    if( !pPropSheetHeader->nPages ){
        DBGMSG( DBG_TRACE, ( "TShellExtPages no pages to create.\n" ) );
        bStatus = FALSE;
    }

    if( bStatus ){

        //
        // Create the insert info.
        //
        InsertInfo.cbSize  = sizeof( InsertInfo );
        InsertInfo.Type    = PSUIPAGEINSERT_GROUP_PARENT;
        InsertInfo.Mode    = INSPSUIPAGE_MODE_LAST_CHILD;
        InsertInfo.dwData1 = 0;
        InsertInfo.dwData2 = 0;
        InsertInfo.dwData3 = 0;

        //
        // Create a group parent handle.
        //
        _hGroupHandle = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                                     CPSFUNC_INSERT_PSUIPAGE,
                                                     0,
                                                     (LPARAM)&InsertInfo );

        if( !TPropertySheetManager::bValidCompstuiHandle( _hGroupHandle ) ){
            DBGMSG( DBG_WARN, ( "TShellExtPages PSUIPAGEINSERT_GROUP_PARENT failed with %d.\n", _hGroupHandle ) );
            bStatus = FALSE;
        }
    }

    if( bStatus ){

        //
        // Add all supplied shell extension property sheet pages.
        //
        for( UINT i = 0; i < pPropSheetHeader->nPages ; i++ ){

            InsertInfo.Type    = PSUIPAGEINSERT_HPROPSHEETPAGE;
            InsertInfo.Mode    = INSPSUIPAGE_MODE_LAST_CHILD;
            InsertInfo.dwData1 = (ULONG_PTR)pPropSheetHeader->phpage[i];

            hResult = pCPSUIInfo->pfnComPropSheet( (HANDLE)_hGroupHandle,
                                                   CPSFUNC_INSERT_PSUIPAGE,
                                                   0,
                                                   (LPARAM)&InsertInfo );

            if( !TPropertySheetManager::bValidCompstuiHandle( hResult ) ){

                DBGMSG( DBG_WARN, ( "TShellExtPages PSUIPAGEINSERT_HPROPSHEETPAGE failed with %d.\n", hResult ) );
                bStatus = FALSE;
                break;

            } else {

                DBGMSG( DBG_TRACE, ( "TShellExtPages page added\n" ) );

            }

        }
    }

    //
    // If the pages failed to create destroy any inconsistant resources.
    //
    if( !bStatus ){
        vDestroyPages( pCPSUIInfo );
    }

    return bStatus;

}

VOID
TShellExtPages::
vDestroyPages(
    IN PPROPSHEETUI_INFO pCPSUIInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtPages vDestroyPages.\n" ) );

    LONG_PTR lResult;
    DWORD dwPageCount;

    //
    // If the vendor pages have not been created.
    //
    if( !_hGroupHandle ){
        DBGMSG( DBG_TRACE, ( "TShellExtPages no pages.\n" ) );
        return;
    }

    //
    // Release the group handle.
    //
    if( pCPSUIInfo ){

        lResult = pCPSUIInfo->pfnComPropSheet( pCPSUIInfo->hComPropSheet,
                                               CPSFUNC_DELETE_HCOMPROPSHEET,
                                               (LPARAM)_hGroupHandle,
                                               (LPARAM)&dwPageCount );

        if( lResult <= 0 ){
            DBGMSG( DBG_WARN, ( "TShellExtPages failed to delete hGroupHandle with %d.\n", lResult ) );
        } else {
            DBGMSG( DBG_TRACE, ( "TShellExtPages release %d pages.\n", dwPageCount ) );
        }
    }

    //
    // Mark the group handle as deleted.
    //
    _hGroupHandle   = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\psetup5.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998
All rights reserved.

Module Name:

    PSetup.cxx

Abstract:

    Printer setup class to gain access to the ntprint.dll
    setup code.

Author:

    Steve Kiraly (SteveKi)  19-Jan-1996

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "psetup5.hxx"

/********************************************************************

    Printer setup class. Verison 5.0

********************************************************************/

UINT                                            TPSetup50::_uRefCount                           = 0;
TLibrary                                       *TPSetup50::_pLibrary                            = NULL;
pfPSetupCreatePrinterDeviceInfoList             TPSetup50::PSetupCreatePrinterDeviceInfoList    = 0;
pfPSetupDestroyPrinterDeviceInfoList            TPSetup50::PSetupDestroyPrinterDeviceInfoList   = 0;
pfPSetupSelectDriver                            TPSetup50::PSetupSelectDriver                   = 0;
pfPSetupCreateDrvSetupPage                      TPSetup50::PSetupCreateDrvSetupPage             = 0;
pfPSetupGetSelectedDriverInfo                   TPSetup50::PSetupGetSelectedDriverInfo          = 0;
pfPSetupDestroySelectedDriverInfo               TPSetup50::PSetupDestroySelectedDriverInfo      = 0;
pfPSetupInstallPrinterDriver                    TPSetup50::PSetupInstallPrinterDriver           = 0;
pfPSetupIsDriverInstalled                       TPSetup50::PSetupIsDriverInstalled              = 0;
pfPSetupRefreshDriverList                       TPSetup50::PSetupRefreshDriverList              = 0;
pfPSetupThisPlatform                            TPSetup50::PSetupThisPlatform                   = 0;
pfPSetupDriverInfoFromName                      TPSetup50::PSetupDriverInfoFromName             = 0;
pfPSetupPreSelectDriver                         TPSetup50::PSetupPreSelectDriver                = 0;
pfPSetupCreateMonitorInfo                       TPSetup50::PSetupCreateMonitorInfo              = 0;
pfPSetupDestroyMonitorInfo                      TPSetup50::PSetupDestroyMonitorInfo             = 0;
pfPSetupEnumMonitor                             TPSetup50::PSetupEnumMonitor                    = 0;
pfPSetupInstallMonitor                          TPSetup50::PSetupInstallMonitor                 = 0;
pfPSetupProcessPrinterAdded                     TPSetup50::PSetupProcessPrinterAdded            = 0;
pfPSetupBuildDriversFromPath                    TPSetup50::PSetupBuildDriversFromPath           = 0;
pfPSetupIsTheDriverFoundInInfInstalled          TPSetup50::PSetupIsTheDriverFoundInInfInstalled = 0;
pfPSetupSetSelectDevTitleAndInstructions        TPSetup50::PSetupSetSelectDevTitleAndInstructions = 0;
pfPSetupInstallPrinterDriverFromTheWeb          TPSetup50::PSetupInstallPrinterDriverFromTheWeb  = 0;
pfPSetupIsOemDriver                             TPSetup50::PSetupIsOemDriver                     = 0;
pfPSetupGetLocalDataField                       TPSetup50::PSetupGetLocalDataField               = 0;
pfPSetupFreeDrvField                            TPSetup50::PSetupFreeDrvField                    = 0;
pfPSetupSelectDeviceButtons                     TPSetup50::PSetupSelectDeviceButtons             = 0;
pfPSetupFreeMem                                 TPSetup50::PSetupFreeMem                         = 0;

//
// Setup class constructor.
//
TPSetup50::
TPSetup50(
    VOID
    ) : _bValid( FALSE )
 {
    DBGMSG( DBG_TRACE, ( "TPSetup50::ctor refcount = %d.\n", _uRefCount ) );

    //
    // Hold a critical section while we load the library.
    //
    {
        CCSLock::Locker CSL( *gpCritSec );

        //
        // If this is the first load.
        //
        if( !_uRefCount ){

            //
            // Load the library, if success update the reference count
            // and indicate we have a valid object.
            //
            if( bLoad() ){
                _uRefCount++;
                _bValid = TRUE;
            } else {
                vUnLoad();
            }

        //
        // Update the reference count and indicate a valid object.
        //
        } else {

            _uRefCount++;
            _bValid = TRUE;
        }
    }
 }

//
// Setup class destructor
//
TPSetup50::
~TPSetup50(
    VOID
    )
 {
    DBGMSG( DBG_TRACE, ( "TPSetup50::dtor.\n" ) );

    //
    // If the object is not valid just exit.
    //
    if( !_bValid )
        return;

    //
    // Hold a critical section while we unload the dll.
    //
    {
        CCSLock::Locker CSL( *gpCritSec );

        //
        // Check the reference count and unload if it's the
        // last reference.
        //
        if( !--_uRefCount ){
            vUnLoad();
        }
    }
 }

//
// Indicates if the class is valid.
//
TPSetup50::
bValid(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPSetup50::bValid.\n" ) );

    //
    // Check if we have a valid library pointer.
    //
    if( _pLibrary )
        return _pLibrary->bValid() && _bValid;

    return FALSE;

}

/********************************************************************

    private member functions.

********************************************************************/

//
// Load the library and inialize all the function addresses.
//
BOOL
TPSetup50::
bLoad(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPSetup50::vLoad.\n" ) );

    //
    // Load the library
    //
    _pLibrary = new TLibrary( TEXT( "ntprint.dll" ) );

    //
    // Check if the library was loaded ok.
    //
    if( VALID_PTR( _pLibrary ) ){

        PSetupCreatePrinterDeviceInfoList             = (pfPSetupCreatePrinterDeviceInfoList)             _pLibrary->pfnGetProc("PSetupCreatePrinterDeviceInfoList");
        PSetupDestroyPrinterDeviceInfoList            = (pfPSetupDestroyPrinterDeviceInfoList)            _pLibrary->pfnGetProc("PSetupDestroyPrinterDeviceInfoList");
        PSetupSelectDriver                            = (pfPSetupSelectDriver)                            _pLibrary->pfnGetProc("PSetupSelectDriver");
        PSetupCreateDrvSetupPage                      = (pfPSetupCreateDrvSetupPage)                      _pLibrary->pfnGetProc("PSetupCreateDrvSetupPage");
        PSetupGetSelectedDriverInfo                   = (pfPSetupGetSelectedDriverInfo)                   _pLibrary->pfnGetProc("PSetupGetSelectedDriverInfo");
        PSetupDestroySelectedDriverInfo               = (pfPSetupDestroySelectedDriverInfo)               _pLibrary->pfnGetProc("PSetupDestroySelectedDriverInfo");
        PSetupInstallPrinterDriver                    = (pfPSetupInstallPrinterDriver)                    _pLibrary->pfnGetProc("PSetupInstallPrinterDriver");
        PSetupIsDriverInstalled                       = (pfPSetupIsDriverInstalled)                       _pLibrary->pfnGetProc("PSetupIsDriverInstalled");
        PSetupRefreshDriverList                       = (pfPSetupRefreshDriverList)                       _pLibrary->pfnGetProc("PSetupRefreshDriverList");
        PSetupThisPlatform                            = (pfPSetupThisPlatform)                            _pLibrary->pfnGetProc("PSetupThisPlatform");
        PSetupDriverInfoFromName                      = (pfPSetupDriverInfoFromName)                      _pLibrary->pfnGetProc("PSetupDriverInfoFromName");
        PSetupPreSelectDriver                         = (pfPSetupPreSelectDriver)                         _pLibrary->pfnGetProc("PSetupPreSelectDriver");
        PSetupCreateMonitorInfo                       = (pfPSetupCreateMonitorInfo)                       _pLibrary->pfnGetProc("PSetupCreateMonitorInfo");
        PSetupDestroyMonitorInfo                      = (pfPSetupDestroyMonitorInfo)                      _pLibrary->pfnGetProc("PSetupDestroyMonitorInfo");
        PSetupEnumMonitor                             = (pfPSetupEnumMonitor)                             _pLibrary->pfnGetProc("PSetupEnumMonitor");
        PSetupInstallMonitor                          = (pfPSetupInstallMonitor)                          _pLibrary->pfnGetProc("PSetupInstallMonitor");
        PSetupProcessPrinterAdded                     = (pfPSetupProcessPrinterAdded)                     _pLibrary->pfnGetProc("PSetupProcessPrinterAdded");
        PSetupBuildDriversFromPath                    = (pfPSetupBuildDriversFromPath)                    _pLibrary->pfnGetProc("PSetupBuildDriversFromPath");
        PSetupIsTheDriverFoundInInfInstalled          = (pfPSetupIsTheDriverFoundInInfInstalled)          _pLibrary->pfnGetProc("PSetupIsTheDriverFoundInInfInstalled");
        PSetupSetSelectDevTitleAndInstructions        = (pfPSetupSetSelectDevTitleAndInstructions)        _pLibrary->pfnGetProc("PSetupSetSelectDevTitleAndInstructions");
        PSetupInstallPrinterDriverFromTheWeb          = (pfPSetupInstallPrinterDriverFromTheWeb)          _pLibrary->pfnGetProc("PSetupInstallPrinterDriverFromTheWeb");
        PSetupIsOemDriver                             = (pfPSetupIsOemDriver)                             _pLibrary->pfnGetProc("PSetupIsOemDriver");
        PSetupGetLocalDataField                       = (pfPSetupGetLocalDataField)                       _pLibrary->pfnGetProc("PSetupGetLocalDataField");
        PSetupFreeDrvField                            = (pfPSetupFreeDrvField)                            _pLibrary->pfnGetProc("PSetupFreeDrvField");
        PSetupSelectDeviceButtons                     = (pfPSetupSelectDeviceButtons)                     _pLibrary->pfnGetProc("PSetupSelectDeviceButtons");
        PSetupFreeMem                                 = (pfPSetupFreeMem)                                 _pLibrary->pfnGetProc("PSetupFreeMem");

        if( PSetupCreatePrinterDeviceInfoList            &&
            PSetupDestroyPrinterDeviceInfoList           &&
            PSetupSelectDriver                           &&
            PSetupCreateDrvSetupPage                     &&
            PSetupGetSelectedDriverInfo                  &&
            PSetupDestroySelectedDriverInfo              &&
            PSetupInstallPrinterDriver                   &&
            PSetupIsDriverInstalled                      &&
            PSetupRefreshDriverList                      &&
            PSetupThisPlatform                           &&
            PSetupDriverInfoFromName                     &&
            PSetupPreSelectDriver                        &&
            PSetupCreateMonitorInfo                      &&
            PSetupDestroyMonitorInfo                     &&
            PSetupEnumMonitor                            &&
            PSetupInstallMonitor                         &&
            PSetupProcessPrinterAdded                    &&
            PSetupIsTheDriverFoundInInfInstalled         &&
            PSetupSetSelectDevTitleAndInstructions       &&
            PSetupInstallPrinterDriverFromTheWeb         &&
            PSetupIsOemDriver                            &&
            PSetupGetLocalDataField                      &&
            PSetupFreeDrvField                           &&
            PSetupSelectDeviceButtons                    &&
            PSetupBuildDriversFromPath                   &&
            PSetupFreeMem ){

            return TRUE;

        } else {

            return FALSE;

        }
    }
    return TRUE;
}

//
// Unload the library and reset static lib pointer.
//
VOID
TPSetup50::
vUnLoad(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TPSetup50::vUnLoad.\n" ) );
    delete _pLibrary;
    _pLibrary = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\query.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998
All rights reserved.

Module Name:

    query.hxx

Abstract:

    Printer DS query

Author:

    Steve Kiraly (SteveKi)  09-Dec-1996

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "dsinterf.hxx"
#include "query.hxx"
#include "persist.hxx"

TQuery::
TQuery(
    IN HWND hDlg
    ) : _bValid( FALSE ),
        _hDlg( hDlg ),
        _cItems( 0 ),
        _pICommonQuery( NULL ),
        _pItems( NULL )
{
    //
    // We will be using OLE.
    //
    CoInitialize( NULL );

    //
    // Validate the ds interface object.
    //
    if( !VALID_OBJ( _Ds ) )
    {
        return;
    }

    //
    // Get a pointer  to the common query interface.
    //
    HRESULT hr = CoCreateInstance( CLSID_CommonQuery,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_ICommonQuery,
                                   (VOID**)&_pICommonQuery );

    if( FAILED( hr ) )
    {
        return;
    }

    //
    // Read the default scope from the policy key.  It does not constitue a
    // failure if the key was not found.
    //
    TPersist PersistPolicy( gszAddPrinterWizardPolicy, TPersist::kOpen|TPersist::kRead );

    if( VALID_OBJ( PersistPolicy ) )
    {
        (VOID)PersistPolicy.bRead( gszAPWDefaultSearchScope, _strDefaultScope );
    }

    _bValid = TRUE;

}


TQuery::
~TQuery(
    VOID
    )
{
    //
    // Release the qurey item.
    //
    vReleaseItems();

    //
    // Release the querey interface.
    //
    if( _pICommonQuery )
    {
        _pICommonQuery->Release();
    }
    //
    // Balance the CoInitalize call.
    //
    CoUninitialize();

}

BOOL
TQuery::
bValid(
    VOID
    )
{
    return _bValid;
}

VOID
TQuery::
vReleaseItems(
    VOID
    )
{
    //
    // Release the qurey item.
    //
    _cItems = 0;
    delete [] _pItems;
}

BOOL
TQuery::
bSetDefaultScope(
    IN LPCTSTR pszDefaultScope
    )
{
    return _strDefaultScope.bUpdate( pszDefaultScope);
}

BOOL
TQuery::
bDoQuery(
    VOID
    )
{
    static UINT g_cfDsObjectNames;

    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    DSQUERYINITPARAMS   dqip            = {0};
    OPENQUERYWINDOW     oqw             = {0};
    LPDSOBJECTNAMES     pDsObjects      = NULL;
    IDataObject        *pDataObject     = NULL;
    FORMATETC           fmte            = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM           medium          = { TYMED_NULL, NULL, NULL };

    //
    // Build the querey parameters.
    //
    dqip.cbStruct           = sizeof(dqip);
    dqip.dwFlags            = 0;
    dqip.pDefaultScope      = ( _strDefaultScope.bEmpty() == TRUE ) ? NULL : (LPTSTR)(LPCTSTR)_strDefaultScope;

    DBGMSG( DBG_TRACE, ( "TQuery::bDoQuery - Default Search Scope: " TSTR "\n", (LPCTSTR)_strDefaultScope ) );

    //
    // Build the open querey window struct.
    //
    oqw.cbStruct            = sizeof( oqw );
    oqw.dwFlags             = OQWF_OKCANCEL|OQWF_DEFAULTFORM|OQWF_SINGLESELECT|OQWF_REMOVEFORMS;
    oqw.clsidHandler        = CLSID_DsQuery;
    oqw.pHandlerParameters  = &dqip;
    oqw.clsidDefaultForm    = CLSID_DsFindPrinter;

    //
    // Open the query window.
    //
    HRESULT hr = _pICommonQuery->OpenQueryWindow( _hDlg, &oqw, &pDataObject);

    //
    // Release any stale items.
    //
    vReleaseItems();

    //
    // If that worked and we received a IDataObjec The DSQUERY
    // code exposes the CF_DSOBJECTNAMES
    // which gives us the full ADsPath and objectClass.
    //
    if( SUCCEEDED(hr) && pDataObject )
    {
        if ( !g_cfDsObjectNames )
        {
            g_cfDsObjectNames = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
        }

        fmte.cfFormat = static_cast<USHORT>( g_cfDsObjectNames );

        if( SUCCEEDED(pDataObject->GetData(&fmte, &medium)) )
        {
            pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;

            //
            // If selected items were returned then save the selected items in
            // an array of items.
            //
            if( pDsObjects->cItems )
            {
                //
                // Allocate the new items.
                //
                _cItems = pDsObjects->cItems;
                _pItems = new TQuery::TItem[_cItems];

                if( _pItems )
                {
                    for( UINT i = 0 ; i < pDsObjects->cItems ; i++ )
                    {
                        bStatus DBGCHK = _pItems[i].strName().bUpdate( ByteOffset( pDsObjects, pDsObjects->aObjects[i].offsetName ) );
                        bStatus DBGCHK = _pItems[i].strClass().bUpdate( ByteOffset( pDsObjects, pDsObjects->aObjects[i].offsetClass ) );
                        DBGMSG( DBG_TRACE, ( " Name " TSTR " Class " TSTR "\n", (LPCTSTR)_pItems[i].strName(), (LPCTSTR)_pItems[i].strClass() ) );
                    }
                }
            }
            ReleaseStgMedium(&medium);
        }
        pDataObject->Release();
    }

    return bStatus;
}

BOOL
TQuery::
bPrinterName(
    IN TString &strPrinterName,
    IN const TString &strDsName
    )
{
    IADs           *pDsObject     = NULL;
    HRESULT         hr            = E_FAIL;
    VARIANT         Variant;
    TStatusB        bStatus;

    bStatus DBGNOCHK = FALSE;

#ifdef UNICODE

    VariantClear( &Variant );

    hr = _Ds.ADsGetObject( const_cast<LPTSTR>( static_cast<LPCTSTR>( strDsName ) ), IID_IADs, (LPVOID*)&pDsObject);

    if( SUCCEEDED(hr))
    {
        hr = pDsObject->Get( TEXT( "uNCName" ), &Variant );

        if( SUCCEEDED(hr))
        {
            if ( Variant.vt == VT_BSTR && Variant.bstrVal && Variant.bstrVal[0] )
            {
                bStatus DBGCHK = strPrinterName.bUpdate( Variant.bstrVal );
            }

            VariantClear( &Variant );
        }
        pDsObject->Release();
    }

#endif

    if( FAILED(hr) )
    {
        SetLastError( ERROR_INVALID_PRINTER_NAME );
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\queue.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    queue.cxx

Abstract:

    Manages the print queue.

    This module is aware of the ListView.

Author:

    Albert Ting (AlbertT)  15-Jun-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "notify.hxx"
#include "data.hxx"
#include "printer.hxx"
#include "dragdrop.hxx"
#include "queue.hxx"
#include "time.hxx"
#include "psetup.hxx"
#include "drvsetup.hxx"
#include "instarch.hxx"
#include "portslv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "propmgr.hxx"
#include "docdef.hxx"
#include "docprop.hxx"
#include "persist.hxx"
#include "rtlmir.hxx"
#include "guids.h"

#if DBG
//#define DBG_QUEUEINFO                DBG_INFO
#define DBG_QUEUEINFO                  DBG_NONE
#endif

const TQueue::POSINFO TQueue::gPQPos = {
    TDataNJob::kColumnFieldsSize,
    {
        JOB_COLUMN_FIELDS,
        0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    },
    {
        200, 80, 80, 60, 100, 140, 120, 80, 80, 80, 80, 80, 80, 80,
        80,  80, 80, 80,  80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80
    },
    {
        sizeof( WINDOWPLACEMENT ), 0, SW_SHOW,
        { 0, 0 }, { 0, 0 }, { 50, 100, 612, 300 }
    },
    TRUE,
    TRUE,
    {
        0,  1,   2,  3,  4,  5,  6,  7,
        8,  9,  10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, 26, 27, 28, 29, 30, 31,
        0,
    }
};

const DWORD
gadwFieldTable[] = {
#define DEFINE( field, x, table, y, offset ) table,
#include "ntfyjob.h"
#undef DEFINE
    0
};

/********************************************************************

    Status translation tables:

********************************************************************/

const STATUS_MAP gaStatusMapPrinter[] = {
    { PRINTER_STATUS_PENDING_DELETION, IDS_STATUS_DELETING           },
    { PRINTER_STATUS_USER_INTERVENTION,IDS_STATUS_USER_INTERVENTION  },
    { PRINTER_STATUS_PAPER_JAM,        IDS_STATUS_PAPER_JAM          },
    { PRINTER_STATUS_PAPER_OUT,        IDS_STATUS_PAPER_OUT          },
    { PRINTER_STATUS_MANUAL_FEED,      IDS_STATUS_MANUAL_FEED        },
    { PRINTER_STATUS_DOOR_OPEN,        IDS_STATUS_DOOR_OPEN          },
    { PRINTER_STATUS_NOT_AVAILABLE,    IDS_STATUS_NOT_AVAILABLE      },
    { PRINTER_STATUS_PAPER_PROBLEM,    IDS_STATUS_PAPER_PROBLEM      },
    { PRINTER_STATUS_OFFLINE,          IDS_STATUS_OFFLINE            },

    { PRINTER_STATUS_PAUSED,           IDS_STATUS_PAUSED             },
    { PRINTER_STATUS_OUT_OF_MEMORY,    IDS_STATUS_OUT_OF_MEMORY      },
    { PRINTER_STATUS_NO_TONER,         IDS_STATUS_NO_TONER           },
    { PRINTER_STATUS_TONER_LOW,        IDS_STATUS_TONER_LOW          },
    { PRINTER_STATUS_PAGE_PUNT,        IDS_STATUS_PAGE_PUNT          },
    { PRINTER_STATUS_OUTPUT_BIN_FULL,  IDS_STATUS_OUTPUT_BIN_FULL    },

    { PRINTER_STATUS_SERVER_UNKNOWN,   IDS_STATUS_SERVER_UNKNOWN     },
    { PRINTER_STATUS_IO_ACTIVE,        IDS_STATUS_IO_ACTIVE          },
    { PRINTER_STATUS_BUSY,             IDS_STATUS_BUSY               },
    { PRINTER_STATUS_WAITING,          IDS_STATUS_WAITING            },
    { PRINTER_STATUS_PROCESSING,       IDS_STATUS_PROCESSING         },
    { PRINTER_STATUS_INITIALIZING,     IDS_STATUS_INITIALIZING       },
    { PRINTER_STATUS_WARMING_UP,       IDS_STATUS_WARMING_UP         },

    { PRINTER_STATUS_PRINTING,         IDS_STATUS_PRINTING           },
    { PRINTER_STATUS_POWER_SAVE,       IDS_STATUS_POWER_SAVE         },
    { 0,                               0 }
};

const STATUS_MAP gaStatusMapJob[] = {
    { JOB_STATUS_DELETING,     IDS_STATUS_DELETING     },
    { JOB_STATUS_PAPEROUT,     IDS_STATUS_PAPER_OUT    },
    { JOB_STATUS_ERROR   ,     IDS_STATUS_ERROR        },
    { JOB_STATUS_OFFLINE ,     IDS_STATUS_OFFLINE      },
    { JOB_STATUS_PAUSED  ,     IDS_STATUS_PAUSED       },
    { JOB_STATUS_SPOOLING,     IDS_STATUS_SPOOLING     },
    { JOB_STATUS_PRINTING,     IDS_STATUS_PRINTING     },    
    { JOB_STATUS_PRINTED ,     IDS_STATUS_PRINTED      },
    { JOB_STATUS_RESTART ,     IDS_STATUS_RESTART      },
    { JOB_STATUS_COMPLETE,     IDS_STATUS_COMPLETE     },
    { 0,                       0 }
};

/********************************************************************

    MenuHelp

********************************************************************/

UINT
TQueue::gauMenuHelp[kMenuHelpMax] = {
    MH_PRINTER, MH_PRINTER,
    0, 0
};


TQueue::
TQueue(
    IN TPrintLib *pPrintLib,
    IN LPCTSTR pszPrinter,
    IN HANDLE hEventClose
    ) : _hwndTB( NULL ), _hwndLV( NULL ), _hwndSB( NULL ),
        _idsConnectStatus( 0 ), _dwErrorStatus( 0 ), _dwAttributes( 0 ),
        _dwStatusPrinter( 0 ), _hEventClose( hEventClose ),
        _bWindowClosing( FALSE ), _cItems( -1 ),
        _pDropTarget( NULL )

/*++

Routine Description:

    Create the Queue object.  The gpPrintLib has already been incremented
    for us, so we do not need to do it here.

    Must be in UI thread so that all UI is handled by one thread.

Arguments:

    hwndOwner - Owning window.

    pszPrinter - Printer to open.

    nCmdShow - Show command for window.

    hEventClose - Event to be triggered when window closes (this
        event is _not_ adopted and must be closed by callee).  Used
        when the callee wants to know when the user dismisses the
        Queue UI.

Return Value:

--*/

{
    ASSERT(pPrintLib);
    SINGLETHREAD(UIThread);

    //
    // This must always occur, so do not fail before it.  We do
    // are using a RefLock because we need to store the _pPrintLib
    // pointer.
    //
    _pPrintLib.vAcquire(pPrintLib);

    SaveSelection._pSelection = NULL;
    _pPrinter = TPrinter::pNew( (TQueue*)this, pszPrinter, 0 );

    if( _pPrinter && !VALID_PTR(_pPrinter) )
    {
        //
        // bValid is looking for _pPrinter to determine if the object is valid.
        //
        _pPrinter->vDelete();
        _pPrinter = NULL;
    }

    _bDefaultPrinter = CheckDefaultPrinter( pszPrinter ) == kDefault;
}

TQueue::
~TQueue(
    VOID
    )
{
    //
    // Delete from our linked list if it's linked.
    //
    if( Queue_bLinked( )){

        CCSLock::Locker CSL( *gpCritSec );
        Queue_vDelinkSelf();
    }
}

//
// this function is taken from the comctl32 code since shfuson doesn't implement a warpper
// and we need to take care of calling CreateWindowEx appropriately.
//
HWND WINAPI FusionWrapper_CreateStatusWindow(LONG style, LPCTSTR pszText, HWND hwndParent, UINT uID)
{
    // remove border styles to fix capone and other apps

    return CreateWindowEx(0, STATUSCLASSNAME, pszText, style & ~(WS_BORDER | CCS_NODIVIDER),
        -100, -100, 10, 10, hwndParent, INT2PTR(uID, HMENU), ghInst, NULL);
}

BOOL
TQueue::
bInitialize(
    IN HWND hwndOwner,
    IN INT  nCmdShow
    )

/*++

Routine Description:

    Creates the queue window and thunks it to our object.

Arguments:

Return Value:

--*/

{
    SINGLETHREAD(UIThread);
    HIMAGELIST himl;
    DWORD dwExStyle;

    if( !bValid() ) {
        goto Error;
    }

    _hwnd = CreateWindowEx( bIsBiDiLocalizedSystem() ? kExStyleRTLMirrorWnd : 0,
                            gszClassName,
                            pPrinter()->strPrinter(),
                            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            hwndOwner,
                            NULL,
                            ghInst,
                            (LPVOID)this );

    if( !_hwnd ){
        goto Error;
    }

    _hwndSB = FusionWrapper_CreateStatusWindow( WS_CHILD | SBARS_SIZEGRIP |
                                  WS_CLIPSIBLINGS,
                                  NULL,
                                  _hwnd,
                                  IDD_STATUSBAR );
    if( !_hwndSB ){
        goto Error;
    }

    _hwndLV = CreateWindowEx( WS_EX_CLIENTEDGE,
                              WC_LISTVIEW,
                              gszNULL,
                              WS_CHILD | WS_VISIBLE | WS_TABSTOP |
                                WS_CLIPSIBLINGS | LVS_REPORT | LVS_NOSORTHEADER,
                              0, 0, 0, 0,
                              _hwnd,
                              (HMENU)IDD_LISTVIEW,
                              ghInst,
                              NULL );
    if( !_hwndLV ){
        goto Error;
    }

    if( SUCCEEDED(DragDrop::CreatePrintQueueDT(IID_IPrintQueueDT, (void **)&_pDropTarget)) )
    {
        _pDropTarget->RegisterDragDrop(_hwndLV, _pPrinter);
    }

    //
    // Enable header re-ordering.
    //
    dwExStyle = ListView_GetExtendedListViewStyle( _hwndLV );
    ListView_SetExtendedListViewStyle( _hwndLV, dwExStyle | LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP );

    //
    // !! LATER !! - add toolbar.
    //
    // NO toolbar for now.
    //

    himl = ImageList_Create( gcxSmIcon,
                             gcySmIcon,
                             ILC_MASK,
                             1,
                             3 );
    if( himl ){

        ImageList_SetBkColor( himl, GetSysColor( COLOR_WINDOW ));

        HICON hIcon = (HICON)LoadImage( ghInst,
                                        MAKEINTRESOURCE( IDI_DOCUMENT ),
                                        IMAGE_ICON,
                                        gcxSmIcon, gcySmIcon,
                                        LR_DEFAULTCOLOR );

        if( hIcon ){

            INT iIndex = ImageList_AddIcon( himl, hIcon );

            //
            // The return value to ImageList_AddIcon should be zero
            // since this is the first image we are adding.
            //
            if( iIndex == 0 ){
                SendMessage( _hwndLV, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM)himl );
            } else {
                DBGMSG( DBG_WARN,
                        ( "Queue.ctr: ImageList_AddIcon failed %d %d\n",
                          iIndex, GetLastError( )));
            }

            DestroyIcon( hIcon );

        } else {

            DBGMSG( DBG_ERROR,
                    ( "Queue.ctr: Failed to load hIcon %d\n",
                      GetLastError( )));
        }
    }

    SetWindowLongPtr( _hwnd, DWLP_USER, (LONG_PTR)this );

    {
        //
        // Retrieve the saved windows settings for the printer.
        //
        POSINFO sPos = gPQPos;

        //
        // Get the the queue position persistant setting if it does not already
        // exist create it.  Then read the posistion from the registry.
        //
        {
            TPersist Persist( gszPrinterPositions, TPersist::kCreate|TPersist::kRead );

            if( VALID_OBJ( Persist ) )
            {
                DWORD dwSize = sizeof( sPos );

                TStatusB bStatus;
                bStatus DBGCHK = Persist.bRead( pPrinter()->strPrinter(), &sPos, dwSize );
            }
        }

        _uColMax    = sPos.uColMax;
        _bStatusBar = sPos.bStatusBar;

        ShowWindow( _hwndSB, _bStatusBar ? SW_SHOW : SW_HIDE );
        vAddColumns( &sPos );

        LoadPrinterIcons( _pPrinter->strPrinter(),
                          &_shIconLarge,
                          &_shIconSmall );

        SendMessage( _hwnd, WM_SETICON, ICON_BIG, (LPARAM)(HICON)_shIconLarge );
        SendMessage( _hwnd, WM_SETICON, ICON_SMALL, (LPARAM)(HICON)_shIconSmall );

        sPos.wp.showCmd = nCmdShow;
        SetWindowPlacement( _hwnd, &sPos.wp );

        //
        // Restore the column order
        //
        ListView_SetColumnOrderArray( _hwndLV, _uColMax, sPos.anColOrder );
    }
    //
    // Open the printer.
    //
    _pPrintLib->bJobAdd( _pPrinter,
                         TPrinter::kExecReopen );

    //
    // hwndLV is our valid check.
    //

    //
    // Insert into our linked list, but only if valid.
    //
    {
        CCSLock::Locker CSL( *gpCritSec );
        SPLASSERT( bValid( ));

        _pPrintLib->Queue_vAdd( this );
    }

    return TRUE;

Error:

    return FALSE;
}

VOID
TQueue::
vWindowClosing(
    VOID
    )

/*++

Routine Description:

    Called when window is closing.

Arguments:

Return Value:

--*/

{
    SINGLETHREAD(UIThread);

    //
    // Mark ourselves as closing the windows.  This prevents us from
    // trying to send more hBlocks to the message queue.
    //
    _bWindowClosing = TRUE;

    SendMessage( _hwnd, WM_SETICON, ICON_SMALL, 0 );
    SendMessage( _hwnd, WM_SETICON, ICON_BIG, 0 );

    //
    // Force cleanup of GenWin.
    //
    vForceCleanup();

    //
    // Disassociate the printer from the queue.  At this stage, the
    // window is marked as closed, so we won't put any more hBlocks into
    // the message queue.  If we are being accessed by another thread,
    // we won't delete ourselves until it has released it's reference
    // to us.
    //
    if( _pPrinter )
    {
        _pPrinter->vDelete();
    }

    if( _hEventClose )
    {
        // notify the caller we are about to go away
        SetEvent(_hEventClose);
    }
}


VOID
TQueue::
vSaveColumns(
    VOID
    )
{
    //
    // Save the position info if we had a valid window.
    //
    if( bValid( )){

        POSINFO sPos = { 0 };
        sPos.uColMax = _uColMax;
        sPos.wp.length = sizeof( WINDOWPLACEMENT );
        GetWindowPlacement( _hwnd, &sPos.wp );

        //
        // Get the column widths.
        //
        UINT i;
        PFIELD pFields = pGetColFields();

        for( i=0; i < _uColMax; ++i ){
            sPos.anWidth[i] = ListView_GetColumnWidth( _hwndLV, i );
            sPos.aField[i] = pFields[i];
        }
        sPos.bStatusBar = _bStatusBar;

        //
        // Get the list views column order.
        //
        ListView_GetColumnOrderArray( _hwndLV, _uColMax, sPos.anColOrder );

        //
        // Persist the queue position.
        //
        TPersist Persist( gszPrinterPositions, TPersist::kOpen|TPersist::kWrite );

        if( VALID_OBJ( Persist ) )
        {
            TCHAR szPrinter[kPrinterBufMax];

            TStatusB bStatus;
            bStatus DBGCHK = Persist.bWrite( _pPrinter->pszPrinterName( szPrinter ), &sPos, sizeof( sPos ) );
        }
    }
}

VOID
TQueue::
vAddColumns(
    IN const POSINFO* pPosInfo
    )
{
    SINGLETHREAD(UIThread);

    LV_COLUMN col;
    TCHAR szColName[kColStrMax];
    UINT i;

    for( i=0; i < pPosInfo->uColMax; ++i ){

        //
        // !! SERVERQUEUE !!
        //
        // Add IDS_HEAD_DELTA if server queue.
        //
        LoadString( ghInst,
                    IDS_HEAD + pPosInfo->aField[i],
                    szColName,
                    COUNTOF( szColName ));

        col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        col.fmt  = LVCFMT_LEFT;
        col.pszText = (LPTSTR)szColName;
        col.cchTextMax = 0;
        col.cx = pPosInfo->anWidth[i];
        col.iSubItem = pPosInfo->aField[i];

        ListView_InsertColumn(_hwndLV, i, &col);
    }
}


/********************************************************************

    Message handler.

********************************************************************/

LRESULT
TQueue::
nHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMsg) {
    case WM_PRINTLIB_STATUS: {
        INFO Info;

        Info.dwData = (DWORD)lParam;

        //
        // Status change request from worker thread.
        //
        vContainerChangedHandler( (CONTAINER_CHANGE)wParam, Info );
        break;
    }
    case WM_NOTIFY:

        if( wParam == IDD_LISTVIEW ){
            return lrOnLVNotify( lParam );
        }
        break;

    case WM_SETFOCUS:

        SetFocus( _hwndLV );
        break;

    case WM_CREATE:

        //
        // The window was successfully created, so increment the
        // reference count.  The corresponding decrement is when the
        // windows is destroyed: WM_NCDESTROY.
        //
        vIncRef();
        break;

    case WM_DESTROY:
        if( _pDropTarget )
        {
            // revoke drag & drop
            _pDropTarget->RevokeDragDrop();

            // this a naked COM pointer - release it.
            _pDropTarget->Release();
            _pDropTarget = NULL;
        }
        vSaveColumns();
        break;

    case WM_NCDESTROY:
    {
        //
        // Deleting ourselves must be the absolute last thing that
        // we do; we don't want any more messages to get processed
        // after that.
        //
        // This is necessary because in the synchronous case, we
        // (thread A) notifies the waiter (thread W) that the queue
        // has gone away.  Then we (thread A) call DefWindowProc
        // with WM_NCDESTROY, which lets comctl32 acquire it's global
        // critical section to destory the image list.
        //
        // In rundll32, thread W terminates since the queue is gone,
        // killing thread A which hold the comctl32 global cs.  Then
        // thread w tries to call comctl32's DllEntryPoint with
        // PROCESS_DETACH, which attempts to acquire the global cs.
        // This hangs and the process never terminates.
        //
        LRESULT lResult = DefWindowProc( hwnd(), uMsg, wParam, lParam );

        //
        // Save out the settings since we are closing the window.
        //
        vWindowClosing();

        //
        // Decrement the reference count since we are deleting.
        //
        vDecRefDelete();

        return lResult;
    }
    case WM_APPCOMMAND:
    {
        if( APPCOMMAND_BROWSER_REFRESH == GET_APPCOMMAND_LPARAM(lParam) )
        {
            //
            // Execute refresh.
            //
            SendMessage( _hwnd, WM_COMMAND, MAKELONG(IDM_REFRESH,0), 0);
        }
        break;
    }
    case WM_COMMAND:
    {
        lParam = 0;
        TCHAR szPrinterBuffer[kPrinterBufMax];
        LPTSTR pszPrinter;

        switch( GET_WM_COMMAND_ID( wParam, lParam )){

        case IDM_PRINTER_SET_DEFAULT:

            //
            // Always write out the default string.  User can't
            // unset default printer.
            //
            pszPrinter = _pPrinter->pszPrinterName( szPrinterBuffer );

            //
            // !! LATER !!
            //
            // Put up error message if fails.
            //
            SetDefaultPrinter( szPrinterBuffer );
            break;

        case IDM_PRINTER_SHARING:

            //
            // Put up printer properties.  If sharing was selected,
            // then go directly to that page.
            //
            lParam = TPrinterData::kPropSharing;

            //
            // Fall through to printer properties.
            //

        case IDM_PRINTER_PROPERTIES:

            pszPrinter = _pPrinter->pszPrinterName( szPrinterBuffer );

            vPrinterPropPages(
                NULL,
                pszPrinter,
                SW_SHOWNORMAL,
                lParam );

            break;

        case IDM_PRINTER_DOCUMENT_DEFAULTS:

            pszPrinter = _pPrinter->pszPrinterName( szPrinterBuffer );

            vDocumentDefaults(
                NULL,
                pszPrinter,
                SW_SHOWNORMAL,
                lParam );

            break;

        case IDM_PRINTER_CLOSE:

            DestroyWindow( _hwnd );
            return 0;

        case IDM_STATUS_BAR:
        {
            RECT rc;

            _bStatusBar = !_bStatusBar;

            ShowWindow( _hwndSB,
                        _bStatusBar ?
                            SW_SHOW :
                            SW_HIDE );

            GetClientRect( _hwnd, &rc );

            SendMessage( _hwnd,
                         WM_SIZE,
                         SIZE_RESTORED,
                         MAKELONG( rc.right, rc.bottom ));
            break;
        }

        case IDM_PRINTER_INSTALL:
            if( !CheckRestrictions(_hwnd, REST_NOPRINTERADD) )
            {
                TStatusB bStatus;
                TCHAR szPrinter[kPrinterBufMax];
                LPTSTR pszPrinterName;

                pszPrinterName = _pPrinter->pszPrinterName(szPrinter);

                bStatus DBGCHK = bPrinterSetup( _hwnd,
                                                MSP_NETPRINTER,
                                                ARRAYSIZE(szPrinter),
                                                pszPrinterName,
                                                NULL,
                                                NULL );
            }
            break;

        case IDM_REFRESH:

            _pPrintLib->bJobAdd( _pPrinter,
                                 TPrinter::kExecRefreshAll );
            _pPrinter->vCommandRequested();
            break;

        case IDM_HELP_CONTENTS:

            PrintUIHtmlHelp( _hwnd, gszHtmlPrintingHlp, HH_DISPLAY_TOPIC, reinterpret_cast<ULONG_PTR>( gszHelpQueueId ) );
            break;

        case IDM_HELP_TROUBLESHOOTER:
            {
                ShellExecute( _hwnd, TEXT("open"), TEXT("helpctr.exe"), gszHelpTroubleShooterURL, NULL, SW_SHOWNORMAL );
            }
            break;

        case IDM_HELP_ABOUT:
            {
                TString strWindows;
                TString strTitle;
                LCID    lcid;
                BOOL    bNeedLRM;

                //
                // if we have Arabic/Hebrew locale we add the text as LRM + Text + LRM 
                // to force left-to-right reading (LRM is the unicode character 0x200E)
                //
                lcid = GetUserDefaultLCID();
                bNeedLRM = (PRIMARYLANGID(LANGIDFROMLCID(lcid))== LANG_ARABIC) || 
                           (PRIMARYLANGID(LANGIDFROMLCID(lcid))== LANG_HEBREW);

                if (bNeedLRM)
                {
                    strTitle.bUpdate(TEXT("\x200E"));
                }

                strWindows.bLoadString( ghInst, IDS_WINDOWS );
                strTitle.bCat(strWindows);

                if (bNeedLRM)
                {
                    strTitle.bCat(TEXT("\x200E"));
                }

                ShellAbout( _hwnd, strTitle, NULL, NULL );
            }
            break;

        default:

            return lrProcessCommand( GET_WM_COMMAND_ID( wParam, lParam ));
        }
        break;
    }
    case WM_ACTIVATE:

        //
        // We must pass the active window to TranslateAccelerator,
        // so when the active window for our app changes, make
        // a note of it.
        //
        if( LOWORD( wParam ) & ( WA_ACTIVE | WA_CLICKACTIVE )){
            ghwndActive = _hwnd;
        }
        break;

    case WM_INITMENU:
        {
            HMENU hMenu = GetMenu( _hwnd );

            if( hMenu ){

                HMENU hTemp = GetSubMenu( hMenu, 0 );

                if( hTemp ){
                    vInitPrinterMenu( hTemp );
                }

                hTemp = GetSubMenu( hMenu, 1 );

                if( hTemp ){
                    vInitDocMenu( FALSE, hTemp );
                }

                hTemp = GetSubMenu( hMenu, 2 );

                if( hTemp ){
                    vInitViewMenu( hTemp );
                }
            }
        }
        break;

    case WM_MENUSELECT:

        if( _bStatusBar ){

            MenuHelp( WM_MENUSELECT,
                      wParam,
                      lParam,
                      GetMenu( _hwnd ),
                      ghInst,
                      _hwndSB,
                      gauMenuHelp );
        }

        break;

    case WM_SIZE:

        if( wParam != SIZE_MINIMIZED ){

            UINT dy = 0;

            RECT rc;

            SendMessage( _hwndSB,
                         WM_SIZE,
                         wParam,
                         lParam );

            GetWindowRect( _hwndSB,
                           &rc );

            //
            // If the status bar exists, then we must move it to the
            // bottom and squeeze the listview slightly higher.
            //
            if( _bStatusBar ){
                dy = rc.bottom - rc.top;
            }

            INT aiPanes[3];

            aiPanes[0] = 0;
            aiPanes[1] = (rc.right - rc.left)/2;
            aiPanes[2] = -1;

            //
            // Put three panes there.
            //
            SendMessage( _hwndSB,
                         SB_SETPARTS,
                         3,
                         (LPARAM)aiPanes );

            //
            // Move this list view to match the parent window.
            //
            MoveWindow( _hwndLV,
                        0, 0,
                        LOWORD( lParam ), HIWORD( lParam ) - dy,
                        TRUE );
        }
        break;

    case WM_COPYDATA:
        return bOnCopyData( wParam, lParam );

    case WM_SETTINGCHANGE:
        {
            //
            // Check if the default printer has changed, to update the icon.
            //
            vCheckDefaultPrinterChanged();

            //
            // This message is sent when the system date/time format
            // has been changed so we need to repaint the list view.
            //
            InvalidateRect(_hwndLV, NULL, TRUE);
        }
        break;

    default:
       return DefWindowProc( hwnd(), uMsg, wParam, lParam );
    }

    return 0;
}


LRESULT
TQueue::
lrOnLVNotify(
    IN LPARAM lParam
    )
{
    switch( ((LPNMHDR)lParam)->code ){

    case LVN_GETDISPINFO:
        return lrOnLVGetDispInfo( (LV_DISPINFO*)lParam );

    case LVN_BEGINDRAG:
    case LVN_BEGINRDRAG:
        // return lrOnLVBeginDrag( reinterpret_cast<const NM_LISTVIEW*>(lParam) );
        return 0; // turn off this feature for XP, will turn it back on for Blackcomb

    case NM_DBLCLK:
        return lrOnLVDoubleClick();

#if 0

    case LVN_COLUMNCLICK:
        return lrOnLVColumnClick( (COLUMN)(( NM_LISTVIEW* )lParam )->iSubItem );

#endif

    case NM_RCLICK:
        return lrOnLVRClick( (NMHDR*)lParam );

    }
    return 0;
}

LRESULT
TQueue::
lrOnLVGetDispInfo(
    IN const LV_DISPINFO* plvdi
    )

/*++

Routine Description:

    Process the display info message for list views.

Arguments:

Return Value:

--*/

{
    //
    // If this message is not going to retrieve the text, return immediately
    //
    if( !(plvdi->item.mask & LVIF_TEXT) )
    {
        return 0;
    }

    LPTSTR pszText = plvdi->item.pszText;
    pszText[0] = 0;

    FIELD Field = gPQPos.aField[plvdi->item.iSubItem];
    INFO Info = _pPrinter->pData()->GetInfo( (HITEM)plvdi->item.lParam,
                                             plvdi->item.iSubItem );

    DATA_INDEX DataIndex = 0;
    DWORD dwPrinted;

    //
    // Special case certain fields:
    //
    // JOB_NOTIFY_FIELD_STATUS_STRING - add STATUS
    // JOB_NOTIFY_FIELD_TOTAL_BYTES - add BYTES_PRINTED
    // JOB_NOTIFY_FIELD_TOTAL_PAGES - add PAGES_PRINTED
    //
    switch( Field ){
    case JOB_NOTIFY_FIELD_STATUS_STRING:
    {
        DWORD dwStatus  = 0;
        COUNT cch       = kStrMax;

        //
        // If the print device wants multiple job status strings or
        // current job status string is null then create a job status
        // string using the job status bits.
        //
        if( _pPrinter->eJobStatusStringType() == TPrinter::kMultipleJobStatusString ||
            !Info.pszData ||
            !Info.pszData[0] ){

            dwStatus = _pPrinter->pData()->GetInfo(
                                 (HITEM)plvdi->item.lParam,
                                 TDataNJob::kIndexStatus ).dwData;

            pszText = pszStatusString( pszText,
                                       cch,             // Note: passed by reference
                                       dwStatus,
                                       FALSE,
                                       FALSE,
                                       gaStatusMapJob );
        }

        //
        // Add the status string, but not if it's PRINTING
        // and we already have PRINTING set.
        //
        if( Info.pszData && Info.pszData[0] ){

            TString strPrinting;
            TStatusB bStatus = TRUE;

            if( dwStatus & JOB_STATUS_PRINTING ){

                bStatus DBGCHK = strPrinting.bLoadString(ghInst, IDS_STATUS_PRINTING);

                if( bStatus ){

                    bStatus DBGCHK = lstrcmpi( Info.pszData, strPrinting ) ? TRUE : FALSE;
                }
            }

            if( bStatus ){

                //
                // Add separator if necessary.
                //
                if( pszText != plvdi->item.pszText ){
                    pszText = pszStrCat( pszText, gszStatusSeparator, cch );
                }

                lstrcpyn( pszText, Info.pszData, cch );
            }
        }

        DBGMSG( DBG_TRACE, ("Job info String: " TSTR "\n", pszText ) );

        return 0;
    }
    case JOB_NOTIFY_FIELD_TOTAL_BYTES:
        {
            dwPrinted = _pPrinter->pData()->GetInfo(
                            (HITEM)plvdi->item.lParam,
                            TDataNJob::kIndexBytesPrinted ).dwData;

            if( dwPrinted )
            {
                TString strForwardSlash;

                TStatusB bStatus;
                bStatus DBGCHK = strForwardSlash.bLoadString(ghInst, IDS_QUEUE_FORWARD_SLASH);

                if( bStatus )
                {
                    TCHAR szPrinted[64];
                    TCHAR szTotal[64];

                    StrFormatByteSize(dwPrinted, szPrinted, ARRAYSIZE(szPrinted));
                    StrFormatByteSize(Info.dwData, szTotal, ARRAYSIZE(szTotal));

                    wnsprintf(plvdi->item.pszText, plvdi->item.cchTextMax, TEXT("%s%s%s"),
                        szPrinted, static_cast<LPCTSTR>(strForwardSlash), szTotal);
                }
            }
            else 
            {
                if( Info.dwData )
                {
                    TCHAR szTotal[64];

                    StrFormatByteSize(Info.dwData, szTotal, ARRAYSIZE(szTotal));
                    wnsprintf(plvdi->item.pszText, plvdi->item.cchTextMax, TEXT("%s"), szTotal);
                }
            }

            return 0;
        }
    case JOB_NOTIFY_FIELD_TOTAL_PAGES:

        dwPrinted = _pPrinter->pData()->GetInfo(
                        (HITEM)plvdi->item.lParam,
                        TDataNJob::kIndexPagesPrinted ).dwData;

        //
        // when a downlevel document is printed (the doc goes directly to the port) StartDoc/EndDoc
        // are not called and the spooler doesn't know the total pages of the document. in this case 
        // we don't display the pages info since it is not acurate.
        //
        if( Info.dwData ){

            if( dwPrinted ){
                AddCommas( dwPrinted, pszText );
                lstrcat( pszText, TEXT( "/" ));
            }

            AddCommas( Info.dwData, pszText + lstrlen( pszText ));
        }
        else
        {
            TStatusB bStatus;
            TString strText;
            bStatus DBGCHK = strText.bLoadString(ghInst, IDS_TEXT_NA);

            if( bStatus )
            {
                //
                // just display "N/A" text (we don't know the total pages)
                //
                lstrcpyn(plvdi->item.pszText, strText, plvdi->item.cchTextMax);
            }
        }

        return 0;

    default:
        break;
    }

    switch( gadwFieldTable[Field] ){
    case TABLE_STRING:

        //
        // If we have data, reassign the pointer,
        // else leave it pointing to szText, which is "".
        //
        if( Info.pszData ){
            lstrcpyn( pszText, Info.pszData, kStrMax );
        }

        break;

    case TABLE_DWORD:

        if( Info.dwData ){
            AddCommas( Info.dwData, pszText );
        }
        break;

    case TABLE_TIME:

        if( Info.pSystemTime ){

            SYSTEMTIME LocalTime;
            COUNT cchText;

            if ( !SystemTimeToTzSpecificLocalTime(
                     NULL,
                     Info.pSystemTime,
                     &LocalTime )) {

                DBGMSG( DBG_MIN, ( "[SysTimeToTzSpecLocalTime failed %d]\n",
                                   ::GetLastError( )));
                break;
            }

            if( !GetTimeFormat( LOCALE_USER_DEFAULT,
                                0,
                                &LocalTime,
                                NULL,
                                pszText,
                                kStrMax )){

                DBGMSG( DBG_MIN, ( "[No Time %d], ", ::GetLastError( )));
                break;
            }

            lstrcat( pszText, TEXT("  ") );
            cchText = lstrlen( pszText );
            pszText += cchText;

            if( !GetDateFormat( LOCALE_USER_DEFAULT,
                                dwDateFormatFlags( hwnd() ),
                                &LocalTime,
                                NULL,
                                pszText,
                                kStrMax - cchText )){

                DBGMSG( DBG_MIN, ( "[No Date %d]\n", ::GetLastError( )));
                break;
            }
        }
        break;

    default:
        DBGMSG( DBG_MIN, ( "[?tab %d %x]\n",
                           Field,
                           Info.pvData ));
        break;
    }
    return 0;
}

LRESULT
TQueue::
lrOnLVBeginDrag(
    const NM_LISTVIEW *plv
    )
/*++

Routine Description:

    Initiates drag & drop operation

Arguments:

    Standard for LVN_BEGINDRAG & LVN_BEGINRDRAG

Return Value:

    Standard for LVN_BEGINDRAG & LVN_BEGINRDRAG

--*/
{
    LVITEM lvi = {0};
    lvi.iItem = plv->iItem;
    lvi.iSubItem = plv->iSubItem;
    lvi.mask = LVIF_PARAM;

    if( ListView_GetItem(_hwndLV, &lvi) )
    {
        DragDrop::JOBINFO jobInfo;

        //
        // Initialize job info.
        //
        jobInfo.dwJobID = _pPrinter->pData()->GetId( (HITEM)lvi.lParam );
        jobInfo.hwndLV = _hwndLV;
        jobInfo.iItem = lvi.iItem;
        _pPrinter->pszPrinterName(jobInfo.szPrinterName);

        //
        // Kick off OLE2 drag & drop.
        //
        CRefPtrCOM<IDataObject> spDataObj;
        CRefPtrCOM<IDropSource> spDropSrc;

        if( SUCCEEDED(DragDrop::CreatePrintJobObject(jobInfo, IID_IDataObject, (void **)&spDataObj)) &&
            SUCCEEDED(spDataObj->QueryInterface(IID_IDropSource, (void **)&spDropSrc)) )

        {
            DWORD dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY;
            SHDoDragDrop(_hwndLV, spDataObj, spDropSrc, dwEffect, &dwEffect);
        }
    }

    return 0;
}

VOID
TQueue::
vInitPrinterMenu(
    HMENU hMenu
    )
{
    //
    // If printer is paused, enable pause, etc.
    //
    BOOL bPaused = _dwStatusPrinter & PRINTER_STATUS_PAUSED;

    //
    // Disable admin functions if not an administrator.
    // We should guard this, but since it's just status, don't bother.
    //
    BOOL bAdministrator = _pPrinter->dwAccess() == PRINTER_ALL_ACCESS;

    BOOL bDirect = _dwAttributes & PRINTER_ATTRIBUTE_DIRECT ? TRUE : FALSE;

    TCHAR szPrinterBuffer[kPrinterBufMax];
    LPTSTR pszPrinter;

    pszPrinter = _pPrinter->pszPrinterName( szPrinterBuffer );

    TCHAR szScratch[2];

    // let's do a quick EnumPrinters call here and see if this printer is
    // locally installed (local printer or printer connection)
    BOOL bInstalled = FALSE;
    DWORD cPrinters = 0, cbBuffer = 0;
    DWORD dwIndex;
    CAutoPtrSpl<PRINTER_INFO_5> spPrinters;

    if( VDataRefresh::bEnumPrinters(PRINTER_ENUM_CONNECTIONS|PRINTER_ENUM_LOCAL, 
            NULL, 5, (void **)&spPrinters, &cbBuffer, &cPrinters) )
    {
        // linear search to see if our printer is installed locally,
        for( DWORD dw = 0; dw < cPrinters; dw++ )
        {
            if( 0 == lstrcmp(spPrinters[dw].pPrinterName, pszPrinter) )
            {
                dwIndex = dw;
                bInstalled = TRUE;
                break;
            }
        }
    }

    BOOL bDefault = bInstalled ? CheckDefaultPrinter(pszPrinter) == kDefault : FALSE;
    BOOL bIsLocal = bInstalled ? _pPrinter->pszServerName(szPrinterBuffer) == NULL : FALSE;
    BOOL bIsNowOffline = _dwAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE;

    CheckMenuItem( hMenu,
                   IDM_PRINTER_SET_DEFAULT,
                   bDefault ?
                        MF_BYCOMMAND|MF_CHECKED :
                        MF_BYCOMMAND|MF_UNCHECKED );

    EnableMenuItem( hMenu,
                    IDM_PRINTER_SET_DEFAULT,
                    bInstalled ?
                        MF_BYCOMMAND|MF_ENABLED :
                        MF_BYCOMMAND|MF_DISABLED|MF_GRAYED );

    EnableMenuItem( hMenu,
                    IDM_PRINTER_INSTALL,
                    bInstalled ?
                        MF_BYCOMMAND|MF_DISABLED|MF_GRAYED :
                        MF_BYCOMMAND|MF_ENABLED );

    CheckMenuItem( hMenu,
                   IDM_PRINTER_PAUSE,
                   bPaused ?
                        MF_BYCOMMAND|MF_CHECKED :
                        MF_BYCOMMAND|MF_UNCHECKED );

    EnableMenuItem( hMenu,
                    IDM_PRINTER_PAUSE,
                    bAdministrator ?
                        MF_BYCOMMAND|MF_ENABLED :
                        MF_BYCOMMAND|MF_DISABLED|MF_GRAYED );

    EnableMenuItem( hMenu,
                    IDM_PRINTER_PURGE,
                    bAdministrator ?
                        MF_BYCOMMAND|MF_ENABLED :
                        MF_BYCOMMAND|MF_DISABLED|MF_GRAYED );

    CheckMenuItem( hMenu,
                   IDM_PRINTER_WORKOFFLINE,
                   bIsNowOffline ?
                        MF_BYCOMMAND|MF_CHECKED :
                        MF_BYCOMMAND|MF_UNCHECKED );

    EnableMenuItem( hMenu,
                    IDM_PRINTER_WORKOFFLINE,
                    bAdministrator ?
                        MF_BYCOMMAND|MF_ENABLED :
                        MF_BYCOMMAND|MF_DISABLED|MF_GRAYED );

    BOOL bIsRedirected = FALSE;
    BOOL bIsMasq = _dwAttributes & PRINTER_ATTRIBUTE_LOCAL && _dwAttributes & PRINTER_ATTRIBUTE_NETWORK;

    //
    // We only check for redirected port for local printer.
    // If bIsLocal is TRUE, bInstalled must be TRUE
    // 
    if( bIsLocal )
    {
        IsRedirectedPort( spPrinters[dwIndex].pPortName, &bIsRedirected );
    }

    //
    // Remove the work offline menu item if this printer is
    // not local or the printer is a masq printer, or if it's a 
    // redirected port printer which is not offline now.
    //
    if( !_dwAttributes || !bIsLocal || (bIsRedirected && !bIsNowOffline) || bIsMasq )
    {
        RemoveMenu( hMenu, IDM_PRINTER_WORKOFFLINE, MF_BYCOMMAND );
    }
}

VOID
TQueue::
vInitDocMenu(
    BOOL bAllowModify,
    HMENU hMenu
    )
/*++

Routine Name:

    vInitDocMenu

Routine Description:

    Enables or disable the document menu selections.

Arguments:

    bAllowModify - whether we allow deleting the menu item.
    HMENU - Handle to document menu

Return Value:


--*/

{
    INT iSel = ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED );
    INT iSelCount = ListView_GetSelectedCount( _hwndLV );

    UINT fuFlags = (iSelCount > 1 || iSel >= 0) ?
                       MF_BYCOMMAND|MF_ENABLED :
                       MF_BYCOMMAND|MF_DISABLED|MF_GRAYED;

    EnableMenuItem(hMenu, IDM_JOB_PAUSE, fuFlags);
    EnableMenuItem(hMenu, IDM_JOB_RESUME, fuFlags);
    EnableMenuItem(hMenu, IDM_JOB_RESTART, fuFlags);
    EnableMenuItem(hMenu, IDM_JOB_CANCEL, fuFlags);
    EnableMenuItem(hMenu, IDM_JOB_PROPERTIES, fuFlags);

    // 
    // If more than one item are selected, we will enable all menu items.
    //
    if( iSelCount == 1 && iSel >= 0 && _pPrinter->pData() )
    {
        // let's see if we can un-clutter the menu a little bit...
        LVITEM lvi;
        ZeroMemory(&lvi, sizeof(lvi));

        lvi.iItem = iSel;
        lvi.mask = LVIF_PARAM;

        if( ListView_GetItem(_hwndLV, &lvi) )
        {
            DWORD dwStatus = _pPrinter->pData()->GetInfo(
                reinterpret_cast<HITEM>(lvi.lParam), TDataNJob::kIndexStatus).dwData;

            if( bAllowModify )
            {
                // delete the corresponding menu item
                DeleteMenu(hMenu, (dwStatus & JOB_STATUS_PAUSED) ? IDM_JOB_PAUSE : IDM_JOB_RESUME, MF_BYCOMMAND);
            }
            else
            {
                // disable the corresponding menu item
                EnableMenuItem(hMenu, 
                    (dwStatus & JOB_STATUS_PAUSED) ? IDM_JOB_PAUSE : IDM_JOB_RESUME, 
                    MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
            }
        }
    }
}

VOID
TQueue::
vInitViewMenu(
    HMENU hMenu
    )
{
    CheckMenuItem( hMenu,
                   IDM_STATUS_BAR,
                       _bStatusBar ?
                           MF_BYCOMMAND | MF_CHECKED :
                           MF_BYCOMMAND | MF_UNCHECKED );
}

/********************************************************************

    Support double click context menus.

********************************************************************/

LRESULT
TQueue::
lrOnLVDoubleClick(
    VOID
    )
{
    //
    // We only handle when an item is selected.
    //
    if( ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED ) < 0 )
        return FALSE;

//
// Prevent the selection of multiple jobs
//
#if 1
    //
    // If multiple job selections then error.
    //
    if( ListView_GetSelectedCount( _hwndLV ) > 1){
        return FALSE;
    }
#endif

    //
    // Display the selected job property.
    //
    vProcessItemCommand( IDM_JOB_PROPERTIES );

    return TRUE;

}

/********************************************************************

    Support right click context menus.

********************************************************************/

LRESULT
TQueue::
lrOnLVRClick(
    NMHDR* pnmhdr
    )
{
    LRESULT lReturn = TRUE;

    switch( pnmhdr->code ){
    case NM_RCLICK:
    {
        INT iSel;
        HMENU hmContext;
        POINT pt;

        iSel = ListView_GetNextItem( _hwndLV, -1, LVNI_SELECTED );

        hmContext = ShellServices::LoadPopupMenu(ghInst, MENU_PRINTQUEUE, iSel >= 0 ? 1 : 0);
        if( !hmContext ){
            break;
        }

        if( iSel < 0 ){

            //
            // We need to remove the "Close" menu item
            // (and separator).
            //
            iSel = GetMenuItemCount( hmContext ) - 2;
            DeleteMenu( hmContext, iSel, MF_BYPOSITION );
            DeleteMenu( hmContext, iSel, MF_BYPOSITION );

            vInitPrinterMenu( hmContext );

        } else {

            vInitDocMenu( TRUE, hmContext );
        }

        DWORD dw = GetMessagePos();
        pt.x = GET_X_LPARAM(dw);
        pt.y = GET_Y_LPARAM(dw);

        //
        // The command will just get stuck in the regular queue and
        // handled at that time.
        //
        TrackPopupMenu( hmContext,
                        TPM_LEFTALIGN|TPM_RIGHTBUTTON,
                         pt.x, pt.y,
                         0, _hwnd, NULL);

        DestroyMenu(hmContext);
        break;
    }
    default:
        lReturn = FALSE;
        break;
    }
    return lReturn;
}

/********************************************************************

    Commands.

********************************************************************/



LRESULT
TQueue::
lrProcessCommand(
    IN UINT uCommand
    )

/*++

Routine Description:

    Process an IDM_* command.

Arguments:

Return Value:

    LRESULT

--*/

{
    //
    // Item (printer) command.
    //
    if( uCommand >= IDM_PRINTER_COMMAND_FIRST && uCommand <= IDM_PRINTER_COMMAND_LAST )
    {
        TSelection* pSelection = new TSelection( this, _pPrinter );

        if( pSelection )
        {

            switch( uCommand ){
            case IDM_PRINTER_PAUSE:
                pSelection->_CommandType        = TSelection::kCommandTypePrinter;
                pSelection->_dwCommandAction    = _dwStatusPrinter & PRINTER_STATUS_PAUSED ?
                                                                     PRINTER_CONTROL_RESUME :
                                                                     PRINTER_CONTROL_PAUSE;
                break;

            case IDM_PRINTER_PURGE:
                {
                    TCHAR szScratch[kStrMax+kPrinterBufMax] = {0};
                    if( CommandConfirmationPurge(_hwnd, _pPrinter->pszPrinterName(szScratch)) )
                    {
                        pSelection->_CommandType        = TSelection::kCommandTypePrinter;
                        pSelection->_dwCommandAction    = PRINTER_CONTROL_PURGE;
                    }
                }
                break;

            case IDM_PRINTER_WORKOFFLINE:
                pSelection->_CommandType        = TSelection::kCommandTypePrinterAttributes;
                pSelection->_dwCommandAction    = _dwAttributes ^ PRINTER_ATTRIBUTE_WORK_OFFLINE;

                DBGMSG( DBG_WARN, ( "Queue.lrProcessCommand: Workoffline %d\n", uCommand ));
                break;

            default:

                pSelection->_dwCommandAction = 0;
                DBGMSG( DBG_WARN, ( "Queue.lrProcessCommand: unknown command %d\n", uCommand ));
                break;
            }

            //
            // Queue the async command.
            //
            _pPrinter->vCommandQueue( pSelection );
        }
        else
        {
            vShowResourceError( _hwnd );
        }
    }
    else
    {
        //
        // Item (job) command.
        //
        vProcessItemCommand( uCommand );
    }

    return 0;
}

VOID
TQueue::
vProcessItemCommand(
    IN UINT uCommand
    )

/*++

Routine Description:

    Retrieves all selected items and attemps to execute a command
    on them.

Arguments:

    uCommand - IDM_* command.

Return Value:

--*/

{
    //
    // Declare job menu id to Job command mapping structure.
    //
    static struct {
        UINT  idmCommand;
        DWORD dwCommand;
    } aJobCommand[] = {
        { IDM_JOB_CANCEL,       JOB_CONTROL_DELETE      },
        { IDM_JOB_PAUSE,        JOB_CONTROL_PAUSE       },
        { IDM_JOB_RESUME,       JOB_CONTROL_RESUME      },
        { IDM_JOB_RESTART,      JOB_CONTROL_RESTART     }
    };

    //
    // Get a list of selected Job IDs
    //
    TSelection* pSelection = new TSelection( this,
                                             _pPrinter );

    //
    // Check for allocation error.  We want to put a pop-up on all
    // user actions if we can detect the error immediately after
    // the user issues the command.  Otherwise put in status bar.
    //
    if( !VALID_PTR(pSelection) ){

        vShowResourceError( _hwnd );
        goto NoCommand;
    }

    //
    // There a few job related menu selections which are not
    // deferable events i.e Job properties, This event will be done
    // immediately and then release the selection object.
    //
    switch( uCommand ){

        case IDM_JOB_PROPERTIES: {

            TCHAR szPrinter[kPrinterBufMax];
            LPTSTR pszPrinter;

            pszPrinter = _pPrinter->pszPrinterName( szPrinter );

            vDocumentPropSelections( NULL, pszPrinter,  pSelection );
            goto NoCommand;
        }

        default:
            break;
    }

    //
    // Ask for confirmation...
    //
    if( IDM_JOB_CANCEL == uCommand && 
        IDYES != iMessage(_hwnd, IDS_PRINTERS_TITLE, IDS_QUEUE_SURE_CANCEL, 
        MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2, kMsgNone, NULL) )
    {
        goto NoCommand;
    }

    //
    // Map the job menu id to a job command.
    //
    UINT uIndex;
    for( uIndex = 0; uIndex < COUNTOF( aJobCommand ); ++uIndex ){

        //
        // Check for a matching IDM_JOB -> JOB_CONTROL mapping.
        //
        if( aJobCommand[uIndex].idmCommand == uCommand ){

            //
            // Update the command action and job type
            //
            pSelection->_dwCommandAction = aJobCommand[uIndex].dwCommand;
            pSelection->_CommandType = TSelection::kCommandTypeJob;

            //
            // Queue the job commands
            //
            _pPrinter->vCommandQueue( pSelection );
            return;
        }
    }

    //
    // No matches; punt.
    //
    SPLASSERT( FALSE );

NoCommand:

    delete pSelection;
    return;
}

/********************************************************************

    Utils.

********************************************************************/

BOOL
TQueue::
bInsertItem(
    HITEM hItem,
    LIST_INDEX ListIndex
    )
{
    LV_ITEM item;

    //
    // Insert item into listview.
    //
    item.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    item.iSubItem = 0;
    item.pszText = LPSTR_TEXTCALLBACK;
    item.state = 0;
    item.iImage = 0;

    item.iItem = ListIndex;
    item.lParam = (LPARAM)hItem;

    if( ListView_InsertItem( _hwndLV, &item ) < 0 ){

        DBGMSG( DBG_WARN,
                ( "Queue.bInsertItem: Failed to add job %d\n",
                  GetLastError( )));

        return FALSE;
    }
    return TRUE;
}


/********************************************************************

    Job block processing.

********************************************************************/

VOID
TQueue::
vBlockProcess(
    VOID
    )

/*++

Routine Description:

    The request has been PostMessage'd and now is ready for
    processing.  If we need to save state, get the queue
    selections then notify the pData that something has changed.

    (The pData may call back and request that the list view
    be cleared and reset.)

    Called from UI thread only.

Arguments:

Return Value:

--*/

{
    SINGLETHREAD(UIThread);
    SPLASSERT( _pPrinter );
    SPLASSERT( _pPrinter->pData( ));

    //
    // Keep track if the number of jobs changes.  If it does,
    // then we need to update the status bar.
    //
    COUNT cItems = _cItems;

    //
    // Process all pending blocks.
    //
    _pPrinter->pData()->vBlockProcess();

    if( cItems != _cItems ){

        TCHAR szScratch[kStrMax];
        TCHAR szText[kStrMax];
        szText[0] = 0;

        //
        // Always update the job count.
        //
        if( LoadString( ghInst,
                        IDS_SB_JOBS,
                        szScratch,
                        COUNTOF( szScratch ))){

            wsprintf( szText, szScratch, _cItems );
        }

        SendMessage( _hwndSB,
                     SB_SETTEXT,
                     kStatusPaneJobs,
                     (LPARAM)szText );

        //
        // Check if it's pending deletion and we just printed the
        // last job.  The queue window should close.
        //
        bDeletingAndNoJobs();
    }
}


/********************************************************************

    Private status helper functions

********************************************************************/

LPTSTR
TQueue::
pszStatusString(
       OUT LPTSTR pszDest,
    IN OUT UINT& cchMark,
    IN     DWORD dwStatus,
    IN     BOOL bInitialSep,
    IN     BOOL bFirstOnly,
    IN     const STATUS_MAP pStatusMaps[]
    )

/*++

Routine Description:

    Builds a status string into pszDest, based on the dwStatus bitfield
    and Type.

Arguments:

    pszDest - Buffer to receive status string.

    cchMark - Char count of pszDest; on return, holds chars remaining.

    dwStatus - DWORD status field matching Type.

    bInitialSep - Indicates whether an initial separator is needed.

    pStatusMaps - Pointer to array of status maps (bit -> IDS).

    bFirstOnly - Adds only 1 status string.

Return Value:

    Pointer to the end of the string (ready for next vStrCat.
    cchMark is updated.

--*/

{
    TCHAR szStatus[kStrMax];
    LPTSTR pszMark = pszDest;
    UINT i;

    for( i = 0, pszMark[0] = 0;
         pStatusMaps->dwMask;
         ++i, ++pStatusMaps ){

        if( pStatusMaps->dwMask & dwStatus ){

            if( !LoadString( ghInst,
                             pStatusMaps->uIDS,
                             szStatus,
                             COUNTOF( szStatus ))){

                DBGMSG( DBG_ERROR,
                        ( "Queue.pszStatusString: unable to load %d, error %d\n",
                          pStatusMaps->uIDS,
                          GetLastError( )));

                continue;
            }

            //
            // If not at the beginning, we need a separator.
            //
            if( pszMark != pszDest || bInitialSep ){

                //
                // Spit out a separator.
                //
                pszMark = pszStrCat( pszMark,
                                     gszStatusSeparator,
                                     cchMark );

                if( !pszMark )
                    break;
            }

            //
            // Append the status string.
            //
            pszMark = pszStrCat( pszMark,
                                 szStatus,
                                 cchMark );

            if( !pszMark || bFirstOnly ){
                break;
            }
        }
    }
    return pszMark;
}


/********************************************************************

    MPrinterClient virtual definitions.

********************************************************************/

VOID
TQueue::
vItemChanged(
    IN ITEM_CHANGE ItemChange,
    IN HITEM hItem,
    IN INFO Info,
    IN INFO InfoNew
    )

/*++

Routine Description:

    A particular item changed, refresh just part of the window.

    Note: Currently there is no sorting, so the NATURAL_INDEX is
    the same as the LIST_INDEX.

    When a TData* calls this routine, it must also upate its data
    structures before calling this.

Arguments:

    ItemChange - Indicates what about the job changed.

    hItem - Handle to job that changed.

    Info - Depends on the type of change; generally the old version
        of the info.

    InfoNew - Depends on the type of change; generally the new version
        of the info.

Return Value:

--*/

{
    SINGLETHREAD(UIThread);

    //
    // Fix up one job.
    //
    switch( ItemChange ){
    case kItemCreate:

        //
        // Always insert at the end of the list.
        //
        Info.NaturalIndex = _cItems;

        //
        // How to handle this error?
        //
        // !! SORT !!
        // iItem == NaturalIndex only if no sorting is enabled.
        //
        bInsertItem( hItem, Info.NaturalIndex );
        ++_cItems;

        break;

    case kItemDelete:

        //
        // Delete the item from the listview.
        //

        //
        // !! SORT !!
        // iItem == NaturalIndex only if no sorting is enabled.
        //
        if( !bDeleteItem( Info.NaturalIndex )){

            DBGMSG( DBG_WARN,
                    ( "Queue.vItemChanged: Failed to del job %d\n",
                      GetLastError( )));
        }

        --_cItems;

        break;

    case kItemName:

        //
        // We must set the item text, or else the width of the
        // label doesn't change.
        //

        //
        // !! SORT !!
        //
        ListView_SetItemText(
            _hwndLV,
            Info.NaturalIndex,
            0,
            (LPTSTR)_pPrinter->pData()->GetInfo( hItem, 0 ).pszData );

        //
        // Fall through.
        //

    case kItemInfo:
    case kItemAttributes:

        //
        // If it's visible, invalidate the line.
        //

        //
        // !! SORT !!
        // iItem == NaturalIndex only if no sorting is enabled.
        //
        RECT rc;

        if( ListView_GetItemRect( _hwndLV,
                                  Info.NaturalIndex,
                                  &rc,
                                  LVIR_BOUNDS )){

            InvalidateRect( _hwndLV, &rc, TRUE );
        }
        break;

    case kItemPosition:

        vItemPositionChanged( hItem,
                              Info.NaturalIndex,
                              InfoNew.NaturalIndex );
        break;

    default:

        DBGMSG( DBG_ERROR,
                ( "Queue.vItemChanged: Unknown change %x\n", ItemChange ));
        break;
    }
}

VOID
TQueue::
vContainerChanged(
    IN CONTAINER_CHANGE ContainerChange,
    IN INFO Info
    )
{
    DBGMSG( DBG_QUEUEINFO,
            ( "Queue.vContainerChanged: %x %x\n", ContainerChange, Info.dwData ));

    //
    // Some of the commands are synchronous.  Handle them first.
    //
    switch( ContainerChange ){

    case kContainerReloadItems:

        vReloadItems( Info.dwData );
        break;

    case kContainerClearItems:

        vClearItems();
        break;

    case kContainerStateVar:

        _pPrintLib->bJobAdd( _pPrinter, Info.dwData );
        break;

    default:

        //
        // All asynchronous commands use PostMessage to get to UI thread.
        //
        PostMessage( _hwnd, WM_PRINTLIB_STATUS, ContainerChange, Info.dwData );
        break;
    }
}

VOID
TQueue::
vSaveSelections(
    VOID
    )
{
    SINGLETHREAD(UIThread);

    //
    // State needs to be saved.
    // NOT RE-ENTRANT.
    //
    SPLASSERT( !SaveSelection._pSelection );

    //
    // Determine which item is selected and store the Id.
    //
    SaveSelection._idFocused = kInvalidIdentValue;
    INT iItem = ListView_GetNextItem( _hwndLV, -1,  LVNI_FOCUSED );

    if( iItem != -1 ){

        //
        // !! SORTORDER !!
        //
        HANDLE hItem = _pPrinter->pData()->GetItem( iItem );
        SaveSelection._idFocused = _pPrinter->pData()->GetId( hItem );
    }

    //
    // Save selected Items.
    //
    // Can't handle a failure here--we don't want to pop up a
    // message box (since this could be poll-refresh) and we
    // don't want to disturb the current error in the status bar.
    // (The status bar error is only for user-initiated commands:
    // we assume the user will look here before executing another
    // commnad.)
    //
    SaveSelection._pSelection = new TSelection( this,
                                                _pPrinter );
}


VOID
TQueue::
vRestoreSelections(
    VOID
    )
{
    SINGLETHREAD(UIThread);

    if( SaveSelection._idFocused != kInvalidIdentValue ){

        NATURAL_INDEX NaturalIndex;
        LV_ITEM item;

        //
        // Translate ID to DataIndex.
        // !! SORT ORDER !!
        //
        item.stateMask =
        item.state = LVIS_FOCUSED;

        NaturalIndex = _pPrinter->pData()->GetNaturalIndex( SaveSelection._idFocused,
                                                            NULL );

        //
        // The DataIndex value may be gone of the selectd Item was
        // deleted or printed.
        //
        if( NaturalIndex != kInvalidNaturalIndexValue ){

            SendMessage( _hwndLV,
                         LVM_SETITEMSTATE,
                         NaturalIndex,
                         (LPARAM)&item );
        }
    }

    //
    // Don't check using VALID_PTR since the no-selection case will
    // cause it to fail, but we don't want to flag an error.
    //
    if( SaveSelection._pSelection && SaveSelection._pSelection->bValid( )){

        NATURAL_INDEX NaturalIndex;
        COUNT i;
        PIDENT pid;
        LV_ITEM item;

        item.stateMask =
        item.state = LVIS_SELECTED;

        for( i = 0, pid = SaveSelection._pSelection->_pid;
             i < SaveSelection._pSelection->_cSelected;
             ++i, ++pid ){

            //
            // Translate IDENT to DataIndex.
            // !! SORT ORDER !!
            //
            NaturalIndex = _pPrinter->pData()->GetNaturalIndex( *pid,
                                                                NULL );

            //
            // The DataIndex value may be gone of the selected Item was
            // deleted or printed.
            //
            if( NaturalIndex != kInvalidNaturalIndexValue ){
                SendMessage( _hwndLV,
                             LVM_SETITEMSTATE,
                             NaturalIndex,
                             (LPARAM)&item );
            }
        }
    }

    //
    // Cleanup even if we fail.
    //
    delete SaveSelection._pSelection;
    SaveSelection._pSelection = NULL;
}

VDataNotify*
TQueue::
pNewNotify(
    MDataClient* pDataClient
    ) const
{
    return new TDataNJob( pDataClient );
}

VDataRefresh*
TQueue::
pNewRefresh(
    MDataClient* pDataClient
    ) const
{
    return new TDataRJob( pDataClient );
}


/********************************************************************

    Retrieve selected items.  Used when processing commands against
    items or saving and restoring the selection during a refresh.

********************************************************************/

COUNT
TQueue::
cSelected(
    VOID
    ) const
{
    SINGLETHREAD(UIThread);
    return ListView_GetSelectedCount( _hwndLV );
}

HANDLE
TQueue::
GetFirstSelItem(
    VOID
    ) const
{
    SINGLETHREAD(UIThread);
    INT iItem = ListView_GetNextItem( _hwndLV,
                                      -1,
                                      LVNI_SELECTED );
    return INT2PTR(iItem, HANDLE);
}

HANDLE
TQueue::
GetNextSelItem(
    HANDLE hItem
    ) const
{
    SINGLETHREAD(UIThread);

    INT iJob = (INT)(ULONG_PTR)hItem;

    SPLASSERT( iJob < 0x8000 );

    iJob = ListView_GetNextItem( _hwndLV,
                                 iJob,
                                 LVNI_SELECTED );

    if( iJob == -1 ){
        DBGMSG( DBG_ERROR,
                ( "Queue.hItemNext: LV_GNI failed %d\n",
                  GetLastError( )));
    }
    return INT2PTR(iJob, HANDLE);
}

IDENT
TQueue::
GetId(
    HANDLE hItem
    ) const
{
    SINGLETHREAD(UIThread);
    INT iJob = (INT)(ULONG_PTR)hItem;

    if( iJob != -1 ){

        hItem = _pPrinter->pData()->GetItem( iJob );
        return _pPrinter->pData()->GetId( hItem );
    }
    return kInvalidIdentValue;
}

BOOL
TQueue::
bGetPrintLib(
    TRefLock<TPrintLib> &refLock
    ) const
{
    ASSERT(_pPrintLib.pGet());
    if (_pPrintLib.pGet())
    {
        refLock.vAcquire(_pPrintLib.pGet());
        return TRUE;
    }
    return FALSE;
}

VOID
TQueue::
vRefZeroed(
    VOID
    )
{
    if( bValid( )){
        delete this;
    }
}


/********************************************************************

    Implementation functions.

********************************************************************/

VOID
TQueue::
vContainerChangedHandler(
    IN CONTAINER_CHANGE ContainerChange,
    IN INFO Info
    )
{
    static DWORD gadwConnectStatusMap[] = CONNECT_STATUS_MAP;

    SINGLETHREAD(UIThread);

    switch( ContainerChange ){

    case kContainerNewBlock:

        vBlockProcess();
        break;

    case kContainerAttributes:

        _dwAttributes = Info.dwData;

        //
        // Update the queue view title, (Note status information is displayed here)
        //
        vUpdateTitle();

        //
        // !! LATER !!
        //
        // Change printer icon.
        //
        break;

    case kContainerName:

        //
        // Update the queue view title, (Note status information is displayed here)
        //
        vUpdateTitle();
        break;

    case kContainerStatus:

        _dwStatusPrinter = Info.dwData;

        //
        // If the printer is pending deletion and has no jobs,
        // then immediately punt.
        //
        if( bDeletingAndNoJobs( )){
            return;
        }

        //
        // Update the queue view title, (Note status information is displayed here)
        //
        vUpdateTitle();

        break;

    case kContainerConnectStatus:

        SPLASSERT( Info.dwData < COUNTOF( gadwConnectStatusMap ));
        _idsConnectStatus = gadwConnectStatusMap[Info.dwData];

        //
        // If the printer isn't found, then put up a message box and
        // dismiss the queue view.
        //
        if( Info.dwData == kConnectStatusInvalidPrinterName ){

            TCHAR szPrinter[kPrinterBufMax];
            LPTSTR pszPrinter = _pPrinter->pszPrinterName( szPrinter );

            iMessage( _hwnd,
                      IDS_ERR_PRINTER_NOT_FOUND_TITLE,
                      IDS_ERR_PRINTER_NOT_FOUND,
                      MB_OK|MB_ICONSTOP,
                      ERROR_INVALID_PRINTER_NAME,
                      NULL,
                      pszPrinter );

            SendMessage( _hwnd,
                         WM_CLOSE,
                         0,
                         0 );

            break;
        }

        //
        // Update the queue view title, (Note status information is displayed here)
        //
        vUpdateTitle();

        break;

    case kContainerErrorStatus: {

        _dwErrorStatus = Info.dwData;

        //
        // Scan for known errors and translate into friendly strings.
        //
        static const ERROR_MAP gaErrorMap[] = {
            ERROR_ACCESS_DENIED, IDS_ERR_ACCESS_DENIED,
        };

        COUNT i;
        DWORD idsError = IDS_SB_ERROR;

        for( i=0; i< COUNTOF( gaErrorMap ); ++i ){

            if( _dwErrorStatus == gaErrorMap[i].dwError ){
                idsError = gaErrorMap[i].uIDS;
                break;
            }
        }

        TString strText;

        if( _dwErrorStatus ){

            TStatusB bStatus;

            bStatus DBGCHK = strText.bLoadString( ghInst, idsError );
        }

        SendMessage( _hwndSB, SB_SETTEXT, kStatusPaneError, (LPARAM)(LPCTSTR)strText );
        break;
    }

    case kContainerRefreshComplete:
        break;

    default:
        DBGMSG( DBG_ERROR, ( "Queue.vContainerChanged: unknown ContainerChange %x\n", ContainerChange ));
        break;
    }
}


VOID
TQueue::
vUpdateTitle(
    VOID
    )
{
    TCHAR szScratch[kStrMax+kPrinterBufMax];
    TCHAR szText[kStrMax+kPrinterBufMax];
    UINT nSize = COUNTOF( szText );

    //
    // Build the printer status string.
    //
    ConstructPrinterFriendlyName( pszPrinterName( szScratch ), szText, &nSize );

    //
    // Calculate the string text.
    //
    UINT cch = lstrlen( szText );
    LPTSTR pszText = szText + cch;
    cch = COUNTOF( szText ) - cch;

    //
    // Update the title text with the current printer status.
    //
    pszText = pszStatusString( pszText, cch, _dwStatusPrinter, TRUE, FALSE, gaStatusMapPrinter );

    //
    // Special case the work off line status, because work offline is not
    // implemented in the spooler as a printer status rather as a printer attribute.
    //
    if( _dwAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE )
    {
        if( LoadString( ghInst, IDS_WORK_OFFLINE, szScratch, COUNTOF( szScratch )))
        {
            pszText = pszStrCat( pszText, gszSpace, cch );
            pszText = pszStrCat( pszText, gszStatusSeparator, cch );
            pszText = pszStrCat( pszText, gszSpace, cch );
            pszText = pszStrCat( pszText, szScratch, cch );
        }
    }

    //
    // If the connection status changed then update the text.
    //
    if( _idsConnectStatus ){

        if( LoadString( ghInst, _idsConnectStatus, szScratch, COUNTOF( szScratch )))
        {
            pszText = pszStrCat( pszText, gszSpace, cch );
            pszText = pszStrCat( pszText, szScratch, cch );
        }
    }

    //
    // Set the queu view title bar text.
    //
    SetWindowText( _hwnd, szText );
}


BOOL
TQueue::
bDeletingAndNoJobs(
    VOID
    )

/*++

Routine Description:

    Returns TRUE if the queue is pending deletion and has no jobs.
    In this case it will also close the window.

Arguments:

Return Value:

    TRUE - Pending deletion with no Jobs; window also closed.
    FALSE - Not (pending deletion and no jobs).

--*/

{
    if( _cItems == 0 && _dwStatusPrinter & PRINTER_STATUS_PENDING_DELETION ){
        PostMessage( _hwnd, WM_CLOSE, 0, 0 );
        return TRUE;
    }
    return FALSE;
}


VOID
TQueue::
vItemPositionChanged(
    IN HITEM hItem,
    IN NATURAL_INDEX NaturalIndex,
    IN NATURAL_INDEX NaturalIndexNew
    )
{
    SPLASSERT( NaturalIndexNew < _cItems );
    SPLASSERT( NaturalIndex != NaturalIndexNew );

    DBGMSG( DBG_QUEUEINFO,
            ( "Queue.vItemPositionChanged: Change requested %d %d %x\n",
              NaturalIndex, NaturalIndexNew, hItem ));

    //
    // Get the item state.
    //
    UINT uState = ListView_GetItemState( _hwndLV,
                                         NaturalIndex,
                                         LVIS_FOCUSED | LVIS_SELECTED );

    //
    // Move it to the right place.
    //
    if( !bDeleteItem( NaturalIndex )){

        DBGMSG( DBG_WARN,
                ( "Queue.vItemPositionChanged: Moving, delete failed on %d %d\n",
                  NaturalIndex, GetLastError( )));
    }

    if( bInsertItem( hItem, NaturalIndexNew )){

        //
        // Set item state.
        //
        ListView_SetItemState( _hwndLV,
                               NaturalIndexNew,
                               LVIS_FOCUSED | LVIS_SELECTED,
                               uState );
    } else {

        DBGMSG( DBG_ERROR,
                ( "Queue.vItemPositionChanged: Moving, insert failed on %d %d\n",
                  NaturalIndex, GetLastError( )));
    }
}

VOID
TQueue::
vClearItems(
    VOID
    )

/*++

Routine Description:

    Removes all items from the list view.

    May be called from either UI or worker thread.  If called from
    worker thread, must guarantee that there are no synchronization
    problems.

Arguments:

Return Value:

--*/

{
    DBGMSG( DBG_QUEUEINFO, ( "Queue.vClearItems: Clearing %d %d\n", _hwndLV, this ));

    TStatusB bStatus;

    //
    // Clear out all items from list view.
    //
    bStatus DBGCHK = ListView_DeleteAllItems( _hwndLV );
}


VOID
TQueue::
vReloadItems(
    COUNT cItems
    )

/*++

Routine Description:

    Delete all items in the list view and refresh based on the
    new pData information.

Arguments:

Return Value:

--*/

{
    SINGLETHREAD(UIThread);

    DBGMSG( DBG_QUEUEINFO,
            ( "Queue.vReloadItems: Reload %d %d %d\n",
              _hwndLV, this, cItems ));

    vClearItems();
    _cItems = cItems;

    //
    // If we have Items, insert them.
    //
    if( _pPrinter->pData() && cItems ){

        LV_ITEM item;

        //
        // Notify the list view of how many jobs we will ultimately insert
        // to avoid reallocs.
        //
        ListView_SetItemCount( _hwndLV, cItems );

        //
        // Add to the listview.
        //
        item.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        item.iSubItem = 0;
        item.pszText = LPSTR_TEXTCALLBACK;
        item.state = 0;
        item.iImage = 0;

        HANDLE hItem;
        COUNT cItemIndex;

        for( cItemIndex = 0, hItem = _pPrinter->pData()->GetItem( 0 );
             cItemIndex < cItems;
             ++cItemIndex, hItem = _pPrinter->pData()->GetNextItem( hItem )){

            item.iItem = cItemIndex;
            item.lParam = (LPARAM)hItem;
            if( ListView_InsertItem( _hwndLV, &item ) < 0 ){

                DBGMSG( DBG_ERROR,
                        ( "Queue.vReloadItems: Failed to insert item %d %d\n",
                          item, GetLastError( )));
                break;
            }
        }
    }
}

BOOL
TQueue::
bOnCopyData(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
/*++

Routine Description:

    Get the data pased to it and checks if it matches the
    current printer name.

Arguments:


Return Value:

    TRUE printer name matches, FALSE match not found.

--*/

{
    TCHAR szFullPrinterName[kPrinterBufMax];
    TCHAR szPrinterName[kPrinterBufMax];
    BOOL bStatus            = FALSE;
    PCOPYDATASTRUCT pcpds   = (PCOPYDATASTRUCT)lParam;
    LPCTSTR pszPrinterName  = (LPTSTR)pcpds->lpData;

    //
    // Check for valid queue signature.
    //
    if( pcpds->dwData == static_cast<DWORD>( TQueue::kQueueSignature ) ){

        //
        // Get the queue view printer name, this may not be fully qualified
        // if it's a local printer.
        //
        if( _pPrinter->pszPrinterName( szPrinterName ) ){

            DBGMSG( DBG_TRACE, ("CopyMessage Printer Name " TSTR " Passed Data " TSTR "\n", szPrinterName, pszPrinterName ) );

            //
            // If the printer name passed is fully qualified and the current
            // queue view printer name is not fully qualified then prepend the
            // computer name.
            //
            if( pszPrinterName[0] == TEXT('\\') &&
                pszPrinterName[1] == TEXT('\\') &&
                szPrinterName[0] != TEXT('\\') &&
                szPrinterName[1] != TEXT('\\') ){

                _tcscpy( szFullPrinterName, _pPrintLib->strComputerName() );
                _tcscat( szFullPrinterName, TEXT("\\") );
                _tcscat( szFullPrinterName, szPrinterName );

            //
            // If the passed printer name is not fully qualified and the
            // queue view is fully qualified then strip the computer name.
            //
            } else if( pszPrinterName[0] != TEXT('\\') &&
                pszPrinterName[1] != TEXT('\\') &&
                szPrinterName[0] == TEXT('\\') &&
                szPrinterName[1] == TEXT('\\') ){


                LPCTSTR psz = _tcschr( szPrinterName+2, TEXT('\\') );
                _tcscpy( szFullPrinterName, psz ? psz : TEXT("") );

            //
            // The passed printer name and the queue view printer names are either
            // fully qualified or not, but they match.
            //
            } else {
                _tcscpy( szFullPrinterName, szPrinterName );
            }

            //
            // Check if the printer names match.
            //
            if( !_tcsicmp( szFullPrinterName, pszPrinterName ) ){
                bStatus = TRUE;
            }
        }
    }

    return bStatus;
}

BOOL
TQueue::
bIsDuplicateWindow(
    IN HWND    hwndOwner,
    IN LPCTSTR pszPrinterName,
    IN HWND    *phwnd
    )
/*++

Routine Description:

    Asks the queue view window if you are the one with the specified
    printer name.  This will ensure there is only one queue view per
    printer on the machine.

Arguments:

    hwndOwner       - Handle of parent window
    pszPrinterName  - Printer name to check
    *phwnd          - Pointer where to return the duplicate previous window handle.

Return Value:

    TRUE duplicate found and phwnd point to its window handle.
    FALSE duplicate window not found.

--*/
{
    BOOL bStatus    = FALSE;
    HWND hwnd       = NULL;

    DBGMSG( DBG_TRACE, ("Searching for Printer Name " TSTR "\n", pszPrinterName ) );

    for (hwnd = FindWindow(gszClassName, NULL); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        TCHAR szClass[kStrMax];
        COPYDATASTRUCT cpds;

        //
        // Set up the copy data structure.
        //
        cpds.dwData     = static_cast<DWORD>( TQueue::kQueueSignature );
        cpds.cbData     = _tcslen( pszPrinterName ) * sizeof(TCHAR) + sizeof(TCHAR);
        cpds.lpData     = reinterpret_cast<PVOID>( const_cast<LPTSTR>( pszPrinterName ) );

        //
        // Just another check to ensure the class name matches.
        //
        GetClassName(hwnd, szClass, COUNTOF(szClass));
        if(!_tcsicmp( szClass, gszClassName ))
        {
            //
            // Ask this queue window if you are viewing this printer.
            //
            if( SendMessage(hwnd, WM_COPYDATA, (WPARAM)hwndOwner, (LPARAM)&cpds) )
            {
                *phwnd = hwnd;
                bStatus = TRUE;
                break;
            }
        }
    }

    return bStatus;

}

VOID
TQueue::
vRemove(
    IN LPCTSTR  pszPrinterName
    )
/*++

Routine Description:

    Remove the printer queue view registry positon information.

Arguments:

    Pointer to printer fully qualified printer name.

Return Value:

    Nothing.

--*/
{
    TPersist Persist( gszPrinterPositions, TPersist::kOpen|TPersist::kRead|TPersist::kWrite );

    if( VALID_OBJ( Persist ) )
    {
        TStatusB bStatus;
        bStatus DBGCHK = Persist.bRemove( pszPrinterName );
    }
}

VOID 
TQueue::
vCheckDefaultPrinterChanged(
    VOID
    )

/*++

Routine Description:

    Update the print queue icon if needed.

Arguments:

    None.

Return Value: 

--*/

{
    BOOL bDefaultPrinter;
    TCHAR szPrinter[kPrinterBufMax];

    _pPrinter->pszPrinterName(szPrinter);
    bDefaultPrinter = CheckDefaultPrinter(szPrinter) == kDefault;

    if( _bDefaultPrinter ^ bDefaultPrinter )
    {
        //
        //  If the default printer setting is changed and it related to
        //  current printer, change the window icon
        //
        _bDefaultPrinter = bDefaultPrinter;

        CAutoHandleIcon shIconLarge, shIconSmall;
        LoadPrinterIcons(szPrinter, &shIconLarge, &shIconSmall);
        if( shIconLarge && shIconSmall )
        {
            _shIconLarge = shIconLarge.Detach();
            _shIconSmall = shIconSmall.Detach();

            SendMessage( _hwnd, WM_SETICON, ICON_BIG, (LPARAM)(HICON)_shIconLarge );
            SendMessage( _hwnd, WM_SETICON, ICON_SMALL, (LPARAM)(HICON)_shIconSmall );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\result.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999
All rights reserved.

Module Name:

    result.cxx

Abstract:

    Error result help class

Author:

    Steve Kiraly (SteveKi)  03-20-1998

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <lmerr.h>
#include "result.hxx"

TResult::
TResult(
    IN DWORD dwLastError
    ) : _dwLastError( dwLastError )
{
}

TResult::
~TResult(
    VOID
    )
{
}

BOOL
TResult::
bValid(
    VOID
    )
{
    return TRUE;
}

TResult::
TResult(
    const TResult &rhs
    )
{
    _dwLastError = rhs._dwLastError;
}

const TResult &
TResult::
operator =(
    const TResult &rhs
    )
{
    if( this != &rhs )
    {
        _dwLastError = rhs._dwLastError;
    }
    return *this;
}

TResult::
operator DWORD(
    VOID
    )
{
    return _dwLastError;
}

BOOL
TResult::
bGetErrorString(
    IN TString &strLastError
    ) const
{
    DWORD       cchReturn           = 0;
    LPTSTR      pszFormatMessage    = NULL;
    HMODULE     hModule             = NULL;
    DWORD       dwFlags             = 0;
    TLibrary    *pLib               = NULL;
    TStatusB    bStatus;

    bStatus DBGNOCHK = FALSE;

    //
    // If the last error is from a lanman call.
    //
    if( _dwLastError >= NERR_BASE && _dwLastError <= MAX_NERR )
    {
        pLib = new TLibrary( gszNetMsgDll );

        if( VALID_PTR( pLib ) )
        {
            hModule = pLib->hInst();
        }

        dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_FROM_HMODULE |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK;
    }
    else
    {
        dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_IGNORE_INSERTS |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_MAX_WIDTH_MASK;
    }

    //
    // Format the message with the passed in last error.
    //
    cchReturn = FormatMessage( dwFlags,
                               hModule,
                               _dwLastError,
                               0,
                               (LPTSTR)&pszFormatMessage,
                               0,
                               NULL );

    //
    // If a format string was returned then copy it back to
    // the callers specified string.
    //
    if( cchReturn )
    {
        bStatus DBGCHK = strLastError.bUpdate( pszFormatMessage );
    }

    //
    // Release the format string.
    //
    if( pszFormatMessage )
    {
        LocalFree( pszFormatMessage );
    }

    //
    // Release the net library dll.
    //
    delete pLib;

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\rtlmir.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    rtlmir.cxx

Abstract:

    RTL (right-to-left) mirroring &
    BIDI localized support

Author:

    Lazar Ivanov (LazarI)

Revision History:

    Jul-29-1999 - Created.

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "rtlmir.hxx"

BOOL 
bConvertHexStringToInt( 
    TCHAR *pszHexNum, 
    int *piNum 
    )
/*++

Routine Description:

    Converts a hex numeric string into an integer.

Arguments:

    pszHexNum - thre string that needs to be converted to a number
    piNum - where to put the output number after the convertion

Return Value:

    TRUE on sucess, FALSE otherwise

--*/
{
    int   n=0L;
    TCHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNext(psz))
    {
        if( (*psz >= TEXT('0')) && (*psz <= TEXT('9')) )
            n = 0x10 * n + *psz - TEXT('0');
        else
        {
            TCHAR ch = *psz;
            int n2;

            if(ch >= TEXT('a'))
                ch -= TEXT('a') - TEXT('A');

            n2 = ch - TEXT('A') + 0xA;

            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}


BOOL  
bIsBiDiLocalizedSystemEx( 
    LANGID *pLangID
    )
/*++

Routine Description:

    returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5. 

Arguments:

    pLangID - where to return the user default UI language

Return Value:

    TRUE on sucess, FALSE otherwise

--*/
{
    HKEY          hKey;
    DWORD         dwType;
    CHAR          szResourceLocale[12];
    DWORD         dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    int           iLCID=0L;
    BOOL          bRet = FALSE;
    LANGID        langID = GetUserDefaultUILanguage();

    /*
     * Need to use NT5 detection method (Multiligual UI ID)
     */
    if( langID )
    {
        WCHAR wchLCIDFontSignature[16];
        iLCID = MAKELCID( langID , SORT_DEFAULT );

        /*
         * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
         * convert to decimal value and call GetLocaleInfo afterwards.
         * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
         */

        if( GetLocaleInfoW( iLCID , 
                            LOCALE_FONTSIGNATURE , 
                            (WCHAR *) &wchLCIDFontSignature[0] ,
                            (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
        {
  
            /* Let's verify the bits we have a BiDi UI locale */
            if( ( wchLCIDFontSignature[7] & (WCHAR)0x0800) && bIsUILanguageInstalled( langID ) )
            {
                bRet = TRUE;
            }
        }
    }

    if( bRet && pLangID )
    {
        *pLangID = langID;
    }

    return bRet;
}

BOOL
bIsBiDiLocalizedSystem( 
    VOID
    )
/*++

Routine Description:

    returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5. 

Arguments:

    None

Return Value:

    TRUE on sucess, FALSE otherwise

--*/
{
    return bIsBiDiLocalizedSystemEx( NULL );
}

typedef struct tagMUIINSTALLLANG {
    LANGID LangID;
    BOOL   bInstalled;
} MUIINSTALLLANG, *LPMUIINSTALLLANG;

BOOL CALLBACK 
EnumUILanguagesProc(
    LPTSTR lpUILanguageString, 
    LONG_PTR lParam
    )
/*++

Routine Description:

    standard EnumUILanguagesProc

Arguments:

    standard - see the SDK

Return Value:

    standard - see the SDK

--*/
{
    int langID = 0;

    bConvertHexStringToInt(lpUILanguageString, &langID);

    if((LANGID)langID == ((LPMUIINSTALLLANG)lParam)->LangID)
    {
        ((LPMUIINSTALLLANG)lParam)->bInstalled = TRUE;
        return FALSE;
    }
    return TRUE;
}

BOOL
bIsUILanguageInstalled( 
    LANGID langId
    )
/*++

Routine Description:

    Verifies that a particular User UI language is installed on W2k

Arguments:

    langId - language to check for

Return Value:

    TRUE if installed, FALSE otherwise

--*/
{
    MUIINSTALLLANG MUILangInstalled = {0};
    MUILangInstalled.LangID = langId;

    EnumUILanguages(EnumUILanguagesProc, 0, (LONG_PTR)&MUILangInstalled);

    return MUILangInstalled.bInstalled;
}

BOOL
bIsWindowMirroredRTL( 
    HWND hWnd
    )
/*++

Routine Description:

    Verifies whether a particular window is right-to-left mirrored.

Arguments:

    hWnd - window to check for

Return Value:

    TRUE if mirrored, FALSE otherwise

--*/
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\rundll.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
All rights reserved.

Module Name:

    rundll.cxx

Abstract:

    Run dll entry interface for lauching printer related
    UI from shell extenstion and other shell related components.

Author:

    Steve Kiraly (SteveKi)  29-Sept-1996

Revision History:

--*/
#include "precomp.hxx"
#pragma hdrstop

#include "rundll.hxx"
#include "getopt.hxx"
#include "parser.hxx"
#include "permc.hxx"
#include "asyncdlg.hxx"
#include "tstpage.hxx"
#include "time.hxx"
#include "psetup.hxx"
#include "drvsetup.hxx"
#include "instarch.hxx"
#include "portslv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "prtshare.hxx"
#include "dsinterf.hxx"
#include "drvsetup.hxx"
#include "driverif.hxx"
#include "driverlv.hxx"
#include "archlv.hxx"
#include "detect.hxx"
#include "setup.hxx"
#include "spllibex.hxx"
#include "spinterf.hxx"

/*++

Routine Name:

    PrintUIEntryW

Routine Description:

    Interface for the Rundll32 process.

Arguments:

    hwnd            - Window handle of stub window.
    hInstance,      - Rundll instance handle.
    pszCmdLine      - Pointer to UNICOE command line.
    nCmdShow        - Show command value always TRUE.

Return Value:

    Nothing.

--*/
DWORD
PrintUIEntryW(
    IN HWND        hwnd,
    IN HINSTANCE   hInstance,
    IN LPCTSTR     pszCmdLine,
    IN UINT        nCmdShow
    )
{
    DBGMSG( DBG_TRACE, ( "PrintUIEntryW interface\n" ) );
    DBGMSG( DBG_TRACE, ( "hwnd                 %x\n",  hwnd ) );
    DBGMSG( DBG_TRACE, ( "hInstance            %x\n",  hInstance ) );
    DBGMSG( DBG_TRACE, ( "pszCmdLine           %ws\n", pszCmdLine ) );
    DBGMSG( DBG_TRACE, ( "nCmdShow             %d\n",  nCmdShow ) );
    DBGMSG( DBG_TRACE, ( "CommandLine          %ws\n", GetCommandLine() ) );

    //
    // we need to count the error messages to see if necessary to
    // show up UI in case of an error or if somebody has been done 
    // this already
    //
    CMsgBoxCounter msgCounter(MB_ICONSTOP|MB_ICONINFORMATION);

    UINT        ac              = 0;
    TCHAR     **av              = NULL;
    BOOL        bRetval         = FALSE;
    AParams     Params          = {0};

    //
    // Strip any trailing white space.
    //
    vStripTrailWhiteSpace( (LPTSTR)pszCmdLine );

    //
    // Convert the command line to an argv,
    //
    bRetval = StringToArgv( pszCmdLine,         // Command line arguments
                            &ac,                // Place to return arg count
                            &av,                // Place to return argv
                            FALSE );            // There is no file name on the command line

    if( bRetval )
    {
        //
        // Store pointer to command line.
        //
        Params.pszCmdLine = pszCmdLine;

        //
        // Parse the command line argumens and execute the command.
        //
        bRetval = bDoCommand( hwnd, ac, av, &Params );
    }

    if( !bRetval )
    {
        //
        // If we are not in quiet mode display error messsage.
        //
        if( !Params.Flags.IsQuiet && 0 == msgCounter.GetCount() )
        {
            switch( Params.dwLastError )
            {
                case ERROR_SUCCESS:
                case ERROR_CANCELLED:
                    break;

                case ERROR_ACCESS_DENIED:
                    {
                        // show up a friendly message that conform the shell32.dll
                        // message in this case. this is because this will be invoked 
                        // primarily from shell32.dll from the runas commands
                        iMessage(NULL, IDS_PRINTERS_TITLE, IDS_FRIENDLY_ACCESSDENIED, 
                            MB_OK|MB_ICONINFORMATION, kMsgNone, NULL);
                    }
                    break;

                case ERROR_INVALID_PARAMETER:
                    {
                        // show up a friendly message to say that the arguments are invalid
                        iMessage(NULL, IDS_PRINTERS_TITLE, IDS_ERROR_INVALID_ARG, 
                            MB_OK|MB_ICONSTOP, kMsgNone, NULL);
                    }
                    break;

                default:
                    {
                        // we are going to show a generic error message here 
                        iMessage(NULL, IDS_PRINTERS_TITLE, IDS_ERR_GENERIC, 
                            MB_OK|MB_ICONSTOP, Params.dwLastError, NULL);
                    }
                    break;
            }

            //
            // If the last error code was not set then set it to a generic
            // error value.  We just chose one, ERROR_INVALID_FUNCTION
            //
            if( Params.dwLastError == ERROR_SUCCESS )
            {
                Params.dwLastError = GetLastError();

                if( Params.dwLastError == ERROR_SUCCESS )
                {
                    Params.dwLastError = ERROR_INVALID_FUNCTION;
                }
            }
        }
    }

    //
    // Ensure we release the command line argv.
    //
    ReleaseArgv( av );

    //
    // If something failed and the error code was not set then set
    // the error to an unspecified error value.
    //
    if( !bRetval )
    {
        //
        // Set the last error incase the caller ignores the return value.
        //
        SetLastError( Params.dwLastError );
    }

    return Params.dwLastError;
}

/*++

Routine Name:

    bDoCommand

Routine Description:

    Parses the commmand line passed by rundll32.

Arguments:

    hwnd            - Parent window handle.
    ac              - Number of strings.
    av              - Pointer to an array of pointer to strings.

Return Value:

    TRUE function complete ok.  FALSE error occurred.

--*/
BOOL
bDoCommand(
    IN HWND     hwnd,
    IN INT      ac,
    IN LPTSTR  *av,
    IN AParams *pParams
    )
{
    INT     retval;
    LPTSTR  options         = TEXT("?KYUPHwuzZkyxqeospS:X:t:d:i:n:r:m:c:l:a:f:b:g:h:v:j:M:W:G:"); // Supported options
    INT     iFunction       = kUnknown;
    BOOL    bStatus         = FALSE;

    //
    // Set to known state
    //
    SetLastError( ERROR_SUCCESS );

    //
    // Indicate there is not a file name as the first argument.
    //
    TGetOptContext context;
    context.optind = 0;

    //
    //  Process any command line arguments switches.
    //
    for (context.opterr = 0, retval = 0; retval != EOF; )
    {
        retval = getopt (ac, av, options, context);

        switch (retval)
        {
        case 't':
            pParams->dwSheet = _ttoi( context.optarg );
            break;
        case 'n':
            pParams->pPrinterName = context.optarg;
            break;
        case 'r':
            pParams->pPortName = context.optarg;
            break;
        case 'm':
            pParams->pModelName = context.optarg;
            break;
        case 'M':
            // get the message type first
            pParams->uMsgType = *context.optarg == TEXT('q') ? kMsgConfirmation     : 
                                *context.optarg == TEXT('w') ? kMsgWarning          : kMsgUnknownType;

            // get the real message text here                
            context.optarg++;
            if( kMsgUnknownType != pParams->uMsgType && context.optarg && *context.optarg )
            {
                pParams->pMsgConfirm = context.optarg;
            }
            break;
        case 'b':
            pParams->pBasePrinterName = context.optarg;
            break;
        case 'f':
            pParams->pInfFileName = context.optarg;
            break;
        case 'a':
            pParams->pBinFileName = context.optarg;
            break;
        case 'G':
            {
                // global flags
                if( *context.optarg == TEXT('w') )
                {
                    // we should suppress the setup driver warnings UI 
                    // -- i.e. we're in super quiet mode
                    pParams->Flags.IsSupressSetupUI = TRUE;
                }
            }
            break;
        case 'g':
            iFunction = *context.optarg == TEXT('a') ? kAddPerMachineConnection     :
                        *context.optarg == TEXT('d') ? kDeletePerMachineConnection  :
                        *context.optarg == TEXT('e') ? kEnumPerMachineConnections   : kUnknown;
            break;
        case 'j':
            pParams->pProvider = context.optarg;
            break;
        case 'i':
            iFunction = *context.optarg == TEXT('n') ? kInstallNetPrinter           :
                        *context.optarg == TEXT('l') ? kInstallLocalPrinter         :
                        *context.optarg == TEXT('d') ? kInstallPrinterDriver        :
                        *context.optarg == TEXT('a') ? kInstallDriverWithInf        :
                        *context.optarg == TEXT('f') ? kInstallPrinterWithInf       :
                        *context.optarg == TEXT('i') ? kInstallLocalPrinterWithInf  : kUnknown;

            break;
        case 'd':
            iFunction = *context.optarg == TEXT('n') ? kDeleteNetPrinter    :
                        *context.optarg == TEXT('l') ? kDeleteLocalPrinter  :
                        *context.optarg == TEXT('d') ? kDeletePrinterDriver : kUnknown;
            break;
        case 'o':
            iFunction = kWin32QueueView;
            break;
        case 's':
            iFunction = kServerProperties;
            break;
        case 'p':
            iFunction = kProperties;
            break;
        case 'X':
            iFunction = *context.optarg == TEXT('g') ? kPrinterGetSettings    :
                        *context.optarg == TEXT('s') ? kPrinterSetSettings    : kUnknown;
            break;
        case 'e':
            iFunction = kDocumentDefaults;
            break;
        case 'c':
            pParams->pMachineName = context.optarg;
            break;
        case 'l':
            pParams->pSourcePath = context.optarg;
            break;
        case 'h':
            pParams->pArchitecture = context.optarg;
            break;
        case 'v':
            pParams->pVersion = context.optarg;
            break;
        case 'q':
            pParams->Flags.IsQuiet = TRUE;
            break;
        case 'k':
            iFunction = kPrintTestPage;
            break;
        case 'y':
            iFunction = kSetAsDefault;
            break;
        case 'x':
            pParams->Flags.IsWebPointAndPrint = TRUE;
            break;
        case 'z':
            pParams->Flags.IsNoSharing = TRUE;
            break;
        case 'Z':
            pParams->Flags.IsShared = TRUE;
            break;
        case 'u':
            pParams->Flags.IsUseExistingDriver = TRUE;
            break;
        case 'w':
            pParams->Flags.IsUnknownDriverPrompt = TRUE;
            break;
        case 'W':
            // wizards flags
            pParams->Flags.IsWizardRestartable = *context.optarg == TEXT('r') ? TRUE : FALSE;
            break;
        case 'H':
            pParams->Flags.IsHydraSpecific = TRUE;
            break;
        case 'P':
            pParams->Flags.IsPromptForNeededFiles = TRUE;
            break;
        case 'Y':
            pParams->Flags.IsDontAutoGenerateName = TRUE;
            break;
        case 'K':
            pParams->Flags.IsUseNonLocalizedStrings = TRUE;
            break;
        case 'S':
            iFunction = *context.optarg == TEXT('s') ? kPrinterPersist    :
                        *context.optarg == TEXT('r') ? kPrinterRestore    : kUnknown;
            break;
        case 'U':
            pParams->Flags.IsWindowsUpdate = TRUE;
            break;
        case EOF:
            bStatus = TRUE;
            break;
        case '?':
            iFunction = kCommandHelp;
            bStatus = TRUE;
            retval = EOF;
            break;
        case INVALID_COMAND:
            bStatus = FALSE;
            retval = EOF;
            break;
        default:
            retval = EOF;
            break;
        }
    }

    //
    // If success validate the command line arguments.
    //
    if( bStatus )
    {
        //
        // Do simple validation on the command line arguments.
        //
        bStatus = bValidateCommand( iFunction, pParams );

        if( bStatus )
        {
            //
            // If there are any remaining arguments then get
            // the argument count and pointer to it.
            //
            if( context.optind < ac )
            {
                pParams->av = &av[context.optind];
                pParams->ac = ac - context.optind;
            }

            //
            // Check to see if we need to ask the user to confirm the operation if
            // not in quiet mode.
            //
            BOOL bContinueExecution = TRUE;
            if( !pParams->Flags.IsQuiet && kMsgUnknownType != pParams->uMsgType && pParams->pMsgConfirm )
            {
                //
                // there is a confirmation/warning message specified and we are going to
                // give opportunity to the user to cancel the whole command here
                //
                UINT uFlags = kMsgConfirmation == pParams->uMsgType ? MB_ICONQUESTION :
                              kMsgConfirmation == pParams->uMsgType ? MB_ICONEXCLAMATION : 0;
                ASSERT(uFlags);             // shouldn't be zero
                uFlags |= MB_YESNO;         // we are asking YES/NO question
                bContinueExecution = (IDYES == iMessage2(NULL, MAKEINTRESOURCE(IDS_PRINTERS_TITLE), 
                                                    pParams->pMsgConfirm, uFlags, kMsgNone, NULL));
            }

            if( bContinueExecution )
            {
                //
                // Execute the command.
                //
                bStatus = bExecuteCommand( hwnd, iFunction, pParams );
            }
        }
    }

    return bStatus;
}

/*++

Routine Name:

    bValidateCommand

Routine Description:

    Validates the command line arguments

Arguments:

    iFunction       - Function code.
    pParams         - pointer to paramter structure.

Return Value:

    TRUE arguments are valid.  FALSE invalid argument found.

--*/
BOOL
bValidateCommand(
    IN  INT     iFunction,
    IN  AParams *pParams
    )
{
    DBGMSG( DBG_TRACE, ("iFunction %d\n",            iFunction                        ) );
    DBGMSG( DBG_TRACE, ("Params\n"                                                    ) );
    DBGMSG( DBG_TRACE, ("Flags            %x\n",     pParams->Flags                   ) );
    DBGMSG( DBG_TRACE, ("dwSheet          %d\n",     pParams->dwSheet                 ) );
    DBGMSG( DBG_TRACE, ("dwLastError      %d\n",     pParams->dwLastError             ) );
    DBGMSG( DBG_TRACE, ("pPrinterName     "TSTR"\n", DBGSTR( pParams->pPrinterName    ) ) );
    DBGMSG( DBG_TRACE, ("pPortName        "TSTR"\n", DBGSTR( pParams->pPortName       ) ) );
    DBGMSG( DBG_TRACE, ("pModelName       "TSTR"\n", DBGSTR( pParams->pModelName      ) ) );
    DBGMSG( DBG_TRACE, ("pInfFileName     "TSTR"\n", DBGSTR( pParams->pInfFileName    ) ) );
    DBGMSG( DBG_TRACE, ("pBasePrinterName "TSTR"\n", DBGSTR( pParams->pBasePrinterName) ) );
    DBGMSG( DBG_TRACE, ("pMachineName     "TSTR"\n", DBGSTR( pParams->pMachineName    ) ) );
    DBGMSG( DBG_TRACE, ("pSourcePath      "TSTR"\n", DBGSTR( pParams->pSourcePath     ) ) );
    DBGMSG( DBG_TRACE, ("pszCmdLine       "TSTR"\n", DBGSTR( pParams->pszCmdLine      ) ) );
    DBGMSG( DBG_TRACE, ("pBinFileName     "TSTR"\n", DBGSTR( pParams->pBinFileName    ) ) );

    BOOL bRetval = FALSE;

    switch( iFunction )
    {
    case kInstallLocalPrinter:
    case kDeleteLocalPrinter:
    case kInstallPrinterDriver:
    case kEnumPerMachineConnections:
    case kServerProperties:
    case kCommandHelp:
        bRetval = TRUE;
        break;

    case kInstallLocalPrinterWithInf:
        if( pParams->pInfFileName )
        {
            bRetval = TRUE;
        }
        break;

    case kSetAsDefault:
    case kAddPerMachineConnection:
    case kDeletePerMachineConnection:
    case kInstallNetPrinter:
    case kDeleteNetPrinter:
    case kWin32QueueView:
    case kProperties:
    case kDocumentDefaults:
    case kPrintTestPage:
    case kPrinterGetSettings:
    case kPrinterSetSettings:
        if( pParams->pPrinterName )
        {
            bRetval = TRUE;
        }
        else
        {
            pParams->dwLastError = ERROR_INVALID_PRINTER_NAME;
        }
        break;

    case kInstallPrinterWithInf:
        if( pParams->pModelName && pParams->pInfFileName && pParams->pPortName )
        {
            bRetval = TRUE;

            if( pParams->Flags.IsWebPointAndPrint )
            {
                //
                // Commenting out pBinFileName - for local cab install for wp&p the bin file
                // won't exist.  This may be fixed if syncing to the server is added and
                // this could be put back then. - pvine
                //
                bRetval = pParams->pPrinterName /*&& pParams->pBinFileName */? TRUE : FALSE;
            }
            else if( pParams->Flags.IsDontAutoGenerateName ) 
            {
                bRetval = pParams->pBasePrinterName != NULL;
            }
        }
        break;

    case kPrinterPersist:
    case kPrinterRestore:
        bRetval = pParams->pPrinterName && pParams->pBinFileName ? TRUE : FALSE;
        break;

    case kDeletePrinterDriver:
    case kInstallDriverWithInf:
        if( pParams->pModelName )
        {
            bRetval = TRUE;
        }
        break;

    case kUnknown:
        pParams->dwLastError = ERROR_INVALID_FUNCTION;
        bRetval = FALSE;
        break;
    }

    if( !bRetval && ERROR_SUCCESS == pParams->dwLastError )
    {
        //
        // An invalid parameter has been passed.
        //
        pParams->dwLastError = ERROR_INVALID_PARAMETER;
    }

    return bRetval;
}


/*++

Routine Name:

    bExecuteCommand

Routine Description:

    Executes the command from the rundll32 command line
    after it has parsed.

Arguments:

    hwnd            - parent window handle.
    iFunction       - Function code.
    pParams         - pointer to paramter structure.

Return Value:

    TRUE function complete ok.  FALSE error occurred.

--*/
BOOL
bExecuteCommand(
    IN  HWND    hwnd,
    IN  INT     iFunction,
    IN  AParams *pParams
    )
{
    BOOL bRetval        = TRUE;
    TCHAR szBuffer[kPrinterBufMax];
    UINT uSize          = COUNTOF( szBuffer );

    DBGMSG( DBG_TRACE, ("Function     %d\n", iFunction ) );

    szBuffer[0] = TEXT('\0');

    if( pParams->pPrinterName )
    {
        _tcsncpy( szBuffer, pParams->pPrinterName, COUNTOF( szBuffer ) );
    }

    //
    // Dispatch the specified function.
    //
    // !!Policy!! if a command is executed then it is responsible
    // for displaying any error UI i.e message boxes.
    //
    switch( iFunction )
    {
    case kInstallNetPrinter:
        (VOID)bPrinterSetup( NULL, MSP_NETPRINTER, MAX_PATH, szBuffer, &uSize, pParams->pMachineName );
        break;

    case kDeleteNetPrinter:
        bRetval = bPrinterNetRemove( NULL, szBuffer, pParams->Flags.IsQuiet );
        break;

    case kDeleteLocalPrinter:
        bRetval = bRemovePrinter( NULL, szBuffer, pParams->pMachineName, pParams->Flags.IsQuiet );
        break;

    case kInstallPrinterDriver:
        bRetval = bDriverSetupNew( NULL, TWizard::kDriverInstall, MAX_PATH, szBuffer, &uSize, 
            pParams->pMachineName, 0, pParams->Flags.IsWizardRestartable );
        break;

    case kInstallLocalPrinter:
        bRetval = bPrinterSetupNew( NULL, TWizard::kPrinterInstall, MAX_PATH, szBuffer, &uSize, 
            pParams->pMachineName, NULL, pParams->Flags.IsWizardRestartable );
        break;

    case kInstallLocalPrinterWithInf:
        bRetval = bPrinterSetupNew( NULL, TWizard::kPrinterInstall, MAX_PATH, szBuffer, &uSize, pParams->pMachineName, pParams->pInfFileName, FALSE );
        break;

    case kInstallDriverWithInf:
        bRetval = bDoInfDriverInstall( pParams );
        break;

    case kInstallPrinterWithInf:
        bRetval = bDoInfPrinterInstall( pParams );
        break;

    case kAddPerMachineConnection:
        vAddPerMachineConnection(pParams->pMachineName,pParams->pPrinterName,pParams->pProvider,pParams->Flags.IsQuiet);
        break;

    case kDeletePerMachineConnection:
        vDeletePerMachineConnection(pParams->pMachineName,pParams->pPrinterName,pParams->Flags.IsQuiet);
        break;

    case kEnumPerMachineConnections:
        vEnumPerMachineConnections(pParams->pMachineName,pParams->pInfFileName,pParams->Flags.IsQuiet);
        break;

    case kWin32QueueView:
        vQueueCreate( NULL, pParams->pPrinterName, SW_SHOW, TRUE );
        break;

    case kProperties:
        vPrinterPropPages( NULL, pParams->pPrinterName, SW_SHOW, MAKELPARAM( pParams->dwSheet+256, 0 ));
        break;

    case kDocumentDefaults:
        vDocumentDefaults( NULL, pParams->pPrinterName, SW_SHOW, MAKELPARAM( pParams->dwSheet, 1 ));
        break;

    case kServerProperties:
        vServerPropPages( NULL, pParams->pPrinterName, SW_SHOW, MAKELPARAM( pParams->dwSheet, 1 ));
        break;

    case kDeletePrinterDriver:
        bRetval = bDoDriverRemoval( pParams );
        break;

    case kSetAsDefault:
        bRetval = SetDefaultPrinter( pParams->pPrinterName );
        break;

    case kPrintTestPage:
        bRetval = bDoPrintTestPage( hwnd, pParams->pPrinterName );
        break;

    case kPrinterGetSettings:
        bRetval = bDoGetPrintSettings( pParams );
        break;

    case kPrinterSetSettings:
        bRetval = bDoSetPrintSettings( pParams );
        break;

    case kPrinterPersist:
        bRetval = bDoPersistPrinterSettings( kPrinterPersist , pParams );
        break;

    case kPrinterRestore:
        bRetval = bDoPersistPrinterSettings( kPrinterRestore , pParams );
        break;

    case kCommandHelp:
        vUsage( pParams );
        break;

    case kUnknown:
    default:
        bRetval = TRUE;
        break;
    }

    //
    // Some of the functions do not setup pParams->dwLastError,
    // so we must rely on the GetLastError() in this case.
    //
    if( !bRetval && ERROR_SUCCESS == pParams->dwLastError )
    {
        pParams->dwLastError = GetLastError();
    }

    return bRetval;
}

/*++

Routine Name:

    vUsage

Routine Description:

    Display a usage message for the rundll switches.

Arguments:

    Nothing.

Return Value:

    None.

--*/
VOID
vUsage(
    IN AParams *pParams
    )
{
    TStatusB bStatus;
    TString strTemp;

    if (!pParams->Flags.IsQuiet)
    {
        TRunDllDisplay Usage( NULL );

        if (VALID_OBJ( Usage ))
        {
#ifdef COMMAND_SPECIFIC_HELP
            if( pParams->ac )
            {
                for( UINT i = 0; i < pParams->ac; i++ )
                {
                    bStatus DBGCHK = Usage.WriteOut( pParams->av[i] );
                    bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n") );
                }
            }
            else
#endif
            {
                //
                // Note we do not check the return values of the string operations
                // because bombing out is just as bad as printing an empty string.  The
                // string class will prevent us from ever crashing.
                //
                bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_RUNDLL_TITLE );
                bStatus DBGCHK = Usage.SetTitle( strTemp );
                bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_RUNDLL_USAGE );
                bStatus DBGCHK = Usage.WriteOut( strTemp );

                for( UINT i = IDS_RUNDLL_OPTION0; i <= IDS_RUNDLL_OPTION_END; i++ )
                {
                    bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n   ") );
                    bStatus DBGCHK = strTemp.bLoadString( ghInst, i );
                    bStatus DBGCHK = Usage.WriteOut( strTemp );
                }

                bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n\r\n") );
                bStatus DBGCHK = strTemp.bLoadString( ghInst,IDS_RUNDLL_EXAMPLE0 );
                bStatus DBGCHK = Usage.WriteOut( strTemp );

                for( i = IDS_RUNDLL_EXAMPLE1; i <= IDS_RUNDLL_EXAMPLE_END; i++ )
                {
                    bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n   ") );
                    bStatus DBGCHK = strTemp.bLoadString( ghInst, i );
                    bStatus DBGCHK = Usage.WriteOut( strTemp );
                }
            }
            Usage.bDoModal();
        }
    }
}


/*++

Routine Name:

    bDoPersistPrinterSettings

Routine Description:

    Store printer settings into file
    Calls Re/StorePrinterSettings with args :
        pParams->pPrinterName, pParams->pBinFileName and flags builded upon pParams->av
        if pParams->ac == 0 , all setttings will be stored/restored

    For restoring settings PRINTER_ALL_ACCESS required for specified printer

Arguments:

    iFunction   specify what function should be called ( Store/RestorePrinterSettings )
    AParams*    ptr to AParam structure

Return Value:

    TRUE if Re/StorePrinterSettings SUCCEEDED.
    FALSE otherwise

--*/
BOOL
bDoPersistPrinterSettings(
    IN  INT     iFunction,
    IN  AParams *pParams
    )
{
    DWORD    dwFlags = 0;
    UINT     idx;
    UINT     ParamIdx;
    UINT     OptionIdx;
    HRESULT  hr;

    struct ParamEntry
    {
        TCHAR   Option;
        DWORD   Flag;

    };

    static ParamEntry PrintSettings_ParamTable [] = {
    {TEXT('2'),           PRST_PRINTER_INFO_2},
    {TEXT('7'),           PRST_PRINTER_INFO_7},
    {TEXT('c'),           PRST_COLOR_PROF},
    {TEXT('d'),           PRST_PRINTER_DATA},
    {TEXT('s'),           PRST_PRINTER_SEC},
    {TEXT('g'),           PRST_PRINTER_DEVMODE},
    {TEXT('u'),           PRST_USER_DEVMODE},
    {TEXT('r'),           PRST_RESOLVE_NAME},
    {TEXT('f'),           PRST_FORCE_NAME},
    {TEXT('p'),           PRST_RESOLVE_PORT},
    {TEXT('h'),           PRST_RESOLVE_SHARE},
    {TEXT('H'),           PRST_DONT_GENERATE_SHARE},
    {TEXT('m'),           PRST_MINIMUM_SETTINGS},
    {0,                   0},
    };


    // for every entry in table
    for (ParamIdx = 0 ; ParamIdx < pParams->ac; ParamIdx++ )
    {
        //for every option argv
        for (idx = 0; PrintSettings_ParamTable[idx].Option; idx++)
        {
            OptionIdx = 0;

            //for every char in option argv
            while(pParams->av[ParamIdx][OptionIdx])
            {
                if(OptionIdx > 0)
                {
                    hr = E_FAIL;
                    goto End;
                }

                if(PrintSettings_ParamTable[idx].Option == pParams->av[ParamIdx][OptionIdx])
                {
                    // apply flags if in table
                    dwFlags |= PrintSettings_ParamTable[idx].Flag;

                    DBGMSG(DBG_TRACE , ("Char %c\n" , pParams->av[ParamIdx][OptionIdx]));

                }

                OptionIdx++;
            }

        }
    }

    if((dwFlags & PRST_FORCE_NAME) && (dwFlags & PRST_RESOLVE_NAME))
    {
        hr = E_FAIL;
        goto End;
    }

    //
    // if no "printer" flags specified , set flags  to PRST_ALL_SETTINGS
    //
    if(!(dwFlags & PRST_ALL_SETTINGS))
    {
        dwFlags |= PRST_ALL_SETTINGS;
    }


    hr =    (iFunction == kPrinterRestore) ?
            RestorePrinterSettings( pParams->pPrinterName, pParams->pBinFileName, dwFlags)
            :
            StorePrinterSettings( pParams->pPrinterName, pParams->pBinFileName, dwFlags) ;

End:

    return SUCCEEDED(hr);

}


/*++

Routine Name:

    bDoWebPnpPreInstall

Routine Description:

    Do Web Point and Print Pre installation tasks.

Arguments:

    pParams         - pointer to paramter structure.
    pfConnection    - pointer where to return connection status

Return Value:

    TRUE Web Point and Print code was successfull, FALSE error occurred.

--*/
BOOL
bDoWebPnpPreInstall(
    IN      AParams *pParams
    )
{
    TStatusB bStatus;

    //
    // Inform the point and print code pre entry.
    //
    bStatus DBGCHK = SUCCEEDED(Winspool_WebPnpEntry( pParams->pszCmdLine ));

    //
    // If something failed return the last error.
    //
    if( !bStatus )
    {
        pParams->dwLastError = GetLastError();
    }

    return bStatus;
}

/*++

Routine Name:

    bDoInfPrinterInstall

Routine Description:

    Do inf based printer installation.

Arguments:

    pParams         - pointer to paramter structure.

Return Value:

    None.

--*/
BOOL
bDoInfPrinterInstall(
    IN  AParams *pParams
    )
{
    TStatusB bStatus;
    TCHAR szBuffer[kPrinterBufMax];

    //
    // Assume success.
    //
    bStatus DBGNOCHK = TRUE;

    //
    // If we are invoked for a Web Point and Pint install.
    //
    if( bStatus && pParams->Flags.IsWebPointAndPrint )
    {
        //
        // Inform the point and print code pre entry.
        //
        bStatus DBGCHK = bDoWebPnpPreInstall( pParams );
    }

    //
    // If web pnp pre installed succeeded.
    //
    if( bStatus )
    {
        TInfInstall II;
        TParameterBlock PB;

        ZeroMemory( &II, sizeof( II ) );
        ZeroMemory( &PB, sizeof( PB ) );
        ZeroMemory( szBuffer, sizeof( szBuffer ) );

        if( pParams->pBasePrinterName )
        {
            _tcsncpy( szBuffer, pParams->pBasePrinterName, COUNTOF( szBuffer ) );
        }

        II.cbSize               = sizeof( II );
        II.pszServerName        = pParams->pMachineName;
        II.pszInfName           = pParams->pInfFileName;
        II.pszModelName         = pParams->pModelName;
        II.pszPortName          = pParams->pPortName;
        II.pszSourcePath        = pParams->pSourcePath;
        II.pszPrinterNameBuffer = szBuffer;
        II.cchPrinterName       = COUNTOF( szBuffer );

        //
        // If this is a web point and print install then set the flags
        // to indicate that we want to create the masq printer.
        //
        II.dwFlags = 0;
        II.dwFlags |= pParams->Flags.IsWebPointAndPrint ? kPnPInterface_WebPointAndPrint : 0;
        II.dwFlags |= pParams->Flags.IsQuiet ? kPnPInterface_Quiet : 0;
        II.dwFlags |= pParams->Flags.IsNoSharing ? kPnPInterface_NoShare : 0;
        II.dwFlags |= pParams->Flags.IsUseExistingDriver ? kPnpInterface_UseExisting : 0;
        II.dwFlags |= pParams->Flags.IsUnknownDriverPrompt ? kPnpInterface_PromptIfUnknownDriver : 0;
        II.dwFlags |= pParams->Flags.IsHydraSpecific ? kPnpInterface_HydraSpecific : 0;
        II.dwFlags |= pParams->Flags.IsPromptForNeededFiles ? kPnPInterface_PromptIfFileNeeded : 0;
        II.dwFlags |= pParams->Flags.IsShared ? kPnPInterface_Share : 0;
        II.dwFlags |= pParams->Flags.IsDontAutoGenerateName ? kPnPInterface_DontAutoGenerateName : 0;
        II.dwFlags |= pParams->Flags.IsSupressSetupUI ? kPnPInterface_SupressSetupUI : 0;

        PB.pInfInstall          = &II;

        pParams->dwLastError = PnPInterface( kInfInstall, &PB );

        bStatus DBGNOCHK = (pParams->dwLastError == ERROR_SUCCESS);
    }

    //
    // If we succeeded and this is a web point and print event.
    //
    if( bStatus && pParams->Flags.IsWebPointAndPrint )
    {
        //
        // Inform the web point and print code that the printer was
        // installed, they can do ay post processing here.
        //
        bStatus DBGCHK = SUCCEEDED(Winspool_WebPnpPostEntry( FALSE, pParams->pBinFileName, pParams->pPortName, szBuffer ));
    }

    return pParams->dwLastError == ERROR_SUCCESS ? TRUE : FALSE;
}

/*++

Routine Name:

    bDoInfDriverInstall

Routine Description:

    Do inf based printer driver installation.

Arguments:

    pParams         - pointer to paramter structure.

Return Value:

    None.

--*/
BOOL
bDoInfDriverInstall(
    IN  AParams *pParams
    )
{
    TInfDriverInstall   II  = {0};
    TParameterBlock     PB  = {0};

    II.cbSize               = sizeof( II );
    II.pszServerName        = pParams->pMachineName;
    II.pszInfName           = pParams->pInfFileName;
    II.pszModelName         = pParams->pModelName;
    II.pszSourcePath        = pParams->pSourcePath;
    II.pszVersion           = pParams->pVersion;
    II.pszArchitecture      = pParams->pArchitecture;

    II.dwFlags = 0;
    II.dwFlags |= pParams->Flags.IsQuiet ? kPnPInterface_Quiet : 0;
    II.dwFlags |= pParams->Flags.IsWindowsUpdate ? kPnPInterface_WindowsUpdate : 0;
    II.dwFlags |= pParams->Flags.IsUseNonLocalizedStrings ? kPnPInterface_UseNonLocalizedStrings : 0;
    II.dwFlags |= pParams->Flags.IsSupressSetupUI ? kPnPInterface_SupressSetupUI : 0;

    PB.pInfDriverInstall    = &II;

    pParams->dwLastError = PnPInterface( kInfDriverInstall, &PB );

    return pParams->dwLastError == ERROR_SUCCESS;
}

/*++

Routine Name:

    bDoDriverRemoval

Routine Description:

    Do driver delete

Arguments:

    pParams         - pointer to paramter structure.

Return Value:

    None.

--*/
BOOL
bDoDriverRemoval(
    IN  AParams *pParams
    )
{
    TDriverRemoval      II  = {0};
    TParameterBlock     PB  = {0};

    II.cbSize               = sizeof( II );
    II.pszServerName        = pParams->pMachineName;
    II.pszModelName         = pParams->pModelName;
    II.pszVersion           = pParams->pVersion;
    II.pszArchitecture      = pParams->pArchitecture;

    II.dwFlags = 0;
    II.dwFlags |= pParams->Flags.IsUseNonLocalizedStrings ? kPnPInterface_UseNonLocalizedStrings : 0;
    II.dwFlags |= pParams->Flags.IsQuiet ? kPnPInterface_Quiet : 0;
    II.dwFlags |= pParams->Flags.IsSupressSetupUI ? kPnPInterface_SupressSetupUI : 0;

    PB.pDriverRemoval       = &II;

    pParams->dwLastError = PnPInterface( kDriverRemoval, &PB );

    if( ERROR_UNKNOWN_PRINTER_DRIVER == pParams->dwLastError )
    {
        // this error code is used primarily for blocking bad
        // oem drivers so the default message used is pretty 
        // incorrect. remap the message to better one based on 
        // the context
        CMsgBoxCounter::SetMsg(IDS_ERROR_DRIVER_DOESNT_EXISTS);
    }

    return pParams->dwLastError == ERROR_SUCCESS;
}


/********************************************************************

    Setting and Getting printer information methods.

********************************************************************/

static TSelect::SelectionVal PrintSettings_ValueTable [] = {
{IDS_RUNDLL_SET_PAUSE,          PRINTER_CONTROL_PAUSE,              OFFSETOF( PRINTER_INFO_2, Status )},
{IDS_RUNDLL_SET_RESUME,         PRINTER_CONTROL_RESUME,             OFFSETOF( PRINTER_INFO_2, Status )},
{IDS_RUNDLL_SET_PURGE,          PRINTER_CONTROL_PURGE,              OFFSETOF( PRINTER_INFO_2, Status )},
{NULL,                          0,                                  NULL}};

static TSelect::SelectionBit PrintSettings_BitTable [] = {
{IDS_RUNDLL_SET_QUEUED,         PRINTER_ATTRIBUTE_QUEUED,           TSelect::kNop},
{IDS_RUNDLL_SET_DIRECT,         PRINTER_ATTRIBUTE_DIRECT,           TSelect::kNop},
{IDS_RUNDLL_SET_DEFAULT,        PRINTER_ATTRIBUTE_DEFAULT,          TSelect::kNop},
{IDS_RUNDLL_SET_SHARED,         PRINTER_ATTRIBUTE_SHARED,           TSelect::kNop},
{IDS_RUNDLL_SET_HIDDEN,         PRINTER_ATTRIBUTE_HIDDEN,           TSelect::kNop},
{IDS_RUNDLL_SET_NETWORK,        PRINTER_ATTRIBUTE_NETWORK,          TSelect::kNop},
{IDS_RUNDLL_SET_LOCAL,          PRINTER_ATTRIBUTE_LOCAL,            TSelect::kNop},
{IDS_RUNDLL_SET_ENABLEDEVQ,     PRINTER_ATTRIBUTE_ENABLE_DEVQ,      TSelect::kNop},
{IDS_RUNDLL_SET_KEEPPRINTEDJOBS,PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS,  TSelect::kNop},
{IDS_RUNDLL_SET_DOCOMPLETEFIRST,PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST,TSelect::kNop},
{IDS_RUNDLL_SET_WORKOFFLINE,    PRINTER_ATTRIBUTE_WORK_OFFLINE,     TSelect::kNop},
{IDS_RUNDLL_SET_ENABLEBIDI,     PRINTER_ATTRIBUTE_ENABLE_BIDI,      TSelect::kNop},
{IDS_RUNDLL_SET_RAWONLY,        PRINTER_ATTRIBUTE_RAW_ONLY,         TSelect::kNop},
{IDS_RUNDLL_SET_PUBLISHED,      PRINTER_ATTRIBUTE_PUBLISHED,        TSelect::kNop},
{0,                             0,                                  TSelect::kNop}};

static TSelect::Selection PrintSettings_Table [] = {
{IDS_RUNDLL_SET_PRINTERNAME,    TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pPrinterName ) },
{IDS_RUNDLL_SET_SHARENAME,      TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pShareName ) },
{IDS_RUNDLL_SET_PORTNAME,       TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pPortName  ) },
{IDS_RUNDLL_SET_DRIVERNAME,     TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pDriverName ) },
{IDS_RUNDLL_SET_COMMENT,        TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pComment   ) },
{IDS_RUNDLL_SET_LOCATION,       TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pLocation  ) },
{IDS_RUNDLL_SET_SEPFILE,        TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pSepFile   ) },
{IDS_RUNDLL_SET_PRINTPROCESSOR, TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pPrintProcessor )},
{IDS_RUNDLL_SET_DATATYPE,       TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pDatatype  ) },
{IDS_RUNDLL_SET_PARAMETERS,     TSelect::kString,   NULL,                   OFFSETOF( PRINTER_INFO_2, pParameters ) },
{IDS_RUNDLL_SET_ATTRIBUTES,     TSelect::kBitTable, PrintSettings_BitTable, OFFSETOF( PRINTER_INFO_2, Attributes ) },
{IDS_RUNDLL_SET_PRIORITY,       TSelect::kInt,      NULL,                   OFFSETOF( PRINTER_INFO_2, Priority   ) },
{IDS_RUNDLL_SET_DEFAULTPRIORITY,TSelect::kInt,      NULL,                   OFFSETOF( PRINTER_INFO_2, DefaultPriority ) },
{IDS_RUNDLL_SET_STARTTIME,      TSelect::kInt,      NULL,                   OFFSETOF( PRINTER_INFO_2, StartTime  ) },
{IDS_RUNDLL_SET_UNTILTIME,      TSelect::kInt,      NULL,                   OFFSETOF( PRINTER_INFO_2, UntilTime  ) },
{IDS_RUNDLL_SET_STATUS,         TSelect::kValTable, PrintSettings_ValueTable,OFFSETOF( PRINTER_INFO_2, Status  ) },
{NULL,                          TSelect::kNone,     NULL,                   NULL }};

/*++

Routine Name:

    bDoGetPrintSettings

Routine Description:

    Get the specified printer settings.

Arguments:

    pParams         - pointer to paramter structure.

Return Value:

    TRUE success, FALSE error.

--*/

BOOL
bDoGetPrintSettings(
    IN  AParams *pParams
    )
{
    DBGMSG( DBG_TRACE, ( "bDoGetPrintSettings\n" ) );
    return PrintSettings_DisplayInformation( pParams, PrintSettings_Table );
}

/*++

Routine Name:

    bDoSetPrintSettings

Routine Description:

    Set the specified printer settings.

Arguments:

    pParams         - pointer to paramter structure.

Return Value:

    TRUE success, FALSE error.

--*/
BOOL
bDoSetPrintSettings(
    IN  AParams *pParams
    )
{
    DBGMSG( DBG_TRACE, ( "bDoSetPrintSettings\n" ) );
    DBGMSG( DBG_TRACE, ( "Argument count %d.\n", pParams->ac ) );

    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;
    TSelect Select;
    PRINTER_INFO_2 Info = {0};

    Info.Attributes         = (DWORD)-1;
    Info.Priority           = (DWORD)-1;
    Info.DefaultPriority    = (DWORD)-1;
    Info.StartTime          = (DWORD)-1;
    Info.UntilTime          = (DWORD)-1;
    Info.Status             = (DWORD)-1;

    //
    // Validate command arguments
    //
    if( !PrintSettings_ValidateArguments( pParams ) )
    {
        DBGMSG( DBG_WARN, ( "Argument validation failed.\n" ) );
        return pParams->dwLastError == ERROR_SUCCESS;
    }

    //
    // Lookup the printer setting command.
    //
    for( UINT i = 0; i < pParams->ac; i += 2 )
    {
        if( (i+0 < pParams->ac) && (i+1 < pParams->ac) )
        {
            bStatus DBGCHK = Select.bLookup( PrintSettings_Table, &Info, pParams->av[i], pParams->av[i+1] );

            if( !bStatus )
            {
                DBGMSG( DBG_WARN, ( "Invalid key name found.\n" ) );
                pParams->dwLastError = ERROR_INVALID_PARAMETER;
                break;
            }
        }
        else
        {
            DBGMSG( DBG_WARN, ( "Unmatched key / value pair arguments\n" ) );
            pParams->dwLastError = ERROR_INVALID_PARAMETER;
            bStatus DBGNOCHK = FALSE;
            break;
        }
    }

    //
    // Set the printer data.
    //
    if( bStatus )
    {
        //
        // Set the printer information.
        //
        bStatus DBGCHK = PrintSettings_SetInfo( pParams, Info );

        if( !bStatus )
        {
            DBGMSG( DBG_TRACE, ( "PrintSettings_SetInfo failed with %d\n", pParams->dwLastError ) );
        }
    }

    return bStatus;
}

/*++

Routine Name:

    PrintSettings_ValidateArguments

Routine Description:

    Validate the command line arguments

Arguments:

    pParams         - pointer to paramter structure.

Return Value:

    TRUE success, FALSE error.

--*/
BOOL
PrintSettings_ValidateArguments(
    IN  AParams *pParams
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;
    TString strHelp1;
    TString strHelp2;

    //
    // There must be at least one additional argumet.
    //
    if( !(pParams->ac >= 1) )
    {
        DBGMSG( DBG_WARN, ( "Insufficent number of additional arguments.\n" ) );
        pParams->dwLastError = ERROR_INVALID_PARAMETER;
        return bStatus;
    }

    //
    // If a help command was specified.
    //
    bStatus DBGCHK = strHelp1.bLoadString( ghInst, IDS_RUNDLL_HELP1 );
    bStatus DBGCHK = strHelp2.bLoadString( ghInst, IDS_RUNDLL_HELP2 );
    if( !_tcsicmp( pParams->av[0], strHelp1 ) || !_tcsicmp( pParams->av[0], strHelp2 ) )
    {
        pParams->dwLastError = ERROR_SUCCESS;
        PrintSettings_DisplayHelp( pParams, PrintSettings_Table );
        return FALSE;
    }

    //
    // Success we have validated the arguments.
    //
    bStatus DBGNOCHK = TRUE;

    return bStatus;
}

/*++

Routine Name:

    PrintSettings_SetInfo

Routine Description:

    Set the printer info data.

Arguments:

    Info        - Reference to printer info data.
    pParams     - pointer to paramter structure.

Return Value:

    TRUE success, FALSE error.

--*/

BOOL
PrintSettings_SetInfo(
    IN  AParams                 *pParams,
    IN  PRINTER_INFO_2          &Info
    )
{
    DBGMSG( DBG_TRACE, ( "PrintSettings_SetInfo\n" ) );

    TStatus         Status;
    TStatusB        bStatus;

    bStatus DBGNOCHK = FALSE;

    HANDLE          hPrinter        = NULL;
    PPRINTER_INFO_2 pInfo           = NULL;
    DWORD           cbInfo          = 0;
    DWORD           dwAccess        = 0;
    DWORD           dwOldAttributes = 0;
    DWORD           dwNewAttributes = 0;

    //
    // Open the printer.
    //
    Status DBGCHK = TPrinter::sOpenPrinter( pParams->pPrinterName, &dwAccess, &hPrinter );

    if( Status == ERROR_SUCCESS )
    {
        //
        // Get the printer data.
        //
        bStatus DBGNOCHK = VDataRefresh::bGetPrinter( hPrinter, 2, (PVOID *)&pInfo, (PDWORD)&cbInfo );

        //
        // Merge in any changed fields.
        //
        if( bStatus )
        {
            TSelect Select;

            //
            // Convert the bit table to a value.
            //
            Select.bApplyBitTableToValue( PrintSettings_BitTable, pInfo->Attributes, &Info.Attributes );

            //
            // Publishing and UnPublishing needs to be special cased, since this setting is
            // not done in the printer info 2 structure.  The published bit is a read only
            // attribute in the printer info 2, the publish state is changed using set printer
            // info 7.
            //
            dwOldAttributes = pInfo->Attributes;
            dwNewAttributes = Info.Attributes != -1 ? Info.Attributes : pInfo->Attributes;

            //
            // Copy the changed date into the info sturcture.
            //
            pInfo->pPrinterName     = Info.pPrinterName ? Info.pPrinterName     : pInfo->pPrinterName;
            pInfo->pShareName       = Info.pShareName   ? Info.pShareName       : pInfo->pShareName;
            pInfo->pPortName        = Info.pPortName    ? Info.pPortName        : pInfo->pPortName;
            pInfo->pDriverName      = Info.pDriverName  ? Info.pDriverName      : pInfo->pDriverName;
            pInfo->pComment         = Info.pComment     ? Info.pComment         : pInfo->pComment;
            pInfo->pLocation        = Info.pLocation    ? Info.pLocation        : pInfo->pLocation;
            pInfo->pSepFile         = Info.pSepFile     ? Info.pSepFile         : pInfo->pSepFile;
            pInfo->pDatatype        = Info.pDatatype    ? Info.pDatatype        : pInfo->pDatatype;
            pInfo->pParameters      = Info.pParameters  ? Info.pParameters      : pInfo->pParameters;

            pInfo->Attributes       = Info.Attributes       != -1   ? Info.Attributes       : pInfo->Attributes;
            pInfo->Priority         = Info.Priority         != -1   ? Info.Priority         : pInfo->Priority;
            pInfo->DefaultPriority  = Info.DefaultPriority  != -1   ? Info.DefaultPriority  : pInfo->DefaultPriority;
            pInfo->StartTime        = Info.StartTime        != -1   ? Info.StartTime        : pInfo->StartTime;
            pInfo->UntilTime        = Info.UntilTime        != -1   ? Info.UntilTime        : pInfo->UntilTime;
        }

        //
        // Set the changed printer data.
        //
        if( bStatus )
        {
            bStatus DBGCHK = SetPrinter( hPrinter, 2, (PBYTE)pInfo, 0 );

            if( bStatus )
            {
                if( Info.Status != -1 )
                {
                    bStatus DBGCHK = SetPrinter( hPrinter, 0, NULL, Info.Status );
                }
            }
        }

        //
        // Handle the printer publishing case.
        //
        if( bStatus )
        {
            //
            // Only do something if the attributes are different.
            //
            if( dwOldAttributes != dwNewAttributes )
            {
                //
                // If the current printer state is not shared and it
                // was previously published then unpublish it now.
                //
                if(!(pInfo->Attributes & PRINTER_ATTRIBUTE_SHARED) &&
                    dwOldAttributes & PRINTER_ATTRIBUTE_PUBLISHED)
                {
                    dwNewAttributes &= ~PRINTER_ATTRIBUTE_PUBLISHED;
                }

                //
                // Only unpublish requests or shared printer publish requests.
                //
                bStatus DBGCHK = !(dwNewAttributes & PRINTER_ATTRIBUTE_PUBLISHED) ||
                                 (dwNewAttributes & PRINTER_ATTRIBUTE_PUBLISHED &&
                                  pInfo->Attributes & PRINTER_ATTRIBUTE_SHARED);

                if(bStatus)
                {
                    PRINTER_INFO_7 Info7 = {0};

                    Info7.dwAction = (dwNewAttributes & PRINTER_ATTRIBUTE_PUBLISHED)
                                     ? DSPRINT_PUBLISH : DSPRINT_UNPUBLISH;

                    bStatus DBGCHK = SetPrinter( hPrinter, 7, (PBYTE)&Info7, 0 );

                    //
                    // Printer info 7 fails with ERROR_IO_PENDING when the publishing is occurring
                    // in the background.  For the rundll32 interface just return success.
                    //
                    if(!bStatus && (GetLastError() == ERROR_IO_PENDING))
                    {
                        SetLastError(ERROR_SUCCESS);
                        bStatus DBGNOCHK = TRUE;
                    }
                }
                else
                {
                    SetLastError(ERROR_INVALID_PARAMETER);
                }
            }
        }

        //
        // Release the printer info data.
        //
        FreeMem( pInfo );

        //
        // Close the printer handle if one was opened.
        //
        if( hPrinter )
        {
            ClosePrinter( hPrinter );
        }
    }

    //
    // If something failed preserve the last error.
    //
    if( !bStatus )
    {
        pParams->dwLastError = GetLastError();
    }

    return bStatus;
}

/*++

Routine Name:

    PrintSettings_DisplayHelp

Routine Description:

    Displays the printer settings command arguments.

Arguments:

    pParams     - pointer to paramter structure.
    pSelection  - pointer argument selection table.

Return Value:

    TRUE success, FALSE error.

--*/
BOOL
PrintSettings_DisplayHelp(
    IN  AParams            *pParams,
    IN TSelect::Selection *pSelection
    )
{
    DBGMSG( DBG_TRACE, ( "PrintSettings_DisplayHelp\n" ) );

    TStatusB bStatus;
    TRunDllDisplay Usage( NULL, pParams->pInfFileName, (pParams->pInfFileName && *pParams->pInfFileName) ?
                                                        TRunDllDisplay::kFile : TRunDllDisplay::kEditBox );

    bStatus DBGNOCHK = VALID_OBJ( Usage );

    if( bStatus )
    {
        TString strTemp;
        TString strString;
        TString strInt;
        TString strStart;
        TString strEnd;
        TString strSep;
        TString strFormat;
        TString strBit;
        LPCTSTR pszType;

        //
        // Set the title.
        //
        bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_RUNDLL_SET_ATTRIBUTE_TITLE );
        bStatus DBGCHK = Usage.SetTitle( strTemp );

        //
        // Set the usage example.
        //
        bStatus DBGCHK = strTemp.bLoadString( ghInst, IDS_RUNDLL_SET_ATTRIBUTE_USAGE );
        bStatus DBGCHK = Usage.WriteOut( strTemp );
        bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n") );

        //
        // Load some constant strings.
        //
        bStatus DBGCHK = strString.bLoadString( ghInst, IDS_RUNDLL_STRING );
        bStatus DBGCHK = strInt.bLoadString( ghInst, IDS_RUNDLL_INTEGER );
        bStatus DBGCHK = strStart.bLoadString( ghInst, IDS_RUNDLL_START );
        bStatus DBGCHK = strEnd.bLoadString( ghInst, IDS_RUNDLL_END );
        bStatus DBGCHK = strSep.bLoadString( ghInst, IDS_RUNDLL_SEP );
        bStatus DBGCHK = strFormat.bLoadString( ghInst, IDS_RUNDLL_FORMAT );

        for( ; pSelection->iKeyWord; pSelection++ )
        {
            switch( pSelection->eDataType )
            {
            case TSelect::kInt:
                pszType = strInt;
                break;

            case TSelect::kString:
                pszType = strString;
                break;

            case TSelect::kValTable:
            case TSelect::kBitTable:
                {
                    bStatus DBGCHK = strBit.bUpdate( strStart );
                    TSelect::SelectionBit *pSel = (TSelect::SelectionBit *)pSelection->pTable;
                    for( ; pSel->iKeyWord; pSel++ )
                    {
                        bStatus DBGCHK = strTemp.bLoadString( ghInst, pSel->iKeyWord );
                        bStatus DBGCHK = strBit.bCat( strTemp );
                        if( (pSel+1)->iKeyWord )
                        {
                            bStatus DBGCHK = strBit.bCat( strSep );
                        }
                    }
                    bStatus DBGCHK = strBit.bCat( strEnd );
                    pszType = strBit;
                }
                break;

            default:
                pszType = gszNULL;
                break;
            }

            bStatus DBGCHK = strTemp.bLoadString( ghInst, pSelection->iKeyWord );
            bStatus DBGCHK = strTemp.bFormat( strFormat, (LPCTSTR)strTemp, pszType );
            bStatus DBGCHK = Usage.WriteOut( strTemp );
            bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n") );
        }

        bStatus DBGCHK = strTemp.bLoadString( ghInst,IDS_RUNDLL_EXAMPLE0 );
        bStatus DBGCHK = Usage.WriteOut( strTemp );

        for( UINT i = IDS_RUNDLL_SET_EXAMPLE1; i <= IDS_RUNDLL_SET_EXAMPLE_END; i++ )
        {
            bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n   ") );
            bStatus DBGCHK = strTemp.bLoadString( ghInst, i );
            bStatus DBGCHK = Usage.WriteOut( strTemp );
        }

        bStatus DBGCHK = Usage.bDoModal();
    }

    return bStatus;
}

/*++

Routine Name:

    PrintSettings_DisplayInformation

Routine Description:

    Displays the printer settings

Arguments:

    pParams     - pointer to paramter structure.
    pSelection  - pointer argument selection table.

Return Value:

    TRUE success, FALSE error.

--*/
BOOL
PrintSettings_DisplayInformation(
    IN AParams            *pParams,
    IN TSelect::Selection *pSelection
    )
{
    DBGMSG( DBG_TRACE, ( "PrintSettings_DisplayInformation\n" ) );

    TStatus Status( DBG_WARN );
    TString strTemp;
    TString strKeyword;
    TString strFormat1;
    TString strFormat2;
    TString strTitle;
    TStatusB bStatus;

    bStatus DBGNOCHK            = FALSE;
    DWORD           dwAccess    = 0;
    HANDLE          hPrinter    = NULL;
    PPRINTER_INFO_2 pInfo       = NULL;
    DWORD           cbInfo      = 0;

    //
    // Open the printer.
    //
    Status DBGCHK = TPrinter::sOpenPrinter( pParams->pPrinterName, &dwAccess, &hPrinter );

    if( Status == ERROR_SUCCESS )
    {
        //
        // Get the printer data.
        //
        bStatus DBGNOCHK = VDataRefresh::bGetPrinter( hPrinter, 2, (PVOID *)&pInfo, (PDWORD)&cbInfo );

        if( bStatus )
        {
            //
            // Display the printer data.
            //
            TRunDllDisplay Usage( NULL, pParams->pInfFileName, (pParams->pInfFileName && *pParams->pInfFileName) ?
                                                                TRunDllDisplay::kFile : TRunDllDisplay::kEditBox );

            bStatus DBGNOCHK = VALID_OBJ( Usage );

            if( bStatus )
            {
                Usage.vSetTabStops(64);

                bStatus DBGCHK = strTitle.bLoadString( ghInst, IDS_RUNDLL_DISPLAY_TITLE );
                bStatus DBGCHK = strTitle.bCat( pParams->pPrinterName );
                Usage.SetTitle( strTitle );

                bStatus DBGCHK = strFormat1.bLoadString( ghInst, IDS_RUNDLL_DISPLAY_FORMAT1 );
                bStatus DBGCHK = strFormat2.bLoadString( ghInst, IDS_RUNDLL_DISPLAY_FORMAT2 );

                for( ; pSelection->iKeyWord; pSelection++ )
                {
                    bStatus DBGCHK = strKeyword.bLoadString( ghInst, pSelection->iKeyWord );

                    switch( pSelection->eDataType )
                    {
                    case TSelect::kString:
                        bStatus DBGCHK = strTemp.bFormat( strFormat1, (LPCTSTR)strKeyword, *(LPCTSTR *)((PBYTE)pInfo+pSelection->iOffset) );
                        break;

                    case TSelect::kInt:
                        bStatus DBGCHK = strTemp.bFormat( strFormat2, (LPCTSTR)strKeyword, *(UINT *)((PBYTE)pInfo+pSelection->iOffset) );
                        break;

                    case TSelect::kBitTable:
                        bStatus DBGCHK = PrintSettings_DisplayAttributes( strTemp, pSelection, *(UINT *)((PBYTE)pInfo+pSelection->iOffset) );
                        bStatus DBGCHK = strTemp.bFormat( strFormat1, (LPCTSTR)strKeyword, (LPCTSTR)strTemp );
                        break;

                    case TSelect::kValTable:
                        bStatus DBGCHK = PrintSettings_DisplayStatus( strTemp, pSelection, *(UINT *)((PBYTE)pInfo+pSelection->iOffset) );
                        bStatus DBGCHK = strTemp.bFormat( strFormat1, (LPCTSTR)strKeyword, (LPCTSTR)strTemp );
                        break;

                    default:
                        bStatus DBGCHK = strTemp.bUpdate( NULL );
                        break;
                    }

                    bStatus DBGCHK = Usage.WriteOut( strTemp );
                    bStatus DBGCHK = Usage.WriteOut( TEXT("\r\n") );

                }

                bStatus DBGCHK = Usage.bDoModal();
            }
        }

        //
        // Release the printer info data.
        //
        FreeMem( pInfo );

        //
        // Close the printer handle if one was opened.
        //
        if( hPrinter )
        {
            ClosePrinter( hPrinter );
        }
    }

    return bStatus;
}

/*++

Routine Name:

    PrintSettings_DisplayAttributes

Routine Description:

    Get the current printer attributes in a displayable form.

Arguments:


Return Value:

    TRUE success, FALSE error.

--*/
BOOL
PrintSettings_DisplayAttributes(
    IN TString             &strBit,
    IN TSelect::Selection  *pSelection,
    IN UINT                 uAttributes
    )
{
    DBGMSG( DBG_TRACE, ( "PrintSettings_DisplayAttributes\n" ) );

    TStatusB bStatus;
    TString strStart;
    TString strEnd;
    TString strSep;
    TString strTemp;

    bStatus DBGCHK = strStart.bLoadString( ghInst, IDS_RUNDLL_START );
    bStatus DBGCHK = strEnd.bLoadString( ghInst, IDS_RUNDLL_END );
    bStatus DBGCHK = strSep.bLoadString( ghInst, IDS_RUNDLL_SEP );

    TSelect::SelectionBit *pSel = (TSelect::SelectionBit *)pSelection->pTable;

    bStatus DBGCHK = strBit.bUpdate( strStart );

    for( ; pSel->iKeyWord; pSel++ )
    {
        if( uAttributes & pSel->uBit )
        {
            bStatus DBGCHK = strTemp.bLoadString( ghInst, pSel->iKeyWord );
            bStatus DBGCHK = strBit.bCat( strTemp );
            bStatus DBGCHK = strBit.bCat( strSep );
        }
    }

    bStatus DBGCHK = strBit.bCat( strEnd );

    return TRUE;
}


/*++

Routine Name:

    PrintSettings_DisplayStatus

Routine Description:

    Get the status in a displayable form.

Arguments:


Return Value:

    TRUE success, FALSE error.

--*/
BOOL
PrintSettings_DisplayStatus(
    IN TString             &strVal,
    IN TSelect::Selection  *pSelection,
    IN UINT                 uStatus
    )
{
    DBGMSG( DBG_TRACE, ( "PrintSettings_DisplayStatus\n" ) );

    TStatusB bStatus;
    TString strStart;
    TString strEnd;
    TString strTemp;

    bStatus DBGCHK = strStart.bLoadString( ghInst, IDS_RUNDLL_START );
    bStatus DBGCHK = strEnd.bLoadString( ghInst, IDS_RUNDLL_END );

    TSelect::SelectionVal *pSel = (TSelect::SelectionVal *)pSelection->pTable;

    bStatus DBGCHK = strVal.bUpdate( strStart );

    for( ; pSel->iKeyWord; pSel++ )
    {
        if( uStatus == pSel->uValue )
        {
            bStatus DBGCHK = strTemp.bLoadString( ghInst, pSel->iKeyWord );
            bStatus DBGCHK = strVal.bCat( strTemp );
            break;
        }
    }

    bStatus DBGCHK = strVal.bCat( strEnd );

    return TRUE;
}

/********************************************************************

    RunDll Usage

********************************************************************/

TRunDllDisplay::
TRunDllDisplay(
    IN HWND                     hWnd,
    IN LPCTSTR                  pszFileName,
    IN DisplayType              Display
    ) : _hWnd( hWnd ),
        _bValid( FALSE ),
        _Display( Display ),
        _pFile( NULL ),
        _cxGrip( 0 ),
        _cyGrip( 0 ),
        _hwndGrip( NULL ),
        _cTabStop( 0 ),
        _dwTabStop( 0 )
{
    memset( &_ptLastSize, 0, sizeof(_ptLastSize) );
    memset( &_ptMinTrack, 0, sizeof(_ptMinTrack) );

    switch( _Display )
    {
    case kFile:
        _pFile = new TFile( pszFileName );
        _bValid = VALID_PTR( _pFile );
        break;

    case kEditBox:
        _bValid = TRUE;
        break;

    default:
        SPLASSERT( FALSE );
        _bValid = FALSE;
        break;
    }
}

TRunDllDisplay::
~TRunDllDisplay(
    VOID
    )
{
    if( _hwndGrip )
    {
        DestroyWindow( _hwndGrip );
    }

    delete _pFile;
}

BOOL
TRunDllDisplay::
WriteOut(
    LPCTSTR pszData
    )
{
    SPLASSERT( pszData );
    return _StringOutput.bCat(pszData);
}

BOOL
TRunDllDisplay::
bValid(
    VOID
    )
{
    return _bValid;
}

VOID
TRunDllDisplay::
vSetTabStops(
    IN UINT uTabStop
    )
{
    _cTabStop = 1;
    _dwTabStop = uTabStop;
}


BOOL
TRunDllDisplay::
bDoModal(
    VOID
    )
{
    TStatusB bStatus;

    switch( _Display  )
    {
    case kEditBox:
        bStatus DBGCHK = (BOOL)DialogBoxParam( ghInst,
                                               MAKEINTRESOURCE( DLG_RUNDLL ),
                                               _hWnd,
                                               MGenericDialog::SetupDlgProc,
                                               (LPARAM)this );
        break;

    case kFile:
        bStatus DBGCHK = _pFile->bWrite( _StringOutput );
        break;

    default:
        bStatus DBGNOCHK = FALSE;
        break;
    }

    return bStatus;
}

BOOL
TRunDllDisplay::
SetTitle(
    IN LPCTSTR  pszData
    )
{
   TStatusB bStatus;
   bStatus DBGCHK = _StringTitle.bUpdate(pszData);
   return bStatus;
}

BOOL
TRunDllDisplay::
bSetUI(
    VOID
    )
{
    TStatusB bStatus;

    bStatus DBGCHK = bSetEditText( _hDlg, IDC_RUNDLL_TITLE, _StringTitle );
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_RUNDLL_TEXT, _StringOutput );
    SendDlgItemMessage( _hDlg, IDC_RUNDLL_TEXT, EM_SETMODIFY, TRUE, 0 );

    //
    // Set any applicable tab stops.
    //
    SendDlgItemMessage( _hDlg, IDC_RUNDLL_TEXT, EM_SETTABSTOPS, _cTabStop, (LPARAM)&_dwTabStop );

    //
    //  Set the initial size.
    //
    RECT rect;
    GetWindowRect(_hDlg, &rect);
    _ptLastSize.x = rect.right - rect.left;
    _ptLastSize.y = rect.bottom - rect.top;

    //
    // Save the minimum track information.
    //
    _ptMinTrack.x = rect.right - rect.left;
    _ptMinTrack.y = rect.bottom - rect.top;

    //
    // Create the sizing grip.
    //
    RECT rc;
    GetClientRect(_hDlg, &rc);

    _cxGrip = GetSystemMetrics(SM_CXVSCROLL);
    _cyGrip = GetSystemMetrics(SM_CYHSCROLL);

    _hwndGrip = CreateWindow( TEXT("Scrollbar"),
                              NULL,
                              WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS |
                              WS_CLIPCHILDREN | SBS_BOTTOMALIGN | SBS_SIZEGRIP |
                              SBS_SIZEBOXBOTTOMRIGHTALIGN,
                              rc.right - _cxGrip,
                              rc.bottom - _cyGrip,
                              _cxGrip,
                              _cyGrip,
                              _hDlg,
                              (HMENU)-1,
                              ghInst,
                              NULL );

    if( !_hwndGrip )
    {
        bStatus DBGCHK = FALSE;
    }

    //
    // Set the dialog icon.
    //
    INT cxIcon = GetSystemMetrics(SM_CXICON);
    INT cyIcon = GetSystemMetrics(SM_CYICON);
    HANDLE hIcon;

    if( hIcon = LoadImage( ghInst, MAKEINTRESOURCE(IDI_PRINTER), IMAGE_ICON, cxIcon, cyIcon, 0 ) )
    {
        SendMessage( _hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon );
    }

    //
    // The small icon size is already cached for the queue view.
    //
    if( hIcon = LoadImage( ghInst, MAKEINTRESOURCE(IDI_PRINTER), IMAGE_ICON, gcxSmIcon, gcySmIcon, 0 ) )
    {
        SendMessage( _hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon );
    }

    return bStatus;
}

BOOL
TRunDllDisplay::
bHandle_WM_SIZE(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    INT width   = LOWORD( lParam );
    INT height  = HIWORD( lParam );

    //
    // Get the current window size.
    //
    RECT rect;
    GetWindowRect(_hDlg, &rect);

    //
    //  Calculate the deltas in the x and y positions that we need to move
    //  each of the child controls.
    //
    INT dx = (rect.right - rect.left) - _ptLastSize.x;
    INT dy = (rect.bottom - rect.top) - _ptLastSize.y;

    //
    //  Update the new size.
    //
    _ptLastSize.x = rect.right - rect.left;
    _ptLastSize.y = rect.bottom - rect.top;

    //
    //  Set the sizing grip to the correct location.
    //
    if( _hwndGrip )
    {
        SetWindowPos( _hwndGrip,
                      NULL,
                      width - _cxGrip,
                      height - _cyGrip,
                      _cxGrip,
                      _cyGrip,
                      SWP_NOZORDER | SWP_NOACTIVATE );
    }

    //
    // Move the ok button.
    //
    GetWindowRect(GetDlgItem(_hDlg, IDOK), &rect);

    MapWindowPoints(NULL, _hDlg, (LPPOINT)&rect, 2);

    SetWindowPos(GetDlgItem(_hDlg, IDOK),
                 NULL,
                 rect.left+dx,
                 rect.top+dy,
                 0,
                 0,
                 SWP_NOZORDER|SWP_NOSIZE);

    //
    // Resize the edit control
    //
    GetWindowRect(GetDlgItem(_hDlg, IDC_RUNDLL_TEXT), &rect);

    MapWindowPoints(NULL, _hDlg, (LPPOINT)&rect, 2);

    SetWindowPos(GetDlgItem(_hDlg, IDC_RUNDLL_TEXT),
                 NULL,
                 0,
                 0,
                 (rect.right-rect.left)+dx,
                 (rect.bottom-rect.top)+dy,
                 SWP_NOZORDER|SWP_NOMOVE);

    return FALSE;
}


BOOL
TRunDllDisplay::
bHandle_WM_GETMINMAXINFO(
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL            bRetval = TRUE;
    LPMINMAXINFO    pmmi    = (LPMINMAXINFO)lParam;

    if( ( _ptMinTrack.x != 0 ) || ( _ptMinTrack.y != 0 ) )
    {
        pmmi->ptMinTrackSize = _ptMinTrack;
        bRetval = FALSE;
    }

    return bRetval;
}

BOOL
TRunDllDisplay::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        bSetUI();
        break;

    case WM_SIZE:
        bStatus = bHandle_WM_SIZE( wParam, lParam );
        break;

    case WM_GETMINMAXINFO:
        bStatus = bHandle_WM_GETMINMAXINFO( wParam, lParam );
        break;

    case WM_COMMAND:
        switch ( LOWORD( wParam ) )
        {
        case IDOK:
        case IDCANCEL:
            EndDialog( _hDlg, LOWORD( wParam ) );
            break;

        default:
            bStatus = FALSE;
            break;
        }

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}

/********************************************************************

    Very simple file output class

********************************************************************/

TFile::
TFile(
    IN LPCTSTR      pszFileName,
    IN BOOL         bNoUnicodeByteMark
    ) : _strFileName( pszFileName ),
        _hFile( INVALID_HANDLE_VALUE ),
        _bValid( FALSE )
{
    if( !_strFileName.bEmpty() )
    {
        _hFile = CreateFile( _strFileName,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

        if( _hFile != INVALID_HANDLE_VALUE )
        {
            _bValid = TRUE;
        }

        //
        // If we are built for unicode then write the unicode byte mark.
        //
#ifdef UNICODE
        if( _bValid && !bNoUnicodeByteMark )
        {
            WORD wUnicodeByteMark = kUnicodePrefix;
            _bValid = bWrite( sizeof( wUnicodeByteMark ), reinterpret_cast<LPBYTE>( &wUnicodeByteMark ) );
        }
#endif

    }
}

TFile::
~TFile(
    VOID
    )
{
    if( _hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hFile );
    }
}

BOOL
TFile::
bValid(
    VOID
    )
{
    return _bValid;
}

BOOL
TFile::
bWrite(
    IN      TString &strString,
        OUT UINT    *pBytesWritten OPTIONAL
    )
{
    return bWrite( strString.uLen() * sizeof( TCHAR ),
                   reinterpret_cast<LPBYTE>( const_cast<LPTSTR>( static_cast<LPCTSTR>( strString ) ) ),
                   pBytesWritten );
}

BOOL
TFile::
bWrite(
    IN      UINT     uSize,
    IN      LPBYTE   pData,
        OUT UINT    *pBytesWritten OPTIONAL
    )
{
    DWORD dwWritten;
    TStatusB bStatus;

    bStatus DBGCHK = WriteFile(_hFile,
                               pData,
                               uSize,
                               &dwWritten,
                               NULL );
    if( bStatus )
    {
        if( pBytesWritten )
        {
            *pBytesWritten = dwWritten;
        }

        bStatus DBGCHK = dwWritten == uSize ? TRUE : FALSE;
    }

    return bStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\sepdlg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    F:\nt\private\windows\spooler\printui.pri\sepdlg.cxx

Abstract:

    Separator page dialog.

Author:

    Steve Kiraly (SteveKi)  11/10/95

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "sepdlg.hxx"

/*++

Routine Name:

    TSeparatorPage

Routine Description:

    TSeparatorPage constructor

Arguments:

    hWnd    - Parent window handle
    TString - String or current separator page.

Return Value:

    Nothing.

--*/
TSeparatorPage::
TSeparatorPage(
    IN const HWND hWnd,
    IN const TString &strSeparatorPage,
    IN const BOOL bAdministrator,
    IN const BOOL bLocal
    ) : _hWnd( hWnd ),
        _bAdministrator( bAdministrator ),
        _bValid( FALSE ),
        _bLocal( bLocal )
{
    //
    // Copy the separator page string.
    //
    if( !_strSeparatorPage.bUpdate( strSeparatorPage ) ){
        DBGMSG( DBG_WARN, ( "_strSeparatorPage failed update with %d.\n", GetLastError() ) );
        return;
    }

    _bValid = TRUE;
}

/*++

Routine Name:

    TSeparatorPage

Routine Description:

    TSeparatorPage destructor

Arguments:

    None.

Return Value:

    Nothing.

--*/
TSeparatorPage::
~TSeparatorPage(
    )
{
}

/*++

Routine Name:

    bValid

Routine Description:

    Valid object member function.

Arguments:

    None.

Return Value:

    TRUE valid object constructor successful
    FALSE error during construction.

--*/
BOOL
TSeparatorPage::
bValid(
    VOID
    ) const
{
    return _bValid;
}

/*++

Routine Name:

    bDoModal

Routine Description:

    Create and starts modal execution of this dialog.

Arguments:

    None.

Return Value:

    TRUE Separator page changed.
    FALSE no separator page change, or error occurred.

--*/
BOOL
TSeparatorPage::
bDoModal(
    VOID
    )
{
    //
    // Create a modal dialog.
    //
    return (BOOL)DialogBoxParam( ghInst,
                         MAKEINTRESOURCE( TSeparatorPage::kResourceId ),
                         _hWnd,
                         MGenericDialog::SetupDlgProc,
                         (LPARAM)this );
}

/*++

Routine Name:

    bSetUI

Routine Description:

    Set the data on the user interface.

Arguments:

    None.

Return Value:

    TRUE UI data is set.
    FALSE error setting UI data.

--*/
BOOL
TSeparatorPage::
bSetUI(
    VOID
    )
{
    BOOL bStatus = bSetEditText( _hDlg, IDC_SEPARATOR_PAGE_EDIT, _strSeparatorPage );
    vEnableCtl( _hDlg, IDC_SEPARATOR_PAGE_EDIT,     _bAdministrator );
    vEnableCtl( _hDlg, IDC_SEPARATOR_PAGE_BROWSE,   _bAdministrator );
    vEnableCtl( _hDlg, IDOK,                        _bAdministrator );
    vEnableCtl( _hDlg, IDC_SEPARATOR_PAGE_DESC,     _bAdministrator );
    vEnableCtl( _hDlg, IDC_SEPARATOR_PAGE_TEXT,     _bAdministrator );

    //
    // Browse button disable for remote machines.  Common dialogs
    // cannot look at files on a remote machine.
    //
    if( !_bLocal )
        vEnableCtl( _hDlg, IDC_SEPARATOR_PAGE_BROWSE,   FALSE );

    return bStatus;
}

/*++

Routine Name:

    bReadUI

Routine Description:

    Read the data from the user interface.

Arguments:

    None.

Return Value:

    TRUE UI data read ok.
    FALSE UI data could not be read.

--*/
BOOL
TSeparatorPage::
bReadUI(
    VOID
    )
{
    TStatusB bStatus;

    //
    // If not an administration return with out reading the UI.
    //
    if( !_bAdministrator )
        return FALSE;

    //
    // Ensure the separator file is a valid file or null.
    //
    bStatus DBGCHK = bValidateSeparatorFile();
    if( !bStatus )
        return FALSE;

    //
    // Get the Separator page text.
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_SEPARATOR_PAGE_EDIT, _strSeparatorPage );

    return bStatus;
}


/*++

Routine Name:

    bHandleMesage

Routine Description:

    Dialog message handler.

Arguments:

    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam

Return Value:

    TRUE message was handled.
    FALSE message was not handled.

--*/
BOOL
TSeparatorPage::
bHandleMessage(
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    UNREFERENCED_PARAMETER( lParam );

    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_INITDIALOG:
        bStatus = bSetUI();
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        bStatus = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    case WM_COMMAND:

        switch( GET_WM_COMMAND_ID( wParam, lParam )){

        case IDOK:
            if( !bReadUI() ){
                iMessage( _hDlg,
                          kSeparatorPageTitle,
                          kErrorSeparatorDoesNotExist,
                          MB_OK|MB_ICONSTOP,
                          kMsgNone,
                          NULL );
            } else {
                EndDialog( _hDlg, TRUE );
            }
            bStatus = TRUE;
            break;

        case IDCANCEL:
            EndDialog( _hDlg, FALSE );
            bStatus = TRUE;
            break;

        case IDC_SEPARATOR_PAGE_BROWSE:
            bSelectSeparatorFile();
            bStatus = TRUE;
            break;

        default:
            bStatus = FALSE;
            break;
        }

    default:
        bStatus = FALSE;
        break;

    }

    return bStatus;
}

/*++

Routine Name:

    bSelectSeparatorFile

Routine Description:

    Display file selection dialog to chose a separator file.

Arguments:

    Nothing.

Return Value:

    TRUE separator file was chosen ok.
    FALSE error or canceled separator selection.

--*/
BOOL
TSeparatorPage::
bSelectSeparatorFile(
    VOID
    )
{
    TCHAR szFile[MAX_PATH];
    TCHAR szInitialDirectory[MAX_PATH];
    TCHAR szFileFilter[kStrMax];
    TString strFormat;
    TStatusB bStatus;
    UINT uLen = 0;

    //
    // Define filter string initializer structure.
    //
    struct FilterInitializer {
        UINT Id;
        };
    //
    // Declare filter string initializer structure.
    //
    FilterInitializer aFilterInit [] = {
        IDS_SEPARATOR_PAGE_DESC,    IDS_SEPARATOR_PAGE_EXT,
        IDS_SEPARATOR_PAGE_ALL,     IDS_SEPARATOR_PAGE_ALL_EXT
        };

    //
    // Initialize all the filters
    //
    for( UINT i = 0; i < COUNTOF( aFilterInit ); i++ )
    {
        bStatus DBGCHK = strFormat.bLoadString( ghInst, aFilterInit[i].Id );
        if( bStatus )
        {
            _tcscpy( szFileFilter+uLen, strFormat );
            uLen = uLen + strFormat.uLen() + 1;
        }
    }

    //
    // Null terminate the strings.
    //
    lstrcpy( szFileFilter+uLen, TEXT("") );
    lstrcpy( szFile,            TEXT("") );

    //
    // Get the initial directory.
    //
    if( !GetSystemDirectory( szInitialDirectory, COUNTOF( szInitialDirectory ) ) )
    {
        _tcscpy( szInitialDirectory, TEXT("") );
    }

    //
    // Get the open file dialog title string.
    //
    TString strTitle;
    bStatus DBGCHK = strTitle.bLoadString( ghInst, kSeparatorPageTitle );
    if( !bStatus )
    {
       vShowResourceError( _hDlg );
       return FALSE;
    }


    //
    // Create the open file structure.
    //
    OPENFILENAME OpenFileName;

    OpenFileName.lStructSize       = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner         = _hDlg;
    OpenFileName.hInstance         = ghInst;
    OpenFileName.lpstrFilter       = szFileFilter;
    OpenFileName.lpstrCustomFilter = NULL;
    OpenFileName.nMaxCustFilter    = 0;
    OpenFileName.nFilterIndex      = 1;
    OpenFileName.lpstrFile         = szFile;
    OpenFileName.nMaxFile          = COUNTOF( szFile );
    OpenFileName.lpstrFileTitle    = NULL;
    OpenFileName.nMaxFileTitle     = 0;
    OpenFileName.lpstrInitialDir   = szInitialDirectory;
    OpenFileName.lpstrTitle        = strTitle;
    OpenFileName.nFileOffset       = 0;
    OpenFileName.nFileExtension    = 0;
    OpenFileName.lpstrDefExt       = NULL;
    OpenFileName.lCustData         = 0;
    OpenFileName.Flags             = OFN_PATHMUSTEXIST |
                                    OFN_FILEMUSTEXIST |
                                    OFN_HIDEREADONLY;

    //
    // If success copy back the selected string.
    //
    bStatus DBGNOCHK = GetOpenFileName(&OpenFileName);
    if( bStatus )
    {
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_SEPARATOR_PAGE_EDIT, szFile );
    }

    return bStatus;
}

/*++

Routine Name:

    bValidateSeparatorFile

Routine Description:

    Validate the name specified in the separator file edit box.
    An empty sting is considered a valid separator file, it is defined
    as no separator file.

Arguments:

    Nothing.

Return Value:

    TRUE separator file in edit box is valid.
    FALSE separator file is invalid.

--*/
BOOL
TSeparatorPage::
bValidateSeparatorFile(
    VOID
    )
{

    TStatusB bStatus;
    TString strTempSeparatorFile;

    DBGMSG( DBG_TRACE, ( "bValidSeparatorFile\n" ) );

    //
    // Get separator file from edit box.
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_SEPARATOR_PAGE_EDIT, strTempSeparatorFile );

    //
    // A null string is a valid separator file.
    //
    if( !lstrlen( strTempSeparatorFile ) || ((LPCTSTR)strTempSeparatorFile == NULL) )
        return TRUE;

    //
    // If we are administrating the separator page remotely then do
    // not validate the sparator file name against the local file system.
    //
    if( bStatus && !_bLocal ){
        return TRUE;
    }

    //
    // Check status of reading edit box.
    //
    if( bStatus ){

        //
        // Get the file attributes.
        //
        DWORD dwFileAttributes = GetFileAttributes( strTempSeparatorFile );

        //
        // If file has some attributes.
        //
        if( dwFileAttributes != -1 ){

            //
            // If file has anyone of these attributes then ok and not a directory
            //
            if( dwFileAttributes & ( FILE_ATTRIBUTE_NORMAL |
                                     FILE_ATTRIBUTE_READONLY |
                                     FILE_ATTRIBUTE_ARCHIVE ) ) {

                if( !( dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ){

                    return TRUE;
                }
            }
        }
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\setup.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    setup.cxx

Abstract:

    Holds Install wizard.

Author:

    Albert Ting (AlbertT)  16-Sept-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "time.hxx"
#include "psetup.hxx"
#include "drvsetup.hxx"
#include "instarch.hxx"
#include "portslv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "prtshare.hxx"
#include "dsinterf.hxx"
#include "drvsetup.hxx"
#include "driverif.hxx"
#include "driverlv.hxx"
#include "archlv.hxx"
#include "detect.hxx"
#include "setup.hxx"
#include "portdlg.hxx"
#include "tstpage.hxx"
#include "drvver.hxx"
#include "printui.h"
#include "query.hxx"
#include "asyncdlg.hxx"
#include "addprn.hxx"
#include "persist.hxx"
#include "compinfo.hxx"
#include "physloc.hxx"
#include "findloc.hxx"

/********************************************************************

    Publicly exported functions.

********************************************************************/

BOOL
bPrinterSetupWOW64(
    IN     HWND     hwnd,
    IN     UINT     uAction,
    IN     UINT     cchPrinterName,
    IN OUT LPTSTR   pszPrinterName,
       OUT UINT    *pcchPrinterName,
    IN     LPCTSTR  pszServerName
    )
/*++

Routine Description:

    WOW64 version.

    see bPrinterSetup below.

Arguments:

    see bPrinterSetup below.

Return Value:

--*/
{
    BOOL bRet = FALSE;
    //
    // This function potentially may load the driver UI so we call a private API
    // exported by winspool.drv, which will RPC the call to a special 64 bit surrogate
    // process where the 64 bit driver can be loaded.
    //
    CDllLoader dll(TEXT("winspool.drv"));
    if (dll)
    {
        ptr_PrintUIPrinterSetup pfn =
            (ptr_PrintUIPrinterSetup )dll.GetProcAddress(ord_PrintUIPrinterSetup);

        if (pfn)
        {
            // call into winspool.drv
            bRet = pfn(hwnd, uAction, cchPrinterName, pszPrinterName, pcchPrinterName, pszServerName);
        }
    }
    return bRet;
}

BOOL
bPrinterSetupNative(
    IN     HWND     hwnd,
    IN     UINT     uAction,
    IN     UINT     cchPrinterName,
    IN OUT LPTSTR   pszPrinterName,
       OUT UINT    *pcchPrinterName,
    IN     LPCTSTR  pszServerName
    )
/*++

Routine Description:

    Native version.

    see bPrinterSetup below.

Arguments:

    see bPrinterSetup below.

Return Value:

--*/
{
    //
    // szNull server is the local server.
    //
    if( pszServerName && !pszServerName[0] ){
        pszServerName = NULL;
    }

    switch( uAction ){

    case MSP_NEWPRINTER:
        return bPrinterSetupNew( hwnd, TWizard::kPrinterInstall, cchPrinterName, pszPrinterName, pcchPrinterName, pszServerName, NULL, FALSE );

    case MSP_NEWPRINTER_MODELESS:
        return bPrinterSetupNew( hwnd, TWizard::kPrinterInstallModeless, cchPrinterName, pszPrinterName, pcchPrinterName, pszServerName, NULL, FALSE );

    case MSP_NETPRINTER:
        return bPrinterNetInstall( hwnd, pszPrinterName );

    case MSP_REMOVENETPRINTER:
        return bPrinterNetRemove( hwnd, pszPrinterName, 0 );

    case MSP_REMOVEPRINTER:
        return bRemovePrinter( hwnd, pszPrinterName, pszServerName, 0 );

    case MSP_NEWDRIVER:
        return bDriverSetupNew( hwnd, TWizard::kDriverInstall, cchPrinterName, pszPrinterName, pcchPrinterName, pszServerName, kSkipArchSelection, FALSE );

    case MSP_FINDPRINTER:
        return bFindPrinter( hwnd, pszPrinterName, pcchPrinterName );

    default:
        DBGMSG( DBG_WARN, ( "bPrinterSetup: unknown command %d\n", uAction ));
    }
    return FALSE;
}


BOOL
bPrinterSetup(
    IN     HWND     hwnd,
    IN     UINT     uAction,
    IN     UINT     cchPrinterName,
    IN OUT LPTSTR   pszPrinterName,
       OUT UINT    *pcchPrinterName,
    IN     LPCTSTR  pszServerName
    )
/*++

Routine Description:

    Brings up the install printer wizard.

Arguments:

    hwnd            - Parent window.
    uAction         - Action requested (defined in windows\inc16\msprintx.h)
    cchPrinterName  - Length of pszPrinterName buffer.
    pszPrinterName  - Input setup printer name, Output pointer to new printer name
    pcchPrinterName - New length of pszPrinterName on return.
    pszServerName   - Name of server that printer is on.

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/
{
    BOOL bRet = FALSE;
    if (IsRunningWOW64())
    {
        bRet = bPrinterSetupWOW64(hwnd, uAction, cchPrinterName, pszPrinterName, pcchPrinterName, pszServerName);
    }
    else
    {
        bRet = bPrinterSetupNative(hwnd, uAction, cchPrinterName, pszPrinterName, pcchPrinterName, pszServerName);
    }
    return bRet;
}

DWORD
PnPInterface(
    IN EPnPFunctionCode    Function,
    IN TParameterBlock    *pParameterBlock
    )
/*++

Routine Description:

    PnP interface which ntprint uses to install printers.

Arguments:
    EPnPFunctionCode - Function code.
    TParameterBlock  - Union of structures see printui.h

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/
{
    SPLASSERT( pParameterBlock );

    BOOL    bStatus     = FALSE;
    DWORD   dwLastError = ERROR_SUCCESS;

    switch( Function )
    {

    //
    // Do quiet install of printer a printer.
    //
    case kPrinterInstall:
    {
        TPrinterInstall *pPI = pParameterBlock->pPrinterInstall;
        SPLASSERT( sizeof( TPrinterInstall ) == pPI->cbSize );
        if( pPI->cchPrinterName && pPI->pszPrinterNameBuffer ) *(pPI->pszPrinterNameBuffer) = 0;
        bStatus = bPrinterInstall( pPI->pszServerName,
                                   pPI->pszDriverName,
                                   pPI->pszPortName,
                                   pPI->pszPrinterNameBuffer,
                                   pPI->cchPrinterName,
                                   0,
                                   0,
                                   NULL,
                                   &dwLastError );
        break;
    }

    //
    // Invoke integrated installation wizard.
    //
    case kInstallWizard:
    {
        TInstallWizard *pPIW = pParameterBlock->pInstallWizard;
        SPLASSERT( sizeof( TInstallWizard ) == pPIW->cbSize );
        bStatus = bInstallWizard( pPIW->pszServerName,
                                  pPIW->pData,
                                  &pPIW->pReferenceData,
                                  &dwLastError );
        break;
    }

    //
    // Destroy integrated installation wizard.
    //
    case kDestroyWizardData:
    {
        TDestroyWizard *pPDW = pParameterBlock->pDestroyWizard;
        SPLASSERT( sizeof( TDestroyWizard ) == pPDW->cbSize );
        bStatus = bDestroyWizard( pPDW->pszServerName,
                                  pPDW->pData,
                                  pPDW->pReferenceData,
                                  &dwLastError );
        break;
    }

    //
    // Invoke the Inf printer installation.
    //
    case kInfInstall:
    {
        TInfInstall *pII = pParameterBlock->pInfInstall;
        SPLASSERT( sizeof( TInfInstall ) == pII->cbSize );
        bStatus = bInfInstall( pII->pszServerName,
                               pII->pszInfName,
                               pII->pszModelName,
                               pII->pszPortName,
                               pII->pszPrinterNameBuffer,
                               pII->cchPrinterName,
                               pII->pszSourcePath,
                               pII->dwFlags,
                               0,
                               NULL,
                               NULL,
                               &dwLastError );
        break;
    }

    //
    // Invoke the Advanced Inf printer installation.
    //
    case kAdvInfInstall:
    {
        TAdvInfInstall *pAII = pParameterBlock->pAdvInfInstall;
        SPLASSERT( sizeof( TAdvInfInstall ) == pAII->cbSize );

        bStatus = bInfInstall( pAII->pszServerName,
                               pAII->pszInfName,
                               pAII->pszModelName,
                               pAII->pszPortName,
                               pAII->pszPrinterNameBuffer,
                               pAII->cchPrinterName,
                               pAII->pszSourcePath,
                               pAII->dwFlags,
                               pAII->dwAttributes,
                               pAII->pSecurityDescriptor,
                               &pAII->dwOutFlags,
                               &dwLastError );

        break;
    }

    //
    // Invoke the Inf driver installation.
    //
    case kInfDriverInstall:
    {
        TInfDriverInstall *pII = pParameterBlock->pInfDriverInstall;
        SPLASSERT( sizeof( TInfDriverInstall ) == pII->cbSize );
        bStatus = bInstallPrinterDriver( pII->pszServerName,
                                         pII->pszModelName,
                                         pII->pszArchitecture,
                                         pII->pszVersion,
                                         pII->pszInfName,
                                         pII->pszSourcePath,
                                         pII->dwFlags,
                                         NULL,
                                         &dwLastError );
        break;
    }

    //
    // Invoke the driver removal
    //
    case kDriverRemoval:
    {
        TDriverRemoval *pII = pParameterBlock->pDriverRemoval;
        SPLASSERT( sizeof( TDriverRemoval ) == pII->cbSize );
        bStatus = bRemovePrinterDriver( pII->pszServerName,
                                        pII->pszModelName,
                                        pII->pszArchitecture,
                                        pII->pszVersion,
                                        pII->dwFlags,
                                        &dwLastError );
        break;
    }

    default:
        DBGMSG( DBG_WARN, ( "PnPInterface: unknown function %d\n", Function ) );
        break;
    }

    //
    // If something failed and the last error is not set then set the
    // last error to a general failure.
    //
    if( !bStatus )
    {
        if( dwLastError == ERROR_SUCCESS )
        {
            dwLastError = ERROR_INVALID_PARAMETER;
        }
    }

    DBGMSG( DBG_WARN, ( "PnPInterface: return value %d\n", dwLastError ) );

    //
    // The caller expects the last error to be valid after this call.
    //
    return dwLastError;
}


BOOL
bPrinterInstall(
    IN     LPCTSTR  pszServerName,
    IN     LPCTSTR  pszDriverName,
    IN     LPCTSTR  pszPortName,
    IN OUT LPTSTR   pszPrinterNameBuffer,
    IN     UINT     cchPrinterName,
    IN     DWORD    dwFlags,
    IN     DWORD    dwAttributes,
    IN     PSECURITY_DESCRIPTOR    pSecurityDescriptor,
       OUT PDWORD   pdwError
    )
/*++

Routine Description:

    Called by plug and play manager to install a printer.
    The driver is assumed to already be installed for this printer.

Arguments:
    pszServerName           - Server where to install printer,
                            - Currently NULL == local machine is supported.
    pszDriverName           - Pointer to printer driver name.
    pszPortName             - Name of port to install.
    pszPrinterNameBuffer    - Buffer where to return fully installed printer name.
    cchPrinterName          - Size of printer name buffer

Return Value:

    TRUE - Success, FALSE = Failure.

Notes:

--*/
{
    DBGMSG( DBG_TRACE, ( "ServerName           " TSTR "\n", DBGSTR( pszServerName ) ) );
    DBGMSG( DBG_TRACE, ( "DriverName           " TSTR "\n", DBGSTR( pszDriverName ) ) );
    DBGMSG( DBG_TRACE, ( "PortName             " TSTR "\n", DBGSTR( pszPortName ) ) );
    DBGMSG( DBG_TRACE, ( "pszPrinterNameBuffer " TSTR "\n", DBGSTR( pszPrinterNameBuffer ) ) );
    DBGMSG( DBG_TRACE, ( "cchPrinterName       %d\n", cchPrinterName ) );

    SPLASSERT( pszDriverName );
    SPLASSERT( pszPortName );
    SPLASSERT( pdwError );

    TStatusB bStatus;
    TCHAR szPrinterBase[kPrinterBufMax];
    TCHAR szPrinterName[kPrinterBufMax];
    WORD wInstance = 0;
    UINT uRetryCount = 0;

    //
    // If the provided printer buffer name contains a name then use
    // it as the base printer name, otherwise use the driver name.
    //
    szPrinterBase[0] = 0;
    szPrinterName[0] = 0;
    if( pszPrinterNameBuffer && *pszPrinterNameBuffer )
    {
        lstrcpyn(szPrinterBase, pszPrinterNameBuffer, ARRAYSIZE(szPrinterBase));
        lstrcpyn(szPrinterName, pszPrinterNameBuffer, ARRAYSIZE(szPrinterName));
    }
    else
    {
        if( pszDriverName && *pszDriverName )
        {
            lstrcpyn(szPrinterBase, pszDriverName, ARRAYSIZE(szPrinterBase));
            lstrcpyn(szPrinterName, pszDriverName, ARRAYSIZE(szPrinterName));
        }
    }

    //
    // Check how to handle the case when the printer
    // already exists on the system
    //
    if( !(dwFlags & kPnPInterface_DontAutoGenerateName) )
    {
        //
        // Generate a friendly unique printer name.
        //
        bStatus DBGNOCHK = NewFriendlyName( const_cast<LPTSTR>( pszServerName ),
                                            const_cast<LPTSTR>( szPrinterBase ),
                                            szPrinterName, &wInstance );
    }

    //
    // szNull server is the local server.
    //
    if( pszServerName && !pszServerName[0] )
    {
        pszServerName = NULL;
    }

    //
    // If a printer name buffer was not provided then force the buffer
    // size to a valid value.
    //
    if( !pszPrinterNameBuffer )
    {
        cchPrinterName = kPrinterBufMax;
    }

    //
    // Ensure the provided buffer can hold the entire generated printer name.
    //
    if( cchPrinterName > _tcslen( szPrinterName ) )
    {
        BOOL bSetDefault = FALSE;

        //
        // If a server name was specified, do not try and
        // set the default printer.  The Default printer is a
        // per user setting which can only be applied to the local machine.
        // Check if there is a default printer.
        //
        if( !pszServerName && ( CheckDefaultPrinter( NULL ) == kNoDefault ) )
        {
            DBGMSG( DBG_TRACE, ( "Default Printer does not exist.\n" ) );
            bSetDefault = TRUE;
        }

        //
        // Check if this machine is NTW or NTS.
        //
        CComputerInfo CompInfo( pszServerName );
        BOOL bIsNTServer = CompInfo.GetProductInfo() ? CompInfo.IsRunningNtServer() : FALSE;

        //
        // Set the default sharing and publishing state.
        //
        BOOL bShared    = bIsNTServer ? TRUE : kDefaultShareState;
        BOOL bPublish   = kDefaultPublishState;

        //
        // Read the bits from the policy location.
        //
        TPersist PersistPolicy( gszAddPrinterWizardPolicy, TPersist::kOpen|TPersist::kRead );

        if( VALID_OBJ( PersistPolicy ) )
        {
            bStatus DBGNOCHK = PersistPolicy.bRead( gszAPWSharing, bShared );
        }

        //
        // Read the bits from the policy location from hkey local machine.
        //
        TPersist PersistPolicy2( gszAddPrinterWizardPolicy, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

        if( VALID_OBJ( PersistPolicy2 ) )
        {
            bStatus DBGNOCHK = PersistPolicy2.bRead( gszAPWPublish, bPublish );
        }

        //
        // If we are specificlay told not to share this device.  This
        // was requested by the fax installation code, because the workstation
        // service may not have been stated yet.  Also it has been mentioned
        // that in the next release of the fax code they may prevent all
        // fax sharing.
        //
        if( dwFlags & kPnPInterface_NoShare )
        {
            bShared = FALSE;
        }

        //
        // If the caller is forcing sharing.
        //
        if( dwFlags & kPnPInterface_Share )
        {
            bShared = TRUE;
        }

        //
        // Read the per machine policy bit that the spooler uses for
        // printer publishing.  The per user policy and the per machine policy
        // must agree inorder for the wizard to publish the printer.
        //
        TPersist SpoolerPolicy( gszSpoolerPolicy, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

        if( VALID_OBJ( SpoolerPolicy ) )
        {
            BOOL bCanPublish = kDefaultPublishState;

            bStatus DBGNOCHK = SpoolerPolicy.bRead( gszSpoolerPublish, bCanPublish );

            if( bStatus )
            {
                bPublish = bPublish && bCanPublish;
            }
        }

        //
        // Check if the Direcotory Services is available.
        //
        TDirectoryService Ds;
        TWizard::EDsStatus eIsDsAvailable;
        eIsDsAvailable = Ds.bIsDsAvailable( pszServerName ) ? TWizard::kDsStatusAvailable : TWizard::kDsStatusUnavailable;

        //
        // Set the printer install flags, using the passed in command line flags.
        //
        TWizard::EAddPrinterAttributes eAddAttributes = ( dwFlags & kPnPInterface_WebPointAndPrint ) ?
                                                        TWizard::kAttributesMasq : TWizard::kAttributesNone;
        for( ;; )
        {
            //
            // Install the printer with defaults.
            //
            bStatus DBGCHK = TWizard::bInstallPrinter( pszServerName,
                                                       szPrinterName,
                                                       gszNULL,
                                                       pszPortName,
                                                       pszDriverName,
                                                       NULL,
                                                       NULL,
                                                       NULL,
                                                       bShared,
                                                       bPublish,
                                                       eAddAttributes,
                                                       eIsDsAvailable,
                                                       dwAttributes,
                                                       pSecurityDescriptor );

            if( !bStatus && ERROR_PRINTER_ALREADY_EXISTS == GetLastError() &&
                uRetryCount < TWizard::kAddPrinterMaxRetry &&
                !(dwFlags & kPnPInterface_DontAutoGenerateName))
            {
                wInstance++;
                uRetryCount++;

                //
                // Generate a friendly unique printer name.
                //
                bStatus DBGNOCHK = NewFriendlyName( const_cast<LPTSTR>( pszServerName ),
                                                    const_cast<LPTSTR>( szPrinterBase ),
                                                    szPrinterName, &wInstance );
                continue;
            }

            if( bStatus )
            {
                //
                // Copy back the printer name if a buffer was provided
                //
                if( pszPrinterNameBuffer )
                {
                    _tcscpy( pszPrinterNameBuffer, szPrinterName );
                }

                //
                // If there are no default printers, make this the default.
                //
                if( bSetDefault )
                {
                    SetDefaultPrinter( szPrinterName );
                }
            }

            //
            // exit the for( ;; ) loop
            //
            break;
        }

    }
    else
    {
        //
        // The buffer was too small to hold the resultant printer name.
        //
        bStatus DBGNOCHK = FALSE;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
    }

    //
    // If an error occurred then preserve the last error.
    // Note: The calling of destructors will modify the last error.
    //
    if( !bStatus )
    {
        *pdwError = GetLastError();
    }

    return bStatus;

}

/********************************************************************

    Private functions.

********************************************************************/

BOOL
bRemovePrinter(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN LPCTSTR  pszServerName,
    IN BOOL     bQuiet
    )
/*++

Routine Description:

    Remove the specified printer on the specified server.

Arguments:

    hwnd            - Parent window.
    pszPrinterName  - Name of printer to remove.

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/
{
    TString strFullPrinterName;
    TStatusB bStatus;

    bStatus DBGCHK = bBuildFullPrinterName( pszServerName, pszPrinterName, strFullPrinterName );

    DWORD dwLastError   = ERROR_SUCCESS;
    HANDLE hPrinter     = NULL;
    PRINTER_DEFAULTS pd;

    pd.pDatatype        = NULL;
    pd.pDevMode         = NULL;
    pd.DesiredAccess    = PRINTER_ALL_ACCESS;

    bStatus DBGCHK = OpenPrinter( (LPTSTR)(LPCTSTR)strFullPrinterName, &hPrinter, &pd );

    if( bStatus ){

        //
        // Delete the printer.
        //
        bStatus DBGCHK = DeletePrinter( hPrinter );

        //
        // Preserve the last error because close printer is
        // setting the last error to ERROR_SUCCESS
        //
        if( !bStatus )
        {
            dwLastError = GetLastError();
        }
        else
        {
            //
            // Printer removed, clean up any queue view informaiton.
            //
            TQueue::vRemove( pszPrinterName );
        }

        //
        // Close the open printer handle.
        //
        if( hPrinter ){
            TStatusB bStatusClosePrinter;
            bStatusClosePrinter DBGCHK = ClosePrinter( hPrinter );
        }
    }

    //
    // If we cannot open or delete the printer inform the user.
    //
    if( !bStatus ){

        //
        // Set the last error if it is not error success.
        //
        if( dwLastError != ERROR_SUCCESS )
        {
            SetLastError( dwLastError );
        }

        DBGMSG( DBG_WARN, ( "bPrinterSetup: Unable to delete printer "TSTR": %d\n", DBGSTR( pszPrinterName ), GetLastError( )));

        if( !bQuiet )
        {
            iMessage( hwnd,
                      IDS_ERR_REMOVE_PRINTER_TITLE,
                      IDS_ERR_REMOVE_PRINTER,
                      MB_OK|MB_ICONHAND,
                      kMsgGetLastError,
                      NULL );
        }
    }

    return bStatus;
}

BOOL
bPrinterNetInstall(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName
    )
/*++

Routine Description:

    Installs a printer connection on this machine to the
    the specified printer.

Arguments:

    hwnd            - Parent window.
    pszPrinterName  - Name of printer to install a connection to.

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/
{
    TStatusB bStatus;

    //
    // Validate the printer name as possible
    //
    bStatus DBGNOCHK =
        ( NULL != pszPrinterName &&
          lstrlen( pszPrinterName ) > 2 &&
          pszPrinterName[0] == TEXT( '\\' ) &&
          pszPrinterName[1] == TEXT( '\\' )
        );

    if( bStatus ){

        //
        // Async version of add printer connection.
        //
        bStatus DBGNOCHK = PrintUIAddPrinterConnectionUI( hwnd, pszPrinterName );
    }

    if( bStatus ){

        //
        // HACK: The SUR spooler does not handle the default
        // printer, so we are forced to do it here.
        //
        // If there are no default printers, make this the default.
        //
        if( CheckDefaultPrinter( NULL ) == kNoDefault ){

            bStatus DBGCHK = SetDefaultPrinter( NULL );
        }

        bStatus DBGNOCHK = TRUE;

    }

    return bStatus;
}

BOOL
bPrinterNetRemove(
    IN HWND     hwnd,
    IN LPCTSTR  pszPrinterName,
    IN BOOL     bQuiet
    )
/*++

Routine Description:

    Removes a printer connection from this machine.

Arguments:

    hwnd            - Parent window.
    pszPrinterName  - Name of printer to remove connection from.

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/
{
    TStatusB bStatus;

    bStatus DBGCHK = DeletePrinterConnection( const_cast<LPTSTR>( pszPrinterName ) );

    if( !bStatus )
    {
        DBGMSG( DBG_WARN, ( "bPrinterSetup: Unable to Delete Connection "TSTR" %d\n", DBGSTR( pszPrinterName ), GetLastError( )));

        if( !bQuiet )
        {
            iMessage( hwnd,
                      IDS_ERR_REMOVE_PRINTER_TITLE,
                      IDS_ERR_REMOVE_PRINTER_CONNECTION,
                      MB_OK|MB_ICONHAND,
                      kMsgGetLastError,
                      NULL );
        }
    }
    else
    {
        //
        // Printer connection removed, clean up any queue view informaiton.
        //
        TQueue::vRemove( pszPrinterName );
    }
    return bStatus;
}

BOOL
bPrinterSetupNew(
    IN     HWND     hwnd,
    IN     UINT     uAction,
    IN     UINT     cchPrinterName,
    IN OUT LPTSTR   pszPrinterName,
       OUT UINT*    pcchPrinterName,
    IN     LPCTSTR  pszServerName,
    IN     LPCTSTR  pszInfFileName,
    IN     BOOL     bRestartableFromLastPage
    )

/*++

Routine Description:

    Brings up the install printer wizard.

Arguments:

    hwnd            - Parent window.
    uAction         - Action requested (defined in windows\inc16\msprintx.h)
    cchPrinterName  - Length of pszPrinterName buffer.
    pszPrinterName  - Input setup printer name, Output pointer to new printer name
    pcchPrinterName - New length of pszPrinterName on return.
    pszServerName   - Name of server that printer is on.

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/
{
    DBGMSG( DBG_TRACE, ( "bPrinterSetupNew\n" ) );

    TStatusB bStatus;

    //
    // Get the current machine name.
    //
    TString strMachineName;
    bStatus DBGCHK = bGetMachineName( strMachineName );

    //
    // If the machine name matches the specified server name
    // adjust the server name pointer to null, which indicates
    // the local machine.
    //
    if( pszServerName &&
        !_tcsicmp( pszServerName, strMachineName ) ){
        pszServerName = NULL;
    }

    //
    // Build a unique name for the singleton window.
    //
    TString strWindowName;
    bStatus DBGCHK = strWindowName.bUpdate( pszServerName );

    //
    // If string is not empty add slash separator.
    //
    if( !strWindowName.bEmpty( ) ){
        bStatus DBGCHK = strWindowName.bCat( gszWack );
    }

    //
    // Concatinate the printer name string.
    //
    bStatus DBGCHK = strWindowName.bCat( pszPrinterName );

    //
    // Check if we are invoked modely.
    //
    BOOL bModal = uAction == TWizard::kPrinterInstall;

    //
    // Create the printer setup data class.
    //
    TPrinterSetupData *pSetupData;
    pSetupData = new TPrinterSetupData( hwnd,
                                        uAction,
                                        cchPrinterName,
                                        pszPrinterName,
                                        pcchPrinterName,
                                        pszServerName,
                                        strWindowName,
                                        pszInfFileName,
                                        bModal,
                                        bRestartableFromLastPage );

    //
    // Check for valid setup data pointer, and valid construction.
    //
    if( VALID_PTR( pSetupData ) ){

        switch ( uAction ){

        case TWizard::kPrinterInstallModeless: {

            //
            // Create the thread which handles a modeless call of the
            // add printer wizard ui.
            //
            DWORD dwIgnore;
            HANDLE hThread;

            hThread = TSafeThread::Create( NULL,
                                           0,
                                           (LPTHREAD_START_ROUTINE)TPrinterSetupData::iPrinterSetupProc,
                                           pSetupData,
                                           0,
                                           &dwIgnore );
            //
            // If the thread could not be created.
            //
            if( !hThread ){

                DBGMSG( DBG_WARN, ( "bPrinterSetupNew thead creation failed.\n" ) );
                delete pSetupData;
                bStatus DBGNOCHK = FALSE;

            //
            // A thread was created then release the thread handle
            // and set the return value.
            //
            } else {

                CloseHandle( hThread );
                bStatus DBGNOCHK = TRUE;
            }
        }
        break;

        case TWizard::kPrinterInstall:

            //
            // Do a modal call of the add printer wizard ui.
            //
            bStatus DBGNOCHK = (BOOL)TPrinterSetupData::iPrinterSetupProc( pSetupData );

            break;

        default:

            DBGMSG( DBG_WARN, ("Invalid add printer option.\n" ) );
            delete pSetupData;
            break;
        }

    //
    // If the pSetupData was allocated but the object faild during construction
    // as indicated by a call to bValid(), we must free the memory.  This code path
    // will be take very often because the constructor of pSetupData checks if
    // another instance of the AddPrinter wizard is currently executing.
    //
    } else {
        DBGMSG( DBG_WARN, ("Add printer is currently running.\n" ) );
        delete pSetupData;
    }

    DBGMSG( DBG_TRACE, ( "bPrinterSetupNew - Returned %d\n", bStatus ) );

    return bStatus;
}

BOOL
bDriverSetupNew(
    IN     HWND     hwnd,
    IN     UINT     uAction,
    IN     UINT     cchDriverName,
    IN OUT LPTSTR   pszDriverName,
       OUT UINT*    pcchDriverName,
    IN     LPCTSTR  pszServerName,
    IN     INT      Flags,
    IN     BOOL     bRestartableFromLastPage
    )

/*++

Routine Description:

    Brings up the install driver wizard.

Arguments:

    hwnd            - Parent window.
    uAction         - Action requested (defined in windows\inc16\msprintx.h)
    cchDriverName   - Length of pszDriverName buffer.
    pszDriverName   - Input setup driver name, Output new driver name
    pcchDriverName  - New length of pszDriverName on return.
    pszServerName   - Name of server that printer is on.

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/
{
    DBGMSG( DBG_TRACE, ( "bDriverSetupNew\n" ) );

    TStatusB bStatus;
    TString strDriverName;
    BOOL bCanceled = FALSE;

    //
    // Copy the passed in printer driver name.
    //
    bStatus DBGCHK = strDriverName.bUpdate( pszDriverName );

    //
    // Install the new printer driver.
    //
    bStatus DBGCHK = bInstallNewPrinterDriver( hwnd,
                                               uAction,
                                               pszServerName,
                                               strDriverName,
                                               NULL,
                                               Flags,
                                               &bCanceled,
                                               bRestartableFromLastPage
                                               );
    if( bStatus )
    {
        //
        // Copy back the installed printer driver name,
        // if a buffer was provided.
        //
        if( pszDriverName &&
            pcchDriverName &&
            cchDriverName > strDriverName.uLen() )
        {
            _tcscpy( pszDriverName, strDriverName );
            *pcchDriverName = strDriverName.uLen();
        }
    }

    //
    // If the wizard was canceled, set the last error.
    //
    if( bCanceled )
    {
        SetLastError( ERROR_CANCELLED );
    }

    return bStatus;

}

BOOL
bInstallNewPrinterDriver(
    IN     HWND             hwnd,
    IN     UINT             uAction,
    IN     LPCTSTR          pszServerName,
    IN OUT TString         &strDriverName,
       OUT TDriverTransfer *pDriverTransfer,
    IN     INT              Flags,
       OUT PBOOL            pbCanceled,
    IN     BOOL             bRestartableFromLastPage,
    IN     PUINT            pnDriverInstallCount
    )
/*++

Routine Description:

    Addes our wizard pages to the set of passed in pages.  The pages
    are only appended to the passed in pages.

Arguments:

    pszServerName   - Name of server that printer is on.
    pWizardData     - Pointer to wizard data structure see setupapi.h

Return Value:

    TRUE = Success, FALSE = FAILURE.

Notes:
    The wizard object is orphaned to the caller if successfull.  It's the
    callers responsibility to clean up if ProperySheets() is not called.
    In the case caller does call PropertySheets() the wizard object will
    be release at or near WM_DESTROY time.

--*/
{

    TStatusB    bStatus;
    bStatus     DBGNOCHK                    = TRUE;
    BOOL        bSkipIntroPageDueToRestart  = FALSE;
    BOOL        bWizardDone                 = FALSE;
    INT         iPosX                       = -1;
    INT         iPosY                       = -1;

    for( ; bStatus && !bWizardDone; )
    {
        //
        // Create the wizard object.
        //
        TWizard Wizard( hwnd, uAction, strDriverName, pszServerName );

        //
        // Validate the wizard object.
        //
        bStatus DBGCHK = VALID_OBJ( Wizard );

        if( bStatus )
        {
            //
            // Set the pointer to the driver transfer data.  This pointer will be use
            // to pass back multiple selected drivers to the caller.
            //
            // Note:  The ? : test with TRUE FALSE assignments is necessary, because the
            //        we test the bXXX flags for equality with TRUE and FALSE in the page
            //        table finite state machine.
            //
            Wizard.pDriverTransfer()          = pDriverTransfer;
            Wizard.bSkipArchSelection()       = Flags & kSkipArchSelection    ? TRUE : FALSE;
            Wizard.bRestartableFromLastPage() = bRestartableFromLastPage;
            Wizard.bRestartAgain()            = bSkipIntroPageDueToRestart;
            Wizard.iPosX()                    = iPosX;
            Wizard.iPosY()                    = iPosY;

            //
            // Display the wizard to the user.
            //
            if( bStatus )
            {
                bStatus DBGCHK = Wizard.bPropPages();
            }

            if( bStatus && Wizard.bShouldRestart() )
            {
                //
                // Second time through the wizard we skip the intro page.
                //
                bSkipIntroPageDueToRestart  = TRUE;
                iPosX                       = Wizard.iPosX();
                iPosY                       = Wizard.iPosY();

                //
                // Restart the wizard to add another printer driver.
                //
                continue;
            }
            else
            {
                bWizardDone = TRUE;

                if( bStatus )
                {
                    (VOID)strDriverName.bUpdate( Wizard.strDriverName() );
                }

                //
                // Check if the dialog was canceled.
                //
                if( pbCanceled )
                {
                    *pbCanceled = Wizard.bWizardCanceled();
                }

                if( pnDriverInstallCount )
                {
                    *pnDriverInstallCount = Wizard.nDriverInstallCount();
                }
            }
        }
    }

    return bStatus;
}

BOOL
GetOrUseInfName(
    IN OUT TString &strInfName
    )
/*++

Routine Description:

    Given a file name and if the name is not empty it will expand
    it to a full file path.  If the name is an empty string, this
    function will return the default system printer inf file name.

Arguments:

    strInfName - reference to inf file name.  On input

Return Value:

    TRUE success, FALSE an error occurred.

--*/
{
    TStatusB bStatus;

    bStatus DBGNOCHK = strInfName.bEmpty();

    //
    // If the inf name was not specified then use the system inf, "ntprint.inf"
    //
    if( bStatus )
    {
        TCHAR szBuff[MAX_PATH];

        bStatus DBGCHK = GetSystemWindowsDirectory( szBuff, COUNTOF( szBuff ) );

        if( bStatus )
        {
           bStatus DBGCHK = strInfName.bUpdate( szBuff );

           if( bStatus )
           {
               bStatus DBGCHK = strInfName.bCat( gszWack )     &&
                                strInfName.bCat( gszInf )      &&
                                strInfName.bCat( gszWack )     &&
                                strInfName.bCat( gszNtPrintInf );
           }
        }
    }
    else
    {
        //
        // The inf name must be fully qualified.
        //
        TCHAR szFullInfName[MAX_PATH];
        LPTSTR pszDummy;
        DWORD dwLength = GetFullPathName( strInfName, COUNTOF( szFullInfName ), szFullInfName, &pszDummy );

        if( dwLength )
        {
            bStatus DBGCHK = strInfName.bUpdate( szFullInfName );
        }
        else
        {
            bStatus DBGCHK = FALSE;
        }
    }

    return bStatus;
}


BOOL
bInstallPrinterDriver(
    IN LPCTSTR                      pszServerName,
    IN LPCTSTR                      pszDriverName,
    IN LPCTSTR                      pszArchitecture,
    IN LPCTSTR                      pszVersion,
    IN LPCTSTR                      pszInfName,
    IN LPCTSTR                      pszSourcePath,
    IN DWORD                        dwFlags,
    IN HWND                         hwnd,
    IN DWORD                       *pdwError
    )
/*++

Routine Description:

    Installs the specified printer driver

Arguments:

    pszServerName   - Name of server that printer is on.
    pWizardData     - Pointer to wizard data structure see setupapi.h

Return Value:

    TRUE = Success, FALSE = FAILURE.

--*/
{
    DBGMSG( DBG_TRACE, ( "bInstallPrinterDriver\n" ) );

    DBGMSG( DBG_TRACE, ( "ServerName        "TSTR"\n", DBGSTR( pszServerName ) ) );
    DBGMSG( DBG_TRACE, ( "DriverName        "TSTR"\n", DBGSTR( pszDriverName ) ) );
    DBGMSG( DBG_TRACE, ( "Architecture      "TSTR"\n", DBGSTR( pszArchitecture ) ) );
    DBGMSG( DBG_TRACE, ( "Version           "TSTR"\n", DBGSTR( pszVersion ) ) );
    DBGMSG( DBG_TRACE, ( "InfName           "TSTR"\n", DBGSTR( pszInfName ) ) );
    DBGMSG( DBG_TRACE, ( "SourcePath        "TSTR"\n", DBGSTR( pszSourcePath ) ) );

    SPLASSERT( pszDriverName );
    SPLASSERT( pdwError );

    // check if we are supposed to suppress the setup warnings UI
    // -- i.e. in super quiet mode.
    if( dwFlags & kPnPInterface_SupressSetupUI )
    {
        SetupSetNonInteractiveMode(TRUE);
    }

    TStatusB    bStatus;
    DWORD       dwEncode        = 0;
    TString     strInfName( pszInfName );

    bStatus DBGNOCHK = TRUE;
    DWORD       dwLastError = ERROR_SUCCESS;

    //
    // Set the last error to a known state.
    //
    SetLastError( ERROR_SUCCESS );

    bStatus DBGCHK = GetOrUseInfName(strInfName);

    if( bStatus )
    {
        TPrinterDriverInstallation  Di( pszServerName );

        bStatus DBGCHK = VALID_OBJ( Di );

        if( bStatus )
        {
            if( pszArchitecture && pszVersion )
            {
                bStatus DBGCHK = TArchLV::bArchAndVersionToEncode(&dwEncode,
                                                                  pszArchitecture,
                                                                  pszVersion,
                                                                  dwFlags & kPnPInterface_UseNonLocalizedStrings);
            }
            else
            {
                //
                // Get this machines current encoding.
                //
                bStatus DBGCHK = Di.bGetCurrentDriverEncode(&dwEncode);
            }
        }

        if( bStatus )
        {
            bStatus DBGCHK = Di.bSetDriverName( pszDriverName )     &&
                             Di.bSetSourcePath( pszSourcePath )     &&
                             Di.bSelectDriverFromInf( strInfName );
            if( bStatus )
            {
                DWORD dwInstallFlags = 0;

                //
                // If the we are in quiet mode.
                //
                if( dwFlags & kPnPInterface_Quiet )
                {
                    dwInstallFlags |= (DRVINST_PROGRESSLESS | DRVINST_PROMPTLESS);
                }

                if( dwFlags & kPnPInterface_WindowsUpdate )
                {
                    dwInstallFlags |= DRVINST_WINDOWS_UPDATE;
                }

                //
                // If the source path was specified then use a flat share.
                //
                if( pszSourcePath )
                {
                    dwInstallFlags |= DRVINST_FLATSHARE;
                }

                //
                // Set the install flags.
                //
                Di.SetInstallFlags( dwInstallFlags );

                //
                // Install the driver.
                //
                bStatus DBGCHK = Di.bInstallDriver(NULL, FALSE, FALSE, NULL, dwEncode );

                //
                // Save the last error here, because the destructor
                // of the TPrinterDriverInstallation will stomp it.
                //
                dwLastError = GetLastError();
            }
        }
    }

    if( !bStatus )
    {
        if( dwLastError == ERROR_SUCCESS )
            dwLastError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwLastError = ERROR_SUCCESS;
    }

    // turn back on the setup warnings UI if necessary
    if( dwFlags & kPnPInterface_SupressSetupUI )
    {
        SetupSetNonInteractiveMode(FALSE);
    }

    SetLastError( dwLastError );
    *pdwError = dwLastError;

    return bStatus;
}

BOOL
bRemovePrinterDriver(
    IN LPCTSTR                      pszServerName,
    IN LPCTSTR                      pszDriverName,
    IN LPCTSTR                      pszArchitecture,
    IN LPCTSTR                      pszVersion,
    IN DWORD                        dwFlags,
    IN DWORD                       *pdwError
    )
/*++

Routine Description:

    Remove the specified printer driver.

Arguments:

    pszServerName   - Name of server that printer is on.

Return Value:

    TRUE = Success, FALSE = FAILURE.

--*/
{
    DBGMSG( DBG_TRACE, ( "TServerDriverNotify::bRemove\n" ) );

    TString strEnv;
    TStatusB bStatus;
    DWORD dwEncode;
    bStatus DBGNOCHK = TRUE;

    if( pszArchitecture && pszVersion )
    {
        //
        // Convert the architecture and version string to a driver encoding.
        //
        bStatus DBGCHK = TArchLV::bArchAndVersionToEncode(&dwEncode,
                                                          pszArchitecture,
                                                          pszVersion,
                                                          dwFlags & kPnPInterface_UseNonLocalizedStrings);
    }
    else
    {
        //
        // get default environment and version
        //
        bStatus DBGCHK = bGetCurrentDriver( pszServerName, &dwEncode );
    }

    if( bStatus )
    {
        bStatus DBGCHK = bGetDriverEnv( dwEncode, strEnv );

        if( bStatus )
        {
            //
            // Delete the specfied printer driver.
            //
            bStatus DBGCHK = DeletePrinterDriverEx( const_cast<LPTSTR>( pszServerName ),
                                                    const_cast<LPTSTR>( static_cast<LPCTSTR>( strEnv ) ),
                                                    const_cast<LPTSTR>( pszDriverName ),
                                                    DPD_DELETE_UNUSED_FILES|DPD_DELETE_SPECIFIC_VERSION,
                                                    GetDriverVersion( dwEncode ) );

            //
            // If we are trying this action on a down level spooler.
            //
            if( !bStatus && GetLastError() == RPC_S_PROCNUM_OUT_OF_RANGE )
            {
                bStatus DBGCHK = DeletePrinterDriver( const_cast<LPTSTR>( pszServerName ),
                                                      const_cast<LPTSTR>( static_cast<LPCTSTR>( strEnv ) ),
                                                      const_cast<LPTSTR>( pszDriverName ) );
            }
        }
        else
        {
            SetLastError( ERROR_BAD_ENVIRONMENT );
        }
    }
    else
    {
        SetLastError( ERROR_BAD_ENVIRONMENT );
    }

    //
    // If an error occurred then preserve the last error.
    // Note: The calling of destructors will modify the last error.
    //
    if( !bStatus )
    {
        *pdwError = GetLastError();
    }

    return bStatus;
}


BOOL
bInstallWizard(
    IN      LPCTSTR                 pszServerName,
    IN OUT  PSP_INSTALLWIZARD_DATA  pWizardData,
    IN OUT  PVOID                  *pReferenceData,
       OUT  PDWORD                  pdwError
    )

/*++

Routine Description:

    Addes our wizard pages to the set of passed in pages.  The pages
    are only appended to the passed in pages.

Arguments:

    pszServerName   - Name of server that printer is on.
    pWizardData     - Pointer to wizard data structure see setupapi.h

Return Value:

    TRUE = Success, FALSE = FAILURE.

Notes:
    The wizard object is orphaned to the caller if successfull.  It's the
    callers responsibility to clean up if ProperySheets() is not called.
    In the case caller does call PropertySheets() the wizard object will
    be release at or near WM_DESTROY time.

--*/

{
    DBGMSG( DBG_TRACE, ( "bInstallWizard\n" ) );

    SPLASSERT( pWizardData );

    DBGMSG( DBG_TRACE, ( "ServerName        "TSTR"\n", DBGSTR( pszServerName ) ) );
    DBGMSG( DBG_TRACE, ( "WizardData         %08x\n", pWizardData ) );
    DBGMSG( DBG_TRACE, ( "RefrenceData       %08x\n", *pReferenceData ) );

    DBGMSG( DBG_TRACE, ( "InstallWizardData:\n" ) );
    DBGMSG( DBG_TRACE, ( "ClassInstallHeader %08x\n", &pWizardData->ClassInstallHeader ) );
    DBGMSG( DBG_TRACE, ( "Flags              %x\n",   pWizardData->Flags ) );
    DBGMSG( DBG_TRACE, ( "DynamicPages       %08x\n", pWizardData->DynamicPages ) );
    DBGMSG( DBG_TRACE, ( "NumDynamicPages    %d\n",   pWizardData->NumDynamicPages ) );
    DBGMSG( DBG_TRACE, ( "DynamicPageFlags   %x\n",   pWizardData->DynamicPageFlags ) );
    DBGMSG( DBG_TRACE, ( "PrivateFlags       %x\n",   pWizardData->PrivateFlags ) );
    DBGMSG( DBG_TRACE, ( "PrivateData        %08x\n", pWizardData->PrivateData ) );
    DBGMSG( DBG_TRACE, ( "hwndWizardDlg      %x\n",   pWizardData->hwndWizardDlg ) );

    TStatusB bReturn;

    //
    // Create the wizard object.
    //
    TWizard *pWizard = new TWizard( pWizardData->hwndWizardDlg, TWizard::kPnPInstall, gszNULL, pszServerName );

    //
    // Check if the wizard was constructed ok.
    //
    if( VALID_PTR( pWizard ))
    {
        //
        // Add our wizard pages to the array of pages.
        //
        bReturn DBGCHK = pWizard->bAddPages( pWizardData );
    }
    else
    {
        bReturn DBGNOCHK = FALSE;
    }

    //
    // If we failed then clean up the wizard object.
    //
    if( !bReturn )
    {
        *pdwError = GetLastError();
        delete pWizard;
        pWizard = NULL;
    }

    //
    // Copy back the reference data.
    //
    *pReferenceData = pWizard;

    DBGMSG( DBG_TRACE, ( "RefrenceData       %08x\n", *pReferenceData ) );

    return bReturn;
}

BOOL
bDestroyWizard(
    IN      LPCTSTR                 pszServerName,
    IN OUT  PSP_INSTALLWIZARD_DATA  pWizardData,
    IN      PVOID                   pReferenceData,
       OUT  PDWORD                  pdwError
    )
/*++

Routine Description:

    Destroys our wizard pages and any associated data that
    was created during a bInstallWizard call.

Arguments:

    pszServerName   - Name of server that printer is on.
    pWizardData     - Pointer to wizard data structure see setupapi.h

Return Value:

    TRUE = Success, FALSE = FAILURE.

Notes:

--*/

{
    DBGMSG( DBG_TRACE, ( "bDestroyWizard\n" ) );

    SPLASSERT( pWizardData );

    DBGMSG( DBG_TRACE, ( "ServerName        "TSTR"\n", DBGSTR( pszServerName ) ) );
    DBGMSG( DBG_TRACE, ( "WizardData         %08x\n", pWizardData ) );
    DBGMSG( DBG_TRACE, ( "RefrenceData       %08x\n", pReferenceData ) );

    TWizard *pWizard = (TWizard *)pReferenceData;

    SPLASSERT( pWizard );

    delete pWizard;

    return TRUE;
}

BOOL
bInfInstall(
    IN      LPCTSTR                 pszServerName,
    IN      LPCTSTR                 pszInfName,
    IN      LPCTSTR                 pszModelName,
    IN      LPCTSTR                 pszPortName,
    IN OUT  LPTSTR                  pszPrinterNameBuffer,
    IN      UINT                    cchPrinterName,
    IN      LPCTSTR                 pszSourcePath,
    IN      DWORD                   dwFlags,
    IN      DWORD                   dwAttributes,
    IN      PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN OUT  PDWORD                  pdwOutFlags,
       OUT  PDWORD                  pdwError
    )
/*++

Routine Description:

    Inf install of a printer.

Arguments:

    pszServerName;              // Machine name NULL equals local machine
    pszInfName;                 // Name of INF file including full path
    pszModelName;               // Model name of printer in inf to install
    pszPortName;                // Port name where to install printer
    pszPrinterNameBuffer;       // Base printer name, Note if a printer exists
                                // with this name a unique name will be
                                // generated ie. "printer (Copy 1)".  This parameter
                                // may contain the null string in which case the printer
                                // name will be auto generated using the model name
                                // as the base name.  This parameter can be null,
                                // and the new name will not be copied back
    cchPrinterName;             // Size of printer name buffer in characters
    pdwOutFlags                 // Flags returned to the caller.

Return Value:

    TRUE = Success, FALSE = FAILURE.

Notes:

--*/

{
    SPLASSERT( pszModelName );
    SPLASSERT( pszPortName );
    SPLASSERT( pszPrinterNameBuffer );
    SPLASSERT( cchPrinterName );
    SPLASSERT( pdwError );

    DBGMSG( DBG_TRACE, ( "pszServerName        " TSTR "\n", DBGSTR( pszServerName ) ) );
    DBGMSG( DBG_TRACE, ( "pszSourcePath        " TSTR "\n", DBGSTR( pszSourcePath ) ) );
    DBGMSG( DBG_TRACE, ( "pszInfName           " TSTR "\n", pszInfName ) );
    DBGMSG( DBG_TRACE, ( "pszModelName         " TSTR "\n", pszModelName ) );
    DBGMSG( DBG_TRACE, ( "pszPortName          " TSTR "\n", pszPortName ) );
    DBGMSG( DBG_TRACE, ( "pszPrinterNameBuffer " TSTR "\n", DBGSTR( pszPrinterNameBuffer ) ) );
    DBGMSG( DBG_TRACE, ( "cchPrinterName       %d\n", cchPrinterName ) );
    DBGMSG( DBG_TRACE, ( "dwFlags              %x\n", dwFlags ) );

    // check if we are supposed to suppress the setup warnings UI
    // -- i.e. in super quiet mode.
    if( dwFlags & kPnPInterface_SupressSetupUI )
    {
        SetupSetNonInteractiveMode(TRUE);
    }

    if (pdwOutFlags)
    {
        *pdwOutFlags = 0;
    }

    TStatusB bStatus;
    TString strDriverName( pszModelName );
    TPrinterDriverInstallation Di( pszServerName, GetDesktopWindow() );
    TCHAR szSourcePath[MAX_PATH];
    DWORD dwDefaultInstallFlags = 0;
    TString strInfName(pszInfName);
    BOOL bOfferReplacementDriver = FALSE;

    //
    // Get a valid inf file name.
    //
    bStatus DBGCHK = GetOrUseInfName(strInfName);

    //
    // If we are doing an install as a result of web point and print
    // we don't want to copy the inf or install driver files.
    //
    if( dwFlags & kPnPInterface_WebPointAndPrint )
    {
        dwDefaultInstallFlags |= (DRVINST_DONOTCOPY_INF | DRVINST_DRIVERFILES_ONLY | DRVINST_WEBPNP);

        //
        // If the source path has not been set then use the current working directory,
        // this is necessary for web point and print because they do not pass use a path,
        // because the uncompression code just runs in the current directory.
        //
        if( !pszSourcePath || !*pszSourcePath)
        {
            if( GetCurrentDirectory( COUNTOF( szSourcePath ), szSourcePath ) )
            {
                pszSourcePath = szSourcePath;
            }
        }

        DBGMSG( DBG_TRACE, ( "Source Path " TSTR "\n", DBGSTR( pszSourcePath ) ) );
    }

    //
    // If we are given a source path we will do a flat share install.
    //
    if( pszSourcePath && *pszSourcePath )
    {
        dwDefaultInstallFlags |= DRVINST_FLATSHARE;
    }

    //
    // If we are supposed to prompt for the CD.
    //
    if( dwFlags & kPnPInterface_PromptForCD )
    {
        dwDefaultInstallFlags &= ~DRVINST_FLATSHARE;
        pszSourcePath = NULL;
    }

    //
    // If we are supposed to suppress the copying progress UI.
    //
    if( dwFlags & kPnPInterface_Quiet )
    {
        dwDefaultInstallFlags |= (DRVINST_PROGRESSLESS | DRVINST_PROMPTLESS);
    }

    //
    // Prompt if files are needed.
    //
    if( dwFlags & kPnPInterface_PromptIfFileNeeded )
    {
        dwDefaultInstallFlags &= ~DRVINST_PROMPTLESS;
    }

    //
    // Set the install flags.
    //
    Di.SetInstallFlags( dwDefaultInstallFlags );

    //
    // Check if the driver installation class is valid,
    // We were able to set the driver name,
    //
    bStatus DBGCHK = bStatus                                    &&
                     VALID_OBJ( strInfName )                    &&
                     VALID_OBJ( Di )                            &&
                     VALID_OBJ( strDriverName )                 &&
                     Di.bSetDriverName( strDriverName )         &&
                     Di.bSetSourcePath( pszSourcePath );

    //
    // If the driver name is an empty string, we treat this as
    // an unknown printer driver.
    //
    if( bStatus )
    {
        bStatus DBGCHK = !strDriverName.bEmpty();

        if( !bStatus )
        {
            SetLastError( ERROR_UNKNOWN_PRINTER_DRIVER );
        }
    }

    //
    // Assume we should install the driver.
    //
    BOOL bInstallDriver = TRUE;

    if( bStatus )
    {
        //
        // If were asked to use the existing driver if it is installed.
        //
        if( dwFlags & kPnpInterface_UseExisting )
        {
            //
            // Check if a compatible printer driver is installed.
            //
            bInstallDriver = !Di.bIsDriverInstalled( TPrinterDriverInstallation::kDefault, TRUE );
        }

        //
        // Driver is not installed or we were asked not to use the existing driver.
        //
        if( bInstallDriver )
        {
            bStatus DBGCHK = Di.bSelectDriverFromInf( strInfName ) &&
                             Di.bInstallDriver(NULL, bOfferReplacementDriver);
        }

    }

    //
    // Prompt the user if the driver is not known, then add the driver failed installation.
    //
    if( !bStatus && GetLastError() == ERROR_UNKNOWN_PRINTER_DRIVER && ( dwFlags & kPnpInterface_PromptIfUnknownDriver ) )
    {
        bStatus DBGCHK = bPromptForUnknownDriver( Di, strDriverName, dwFlags );
    }

    if( bStatus )
    {
        //
        // Install the printer using specified printer driver.
        //
        bStatus DBGCHK = bPrinterInstall( pszServerName,
                                          strDriverName,
                                          pszPortName,
                                          pszPrinterNameBuffer,
                                          cchPrinterName,
                                          dwFlags,
                                          dwAttributes,
                                          pSecurityDescriptor,
                                          pdwError );
    }

    //
    // Preserve the last error.
    //
    *pdwError = bStatus ? ERROR_SUCCESS : GetLastError();

    //
    // Success
    //
    if( bStatus )
    {
        TString strFullPrinterName;
        BOOL    bColor = FALSE;

        //
        // Get the full printer name and check if the printer supports color
        //
        bStatus DBGCHK = bBuildFullPrinterName(pszServerName, pszPrinterNameBuffer, strFullPrinterName) &&
                         SUCCEEDED(IsColorPrinter(strFullPrinterName, &bColor));

        if (bStatus && pdwOutFlags && bColor)
        {
            //
            // Update the flags returned to the caller. TS is interested if the printer installed
            // supports color or not. TS will save ICM color profiles for color printers.
            //
            *pdwOutFlags |= kAdvInf_ColorPrinter;
        }

        //
        // At this point bInstallDriver has the following meaning: TRUE means that the driver
        // was installed in this function before the printer was added. FALSE means that the
        // driver was already present on the machine.
        //
        // If the driver was already installed on the machine and our caller wants us to take
        // care of color profiles, then we check if the printer suports color and we reinstall
        // the driver. By doing so, Di is populated with all the extra information needed by
        // vPrinterAdded(). That function performs things like installing ICM color profiles
        //
        if (bStatus                                      &&
            !bInstallDriver                              &&
            dwFlags & kPnPInterface_InstallColorProfiles &&
            bColor)
        {
            //
            // By reinstalling the driver we get the extra infromation about the
            // ICM color profiles
            //
            bStatus DBGCHK = Di.bSelectDriverFromInf(strInfName) &&
                             Di.bInstallDriver(NULL, bOfferReplacementDriver);

            //
            // We successfully installed the driver. We need to update the bInstallDriver
            // variable so that vPrinterAdded will be called below.
            //
            if (bStatus)
            {
                bInstallDriver = TRUE;
            }
        }

        //
        // Inform the printer class installer that a printer was added.
        // This is need to for vendor installition options that
        // may have been specified in the inf.
        //
        if (bStatus && bInstallDriver)
        {
            Di.vPrinterAdded( strFullPrinterName );
        }

        //
        // Our basic operation of adding the printer succeeded. We will not fail
        // the bInfInstall function call or return an error if the code that does
        // the ICM association and updates other settings happens to fail.
        //
        bStatus DBGNOCHK = TRUE;
    }

    // turn back on the setup warnings UI if necessary
    if( dwFlags & kPnPInterface_SupressSetupUI )
    {
        SetupSetNonInteractiveMode(FALSE);
    }

    return bStatus;
}

BOOL
bPromptForUnknownDriver(
    IN TPrinterDriverInstallation  &Di,
    IN TString                     &strDriverName,
    IN DWORD                       dwFlags
    )
/*++

Routine Description:

    Prompts the user for a printer driver.

Arguments:


Return Value:

    TRUE = Success, FALSE = FAILURE.

Notes:

--*/
{
    TStatusB bStatus;

    //
    // Put up a message telling the user they must select the driver.
    //
    if( iMessage( Di.hGetHwnd(),
                  IDS_ERR_ADD_PRINTER_TITLE,
                  0 == strDriverName.uLen() ? IDS_CONFIRMUNKNOWNDRIVER : IDS_CONFIRMKNOWNDRIVER,
                  MB_OKCANCEL | MB_ICONEXCLAMATION,
                  kMsgNone,
                  NULL,
                  (LPCTSTR)strDriverName ) == IDOK )
    {
        bStatus DBGNOCHK = TRUE;
    }
    else
    {
        bStatus DBGNOCHK = FALSE;
        SetLastError(ERROR_CANCELLED);
    }

    if( bStatus )
    {
        if( dwFlags & kPnpInterface_HydraSpecific )
        {
            //
            // Remove the have disk button.
            //
            Di.bShowOem( FALSE );

            TString strSetupPageTitle, strSetupPageSubTitle, strSetupPageInstructions;

            //
            // Update the title, subtite & description of the setup page
            //
            bStatus DBGCHK = strSetupPageTitle.bLoadString( ghInst, IDS_APW_SETUP_PAGE_TITLE) &&
                             strSetupPageSubTitle.bLoadString( ghInst, IDS_APW_SETUP_PAGE_SUBTITLE) &&
                             strSetupPageInstructions.bLoadString( ghInst, IDS_APW_SETUP_PAGE_INSTRUCT_HYDRA) &&
                             Di.bSetDriverSetupPageTitle( strSetupPageTitle, strSetupPageSubTitle, strSetupPageInstructions );
        }

        if( bStatus )
        {
            //
            // Prompt the user for a driver, since the one we were given was not found.
            //
            bStatus DBGNOCHK = (TPrinterDriverInstallation::EStatusCode::kSuccess == Di.ePromptForDriverSelection());

            if( bStatus )
            {
                //
                // Get the selected driver.
                //
                bStatus DBGCHK = Di.bGetSelectedDriver();

                if( bStatus )
                {
                    //
                    // Get the selected driver name.
                    //
                    bStatus DBGCHK = Di.bGetDriverName( strDriverName );

                    if( bStatus )
                    {
                        //
                        // If the driver the user selected is already installed then do not re-install it.
                        //
                        if( !Di.bIsDriverInstalled() )
                        {
                            //
                            // The driver was not installed then install it now.
                            //
                            BOOL bOfferReplacementDriver = TRUE;
                            bStatus DBGCHK = Di.bInstallDriver(&strDriverName, bOfferReplacementDriver);
                        }
                    }
                }
            }
        }
    }

    return bStatus;
}


/********************************************************************

    TPrinterSetupData class.

********************************************************************/

TPrinterSetupData::
TPrinterSetupData(
    IN     HWND     hwnd,
    IN     UINT     uAction,
    IN     UINT     cchPrinterName,
    IN OUT LPTSTR   pszPrinterName,
       OUT UINT*    pcchPrinterName,
    IN     LPCTSTR  pszServerName,
    IN     LPCTSTR  pszWindowName,
    IN     LPCTSTR  pszInfFileName,
    IN     BOOL     bModal,
    IN     BOOL     bRestartableFromLastPage
    ) : MSingletonWin( pszWindowName, hwnd, bModal ),
        _uAction( uAction ),
        _cchPrinterName( cchPrinterName ),
        _pcchPrinterName( pcchPrinterName ),
        _pszPrinterName( pszPrinterName ),
        _pszServerName( NULL ),
        _strPrinterName( pszPrinterName ),
        _strServerName( pszServerName ),
        _strInfFileName( pszInfFileName ),
        _bValid( FALSE ),
        _bRestartableFromLastPage( bRestartableFromLastPage )
/*++

Routine Description:

    Create the small setup data class for running the add printer
    wizard in a separate thread.

Arguments:

    hwnd - Parent window.

    uAction - Action requested (defined in windows\inc16\msprintx.h)

    cchPrinterName - Length of pszPrinterName buffer.

    pszPrinterName - Input setup printer name, Output pointer to new printer name

    pcchPrinterName - New length of pszPrinterName on return.

    pszServerName - Name of server that printer is on.

    pszWindowName - Name of the sub window for creating the singleton.

Return Value:

    TRUE - Success, FALSE = FAILURE.

Notes:

--*/

{
    DBGMSG( DBG_TRACE, ( "TPinterSetupData::ctor\n" ) );
    DBGMSG( DBG_TRACE, ( "TPinterSetupData::ServerName  " TSTR "\n", (LPCTSTR)_strServerName ) );
    DBGMSG( DBG_TRACE, ( "TPinterSetupData::PrinterName " TSTR "\n", (LPCTSTR)_strPrinterName ) );
    DBGMSG( DBG_TRACE, ( "TPinterSetupData::WindowName  " TSTR "\n", (LPCTSTR)pszWindowName ) );

    //
    // Check for valid singleton window.
    //
    if( MSingletonWin::bValid( ) &&
        _strServerName.bValid( ) &&
        _strPrinterName.bValid( ) &&
        _strInfFileName.bValid( ) ){

        //
        // Since we are starting a separate thread the server name
        // pointer must point to valid storage when the thread is
        // executing.
        //
        if( !_strServerName.bEmpty() ){
            _pszServerName = (LPCTSTR)_strServerName;
        }

        _bValid = TRUE;
    }

}

TPrinterSetupData::
~TPrinterSetupData(
    VOID
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing.

Notes:

--*/

{
    DBGMSG( DBG_TRACE, ( "TPinterSetupData::dtor\n" ) );
}

BOOL
TPrinterSetupData::
bValid(
    VOID
    )
/*++

Routine Description:

    Indicates if the class is valid.

Arguments:

    None

Return Value:

    Nothing.

Notes:

--*/

{
    return _bValid;
}

INT
TPrinterSetupData::
iPrinterSetupProc(
    IN TPrinterSetupData *pSetupData ADOPT
    )

/*++

Routine Description:

    Brings up the install printer wizard.

Arguments:

    pSetupData - pointer to setup data clsss which we adopt.

Return Value:

    TRUE - Success, FALSE = FAILURE.

--*/

{
    DBGMSG( DBG_TRACE, ( "TPrinterSetup::iPrinterSetupProc\n" ) );

    TStatusB bStatus;
    bStatus DBGNOCHK                    = FALSE;
    BOOL    bCancelled                  = FALSE;
    BOOL    bSkipIntroPageDueToRestart  = FALSE;
    BOOL    bWizardDone                 = FALSE;
    INT     iPosX                       = -1;
    INT     iPosY                       = -1;

    //
    // Register the singleton window.
    //
    bStatus DBGCHK = pSetupData->MSingletonWin::bRegisterWindow( PRINTER_PIDL_TYPE_PROPERTIES );

    if( bStatus ){

        //
        // Check if the window is already present.
        //
        if( pSetupData->bIsWindowPresent() ){

            DBGMSG( DBG_TRACE, ( "bPrinterSetup: currently running.\n" ) );
            bStatus DBGNOCHK = FALSE;
        }

    //
    // If registering the singlton window failed.
    //
    } else {

        iMessage( NULL,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_ADD_PRINTER_WINDOW,
                  MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                  kMsgGetLastError,
                  NULL );

    }

    if( bStatus ){

        //
        // Set the correct icon in the alt-tab menu. This is shared icon,
        // (obtained through LoadIcon()), so it doesn't need to be destroyed.
        //
        HICON hIcon = LoadIcon( ghInst, MAKEINTRESOURCE( IDI_PRINTER ) );
        if( hIcon ) {

            SendMessage( pSetupData->hwnd(), WM_SETICON, ICON_BIG,   (LPARAM )hIcon );
        }
    }

    for( ; bStatus && !bWizardDone; ) {

        //
        // Create the wizard object.
        //
        TWizard Wizard( pSetupData->_hwnd,
                        pSetupData->_uAction,
                        pSetupData->_strPrinterName,
                        pSetupData->_pszServerName );

        if( !VALID_OBJ( Wizard )){

            vShowResourceError( pSetupData->_hwnd );
            bStatus DBGNOCHK = FALSE;

        } else {

            //
            // Set the inf file name if one was provided.
            //
            Wizard.strInfFileName().bUpdate( pSetupData->_strInfFileName );
            Wizard.bRestartableFromLastPage() = pSetupData->_bRestartableFromLastPage;
            Wizard.bRestartAgain()            = bSkipIntroPageDueToRestart;
            Wizard.iPosX()                    = iPosX;
            Wizard.iPosY()                    = iPosY;

            //
            // Display the wizard pages.
            //
            bStatus DBGCHK = Wizard.bPropPages();

            if( bStatus && Wizard.bShouldRestart() ) {

                //
                // Second time through the wizard we skip the into page.
                //
                bSkipIntroPageDueToRestart  = TRUE;
                iPosX                       = Wizard.iPosX();
                iPosY                       = Wizard.iPosY();

                continue;

            } else {

                bCancelled = Wizard.bWizardCanceled();
                bWizardDone = TRUE;
            }

            if( bStatus ) {

                //
                // If modal copy back the printer name to the provided buffer.
                //
                if( pSetupData->_uAction == TWizard::kPrinterInstall ){

                    UINT uPrinterNameLength = Wizard.strPrinterName().uLen();

                    //
                    // Check if the provided return buffer is big enough.
                    //
                    if( pSetupData->_cchPrinterName > uPrinterNameLength ){

                        //
                        // Copy the name of the new printer into pszPrintername.
                        //
                        _tcscpy( pSetupData->_pszPrinterName, Wizard.strPrinterName( ));
                        *pSetupData->_pcchPrinterName = uPrinterNameLength;

                    } else {
                        DBGMSG( DBG_WARN, ( "bPrinterSetup: printer "TSTR" too long.\n", (LPCTSTR)Wizard.strPrinterName( )));

                        //
                        // We don't fail the call if the provided buffer is too small since the
                        // printer was created, instead we will clear the printer name length,
                        // maybe this will mean something to the caller.
                        //
                        *pSetupData->_pcchPrinterName = 0;
                    }
                }

            }
        }
    }

    DBGMSG( DBG_TRACE, ( "bPrinterSetup: returned %d.\n", bStatus ) );

    //
    // Release the adopted se-tup data.
    //
    delete pSetupData;

    if( bCancelled )
    {
        SetLastError( ERROR_CANCELLED );
    }

    return bStatus;
}

/********************************************************************

    Page switch controller class (implements IPageSwitch)

********************************************************************/

TPageSwitch::
TPageSwitch(
    TWizard *pWizard
    ): _pWizard( pWizard )
{
}

TPageSwitch::
~TPageSwitch(
    VOID
    )
{
    // do nothing
}

STDMETHODIMP
TPageSwitch::
GetPrevPageID( THIS_ UINT *puPageID )
{
    //
    // Just pop the page ID from the stack
    //
    _pWizard->Stack().bPop( puPageID );

    // OK - allow switching to the prev page
    return S_OK;
}

STDMETHODIMP
TPageSwitch::
GetNextPageID( THIS_ UINT *puPageID )
{
    //
    // Assume don't advance to the next page
    //
    HRESULT hResult = S_FALSE;

    //
    // Check if the connection has been made sucessfully?
    //
    if( _pWizard->bConnected() )
    {
        //
        // Check for any default printer.
        //
        if( !_pWizard->bIsPrinterFolderEmpty() )
        {
            //
            // Always set it as the default.
            //
            _pWizard->bSetDefault() = TRUE;

            //
            // Don't show the set as default UI.
            //
            _pWizard->bShowSetDefault() = FALSE;
        }

        //
        // Save the current page ID
        //
        TStatusB bStatus;
        bStatus DBGCHK = _pWizard->Stack().bPush( _pWizard->nBrowsePageID( ) );

        //
        // Here must determine the next page ID
        //
        if( _pWizard->bShowSetDefault() )
        {
            //
            // Ask the user if he want to change the default
            // printer
            //
            *puPageID = DLG_WIZ_NET;
        }
        else
        {
            //
            // Set the printer as default and go directly to
            // the finish page
            //
            *puPageID = DLG_WIZ_FINISH;
        }

        //
        // OK - allow to advance to the next page
        //
        hResult = S_OK;
    }

    return hResult;
}

STDMETHODIMP
TPageSwitch::
SetPrinterInfo( THIS_ LPCTSTR pszPrinterName, LPCTSTR pszComment, LPCTSTR pszLocation, LPCTSTR pszShareName )
{
    //
    // Indicate a printer connection has been made.
    //
    _pWizard->bConnected() = TRUE;

    //
    // Here must save the printer information for the
    // next page (the info page)
    //
    TStatusB bStatus;
    bStatus DBGCHK = _pWizard->strPrinterName().bUpdate( pszPrinterName );
    bStatus DBGCHK = _pWizard->strComment().bUpdate( pszComment );
    bStatus DBGCHK = _pWizard->strLocation().bUpdate( pszLocation );
    bStatus DBGCHK = _pWizard->strShareName().bUpdate( pszShareName );

    return S_OK;
}

STDMETHODIMP
TPageSwitch::
QueryCancel( THIS_ )
{
    //
    // Allow the cancel operation and
    // close the wizard
    //
    _pWizard->_bWizardCanceled = TRUE;
    return S_FALSE;
}

/********************************************************************

    TWizard.

********************************************************************/

TWizard::
TWizard(
    IN HWND hwnd,
    IN UINT uAction,
    IN LPCTSTR pszPrinterName,
    IN LPCTSTR pszServerName
    ) : _hwnd( hwnd ),
        _uAction( uAction ),
        _strPrinterName( pszPrinterName ),
        _strServerName( pszServerName ),
        _pszServerName( pszServerName ),
        _bPrinterCreated( FALSE ),
        _bErrorSaving( FALSE ),
        _bValid( FALSE ),
        _bSetDefault( TRUE ),
        _bShowSetDefault( TRUE ),
        _bConnected( FALSE ),
        _uDriverExists( kUninitialized ),
        _bDriverChanged( FALSE ),
        _bTestPage( TRUE ),
        _bRefreshPrinterName( FALSE ),
        _bShared( kDefaultShareState ),
        _eIsDsAvailablePerMachine( kDsStatusUnknown ),
        _eIsDsAvailablePerUser( kDsStatusUnknown ),
        _bNetworkInstalled( FALSE ),
        _Di( pszServerName, hwnd ),
        _bUseNewDriver( FALSE ),
        _bUseNewDriverSticky( FALSE ),
        _bNet( FALSE ),
        _bDefaultPrinter( FALSE ),
        _bIsCodeDownLoadAvailable( FALSE ),
        _bUseWeb( FALSE ),
        _Stack( kInitialStackSize ),
        _bNoPageChange( FALSE ),
        _bPreDir( FALSE ),
        _bPostDir( FALSE ),
        _pDriverTransfer( NULL ),
        _bSkipArchSelection( FALSE ),
        _bPersistSettings( TRUE ),
        _LocateType( kSearch ),
        _bPublish( kDefaultPublishState ),
        _dwAdditionalDrivers( 0 ),
        _bAdditionalDrivers( TRUE ),
        _bDownlevelBrowse( TRUE ),
        _bIsNTServer( FALSE ),
        _hBigBoldFont( NULL ),
        _bWizardCanceled( FALSE ),
        _bIsPrinterFolderEmpty( FALSE ),
        _nDriverInstallCount( 0 ),
        _bAdminPrivilege( FALSE ),
        _nBrowsePageID( 0 ),
        _pPageSwitchController( NULL ),
        _bStylePatched( FALSE ),
        _bPrinterAutoDetected( FALSE ),
        _bPnPAutodetect( TRUE ),
        _bRunDetection( FALSE ),
        _COM(FALSE),
        _bRestartableFromLastPage( FALSE ),
        _bRestartAgain( FALSE ),
        _bIsSharingEnabled( FALSE ),
        _iPosX(-1),
        _iPosY(-1)
/*++

Routine Description:

    Create all state information for the printer wizard.

Arguments:

    hwnd - Parent hwnd.

    pszServerName - Server to install printer on; NULL = local.

    pszPrinterName - Return buffer for newly created printer.

    uAction - Action, MSP_NEWPRINTER and MSP_NEWPRINTER_MODELESS.

Return Value:

--*/
{
    DBGMSG( DBG_TRACE, ( "TWizard::ctor\n" ) );

    //
    // Initialize the page array.
    //
    ZeroMemory( _aPages, sizeof( _aPages ) );

    //
    // Get the select device title.
    //
    _strTitle.bLoadString( ghInst, _uAction == kDriverInstall ? IDS_DRIVER_WIZ_TITLE : IDS_ADD_PRINTER_TITLE );

    _strSetupPageTitle.bLoadString( ghInst, _uAction == kDriverInstall ? IDS_APDW_SETUP_PAGE_TITLE : IDS_APW_SETUP_PAGE_TITLE );
    _strSetupPageSubTitle.bLoadString( ghInst,  _uAction == kDriverInstall ? IDS_APDW_SETUP_PAGE_SUBTITLE : IDS_APW_SETUP_PAGE_SUBTITLE );
    _strSetupPageDescription.bLoadString( ghInst, _uAction == kDriverInstall ? IDS_APDW_SETUP_PAGE_INSTRUCT : IDS_APW_SETUP_PAGE_INSTRUCT );
    // _strSetupPageDescription.bLoadString( ghInst, _uAction == kDriverInstall ? IDS_APDW_SETUP_PAGE_INSTRUCT : IDS_APW_SETUP_PAGE_INSTRUCT_HYDRA );

    //
    // setup APIs do not validate the input buffers correctly and just fail if
    // the length is less than MAX_XXX_LEN-1 - this is incorrect. we workaround
    // this bug by bounding the length to MAX_XXX_LEN-1 before calling them.
    // i hope this will get fixed and then i'll fix the code and remove this comment.
    //

    //
    // those limits are defined in setupapi.h and we need to enforse this
    // lengths before calling the setup APIs - otherwise they fail.
    //
    ASSERT(_strSetupPageTitle.uLen() < (MAX_TITLE_LEN-1));
    ASSERT(_strSetupPageSubTitle.uLen() < (MAX_SUBTITLE_LEN-1));
    ASSERT(_strSetupPageDescription.uLen() < (MAX_INSTRUCTION_LEN-1));

    //
    // Since we don't want setup APIs to fail in this case we
    // bound the strings to the requred buffer length.
    //
    _strSetupPageTitle.bLimitBuffer(MAX_TITLE_LEN-1);
    _strSetupPageSubTitle.bLimitBuffer(MAX_SUBTITLE_LEN-1);
    _strSetupPageDescription.bLimitBuffer(MAX_INSTRUCTION_LEN-1);

    //
    // Check if all the aggregate objects are valid.
    //
    if( !VALID_OBJ( _strPrinterName) ||
        !VALID_OBJ( _strServerName ) ||
        !VALID_OBJ( _strTitle )      ||
        !VALID_OBJ( _strSetupPageTitle )      ||
        !VALID_OBJ( _strSetupPageSubTitle )   ||
        !VALID_OBJ( _strSetupPageDescription )||
        !VALID_OBJ( _Ds )            ||
        !VALID_OBJ( _Di ) )
    {
        return;
    }

    // check to see if we have access to the server
    HRESULT hr = ServerAccessCheck(pszServerName, &_bAdminPrivilege);
    if( FAILED(hr) )
    {
        // failed to open the print server - setup the last error.
        SetLastError(SCODE_CODE(GetScode(hr)));
        return;
    }
    else
    {
        if (pszServerName && (FALSE == _bAdminPrivilege))
        {
            // this is not a local server and you don't have full access
            // then the wizard should fail with access denied.
            SetLastError(ERROR_ACCESS_DENIED);
            return;
        }
    }

    //
    // Create the wizard pages.
    //
    if( !bCreatePages() )
    {
        return;
    }

    //
    // Check if the network is installed.
    //
    _bNetworkInstalled = TPrtShare::bNetworkInstalled();

    //
    // Check if this machine is NTW or NTS.
    //
    CComputerInfo CompInfo( _strServerName );
    _bIsNTServer = CompInfo.GetProductInfo() ? CompInfo.IsRunningNtServer() : FALSE;

    //
    // On NT server we want to share printers by default.
    //
    _bShared = _bIsNTServer ? TRUE : kDefaultShareState;

    //
    // On NT server install additional drivers.
    //  0 install the additonal drivers on this machine.
    //  1 do not install additional drivers on this machine.
    //
    // _dwAdditionalDrivers = _bIsNTServer ? 0 : -1;

    //
    // After the drivers went to a CAB file and we removed
    // the cross-platform drivers from the media we will never
    // give the user oportunity to install additional drivers
    // in the APW
    //
    _dwAdditionalDrivers = -1;

    //
    // Check if code download is available, as long as this is a
    // local install.  We do not support code download remotely.
    //
    if( !bIsRemote( _strServerName ) )
    {
        _bIsCodeDownLoadAvailable = _Di.bIsCodeDownLoadAvailable();
    }

    //
    // If we are launched as the add printer driver wizard then
    // do not persist any settings and do not set as default
    // and do not print a test page.
    //
    if( _uAction == kDriverInstall )
    {
        _bPersistSettings   = FALSE;
        _bTestPage          = FALSE;
        _bSetDefault        = FALSE;
        _strDriverName.bUpdate( _strPrinterName );
    }

    //
    // Read the default setting state from the registry.
    //
    vReadRegistrySettingDefaults();

    //
    // If the network is not installed then disable sharing.
    //
    _bShared = _bNetworkInstalled ? _bShared : FALSE;

    //
    // Check if current printer folder is empty. This flag is needed to
    // skip the default printer ui page in the network case.
    //
    _bIsPrinterFolderEmpty = CheckDefaultPrinter( NULL ) != kNoDefault;

    //
    // Setup the big bold fonts for the WIZARD97 style.
    //
    SetupFonts( ghInst, _hwnd, &_hBigBoldFont );

    //
    // Initialize the page switch controller class
    //
    _pPageSwitchController = new TPageSwitch( this );
    if( !_pPageSwitchController )
    {
        return;
    }

    hr = IsSharingEnabled(&_bIsSharingEnabled);
    if( FAILED(hr) )
    {
        // we don't want to fail the wizard rather than simply not allow 
        // sharing (since we don't know if it is enabled).

        _bIsSharingEnabled = FALSE;
    }

    _bValid = TRUE;
}

TWizard::
~TWizard(
    VOID
    )

/*++

Routine Description:

    Destruct and cleanup the printer wizard state data.

    Note: the global static is not deleted; we keep it in memory
    so it will not have to be reparsed.

Arguments:

Return Value:

--*/

{
    DBGMSG( DBG_TRACE, ( "TWizard::dtor\n" ) );

    //
    // Save the default settings in the registry.
    //
    vWriteRegistrySettingDefaults();

    //
    // Release all our created wizard pages.
    //
    UINT uSize = COUNTOF( _aPages );

    while( uSize-- )
    {
        if( _aPages[uSize].pPage )
        {
            DBGMSG( DBG_TRACE, ( "TWizard::dtor deleting page\n" ) );
            delete _aPages[uSize].pPage;
        }
    }

    //
    // Release the bold font handles.
    //
    if( _hBigBoldFont )
    {
        TStatusB bStatus;
        bStatus DBGCHK = DeleteObject( _hBigBoldFont );
    }

    //
    // Destroy the page controller class
    //
    delete _pPageSwitchController;
}

BOOL
TWizard::
bCreatePages(
    VOID
    )
/*++

Routine Description:

    Creates the wizard pages.  Note the order is significant.

Arguments:

    None

Return Value:

    TRUE - success, FALSE - error.

--*/
{
    UINT iIndex = 0;

    if( _uAction == kDriverInstall )
    {
        if( !bInsertPage( iIndex, new TWizDriverIntro( this ),      DLG_WIZ_DRIVER_INTRO )                                            ||
            !bInsertPage( iIndex, new TWizDriverEnd( this ),        DLG_WIZ_DRIVER_END )                                              ||
            !bInsertPage( iIndex, new TWizPreSelectDriver( this ),  DLG_WIZ_PRE_SELECT_DEVICE )                                       ||
            !bInsertPage( iIndex, NULL,                             static_cast<UINT>( kSelectDriverPage ) )                          ||
            !bInsertPage( iIndex, new TWizPostSelectDriver( this ), DLG_WIZ_POST_SELECT_DEVICE )                                      ||
            !bInsertPage( iIndex, new TWizArchitecture( this ),     DLG_WIZ_DRIVER_ARCHITECTURE, IDS_WIZ_ARCH_TITLE,        IDS_WIZ_ARCH_SUBTITLE ) )
        {
            return FALSE;
        }
    }
    else
    {
        if( !bInsertPage( iIndex, new TWizPreIntro( this ),         DLG_WIZ_PRE_INTRO )                                               ||
            !bInsertPage( iIndex, new TWizIntro( this ),            DLG_WIZ_INTRO )                                                   ||
            !bInsertPage( iIndex, new TWizFinish( this ),           DLG_WIZ_FINISH )                                                  ||
            !bInsertPage( iIndex, new TWizPreSelectDriver( this ),  DLG_WIZ_PRE_SELECT_DEVICE )                                       ||
            !bInsertPage( iIndex, NULL,                             static_cast<UINT>( kSelectDriverPage ) )                          ||
            !bInsertPage( iIndex, new TWizPostSelectDriver( this ), DLG_WIZ_POST_SELECT_DEVICE )                                      ||
            !bInsertPage( iIndex, new TWizPortNew( this ),          DLG_WIZ_PORT_NEW,           IDS_WIZ_PORT_TITLE,         IDS_WIZ_PORT_SUBTITLE )         ||
            !bInsertPage( iIndex, new TWizDriverExists( this ),     DLG_WIZ_DRIVEREXISTS,       IDS_WIZ_DRIVEREXISTS_TITLE, IDS_WIZ_DRIVEREXISTS_SUBTITLE ) ||
            !bInsertPage( iIndex, new TWizName( this ),             DLG_WIZ_NAME,               IDS_WIZ_NAME_TITLE,         IDS_WIZ_NAME_SUBTITLE )         ||
            !bInsertPage( iIndex, new TWizShare( this ),            DLG_WIZ_SHARE,              IDS_WIZ_SHARE_TITLE,        IDS_WIZ_SHARE_SUBTITLE )        ||
            !bInsertPage( iIndex, new TWizComment( this ),          DLG_WIZ_COMMENT,            IDS_WIZ_COMMENT_TITLE,      IDS_WIZ_COMMENT_SUBTITLE )      ||
            !bInsertPage( iIndex, new TWizLocate( this ),           DLG_WIZ_LOCATE,             IDS_WIZ_LOCATE_TITLE,       IDS_WIZ_LOCATE_SUBTITLE )       ||
            !bInsertPage( iIndex, new TWizType( this ),             DLG_WIZ_TYPE,               IDS_WIZ_TYPE_TITLE,         IDS_WIZ_TYPE_SUBTITLE )         ||
            !bInsertPage( iIndex, new TWizDetect( this ),           DLG_WIZ_DETECT,             IDS_WIZ_DETECT_TITLE,       IDS_WIZ_DETECT_SUBTITLE )       ||
            !bInsertPage( iIndex, new TWizNet( this ),              DLG_WIZ_NET,                IDS_WIZ_NET_TITLE,          IDS_WIZ_NET_SUBTITLE )          ||
            !bInsertPage( iIndex, new TWizTestPage( this ),         DLG_WIZ_TEST_PAGE,          IDS_WIZ_TEST_PAGE_TITLE,    IDS_WIZ_TEST_PAGE_SUBTITLE )    ||
            !bInsertPage( iIndex, NULL,                             static_cast<UINT>( kSelectPrinterPage ) ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
TWizard::
bInsertPage(
    IN OUT  UINT        &Index,
    IN      MGenericProp *pWizPage,
    IN      UINT        uDlgId,
    IN      UINT        uTitleId,
    IN      UINT        uSubTitleId
    )
{
    DBGMSG( DBG_TRACE, ( "TWizard::bInsertPage\n" ) );
    BOOL bReturn = TRUE;

    if( Index < kPropMax )
    {

        _aPages[Index].pPage       = pWizPage;
        _aPages[Index].iDialog     = uDlgId;
        _aPages[Index].iTitle      = uTitleId;
        _aPages[Index].iSubTitle   = uSubTitleId;

        Index++;

        if( !pWizPage && !( uDlgId == kSelectDriverPage || uDlgId == kSelectPrinterPage ) )
        {
            bReturn = FALSE;
        }
    }
    else
    {
        //
        // This is code error. It shouldn't happen
        //
        SPLASSERT( Index < kPropMax );
        DBGMSG( DBG_TRACE, ( "TWizard::bInsertPage - Trying to insert more prop pages than kPropMax\n" ) );

        bReturn = FALSE;
    }

    return bReturn;
}

HRESULT
TWizard::
ServerAccessCheck(
    LPCTSTR pszServer,
    BOOL *pbFullAccess
    )
{
    HRESULT hr = E_FAIL;
    if (pbFullAccess)
    {
        CAutoHandlePrinter shServer;
        DWORD dwAccess = SERVER_ALL_ACCESS;

        // Attempt to open the server with Admin access
        TStatus Status;
        Status DBGCHK = TPrinter::sOpenPrinter(pszServer, &dwAccess, &shServer);

        if (Status == ERROR_SUCCESS)
        {
            // We have an admin access
            hr = S_OK;
            *pbFullAccess = TRUE;
        }
        else
        {
            if (Status == ERROR_ACCESS_DENIED)
            {
                // We don't have an admin access.
                hr = S_OK;
                *pbFullAccess = FALSE;
            }
            else
            {
                // Failed to open the server.
                hr = HRESULT_FROM_WIN32(Status);
           }
        }
    }
    else
    {
        // invalid argument
        hr = E_INVALIDARG;
    }
    return hr;
}

BOOL
TWizard::
bAddPages(
    IN OUT  PSP_INSTALLWIZARD_DATA  pWizardData
    )
{
    DBGMSG( DBG_TRACE, ( "TWizard::bAddPages\n" ) );

    BOOL    bReturn         = FALSE;
    UINT    nExistingPages  = pWizardData->NumDynamicPages;
    UINT    nSlots          = COUNTOF( pWizardData->DynamicPages );
    UINT    nPagesAdded     = 0;
    UINT    nOurPages       = COUNTOF( _aPages );

    //
    // If the number of existing pages plus our pages is
    // greater than number available slots, exit with an error.
    //
    if( nExistingPages + nOurPages > nSlots )
    {
        DBGMSG( DBG_TRACE, ( "Too many dynamic pags %d\n", pWizardData->NumDynamicPages + COUNTOF( _aPages ) ) );
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
    }
    else
    {
        //
        // Calculate the address of the first available slot.
        //
        HPROPSHEETPAGE *pPages = &pWizardData->DynamicPages[nExistingPages];

        //
        // Create the property page pages.
        //
        if( bCreatePropPages( &nPagesAdded, nSlots - nExistingPages, pPages, nOurPages, _aPages ) )
        {
            //
            // Indicate pages were added.
            //
            pWizardData->DynamicPageFlags = pWizardData->DynamicPageFlags | DYNAWIZ_FLAG_PAGESADDED;

            //
            // Adjust the total page count.
            //
            pWizardData->NumDynamicPages  = nExistingPages + nPagesAdded;

            //
            // Indicate success.
            //
            bReturn = TRUE;
        }
    }

    return bReturn;
}

BOOL
TWizard::
bPropPages(
    VOID
    )

/*++

Routine Description:

    Thread proc to create the printer wizard.

Arguments:

Return Value:

    TRUE = success, FALSE = fail.

History:

    Lazar Ivanov (LazarI) - Nov-30-2000, redesign.

--*/

{
    HPROPSHEETPAGE  ahpsp[TWizard::kPropMax];
    PROPSHEETHEADER psh                    = {0};
    BOOL            bLinkWindowRegistered  = FALSE;
    TStatusB        bReturn;

    // initialize the return value.
    bReturn DBGNOCHK = FALSE;

    // register the link window class
    bLinkWindowRegistered = LinkWindow_RegisterClass();

    if( !bLinkWindowRegistered )
    {
        // unable to register the link window class - this is fatal, so exit
        DBGMSG( DBG_WARN, ( "LinkWindow_RegisterClass() failed - unable to register link window class\n" ) );
        vShowResourceError(_hwnd);
        goto Done;
    }


    // initialize the property sheet header.
    ZeroMemory(ahpsp, sizeof(ahpsp));

    psh.dwSize          = sizeof(psh);
    psh.hwndParent      = _hwnd;
    psh.hInstance       = ghInst;
    psh.dwFlags         = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_STRETCHWATERMARK | PSH_WATERMARK | PSH_HEADER;
    psh.pszbmWatermark  = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader     = MAKEINTRESOURCE(IDB_BANNER);
    psh.phpage          = ahpsp;
    psh.pfnCallback     = TWizard::iSetupDlgCallback;
    psh.nStartPage      = 0;
    psh.nPages          = 0;

    // if this is a specific inf install then build the driver list using the specified inf file.
    if( !_strInfFileName.bEmpty() )
    {
        if( !_Di.bSelectDriverFromInf(_strInfFileName, TRUE) )
        {
            // this is fatal
            DBGMSG( DBG_WARN, ( "TWizard::vWizardPropPage: Unable to use specified inf " TSTR "\n", (LPCTSTR)_strInfFileName ));
            vShowResourceError( _hwnd );
            goto Done;
        }
    }

    // create the property page pages and bring up the wizard.
    if( !bCreatePropPages(&psh.nPages, ARRAYSIZE(ahpsp), ahpsp, ARRAYSIZE(_aPages), _aPages) )
    {
        DBGMSG( DBG_WARN, ( "TWizard::bCreatePropPages failed\n" ) );
        vShowResourceError( _hwnd );
        goto Done;
    }

    if( -1 == PropertySheet(&psh) )
    {
        DBGMSG( DBG_WARN, ( "TWizard::vWizardPropPages: PropertySheet failed %d\n", GetLastError( )));
        vShowResourceError( _hwnd );
        goto Done;
    }

    // if a printer was created or connectd to then indicate success.
    bReturn DBGNOCHK = _bPrinterCreated || _bConnected;

Done:

    // set browse page ID to invalid
    _nBrowsePageID = 0;

    if( bLinkWindowRegistered )
    {
        // unregister the link window class
        LinkWindow_UnregisterClass(ghInst);
    }

    return bReturn;
}


VOID
TWizard::
SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *hBigBoldFont
    )
/*++

Routine Description:

    Sets up the large fonts for the WORD 97 wizard style.

Arguments:

    hInstance       - Instance handle.
    hwnd            - Current window handle.
    hBigBoldFont    - Pointer where to return big bold font handle.

Return Value:

    Nothing. Returned font handles indicate success or failure.

--*/
{
    DBGMSG( DBG_TRACE, ( "TWizard::SetupFonts\n" ) );

    //
    // Create the fonts we need based on the dialog font
    //
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
        LOGFONT BigBoldLogFont  = ncm.lfMessageFont;

    //
    // Create the Big Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;

    INT FontSize;
    TString strLargeFontName;
    TString strLargeFontSize;
    TStatusB bStatus;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    bStatus DBGCHK = strLargeFontName.bLoadString( hInstance, IDS_LARGEFONTNAME ) &&
                     strLargeFontSize.bLoadString( hInstance, IDS_LARGEFONTSIZE );

    if( bStatus )
    {
        _tcsncpy( BigBoldLogFont.lfFaceName, strLargeFontName, COUNTOF( BigBoldLogFont.lfFaceName ) );

        FontSize = _tcstoul( strLargeFontSize, NULL, 10 );
    }
    else
    {
        _tcscpy( BigBoldLogFont.lfFaceName, TEXT("MS Shell Dlg") );
        FontSize = 18;
    }

        HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

        *hBigBoldFont = CreateFontIndirect( &BigBoldLogFont );

        ReleaseDC( hwnd, hdc);
    }
}

BOOL
TWizard::
bPrintTestPage(
    VOID
    )
/*++

Routine Description:

    Prints the test page for the newly created printer.

Arguments:

    None.

Return Value:

    TRUE success, FALSE error.

--*/

{
    TString strFullPrinterName;
    TStatusB bStatus;

    //
    // The test page requires a fully qualified printer name.
    //
    bStatus DBGCHK = bBuildFullPrinterName( _pszServerName, _strPrinterName, strFullPrinterName );

    if( bStatus )
    {
        //
        // Print the test page.
        //
        bStatus DBGCHK = ::bPrintTestPage( _hwnd, strFullPrinterName, NULL );
    }

    return bStatus;
}

UINT
TWizard::
MapPageID(
    UINT uPageID
    ) const
/*++

Routine Description:

    Maps the page ID to the real one. This function
    allows mapping of imaginary page IDs as the
    kSelectPrinterPage to the real ones

Arguments:

    uPageID - The page ID to be mapped

Return Value:

    The real page ID

--*/
{
    //
    // Just map the kSelectPrinterPage to the
    // appropriate ID
    //
    if( kSelectPrinterPage == uPageID )
    {
        SPLASSERT( 0 != nBrowsePageID() );
        uPageID = nBrowsePageID();
    }

    return uPageID;
}

VOID
TWizard::
OnWizardInitro(
    HWND hDlgIntroPage
    )
{
    HWND hWndThis = GetParent( hDlgIntroPage );

    //
    // Subclass the wizard here.
    //
    Attach( hWndThis );

    if( bRestartAgain() )
    {
        if( -1 != iPosX() && -1 != iPosY() )
        {
            //
            // We are in the case where the wizard gets restarted, so we
            // want to restore its position at the same place it has been
            // when the user has clicked "Finish" last time.
            //
            SetWindowPos( hWndThis, NULL, iPosX(), iPosY(), 0, 0, SWP_NOZORDER|SWP_NOSIZE );
        }

        //
        // We are restarting the wizard, so skip the into page.
        //
        PropSheet_PressButton( hWndThis, PSBTN_NEXT );
    }
}

VOID
TWizard::
OnWizardFinish(
    HWND hDlgFinishPage
    )
{
    if( bRestartAgain() && FALSE == bNoPageChange() )
    {
        //
        // We are going to restart the wizard - should blow off
        // the DFA stack here....
        //
        UINT uPage;
        while( Stack().bPop(&uPage) );

        //
        // ...then reset some internal vars, so the wizard doesn't
        // get messed up next time.
        //
        bPreDir() = FALSE;
        bPostDir() = FALSE;
        uDriverExists() = TWizard::kUninitialized;

        //
        // save the window position, so it can be restored later when
        // the wizard gets restarted.
        //
        RECT rcClient;
        HWND hwndThis = GetParent( hDlgFinishPage );

        GetWindowRect( hwndThis, &rcClient );
        MapWindowPoints( HWND_DESKTOP, GetParent( hwndThis ), (LPPOINT)&rcClient, 2 );
        iPosX() = rcClient.left;
        iPosY() = rcClient.top;
    }
}

BOOL
TWizard::
bShouldRestart(
    VOID
    )
/*++

Routine Description:

    Decide whether the wizard should be restarted.

Arguments:

    None.

Return Value:

    TRUE for restart, FALSE for not restart.

--*/

{
    //
    // We check the !(_bPreDir ^ _bPostDir) because we don't have control on the driver setup page.
    // If the user cancel the wizard the driver setup page, the _bPreDir will be TRUE and _bPostDir
    // will be FALSE.
    //

    TStatusB bStatus;

    bStatus DBGNOCHK = _bRestartAgain && !(_bWizardCanceled) && !(_bPreDir ^ _bPostDir);

    return bStatus;
}

LRESULT
TWizard::
WindowProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    //
    // This code is taken from MSDN:
    // http://msdn.microsoft.com/library/psdk/shellcc/shell/Shell_basics/Autoplay_reg.htm#suppressing
    // and the purpose is to suppress autoplay when the add printer wizard is up and running
    //
    static UINT uQueryCancelAutoPlay = 0;

    if( 0 == uQueryCancelAutoPlay )
    {
        uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
    }

    if( uMsg == uQueryCancelAutoPlay )
    {
        SetWindowLong(hwnd, DWLP_MSGRESULT, TRUE);
        return 1;
    }

    // allways call the default processing
    return DefDlgProc(hwnd, uMsg, wParam, lParam);
}

BOOL
TWizard::
bCreatePropPages(
    IN UINT            *pnPageHandles,
    IN UINT             nPageHandles,
    IN HPROPSHEETPAGE  *pPageHandles,
    IN UINT             nPages,
    IN Page            *pPages
    )
/*++

Routine Description:

    Create prop page internal function.

Arguments:

Return Value:

    TRUE success, FALSE error.

--*/

{
    DBGMSG( DBG_TRACE, ( "TWizard.bCreatePropPages\n" ) );

    SPLASSERT( pnPageHandles || pPageHandles || pPages );

    TStatusB bReturn;
    bReturn DBGNOCHK = FALSE;

    //
    // If there is room to store all the page handles.
    //
    if( nPages <= nPageHandles )
    {
        HPROPSHEETPAGE *pHandles    = pPageHandles;
        PROPSHEETPAGE   psp         = {0};

        // assume success
        bReturn DBGNOCHK = TRUE;

        //
        // Initialize the property sheet page structure.
        //
        psp.dwSize          = sizeof( psp );
        psp.hInstance       = ghInst;
        psp.pfnDlgProc      = MGenericProp::SetupDlgProc;

        //
        // Initialze the page handle count.
        //
        *pnPageHandles      = 0;

        //
        // Create all the page and fill in the page handle array.
        //
        for( UINT i = 0; i < nPageHandles && i < nPages && bReturn; i++ )
        {
            if( pPages[i].iDialog == kSelectDriverPage )
            {
                bReturn DBGCHK = _Di.bGetDriverSetupPage( &pHandles[i], _strSetupPageTitle, _strSetupPageSubTitle, _strSetupPageDescription );
            }
            else if( pPages[i].iDialog == kSelectPrinterPage )
            {
                //
                // Special creation for the browse for printer page
                //
                HRESULT hr = ConnectToPrinterPropertyPage( &pHandles[i], &_nBrowsePageID, pPageSwitchController() );
                bReturn DBGCHK = ( S_OK == hr ) && ( NULL != pHandles[i] );
            }
            else if( NULL != pPages[i].pPage )
            {
                psp.dwFlags = PSP_DEFAULT;

                psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

                if( _uAction == kDriverInstall )
                {
                    if( pPages[i].iDialog == DLG_WIZ_DRIVER_INTRO || pPages[i].iDialog == DLG_WIZ_DRIVER_END )
                    {
                        psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
                    }
                }
                else
                {
                    if( pPages[i].iDialog == DLG_WIZ_INTRO || pPages[i].iDialog == DLG_WIZ_FINISH )
                    {
                        psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
                    }
                }

                //
                // Set the title and subtitle.
                //
                TString strTitle;
                TString strSubTitle;

                strTitle.bLoadString( ghInst, pPages[i].iTitle );
                strSubTitle.bLoadString( ghInst, pPages[i].iSubTitle );

                psp.pszHeaderTitle      = strTitle;
                psp.pszHeaderSubTitle   = strSubTitle;

                psp.pszTemplate         = MAKEINTRESOURCE( pPages[i].iDialog );
                psp.lParam              = reinterpret_cast<LPARAM>( pPages[i].pPage );

                pHandles[i]             = CreatePropertySheetPage( &psp );

                bReturn DBGCHK          = pHandles[i] ? TRUE : FALSE;
            }
            else
            {
                pHandles[i] = NULL;
            }

            if( bReturn && pHandles[i] )
            {
                //
                // Update the handle count for valid page handles.
                //
                (*pnPageHandles)++;
                DBGMSG( DBG_TRACE, ( "TWizard::bCreatePropPages Page created %d\n", *pnPageHandles ) );
            }
            else
            {
                //
                // Page creation failed. Fail gracefully.
                //
                DBGMSG( DBG_TRACE, ( "TWizard::bCreatePropPages CreatePropertySheetPage failed %d\n", GetLastError() ) );
                break;
            }
        }

        if( bReturn )
        {
            //
            // The pages were created, and we are not remote and
            // not in the add printer driver wizard, then enable
            // the web button.
            //
            if( _uAction != kDriverInstall && !bIsRemote( _strServerName ) )
            {
                (VOID)_Di.bSetWebMode( TRUE );
            }
        }
        else
        {
            //
            // If something failed then relase any created pages.
            //
            pHandles = pPageHandles;

            for( UINT i = 0; i < nPageHandles; i++ )
            {
                if( pHandles[i] )
                {
                    DestroyPropertySheetPage( pHandles[i] );
                }
            }
        }
    }
    return bReturn;
}



INT CALLBACK
TWizard::
iSetupDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{
    DBGMSG( DBG_TRACE, ( "TWizard::uSetupDlgCallback\n" ) );

    switch( uMsg )
    {
        case PSCB_INITIALIZED:
            break;

        case PSCB_PRECREATE:
            break;
    }

    return FALSE;
}

BOOL
TWizard::
bParseDriver(
    IN HWND hDlg
    )

/*++

Routine Description:

    Parse the driver data.  This ensures that selected
    the driver information is initialized correctly.

Arguments:

    HWND hDlg - Handle to parent dialog.

Return Value:

    TRUE = success,
    FALSE = fail, GLE.

--*/

{
    DBGMSG( DBG_TRACE, ( "TWizard::bParseDriver\n" ) );

    TStatusB bStatus;
    TString strDriverName;

    //
    // Refresh the selected driver.
    //
    bStatus DBGCHK = _Di.bGetSelectedDriver();

    if( bStatus )
    {
        //
        // Get the selected driver name.
        //
        bStatus DBGCHK = _Di.bGetDriverName( strDriverName );

        if( bStatus )
        {
            DBGMSG( DBG_TRACE, ( "Selected Driver name " TSTR "\n", (LPCTSTR)strDriverName ) );

            //
            // Check if the driver name has changed.
            //
            if( _tcsicmp( _strDriverName, strDriverName ) )
            {
                //
                // Force _uDriverExists to recheck if the driver is installed
                // on the server.  Turn everything off.
                //
                _uDriverExists          = kUninitialized;
                _bDriverChanged         = TRUE;
                _bRefreshPrinterName    = TRUE;

                //
                // Update the new driver name.
                //
                bStatus DBGCHK = _strDriverName.bUpdate( strDriverName );
            }
        }
    }

    //
    // Check if an error occurred.
    //
    if( !bStatus ){

        _bErrorSaving = TRUE;

        //
        // Driver data failed to be parsed.
        //
        iMessage( hDlg,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_DRIVER_SELECTION,
                  MB_OK|MB_ICONHAND,
                  kMsgNone,
                  NULL );

        //
        // Terminate the wizard.
        //
        vTerminate( hDlg );

    }

    return bStatus;
}

BOOL
TWizard::
bDriverExists(
    VOID
    )

/*++

Routine Description:

    Returns whether the selected driver already exists on the server.
    Assumes bParseDriver called successfully.

Arguments:

Return Value:

    TRUE = driver exists, FALSE = does not exist on the server.

--*/

{
    DBGMSG( DBG_TRACE, ( "TWizard::bDriverExists\n" ) );

    if( _uDriverExists == kUninitialized ){

        //
        // Check if a compatible driver is installed.
        //
        INT Status;

        Status = _Di.IsDriverInstalledForInf( TPrinterDriverInstallation::kDefault, TRUE );

        if( Status == DRIVER_MODEL_NOT_INSTALLED )
        {
            _uDriverExists = kDoesNotExist;
        }
        else
        {
            _uDriverExists = kExists;
        }
    }

    return ( _uDriverExists & kExists ) ? TRUE : FALSE;

}

BOOL
TWizard::
bCreatePrinter(
    IN HWND hwnd
    )

/*++

Routine Description:

    Creates the printer.  Puts up UI on failure.

Arguments:

Return Value:

    TRUE = success, FALSE = fail.

--*/

{
    TStatusB bReturn;

    //
    // Install the current architecture/version if requested.
    //
    if( _bUseNewDriver ){

        //
        // Attempt to install the specified driver.
        //
        BOOL bOfferReplacementDriver = TRUE;
        bReturn DBGCHK = _Di.bInstallDriver(
            &_strDriverName, bOfferReplacementDriver, _bUseWeb, hwnd);

        //
        // If and error occurred installing the printer driver. Display an
        // error message to the user and do not exit the wizard.
        //
        if( !bReturn ){

            switch( GetLastError() )
            {

                case ERROR_CANCELLED:
                    break;

                case ERROR_UNKNOWN_PRINTER_DRIVER:
                    iMessage( hwnd,
                              IDS_ERR_ADD_PRINTER_TITLE,
                              IDS_ERROR_UNKNOWN_DRIVER,
                              MB_OK | MB_ICONSTOP,
                              kMsgNone,
                              NULL );
                    break;

                default:
                    iMessage( hwnd,
                              IDS_ERR_ADD_PRINTER_TITLE,
                              IDS_ERR_INSTALL_DRIVER,
                              MB_OK|MB_ICONHAND,
                              kMsgGetLastError,
                              NULL );
                    break;
            }

            return bReturn;

        } else {

            //
            // Add any additional printer drivers.  Note policy bits define which
            // drivers are the additional drivers. The wizard will not fail if any
            // additional drivers are not copied down or installation fails
            //
            if( !bAddAdditionalDrivers( hwnd ) )
            {
                iMessage( hwnd,
                          IDS_ERR_ADD_PRINTER_TITLE,
                          IDS_ERR_ADDITIONAL_DRIVERS,
                          MB_OK|MB_ICONWARNING,
                          kMsgNone,
                          NULL );
            }

            //
            // Prevent the driver from being installed again if the printer
            // fails to be added to either the spooler or the DS
            //
            _bUseNewDriver = FALSE;
        }
    }

    //
    // Get the selected print processor.
    //
    TString strPrintProcessor;
    bReturn DBGCHK = _Di.bGetPrintProcessor( strPrintProcessor );

    //
    // Check if the Directory Service is installed and available.
    //
    if( ( _eIsDsAvailablePerMachine == TWizard::kDsStatusUnknown ) && _bPublish )
    {
        TWaitCursor Cur;
        _eIsDsAvailablePerMachine = _Ds.bIsDsAvailable( _strServerName ) ? TWizard::kDsStatusAvailable : TWizard::kDsStatusUnavailable;
    }

    //
    // The driver has been installed, now add the printer to the
    // spooler and the DS.
    //
    bReturn DBGCHK = bInstallPrinter(_pszServerName,
                                     _strPrinterName,
                                     _strShareName,
                                     _strPortName,
                                     _strDriverName,
                                     strPrintProcessor,
                                     _strLocation,
                                     _strComment,
                                     _bShared,
                                     _bPublish,
                                     kAttributesNone,
                                     _eIsDsAvailablePerMachine,
                                     0,
                                     NULL );
    //
    // If an error occurred adding the printer.
    //
    if( !bReturn ){

        DBGMSG( DBG_WARN, ( "Wizard.bCreatePrinter: could not create "TSTR" %d\n" , DBGSTR( (LPCTSTR)_strPrinterName ), GetLastError()));

        iMessage( _hwnd,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_INSTALLPRINTER,
                  MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                  kMsgGetLastError,
                  NULL );

    } else {

        TString strFullPrinterName;
        TStatusB bStatus;

        //
        // Build full printer name.
        //
        bStatus DBGCHK = bBuildFullPrinterName( _pszServerName, _strPrinterName, strFullPrinterName );

        //
        // Inform the driver installation that a printer has been added.
        //
        _Di.vPrinterAdded( strFullPrinterName );
    }

    return bReturn;
}

BOOL
TWizard::
bAddAdditionalDrivers(
    IN HWND hwnd
    )
/*++

Routine Description:

    Adds any additonal printer drivers.

Arguments:

    Pointer to add info structure.

Return Value:

    TRUE post printer install was successful, otherwize FALSE.

--*/

{
    //
    // Assume success.
    //
    BOOL bStatus = TRUE;

    //
    // If the user did not check the 'Do not install additional drivers' and
    // the policy bits indicate we should add the addtional drivers and the
    // the user is not using a existing driver and the user has not
    // used the 'HaveDisk'.
    //
    if( !_bUseWeb && _bAdditionalDrivers && _dwAdditionalDrivers != -1 && _bUseNewDriver && !_Di.bIsOemDriver() )
    {
        //
        // If we should install the default additional drivers.
        //
        if( _dwAdditionalDrivers == 0 )
        {
            _dwAdditionalDrivers = kDefaultAdditionalDrivers;
        }

        DBGMSG( DBG_TRACE, ( "Wizard.bAddAdditonalDrivers additional drivers %x\n", _dwAdditionalDrivers ));

        //
        // Install the additional drivers.
        //
        for( UINT i = 0, uBit = 1; uBit; uBit <<= 1, i++ )
        {
            //
            // Did we find a match.
            //
            if( uBit & _dwAdditionalDrivers )
            {
                DWORD dwEncode;

                //
                // Convert this bit to a driver encode.
                //
                if( TArchLV::bGetEncodeFromIndex( i, &dwEncode ) )
                {
                    //
                    // Do not re-install installed drivers.
                    //
                    if( !_Di.bIsDriverInstalled( dwEncode ) )
                    {
                        //
                        // Install the printer driver.
                        //
                        if( !TWizDriverEnd::bInstallDriver( hwnd, dwEncode, _Di, FALSE, DRVINST_PROMPTLESS, &_strDriverName ) )
                        {
                            bStatus = FALSE;
                        }
                    }
                }
            }
        }
    }

    //
    // We indicate failure if any additional driver fails
    // to install successfully.
    //
    return bStatus;
}


BOOL
TWizard::
bInstallPrinter(
    IN LPCTSTR                  pszServerName,
    IN LPCTSTR                  pszPrinterName,
    IN LPCTSTR                  pszShareName,
    IN LPCTSTR                  pszPortName,
    IN LPCTSTR                  pszDriverName,
    IN LPCTSTR                  pszPrintProcessor,
    IN LPCTSTR                  pszLocation,
    IN LPCTSTR                  pszComment,
    IN BOOL                     bShared,
    IN BOOL                     bPublish,
    IN EAddPrinterAttributes    eAttributeFlags,
    IN EDsStatus                eIsDsAvailable,
    IN DWORD                    dwAttributes,
    IN PSECURITY_DESCRIPTOR     pSecurityDescriptor

    )
/*++

Routine Description:

    Installs a printer by calling add printer.

Arguments:

    Parameters needed for filling in a printer info 2
    structure and a printer info 7 structure.

Return Value:

    TRUE = success, FALSE = fail.

--*/
{
    TStatusB bStatus;
    HANDLE hPrinter;
    AddInfo Info;
    TWaitCursor Cur;

    //
    // Fill in the Info structure.
    //
    Info.pszServerName      = pszServerName;
    Info.pszPrinterName     = pszPrinterName;
    Info.pszShareName       = pszShareName;
    Info.pszPrintProcessor  = pszPrintProcessor;
    Info.bShared            = bShared;
    Info.bPublish           = bPublish;
    Info.eFlags             = eAttributeFlags;
    Info.eIsDsAvailable     = eIsDsAvailable;
    Info.dwAttributes       = dwAttributes;

    //
    // Do any pre add printer actions.
    //
    bStatus DBGCHK = bPreAddPrinter( Info );

    if( bStatus )
    {
        //
        // Ask the spooler to add this printer.
        //
        PRINTER_INFO_2 PrinterInfo2;

        ZeroMemory( &PrinterInfo2, sizeof( PrinterInfo2 ));

        PrinterInfo2.pPrinterName       = (LPTSTR)pszPrinterName;
        PrinterInfo2.pShareName         = (LPTSTR)Info.pszShareName;
        PrinterInfo2.pPortName          = (LPTSTR)pszPortName;
        PrinterInfo2.pDriverName        = (LPTSTR)pszDriverName;
        PrinterInfo2.pLocation          = (LPTSTR)pszLocation;
        PrinterInfo2.pComment           = (LPTSTR)pszComment;
        PrinterInfo2.pPrintProcessor    = (LPTSTR)Info.pszPrintProcessor;
        PrinterInfo2.pDatatype          = (LPTSTR)gszDefaultDataType;
        PrinterInfo2.Attributes         = Info.dwAttributes;
        PrinterInfo2.pSecurityDescriptor= pSecurityDescriptor;

        hPrinter = AddPrinter( (LPTSTR)pszServerName, 2, (PBYTE)&PrinterInfo2 );

        //
        // Do any post add printer processing.
        //
        bStatus DBGCHK = bPostAddPrinter( Info, hPrinter );

        if( hPrinter ){

            bStatus DBGCHK = ClosePrinter( hPrinter );
            bStatus DBGNOCHK = TRUE;

        } else {

            bStatus DBGNOCHK = FALSE;

        }
    }

    return bStatus;
}

BOOL
TWizard::
bPreAddPrinter(
    IN AddInfo &Info
    )
/*++

Routine Description:

    Handles any pre printer install processing.  Note this routine is very
    tighly coupled to the bInstallPrinter routine.

Arguments:

    Pointer to add info structure.

Return Value:

    TRUE pre printer install was successful, otherwize FALSE.

--*/
{
    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    //
    // If a valid print processor string was given
    // use it, otherwize use the default print
    // processor.
    //
    if( !Info.pszPrintProcessor || !*Info.pszPrintProcessor )
    {
        Info.pszPrintProcessor = gszDefaultPrintProcessor;
    }

    //
    // The default attribute is to print spooled jobs first.
    //

    DWORD dwDefaultAttributes = PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST;

    //
    // Get the default attributes from the registry if the value is not there
    // then set the default attribute value.
    //
    TPersist Persist( gszAddPrinterWizard, TPersist::kCreate|TPersist::kRead|TPersist::kWrite );

    if( VALID_OBJ( Persist ) )
    {
        bStatus DBGCHK = Persist.bRead( gszAPWAttributes, dwDefaultAttributes );

        if( !bStatus )
        {
            //
            // Set the default attribute in the registry.
            //
            bStatus DBGCHK = Persist.bWrite( gszAPWAttributes, dwDefaultAttributes );
        }
    }

    //
    // Set the returned default attributes, not we are clearing the sharing
    // bit to ensure we do not try and share the printer during the add
    // printer call.  If the print is to be shared then we will share it
    // during the post add printer call.
    //
    Info.dwAttributes |= (dwDefaultAttributes & ~PRINTER_ATTRIBUTE_SHARED);

    //
    // If we are to create a masq printer, set the attribute bits that indicate
    // it is a masq printer.  A masq printer is a printer which has both the
    // local and network attribute bits set.
    //
    if( Info.eFlags == kAttributesMasq )
    {
        Info.dwAttributes |= PRINTER_ATTRIBUTE_LOCAL | PRINTER_ATTRIBUTE_NETWORK;
    }

    //
    // There is a race conditions when attempting to use a port that was dynamicaly
    // added ports.  We make a EnumPorts call to kick off discovery of this new
    // port before the AddPrinter call is done.
    //
    // This is really should be done in spooler.
    //
    if( !Info.pszServerName || !*Info.pszServerName )
    {
        DWORD           dwLevel = 2;
        PPORT_INFO_2    pPorts  = NULL;
        DWORD           cbPorts = 0;
        DWORD           cPorts  = 0;

        //
        // Enumerate the port starting at level 2.
        //
        bStatus DBGCHK = VDataRefresh::bEnumPortsMaxLevel( Info.pszServerName,
                                                           &dwLevel,
                                                           (PVOID *)&pPorts,
                                                           &cbPorts,
                                                           &cPorts );
        if( bStatus )
        {
            FreeMem( pPorts );
        }
    }

    //
    // If we are adding the masq printer do not validate the printer name.
    //
    if( Info.eFlags == kAttributesMasq )
    {
        bStatus DBGNOCHK = TRUE;
    }
    else
    {
        //
        // Check the printe name for illegal characters.
        //
        bStatus DBGCHK = bIsLocalPrinterNameValid( Info.pszPrinterName );

        if( !bStatus )
        {
            SetLastError( ERROR_INVALID_PRINTER_NAME );
        }
    }

    return bStatus;
}

BOOL
TWizard::
bPostAddPrinter(
    IN AddInfo &Info,
    IN HANDLE   hPrinter
    )
/*++

Routine Description:

    Handles any post printer install processing.  Note this routine is very
    tighly coupled to the bInstallPrinter routine.

Arguments:

    Pointer to add info structure.

Return Value:

    TRUE post printer install was successful, otherwize FALSE.

--*/

{
    TStatusB bStatus;

    bStatus DBGNOCHK = FALSE;

    if( !hPrinter )
    {
        DBGMSG( DBG_TRACE, ( "bPostAddPrinter called with invalid printer handle.\n" ) );
        return FALSE;
    }

    //
    // We don't share or publish the masq printers.
    //
    if( Info.eFlags == kAttributesMasq )
    {
        DBGMSG( DBG_TRACE, ( "bPostAddPrinter called with masq printer.\n" ) );
        return FALSE;
    }

    //
    // If the network is available and we are to share the printer.
    //
    if( TPrtShare::bNetworkInstalled() && Info.bShared )
    {
        TString strShareName;
        TString strPrinterName;
        TPrtShare PrtShare( Info.pszServerName );

        if( !Info.pszShareName || !*Info.pszShareName )
        {
            //
            // Copy the printer name to a temporary string class because the
            // TPrtShare object only accepts the printer name as a string refrence.
            //
            bStatus DBGCHK = strPrinterName.bUpdate( Info.pszPrinterName );

            //
            // Validate the prt share object and the printer name.
            //
            bStatus DBGNOCHK = VALID_OBJ( PrtShare ) && VALID_OBJ( strPrinterName );

            if( bStatus )
            {
                //
                // Generate a unique share name.
                //
                bStatus DBGCHK = PrtShare.bNewShareName( strShareName, strPrinterName );
            }
        }
        else
        {
            bStatus DBGCHK = strShareName.bUpdate( Info.pszShareName );
        }

        //
        // If the share name was either given or generated then
        // attempt to share the printer.
        //
        if( bStatus )
        {
            PPRINTER_INFO_2 pInfo2  = NULL;
            DWORD           cbInfo2 = 0;

            //
            // Get the current printer info 2.
            //
            bStatus DBGCHK = VDataRefresh::bGetPrinter( hPrinter, 2, (PVOID*)&pInfo2, &cbInfo2 );

            if( bStatus )
            {
                pInfo2->Attributes |= PRINTER_ATTRIBUTE_SHARED;
                pInfo2->pShareName = (LPTSTR)(LPCTSTR)strShareName;

                bStatus DBGCHK = SetPrinter( hPrinter, 2, (PBYTE)pInfo2, 0 );
            }

            //
            // Release the printer info 2 structure.
            //
            FreeMem( pInfo2 );
        }

        //
        // Attempt to publish the printer if the DS is available.
        // Note this is only a suggestion, if the publish fails
        // do not inform the user just complete the add printer.
        //
        if( bStatus && Info.bPublish && ( Info.eIsDsAvailable == kDsStatusAvailable ) )
        {
            DBGMSG( DBG_TRACE, ( "bPostAddPrinter attempting to publish printer.\n" ) );

            PRINTER_INFO_7 Info7 = { 0 };
            Info7.dwAction       = DSPRINT_PUBLISH;

            bStatus DBGCHK = SetPrinter( hPrinter, 7, (PBYTE)&Info7, 0 );
        }
    }

    return bStatus;
}


VOID
TWizard::
vTerminate(
    IN HWND hDlg
    )
/*++

Routine Description:

    Terminates the wizard.

Arguments:

    Window handle of current page.

Return Value:

    Nothing.

--*/
{
    PostMessage( GetParent( hDlg ), PSM_PRESSBUTTON, PSBTN_CANCEL, 0 );
}

VOID
TWizard::
vReadRegistrySettingDefaults(
    VOID
    )
/*++

Routine Description:

    Reads any default settings from the registry.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    TStatusB bStatus;
    TPersist Persist( gszAddPrinterWizard, TPersist::kCreate|TPersist::kRead );

    if( VALID_OBJ( Persist ) && _bPersistSettings )
    {
        bStatus DBGNOCHK = Persist.bRead( gszAPWTestPage,       _bTestPage );
        bStatus DBGNOCHK = Persist.bRead( gszAPWUseWeb,         _bUseWeb );
        bStatus DBGNOCHK = Persist.bRead( gszAPWUseExisting,    _bUseNewDriverSticky );
        bStatus DBGNOCHK = Persist.bRead( gszAPWSetAsDefault,   _bSetDefault );
        bStatus DBGNOCHK = Persist.bRead( gszAPWDriverName,     _strDriverName );
        bStatus DBGNOCHK = Persist.bRead( gszAPWLocalPrinter,   _bNet );
        bStatus DBGNOCHK = Persist.bRead( gszAPWShared,         _bShared );
        bStatus DBGNOCHK = Persist.bRead( gszAPWAdditionalDrv,  _bAdditionalDrivers );
        bStatus DBGNOCHK = Persist.bRead( gszAPWPnPAutodetect,  _bPnPAutodetect );
    }

    //
    // Read the bits from the policy location.
    //
    TPersist PersistPolicy( gszAddPrinterWizardPolicy, TPersist::kOpen|TPersist::kRead );

    if( VALID_OBJ( PersistPolicy ) )
    {
        bStatus DBGNOCHK = PersistPolicy.bRead( gszAPWSharing,          _bShared );
        bStatus DBGNOCHK = PersistPolicy.bRead( gszAPWDownLevelBrowse,  _bDownlevelBrowse );

        //
        // After the drivers went to a CAB file and we removed
        // the cross-platform drivers from the media we will never
        // give the user oportunity to install additional drivers
        // in the APW
        //
        // bStatus DBGNOCHK = PersistPolicy.bRead( gszAPWDrivers,          _dwAdditionalDrivers );

        bStatus DBGNOCHK = PersistPolicy.bRead( gszAPWPrintersPageURL,  _strPrintersPageURL );
    }

    //
    // Read the bits from the policy location from hkey local machine.
    //
    TPersist PersistPolicy2( gszAddPrinterWizardPolicy, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

    if( VALID_OBJ( PersistPolicy2 ) )
    {
        bStatus DBGNOCHK = PersistPolicy2.bRead( gszAPWPublish,        _bPublish );
    }

    //
    // Read the per machine policy bit that the spooler uses for
    // printer publishing.  The per user policy and the per machine policy
    // must agree inorder for the wizard to publish the printer.
    //
    TPersist SpoolerPolicy( gszSpoolerPolicy, TPersist::kOpen|TPersist::kRead, HKEY_LOCAL_MACHINE );

    if( VALID_OBJ( SpoolerPolicy ) )
    {
        BOOL bCanPublish = kDefaultPublishState;

        bStatus DBGNOCHK = SpoolerPolicy.bRead( gszSpoolerPublish, bCanPublish );

        if( bStatus )
        {
            _bPublish = _bPublish && bCanPublish;
        }
    }
}

VOID
TWizard::
vWriteRegistrySettingDefaults(
    VOID
    )
/*++

Routine Description:

    Writes any default settings to the registry.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    TPersist Persist( gszAddPrinterWizard, TPersist::kOpen|TPersist::kWrite );

    if( VALID_OBJ( Persist ) && _bPersistSettings )
    {
        TStatusB bStatus;
        bStatus DBGCHK = Persist.bWrite( gszAPWTestPage,        _bTestPage );
        bStatus DBGCHK = Persist.bWrite( gszAPWUseWeb,          _bUseWeb );
        bStatus DBGCHK = Persist.bWrite( gszAPWUseExisting,     _bUseNewDriverSticky );
        bStatus DBGCHK = Persist.bWrite( gszAPWSetAsDefault,    _bSetDefault );
        bStatus DBGCHK = Persist.bWrite( gszAPWDriverName,      _strDriverName );
        bStatus DBGCHK = Persist.bWrite( gszAPWLocalPrinter,    _bNet );
        bStatus DBGCHK = Persist.bWrite( gszAPWShared,          _bShared );
        bStatus DBGCHK = Persist.bWrite( gszAPWAdditionalDrv,   _bAdditionalDrivers );
        bStatus DBGCHK = Persist.bWrite( gszAPWPnPAutodetect,   _bPnPAutodetect );
    }
}

/********************************************************************

    Generic wizard base class.

********************************************************************/

MWizardProp::
MWizardProp(
    TWizard* pWizard
    ) : _pWizard( pWizard )
{
}

MWizardProp::
~MWizardProp(
    VOID
    )
{
}

BOOL
MWizardProp::
bHandleMessage(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL bReturn = FALSE;

    switch( uMsg )
    {

    case WM_INITDIALOG:
        {
            //
            // Patch some styles of the property sheet window once
            //
            vCheckToPatchStyles( );

            //
            // Handle the WM_INITDIALOG message
            //
            bReturn = bHandle_InitDialog();
        }
        break;

    case WM_COMMAND:

        bReturn = bHandle_Command( GET_WM_COMMAND_ID( wParam, lParam ),
                                   GET_WM_COMMAND_CMD(wParam, lParam ),
                                   (HWND)lParam );
        break;

    case WM_TIMER:

        bReturn = bHandle_Timer( wParam, (TIMERPROC *)lParam );

        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;

        switch( pnmh->code )
        {
        case PSN_SETACTIVE:
            bReturn = bHandle_SetActive();
            break;

        case PSN_KILLACTIVE:
            bReturn = bHandle_KillActive();
            break;

        case PSN_WIZBACK:
            bReturn = bHandle_WizBack();
            break;

        case PSN_WIZNEXT:
            bReturn = bHandle_WizNext();
            break;

        case PSN_WIZFINISH:
            bReturn = bHandle_WizFinish();
            break;

        case PSN_QUERYCANCEL:
            bReturn = bHandle_Cancel();
            break;

        //
        // Message not handled.
        //
        default:
            bReturn = bHandle_Notify( wParam, pnmh );
            break;
        }

        //
        // Handle any page changes.
        //
        bReturn = bHandle_PageChange( bReturn, pnmh->code, wParam, lParam );

    }
    break;

    //
    // Message not handled.
    //
    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

VOID
MWizardProp::
vCheckToPatchStyles(
    VOID
    )
{
    SPLASSERT( _pWizard );
    SPLASSERT( _hDlg );

    if( !_pWizard->bStylePatched() )
    {
        HWND hPropSheet = GetParent( _hDlg );
        SPLASSERT( hPropSheet );

        LONG lStyle = GetWindowLong( hPropSheet, GWL_STYLE );
        lStyle &= ~( WS_SYSMENU | DS_CONTEXTHELP );
        SetWindowLong( hPropSheet, GWL_STYLE, lStyle );

        _pWizard->bStylePatched() = TRUE;
    }
}

BOOL
MWizardProp::
bHandle_InitDialog(
    VOID
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_Command(
    IN WORD wId,
    IN WORD wNotifyId,
    IN HWND hwnd
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_Notify(
    IN WPARAM   wParam,
    IN LPNMHDR  pnmh
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_SetActive(
    VOID
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_KillActive(
    VOID
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_WizBack(
    VOID
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_WizNext(
    VOID
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_WizFinish(
    VOID
    )
{
    return FALSE;
}

BOOL
MWizardProp::
bHandle_Cancel(
    VOID
    )
{
    _pWizard->_bWizardCanceled = TRUE;
    return FALSE;
}

BOOL
MWizardProp::
bHandle_Timer(
    IN WPARAM     wIdTimer,
    IN TIMERPROC *tmProc
    )
{
    return FALSE;
}

VOID
MWizardProp::
SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    )
{
    if( hFont )
    {
        HWND hwndControl = GetDlgItem(hwnd, nId);

        if( hwndControl )
        {
            SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}

BOOL
MWizardProp::
bHandle_PageChange(
    IN BOOL    bReturn,
    IN UINT    uMsg,
    IN WPARAM  wParam,
    IN LPARAM  lParam
    )
{
    //
    // If no page change request was made then
    // do not switch the page and return.
    //
    if( _pWizard->bNoPageChange() )
    {
        _pWizard->bNoPageChange() = FALSE;

        // XP bug #22031: if uMsg == PSN_WIZFINISH then in case we want to prevent the wizard
        // from finishing we should return the handle of a window to receive the focus (this is
        // valid for comctl32 ver 5.80 or higer - for more information, see SDK).
        vSetDlgMsgResult( uMsg == PSN_WIZFINISH ? reinterpret_cast<LONG_PTR>(_hDlg) : (LPARAM)-1 );

        return TRUE;
    }

    if( uMsg == PSN_WIZNEXT    ||
        uMsg == PSN_WIZBACK    ||
        uMsg == PSN_SETACTIVE  ||
        uMsg == PSN_KILLACTIVE )
    {
        //
        // The Twizard object controls both the add printer and add driver wizard.
        // Since these two wizard do not share the page switching code we must
        // detect which mode the wizard is in.
        //
        if( _pWizard->uAction() == TWizard::kPnPInstall     ||
            _pWizard->uAction() == TWizard::kPrinterInstall ||
            _pWizard->uAction() == TWizard::kPrinterInstallModeless )
        {
            //
            // Handle the add printer wizard page change.
            //
            if( bAddPrinterWizardPageChange( uMsg ) )
            {
                bReturn = TRUE;
            }
        }

        if( _pWizard->uAction() == TWizard::kDriverInstall )
        {
            //
            // Handle the add driver wizard page change.
            //
            if( bDriverWizardPageChange( uMsg ) )
            {
                bReturn = TRUE;
            }
        }
    }

    return bReturn;
}

BOOL
MWizardProp::
bAddPrinterWizardPageChange(
    IN UINT uMsg
    )
{
    BOOL bReturn = FALSE;

    static PrinterWizPageEntry Table [] = {

    // Message        Current Page                  SharingEnabled, Autodetect,     PrnDetected,    PnpInstall,     Keep Existing,  Driver Exists,  Net Avail,  Network,    Is Remote   DS,          Dir Pre,     Dir Post    Default     Shared,    Admin           LocateType                  bDownlevelBrowse              bConnected            Result                        Extra
    { PSN_SETACTIVE,  DLG_WIZ_PRE_INTRO,            kDontCare,      kDontCare,      kDontCare,      kFalse,         kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_INTRO,                kPush       },
    { PSN_SETACTIVE,  DLG_WIZ_PRE_INTRO,            kDontCare,      kDontCare,      kDontCare,      kTrue,          kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_PORT_NEW,                 kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_INTRO,                kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kFalse,     kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_TYPE,                 kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_INTRO,                kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kTrue,      kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_PORT_NEW,                 kPush       },

    // DLG_WIZ_TYPE rules
    { PSN_WIZNEXT,    DLG_WIZ_TYPE,                 kDontCare,      kTrue,          kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kFalse,     kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kTrue,          kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_DETECT,               kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_TYPE,                 kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kTrue,      kDontCare,  kFalse,      kDontCare,   kDontCare,  kDontCare,  kDontCare, kFalse,         kDontCare,                  kTrue,                        kTrue,                TWizard::kSelectPrinterPage,  kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_TYPE,                 kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kTrue,      kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_LOCATE,               kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_TYPE,                 kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kFalse,     kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_PORT_NEW,                 kPush       },

    // DLG_WIZ_DETECT rules
    { PSN_WIZNEXT,    DLG_WIZ_DETECT,               kDontCare,      kTrue,          kTrue,          kDontCare,      kDontCare,      kDontCare,      kDontCare,  kFalse,     kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kTrue,          kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_FINISH,               kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_DETECT,               kDontCare,      kDontCare,      kFalse,         kDontCare,      kDontCare,      kDontCare,      kDontCare,  kFalse,     kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kTrue,          kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_PORT_NEW,                 kPush       },

    // DLG_WIZ_LOCATE rules
    { PSN_WIZNEXT,    DLG_WIZ_LOCATE,               kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kFalse,      kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      TWizard::kSearch,           kTrue,                        kFalse,               TWizard::kSelectPrinterPage,  kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_LOCATE,               kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      TWizard::kBrowseNET,        kTrue,                        kFalse,               TWizard::kSelectPrinterPage,  kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_LOCATE,               kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kTrue,      kDontCare, kDontCare,      TWizard::kSearch,           kDontCare,                    kTrue,                DLG_WIZ_NET,                  kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_LOCATE,               kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kFalse,     kDontCare, kDontCare,      TWizard::kSearch,           kDontCare,                    kTrue,                DLG_WIZ_FINISH,               kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_LOCATE,               kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kTrue,      kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kTrue,                DLG_WIZ_NET,                  kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_LOCATE,               kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kFalse,     kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kTrue,                DLG_WIZ_FINISH,               kPush       },

    { PSN_WIZNEXT,    DLG_WIZ_DRIVEREXISTS,         kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_NAME,                 kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_NAME,                 kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kFalse,     kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_TEST_PAGE,            kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_TEST_PAGE,            kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_FINISH,               kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_NET,                  kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_FINISH,               kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_NAME,                 kTrue,          kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_SHARE,                kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_NAME,                 kFalse,         kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_TEST_PAGE,            kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_SHARE,                kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kTrue,     kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_COMMENT,              kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_SHARE,                kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kFalse,    kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_TEST_PAGE,            kPush       },
    { PSN_WIZNEXT,    DLG_WIZ_COMMENT,              kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_TEST_PAGE,            kPush       },

    { PSN_WIZNEXT,    DLG_WIZ_PORT_NEW,             kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_PRE_SELECT_DEVICE,    kPush       },
    { PSN_SETACTIVE,  DLG_WIZ_PRE_SELECT_DEVICE,    kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kTrue,       kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            kNoPage,                      kSkipPage   },
    { PSN_SETACTIVE,  DLG_WIZ_POST_SELECT_DEVICE,   kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kFalse,         kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kTrue,      kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_NAME,                 kPush       },
    { PSN_SETACTIVE,  DLG_WIZ_POST_SELECT_DEVICE,   kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kTrue,          kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kTrue,      kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            DLG_WIZ_DRIVEREXISTS,         kPush       },
    { PSN_WIZBACK,    DLG_WIZ_DRIVEREXISTS,         kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            kNoPage,                      kPop        },
    { PSN_WIZBACK,    DLG_WIZ_NAME,                 kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            kNoPage,                      kPop        },
    { PSN_SETACTIVE,  DLG_WIZ_POST_SELECT_DEVICE,   kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kFalse,     kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            kNoPage,                      kSkipPage   },
    { PSN_SETACTIVE,  DLG_WIZ_PRE_SELECT_DEVICE,    kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kFalse,      kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            kNoPage,                      kPop        },

    { PSN_WIZBACK,    DLG_WIZ_PORT_NEW,             kDontCare,      kDontCare,      kDontCare,      kTrue,          kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            IDD_DYNAWIZ_SELECTCLASS_PAGE, kPop        },
    { PSN_WIZBACK,    DLG_WIZ_TYPE,                 kDontCare,      kDontCare,      kDontCare,      kFalse,         kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            kNoPage,                      kPop        },
    { PSN_WIZBACK,    kDontCare,                    kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            kNoPage,                      kPop        },

    { PSN_SETACTIVE,  DLG_WIZ_INTRO,                kDontCare,      kDontCare,      kDontCare,      kTrue,          kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_NEXT | PSWIZB_BACK,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_INTRO,                kDontCare,      kDontCare,      kDontCare,      kFalse,         kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_NEXT,                  kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_PORT_NEW,             kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_NAME,                 kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_SHARE,                kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_COMMENT,              kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_DRIVEREXISTS,         kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_LOCATE,               kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_TEST_PAGE,            kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_TYPE,                 kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_BACK | PSWIZB_NEXT,    kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_NET,                  kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,      kDontCare,  kDontCare,  kDontCare,  kDontCare,   kDontCare,   kDontCare,  kDontCare,  kDontCare, kDontCare,      kDontCare,                  kDontCare,                    kDontCare,            PSWIZB_NEXT,                  kSetButtonState },

    { kEnd }};

    //
    // Scan for a message match, disregarding don't care fields.
    //
    for( PrinterWizPageEntry *pTable = Table; pTable->uMessage != kEnd; pTable++ )
    {
        PrinterWizPageEntry Entry;

        Entry.uMessage          = pTable->uMessage          == kDontCare ? kDontCare : uMsg;
        Entry.uCurrentPage      = pTable->uCurrentPage      == kDontCare ? kDontCare : uGetPageId();
        Entry.uSharingEnabled   = pTable->uSharingEnabled   == kDontCare ? kDontCare : _pWizard->bIsSharingEnabled() ? kTrue : kFalse;
        Entry.uAutodetect       = pTable->uAutodetect       == kDontCare ? kDontCare : _pWizard->pszServerName() ? 0 : _pWizard->_bPnPAutodetect;
        Entry.uPrinterDetected  = pTable->uPrinterDetected  == kDontCare ? kDontCare : _pWizard->bPrinterAutoDetected();
        Entry.uPnPInstall       = pTable->uPnPInstall       == kDontCare ? kDontCare : _pWizard->uAction() == TWizard::kPnPInstall ? kTrue : kFalse;
        Entry.uDriverExists     = pTable->uDriverExists     == kDontCare ? kDontCare : _pWizard->uDriverExists() == TWizard::kExists ? kTrue : kFalse;
        Entry.uSharing          = pTable->uSharing          == kDontCare ? kDontCare : _pWizard->bNetworkInstalled() ? kTrue : kFalse;
        Entry.uNetwork          = pTable->uNetwork          == kDontCare ? kDontCare : _pWizard->bNet() ? kTrue : kFalse;
        Entry.bIsRemoteServer   = pTable->bIsRemoteServer   == kDontCare ? kDontCare : bIsRemote( _pWizard->pszServerName() ) ? kTrue : kFalse;
        Entry.uDirectoryService = pTable->uDirectoryService == kDontCare ? kDontCare : _pWizard->eIsDsAvailablePerUser() == TWizard::kDsStatusAvailable ? kTrue : kFalse;
        Entry.uKeepExisting     = pTable->uKeepExisting     == kDontCare ? kDontCare : !_pWizard->bUseNewDriver() ? kTrue : kFalse;
        Entry.uSetDefault       = pTable->uSetDefault       == kDontCare ? kDontCare : _pWizard->bIsPrinterFolderEmpty() ? kTrue : kFalse;
        Entry.uShared           = pTable->uShared           == kDontCare ? kDontCare : _pWizard->bShared() ? kTrue : kFalse;
        Entry.uPreDir           = pTable->uPreDir           == kDontCare ? kDontCare : _pWizard->bPreDir();
        Entry.uPostDir          = pTable->uPostDir          == kDontCare ? kDontCare : _pWizard->bPostDir();
        Entry.bAdminPrivilege   = pTable->bAdminPrivilege   == kDontCare ? kDontCare : _pWizard->bAdminPrivilege();
        Entry.nLocateType       = pTable->nLocateType       == kDontCare ? kDontCare : _pWizard->LocateType();
        Entry.nDownlevelBrowse  = pTable->nDownlevelBrowse  == kDontCare ? kDontCare : _pWizard->bDownlevelBrowse() ? kTrue : kFalse;
        Entry.uConnected        = pTable->uConnected        == kDontCare ? kDontCare : _pWizard->bConnected() ? kTrue : kFalse;

        if( pTable->uMessage            == Entry.uMessage           &&
            pTable->uCurrentPage        == Entry.uCurrentPage       &&
            pTable->uSharingEnabled     == Entry.uSharingEnabled    &&
            pTable->uAutodetect         == Entry.uAutodetect        &&
            pTable->uPrinterDetected    == Entry.uPrinterDetected   &&
            pTable->uPnPInstall         == Entry.uPnPInstall        &&
            pTable->uDriverExists       == Entry.uDriverExists      &&
            pTable->uSharing            == Entry.uSharing           &&
            pTable->uNetwork            == Entry.uNetwork           &&
            pTable->bIsRemoteServer     == Entry.bIsRemoteServer    &&
            pTable->uDirectoryService   == Entry.uDirectoryService  &&
            pTable->uKeepExisting       == Entry.uKeepExisting      &&
            pTable->uSetDefault         == Entry.uSetDefault        &&
            pTable->uShared             == Entry.uShared            &&
            pTable->uPreDir             == Entry.uPreDir            &&
            pTable->uPostDir            == Entry.uPostDir           &&
            pTable->bAdminPrivilege     == Entry.bAdminPrivilege    &&
            pTable->nDownlevelBrowse    == Entry.nDownlevelBrowse   &&
            pTable->nLocateType         == Entry.nLocateType        &&
            pTable->uConnected          == Entry.uConnected        )
        {
            break;
        }
    }

    //
    // If a table match was found handle the page switch.
    //
    if( pTable->uMessage != kEnd )
    {
        DBGMSG( DBG_NONE, ( "Match found Entry index %d\n" , pTable - Table ) );

        TStatusB bStatus;
        UINT uNextPage = 0;

        switch( pTable->Action )
        {
        case kPush:
            bStatus DBGCHK = _pWizard->Stack().bPush( uGetPageId() );
            uNextPage = _pWizard->MapPageID(pTable->Result);
            vSetDlgMsgResult( reinterpret_cast<LONG_PTR>(MAKEINTRESOURCE(uNextPage)) );
            break;

        case kPop:
            bStatus DBGCHK = _pWizard->Stack().bPop( &uNextPage );

            if( _pWizard->MapPageID(pTable->Result) != kNoPage )
            {
                uNextPage = _pWizard->MapPageID(pTable->Result);
            }
            vSetDlgMsgResult( reinterpret_cast<LONG_PTR>(MAKEINTRESOURCE(uNextPage)) );
            break;

        case kSkipPage:
            vSetDlgMsgResult( -1 );
            break;

        case kSetButtonState:
            PropSheet_SetWizButtons( GetParent( _hDlg ), pTable->Result );
            break;

        default:
            break;
        }

        bReturn = TRUE;
    }

    return bReturn;
}

BOOL
MWizardProp::
bDriverWizardPageChange(
    IN UINT uMsg
    )
{
    BOOL bReturn = FALSE;

    static DriverWizPageEntry Table [] = {
    // Message        Current Page                  Skip Arch,  Dir Pre,     Dir Post   Result                      Action
    { PSN_WIZNEXT,    DLG_WIZ_DRIVER_INTRO,         kDontCare,  kDontCare,   kDontCare, DLG_WIZ_PRE_SELECT_DEVICE,  kPush           },
    { PSN_WIZNEXT,    DLG_WIZ_DRIVER_ARCHITECTURE,  kDontCare,  kDontCare,   kDontCare, DLG_WIZ_DRIVER_END,         kPush           },

    { PSN_SETACTIVE,  DLG_WIZ_PRE_SELECT_DEVICE,    kDontCare,  kTrue,       kDontCare, kNoPage,                    kSkipPage       },
    { PSN_SETACTIVE,  DLG_WIZ_PRE_SELECT_DEVICE,    kDontCare,  kFalse,      kDontCare, kNoPage,                    kPop            },

    { PSN_SETACTIVE,  DLG_WIZ_POST_SELECT_DEVICE,   kDontCare,  kDontCare,   kFalse,    kNoPage,                    kSkipPage       },
    { PSN_SETACTIVE,  DLG_WIZ_POST_SELECT_DEVICE,   kFalse,     kDontCare,   kTrue,     DLG_WIZ_DRIVER_ARCHITECTURE,kPush           },
    { PSN_SETACTIVE,  DLG_WIZ_POST_SELECT_DEVICE,   kTrue,      kDontCare,   kTrue,     DLG_WIZ_DRIVER_END,         kPush           },

    { PSN_SETACTIVE,  DLG_WIZ_DRIVER_INTRO,         kDontCare,  kDontCare,   kDontCare, PSWIZB_NEXT,                kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_DRIVER_ARCHITECTURE,  kDontCare,  kDontCare,   kDontCare, PSWIZB_BACK | PSWIZB_NEXT,  kSetButtonState },
    { PSN_SETACTIVE,  DLG_WIZ_DRIVER_END,           kDontCare,  kDontCare,   kDontCare, PSWIZB_BACK | PSWIZB_FINISH,kSetButtonState },

    { PSN_WIZBACK,    kDontCare,                    kDontCare,  kDontCare,   kDontCare, kNoPage,                    kPop            },

    { kEnd }};

    //
    // Scan for a message match, disregarding don't care fields.
    //
    for( DriverWizPageEntry *pTable = Table; pTable->uMessage != kEnd; pTable++ )
    {
        DriverWizPageEntry Entry;

        Entry.uMessage      = uMsg;
        Entry.uSkipArchPage = pTable->uSkipArchPage == kDontCare ? kDontCare : _pWizard->bSkipArchSelection();
        Entry.uCurrentPage  = pTable->uCurrentPage  == kDontCare ? kDontCare : uGetPageId();
        Entry.uPreDir       = pTable->uPreDir       == kDontCare ? kDontCare : _pWizard->bPreDir() ? kTrue : kFalse;
        Entry.uPostDir      = pTable->uPostDir      == kDontCare ? kDontCare : _pWizard->bPostDir() ? kTrue : kFalse;

        if( pTable->uMessage        == Entry.uMessage      &&
            pTable->uCurrentPage    == Entry.uCurrentPage  &&
            pTable->uSkipArchPage   == Entry.uSkipArchPage &&
            pTable->uPreDir         == Entry.uPreDir       &&
            pTable->uPostDir        == Entry.uPostDir      )
        {
            break;
        }
    }

    //
    // If a table match was found handle the page switch.
    //
    if( pTable->uMessage != kEnd )
    {
        DBGMSG( DBG_NONE, ( "Match found Entry index %d\n" , pTable - Table ) );

        TStatusB bStatus;
        UINT uNextPage = 0;

        switch( pTable->Action )
        {
        case kPush:
            bStatus DBGCHK = _pWizard->Stack().bPush( uGetPageId() );
            uNextPage = pTable->Result;
            vSetDlgMsgResult( reinterpret_cast<LONG_PTR>(MAKEINTRESOURCE(uNextPage)) );
            break;

        case kPop:
            bStatus DBGCHK = _pWizard->Stack().bPop( &uNextPage );

            if( pTable->Result != kNoPage )
            {
                uNextPage = pTable->Result;
            }
            vSetDlgMsgResult( reinterpret_cast<LONG_PTR>(MAKEINTRESOURCE(uNextPage)) );
            break;

        case kSkipPage:
            vSetDlgMsgResult( -1 );
            break;

        case kSetButtonState:
            PropSheet_SetWizButtons( GetParent( _hDlg ), pTable->Result );
            break;

        default:
            break;
        }

        bReturn = TRUE;
    }

    return bReturn;
}

/********************************************************************

    Pre-Introduction

********************************************************************/

TWizPreIntro::
TWizPreIntro(
    TWizard *pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizPreIntro::
bHandle_SetActive(
    VOID
    )
{
    if( _pWizard->uAction() != TWizard::kPnPInstall )
    {
        PropSheet_SetTitle( GetParent( _hDlg ), PSH_DEFAULT, _pWizard->_strTitle );
    }
    else
    {
        //
        // Set the select device page title to the wizard title.
        //
        _pWizard->_Di.bSetDriverSetupPageTitle( _pWizard->_strSetupPageTitle, _pWizard->_strSetupPageSubTitle, _pWizard->_strSetupPageDescription );
    }

    return TRUE;
}

/********************************************************************

    Introduction

********************************************************************/

TWizIntro::
TWizIntro(
    TWizard *pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizIntro::
bHandle_InitDialog(
    VOID
    )
{
    TString strTemp;
    TCHAR szServerName[kDNSMax + 1];

    //
    // The fonts for the Word 97 wizard style.
    //
    SetControlFont( _pWizard->_hBigBoldFont, _hDlg, IDC_MAIN_TITLE );

    HICON hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_INFORMATION));
    if (hIcon)
    {
        HWND hwndIcon = GetDlgItem(_hDlg, IDC_ICON_INFO);
        if (hwndIcon)
        {
            SendMessage(hwndIcon, STM_SETICON, (WPARAM )hIcon, 0L);
            ShowWindow(hwndIcon, SW_SHOW);
        }
    }

    TString strUSBInfo;
    TStatusB bStatus;

    bStatus DBGCHK = strUSBInfo.bLoadString(ghInst, IDS_TEXT_USB);
    if (bStatus)
    {
        HWND hwndText = GetDlgItem(_hDlg, IDC_TEXT_USB);
        if (hwndText)
        {
            SetWindowText(hwndText, strUSBInfo);
            ShowWindow(hwndText, SW_SHOW);
        }
    }

    //
    // If we are admining a remote server, we'll change the title and text.
    // And we need to check the priviledge to add printer on remote server.
    //
    if( bIsRemote( _pWizard->pszServerName() ) )
    {
        //
        // Remove "\\" from the server name, and change the server name
        // to lower case
        //
        lstrcpy( szServerName, (LPTSTR)_pWizard->pszServerName() + 2 );
        CharLower( szServerName );

        //
        // Change "Add Printer Wizard" to "Add Printer Wizard on '%s.'"
        //
        strTemp.bLoadString( ghInst, IDS_ADD_PRINTER_TITLE_REMOTE );
        _pWizard->_strTitle.bFormat( strTemp, szServerName );

        PropSheet_SetTitle( GetParent( _hDlg ), 0, _pWizard->_strTitle );

        //
        // change the text for intro and desc to fit remote APW
        //
        strTemp.bLoadString( ghInst, IDS_ADD_PRINTER_INTRO_REMOTE );
        strTemp.bFormat( strTemp, szServerName );
        bSetEditText( _hDlg, IDC_MAIN_TITLE, strTemp );

        strTemp.bLoadString( ghInst, IDS_ADD_PRINTER_DESC_REMOTE );
        bSetEditText( _hDlg, IDC_ADD_PRINTER_DESC, strTemp );

        //
        // we don't want the user to add network connections, since that's per-user.
        // then we go directly to the port page
        //
        _pWizard->_bNet = FALSE;
        _pWizard->_bPnPAutodetect = FALSE;
        _pWizard->_bRunDetection = _pWizard->_bPnPAutodetect;
    }

    //
    // Let the wizard to initialize itself.
    //
    _pWizard->OnWizardInitro( hDlg() );

    return TRUE;
}

/********************************************************************

    Finish

********************************************************************/

TWizFinish::
TWizFinish(
    TWizard *pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizFinish::
bHandle_InitDialog(
    VOID
    )
{
    BOOL bReturn = TRUE;

    //
    // check to see if the wizard is restartable and if so
    // show the appropriate checkbox
    //
    if( _pWizard->bRestartableFromLastPage() )
    {
        _pWizard->bRestartAgain() = TRUE; // assume "On" by default
        ShowWindow( GetDlgItem( _hDlg, IDC_RESTART_WIZARD ), SW_SHOW );
    }
    vSetCheck( _hDlg, IDC_RESTART_WIZARD, _pWizard->bRestartAgain() );

    //
    // Set the commpletion text to what the title is in the pnp install case.
    //
    if( _pWizard->uAction() == TWizard::kPnPInstall )
    {
        TCHAR szBuffer [MAX_PATH] = {0};

        GetWindowText( GetParent( _hDlg ), szBuffer, COUNTOF( szBuffer ) );

        if( *szBuffer )
        {
            TStatusB bStatus;
            TString strCompletionText;
            bStatus DBGCHK = strCompletionText.bLoadString( ghInst, IDS_COMPLETING_TEXT );
            bStatus DBGCHK = strCompletionText.bFormat( strCompletionText, szBuffer );
            bStatus DBGCHK = bSetEditText( _hDlg, IDC_MAIN_TITLE, strCompletionText );
        }
    }

    //
    // The fonts for the Word 97 wizard style.
    //
    SetControlFont( _pWizard->_hBigBoldFont, _hDlg, IDC_MAIN_TITLE );

    if( _pWizard->_bConnected || _pWizard->_bPrinterAutoDetected )
    {
        //
        // Set cancel to close, since the printer connection can't
        // be undone at this point.  (We could try just deleting the
        // connection, but this doesn't undo the driver downloads, etc.
        //
        PropSheet_CancelToClose( GetParent( _hDlg ) );
    }

    if( _pWizard->_bPrinterAutoDetected )
    {
        //
        // If the printer has been autodetected at this point we don't
        // know anything but the printer name. Get all the rest of the
        // information for the finish page here.
        //
        DWORD dwAccess = PRINTER_READ;
        TStatus Status;
        HANDLE hPrinter;

        //
        // Open the printer
        //
        Status DBGCHK = TPrinter::sOpenPrinter( _pWizard->strPrinterName(), &dwAccess, &hPrinter );

        if( Status == ERROR_SUCCESS )
        {
            TStatusB bStatus;

            //
            // Get PRINTER_INFO_2 for the autodetected printer. This call
            // should be rather quick as hPrinter is a local printer.
            //
            PPRINTER_INFO_2 pInfo2  = NULL;
            DWORD           cbInfo2 = 0;

            bStatus DBGCHK = VDataRefresh::bGetPrinter( hPrinter,
                                                        2,
                                                        (PVOID*)&pInfo2,
                                                        &cbInfo2 );

            if( bStatus )
            {
                _pWizard->_strPortName.bUpdate( pInfo2->pPortName );
                _pWizard->_strDriverName.bUpdate( pInfo2->pDriverName );
                _pWizard->_strShareName.bUpdate( pInfo2->pShareName );
                _pWizard->_strLocation.bUpdate( pInfo2->pLocation );
                _pWizard->_strComment.bUpdate( pInfo2->pComment );

                //
                // Check default printer
                //
                _pWizard->_bSetDefault = (kDefault == CheckDefaultPrinter(_pWizard->strPrinterName()));
            }


            //
            // Release the printer info 2 structure and close
            // the printer handle.
            //
            FreeMem( pInfo2 );
            ClosePrinter( hPrinter );

            bReturn = bStatus;
        }
        else
        {
            bReturn = FALSE;
        }

    }

    return TRUE;
}

BOOL
TWizFinish::
bHandle_SetActive(
    VOID
    )
{
    if( _pWizard->_bConnected && !_pWizard->_bIsPrinterFolderEmpty )
    {
        PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_FINISH );
    }
    else
    {
        PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_BACK | PSWIZB_FINISH );
    }

    TStatusB bStatus;
    TString strShareName;
    TString strConShareName;
    TString strAsDefault;
    TString strPrintTestPage;

    bStatus DBGCHK = _pWizard->_bShared      ? strShareName.bUpdate( _pWizard->_strShareName )   : strShareName.bLoadString( ghInst, IDS_NOT_SHARED );
    bStatus DBGCHK = _pWizard->_bSetDefault  ? strAsDefault.bLoadString( ghInst, IDS_YES )       : strAsDefault.bLoadString( ghInst, IDS_NO );
    bStatus DBGCHK = _pWizard->_bTestPage    ? strPrintTestPage.bLoadString( ghInst, IDS_YES )   : strPrintTestPage.bLoadString( ghInst, IDS_NO );

    BOOL bShared = _pWizard->_bConnected ? FALSE : !_pWizard->_bShared;

    LPCTSTR pszServer;
    LPCTSTR pszPrinter;
    TCHAR szScratch[kStrMax+kPrinterBufMax];
    TString strPrinterFriendlyName;
    UINT nSize = COUNTOF( szScratch );

    //
    // Split the printer name into its components.
    //
    vPrinterSplitFullName( szScratch, _pWizard->_strPrinterName, &pszServer, &pszPrinter );

    //
    // If share name is empty then indicate the printer is not shared.
    //
    if( _pWizard->_strShareName.bEmpty() )
    {
        strConShareName.bLoadString( ghInst, IDS_NOT_SHARED );
    }
    else
    {
        bBuildFullPrinterName( pszServer, _pWizard->_strShareName, strConShareName );
    }

    if( _pWizard->_bConnected )
    {
        //
        // Create the formatted printer friendly name, when adding connections
        // or the masq printer.
        //
        ConstructPrinterFriendlyName( (LPCTSTR)_pWizard->_strPrinterName, szScratch, &nSize );
        strPrinterFriendlyName.bUpdate( szScratch );
    }

    struct TextInfo
    {
        BOOL    bType;
        UINT    Id;
        LPCTSTR pszText;
    };

    TextInfo aText [] = {
                        { FALSE, IDC_PORT_NAME_TEXT,            NULL },
                        { FALSE, IDC_PORT_NAME_SUMMARY,         _pWizard->_strPortName },

                        { FALSE, IDC_SET_AS_DEFAULT_TEXT,       NULL },
                        { FALSE, IDC_SET_AS_DEFAULT_SUMMARY,    strAsDefault },

                        { FALSE, IDC_PRINTER_NAME_TEXT,         NULL },
                        { FALSE, IDC_PRINTER_NAME_SUMMARY,      _pWizard->_strPrinterName },

                        { FALSE, IDC_MODEL_NAME_TEXT,           NULL },
                        { FALSE, IDC_MODEL_NAME_SUMMARY,        _pWizard->_strDriverName },

                        { FALSE, IDC_SHARE_NAME_TEXT,           NULL },
                        { FALSE, IDC_SHARE_NAME_SUMMARY,        strShareName },

                        { FALSE, IDC_PRINT_TEST_PAGE_TEXT,      NULL },
                        { FALSE, IDC_PRINT_TEST_PAGE_SUMMARY,   strPrintTestPage },

                        { bShared, IDC_LOCATION_TEXT,           NULL },
                        { bShared, IDC_LOCATION_SUMMARY,        _pWizard->_strLocation },

                        { bShared, IDC_COMMENT_TEXT,            NULL },
                        { bShared, IDC_COMMENT_SUMMARY,         _pWizard->_strComment },

                        { FALSE, IDC_COMPLETION_TEXT,           NULL },
                        { FALSE, IDC_CLICK_TO_ADD_TEXT,         NULL },

                        { TRUE,  IDC_CONNECTION_TEXT,           NULL },
                        { TRUE,  IDC_CONNECTION_SUMMARY,        strPrinterFriendlyName },

                        { TRUE,  IDC_CON_COMMENT_TEXT,          NULL },
                        { TRUE,  IDC_CON_COMMENT_SUMMARY,       _pWizard->_strComment },

                        { TRUE,  IDC_CON_LOCATION_TEXT,         NULL },
                        { TRUE,  IDC_CON_LOCATION_SUMMARY,      _pWizard->_strLocation },

                        { TRUE,  IDC_CON_SET_DEFAULT_TEXT,      NULL },
                        { TRUE,  IDC_CON_SET_DEFAULT_SUMMARY,   strAsDefault },

                        { TRUE,  IDC_CON_COMPLETION_TEXT,       NULL },
                        { TRUE,  IDC_CON_CLICK_TO_ADD_TEXT,     NULL }};


    //
    // Hide or show the controls, whether we have connection or local printer install.
    //
    for( UINT i = 0; i < COUNTOF( aText ); i++ )
    {
        if( _pWizard->_bConnected )
        {
            ShowWindow( GetDlgItem( _hDlg, aText[i].Id ), aText[i].bType ? SW_NORMAL : SW_HIDE );
        }
        else
        {
            ShowWindow( GetDlgItem( _hDlg, aText[i].Id ), aText[i].bType ? SW_HIDE : SW_NORMAL );
        }

        if( aText[i].pszText )
        {
            bStatus DBGCHK = bSetEditText( _hDlg, aText[i].Id, aText[i].pszText );
        }
    }

    return TRUE;
}

BOOL
TWizFinish::
bHandle_WizFinish(
    VOID
    )
{
    BOOL bCloseOnError =(_pWizard->_bConnected || _pWizard->_bPrinterAutoDetected);
    _pWizard->bRestartAgain() = bGetCheck( _hDlg, IDC_RESTART_WIZARD );

    if( !_pWizard->_bPrinterAutoDetected )
    {
        //
        // If an error occurred saving a setting
        //
        if( _pWizard->bErrorSaving() )
        {
            iMessage( _hDlg,
                      IDS_ERR_ADD_PRINTER_TITLE,
                      IDS_ERR_ERROR_SAVING,
                      MB_OK|MB_ICONSTOP,
                      kMsgNone,
                      NULL );
            //
            // Policy question, is it correct to prevent switching
            // or closing the wizard if an error occurred saving.
            //
            _pWizard->bNoPageChange() = !bCloseOnError;
        }
        else
        {
            //
            // If we are not doing a network install, install the printer
            // and print a test page.
            //
            if( !_pWizard->bNet( ) )
            {
                //
                // Create the printer.
                //
                _pWizard->bPrinterCreated() = _pWizard->bCreatePrinter( _hDlg );

                //
                // If the printer failed creation, keep the wizard up and
                // stay on this page.
                //
                if( !_pWizard->bPrinterCreated() )
                {
                    //
                    // Something failed stay on this page.
                    //
                    _pWizard->bNoPageChange() = !bCloseOnError;
                }
                else
                {
                    if( _pWizard->_bTestPage )
                    {
                        //
                        // Print this printers test page.
                        //
                        _pWizard->bPrintTestPage();
                    }
                }
            }
        }

        //
        // If a printer was created or connected to
        // and the set as default was requested and
        // we are not adding a printer remotely
        //
        if( ( _pWizard->bPrinterCreated() || _pWizard->bConnected() ) &&
            _pWizard->bSetDefault() && !_pWizard->pszServerName() )
        {
            //
            // Set the default printer.
            //
            if( !SetDefaultPrinter( _pWizard->strPrinterName() )){

                iMessage( _hDlg,
                          IDS_ERR_ADD_PRINTER_TITLE,
                          IDS_ERR_SET_DEFAULT_PRINTER,
                          MB_OK|MB_ICONHAND,
                          kMsgNone,
                          NULL );

                _pWizard->bNoPageChange() = !bCloseOnError;
            }
        }
    }
    else
    {
        //
        // Only print the test page if necessary
        //
        if( _pWizard->_bTestPage )
        {
            //
            // Print this printers test page.
            //
            _pWizard->bPrintTestPage();
        }
    }

    //
    // Let the wizard cleanup here.
    //
    _pWizard->OnWizardFinish( _hDlg );

    return TRUE;
}

/********************************************************************

    Type of printer: local or network.

********************************************************************/

TWizType::
TWizType(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizType::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Set the default control id.
    //
    INT idcDefault = _pWizard->_bNet ? IDC_NET : IDC_LOCAL;

    if (FALSE == _pWizard->_bAdminPrivilege)
    {
        idcDefault = IDC_NET;
        vEnableCtl(_hDlg, IDC_LOCAL, FALSE);
        vEnableCtl(_hDlg, IDC_KICKOFF_PNP_REFRESH, FALSE);
    }

    //
    // Initialize the default value from the sticky settings
    //
    vSetCheck( _hDlg, IDC_KICKOFF_PNP_REFRESH, _pWizard->_bPnPAutodetect );

    //
    // If the network is not loaded then do not show the net selection.
    //
    if( !_pWizard->bNetworkInstalled() )
    {
        idcDefault = IDC_LOCAL;
        ShowWindow( GetDlgItem( _hDlg, IDC_NET ),       SW_HIDE );
    }

    HICON hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_INFORMATION));
    if (hIcon)
    {
        HWND hwndIcon = GetDlgItem(_hDlg, IDC_ICON_INFO);
        if (hwndIcon)
        {
            SendMessage(hwndIcon, STM_SETICON, (WPARAM )hIcon, 0L);
            ShowWindow(hwndIcon, SW_SHOW);
        }
    }

    //
    // Set the default button.
    //
    bStatus DBGCHK = CheckRadioButton( _hDlg, IDC_LOCAL, IDC_NET, idcDefault );

    //
    // Initially enable/disable the PnP refresh checkbox
    // regardless of the fact if it is visible or not
    //
    vEnableCtl( _hDlg, IDC_KICKOFF_PNP_REFRESH,
        NULL == _pWizard->pszServerName( ) &&       // Not in the remote case
        _pWizard->_bAdminPrivilege &&               // Have admin privileges
        IDC_LOCAL == idcDefault );                  // We are in the local case

    return bStatus;
}

BOOL
TWizType::
bHandle_SetActive(
    VOID
    )
{
    vSetCheck( _hDlg, IDC_KICKOFF_PNP_REFRESH, _pWizard->_bPnPAutodetect );
    return TRUE;
}

VOID
TWizType::
vReadUI(
    VOID
    )

/*++

Routine Description:

    Save the state the user has set in the UI elements into _pWizard.

Arguments:

Return Value:

--*/

{
    _pWizard->_bNet = ( IsDlgButtonChecked( _hDlg, IDC_NET ) == BST_CHECKED );
    _pWizard->_bPnPAutodetect = bGetCheck( _hDlg, IDC_KICKOFF_PNP_REFRESH );
    _pWizard->_bRunDetection = _pWizard->_bPnPAutodetect;
}


BOOL
TWizType::
bConnectToPrinter(
    IN HWND     hDlg,
    IN TString &strPrinterName,
    IN TString *pstrComment,
    IN TString *pstrLocation,
    IN TString *pstrShareName
    )
/*++

Routine Description:

    Browse and connect to a printer.

Arguments:

Return Value:

Notes:
    This is a static function, other wizard pages
    use this funtion to invoke the printer browser.

--*/
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    //
    // Call the ConnectToPrinterDlg to browse for a printer.
    //
    HANDLE hPrinter = ConnectToPrinterDlg( hDlg, 0 );

    if( hPrinter )
    {
        //
        // Get the printer name from the handle so we can
        // pass it back to the user.
        //
        PPRINTER_INFO_2 pInfo2  = NULL;
        DWORD           cbInfo2 = 0;

        bStatus DBGCHK = VDataRefresh::bGetPrinter( hPrinter,
                                                    2,
                                                    (PVOID*)&pInfo2,
                                                    &cbInfo2 );
        //
        // Printer connection made copy back the new printer name.
        //
        if( bStatus )
        {
            bStatus DBGCHK = strPrinterName.bUpdate( pInfo2->pPrinterName );

            if( pstrLocation )
                pstrLocation->bUpdate( pInfo2->pLocation );

            if( pstrComment )
                pstrComment->bUpdate( pInfo2->pComment );

            if( pstrShareName )
                pstrShareName->bUpdate( pInfo2->pShareName );

        }

        //
        // If the printer name could not be found don't indicate
        // a failure and fail to switch pages.
        //
        bStatus DBGNOCHK = TRUE;

        FreeMem( pInfo2 );

        ClosePrinter( hPrinter );
    }

    return bStatus;

}

BOOL
TWizType::
bHandle_WizNext(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Read the information from the UI controls.
    //
    vReadUI();

    //
    // If we are not in the remote case and the user is
    // attempting to install printer locally and the PnP
    // is selcted then kick off the PnP enumeration event
    //
    if( !_pWizard->_bNet &&
        bGetCheck( _hDlg, IDC_KICKOFF_PNP_REFRESH ) )
    {
        //
        // Autodetection has been slected. Kick off the
        // PnP enumeration here before going to the next page
        //
    }

    //
    // We are advancing to the next page.  For network installs,
    // and the DS is installed then jump to the locate / browse page.
    //
    if( _pWizard->bNet( ) )
    {
        //
        // Check if the Directory Service is installed and available.
        //
        if( _pWizard->_eIsDsAvailablePerUser == TWizard::kDsStatusUnknown )
        {
            TWaitCursor Cur;
            _pWizard->_eIsDsAvailablePerUser = _pWizard->_Ds.bIsDsAvailable() ? TWizard::kDsStatusAvailable : TWizard::kDsStatusUnavailable;
        }
    }

    return TRUE;
}

BOOL
TWizType::
bHandle_Command(
    IN WORD wId,
    IN WORD wNotifyId,
    IN HWND hwnd
    )
{
    BOOL bStatus = (NULL == _pWizard->pszServerName( ));

    if( bStatus )
    {
        switch( wId )
        {
            case IDC_LOCAL:
            case IDC_NET:
                {
                    //
                    // Check to enable/disable PnP refresh if "Network"
                    // printer is selected
                    //
                    EnableWindow( GetDlgItem( _hDlg, IDC_KICKOFF_PNP_REFRESH ),   wId == IDC_LOCAL );
                }
                break;

            default:
                bStatus = FALSE;
                break;
        }
    }

    return bStatus;
}

/********************************************************************

    Auto detect: show the autodetection progress

********************************************************************/

TWizDetect::
TWizDetect(
    TWizard* pWizard
    ):  MWizardProp( pWizard )
{
}

VOID
TWizDetect::
vReadUI(
    VOID
    )
{
    if( _pWizard->_bPrinterAutoDetected )
    {
        //
        // Read the test page setting from the ui.
        //
        if( IsDlgButtonChecked( _hDlg, IDC_RADIO_YES ) == BST_CHECKED )
        {
            _pWizard->_bTestPage = TRUE;
        }
        else
        {
            _pWizard->_bTestPage = FALSE;
        }
    }
}

BOOL
TWizDetect::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Set the test page setting and hide the controls.
    //
    INT iValueId = _pWizard->bTestPage() ? IDC_RADIO_YES : IDC_RADIO_NO;
    bStatus DBGCHK = CheckRadioButton( _hDlg, IDC_RADIO_YES, IDC_RADIO_NO, iValueId );

    vToggleTestPageControls( SW_HIDE );

    //
    // Load the animation
    //
    HWND hwndAnimation = GetDlgItem( _hDlg, IDC_DETECT_ANIMATE );
    Animate_Open( hwndAnimation, MAKEINTRESOURCE( IDA_INSPECT ) );

    return TRUE;
}

BOOL
TWizDetect::
bHandle_SetActive(
    VOID
    )
{
    if( _pWizard->_bPrinterAutoDetected )
    {
        //
        // The printer has been autodetected and installed already.
        // Enable only Next button
        //
        PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT );
    }
    else
    {
        if( _pWizard->_bRunDetection && !pnpPrinterDetector().bDetectionInProgress( ) )
        {
            TStatusB bStatus;

            //
            // Show the wait cursor
            //
            TWaitCursor wait;

            //
            // Show/Hide some controls appropriately
            //
            ShowWindow( GetDlgItem( _hDlg, IDC_ICON_DETECT_PRINTER ), SW_HIDE );
            ShowWindow( GetDlgItem( _hDlg, IDC_DETECT_STATUS ),       SW_HIDE );
            ShowWindow( GetDlgItem( _hDlg, IDC_TEXT_DETECT_INFO ),    SW_SHOW );

            //
            // Disable Back & Next wizard buttons
            //
            PropSheet_SetWizButtons( GetParent( _hDlg ), 0 );

            //
            // Kick off the PnP enumeration event
            //
            bStatus DBGCHK = pnpPrinterDetector().bKickOffPnPEnumeration();


            if( bStatus )
            {
                //
                // Stop the animation
                //
                vStartAnimation( );

                //
                // Setup the polling timer to hit on each POLLING_TIMER_INTERVAL
                //
                SetTimer( _hDlg, POLLING_TIMER_ID, POLLING_TIMER_INTERVAL, NULL );
            }
            else
            {
                //
                // PnP enumeration failed. We need to handle this case properly.
                // This actually shouldn't never happen, but if it happens somehow
                // we don't want to mess up the UI.
                //
                LPCTSTR pszIconName = NULL;
                TString strStatus;

                //
                // Revert the buttons in case of failure
                //
                PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_BACK | PSWIZB_NEXT );

                bStatus DBGCHK = strStatus.bLoadString( ghInst, IDS_TEXT_DETECT_FAILURE );
                pszIconName = MAKEINTRESOURCE( IDI_WARNING );

                //
                // Don't run the detection process any more until
                // the user goes to the prev page (TWizType).
                //
                _pWizard->_bRunDetection = FALSE;

                //
                // Show/Hide some controls appropriately
                //
                ShowWindow( GetDlgItem( _hDlg, IDC_TEXT_DETECT_INFO ),    SW_HIDE );
                ShowWindow( GetDlgItem( _hDlg, IDC_DETECT_STATUS ),       SW_SHOW );

                //
                // Check to load and show the approprate icon.
                //
                if( pszIconName )
                {
                    HICON hIcon = LoadIcon( NULL, pszIconName );

                    if( hIcon )
                    {
                        HWND hwndIcon = GetDlgItem( _hDlg, IDC_ICON_DETECT_PRINTER );
                        SendMessage( hwndIcon, STM_SETICON, (WPARAM )hIcon, 0L );
                        ShowWindow( hwndIcon, SW_SHOW );
                    }
                }

                //
                // Show the failed status text.
                //
                bStatus DBGCHK = SetWindowText( GetDlgItem( _hDlg, IDC_DETECT_STATUS ), strStatus );
            }
        }
    }

    return TRUE;
}

BOOL
TWizDetect::
bHandle_WizNext(
    VOID
    )
{
    vReadUI();
    return TRUE;
}

BOOL
TWizDetect::
bHandle_Cancel(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Stop the animation & kill the polling timer.
    //
    vStartAnimation( FALSE );
    bStatus DBGCHK = KillTimer( _hDlg, POLLING_TIMER_ID );

    return TRUE;
}

BOOL
TWizDetect::
bHandle_Timer(
    IN WPARAM     wIdTimer,
    IN TIMERPROC *tmProc
    )
{
    TStatusB bStatus;
    TString  strStatus, strPrinterName;

    bStatus DBGNOCHK = FALSE;
    BOOL bResult = FALSE;

    if( POLLING_TIMER_ID == wIdTimer )
    {
        //
        // If PnP printer detection process is in progress ...
        //
        if( pnpPrinterDetector().bDetectionInProgress( ) )
        {
            //
            // Ping the PnP detection/installation process to see whether
            // it has finished?
            //
            if( pnpPrinterDetector().bFinished( ) )
            {
                LPCTSTR pszIconName = NULL;

                //
                // Show wait cursor because the following operation below might
                // take some time.
                //
                TWaitCursor wait;

                //
                // Check whether the detection/installation is successful or not.
                //
                if( pnpPrinterDetector().bGetDetectedPrinterName( &strPrinterName ) )
                {
                    //
                    // The detect/install process was successful.
                    //
                    _pWizard->_bPrinterAutoDetected = TRUE;
                    bStatus DBGCHK = strStatus.bLoadString( ghInst, IDS_TEXT_DETECT_SUCCESS );
                    pszIconName = MAKEINTRESOURCE( IDI_INFORMATION );

                    //
                    // The printer is installed here, so there is no point Back and
                    // Cancel buttons.
                    //
                    PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT );
                    PropSheet_CancelToClose( GetParent( _hDlg ) );

                    //
                    // Show the test page controls
                    //
                    vToggleTestPageControls( SW_SHOW );

                    //
                    // Select the first control with WS_TABSTOP style
                    SendMessage( _hDlg, WM_NEXTDLGCTL, 0, (LPARAM )FALSE );

                    //
                    // Here must setup all the parameters configured from PnP
                    // before jump to the finish page. Done forget to disable
                    // Back and Cancel buttons.
                    //

                    bStatus DBGCHK = _pWizard->_strPrinterName.bUpdate( strPrinterName );
                }
                else
                {
                    //
                    // The detect/install process *was not* successful.
                    //
                    bStatus DBGCHK = strStatus.bLoadString( ghInst, IDS_TEXT_DETECT_FAILURE );
                    pszIconName = MAKEINTRESOURCE( IDI_WARNING );

                    PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_BACK | PSWIZB_NEXT );
                }

                //
                // Don't run the detection process any more until
                // the user goes to the prev (type) page.
                //
                _pWizard->_bRunDetection = FALSE;

                //
                // Show/Hide some controls appropriately
                //
                ShowWindow( GetDlgItem( _hDlg, IDC_TEXT_DETECT_INFO ),    SW_HIDE );
                ShowWindow( GetDlgItem( _hDlg, IDC_DETECT_STATUS ),       SW_SHOW );

                //
                // Check to load and show the approprate icon.
                //
                if( pszIconName )
                {
                    HICON hIcon = LoadIcon( NULL, pszIconName );

                    if( hIcon )
                    {
                        HWND hwndIcon = GetDlgItem( _hDlg, IDC_ICON_DETECT_PRINTER );
                        SendMessage( hwndIcon, STM_SETICON, (WPARAM )hIcon, 0L );
                        ShowWindow( hwndIcon, SW_SHOW );
                    }
                }

                //
                // Kill the timer and show the status text.
                //
                bStatus DBGCHK = KillTimer( _hDlg, POLLING_TIMER_ID );
                bStatus DBGCHK = SetWindowText( GetDlgItem( _hDlg, IDC_DETECT_STATUS ), strStatus );

                //
                // Stop the animation
                //
                vStartAnimation( FALSE );
            }
        }

        // Message is processed
        bResult = TRUE;
    }

    return bResult;
}

VOID
TWizDetect::
vToggleTestPageControls(
    int nCmdShow
    )
/*++

Routine Description:

    Toggles the visibility state of the test
    page controls.

Arguments:

    nCmdShow - Whether to show or hide the controls.

Return Value:

    None.

--*/
{
    static DWORD arrTestPageControls[] =
    {
        IDC_TEST_PAGE_QUESTION,
        IDC_RADIO_YES,
        IDC_RADIO_NO
    };

    for( UINT i = 0; i < COUNTOF( arrTestPageControls ); ++i )
    {
        ShowWindow( GetDlgItem( _hDlg, arrTestPageControls[i] ), nCmdShow );
    }
}

VOID
TWizDetect::
vStartAnimation(
    BOOL bStart
    )
/*++

Routine Description:

    Toggles the animation control between
    show and play/hide and stop play mode

Arguments:

    bStart - Start or stop the animation.

Return Value:

    None.

--*/
{
    HWND hwndAnimation = GetDlgItem( _hDlg, IDC_DETECT_ANIMATE );
    ShowWindow( hwndAnimation, bStart ? SW_SHOW : SW_HIDE );

    if( bStart )
    {
        //
        // Request to start the animation
        //
        Animate_Play( hwndAnimation, 0, -1, -1 );
    }
    else
    {
        //
        // Request to stop the animation
        //
        Animate_Stop( hwndAnimation );
    }
}

/********************************************************************

    Driver Exists dialog.

********************************************************************/

TWizDriverExists::
TWizDriverExists(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizDriverExists::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Determine what the default setting to use.
    //
    INT iValueId = _pWizard->bUseNewDriverSticky() ? IDC_DRIVEREXISTS_USE_NEW : IDC_DRIVEREXISTS_KEEP_OLD;

    //
    // By default, use existing driver.
    //
    bStatus DBGCHK = CheckRadioButton( _hDlg,
                                       IDC_DRIVEREXISTS_KEEP_OLD,
                                       IDC_DRIVEREXISTS_USE_NEW,
                                       iValueId );
    //
    // Set the page title.
    //
    if( _pWizard->uAction() == TWizard::kDriverInstall )
    {
        PropSheet_SetTitle( GetParent( _hDlg ), 0, IDS_DRIVER_WIZ_TITLE );
        PropSheet_SetTitle( _hDlg, 0, IDS_DRIVER_WIZ_TITLE );
    }

    return bStatus;
}

VOID
TWizDriverExists::
vReadUI(
    VOID
    )

/*++

Routine Description:

    Save the state the user has set in the UI elements into _pWizard.

Arguments:

Return Value:

--*/

{
    _pWizard->bUseNewDriverSticky() = IsDlgButtonChecked( _hDlg, IDC_DRIVEREXISTS_USE_NEW ) == BST_CHECKED;
    _pWizard->bUseNewDriver() = _pWizard->bUseNewDriverSticky();
}

BOOL
TWizDriverExists::
bHandle_SetActive(
    VOID
    )
{
    //
    // Set the driver name in the page.
    //
    bSetEditText( _hDlg, IDC_DRIVEREXISTS_TEXT, _pWizard->strDriverName() );
    return TRUE;
}

BOOL
TWizDriverExists::
bHandle_WizNext(
    VOID
    )
{
    vReadUI();
    return TRUE;
}

/********************************************************************

    Port selection.

********************************************************************/

TWizPort::
TWizPort(
    TWizard* pWizard
    ) : MWizardProp( pWizard ),
        _hMonitorList( NULL )
{
}

BOOL
TWizPort::
bValid(
    VOID
    )
{
    return MGenericProp::bValid() && _PortsLV.bValid();
}

BOOL
TWizPort::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Initialize the monitor list.
    //
    if( !bInitializeMonitorList() )
    {
        DBGMSG( DBG_WARN, ( "bInitializeMonitorList failed %d\n", GetLastError( )));
        vShowUnexpectedError( _pWizard->hwnd(), IDS_ERR_ADD_PRINTER_TITLE );
        return FALSE;
    }

    //
    // Initialize the ports list view.  No user selcection and two column mode.
    //
    if( !_PortsLV.bSetUI( GetDlgItem( _hDlg, IDC_PORTS ), FALSE, FALSE, TRUE, _hDlg, IDC_PORT_DOUBLE_CLICKED ) )
    {
        DBGMSG( DBG_WARN, ( "PortsLV.bSetUI failed %d\n", GetLastError( )));
        vShowUnexpectedError( _pWizard->hwnd(), IDS_ERR_ADD_PRINTER_TITLE );
        return FALSE;
    }

    //
    // Load ports into the view.
    //
    if( !_PortsLV.bReloadPorts( _pWizard->pszServerName( ) ))
    {
        DBGMSG( DBG_WARN, ( "PortsLV.bReloadPorts failed %d\n", GetLastError( )));
        vShowUnexpectedError( _pWizard->hwnd(), IDS_ERR_ADD_PRINTER_TITLE );
        return FALSE;
    }

    //
    // Select the default port.  Note the default port does not exist
    // as a valid port then no port will be selected as the default.
    //
    bStatus DBGCHK = _pWizard->_strPortName.bLoadString( ghInst, IDS_DEFAULT_PORT );

    //
    // Check the existing port by default.
    //
    CheckRadioButton( _hDlg, IDC_PORT_OTHER, IDC_PORT_EXISTING, IDC_PORT_EXISTING );

    //
    // Do any of the port selection action.
    //
    PostMessage( _hDlg, WM_COMMAND, MAKELPARAM( IDC_PORT_EXISTING, 0 ), (LPARAM)GetDlgItem( _hDlg, IDC_PORT_EXISTING ) );

    return TRUE;
}

BOOL
TWizPort::
bHandle_Notify(
    IN WPARAM   wParam,
    IN LPNMHDR  pnmh
    )
{
    return _PortsLV.bHandleNotifyMessage( (LPARAM)pnmh );
}

BOOL
TWizPort::
bHandle_WizNext(
    VOID
    )
{
    if( IsDlgButtonChecked( _hDlg, IDC_PORT_EXISTING ) == BST_CHECKED )
    {
        vSelectionPort();
    }
    else
    {
        vSelectionMonitor();
    }
    return TRUE;
}

BOOL
TWizPort::
bHandle_SetActive(
    VOID
    )
{
    //
    // Select the default port.
    //
    _PortsLV.vSelectPort( _pWizard->_strPortName );

    //
    // If the port monitor is the select radio button,
    // then ensure the list view is disable, problem
    // is vSelectPort sets the selection state.
    //
    if( IsDlgButtonChecked( _hDlg, IDC_PORT_OTHER ) == BST_CHECKED )
    {
        _PortsLV.vDisable( TRUE );
    }

    return TRUE;
}

BOOL
TWizPort::
bHandle_Command(
    IN WORD wId,
    IN WORD wNotifyId,
    IN HWND hwnd
    )
{
    BOOL bStatus = TRUE;

    switch( wId )
    {
    case IDC_PORT_EXISTING:
        _PortsLV.vEnable( TRUE );
        _PortsLV.vSetFocus();
        vDisableMonitorList();
        break;

    case IDC_PORT_OTHER:
        _PortsLV.vDisable( TRUE );
        vEnableMonitorList();
        vSetFocusMonitorList();
        break;

    case IDC_PORT_DOUBLE_CLICKED:
        PropSheet_PressButton( GetParent( _hDlg ), PSBTN_NEXT );
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}

VOID
TWizPort::
vSelectionPort(
    VOID
    )
{
    if( !_PortsLV.bReadUI( _pWizard->_strPortName, TRUE ) )
    {
        //
        // Put up error explaining that at least one
        // port must be selected.
        //
        iMessage( _hDlg,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_NO_PORTS,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        //
        // Set focus to ports LV.
        //
        _PortsLV.vSetFocus();

        //
        // Remain on this page, do not switch.
        //
        _pWizard->bNoPageChange() = TRUE;
    }
}

/********************************************************************

    Monitor related members.

********************************************************************/

BOOL
TWizPort::
bInitializeMonitorList(
    VOID
    )
{
    //
    // Get and save the monitor list handle.
    //
    _hMonitorList = GetDlgItem( _hDlg, IDC_MONITOR_LIST );
    SPLASSERT( _hMonitorList );

    //
    // Clear the monitor list.
    //
    ComboBox_ResetContent( _hMonitorList );

    //
    // Enumerate the monitors.
    //
    TStatusB        bStatus;
    DWORD           cbMonitors  = 0;
    PMONITOR_INFO_1 pMonitors   = NULL;
    DWORD           cMonitors   = 0;

    bStatus DBGCHK = VDataRefresh::bEnumMonitors( _pWizard->_strServerName,
                                                  1,
                                                  (PVOID *)&pMonitors,
                                                  &cbMonitors,
                                                  &cMonitors );

    if( bStatus )
    {
        for( UINT i = 0; i < cMonitors; i++ )
        {
            BOOL bAddMonitor = TRUE;

            //
            // If we are on a remote machine check if the monitor
            // supports remoteable calls.  Only remoteable monitors
            // should show up in the combobox.
            //
            if( bIsRemote( _pWizard->_strServerName ) )
            {
                bAddMonitor = bIsRemoteableMonitor( pMonitors[i].pName );
            }

            //
            // Hide the fax monitor, users are not allowed to
            // create fax printer from the add printer wizard.
            //
            bAddMonitor = _tcsicmp( pMonitors[i].pName, FAX_MONITOR_NAME );

            if( bAddMonitor )
            {
                ComboBox_AddString( _hMonitorList, pMonitors[i].pName );
            }
        }

        ComboBox_SetCurSel( _hMonitorList, 0 );
    }

    FreeMem( pMonitors );

    //
    // If there are no monitors in the list, hide the UI.
    // This is possible if all the monitors are not remoteable
    //
    BOOL bDisableMonitorUI = !ComboBox_GetCount( _hMonitorList );

    //
    // Adding ports remotely is not supported on downlevel machines.
    //
    if( bIsRemote( _pWizard->_strServerName ) )
    {
        if( _pWizard->_Di.dwGetCurrentDriverVersion( ) <= 2 )
        {
            bDisableMonitorUI = TRUE;
        }
    }

    //
    // Hide the monitor UI.
    //
    if( bDisableMonitorUI )
    {
        EnableWindow( _hMonitorList, FALSE);
        EnableWindow( GetDlgItem( _hDlg, IDC_MONITOR_TEXT ), FALSE );
        EnableWindow( GetDlgItem( _hDlg, IDC_PORT_OTHER ), FALSE );
    }

    return bStatus;
}

BOOL
TWizPort::
bGetSelectedMonitor(
    IN TString &strMonitor
    )
{
    return bGetEditText( _hDlg, IDC_MONITOR_LIST, strMonitor );
}

VOID
TWizPort::
vEnableMonitorList(
    VOID
    )
{
    EnableWindow( _hMonitorList, TRUE );
    EnableWindow( GetDlgItem( _hDlg, IDC_MONITOR_TEXT ), TRUE );
}

VOID
TWizPort::
vDisableMonitorList(
    VOID
    )
{
    EnableWindow( _hMonitorList, FALSE );
    EnableWindow( GetDlgItem( _hDlg, IDC_MONITOR_TEXT ), FALSE );
}

VOID
TWizPort::
vSetFocusMonitorList(
    VOID
    )
{
    SetFocus( _hMonitorList );
}

BOOL
TWizPort::
bIsRemoteableMonitor(
    IN LPCTSTR pszMonitorName
    )
{
    //
    // !!LATER!!
    // Add private winspool.drv interface to check if a
    // port monitor is remoteable.
    //
    return TRUE;
}

VOID
TWizPort::
vSelectionMonitor(
    VOID
    )
{
    TString strMonitor;

    if( bGetSelectedMonitor( strMonitor ) )
    {
        TStatusB bStatus;

        //
        // Add the port using the selected montior.
        //
        bStatus DBGCHK = AddPort( (LPTSTR)(LPCTSTR)_pWizard->_pszServerName,
                                  _hDlg,
                                  (LPTSTR)(LPCTSTR)strMonitor );

        DBGMSG( DBG_TRACE, ( "AddPort returned %d GLE %d\n", bStatus, GetLastError( )));

        if( !bStatus )
        {
            //
            // If not a cancel request then display error message.
            //
            if( GetLastError() != ERROR_CANCELLED )
            {
                extern MSG_ERRMAP gaMsgErrMapPorts[];

                iMessage( _hDlg,
                          IDS_ERR_ADD_PRINTER_TITLE,
                          IDS_ERR_ADD_PORT,
                          MB_OK|MB_ICONSTOP,
                          kMsgGetLastError,
                          gaMsgErrMapPorts );
            }

            _pWizard->bNoPageChange() = TRUE;
        }
        else
        {
            //
            // Locate the added port
            //
            bStatus DBGCHK = _PortsLV.bLocateAddedPort( _pWizard->pszServerName(),
                                                        _pWizard->_strPortName );
            //
            // We are here because: The monitor returned success but
            // did not add a new port.  The whole monitor error reporting path
            // is totaly busted.  Monitors are returning success even if they don't
            // add a port.  They are also displaying error UI and then returning
            // a success.  It is impossible to know what they did and how to react.
            // Therefore I am going to just silently fail, hopeing the monitor
            // writers display a reasonable error message if something went wrong.
            //
            if( !bStatus )
            {
                //
                // Remain on this page, do not switch.
                //
                _pWizard->bNoPageChange() = TRUE;

                //
                // Restore the focus to the monitor list
                //
                SetFocus( GetDlgItem( _hDlg, IDC_MONITOR_LIST ));
            }
            else
            {
                //
                // Reload the ports list view.
                //
                bStatus DBGCHK = _PortsLV.bReloadPorts( _pWizard->pszServerName() );

                //
                // Check the existing port since a new port was added.
                //
                CheckRadioButton( _hDlg, IDC_PORT_OTHER, IDC_PORT_EXISTING, IDC_PORT_EXISTING );

                PostMessage( _hDlg, WM_COMMAND, MAKELPARAM( IDC_PORT_EXISTING, 0 ), (LPARAM)GetDlgItem( _hDlg, IDC_PORT_EXISTING ) );
            }
        }
    }
    else
    {
        _pWizard->bNoPageChange() = TRUE;
    }
}

/********************************************************************

    Port selection - new version.

********************************************************************/

static UINT g_arrPorts[]        = {IDC_PORTS, IDC_PORTS_INFO_TEXT};
static UINT g_arrMonitors[]     = {IDC_MONITOR_TEXT, IDC_MONITOR_LIST};
static UINT g_arrMonitorsUI[]   = {IDC_MONITOR_TEXT, IDC_MONITOR_LIST, IDC_PORT_OTHER};

static UINT g_arrPortDesc[TWizPortNew::PORT_TYPE_OTHER] =
{
    IDS_TEXT_RECOMMENDED,
    IDS_TEXT_PRINTERPORT,
    IDS_TEXT_SERIALPORT,
    IDS_TEXT_PRINTTOFILE
};

TWizPortNew::
TWizPortNew(
    TWizard* pWizard
    ) : MWizardProp(pWizard),
        m_hBmp(NULL),
        m_hwndCB_Ports(NULL),
        m_hwndCB_Monitors(NULL)
{
    // nothing
}

BOOL
TWizPortNew::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    m_hwndCB_Ports = GetDlgItem(hDlg(), IDC_PORTS);
    m_hwndCB_Monitors = GetDlgItem(hDlg(), IDC_MONITOR_LIST);

    // something is wrong with the .rc template if those are not here...
    ASSERT(m_hwndCB_Ports);
    ASSERT(m_hwndCB_Monitors);

    if( m_hwndCB_Ports && m_hwndCB_Monitors )
    {
        HWND hwndImagePlug = GetDlgItem(hDlg(), IDC_IMAGE_PRNPLUG);
        if( hwndImagePlug )
        {
            m_hBmp = (HBITMAP)LoadImage(
                ghInst, MAKEINTRESOURCE(IDB_PRNPLUG), IMAGE_BITMAP, 0, 0,
                LR_LOADTRANSPARENT|LR_LOADMAP3DCOLORS);

            if( m_hBmp )
            {
                HANDLE hOldBmp = (HANDLE)SendMessage(hwndImagePlug, STM_SETIMAGE, IMAGE_BITMAP,
                    reinterpret_cast<LPARAM>((HBITMAP)m_hBmp));
                if( hOldBmp )
                {
                    DeleteObject( hOldBmp );
                }
            }
        }

        // initialize the port's list combobox
        int iPosNew = -1;
        bStatus DBGCHK = bInitializePortsList(&iPosNew);
        if( bStatus && m_spPorts->Count() )
        {
            // select the default port here
            bStatus DBGCHK = pWizard()->strPortName().bUpdate((*m_spPorts)[0].pszName);
            ComboBox_SetCurSel(m_hwndCB_Ports, 0);
        }

        // initialize the monitor's list combobox
        bStatus DBGCHK = bInitializeMonitorsList();
        if( bStatus && ComboBox_GetCount(m_hwndCB_Monitors) )
        {
            // select the default monitor
            ComboBox_SetCurSel(m_hwndCB_Monitors, 0);
        }

        // select ports radio button
        vSelectPortsRadio();
    }

    return bStatus;
}

BOOL
TWizPortNew::
bHandle_SetActive(
    VOID
    )
{
    BOOL bPorts = (BST_CHECKED == IsDlgButtonChecked(hDlg(), IDC_PORT_EXISTING));
    PostMessage(hDlg(), WM_NEXTDLGCTL,
        reinterpret_cast<WPARAM>(bPorts ? m_hwndCB_Ports : m_hwndCB_Monitors), (LPARAM)TRUE);

    return TRUE;
}

BOOL
TWizPortNew::
bHandle_WizNext(
    VOID
    )
{
    if( BST_CHECKED == IsDlgButtonChecked(hDlg(), IDC_PORT_EXISTING) )
    {
        vSelectionPort();
    }
    else
    {
        vSelectionMonitor();
    }
    return TRUE;
}

BOOL
TWizPortNew::
bHandle_Command(
    IN WORD wId,
    IN WORD wNotifyId,
    IN HWND hwnd
    )
{
    BOOL bRet = TRUE;
    switch( wId )
    {
        case IDC_PORT_OTHER:
        case IDC_PORT_EXISTING:
            {
                // enable/disable controls appropriately
                BOOL bPorts = IDC_PORT_EXISTING == wId ? TRUE : FALSE;
                vEnableControls(hDlg(), bPorts, g_arrPorts, ARRAYSIZE(g_arrPorts));
                vEnableControls(hDlg(), !bPorts, g_arrMonitors, ARRAYSIZE(g_arrMonitors));
                PostMessage(hDlg(), WM_NEXTDLGCTL,
                    reinterpret_cast<WPARAM>(bPorts ? m_hwndCB_Ports : m_hwndCB_Monitors), (LPARAM)TRUE);
            }
            break;

        default:
            // message not processed
            bRet = FALSE;
            break;
    }
    return bRet;
}

VOID
TWizPortNew::
vSelectionPort(
    VOID
    )
{
    int iPos = ComboBox_GetCurSel(m_hwndCB_Ports);
    if( CB_ERR == iPos )
    {
        // that would be pretty weird, but may happen
        vShowUnexpectedError(hDlg(), IDS_ERR_ADD_PRINTER_TITLE);
        pWizard()->bNoPageChange() = TRUE;
        PostMessage(hDlg(), WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(m_hwndCB_Ports), (LPARAM)TRUE);
    }
    else
    {
        // update pWizard()->strPortName & continue
        TStatusB bStatus;
        bStatus DBGCHK = pWizard()->strPortName().bUpdate(
            (*m_spPorts)[iPos].pszName);
    }
}

VOID
TWizPortNew::
vSelectionMonitor(
    VOID
    )
{
    TStatusB bStatus;
    TString strMonitor;

    if( !bGetEditText(hDlg(), IDC_MONITOR_LIST, strMonitor) )
    {
        // that would pretty weird, but may happen
        vShowUnexpectedError(hDlg(), IDS_ERR_ADD_PRINTER_TITLE);
        pWizard()->bNoPageChange() = TRUE;
        PostMessage(hDlg(), WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(m_hwndCB_Ports), (LPARAM)TRUE);
    }
    else
    {
        // add the port using the selected montior.
        bStatus DBGCHK = AddPort(
            const_cast<LPTSTR>(static_cast<LPCTSTR>(pWizard()->pszServerName())), hDlg(),
            const_cast<LPTSTR>(static_cast<LPCTSTR>(strMonitor)));

        if( bStatus )
        {
            // remember the last selected string
            TCHAR szLastSel[MAX_PATH];
            ComboBox_GetText( m_hwndCB_Ports, szLastSel, ARRAYSIZE(szLastSel) );

            // reinitiaize the ports list and select the newly added port, if any
            int iPosNew;
            bStatus DBGCHK = bInitializePortsList(&iPosNew);

            if( -1 == iPosNew )
            {
                // We are here because: The monitor returned success but
                // did not add a new port.  The whole monitor error reporting path
                // is totaly busted. Monitors are returning success even if they don't
                // add a port. They are also displaying error UI and then returning
                // a success. It is impossible to know what they did and how to react.
                // Therefore I am going to just silently fail, hopeing the monitor
                // writers display a reasonable error message if something went wrong.

                // Reselect the last selected item
                int iLastSel = ComboBox_FindStringExact( m_hwndCB_Ports, -1, szLastSel );
                ComboBox_SetCurSel( m_hwndCB_Ports, ((iLastSel == CB_ERR) ? 0 : iLastSel) );

                pWizard()->bNoPageChange() = TRUE;
                PostMessage(hDlg(), WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(m_hwndCB_Monitors), (LPARAM)TRUE);
            }
            else
            {
                // select the newly added port and continue
                ComboBox_SetCurSel(m_hwndCB_Ports, iPosNew);

                // select ports radio button
                vSelectPortsRadio();

                // proceed with the port selection
                vSelectionPort();
            }
        }
        else
        {
            // if not ERROR_CANCELLED then display error message.
            if( GetLastError() != ERROR_CANCELLED )
            {
                extern MSG_ERRMAP gaMsgErrMapPorts[];
                iMessage(hDlg(), IDS_ERR_ADD_PRINTER_TITLE, IDS_ERR_ADD_PORT, MB_OK|MB_ICONSTOP, kMsgGetLastError, gaMsgErrMapPorts);
            }
            pWizard()->bNoPageChange() = TRUE;
            PostMessage(hDlg(), WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(m_hwndCB_Monitors), (LPARAM)TRUE);
        }
    }
}

BOOL
TWizPortNew::
bInitializePortsList(
    OUT int *piNewlyAdded
    )
{
    // enumerate the ports starting at level 2 downward.
    TStatusB bStatus;
    bStatus DBGCHK = SUCCEEDED(hGetPorts(piNewlyAdded));

    if( bStatus )
    {
        ASSERT(m_hwndCB_Ports);
        ComboBox_ResetContent(m_hwndCB_Ports);

        int  i, iCount = m_spPorts->Count();
        if( iCount )
        {
            // go ahead and insert the ports...
            TString strFriendly;
            for( i = 0; i < iCount; i++ )
            {
                bStatus DBGCHK = bFormatPortName((*m_spPorts)[i], &strFriendly);
                if( bStatus )
                {
                    bStatus DBGCHK = (CB_ERR != ComboBox_AddString(m_hwndCB_Ports,
                        static_cast<LPCTSTR>(strFriendly)));

                    if( !bStatus )
                    {
                        // something has failed - cleanup
                        ComboBox_ResetContent(m_hwndCB_Ports);
                        m_spPorts->DeleteAll();
                        m_spBuffer = NULL;
                        break;
                    }
                }

            }
        }
    }

    return bStatus;
}

BOOL
TWizPortNew::
bInitializeMonitorsList(
    VOID
    )
{
    DWORD cbMonitors = 0;
    DWORD cMonitors = 0;
    CAutoPtrSpl<MONITOR_INFO_2> spMonitors;

    TStatusB bStatus;
    bStatus DBGCHK = VDataRefresh::bEnumMonitors(_pWizard->_strServerName, 2, spMonitors.GetPPV(), &cbMonitors, &cMonitors);

    if( bStatus )
    {
        // port monitors enumerated successfully here, we are about to fill up the combo
        ComboBox_ResetContent(m_hwndCB_Monitors);

        for( DWORD i = 0; i < cMonitors; i++ )
        {
            BOOL bAddMonitor = TRUE;

            // If we are on a remote machine check if the monitor
            // supports remoteable calls.  Only remoteable monitors
            // should show up in the combobox.
            if( bIsRemote(_pWizard->_strServerName) )
            {
                bAddMonitor = bIsRemoteableMonitor(spMonitors[i].pName);
            }

            // Hide the fax monitor, users are not allowed to
            // create fax printer from the add printer wizard.
            bAddMonitor = _tcsicmp(spMonitors[i].pName, FAX_MONITOR_NAME);

            if( bAddMonitor )
            {
                // this monitor is OK to add...
                ComboBox_AddString(m_hwndCB_Monitors, spMonitors[i].pName);
            }
        }

        ComboBox_SetCurSel(m_hwndCB_Monitors, 0);
    }

    if( !ComboBox_GetCount(m_hwndCB_Monitors) ||
        (bIsRemote(_pWizard->_strServerName) && _pWizard->_Di.dwGetCurrentDriverVersion() <= 2) )
    {
        // If there are no monitors in the list, hide the UI.
        // This is possible if all the monitors are not remoteable
        // Also adding ports remotely is not supported on downlevel
        // machines.
        vEnableControls(_hDlg, FALSE, g_arrMonitorsUI, ARRAYSIZE(g_arrMonitorsUI));
    }

    return bStatus;
}

BOOL
TWizPortNew::
bIsRemoteableMonitor(
    IN LPCTSTR pszMonitorName
    )
{
    //
    // !!LATER!!
    // Add private winspool.drv interface to check if a
    // port monitor is remoteable.
    //
    return TRUE;
}

VOID
TWizPortNew::
vSelectPortsRadio(
    VOID
    )
{
    // so any of the port selection action.
    CheckRadioButton(hDlg(), IDC_PORT_OTHER, IDC_PORT_EXISTING, IDC_PORT_EXISTING);

    // enable/diable the controls appropriately
    vEnableControls(hDlg(), TRUE, g_arrPorts, ARRAYSIZE(g_arrPorts));
    vEnableControls(hDlg(), FALSE, g_arrMonitors, ARRAYSIZE(g_arrMonitors));
    PostMessage(hDlg(), WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(m_hwndCB_Ports), (LPARAM)TRUE);
}

HRESULT
TWizPortNew::
hGetPorts(
    OUT int *piNewlyAdded
    )
{
    HRESULT hr = E_INVALIDARG;

    // validate arguments...
    if( piNewlyAdded )
    {
        hr =  S_OK;

        // enumerate the ports starting at level 2 downward.
        CAutoPtrSpl<BYTE> spBuffer;
        CAutoPtr<CPortsArray> spPorts = new CPortsArray;
        DWORD dwLevel = 2, cbPorts = 0, cPorts = 0;

        if( spPorts && VDataRefresh::bEnumPortsMaxLevel(
            pWizard()->pszServerName(), &dwLevel,
            spBuffer.GetPPV(), &cbPorts, &cPorts) )
        {
            // insert ports in the priority array
            int iPos;
            BOOL bNewFound = FALSE;
            PortInfo piNew, pi = {0, NULL, NULL};

            for( DWORD dw = 0; dw < cPorts; dw++ )
            {
                pi.pszName = (2 == dwLevel ? spBuffer.GetPtrAs<PORT_INFO_2*>()[dw].pPortName :
                                             spBuffer.GetPtrAs<PORT_INFO_1*>()[dw].pName);

                if( 2 == dwLevel && bIsFaxPort(pi.pszName,
                    spBuffer.GetPtrAs<PORT_INFO_2*>()[dw].pMonitorName) )
                {
                    // skip the fax ports
                    continue;
                }

                pi.pszDesc = (2 == dwLevel ? spBuffer.GetPtrAs<PORT_INFO_2*>()[dw].pDescription : NULL);
                pi.iType = iGetPortType(pi.pszName);

                if( m_spPorts && FALSE == bNewFound && FALSE == m_spPorts->FindItem(pi, &iPos) )
                {
                    // this is a newly added port, remember it
                    bNewFound = TRUE;
                    piNew = pi;
                }

                // insert...
                if( -1 == spPorts->SortedInsert(pi) )
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }

            if( SUCCEEDED(hr) )
            {
                m_spBuffer = spBuffer.Detach();
                m_spPorts = spPorts.Detach();
                *piNewlyAdded = (bNewFound && m_spPorts->FindItem(piNew, &iPos)) ? iPos : -1;
            }
        }
        else
        {
            // spPorts is NULL or VDataRefresh::bEnumPortsMaxLevel failed
            DWORD dwErr = GetLastError();
            hr = (!spPorts ? E_OUTOFMEMORY : (ERROR_SUCCESS == dwErr ?
                E_FAIL : HRESULT_FROM_WIN32(dwErr)));
        }
    }

    return hr;
}

int
TWizPortNew::
iGetPortType(
    IN LPCTSTR pszPortName
    )
{
    ASSERT(pszPortName);

    if( bMatchTemplate(TEXT("LPT1:"), pszPortName) )
    {
        // "LPT1:" has the ultimate highest priority - pri 0
        return PORT_TYPE_LPT1;
    }
    else if( bMatchTemplate(TEXT("LPT?:"), pszPortName) )
    {
        // followed by the rest of the LPT ports as pri 1
        return PORT_TYPE_LPTX;
    }
    else if( bMatchTemplate(TEXT("COM?:"), pszPortName) )
    {
        // followed by the COM ports as pri 2
        return PORT_TYPE_COMX;
    }
    else if( bMatchTemplate(TEXT("FILE:"), pszPortName) )
    {
        // followed by the FILE ports as pri 3
        return PORT_TYPE_FILE;
    }
    else
    {
        // followed by the other ports as pri 4
        return PORT_TYPE_OTHER;
    }
}

BOOL
TWizPortNew::
bFormatPortName(
    IN  const PortInfo &pi,
    OUT TString *pstrFriendlyName
    )
{
    ASSERT(pstrFriendlyName);
    TStatusB bStatus;

    if( pi.iType < PORT_TYPE_OTHER )
    {
        // this is a common port type - load frendly decr...
        TString strDesc;
        bStatus DBGCHK = strDesc.bLoadString(ghInst, g_arrPortDesc[pi.iType]);

        if( bStatus )
        {
            bStatus DBGCHK = pstrFriendlyName->bFormat(TEXT("%s (%s)"),
                pi.pszName, static_cast<LPCTSTR>(strDesc));
        }
    }
    else
    {
        // pi.pszName can be NULL, but that's OK
        bStatus DBGCHK = ((pi.pszDesc && pi.pszDesc[0]) ?
            pstrFriendlyName->bFormat(TEXT("%s (%s)"), pi.pszName, pi.pszDesc) :
            pstrFriendlyName->bUpdate(pi.pszName));
    }

    return bStatus;
}

/********************************************************************

    Printer name.

********************************************************************/

TWizName::
TWizName(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizName::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // If we are adding a printer on a remote machine, don't bother
    // showing the default settings, since the user doen't have a
    // connection.
    //
    // Check if there is a default printer.  If there isn't one,
    // we'll always make it the default, so we want to hide
    // the controls.
    //
    if( _pWizard->pszServerName() || CheckDefaultPrinter( NULL ) == kNoDefault ){

        static DWORD adwDefault[] = {
            IDC_SET_DEFAULT,
            IDC_RADIO_YES,
            IDC_RADIO_NO
        };

        for( UINT i = 0; i < COUNTOF( adwDefault ); ++i )
        {
            ShowWindow( GetDlgItem( _hDlg, adwDefault[i] ), SW_HIDE );
        }

        //
        // If we're here not because we're adding a printer on a remote
        // machine, then always make it the default.
        //
        if( !_pWizard->pszServerName( )){

            //
            // Always set it as the default.
            //
            _pWizard->bSetDefault() = TRUE;

            //
            // Don't show the set as default UI.
            //
            _pWizard->bShowSetDefault() = FALSE;
        }

    } else {

        //
        // Get the default button state.
        //
        INT iValueId = _pWizard->bSetDefault() ? IDC_RADIO_YES : IDC_RADIO_NO;

        //
        // By default, don't make it the default printer.
        //
        bStatus DBGCHK = CheckRadioButton( _hDlg,
                                           IDC_RADIO_YES,
                                           IDC_RADIO_NO,
                                           iValueId );
    }

    //
    // Set the printer name limit.  The limit in win9x is 32 chars
    // (including NULL terminator).  There isn't a properly defined
    // WinNT spooler limit, but it crashes around MAX_PATH (260 including
    // NULL).  Note that win32spl.dll prepends \\server\ when connection
    // remotely, so our effective limit, including NULL is
    // MAX_PATH - (kServerLenMax = MAX_COMPUTERNAME_LEN - 3).
    //
    SendDlgItemMessage( _hDlg,
                        IDC_PRINTER_NAME,
                        EM_SETLIMITTEXT,
                        kPrinterLocalNameMax,
                        0 );

    //
    // Generate a new printer name that is unique.
    //
    vUpdateName();

    return TRUE;
}

VOID
TWizName::
vUpdateName(
    VOID
    )
{
    TStatusB bStatus;
    TCHAR szDefault[kPrinterBufMax];
    LPCTSTR pszPrinterName;
    TString strPrinterName;

    //
    // Read the current contents of the edit control.
    //
    bStatus DBGCHK = bGetEditText( _hDlg,
                                    IDC_PRINTER_NAME,
                                    strPrinterName );

    // If the name is empty then generate a unique name.
    // If the current printer name is equal to the generated name
    // then we assume the user has not provided their own printer name
    // and thus we will generated a printer name.
    //
    if( strPrinterName.bEmpty() ||
        (strPrinterName == _strGeneratedPrinterName &&
         _pWizard->_bRefreshPrinterName ) ){

        //
        // Clear the refresh printer name flag.
        //
        _pWizard->_bRefreshPrinterName = FALSE;

        //
        // Create a new friendly printer name.
        //
        bStatus DBGNOCHK = NewFriendlyName( _pWizard->_pszServerName,
                                            (LPTSTR)(LPCTSTR)_pWizard->strDriverName(),
                                            szDefault );
        //
        // If a new Friendly name was created.
        //
        if( bStatus ){
            pszPrinterName = szDefault;
        } else {
            pszPrinterName = _pWizard->strDriverName();
        }

        //
        // Save the generated printer name.
        //
        bStatus DBGCHK = _strGeneratedPrinterName.bUpdate( pszPrinterName );

        //
        // Update the edit control with new printer name.
        //
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_PRINTER_NAME, pszPrinterName );
    }
}

VOID
TWizName::
vReadUI(
    VOID
    )
{
    //
    // Save state.
    //
    if( !bGetEditText( _hDlg, IDC_PRINTER_NAME, _pWizard->_strPrinterName )){

        _pWizard->_bErrorSaving = TRUE;
        vShowUnexpectedError( _hDlg, IDS_ERR_ADD_PRINTER_TITLE );
        _pWizard->bNoPageChange() = TRUE;
        return;
    }

    //
    // Printer names cannot have trailing white spaces.
    //
    vStripTrailWhiteSpace( (LPTSTR)(LPCTSTR)_pWizard->_strPrinterName );

    //
    // Check if the name has any illegal characters.
    //
    if( !bIsLocalPrinterNameValid( _pWizard->_strPrinterName ) )
    {
        iMessage( _hDlg,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_BAD_PRINTER_NAME,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        goto BadName;
    }

    //
    // Check if the name is null.
    //
    if( _pWizard->_strPrinterName.bEmpty( ) ){

        iMessage( _hDlg,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_NO_PRINTER_NAME,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );
        goto BadName;
    }

    //
    // Check if the name is longer than kPrinterLocalNameMax characters.
    //
    if( lstrlen(_pWizard->_strPrinterName) > kPrinterLocalNameMax ){

        iMessage( _hDlg,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_LONG_PRINTER_NAME,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );
        goto BadName;
    }

    //
    // Check if the name conflicts with an existing printer name.
    //
    TCHAR szDefault[kPrinterBufMax];
    if( NewFriendlyName( _pWizard->_pszServerName,
                         (LPTSTR)(LPCTSTR)_pWizard->_strPrinterName,
                         szDefault ) ){
        iMessage( _hDlg,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  IDS_ERR_PRINTER_NAME_CONFLICT,
                  MB_OK|MB_ICONSTOP,
                  ERROR_PRINTER_ALREADY_EXISTS,
                  NULL );

        goto BadName;
    }

    //
    // If the default UI is displayed then read the UI setting.
    //
    if( _pWizard->bShowSetDefault() )
    {
        //
        // Get default printer selection.
        //
        _pWizard->bSetDefault() = IsDlgButtonChecked( _hDlg, IDC_RADIO_YES ) == BST_CHECKED;
    }

    return;

BadName:

    //
    // Set focus to name edit control.
    //
    SetFocus( GetDlgItem( _hDlg, IDC_PRINTER_NAME ));
    _pWizard->bNoPageChange() = TRUE;
}

BOOL
TWizName::
bHandle_SetActive(
    VOID
    )
{
    //
    // Since the driver name may have changed we may
    // have to generate a new unique printer name.
    //
    vUpdateName();

    return TRUE;
}

BOOL
TWizName::
bHandle_WizNext(
    VOID
    )
{
    vReadUI();
    return TRUE;
}

/********************************************************************

    Sharing and architecture.

********************************************************************/

TWizShare::
TWizShare(
    TWizard* pWizard
    ) : MWizardProp( pWizard ),
        _pPrtShare( NULL )
{
}

TWizShare::
~TWizShare(
    VOID
    )
{
    delete _pPrtShare;
}

BOOL
TWizShare::
bHandle_InitDialog(
    VOID
    )
{
    //
    // By default, don't share the printer.
    //
    if( _pWizard->bShared() )
    {
        vSharePrinter();
    }
    else
    {
        vUnsharePrinter();
    }

    //
    // Set the printer share name limit.  The limit in win9x is
    // 8.3 == 12+1 chars (including NULL terminator).  The Winnt limit
    // is defined as NNLEN;
    //
    SendDlgItemMessage( _hDlg, IDC_SHARED_NAME, EM_SETLIMITTEXT, kPrinterShareNameMax, 0 );

    return TRUE;
}


VOID
TWizShare::
vReadUI(
    VOID
    )
{
    PDWORD pdwSelected = NULL;

    _pWizard->_bShared = ( IsDlgButtonChecked( _hDlg, IDC_SHARED ) == BST_CHECKED );

    if( !bGetEditText( _hDlg, IDC_SHARED_NAME, _pWizard->_strShareName )){

        _pWizard->_bErrorSaving = TRUE;
        vShowUnexpectedError( _hDlg, IDS_ERR_ADD_PRINTER_TITLE );

        goto Fail;
    }

    //
    // Has the user choosen to share this printer.
    //
    if( _pWizard->bShared( ) ){

        //
        // If the share name is NULL, put up an error.
        //
        if( _pWizard->_strShareName.bEmpty( ) ){

            iMessage( _hDlg,
                      IDS_ERR_ADD_PRINTER_TITLE,
                      IDS_ERR_NO_SHARE_NAME,
                      MB_OK|MB_ICONSTOP,
                      kMsgNone,
                      NULL );
            //
            // Set the focus to the shared as text.
            //
            SetFocus( GetDlgItem( _hDlg, IDC_SHARED_NAME ));
            goto Fail;

        }

        //
        // Ensure the Printer share object is valid.
        //
        if( VALID_PTR( _pPrtShare ) ){

            //
            // Check the share name if its valid.
            //
            INT iStatus;
            iStatus = _pPrtShare->iIsValidNtShare( _pWizard->_strShareName );

            //
            // If share name is not a valid NT share name, put error message.
            //
            if( iStatus != TPrtShare::kSuccess ){

                iMessage( _hDlg,
                          IDS_ERR_ADD_PRINTER_TITLE,
                          IDS_ERR_INVALID_CHAR_SHARENAME,
                          MB_OK|MB_ICONSTOP,
                          kMsgNone,
                          NULL );

                SetFocus( GetDlgItem( _hDlg, IDC_SHARED_NAME ));
                goto Fail;
            }

            //
            // Check if the share name is a valid DOS share.
            //
            iStatus = _pPrtShare->iIsValidDosShare( _pWizard->_strShareName );

            //
            // If share name is not a valid DOS share name, warn the user.
            //
            if( iStatus != TPrtShare::kSuccess ){

                if( IDYES != iMessage( _hDlg,
                                       IDS_ERR_ADD_PRINTER_TITLE,
                                       IDS_ERR_SHARE_NAME_NOT_DOS,
                                       MB_YESNO|MB_ICONEXCLAMATION,
                                       kMsgNone,
                                       NULL ) ){

                    SetFocus( GetDlgItem( _hDlg, IDC_SHARED_NAME ) );
                    goto Fail;
                }
            }

            //
            // Check if the share name is unique.
            //
            if( !_pPrtShare->bIsValidShareNameForThisPrinter( _pWizard->_strShareName,
                                                              _pWizard->_strPrinterName ) ){

                iMessage( _hDlg,
                          IDS_ERR_ADD_PRINTER_TITLE,
                          IDS_ERR_DUPLICATE_SHARE,
                          MB_OK|MB_ICONSTOP,
                          kMsgNone,
                          NULL );
                //
                // Set the focus to the shared as text.
                //
                SetFocus( GetDlgItem( _hDlg, IDC_SHARED_NAME ));
                goto Fail;

            }
        }
    }

    if (FALSE == _pWizard->_bShared)
    {
        // if the printer is not shared we should clear the comment and
        // location since they may have been set already in the case
        // where the wizard has been restarted from the last page.

        _pWizard->_strLocation.bUpdate(NULL);
        _pWizard->_strComment.bUpdate(NULL);
    }

    return;

Fail:

    _pWizard->bNoPageChange() = TRUE;

    return;
}


VOID
TWizShare::
vSharePrinter(
    VOID
    )

/*++

Routine Description:

    User clicked share radio button.  Change the UI appropriately.

Arguments:

Return Value:

--*/

{
    //
    // Set radio button and possibly enable window.
    //
    CheckRadioButton( _hDlg, IDC_SHARED_OFF, IDC_SHARED, IDC_SHARED );
    vEnableCtl( _hDlg, IDC_SHARED_NAME, TRUE );

    //
    // Set the default share name.
    //
    vSetDefaultShareName();

    //
    // Set the focus to the shared as text.
    //
    SetFocus( GetDlgItem( _hDlg, IDC_SHARED_NAME ));
    Edit_SetSel( GetDlgItem( _hDlg, IDC_SHARED_NAME ), 0, -1 );
}


VOID
TWizShare::
vUnsharePrinter(
    VOID
    )

/*++

Routine Description:

    User clicked don't share radio button.  Change the UI appropriately.

Arguments:

Return Value:

--*/

{
    //
    // Set radio button and disable window.
    //
    CheckRadioButton( _hDlg, IDC_SHARED_OFF, IDC_SHARED, IDC_SHARED_OFF );
    vEnableCtl( _hDlg, IDC_SHARED_NAME, FALSE );

}

VOID
TWizShare::
vSetDefaultShareName(
    VOID
    )
/*++

Routine Description:

    Sets the default share name if use has choosen to share
    this printer.  We will update the share name if
    this is the first time setting the share name.

Arguments:

    BOOL Indicating if the printer name has changed.  TRUE
    if the printe name has changed and FALSE if printer name
    has not change.

Return Value:

    Nothing.

--*/
{
    TStatusB bStatus;
    TString strShareName;

    //
    // Ignore share name generation if the printer has
    // not been shared.
    //
    if( IsDlgButtonChecked( _hDlg, IDC_SHARED ) != BST_CHECKED ){
        return;
    }

    //
    // Read the current contents of the edit control.
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_SHARED_NAME, strShareName );

    DBGMSG( DBG_TRACE, ( "strShareName " TSTR "\n", (LPCTSTR)strShareName ) );
    DBGMSG( DBG_TRACE, ( "_strGeneratedShareName " TSTR "\n", (LPCTSTR)_strGeneratedShareName ) );

    //
    // Create a share name if the current edit field is empty.
    // or if the current share name is the same as the previously
    // generated share name.
    //
    if( strShareName.bEmpty() || (_strGeneratedShareName == strShareName) ){

        //
        // If the share object has not be constructed, then
        // construct it.
        //
        if( !_pPrtShare ){
            _pPrtShare = new TPrtShare( _pWizard->_pszServerName );
        }

        //
        // Ensure the share object is still valid.
        //
        if( VALID_PTR( _pPrtShare ) ){

            //
            // Create valid unique share name.
            //
            bStatus DBGNOCHK = _pPrtShare->bNewShareName( strShareName, _pWizard->_strPrinterName );

            //
            // Set the generated share name.
            //
            bStatus DBGCHK = bSetEditText( _hDlg, IDC_SHARED_NAME, strShareName );

            //
            // Save the generated share name.
            //
            bStatus DBGCHK = _strGeneratedShareName.bUpdate( strShareName );
        }
    }
}

BOOL
TWizShare::
bHandle_SetActive(
    VOID
    )
{
    //
    // Clear the driver changed status.
    //
    _pWizard->bDriverChanged() = FALSE;

    //
    // Refresh the share name, the printer name may have changed.
    //
    vSetDefaultShareName();

    return TRUE;
}

BOOL
TWizShare::
bHandle_WizNext(
    VOID
    )
{
    vReadUI();
    return TRUE;
}

BOOL
TWizShare::
bHandle_Command(
    IN WORD wId,
    IN WORD wNotifyId,
    IN HWND hwnd
    )
{
    BOOL bStatus = TRUE;

    switch( wId )
    {
    case IDC_SHARED_OFF:
        vUnsharePrinter();
        break;

    case IDC_SHARED:
        vSharePrinter();
        break;

    default:
        bStatus = FALSE;
        break;
    }
    return bStatus;
}

/********************************************************************

    Comment

********************************************************************/

TWizComment::
TWizComment(
    TWizard* pWizard
    ) : MWizardProp( pWizard ),
    _pLocDlg(NULL)
{
}

TWizComment::
~TWizComment(
    VOID
    )
{
    delete _pLocDlg;
}

BOOL
TWizComment::
bHandle_InitDialog(
    VOID
    )
{
    // subclass the edit control to workaround a bug
    if( !m_wndComment.IsAttached() )
    {
        VERIFY(m_wndComment.Attach(GetDlgItem(hDlg(), IDC_WIZ_COMMENT)));
    }

    TDirectoryService ds;
    TStatusB          bStatus;
    //
    // Set resonable limits on the comment and location edit controls.
    //
    SendDlgItemMessage( _hDlg, IDC_WIZ_LOCATION, EM_SETLIMITTEXT, kPrinterLocationBufMax, 0 );
    SendDlgItemMessage( _hDlg, IDC_WIZ_COMMENT, EM_SETLIMITTEXT, kPrinterCommentBufMax, 0 );
    _pLocDlg = new TFindLocDlg;

    bStatus DBGCHK = VALID_PTR(_pLocDlg);
    if (bStatus)

    {
        bStatus DBGCHK =  ds.bValid();
        if (bStatus)
        {
            bStatus DBGCHK = ds.bIsDsAvailable();
            //
            // If the DS is not available or the location policy is disabled then
            // remove the location UI.
            //
            if (!bStatus || !TPhysicalLocation::bLocationEnabled())
            {
                //
                // If no DS is available, hide the Browse button and extend the location
                // edit control appropriately
                //
                RECT rcComment;
                RECT rcLocation;
                HWND hLoc;

                hLoc = GetDlgItem (_hDlg, IDC_WIZ_LOCATION);

                GetWindowRect (GetDlgItem (_hDlg, IDC_WIZ_COMMENT), &rcComment);
                GetWindowRect (hLoc, &rcLocation);
                SetWindowPos (hLoc,
                          NULL,
                          0,0,
                          rcComment.right-rcComment.left,
                          rcLocation.bottom-rcLocation.top,
                          SWP_NOMOVE|SWP_NOZORDER);
                //
                // Remove the location button.
                //
                ShowWindow (GetDlgItem (_hDlg, IDC_WIZ_BROWSE_LOCATION), SW_HIDE);
            }
        }
    }

    return TRUE;
}

BOOL
TWizComment::
bHandle_WizNext(
    VOID
    )
{
    TStatusB bStatus;
    UINT uLen;

    bStatus DBGCHK = bGetEditText( _hDlg, IDC_WIZ_LOCATION, _pWizard->_strLocation );
    TPhysicalLocation::vTrimSlash (_pWizard->_strLocation);
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_WIZ_COMMENT, _pWizard->_strComment );
    return TRUE;
}

BOOL
TWizComment::
bHandle_Command(
    IN WORD wId,
    IN WORD wNotifyId,
    IN HWND hwnd
    )
{
    TString  strLocation;
    TStatusB bStatus;

    bStatus DBGNOCHK = TRUE;

    switch (wId)
    {
        case IDC_WIZ_BROWSE_LOCATION:
        {
            //
            // Get the current edit control contents.
            //
            bStatus DBGCHK = bGetEditText (_hDlg, IDC_WIZ_LOCATION, strLocation);

            //
            // Display the location tree to the user.
            //
            bStatus DBGCHK = _pLocDlg->bDoModal(_hDlg, &strLocation);

            //
            // If the user click ok, then populate location edit control with
            // the users selection, along with a trailing slash.
            //
            if (bStatus)
            {
                bStatus DBGCHK = _pLocDlg->bGetLocation (strLocation);

                if (bStatus && !strLocation.bEmpty())
                {
                    //
                    // Check to append a trailing slash
                    //
                    UINT uLen = strLocation.uLen();
                    if( uLen && gchSeparator != static_cast<LPCTSTR>(strLocation)[uLen-1] )
                    {
                        static const TCHAR szSepStr[] = { gchSeparator };
                        bStatus DBGCHK = strLocation.bCat( szSepStr );
                    }

                    bStatus DBGCHK = _pWizard->_strLocation.bUpdate( strLocation );
                    bStatus DBGCHK = bSetEditText ( _hDlg, IDC_WIZ_LOCATION, _pWizard->_strLocation );
                }

                //
                // Set focus to the edit control for location
                //
                SetFocus (GetDlgItem (_hDlg, IDC_WIZ_LOCATION));

                //
                // Place the caret at the end of the text, for appending
                //
                SendDlgItemMessage (_hDlg, IDC_WIZ_LOCATION, EM_SETSEL, _pWizard->_strLocation.uLen(), (LPARAM)-1);
            }

            break;
        }

        default:
        {
            bStatus DBGNOCHK = FALSE;
            break;
        }
    }

    return bStatus;
}

/********************************************************************

    Network install dialog.

********************************************************************/

TWizNet::
TWizNet(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizNet::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Get the default control state.
    //
    INT iValueId = _pWizard->bSetDefault() ? IDC_RADIO_YES : IDC_RADIO_NO;

    //
    // By default, don't make it the default printer.
    //
    bStatus DBGCHK = CheckRadioButton( _hDlg, IDC_RADIO_YES, IDC_RADIO_NO, iValueId );

    //
    // Set cancel to close, since the printer connection can't
    // be undone at this point.  (We could try just deleting the
    // connection, but this doesn't undo the driver downloads, etc.
    //
    PropSheet_CancelToClose( GetParent( _hDlg ) );

    return TRUE;
}

BOOL
TWizNet::
bHandle_WizNext(
    VOID
    )
{
    //
    // Get default printer selection.
    //
    _pWizard->_bSetDefault = ( IsDlgButtonChecked( _hDlg, IDC_RADIO_YES ) == BST_CHECKED );

    return TRUE;
}

/********************************************************************

    Locate printer wizard page.

********************************************************************/

TWizLocate::
TWizLocate(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizLocate::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;
    bStatus DBGCHK = TRUE;

    if( _pWizard->bAdminPrivilege() && _pWizard->strPrintersPageURL().uLen() )
    {
        //
        // Show browse for printer URL button,
        // note this depends on a policy settings.
        //
        ShowWindow( GetDlgItem( _hDlg, IDC_BROWSELINK_BTN ), SW_SHOW );
    }

    //
    // Enable URL browse if the current user has an administrative
    // priviledge only
    //
    EnableWindow( GetDlgItem( _hDlg, IDC_URL_BROWSE ),     _pWizard->bAdminPrivilege() );
    EnableWindow( GetDlgItem( _hDlg, IDC_BROWSELINK_BTN ), _pWizard->bAdminPrivilege() );

    if( TWizard::kDsStatusAvailable == _pWizard->eIsDsAvailablePerUser() )
    {
        //
        // DS available case - change the browse text appropriately
        //
        TString strText;
        bStatus DBGCHK = strText.bLoadString( ghInst, IDS_DS_SEARCH_DIR_NAME );
        SetWindowText(GetDlgItem( _hDlg, IDC_DS_SEARCH ), strText );
    }
    else
    {
        //
        // NON-DS case - check to see is downlevel browsing is enabled at all
        //
        if( !_pWizard->bDownlevelBrowse() )
        {
            //
            // There is no Directory Service installed and downlevel
            // browse is not enabled....
            //

            // make the "connect to..." the default option
            _pWizard->_LocateType = TWizard::kBrowseNET;

            // hide & disable the search DS/browse radio button
            ShowWindow( GetDlgItem( _hDlg, IDC_DS_SEARCH ), SW_HIDE );
            EnableWindow( GetDlgItem( _hDlg, IDC_DS_SEARCH ), FALSE );
        }
    }

    if( !_pWizard->bDownlevelBrowse() )
    {
        TString strText;

        // if downlevel browse policy is not enabled then
        // change the text of the "connect to..." not to imply browsing
        bStatus DBGCHK = strText.bLoadString( ghInst, IDS_APW_TEXT_CONNECT_TO_THIS_PRINTER );
        SetWindowText(GetDlgItem( _hDlg, IDC_NET_BROWSE ), strText );
    }

    if( _pWizard->COM() )
    {
        //
        // Enable autocomplete for the printer share/name
        //
        ShellServices::InitPrintersAutoComplete(GetDlgItem(_hDlg, IDC_CONNECT_TO_NET));
    }

    return bStatus;
}

BOOL
TWizLocate::
bHandle_SetActive(
    VOID
    )
{
    //
    // Setup a radio table for fast lookup
    //
    static INT radioTable[] =
    { IDC_DS_SEARCH, IDC_NET_BROWSE, IDC_URL_BROWSE };

    //
    // Set the default setting.
    //
    TStatusB bStatus;
    bStatus DBGCHK = CheckRadioButton( _hDlg,
                radioTable[0], radioTable[COUNTOF(radioTable)-1],
                radioTable[ _pWizard->_LocateType ] );

    //
    // Set the initial control enable state.
    //
    PostMessage( _hDlg, WM_COMMAND,
                radioTable[ _pWizard->_LocateType ], 0 );

    return TRUE;
}

BOOL
TWizLocate::
Handle_ConnectToPrinterName(
    VOID
    )
{
    LPCTSTR lpszNameOrURL = _strConnectToNET;
    if( TWizard::kBrowseURL == _pWizard->_LocateType )
        lpszNameOrURL = _strConnectToURL;

    //
    // Eat the white spaces, in front of the string
    //
    while( lpszNameOrURL && lpszNameOrURL[0] && TEXT(' ') == lpszNameOrURL[0] )
    {
        lpszNameOrURL++;
    }

    //
    // If the edit contol blank warn the user and do not switch the page.
    //
    if( 0 == lstrlen(lpszNameOrURL) )
    {
        UINT uErrID = IDS_ERR_MISSING_PRINTER_NAME;
        if( TWizard::kBrowseURL == _pWizard->_LocateType )
            uErrID = IDS_ERR_MISSING_PRINTER_URL;

        iMessage( _hDlg,
                  IDS_ERR_ADD_PRINTER_TITLE,
                  uErrID,
                  MB_OK|MB_ICONHAND,
                  kMsgNone,
                  NULL );
        //
        // Printer name was not entered.  Do not switch pages.
        //
        _pWizard->bNoPageChange() = TRUE;
    }
    else
    {
        TWaitCursor Cur;
        TStatusB bStatus;

        //
        // Add the printer connection.
        //
        bStatus DBGCHK = PrintUIAddPrinterConnectionUIEx( _hDlg,
                                                          lpszNameOrURL,
                                                          &_pWizard->_strPrinterName,
                                                          &_pWizard->_strComment,
                                                          &_pWizard->_strLocation,
                                                          &_pWizard->_strShareName );

        if( bStatus )
        {
            //
            // Indicate a printer connection has been made.
            //
            _pWizard->bConnected() = TRUE;

            //
            // Check for any default printer.
            //
            if( !_pWizard->bIsPrinterFolderEmpty() )
            {
                //
                // Always set it as the default.
                //
                _pWizard->bSetDefault() = TRUE;

                //
                // Don't show the set as default UI.
                //
                _pWizard->bShowSetDefault() = FALSE;
            }
        }
        else
        {
            //
            // An error occurred adding the printer connection do not
            // switch the page on error.  Note we do not display an error
            // message if something failed add printer connection will display
            // an error if one does happens.
            //
            _pWizard->bNoPageChange() = TRUE;
        }
    }

    return TRUE;
}


BOOL
TWizLocate::
Handle_URLBrowseClick(
    VOID
    )
{
    ShellExecute(  NULL, _T("open"), _pWizard->strPrintersPageURL(), NULL, NULL, SW_SHOWDEFAULT );
    PropSheet_PressButton( GetParent( _hDlg ), PSBTN_CANCEL );
    return TRUE;
}

VOID
TWizLocate::
vReadUI(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Read the LocateType first
    //
    _pWizard->_LocateType = TWizard::kSearch;
    if( IsDlgButtonChecked( _hDlg, IDC_NET_BROWSE ) )
            _pWizard->_LocateType = TWizard::kBrowseNET;
    if( IsDlgButtonChecked( _hDlg, IDC_URL_BROWSE ) )
            _pWizard->_LocateType = TWizard::kBrowseURL;


    //
    // get the URL of the printer
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_CONNECT_TO_URL, _strConnectToURL );

    //
    // get the network name of the printer
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_CONNECT_TO_NET, _strConnectToNET );

    //
    // Stip trailing white spaces from the names.
    //
    vStripTrailWhiteSpace( const_cast<LPTSTR>( static_cast<LPCTSTR>( _strConnectToURL ) ) );
    vStripTrailWhiteSpace( const_cast<LPTSTR>( static_cast<LPCTSTR>( _strConnectToNET ) ) );
}

VOID
TWizLocate::
vSearch(
    VOID
    )
{
    TStatusB bStatus;
    TQuery Query( _hDlg );
    TString strPrinterName;
    INT iMessageId = IDS_ERR_ADD_PRINTER_CONNECTION;
    BOOL bErrorMessageAlreadyDisplayed = FALSE;

    //
    // Validate the query class.
    //
    bStatus DBGCHK = VALID_OBJ( Query );

    if( bStatus )
    {
        //
        // Show waiting cursor when building printer connections.
        //
        TWaitCursor Cur;

        //
        // Display the query dialog.
        //
        (VOID)Query.bDoQuery();

        //
        // For all printers selected in the results pane install the
        // selected printer.
        //
        for( UINT i = 0; i < Query.cItems(); i++ )
        {
            DBGMSG( DBG_TRACE, ( "cItems %d\n", Query.cItems() ) );
            DBGMSG( DBG_TRACE, ( "Name  " TSTR "\n", (LPCTSTR)(Query._pItems[i]._strName) ) );
            DBGMSG( DBG_TRACE, ( "Class " TSTR "\n", (LPCTSTR)(Query._pItems[i]._strClass) ) );

            //
            // We want to only install printer selected devices.
            //
            if( Query.pItems()[i].strClass() == gszDsPrinterClassName )
            {
                //
                // Get the printer name from the DS name.
                //
                bStatus DBGCHK = Query.bPrinterName( strPrinterName, Query.pItems()[i].strName() );

                if( bStatus )
                {
                    TString strRealPrinterName;

                    //
                    // Install network printer connection.
                    //
                    bStatus DBGCHK = PrintUIAddPrinterConnectionUIEx( _hDlg,
                                                                      strPrinterName,
                                                                      &strRealPrinterName,
                                                                      &_pWizard->_strComment,
                                                                      &_pWizard->_strLocation,
                                                                      &_pWizard->_strShareName );

                    if( bStatus )
                    {
                        //
                        // If only one item was selected then we will set the
                        // default printer so get the real printer name because
                        // the user may have connected using the printer share name.
                        //
                        if( Query.cItems() == 1 && bStatus )
                        {
                            bStatus DBGCHK = strPrinterName.bUpdate( strRealPrinterName );
                        }
                    }
                    else
                    {
                        bErrorMessageAlreadyDisplayed = TRUE;
                        _pWizard->bNoPageChange() = TRUE;
                        break;
                    }
                }
            }
            else
            {
                iMessageId = IDS_ERR_ADD_ONLY_PRINTERS;
                bStatus DBGCHK = FALSE;
                break;
            }
        }
    }

    //
    // If a printer was installed successfully
    //
    if( bStatus )
    {
        //
        // If no items were selected stay on this page, if the user
        // want to exit they will have to hit the cancel button.
        //
        if( Query.cItems() == 0 )
        {
            //
            // Do not switch away from this page.
            //
            _pWizard->bNoPageChange() = TRUE;
        }
        else
        {

            //
            // Check for a default printer.
            //
            if( !_pWizard->bIsPrinterFolderEmpty() )
            {
                //
                // Always set it as the default, skip the set as default page.
                //
                _pWizard->bSetDefault() = TRUE;

                //
                // Don't show the set as default UI.
                //
                _pWizard->bShowSetDefault() = FALSE;
            }

            //
            // If more then one item was selected and the default printer
            // has already been set, don't prompt for setting the default
            // printer.
            //
            if( Query.cItems() > 1 && _pWizard->bSetDefault() == FALSE )
            {
                //
                // Don't show the set as default UI.
                //
                _pWizard->bShowSetDefault() = FALSE;

                //
                // Indicate no printer connection was made to prevent setting
                // the default printer, at wizard termination.
                //
                _pWizard->bConnected() = FALSE;
            }
            else
            {
                //
                // Indicate a printer connection has been made.
                //
                _pWizard->bConnected() = TRUE;

                //
                // Set the printer name.  This is need to set the default
                // printer when the wizard terminates.
                //
                bStatus DBGCHK = _pWizard->strPrinterName().bUpdate( strPrinterName );
            }
        }
    }

    if( !bStatus )
    {
        if( !bErrorMessageAlreadyDisplayed )
        {
            //
            // Something failed display an error message.
            //
            iMessage( _hDlg,
                      IDS_ERR_ADD_PRINTER_TITLE,
                      iMessageId,
                      MB_OK|MB_ICONHAND,
                      iMessageId == IDS_ERR_ADD_PRINTER_CONNECTION ? kMsgGetLastError : kMsgNone,
                      NULL );
        }

        //
        // Do not switch away from this page.
        //
        _pWizard->bNoPageChange() = TRUE;
    }
}

BOOL
TWizLocate::
bHandle_WizNext(
    VOID
    )
{
    //
    // Assume success
    //
    BOOL bResult = TRUE;

    //
    // Read the edit control.
    //
    vReadUI();

    switch( _pWizard->_LocateType )
    {
        case TWizard::kSearch:
            {
                if( TWizard::kDsStatusAvailable == _pWizard->eIsDsAvailablePerUser() )
                {
                    //
                    // If DS is avilable then let the user to search for a printer.
                    // otherwise just skip to the next page.
                    //
                    vSearch();
                }
            }
            break;

        case TWizard::kBrowseNET:
            if( !_pWizard->bDownlevelBrowse() || strConnectToNET().uLen() )
            {
                //
                // If downlevel browsing is not enabled then we enforce
                // connection here. otherwise just skip to the browse page.
                //
                bResult = Handle_ConnectToPrinterName();
            }
            break;

        case TWizard::kBrowseURL:
            {
                //
                // Try to connect to the specified network name
                //
                bResult = Handle_ConnectToPrinterName();
            }
            break;
    }

    return bResult;
}

BOOL
TWizLocate::
bHandle_WizBack(
    VOID
    )
{
    //
    // Read the edit controls.
    //
    vReadUI();

    return TRUE;
}

BOOL
TWizLocate::
bHandle_Command(
    IN WORD wId,
    IN WORD wNotifyId,
    IN HWND hwnd
    )
{
    BOOL bStatus = TRUE;

    switch( wId )
    {
        case IDC_DS_SEARCH:
        case IDC_NET_BROWSE:
        case IDC_URL_BROWSE:
            {
                //
                // Check to enable/disable controls depending
                // on connect type selection
                //
                EnableWindow( GetDlgItem( _hDlg, IDC_CONNECT_TO_URL ),   wId == IDC_URL_BROWSE );
                EnableWindow( GetDlgItem( _hDlg, IDC_CONNECT_TO_NET ),   wId == IDC_NET_BROWSE );

                //
                // Setup the focus to the apropriate edit control
                //
                if( wId == IDC_URL_BROWSE )
                {
                    SetFocus( GetDlgItem( _hDlg, IDC_CONNECT_TO_URL ) );
                }

                if( wId == IDC_NET_BROWSE )
                {
                    SetFocus( GetDlgItem( _hDlg, IDC_CONNECT_TO_NET ) );
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }

    return bStatus;
}

BOOL
TWizLocate::
bHandle_Notify(
    IN WPARAM   wIdCtrl,
    IN LPNMHDR  pnmh
    )
{
    BOOL bStatus = FALSE;

    switch( pnmh->code )
    {
        case NM_RETURN:
        case NM_CLICK:
            if( IDC_BROWSELINK_BTN == wIdCtrl )
            {
                bStatus = Handle_URLBrowseClick( );
            }
            break;
    }

    return bStatus;
}

/********************************************************************

    Test page.

********************************************************************/

TWizTestPage::
TWizTestPage(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizTestPage::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Set the test page setting.
    //
    INT iValueId = _pWizard->bTestPage() ? IDC_RADIO_YES : IDC_RADIO_NO;

    //
    // By default, don't make it the default printer.
    //
    bStatus DBGCHK = CheckRadioButton( _hDlg,
                                       IDC_RADIO_YES,
                                       IDC_RADIO_NO,
                                       iValueId );

    //
    // Set the additional driver check state.
    //
    vSetCheck( _hDlg, IDC_ADDITIONAL_DRIVERS, _pWizard->_bAdditionalDrivers );

    return TRUE;
}

BOOL
TWizTestPage::
bHandle_SetActive(
    VOID
    )
{
    UINT uFlags = SW_HIDE;

    //
    // If we are to add additional drivers and not the existing driver and not using 'HaveDisk'.
    //
    if( _pWizard->_dwAdditionalDrivers != -1 && _pWizard->_bUseNewDriver && !_pWizard->_Di.bIsOemDriver() )
    {
        uFlags = SW_NORMAL;
    }

    //
    // Set the control states.
    //
    ShowWindow( GetDlgItem( _hDlg, IDC_ADDITIONAL_DRIVERS_TEXT ),  uFlags );
    ShowWindow( GetDlgItem( _hDlg, IDC_ADDITIONAL_DRIVERS ),       uFlags );

    return TRUE;
}

VOID
TWizTestPage::
vReadUI(
    VOID
    )
{
    //
    // Read the test page setting from the ui.
    //
    if( IsDlgButtonChecked( _hDlg, IDC_RADIO_YES ) == BST_CHECKED )
    {
        _pWizard->_bTestPage = TRUE;
    }
    else
    {
        _pWizard->_bTestPage = FALSE;
    }

    //
    // Read the additional drivers from the check box control.
    //
    if( _pWizard->_dwAdditionalDrivers != -1 && _pWizard->_bUseNewDriver )
    {
        _pWizard->_bAdditionalDrivers = bGetCheck( _hDlg, IDC_ADDITIONAL_DRIVERS );
    }
}

BOOL
TWizTestPage::
bHandle_WizNext(
    VOID
    )
{
    vReadUI();
    return TRUE;
}

/********************************************************************

    Driver introduction page.

********************************************************************/

TWizDriverIntro::
TWizDriverIntro(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizDriverIntro::
bHandle_InitDialog(
    VOID
    )
{
    TString strTemp;
    TCHAR szServerName[kDNSMax + 1];

    //
    // The fonts for the Word 97 wizard style.
    //
    SetControlFont( _pWizard->_hBigBoldFont, _hDlg, IDC_MAIN_TITLE );

    //
    // If we are admining a remote server, we'll change the title and text.
    // And we need to check the priviledge to add printer on remote server.
    //
    if( bIsRemote( _pWizard->pszServerName() ) )
    {
        //
        // Remove "\\" from the server name, and change the server name
        // to lower case
        //
        lstrcpy( szServerName, (LPTSTR)_pWizard->pszServerName() + 2 );
        CharLower( szServerName );

        //
        // Change "Add Printer Driver Wizard" to "Add Printer Driver Wizard on '%s.'"
        //
        strTemp.bLoadString( ghInst, IDS_ADD_DRIVER_TITLE_REMOTE );
        _pWizard->_strTitle.bFormat( strTemp, szServerName );

        PropSheet_SetTitle( GetParent( _hDlg ), 0, _pWizard->_strTitle );

        //
        // change the test for intro to fit remote APDW
        //
        strTemp.bLoadString( ghInst, IDS_ADD_DRIVER_INTRO_REMOTE );
        strTemp.bFormat( strTemp, szServerName );
        bSetEditText( _hDlg, IDC_MAIN_TITLE, strTemp );

    }

    if( _pWizard->_bSkipArchSelection )
    {
        TString strTitle;

        if( strTitle.bLoadString( ghInst, IDS_DRIVER_INTRO_TEXT ) )
        {
            SetWindowText( GetDlgItem( _hDlg, IDC_DRIVER_INTRO_TEXT1 ), (LPCTSTR)strTitle );
        }

        ShowWindow( GetDlgItem( _hDlg, IDC_DRIVER_INTRO_TEXT2 ), SW_HIDE );
    }

    //
    // Let the wizard to initialize itself.
    //
    _pWizard->OnWizardInitro( hDlg() );

    return TRUE;
}

BOOL
TWizDriverIntro::
bHandle_SetActive(
    VOID
    )
{
    PropSheet_SetTitle( GetParent( _hDlg ), PSH_DEFAULT, _pWizard->_strTitle );
    return TRUE;
}

/********************************************************************

    Architecture page.

********************************************************************/

TWizArchitecture::
TWizArchitecture(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizArchitecture::
bHandle_InitDialog(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Set the architecture list view UI.
    //
    bStatus DBGCHK = _pWizard->ArchLV().bSetUI( _hDlg );

    return TRUE;
}

BOOL
TWizArchitecture::
bHandle_WizNext(
    VOID
    )
{
    TStatusB    bStatus;
    BOOL        bInstalled              = FALSE;
    DWORD       dwEncode                = 0;
    UINT        uNotInstalledItemCount  = 0;

    //
    // Get the selected item count.
    //
    UINT cSelectedCount = _pWizard->ArchLV().uGetCheckedItemCount();

    //
    // Fill the driver list view with the selected architectures from
    // the architecture list view.
    //
    for( UINT i = 0; i < cSelectedCount; i++ )
    {
        bStatus DBGCHK = _pWizard->ArchLV().bGetCheckedItems( i, &bInstalled, &dwEncode );

        if( bStatus )
        {
            if( !bInstalled )
            {
                uNotInstalledItemCount++;
            }
        }
    }

    //
    // If a non installed item was not checked then warn the user.
    //
    if( !uNotInstalledItemCount )
    {
        //
        // At least one version must be choosen to switch pages.
        //
        iMessage( _hDlg,
                  IDS_DRIVER_WIZ_TITLE,
                  IDS_ERR_ATLEAST_ONE_VERSION,
                  MB_OK|MB_ICONHAND,
                  kMsgNone,
                  NULL );
        //
        // Don't switch to the next page.
        //
        _pWizard->bNoPageChange() = TRUE;
    }

    return TRUE;
}

BOOL
TWizArchitecture::
bHandle_SetActive(
    VOID
    )
{
    //
    // Show the hour glass this can take a while
    // when talking to a remote machine.
    //
    TWaitCursor Cursor;

    //
    // Parse the driver data.
    //
    if( _pWizard->bParseDriver( _hDlg ) )
    {
        //
        // If the driver changed or a driver was installed
        // then refresh the architecture list.  Since the driver
        // install count is always incrementing once a driver
        // was installed we will always fresh the the architecture
        // list.  I supect this will happen seldom, but it could
        // lead to slow page changes in the remote case.  Since
        // we hit the net to determine if the printer driver
        // is installed.
        //
        if( _pWizard->bDriverChanged() == TRUE || _pWizard->_nDriverInstallCount )
        {
            _pWizard->bDriverChanged() = FALSE;

            //
            // Refresh the architecture list.
            //
            TStatusB bStatus;
            bStatus DBGCHK = _pWizard->ArchLV().bRefreshListView( _pWizard->pszServerName(),
                                                                  _pWizard->strDriverName() );
            //
            // Check the default architecture.
            //
            bStatus DBGCHK = _pWizard->ArchLV().bSetCheckDefaultArch( _pWizard->pszServerName() );

            //
            // Select the first item in the list view.
            //
            _pWizard->ArchLV().vSelectItem( 0 );
        }
    }

    return TRUE;
}

BOOL
TWizArchitecture::
bHandle_Notify(
    IN WPARAM   wParam,
    IN LPNMHDR  pnmh
    )
{
    //
    // Forward notify messages to the architecture list view.
    //
    return _pWizard->ArchLV().bHandleNotifyMessage( WM_NOTIFY, wParam, (LPARAM)pnmh );
}

/********************************************************************

    Install driver end page.

********************************************************************/

TWizDriverEnd::
TWizDriverEnd(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizDriverEnd::
bHandle_InitDialog(
    VOID
    )
{
    //
    // The fonts for the Word 97 wizard style.
    //
    SetControlFont( _pWizard->_hBigBoldFont, _hDlg, IDC_MAIN_TITLE );

    //
    // check to see if the wizard is restartable and if so
    // show the appropriate checkbox
    //
    if( _pWizard->bRestartableFromLastPage() )
    {
        _pWizard->bRestartAgain() = TRUE; // assume "On" by default
        ShowWindow( GetDlgItem( _hDlg, IDC_RESTART_WIZARD ), SW_SHOW );
    }
    vSetCheck( _hDlg, IDC_RESTART_WIZARD, _pWizard->bRestartAgain() );

    return TRUE;
}

BOOL
TWizDriverEnd::
bHandle_SetActive(
    VOID
    )
{
    TStatusB bStatus;

    //
    // If the architecture page was skipped.
    // We will add this platforms driver.
    //
    if( _pWizard->bSkipArchSelection() )
    {
        //
        // Parse the selected inf file.
        //
        bStatus DBGCHK = _pWizard->bParseDriver( _hDlg );
    }
    else
    {
        bStatus DBGNOCHK = FALSE;
    }

    vDisplaySelectedDrivers();

    return bStatus;
}

VOID
TWizDriverEnd::
vDisplaySelectedDrivers(
    VOID
    )
{
    TStatusB    bStatus;
    TDriverInfo DriverInfo;
    TString     strResults;
    BOOL        bInstalled;
    DWORD       dwEncode;
    TCHAR const cszFormat[] = TEXT("%s, %s, %s\r\n");

    //
    // If the architecture page was skipped.
    // We will add this platforms driver.
    //
    if( _pWizard->bSkipArchSelection() )
    {
        //
        // Get the current driver encode, this is then native driver.
        //
        bStatus DBGCHK = _pWizard->_Di.bGetCurrentDriverEncode( &dwEncode );

        if( bStatus )
        {
            TString strEnvironment;
            TString strVersion;

            (VOID)TArchLV::bEncodeToArchAndVersion( dwEncode, strEnvironment, strVersion );

            bStatus DBGCHK = strResults.bFormat( cszFormat,
                                                 static_cast<LPCTSTR>( _pWizard->strDriverName() ),
                                                 static_cast<LPCTSTR>( strEnvironment ),
                                                 static_cast<LPCTSTR>( strVersion ) );
        }
    }
    else
    {
        //
        // Get the selected item count.
        //
        UINT cSelectedCount = _pWizard->ArchLV().uGetCheckedItemCount();

        //
        // Display the results of the users selection.
        //
        for( UINT i = 0; i < cSelectedCount; i++ )
        {
            bStatus DBGCHK = _pWizard->ArchLV().bGetCheckedItems( i, &bInstalled, &dwEncode );

            if( bStatus && !bInstalled )
            {
                TString strEnvironment;
                TString strVersion;

                (VOID)TArchLV::bEncodeToArchAndVersion( dwEncode, strEnvironment, strVersion );

                TString strFmt;
                bStatus DBGCHK = strFmt.bFormat( cszFormat,
                                                 static_cast<LPCTSTR>( _pWizard->strDriverName() ),
                                                 static_cast<LPCTSTR>( strEnvironment ),
                                                 static_cast<LPCTSTR>( strVersion ) );
                if( bStatus )
                {
                    bStatus DBGCHK = strResults.bCat( strFmt );
                }
            }
        }
    }

    if( !strResults.bEmpty() )
    {
        bStatus DBGCHK = bSetEditText( _hDlg, IDC_DRIVER_SELECTION_SUMMARY, strResults );
    }
}

BOOL
TWizDriverEnd::
bHandle_WizFinish(
    VOID
    )
{
    DWORD dwEncode = static_cast<DWORD>(-1);
    TStatusB bStatus;

    _pWizard->bRestartAgain() = bGetCheck( _hDlg, IDC_RESTART_WIZARD );

    //
    // If the architecture page was skipped.
    // We will add the native driver.
    //
    if( _pWizard->bSkipArchSelection() )
    {
        bStatus DBGCHK = bInstallNativeDriver( &dwEncode );
    }
    else
    {
        bStatus DBGCHK = bInstallSelectedDrivers( &dwEncode );
    }

    if( !bStatus )
    {
        switch( GetLastError() )
        {
            case ERROR_CANCELLED:
                break;

            case ERROR_UNKNOWN_PRINTER_DRIVER:
                {
                    iMessage( _hDlg,
                              IDS_DRIVER_WIZ_TITLE,
                              IDS_ERROR_UNKNOWN_DRIVER,
                              MB_OK | MB_ICONSTOP,
                              kMsgNone,
                              NULL );
                }
                break;

            default:
                //
                // in the case where bInstallSelectedDrivers fails there is no way to tell why it
                // has failed and there is no guarantee that dwEncode will be set correctly to a valid
                // arch/ver encoding. to avoid showing incorrect error messages and/or plain crashes we
                // need to assign an invalid value and then check to see if it has been set correctly.
                //
                {
                    if( static_cast<DWORD>(-1) != dwEncode )
                    {
                        TString strEnvironment;
                        TString strVersion;

                        (VOID)TArchLV::bEncodeToArchAndVersion( dwEncode, strEnvironment, strVersion );

                        //
                        // An error occurred installing a printer driver.
                        //
                        iMessage( _hDlg,
                                  IDS_DRIVER_WIZ_TITLE,
                                  IDS_ERR_ALL_DRIVER_NOT_INSTALLED,
                                  MB_OK|MB_ICONHAND,
                                  kMsgGetLastError,
                                  NULL,
                                  static_cast<LPCTSTR>( _pWizard->strDriverName() ),
                                  static_cast<LPCTSTR>( strVersion ),
                                  static_cast<LPCTSTR>( strEnvironment ) );
                    }
                    else
                    {
                        //
                        // in this case we don't really know what happened, so just show a generic error message
                        //
                         iMessage( _hDlg,
                                  IDS_DRIVER_WIZ_TITLE,
                                  IDS_ERR_GENERIC,
                                  MB_OK|MB_ICONHAND,
                                  kMsgGetLastError,
                                  NULL );
                    }
                }
                break;
        }

        //
        // Don't switch to the next page.
        //
        _pWizard->bNoPageChange() = TRUE;
    }
    else
    {
        //
        // bPrinterCreated flag is overloaded in the add printer driver
        // wizard, it indicates that the driver was added successfully.
        //
        _pWizard->bPrinterCreated() = TRUE;
    }

    //
    // Let the wizard cleanup here.
    //
    _pWizard->OnWizardFinish( _hDlg );

    return bStatus;
}

BOOL
TWizDriverEnd::
bInstallNativeDriver(
    OUT DWORD *pdwEncode
    )
{
    TStatusB    bStatus;

    //
    // Get the current driver encode, this is then native driver.
    //
    bStatus DBGCHK = _pWizard->_Di.bGetCurrentDriverEncode( pdwEncode );

    if( bStatus )
    {
        //
        // Install the driver.
        //
        bStatus DBGCHK = bInstallDriver( _hDlg, *pdwEncode, _pWizard->_Di, FALSE, 0, &(_pWizard->strDriverName()) );
    }

    return bStatus;
}

BOOL
TWizDriverEnd::
bInstallSelectedDrivers(
    OUT DWORD *pdwEncode
    )
{
    BOOL        bInstalled;
    TStatusB    bStatus;

    //
    // Initialize the status return value.
    //
    bStatus DBGNOCHK = TRUE;

    //
    // Get the selected item count.
    //
    UINT cSelectedCount = _pWizard->ArchLV().uGetCheckedItemCount();

    //
    // Fill the driver list view with the selected architectures from
    // the architecture list view.
    //
    for( UINT i = 0; i < cSelectedCount; i++ )
    {
        bStatus DBGCHK = _pWizard->ArchLV().bGetCheckedItems( i, &bInstalled, pdwEncode );

        if( bStatus && !bInstalled )
        {

            bStatus DBGCHK = bInstallDriver( _hDlg, *pdwEncode, _pWizard->_Di, _pWizard->bUseWeb(), 0, &(_pWizard->strDriverName()) );

            //
            // If the installation was successful keep track of the number of
            // drivers that were actually installed.  This information is necceasary
            // for determining if the drivers list view needs to be refreshed.
            //
            if( bStatus )
            {
                _pWizard->_nDriverInstallCount++;
            }

            //
            // Exit the loop if any of the drivers fail to install.
            //
            if( !bStatus )
            {
                break;
            }
        }
    }

    return bStatus;
}

BOOL
TWizDriverEnd::
bInstallDriver(
    IN HWND                         hwnd,
    IN DWORD                        dwEncode,
    IN TPrinterDriverInstallation   &Di,
    IN BOOL                         bFromWeb,
    IN DWORD                        dwDriverFlags,
    OUT TString                     *pstrDriverName
    )
{
    TStatusB bStatus;

    //
    // Get the current install flags.
    //
    DWORD dwPrevInstallFlags = Di.GetInstallFlags();

    //
    // We do not copy the inf for version 2 drivers.
    //
    if( GetDriverVersion( dwEncode ) == 2 )
    {
        //
        // We don't copy the inf for version 2 drivers.
        //
        dwDriverFlags |= DRVINST_DONOTCOPY_INF;
    }

    //
    // Set the install flags.
    //
    Di.SetInstallFlags( dwDriverFlags );

    //
    // Install the driver.
    //
    BOOL bOfferReplacementDriver = TRUE;
    bStatus DBGCHK = Di.bInstallDriver(
        pstrDriverName, bOfferReplacementDriver, bFromWeb, hwnd, dwEncode);

    //
    // Restore the previous install flags.
    //
    Di.SetInstallFlags( dwPrevInstallFlags );

    return bStatus;
}


/********************************************************************

    Pre select driver wizard page

********************************************************************/
TWizPreSelectDriver::
TWizPreSelectDriver(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizPreSelectDriver::
bHandle_SetActive(
    VOID
    )
{
    //
    // Toggle the direction flag.
    //
    _pWizard->bPreDir() = _pWizard->bPreDir() == FALSE ? TRUE : FALSE;

    //
    // Preselect the driver using the previous driver
    // the user selected.
    //
    if( !_pWizard->strDriverName().bEmpty() )
    {
        TWaitCursor Cursor;

        TStatusB bStatus;
        bStatus DBGCHK = _pWizard->_Di.bSetDriverName( _pWizard->strDriverName() );
        bStatus DBGCHK = _pWizard->_Di.bGetSelectedDriver( TRUE );
    }

    return TRUE;
}

/********************************************************************

    Post select driver wizard page

********************************************************************/
TWizPostSelectDriver::
TWizPostSelectDriver(
    TWizard* pWizard
    ) : MWizardProp( pWizard )
{
}

BOOL
TWizPostSelectDriver::
bHandle_SetActive(
    VOID
    )
{
    if( _pWizard->uAction() == TWizard::kPnPInstall     ||
        _pWizard->uAction() == TWizard::kPrinterInstall ||
        _pWizard->uAction() == TWizard::kPrinterInstallModeless )
    {
        //
        // Parse the driver data.
        //
        if( _pWizard->bParseDriver( _hDlg ) )
        {
            //
            // Check if the diriver exists.
            //
            _pWizard->bUseNewDriver() = _pWizard->bDriverExists() ? FALSE : TRUE;
        }
    }

    //
    // Toggle the direction flag.
    //
    _pWizard->bPostDir() = _pWizard->bPostDir() == FALSE ? TRUE : FALSE;

    return TRUE;
}

BOOL
bFindPrinter(
    IN HWND     hwnd,
    IN LPTSTR   pszBuffer,
    IN UINT     *puSize
    )
{
    DBGMSG( DBG_TRACE, ( "bFindPrinter\n" ) );

    SPLASSERT( pszBuffer );
    SPLASSERT( puSize );

    TStatusB bStatus;
    TString strPrinterName;
    TString strRealPrinterName;
    TDirectoryService Ds;

    if( Ds.bIsDsAvailable() )
    {
        //
        // Create the query object.
        //
        TQuery Query( hwnd );

        //
        // Ensue the query object is valid.
        //
        bStatus DBGCHK = VALID_OBJ( Query );

        if( bStatus )
        {
            //
            // Display the ds printer query dialog.
            //
            bStatus DBGCHK = Query.bDoQuery();

            //
            // Show waiting cursor when building printer connections.
            //
            TWaitCursor Cur;

            //
            // For all printers selected in the results pane install the
            // selected printer.
            //
            for( UINT i = 0; i < Query.cItems(); i++ )
            {
                DBGMSG( DBG_TRACE, ( "cItems %d\n", Query.cItems() ) );
                DBGMSG( DBG_TRACE, ( "Name  " TSTR "\n", (LPCTSTR)(Query._pItems[i]._strName) ) );
                DBGMSG( DBG_TRACE, ( "Class " TSTR "\n", (LPCTSTR)(Query._pItems[i]._strClass) ) );

                //
                // We want to only install printer selected devices.
                //
                if( Query.pItems()[i].strClass() == gszDsPrinterClassName )
                {
                    //
                    // Get the printer name from the DS name.
                    //
                    bStatus DBGCHK = Query.bPrinterName( strPrinterName, Query.pItems()[i].strName() );

                    if( bStatus )
                    {
                        //
                        // Install network printer connection.
                        //
                        bStatus DBGCHK = PrintUIAddPrinterConnectionUIEx( hwnd, strPrinterName, &strRealPrinterName );

                        if( bStatus && i == 1 )
                        {
                            bStatus DBGCHK = strPrinterName.bUpdate( strRealPrinterName );
                        }
                    }
                }
            }
        }
    }
    else
    {
        //
        // Allow a user to browse for a printer conneciton.
        //
        bStatus DBGCHK = TWizType::bConnectToPrinter( hwnd, strPrinterName );
    }

    //
    // If everything succeeded and a printer was returned
    // check if there is a default printer and if not set then
    // set this printer as the default.
    //
    if( bStatus && !strPrinterName.bEmpty() )
    {
        if( pszBuffer )
        {
            if( *puSize > strPrinterName.uLen() )
            {
                //
                // Copy the printer name to the supplied buffer if it fits.
                //
                _tcsncpy( pszBuffer, strPrinterName, *puSize );
            }
            else
            {
                *puSize = strPrinterName.uLen()+1;
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                bStatus DBGNOCHK = FALSE;
            }
        }

        if( bStatus )
        {
            //
            // Set the default printer if there is no default printer.
            //
            TCHAR  szPrinter[kPrinterBufMax] = {0};
            DWORD  dwSize      = COUNTOF( szPrinter );

            //
            // Get the default printer.
            //
            bStatus DBGNOCHK = GetDefaultPrinter( szPrinter, &dwSize );

            if( !bStatus )
            {
                bStatus DBGCHK = SetDefaultPrinter( strPrinterName );
            }
        }
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\select.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1998
All rights reserved.

Module Name:

    Select.cxx

Abstract:

    Handles queuing and processing of commands.
    This module should _not_ be aware of any interfaces beyond
    TPrinter and MPrinterClient (i.e., no listview code).

Author:

    Albert Ting (AlbertT)  07-13-1995
    Steve Kiraly (SteveKi)  10-23-1995 Additional comments.


Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "select.hxx"

/********************************************************************

    Retrieve state of selected items.

********************************************************************/

TSelection::
TSelection(
    IN const MPrinterClient* pPrinterClient,
    IN const TPrinter* pPrinter
    ) : _pid( NULL ), _cSelected( 0 )

/*++

Routine Description:

    Get the JobIds of all selected jobs and the one that currently
    has focus.  This is used when a refresh occurs and we need
    to update the queue while keeping selected items selected.

    Note: this routine is very slow, so we may want to optimize
    it if it uses too much cpu bandwidth.  It should only be called on a
    full refresh (every 10 seconds on downlevel, rare on uplevel).

    This routine is very inefficient with TDataNotify, and not
    as bad with TDataRefresh.

    Must be called from UI thread.

Arguments:

    pPrinterClient - Client from which we will grab selections.

    pPrinter - Printer.

Return Value:

--*/

{
    UNREFERENCED_PARAMETER( pPrinter );

    SINGLETHREAD(UIThread);

    //
    // Quit if no printer client.
    //
    if( !pPrinterClient ){
        return;
    }

    //
    // Quit if no selections.
    //
    _cSelected = pPrinterClient->cSelected();
    if( !_cSelected ){
        return;
    }

    //
    // Allocate the variable length Job Id array within the
    // selection class.  This optimizes the number of memory allocations.
    // Note the non-use of the new operator.  This really is not a good
    // thing, it is the price we pay for greater efficiency.
    //
    _pid = (PIDENT) AllocMem( sizeof( IDENT ) * _cSelected );

    if( !_pid ){
        return;
    }

    if( pPrinterClient ){

        //
        // Put selected jobs in array.
        //

        HITEM hItem = pPrinterClient->GetFirstSelItem();
        COUNT i = 0;

        //
        // Strange looking FOR loop to prevent GetNextSelItem being
        // called any extra times.
        //
        for( ; ; ){

            _pid[i] = pPrinterClient->GetId( hItem );

            ++i;
            if( i == _cSelected ){
                break;
            }

            hItem = pPrinterClient->GetNextSelItem( hItem );
        }
    }
}

TSelection::
~TSelection(
    VOID
    )

/*++

Routine Description:

    Free the object.
    Callable from any thread.

Arguments:

Return Value:

--*/

{
    FreeMem( _pid );
}

/********************************************************************

    Command line argument selection

********************************************************************/

TSelect::
TSelect(
    VOID
    )
{
}

TSelect::
~TSelect(
    VOID
    )
{
}

TSelect::
bValid(
    VOID
    )
{
    return TRUE;
}

BOOL
TSelect::
bLookup( 
    IN Selection *pSelection,
    IN PVOID      pInfo,
    IN LPCTSTR    pKey,
    IN LPCTSTR    pValue
    )
{
    SPLASSERT( pSelection );
    SPLASSERT( pInfo );
    SPLASSERT( pKey );
    SPLASSERT( pValue );

    BOOL bStatus = FALSE;

    if( pKey && pValue )
    {
        for( ; pSelection->iKeyWord; pSelection++ )
        {
            if( bMatch( pKey, pSelection->iKeyWord ) )
            {
                switch( pSelection->eDataType )
                {
                case kString:
                    *(LPCTSTR *)((LPBYTE)pInfo+pSelection->iOffset) = pValue;
                    bStatus = TRUE;
                    break;

                case kInt:
                    {
                        LPCTSTR pszFmt = (*pValue == TEXT('0') && *(pValue+1) == TEXT('x')) ? TEXT("%x") : TEXT("%d");
                        bStatus = _stscanf( pValue, pszFmt, (LPBYTE)pInfo+pSelection->iOffset );
                    }
                    break;

                case kBitTable:
                    bStatus = bLookupBitTable( (SelectionBit *)pSelection->pTable, pValue );
                    break;

                case kValTable:
                    bStatus = bLookupValTable( (SelectionVal *)pSelection->pTable, pInfo, pValue );
                    break;
                    
                default:
                    bStatus = FALSE;
                    break;
                }
                break;
            }
        }
    }
    return bStatus;
}    

BOOL
TSelect::
bLookupBitTable( 
    IN SelectionBit *pBitTable, 
    IN LPCTSTR      pKey 
    )
{
    SPLASSERT( pBitTable );
    SPLASSERT( pKey );

    BOOL bStatus = FALSE;

    if( pKey )
    {
        EOperation Op = kNop;

        switch ( *pKey )
        {
        case TEXT('-'):
            Op = kNot;
            pKey++;
            break;

        case TEXT('+'):
            Op = kOr;
            pKey++;
            break;

        case TEXT('&'):
            Op = kAnd;
            pKey++;
            break;

        case TEXT('^'):
            Op = kXor;
            pKey++;
            break;

        default:
            Op = kOr;
            break;
        }

        for( ; pBitTable->iKeyWord; pBitTable++ )
        {
            if( bMatch( pKey, pBitTable->iKeyWord ) )
            {
                pBitTable->Op = Op;
                bStatus = TRUE;
                break;
            }
        }
    }
    return bStatus;
}


BOOL
TSelect::
bLookupValTable( 
    IN SelectionVal *pValTable, 
    IN PVOID        pInfo,
    IN LPCTSTR      pKey 
    )
{
    SPLASSERT( pValTable );
    SPLASSERT( pInfo );
    SPLASSERT( pKey );

    BOOL bStatus = FALSE;

    if( pKey )
    {
        for( ; pValTable->iKeyWord; pValTable++ )
        {
            if( bMatch( pKey, pValTable->iKeyWord ) )
            {
                *(UINT *)((LPBYTE)pInfo+pValTable->iOffset) = pValTable->uValue;
                bStatus = TRUE;
                break;
            }
        }
    }
    return bStatus;
}

BOOL
TSelect::
bApplyBitTableToValue( 
    IN SelectionBit *pBitTable, 
    IN UINT         uBit, 
    IN LPDWORD      pdwBit
    )
{
    SPLASSERT( pBitTable );
    SPLASSERT( pdwBit );

    BOOL bStatus = FALSE;

    for( ; pBitTable->iKeyWord; pBitTable++ )
    {
        switch ( pBitTable->Op )
        {
        case kNot:
            uBit = uBit & ~pBitTable->uBit;
            bStatus = TRUE;
            break;

        case kOr:
            uBit = uBit | pBitTable->uBit;
            bStatus = TRUE;
            break;

        case kAnd:
            uBit = uBit & pBitTable->uBit;
            bStatus = TRUE;
            break;

        case kXor:
            uBit = uBit ^ pBitTable->uBit;
            bStatus = TRUE;
            break;

        case kNop:
            break;

        default:
            break;
        }
    }

    if( bStatus && pdwBit )
    {
        *pdwBit = uBit;
    }

    return bStatus;
}

BOOL
TSelect::
bMatch(
    IN LPCTSTR  pszString,
    IN UINT     iResId
    )
{
    TString strString;
    TStatusB bStatus;

    bStatus DBGCHK = strString.bLoadString( ghInst, iResId );

    return bStatus && !_tcsicmp( pszString, strString );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\spcompat.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    spcompat.cxx

Abstract:

    porting the spool library code into printui

Author:

    Lazar Ivanov (LazarI)  Jul-05-2000

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

///////////////////////////////////////////////////
// @@file@@ debug.cxx
///////////////////////////////////////////////////

#if DBG

/********************************************************************

    TStatus automated error logging and codepath testing.

********************************************************************/

TStatusBase&
TStatusBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusBase&)*this;
}



TStatusBase&
TStatusBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusBase&)*this;
}


DWORD
TStatus::
dwGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _dwStatus;
}


DWORD
TStatusBase::
operator=(
    DWORD dwStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //
    if( _pszFileA &&
        dwStatus != ERROR_SUCCESS &&
        dwStatus != _dwStatusSafe1 &&
        dwStatus != _dwStatusSafe2 &&
        dwStatus != _dwStatusSafe3 ){

        DBGMSG( DBG_WARN,
                ( "TStatus set to %d\nLine %d, %hs\n",
                  dwStatus,
                  _uLine,
                  _pszFileA ));
    }

    return _dwStatus = dwStatus;
}

/********************************************************************

    Same, but for HRESULTs.

********************************************************************/

TStatusHBase&
TStatusHBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusH&)*this;
}

TStatusHBase&
TStatusHBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusH&)*this;
}

HRESULT
TStatusHBase::
operator=(
    HRESULT hrStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //


    if( _pszFileA &&
        FAILED(hrStatus)           &&
        hrStatus != _hrStatusSafe1 &&
        hrStatus != _hrStatusSafe2 &&
        hrStatus != _hrStatusSafe3 ){

        DBGMSG( DBG_WARN,
                ( "TStatusH set to %x\nLine %d, %hs\n",
                  hrStatus,
                  _uLine,
                  _pszFileA ));
    }

    return _hrStatus = hrStatus;
}

HRESULT
TStatusH::
hrGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _hrStatus;
}
/********************************************************************

    Same, but for BOOLs.

********************************************************************/

TStatusBBase&
TStatusBBase::
pNoChk(
    VOID
    )
{
    _pszFileA = NULL;
    return (TStatusBBase&)*this;
}

TStatusBBase&
TStatusBBase::
pSetInfo(
    UINT uDbg,
    UINT uLine,
    LPCSTR pszFileA,
    LPCSTR pszModuleA
    )
{
    _uDbg = uDbg;
    _uLine = uLine;
    _pszFileA = pszFileA;
    SPLASSERT( pszFileA );

    _pszModuleA = pszModuleA;

    return (TStatusBBase&)*this;
}

BOOL
TStatusB::
bGetStatus(
    VOID
    )
{
    //
    // For now, return error code.  Later it will return the actual
    // error code.
    //
    return _bStatus;
}


BOOL
TStatusBBase::
operator=(
    BOOL bStatus
    )
{
    //
    // Check if we have an error, and it's not one of the two
    // accepted "safe" errors.
    //
    // If pszFileA is not set, then we can safely ignore the
    // error as one the client intended.
    //
    if( _pszFileA && !bStatus ){

        DWORD dwLastError = GetLastError();

        if( dwLastError != _dwStatusSafe1 &&
            dwLastError != _dwStatusSafe2 &&
            dwLastError != _dwStatusSafe3 ){

            DBGMSG( DBG_WARN,
                    ( "TStatusB set to FALSE, LastError = %d\nLine %d, %hs\n",
                      GetLastError(),
                      _uLine,
                      _pszFileA ));
        }
    }

    return _bStatus = bStatus;
}

#endif // DBG

///////////////////////////////////////////////////
// @@file@@ string.cxx
///////////////////////////////////////////////////

//
// Class specific NULL state.
//
TCHAR TString::gszNullState[2] = {0,0};

//
// Default construction.
//
TString::
TString(
    VOID
    ) : _pszString( &TString::gszNullState[kValid] )
{
}

//
// Construction using an existing LPCTSTR string.
//
TString::
TString(
    IN LPCTSTR psz
    ) : _pszString( &TString::gszNullState[kValid] )
{
    bUpdate( psz );
}

//
// Destruction, ensure we don't free our NULL state.
//
TString::
~TString(
    VOID
    )
{
    vFree( _pszString );
}

//
// Copy constructor.
//
TString::
TString(
    const TString &String
    ) : _pszString( &TString::gszNullState[kValid] )
{
    bUpdate( String._pszString );
}

//
// Indicates if a string has any usable data.
//
BOOL
TString::
bEmpty(
    VOID
    ) const
{
    return _pszString[0] == 0;
}

//
// Indicates if a string object is valid.
//
BOOL
TString::
bValid(
    VOID
    ) const
{
    return _pszString != &TString::gszNullState[kInValid];
}

//
// Return the length of the string.
//
UINT
TString::
uLen(
    VOID
    ) const
{
    return lstrlen( _pszString );
}

BOOL
TString::
bCat(
    IN LPCTSTR psz
    )

/*++

Routine Description:

    Safe concatenation of the specified string to the string
    object. If the allocation fails, return FALSE and the
    original string is not modified.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    TRUE = update successful
    FALSE = update failed

--*/

{
    BOOL bStatus = FALSE;

    //
    // If a valid string was passed.
    //
    if( psz ){

        LPTSTR pszTmp = _pszString;

        //
        // Allocate the new buffer consisting of the size of the orginal
        // string plus the sizeof of the new string plus the null terminator.
        //
        _pszString = (LPTSTR)AllocMem(
                                ( lstrlen( pszTmp ) +
                                  lstrlen( psz ) +
                                  1 ) *
                                  sizeof ( pszTmp[0] ) );

        //
        // If memory was not available.
        //
        if( !_pszString ){

            //
            // Release the original buffer.
            //
            vFree( pszTmp );

            //
            // Mark the string object as invalid.
            //
            _pszString = &TString::gszNullState[kInValid];

        } else {

            //
            // Copy the string and concatenate the passed string.
            //
            lstrcpy( _pszString, pszTmp );
            lstrcat( _pszString, psz );

            //
            // Release the original buffer.
            //
            vFree( pszTmp );

            //
            // Indicate success.
            //
            bStatus = TRUE;

        }

    //
    // Skip null pointers, not an error.
    //
    } else {

        bStatus = TRUE;

    }

    return bStatus;
}

BOOL
TString::
bLimitBuffer(
    IN UINT nMaxLength
    )

/*++

Routine Description:

    Truncates th string if longer than nMaxLength 
    including the terminating character

Arguments:

    nMaxLength - the max length of the buffer

Return Value:

    TRUE if the string is truncated and FALSE otherwise

--*/

{
    BOOL bRet = FALSE;
    if( lstrlen(_pszString) >= nMaxLength )
    {
        // truncate up to nMaxLength including the terminating character
        _pszString[nMaxLength-1] = 0;
        bRet = TRUE;
    }
    return bRet;
}

BOOL
TString::
bDeleteChar(
    IN UINT nPos
    )
/*++

Routine Description:

    Deletes the character at the specified pos

Arguments:

    nPos - which char to delete

Return Value:

    TRUE if on success and FALSE otherwise

--*/
{
    BOOL bRet = FALSE;
    UINT u, uLen = lstrlen(_pszString);
    ASSERT(nPos < uLen);

    if( nPos < uLen )
    {
        // the new length
        uLen--; 

        // shift all the characters
        for( u=nPos; u<uLen; u++ )
        {
            _pszString[u] = _pszString[u+1];
        }

        // zero terminate
        _pszString[uLen] = 0;
        bRet = TRUE;
    }

    return bRet;
}

BOOL
TString::
bReplaceAll(
    IN TCHAR chFrom,
    IN TCHAR chTo
    )
/*++

Routine Description:

    replaces all chFrom characters to chTo

Arguments:

    chFrom  - character that needs to be replaced
    chTo    - character to replace with 

Return Value:

    TRUE if on success and FALSE otherwise

--*/
{
    UINT u, uLen = lstrlen(_pszString);
    for( u=0; u<uLen; u++ )
    {
        if( chFrom == _pszString[u] )
        {
            // replace
            _pszString[u] = chTo;
        }
    }
    return TRUE;
}

VOID
TString::
vToUpper(
    VOID
    )
/*++

Routine Description:

    converts the string to upper case

Arguments:

    None

Return Value:

    None

--*/
{
    if( _pszString && _pszString[0] )
    {
        CharUpper(_pszString);
    }
}

VOID
TString::
vToLower(
    VOID
    )
/*++

Routine Description:

    converts the string to lower case

Arguments:

    None

Return Value:

    None

--*/
{
    if( _pszString && _pszString[0] )
    {
        CharLower(_pszString);
    }
}

BOOL
TString::
bUpdate(
    IN LPCTSTR psz
    )

/*++

Routine Description:

    Safe updating of string.  If the allocation fails, return FALSE
    and leave the string as is.

Arguments:

    psz - Input string, may be NULL.

Return Value:

    TRUE = update successful
    FALSE = update failed

--*/

{
    //
    // Check if the null pointer is passed.
    //
    if( !psz ){

        //
        // If not pointing to the gszNullState
        //
        vFree( _pszString );

        //
        // Mark the object as valid.
        //
       _pszString = &TString::gszNullState[kValid];

        return TRUE;
    }

    //
    // Create temp pointer and allocate the new string.
    //
    LPTSTR pszTmp = _pszString;
    _pszString = (LPTSTR) AllocMem(( lstrlen(psz)+1 ) * sizeof( psz[0] ));

    //
    // If memory was not available.
    //
    if( !_pszString ){

        //
        // Ensure we free any previous string.
        //
        vFree( pszTmp );

        //
        // Mark the string object as invalid.
        //
        _pszString = &TString::gszNullState[kInValid];

        return FALSE;
    }

    //
    // Copy the string and
    //
    lstrcpy( _pszString, psz );

    //
    // If the old string object was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    vFree( pszTmp );

    return TRUE;
}

BOOL
TString::
bLoadString(
    IN HINSTANCE hInst,
    IN UINT uID
    )

/*++

Routine Description:

    Safe load of a string from a resources file.

Arguments:

    hInst - Instance handle of resource file.
    uId - Resource id to load.

Return Value:

    TRUE = load successful
    FALSE = load failed

--*/

{
    LPTSTR  pszString   = NULL;
    BOOL    bStatus     = FALSE;
    INT     iSize;
    INT     iLen;

    //
    // Continue increasing the buffer until
    // the buffer is big enought to hold the entire string.
    //
    for( iSize = kStrMax; ; iSize += kStrMax ){

        //
        // Allocate string buffer.
        //
        pszString = (LPTSTR)AllocMem( iSize * sizeof( pszString[0] ) );

        if( pszString ){

            iLen = LoadString( hInst, uID, pszString, iSize );

            if( iLen == 0 ) {

                DBGMSG( DBG_ERROR, ( "String.vLoadString: failed to load IDS 0x%x, %d\n",  uID, GetLastError() ));
                FreeMem( pszString );
                break;

            //
            // Since LoadString does not indicate if the string was truncated or it
            // just happened to fit.  When we detect this ambiguous case we will
            // try one more time just to be sure.
            //
            } else if( iSize - iLen <= sizeof( pszString[0] ) ){

                FreeMem( pszString );

            //
            // LoadString was successful release original string buffer
            // and update new buffer pointer.
            //
            } else {

                vFree( _pszString );
                _pszString = pszString;
                bStatus = TRUE;
                break;
            }

        } else {
            DBGMSG( DBG_ERROR, ( "String.vLoadString: unable to allocate memory, %d\n", GetLastError() ));
            break;
        }
    }
    return bStatus;
}

VOID
TString::
vFree(
    IN LPTSTR pszString
    )
/*++

Routine Description:

    Safe free, frees the string memory.  Ensures
    we do not try an free our global memory block.

Arguments:

    pszString pointer to string meory to free.

Return Value:

    Nothing.

--*/

{
    //
    // If this memory was not pointing to our
    // class specific gszNullStates then release the memory.
    //
    if( pszString != &TString::gszNullState[kValid] &&
        pszString != &TString::gszNullState[kInValid] ){

        FreeMem( pszString );
    }
}


BOOL
TString::
bFormat(
    IN LPCTSTR pszFmt,
    IN ...
    )
{
/*++

Routine Description:

    Format the string opbject similar to sprintf.

Arguments:

    pszFmt pointer format string.
    .. variable number of arguments similar to sprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    invalid and the previous string lost.

--*/

    BOOL bStatus = TRUE;

    va_list pArgs;

    va_start( pArgs, pszFmt );

    bStatus = bvFormat( pszFmt, pArgs );

    va_end( pArgs );

    return bStatus;

}

BOOL
TString::
bvFormat(
    IN LPCTSTR pszFmt,
    IN va_list avlist
    )
/*++

Routine Description:

    Format the string opbject similar to vsprintf.

Arguments:

    pszFmt pointer format string.
    pointer to variable number of arguments similar to vsprintf.

Return Value:

    TRUE if string was format successfully. FALSE if error
    occurred creating the format string, string object will be
    invalid and the previous string lost.

--*/
{
    BOOL bStatus;

    //
    // Save previous string value.
    //
    LPTSTR pszTemp = _pszString;

    //
    // Format the string.
    //
    _pszString = vsntprintf( pszFmt, avlist );

    //
    // If format failed mark object as invalid and
    // set the return value.
    //
    if( !_pszString )
    {
        _pszString = &TString::gszNullState[kInValid];
        bStatus = FALSE;
    }
    else
    {
        bStatus = TRUE;
    }

    //
    // Release near the end because the format string or arguments
    // may be referencing this string object.
    //
    vFree( pszTemp );

    return bStatus;
}

LPTSTR
TString::
vsntprintf(
    IN LPCTSTR      szFmt,
    IN va_list      pArgs
    )
/*++

Routine Description:

    //
    // Formats a string and returns a heap allocated string with the
    // formated data.  This routine can be used to for extremely
    // long format strings.  Note:  If a valid pointer is returned
    // the callng functions must release the data with a call to delete.
    // Example:
    //
    //  LPCTSTR p = vsntprintf("Test %s", pString );
    //
    //  SetTitle( p );
    //
    //  delete [] p;
    //

Arguments:

    pszString pointer format string.
    pointer to a variable number of arguments.

Return Value:

    Pointer to format string.  NULL if error.

--*/

{
    LPTSTR  pszBuff = NULL;
    INT     iSize   = kStrIncrement;

    for( ; ; )
    {
        //
        // Allocate the message buffer.
        //
        pszBuff = (LPTSTR)AllocMem( iSize * sizeof(TCHAR) );

        if( !pszBuff )
        {
            break;
        }

        //
        // Attempt to format the string.  snprintf fails with a
        // negative number when the buffer is too small.
        //
        INT iReturn = _vsntprintf( pszBuff, iSize, szFmt, pArgs );

        //
        // If the return value positive and not equal to the buffer size
        // then the format succeeded.  _vsntprintf will not null terminate
        // the string if the resultant string is exactly the lenght of the
        // provided buffer.
        //
        if( iReturn > 0 && iReturn != iSize )
        {
            break;
        }

        //
        // String did not fit release the current buffer.
        //
        if( pszBuff )
        {
            FreeMem( pszBuff );
        }

        //
        // Double the buffer size after each failure.
        //
        iSize *= 2;

        //
        // If the size is greater than 100k exit without formatting a string.
        //
        if( iSize > kStrMaxFormatSize )
        {
            DBGMSG( DBG_ERROR, ("TString::vsntprintf failed string too long.\n") );
            pszBuff = NULL;
            break;
        }

    }

    return pszBuff;

}

///////////////////////////////////////////////////
// @@file@@ state.cxx
///////////////////////////////////////////////////

/********************************************************************

    Ref counting

********************************************************************/

VOID
MRefQuick::
vIncRef(
    VOID
    )
{
    ++_cRef;
}

LONG
MRefQuick::
cDecRef(
    VOID
    )
{
    --_cRef;

    if( !_cRef ){

        vRefZeroed();
        return 0;
    }
    return _cRef;
}

VOID
MRefQuick::
vDecRefDelete(
    VOID
    )
{
    --_cRef;

    if( !_cRef ){
        vRefZeroed();
    }
}

/********************************************************************

    MRefCom: Reference counting using interlocked references.
    This avoids creating a common critical section.

    vDeleteDecRef is the same as vDecRef, but it logs differently.

********************************************************************/

VOID
MRefCom::
vIncRef(
    VOID
    )
{
    InterlockedIncrement( &_cRef );
}

LONG
MRefCom::
cDecRef(
    VOID
    )
{
    LONG cRefReturn = InterlockedDecrement( &_cRef );

    if( !cRefReturn ){
        vRefZeroed();
    }
    return cRefReturn;
}


VOID
MRefCom::
vDecRefDelete(
    VOID
    )
{
    if( !InterlockedDecrement( &_cRef )){
        vRefZeroed();
    }
}

VOID
MRefCom::
vRefZeroed(
    VOID
    )
{
}

/********************************************************************

    State

********************************************************************/

#if DBG
TState::
TState(
    VOID
    ) : _StateVar(0)
{
}

TState::
TState(
    STATEVAR StateVar
    ) : _StateVar(StateVar)
{
}

TState::
~TState(
    VOID
    )
{
}

STATEVAR
TState::
operator|=(
    STATEVAR StateVarOn
    )
{
    SPLASSERT( bValidateSet( StateVarOn ));

    _StateVar |= StateVarOn;
    return _StateVar;
}

STATEVAR
TState::
operator&=(
    STATEVAR StateVarMask
    )
{
    SPLASSERT( bValidateMask( StateVarMask ));

    _StateVar &= StateVarMask;
    return _StateVar;
}
#endif

///////////////////////////////////////////////////
// @@file@@ splutil.cxx
///////////////////////////////////////////////////

MEntry*
MEntry::
pFindEntry(
    PDLINK pdlink,
    LPCTSTR pszName
    )
{
    PDLINK pdlinkT;
    MEntry* pEntry;

    for( pdlinkT = pdlink->FLink;
         pdlinkT != pdlink;
         pdlinkT = pdlinkT->FLink ){

        pEntry = MEntry::Entry_pConvert( pdlinkT );
        if( pEntry->_strName == pszName ){

            return pEntry;
        }
    }
    return NULL;
}

///////////////////////////////////////////////////
// @@file@@ threadm.cxx
///////////////////////////////////////////////////

/********************************************************************

    Public interfaces.

********************************************************************/

TThreadM::
TThreadM(
    UINT uMaxThreads,
    UINT uIdleLife,
    CCSLock* pCritSec OPTIONAL
    ) :

    _uMaxThreads(uMaxThreads), _uIdleLife(uIdleLife), _uActiveThreads(0),
    _uRunNowThreads(0), _iIdleThreads(0), 

    _lLocks(1) // the one who calls 'new TThreadM' acquires the initial lock

/*++

Routine Description:

    Construct a Thread Manager object.

Arguments:

    uMaxThreads - Upper limit of threads that will be created.

    uIdleLife - Maximum life once a thread goes idle (in ms).

    pCritSec - Use this crit sec for synchronization (if not specified,
        a private one will be created).

Return Value:

Notes:

    _hTrigger is our validity variable.  When this value is NULL,
    instantiation failed.  If it's non-NULL, the entire object is valid.

--*/

{
    _hTrigger = CreateEvent( NULL,
                             FALSE,
                             FALSE,
                             NULL );

    if( !_hTrigger ){
        return;
    }

    //
    // If no critical section, create our own.
    //
    if (!pCritSec) {

        _pCritSec = new CCSLock();

        if( !_pCritSec ){

            //
            // _hTrigger is our valid variable.  If we fail to create
            // the critical section, prepare to return failure.
            //
            CloseHandle( _hTrigger );
            _hTrigger = NULL;

            return;
        }
        _State |= kPrivateCritSec;

    } else {
        _pCritSec = pCritSec;
    }
}

VOID
TThreadM::
vDelete(
    VOID
    )

/*++

Routine Description:

    Indicates that the object is pending deletion.  Any object that
    inherits from vDelete should _not_ call the destructor directly,
    since there may be pending jobs.  Instead, they should call
    TThreadM::vDelete().

Arguments:

Return Value:

--*/

{
    CCSLock::Locker CSL( *_pCritSec );

    //
    // Mark as wanting to be destroyed.
    //
    _State |= kDestroyReq;
}

BOOL
TThreadM::
bJobAdded(
    BOOL bRunNow
    )

/*++

Routine Description:

    Notify the thread manager that a new job has been added.  This job
    will be processed fifo.

Arguments:

    bRunNow - Ignore the thread limits and run the job now.

Return Value:

    TRUE - Job successfully added.
    FALSE - Job could not be added.

--*/

{
    DWORD dwThreadId;
    HANDLE hThread;
    BOOL rc = TRUE;

    CCSLock::Locker CSL( *_pCritSec );

    if( _State.bBit( kDestroyReq )){

        DBGMSG( DBG_THREADM | DBG_ERROR,
                ( "ThreadM.bJobAdded: add failed since DESTROY requested.\n" ));

        SetLastError( ERROR_INVALID_PARAMETER );
        rc = FALSE;

    } else {

        //
        // We either: give it to an idle thread, create a new thread,
        // or leave it in the queue.
        //
        if( _iIdleThreads > 0 ){

            //
            // There are some idle threads--trigger the event and it
            // will be picked up.
            //
            --_iIdleThreads;

            DBGMSG( DBG_THREADM,
                    ( "ThreadM.bJobAdded: Trigger: --iIdle %d, uActive %d\n",
                      _iIdleThreads, _uActiveThreads ));

            //
            // If we set the event, then the worker thread that receives
            // this event should _not_ decrement _iIdleThreads, since
            // we already did this.
            //
            SetEvent( _hTrigger );

        } else if( _uActiveThreads < _uMaxThreads || bRunNow ){

            //
            // No idle threads, but we can create a new one since we
            // haven't reached the limit, or the bRunNow flag is set.
            //

            Lock();

            hThread = TSafeThread::Create( NULL,
                                           0,
                                           xdwThreadProc,
                                           this,
                                           0,
                                           &dwThreadId );
            if( hThread ){

                CloseHandle( hThread );

                //
                // We have successfully created a thread; up the
                // count.
                //
                ++_uActiveThreads;

                //
                // We have less active threads than the max; create a new one.
                //
                DBGMSG( DBG_THREADM,
                        ( "ThreadM.bJobAdded: ct: iIdle %d, ++uActive %d\n",
                          _iIdleThreads,
                          _uActiveThreads ));

            } else {

                Unlock();

                rc = FALSE;

                DBGMSG( DBG_THREADM | DBG_WARN,
                        ( "ThreadM.bJobAdded: unable to ct %d\n",
                          GetLastError( )));
            }
        } else {

            //
            // No idle threads, and we are already at the max so we
            // can't create new threads.  Dec iIdleThreads anyway
            // (may go negative, but that's ok).
            //
            // iIdleThreads represents the number of threads that
            // are currently not processing jobs.  If the number is
            // negative, this indicates that even if a thread suddenly
            // completes a job and would go idle, there is a queued
            // job that would immediately grab it, so the thread really
            // didn't go into an idle state.
            //
            // The negative number indicates the number of outstanding
            // jobs that are queued (e.g., -5 indicate 5 jobs queued).
            //
            // There is always an increment of iIdleThreads when a
            // job is compeleted.
            //
            --_iIdleThreads;

            //
            // No threads idle, and at max threads.
            //
            DBGMSG( DBG_THREADM,
                    ( "ThreadM.bJobAdded: wait: --iIdle %d, uActive %d\n",
                      _iIdleThreads,
                      _uActiveThreads ));
        }

        //
        // If we succeeded and bRunNow is set, this indicates that
        // we were able to start a special thread, so we need to adjust
        // the maximum number of threads.  When a this special thread
        // job completes, we will decrement it.
        //
        if( bRunNow && rc ){

            ++_uMaxThreads;
            ++_uRunNowThreads;
        }
    }
    return rc;
}

/********************************************************************

    Private routines.

********************************************************************/

TThreadM::
~TThreadM(
    VOID
    )

/*++

Routine Description:

    Destroy the thread manager object.  This is private; to request
    that the thread manager quit, call vDelete().

Arguments:

Return Value:

--*/

{
    SPLASSERT( _State.bBit( kDestroyReq ));

    if( _State.bBit( kPrivateCritSec )){
        SPLASSERT( _pCritSec->bOutside( ));
        delete _pCritSec;
    }

    if( _hTrigger )
        CloseHandle( _hTrigger );
}

DWORD
TThreadM::
xdwThreadProc(
    LPVOID pVoid
    )

/*++

Routine Description:

    Worker thread routine that calls the client to process the jobs.

Arguments:

    pVoid - pTMStateVar

Return Value:

    Ignored.

--*/

{
    TThreadM* pThreadM = (TThreadM*)pVoid;
    DWORD dwExitCode = pThreadM->dwThreadProc();
    pThreadM->Unlock(); // release
    return dwExitCode;
}

DWORD
TThreadM::
dwThreadProc(
    VOID
    )
{
    CCSLock::Locker CSL( *_pCritSec );

    DBGMSG( DBG_THREADM,
            ( "ThreadM.dwThreadProc: ct: iIdle %d, uActive %d\n",
              _iIdleThreads,
              _uActiveThreads));

    PJOB pJob = pThreadMJobNext();

    while( TRUE ){

        for( ; pJob; pJob=pThreadMJobNext( )){

            //
            // If bRunNow count is non-zero, this indicates that we just
            // picked up a RunNow job.  As soon as it completes, we
            // can decrement the count.
            //
            BOOL bRunNowCompleted = _uRunNowThreads > 0;

            {
                _pCritSec->Unlock();

                //
                // Call back to client to process the job.
                //
                DBGMSG( DBG_THREADM,
                        ( "ThreadM.dwThreadProc: %x processing\n",
                          (ULONG_PTR)pJob ));

                //
                // Call through virtual function to process the
                // user's job.
                //
                vThreadMJobProcess( pJob );

                DBGMSG( DBG_THREADM,
                        ( "ThreadM.dwThreadProc: %x processing done\n",
                          (ULONG_PTR)pJob ));

                // aquire the CS again
                _pCritSec->Lock();
            }


            //
            // If a RunNow job has been completed, then decrement both
            // counts.  uMaxThreads was increased by one when the job was
            // accepted, so now it must be lowered.
            //
            if( bRunNowCompleted ){

                --_uMaxThreads;
                --_uRunNowThreads;
            }

            ++_iIdleThreads;

            DBGMSG( DBG_THREADM,
                    ( "ThreadM.dwThreadProc: ++iIdle %d, uActive %d\n",
                       _iIdleThreads,
                       _uActiveThreads ));
        }

        DBGMSG( DBG_THREADM,
                ( "ThreadM.dwThreadProc: Sleep: iIdle %d, uActive %d\n",
                                _iIdleThreads,
                                _uActiveThreads ));

        {
            _pCritSec->Unlock();

            //
            // Done, now relax and go idle for a bit.  We don't
            // care whether we timeout or get triggered; in either
            // case we check for another job.
            //
            WaitForSingleObject( _hTrigger, _uIdleLife );

            // aquire the CS again
            _pCritSec->Lock();
        }


        //
        // We must check here instead of relying on the return value
        // of WaitForSingleObject since someone may see iIdleThreads!=0
        // and set the trigger, but we timeout before it gets set.
        //
        pJob = pThreadMJobNext();

        if( pJob ){

            DBGMSG( DBG_THREADM,
                    ( "ThreadM.dwThreadProc: Woke and found job: iIdle %d, uActive %d\n",
                      _iIdleThreads,
                      _uActiveThreads ));
        } else {

            //
            // No jobs found; break.  Be sure to reset the hTrigger, since
            // there are no waiting jobs, and the main thread might
            // have set it in the following case:
            //
            // MainThread:           WorkerThread:
            //                       Sleeping
            //                       Awoke, not yet in CS.
            // GotJob
            // SetEvent
            // --iIdleThreads
            //                       Enter CS, found job, process it.
            //
            // In this case, the event is set, but there is no thread
            // to pick it up.
            //
            ResetEvent( _hTrigger );
            break;
        }
    }

    //
    // Decrement ActiveThreads.  This was incremented when the thread
    // was successfully created, and should be decremented when the thread
    // is about to exit.
    //
    --_uActiveThreads;

    //
    // The thread enters an idle state right before it goes to sleep.
    //
    // When a job is added, the idle count is decremented by the main
    // thread, so the worker thread doesn't decrement it (avoids sync
    // problems).  If the worker thread timed out and there were no jobs,
    // then we need to decrement the matching initial increment here.
    //
    --_iIdleThreads;

    DBGMSG( DBG_THREADM,
            ( "ThreadM.dwThreadProc: dt: --iIdle %d, --uActive %d\n",
              _iIdleThreads,
              _uActiveThreads));

    return 0;
}

///////////////////////////////////////////////////
// @@file@@ exec.cxx
///////////////////////////////////////////////////

/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    exec.cxx

Abstract:

    Handles async commands.

    The client give TExec a worker object (MExecWork).  At some later
    time, the worker is given a thread (called via svExecute).

    If the Job is already on the list but is waiting, we just return.
    If it's not on the list but currently executing, we add it to the
    list when it's done executing.

    kExecActive    -> currently executing (so it's not on the list)
    kExecActiveReq -> kExecActive is on, and it needs to run again.

    If kExecExit is added, we call vExecExitComplete() (virtual function)
    when all jobs have been completed and assume the the client is cleaning
    up after itself.  In fact, the MExecWork object may be destroyed
    in vExecExitComplete().

Author:

    Albert Ting (AlbertT)  8-Nov-1994

Revision History:

--*/

BOOL
TExec::
bJobAdd(
    MExecWork* pExecWork,
    STATEVAR StateVar
    )

/*++

Routine Description:

    Adds a job request to move to a given state.

Arguments:

    pExecWork - Work structure.

    StateVar - StateVar that we want to move toward.  If kExecExit
        is set, then we will complete the currently executing job
        then exit by calling vExecExitComplete().

        Note that kExecExit should be added by itself; if it is added
        with other commands, they will be ignored.

Return Value:

    TRUE  = Job added (or job already on wait list)
    FALSE = failed, GLE.

    Adding kExecExit is guarenteed to succeed here.

--*/

{
    BOOL bReturn = TRUE;
    BOOL bCallExecExitComplete = FALSE;

    {
        CCSLock::Locker CSL( *_pCritSec );

        DBGMSG( DBG_EXEC,
                ( "Exec.bJobAdd: %x StateVar = %x\n", pExecWork, StateVar ));

        //
        // Job bits must not have PRIVATE bits.
        //
        SPLASSERT( !( StateVar & kExecPrivate ));

        //
        // Don't allow adding a job after we are set to exit.
        //
        SPLASSERT( !( pExecWork->_State & kExecExit ));

        //
        // If it's active (currently executing in a thread), then it is
        // not on the wait list and we mark it as ACTIVE_REQ so that
        // when the job completes, it sees that more jobs have accumulated.
        //
        if( pExecWork->_State & kExecActive ){

            DBGMSG( DBG_EXEC,
                    ( "\n    ACTIVE, ++REQ _State %x _StatePending %x\n",
                      (STATEVAR)pExecWork->_State,
                      (STATEVAR)pExecWork->_StatePending ));

            //
            // Can't be an immediate request if executing already.
            //
            SPLASSERT( !( StateVar & kExecRunNow ));

            pExecWork->_StatePending |= StateVar;
            pExecWork->_State |= kExecActiveReq;

            bReturn = TRUE;

        } else {

            //
            // Store up the work requested since we aren't currently active.
            //
            pExecWork->_State |= StateVar;

            //
            // If we are not on the wait list, add it.
            //
            if( !pExecWork->Work_bLinked( )){

                if( StateVar & kExecExit ){

                    bCallExecExitComplete = TRUE;

                } else {

                    DBGMSG( DBG_EXEC, ( "not linked, added\n" ));
                    SPLASSERT( NULL == Work_pFind( pExecWork ));

                    bReturn = bJobAddWorker( pExecWork );
                }

            } else {

                DBGMSG( DBG_EXEC, ( "linked, NOP\n" ));
            }
        }
    }

    if( bCallExecExitComplete ){

        //
        // Special case exit: we should exit.  Once we call
        // vExecExitComplete, we can't refer to *this anymore,
        // since we may have deleted ourself.
        //
        pExecWork->vExecExitComplete();
        bReturn = TRUE;

    }

    return bReturn;
}


VOID
TExec::
vJobDone(
    MExecWork* pExecWork,
    STATEVAR StateVar
    )

/*++

Routine Description:

    A job has compeleted execution, clean up.

Arguments:

    pExecWork - Unit that just completed executing.

    StateVar - New state that the object is in (requests that
        successfully completed should be turned off--done by client).

Return Value:

--*/

{
    BOOL bCallExecExitComplete = FALSE;
    BOOL bCallExecFailedAddJob = FALSE;

    {
        CCSLock::Locker CSL( *_pCritSec );

        DBGMSG( DBG_EXEC,
                ( "Exec.vJobDone: %x completed -> %x +(new) %x = %x\n",
                  pExecWork, StateVar, (DWORD)pExecWork->_StatePending,
                  (DWORD)pExecWork->_State | pExecWork->_StatePending ));

        //
        // kExecRunNow can not be set when the object is working.
        //
        SPLASSERT( !( StateVar & kExecRunNow ));

        //
        // We have completed the work request, put in the new state.
        // Keep the private bits, and add in the new state variable,
        // plus any additional work that was pending.
        //
        // The ExecNow bit is not saved (it's not part of kExecPrivate)
        // since it's good for one shot only.
        //
        pExecWork->_State = ( pExecWork->_State & kExecPrivate ) |
                            ( StateVar & ~kExecPrivate ) |
                            pExecWork->_StatePending;

        pExecWork->_State &= ~kExecActive;

        //
        // If job is done, then quit.
        //
        if( pExecWork->_State & kExecExit ){

            DBGMSG( DBG_EXEC,
                    ( "Exec.vJobDone: _State %x, calling vExecExitComplete\n",
                      (STATEVAR)pExecWork->_State ));

            bCallExecExitComplete = TRUE;

        } else {

            //
            // If we have more work to do, add ourselves back
            // to the queue.
            //
            if( pExecWork->_State & kExecActiveReq &&
                !bJobAddWorker( pExecWork )){

                bCallExecFailedAddJob = TRUE;
            }
        }
    }

    if( bCallExecFailedAddJob ){

        //
        // Fail on delayed job add.
        //
        pExecWork->vExecFailedAddJob();
    }

    if( bCallExecExitComplete ){

        //
        // Once vExecExitComplete has been called, the current object
        // pExecWork may be destroyed.
        //
        // Don't refer to it again since vExecExitComplete may delete
        // this as part of cleanup.
        //
        pExecWork->vExecExitComplete();
    }
}


STATEVAR
TExec::
svClearPendingWork(
    MExecWork* pExecWork
    )

/*++

Routine Description:

    Queries what work is currently pending.

Arguments:

    pExecWork -- Work item.

Return Value:

--*/

{
    CCSLock::Locker CSL( *_pCritSec );

    //
    // Return pending work, minus the private and kExecRunNow
    // bits.
    //
    STATEVAR svPendingWork = pExecWork->_StatePending & ~kExecNoOutput;
    pExecWork->_StatePending = 0;

    return svPendingWork;
}

/********************************************************************

    Private

********************************************************************/

TExec::
TExec(
    CCSLock* pCritSec
    ) : TThreadM( 10, 2000, pCritSec ), _pCritSec( pCritSec )
{
}

BOOL
TExec::
bJobAddWorker(
    MExecWork* pExecWork
    )

/*++

Routine Description:

    Common code to add a job to our linked list.

    Must be called inside the _pCritSec.  It does leave it inside
    this function, however.

Arguments:


Return Value:

--*/

{
    SPLASSERT( _pCritSec->bInside( ));

    BOOL bRunNow = FALSE;

    //
    // Check if the client wants the job to run right now.
    //
    if( pExecWork->_State & kExecRunNow ){

        //
        // Add the job to the head of the queue.  Since we always pull
        // jobs from the beginning, we'll get to this job first.
        //
        // If a non-RunNow job is added to the list before we execute,
        // we'll still run, since the other job will be added to the
        // end of the list.
        //
        // If another RunNow job is added, we'll spawn separate threads
        // for each (unless an idle thread is available).
        //

        Work_vAdd( pExecWork );
        bRunNow = TRUE;

    } else {
        Work_vAppend( pExecWork );
    }

    if( !bJobAdded( bRunNow ) ){

        DBGMSG( DBG_INFO, ( "Exec.vJobProcess: unable to add job %x: %d\n",
                            pExecWork,
                            GetLastError( )));

        Work_vDelink( pExecWork );
        return FALSE;
    }

    return TRUE;
}

PJOB
TExec::
pThreadMJobNext(
    VOID
    )

/*++

Routine Description:

    Gets the next job from the queue.  This function is defined in
    TThreadM.

Arguments:

Return Value:

--*/

{
    CCSLock::Locker CSL( *_pCritSec );

    MExecWork* pExecWork = Work_pHead();

    if( !pExecWork ){
        return NULL;
    }

    Work_vDelink( pExecWork );

    //
    // Job should never be active here.
    //
    SPLASSERT( !(pExecWork->_State & kExecActive) );

    //
    // We will handle all requests now, so clear kExecActiveReq.
    // Also remove kExecRunNow, since it's one shot only, and mark us
    // as currently active (kExecActive).
    //
    pExecWork->_State &= ~( kExecActiveReq | kExecRunNow );
    pExecWork->_State |= kExecActive;

    return (PJOB)pExecWork;
}

VOID
TExec::
vThreadMJobProcess(
    PJOB pJob
    )

/*++

Routine Description:

    Process a job in the current thread.  We call the virtual function
    with the job object, then clear out the bits that it has completed.
    (This is a member of TThreadM.)

    If there is additional pending work (ACTIVE_REQ), then we re-add
    the job.

    If there is a failure in the re-add case, we must send an
    asynchronous fail message.

Arguments:

    pJob - MExecWork instance.

Return Value:

--*/

{
    SPLASSERT( _pCritSec->bOutside( ));

    STATEVAR StateVar;
    MExecWork* pExecWork = (MExecWork*)pJob;

    //
    // Do the work.
    //
    StateVar = pExecWork->svExecute( pExecWork->State() & ~kExecNoOutput );

    vJobDone( pExecWork, StateVar );
}

///////////////////////////////////////////////////
// @@file@@ bitarray.cxx
///////////////////////////////////////////////////

/********************************************************************

    Bit Array class

********************************************************************/

TBitArray::
TBitArray(
    IN UINT nBits,
    IN UINT uGrowSize
    ) : _nBits( nBits ),
        _pBits( NULL ),
        _uGrowSize( uGrowSize )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::ctor\n" ) );

    //
    // If the initial number of bits is not specified then
    // create a default bit array size.
    //
    if( !_nBits )
    {
        _nBits = kBitsInType;
    }

    //
    // This could fail, thus leaving the bit array
    // in an invalid state, Note _pBits being true is
    // the bValid check.
    //
    _pBits = new Type [ nBitsToType( _nBits ) ];

    if( _pBits )
    {
        //
        // The grow size should be at least the
        // number of bits in the type.
        //
        if( _uGrowSize < kBitsInType )
        {
            _uGrowSize = kBitsInType;
        }

        //
        // Clear all the bits.
        //
        memset( _pBits, 0, nBitsToType( _nBits ) * sizeof( Type ) );
    }
}

TBitArray::
TBitArray(
    const TBitArray &rhs
    ) : _nBits( kBitsInType ),
        _pBits( NULL )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::copy_ctor\n" ) );
    bClone( rhs );
}

const TBitArray &
TBitArray::
operator =(
    const TBitArray &rhs
    )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::operator =\n" ) );
    bClone( rhs );
    return *this;
}

TBitArray::
~TBitArray(
    VOID
    )
    {
    DBGMSG( DBG_TRACE, ( "TBitArray::dtor\n" ) );
    delete [] _pBits;
}

BOOL
TBitArray::
bValid(
    VOID
    ) const
{
    return _pBits != NULL;
}

BOOL
TBitArray::
bToString(
    IN TString &strBits
    ) const
{
    BOOL bStatus = bValid();

    if( bStatus )
    {
        TString strString;

        strBits.bUpdate( NULL );

        //
        // Get the upper bound bit.
        //
        UINT uIndex = _nBits - 1;

        //
        // Print the array in reverse order to make the bit array
        // appear as one large binary number.
        //
        for( UINT i = 0; i < _nBits; i++, uIndex-- )
        {
            strString.bFormat( TEXT( "%d" ), bRead( uIndex ) );
            strBits.bCat( strString );
        }

        bStatus = strBits.bValid();
    }

    return bStatus;
}

BOOL
TBitArray::
bRead(
    IN UINT Bit
    ) const
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        bStatus = _pBits[BitToIndex( Bit )] & BitToMask( Bit ) ? TRUE : FALSE;
    }

    return bStatus;
}

BOOL
TBitArray::
bSet(
    IN UINT Bit
    )
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        _pBits[BitToIndex( Bit )] |= BitToMask( Bit );
    }

    return bStatus;
}

BOOL
TBitArray::
bReset(
    IN UINT Bit
    )
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        _pBits[BitToIndex( Bit )] &= ~BitToMask( Bit );
    }

    return bStatus;
}

BOOL
TBitArray::
bToggle(
    IN UINT Bit
    )
{
    BOOL bStatus = bIsValidBit( Bit );

    if( bStatus )
    {
        _pBits[BitToIndex( Bit )] ^= BitToMask( Bit );
    }

    return bStatus;
}

//
// Add one new bit to the end of the bit array.
// If multiple bits need to be added the user of the
// class should call this routine repeatedly.
//
BOOL
TBitArray::
bAdd(
    VOID
    )
{
    BOOL bStatus = FALSE;
    UINT Bit = _nBits + 1;

    //
    // Check if there is room in the array for one more bit.
    //
    if( Bit <= nBitsToType( _nBits ) * kBitsInType )
    {
        //
        // Update the current bit count and return true.
        //
        _nBits  = Bit;
        bStatus = TRUE;
    }
    else
    {
        //
        // Grow the bit array.
        //
        bStatus = bGrow( Bit );
    }

    return bStatus;
}

VOID
TBitArray::
vSetAll(
    VOID
    )
{
    for( UINT i = 0; i < _nBits; i++ )
    {
        bSet( i );
    }
}

VOID
TBitArray::
vResetAll(
    VOID
    )
{
    for( UINT i = 0; i < _nBits; i++ )
    {
        bReset( i );
    }
}

UINT
TBitArray::
uNumBits(
    VOID
    ) const
{
    return _nBits;
}


BOOL
TBitArray::
bFindNextResetBit(
    IN UINT *puNextFreeBit
    )
{
    BOOL bStatus = bValid();

    if( bStatus )
    {
        BOOL bFound = FALSE;

        //
        // Locate the first type that contains at least one cleared bit.
        //
        for( UINT i = 0; i < nBitsToType( _nBits ); i++ )
        {
            if( _pBits[i] != kBitsInTypeMask )
            {
                //
                // Search for the bit that is cleared.
                //
                for( UINT j = 0; j < kBitsInType; j++ )
                {
                    if( !( _pBits[i] & BitToMask( j ) ) )
                    {
                        *puNextFreeBit = i * kBitsInType + j;
                        bFound = TRUE;
                        break;
                    }
                }
            }

            //
            // Free bit found terminate the search.
            //
            if( bFound )
            {
                break;
            }
        }

        //
        // Free bit was not found then grow the bit array
        //
        if( !bFound )
        {
            //
            // Assume a new bit will be added.
            //
            *puNextFreeBit = uNumBits();

            //
            // Add a new bit.
            //
            bStatus = bAdd();
        }
    }
    return bStatus;
}


/********************************************************************

    Bit Array - private member functions.

********************************************************************/

BOOL
TBitArray::
bClone(
    const TBitArray &rhs
    )
{
    BOOL bStatus = FALSE;

    if( this == &rhs )
    {
        bStatus = TRUE;
    }
    else
    {
        Type *pTempBits = new Type [ nBitsToType( _nBits ) ];

        if( pTempBits )
        {
            memcpy( pTempBits, rhs._pBits, nBitsToType( _nBits ) * sizeof( Type ) );
            delete [] _pBits;
            _pBits = pTempBits;
            _nBits = rhs._nBits;
            bStatus = TRUE;
        }
    }
    return bStatus;
}

BOOL
TBitArray::
bGrow(
    IN UINT uBits
    )
{
    DBGMSG( DBG_TRACE, ( "TBitArray::bGrow\n" ) );

    BOOL bStatus    = FALSE;
    UINT uNewBits   = uBits + _uGrowSize;

    DBGMSG( DBG_TRACE, ( "Grow to size %d Original size %d Buffer pointer %x\n", uNewBits, _nBits, _pBits ) );

    //
    // We do support reducing the size of the bit array.
    //
    SPLASSERT( uNewBits > _nBits );

    //
    // Allocate the enlarged bit array.
    //
    Type *pNewBits  = new Type [ nBitsToType( uNewBits ) ];

    if( pNewBits )
    {
        //
        // Clear the new bits.
        //
        memset( pNewBits, 0, nBitsToType( uNewBits ) * sizeof( Type ) );

        //
        // Copy the old bits to the new bit array.
        //
        memcpy( pNewBits, _pBits, nBitsToType( _nBits ) * sizeof( Type ) );

        //
        // Release the old bit array and save the new pointer and size.
        //
        delete [] _pBits;
        _pBits  = pNewBits;
        _nBits  = uBits;

        //
        // Success.
        //
        bStatus = TRUE;
    }

    DBGMSG( DBG_TRACE, ( "New size %d Buffer pointer %x\n", _nBits, _pBits ) );

    return bStatus;
}

UINT
TBitArray::
nBitsToType(
    IN UINT uBits
    ) const
{
    return ( uBits + kBitsInType - 1 ) / kBitsInType;
}

TBitArray::Type
TBitArray::
BitToMask(
    IN UINT uBit
    ) const
{
    return 1 << ( uBit % kBitsInType );
}

UINT
TBitArray::
BitToIndex(
    IN UINT uBit
    ) const
{
    return uBit / kBitsInType;
}

BOOL
TBitArray::
bIsValidBit(
    IN UINT uBit
    ) const
{
    BOOL bStatus = ( uBit < _nBits ) && bValid();

    if( !bStatus )
    {
        DBGMSG( DBG_TRACE, ( "Invalid bit value %d\n", uBit ) );
    }

    return bStatus;
}

///////////////////////////////////////////////////
// @@file@@ loadlib.cxx
///////////////////////////////////////////////////

TLibrary::
TLibrary(
    LPCTSTR pszLibName
    ) 
{
    _hInst = LoadLibrary( pszLibName );

    if( !_hInst )
    {
        DBGMSG( DBG_WARN, ( "Library.ctr: unable to load "TSTR"\n", pszLibName ));
    }
}

TLibrary::
~TLibrary(
    )
{
    if( bValid() )
    {
        FreeLibrary( _hInst );
    }
}

BOOL
TLibrary::
bValid(
    VOID
    ) const
{
    return _hInst != NULL;
}

FARPROC
TLibrary::
pfnGetProc(
    IN LPCSTR pszProc
    ) const
{
    FARPROC fpProc = bValid() ? GetProcAddress( _hInst, pszProc ) : NULL;

    if( !fpProc )
    {
        DBGMSG( DBG_WARN, ( "Library.pfnGetProc: failed %s\n", pszProc ));
    }
    return fpProc;
}

FARPROC
TLibrary::
pfnGetProc(
    IN UINT uOrdinal
    ) const
{
    FARPROC fpProc = bValid() ? GetProcAddress( _hInst, (LPCSTR)MAKELPARAM( uOrdinal, 0 ) ) : NULL;

    if( !fpProc )
    {
        DBGMSG( DBG_WARN, ( "Library.pfnGetProc: failed %d\n", uOrdinal ));
    }
    return fpProc;
}

HINSTANCE
TLibrary::
hInst(
    VOID
    ) const
{
    return _hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\spllibex.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    spllibex.cxx

Abstract:

    spllib extentions

Author:

    Lazar Ivanov (LazarI)  29-Mar-2000

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "spllibex.hxx"

////////////////////////////////////////////////
//
// class CMsgBoxCounter
//
// this class counts the popups which have come up 
// during it's lifetime.
//

static DWORD g_dwTlsMsgsCounterCookie = -1;

CMsgBoxCounter::CMsgBoxCounter(UINT uFlags)
    : m_uCount(0),
      m_uFlags(uFlags),
      m_uMsgID(0)
{
    if( IsInitialized() )
    {
        // Only one instance of CMsgBoxCounter at a time can use 
        // the TLS cookie
        ASSERT(NULL == TlsGetValue(g_dwTlsMsgsCounterCookie));
        TlsSetValue(g_dwTlsMsgsCounterCookie, reinterpret_cast<LPVOID>(this));
    }
}

CMsgBoxCounter::~CMsgBoxCounter()
{
    if( IsInitialized() )
    {
        ASSERT(this == TlsGetValue(g_dwTlsMsgsCounterCookie));
        TlsSetValue(g_dwTlsMsgsCounterCookie, NULL);
    }
}

BOOL CMsgBoxCounter::Initialize()
{
    // allocate TLS cookies
    if( !IsInitialized() )
    {
        g_dwTlsMsgsCounterCookie = TlsAlloc();
    }
    return IsInitialized();
}

BOOL CMsgBoxCounter::Uninitialize()
{
    // free up the TLS cookies
    if( -1 != g_dwTlsMsgsCounterCookie )
    {
        VERIFY(TlsFree(g_dwTlsMsgsCounterCookie));
        g_dwTlsMsgsCounterCookie = -1;
    }
    return TRUE;
}

UINT CMsgBoxCounter::GetCount() 
{
    UINT uReturn = INVALID_COUNT;
    if( IsInitialized() )
    {
        // lookup the value in the TLS 
        CMsgBoxCounter *pThis = reinterpret_cast<CMsgBoxCounter*>(TlsGetValue(g_dwTlsMsgsCounterCookie));
        uReturn = pThis->m_uCount;
    }
    return uReturn;
}

BOOL CMsgBoxCounter::IsInitialized() 
{
    // the TLS cookie should be valid to assume success
    return (-1 != g_dwTlsMsgsCounterCookie);
}

void CMsgBoxCounter::LogMessage(UINT uFlags)
{
    if( IsInitialized() )
    {
        CMsgBoxCounter *pThis = reinterpret_cast<CMsgBoxCounter*>(TlsGetValue(g_dwTlsMsgsCounterCookie));

        if( pThis && (pThis->m_uFlags & uFlags) )
        {
            // increment the message box counter
            pThis->m_uCount++;
        }
    }
}

void CMsgBoxCounter::SetMsg(UINT uMsgID)
{
    if( IsInitialized() )
    {
        CMsgBoxCounter *pThis = reinterpret_cast<CMsgBoxCounter*>(TlsGetValue(g_dwTlsMsgsCounterCookie));

        if( pThis )
        {
            pThis->m_uMsgID = uMsgID;
        }
    }
}

UINT CMsgBoxCounter::GetMsg()
{
    UINT uMsgID = 0;

    if( IsInitialized() )
    {
        CMsgBoxCounter *pThis = reinterpret_cast<CMsgBoxCounter*>(TlsGetValue(g_dwTlsMsgsCounterCookie));

        if( pThis )
        {
            uMsgID = pThis->m_uMsgID;
        }
    }

    return uMsgID;
}

////////////////////////////////////////////////
//
// class CPrintNotify
//
// printer notifications listener
//

CPrintNotify::CPrintNotify(
    IPrinterChangeCallback *pClient, 
    DWORD dwCount,
    const PPRINTER_NOTIFY_OPTIONS_TYPE arrNotifications,
    DWORD dwFlags
    ): 
    m_bRegistered(FALSE),
    m_uCookie(0),
    m_dwCount(dwCount),
    m_arrNotifications(arrNotifications),
    m_dwFlags(dwFlags)
{
    SINGLETHREADRESET(TrayUIThread)

    ASSERT(pClient);
    m_spClient.CopyFrom(pClient);
}

CPrintNotify::~CPrintNotify()
{
    SINGLETHREAD(TrayUIThread)

    // make sure we uninitialize here
    Uninitialize();
}

HRESULT CPrintNotify::Initialize(LPCTSTR pszPrinter)
{
    SINGLETHREAD(TrayUIThread)

    ASSERT(!m_shPrinter);
    ASSERT(!m_shNotify);
    ASSERT(pszPrinter);

    HRESULT hr = E_FAIL;

    SetLastError(0);
    if( NULL == m_pPrintLib.pGet() )
    {
        // aquire a reference to the printui lib object. this will be used
        // to register/unregister notification handles in the folder cache.
        TPrintLib::bGetSingleton(m_pPrintLib);
    }

    if( m_pPrintLib.pGet() )
    {
        m_strPrinter.bUpdate(pszPrinter);

        DWORD dwAccess = 0; // whatever
        DWORD dwErr = TPrinter::sOpenPrinter(m_strPrinter, &dwAccess, &m_shPrinter);
        hr = HRESULT_FROM_WIN32(dwErr);

        if( SUCCEEDED(hr) )
        {
            ASSERT(m_dwFlags);
            PRINTER_NOTIFY_OPTIONS opt = {2, 0, m_dwCount, m_arrNotifications};
            m_shNotify = FindFirstPrinterChangeNotification(m_shPrinter, m_dwFlags, 0, &opt);

            // setup the HRESULT here
            hr = m_shNotify ? S_OK : CreateHRFromWin32();
        }
    }
    else
    {
        // build an appropriate HRESULT
        hr = CreateHRFromWin32();
    }

    if( FAILED(hr) )
    {
        // if something has failed we don't want to 
        // keep the handles around in this case
        m_shNotify = NULL;
        m_shPrinter = NULL;
        m_strPrinter.bUpdate(NULL);
    }

    return hr;
}

HRESULT CPrintNotify::Uninitialize()
{
    SINGLETHREAD(TrayUIThread)

    // make sure we don't listen anymore
    HRESULT hr = StopListen();

    // clear the handles
    m_shNotify = NULL;
    m_shPrinter = NULL;
    m_strPrinter.bUpdate(NULL);

    return hr;
}

// this is just wrappers around _NotifyRegister
HRESULT CPrintNotify::StartListen()
{
    SINGLETHREAD(TrayUIThread)

    ASSERT(m_shNotify);
    ASSERT(m_spClient);

    // register ourselves in the wait list
    return _NotifyRegister(TRUE);
}

HRESULT CPrintNotify::Refresh(LPVOID lpCookie, PFN_PrinterChange pfn)
{
    SINGLETHREAD(TrayUIThread)

    ASSERT(m_shNotify);
    ASSERT(m_spClient);
    ASSERT(m_dwFlags);

    HRESULT hr = S_OK;
    DWORD dwChange = 0;
    CAutoPtrPrinterNotify pInfo;

    PRINTER_NOTIFY_OPTIONS opt = {2, PRINTER_NOTIFY_OPTIONS_REFRESH, m_dwCount, m_arrNotifications };
    if( FindNextPrinterChangeNotification(m_shNotify, &dwChange, &opt, pInfo.GetPPV()) )
    {
        // we hope the client callback will process this call quickly as there shouldn't 
        // be any delays here if we don't want to loose notifications.
        // we don't really care what the retirn value is here.
        if( pfn )
        {
            pfn(lpCookie, m_uCookie, dwChange, pInfo);
        }
        else
        {
            m_spClient->PrinterChange(m_uCookie, dwChange, pInfo);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

// this is just wrappers around _NotifyRegister
HRESULT CPrintNotify::StopListen()
{
    SINGLETHREAD(TrayUIThread)

    // unregister ourselves from the wait list
    return _NotifyRegister(FALSE);
}

HRESULT CPrintNotify::SetCookie(ULONG_PTR uCookie)
{
    SINGLETHREAD(TrayUIThread)

    m_uCookie = uCookie;
    return S_OK;
}

LPCTSTR CPrintNotify::GetPrinter() const
{
    // !!MT NOTES!!
    // this function can be invoked only from the bkgnd threads,
    // but it never touches the object state.

    return (0 == m_strPrinter.uLen() ? NULL : m_strPrinter);
}

HANDLE CPrintNotify::GetPrinterHandle() const
{
    SINGLETHREAD(TrayUIThread)

    return m_shPrinter;
}

HRESULT CPrintNotify::_NotifyRegister(BOOL bRegister)
{
    SINGLETHREAD(TrayUIThread)

    HRESULT hr = E_FAIL;
    ASSERT(m_pPrintLib.pGet());

    if( bRegister )
    {
        // register request
        hr =  (m_bRegistered ? S_OK : HRESULT_FROM_WIN32(m_pPrintLib->pNotify()->sRegister(this)));
        m_bRegistered = SUCCEEDED(hr) ? TRUE  : m_bRegistered;
    }
    else
    {
        // unregister request
        hr = (!m_bRegistered ? S_OK : HRESULT_FROM_WIN32(m_pPrintLib->pNotify()->sUnregister(this)));
        m_bRegistered = SUCCEEDED(hr) ? FALSE : m_bRegistered;
    }

    return hr;
}

HANDLE CPrintNotify::hEvent() const 
{ 
    // !!MT NOTES!!
    // this function can be invoked only from the bkgnd threads,
    // but it never touches the object state.

    ASSERT(m_shNotify); 
    return m_shNotify; 
}

void CPrintNotify::vProcessNotifyWork(TNotify *pNotify)
{
    // !!MT NOTES!!
    // this function can be invoked only from the bkgnd threads,
    // but it never touches the object state.

    ASSERT(m_shNotify);
    ASSERT(m_spClient);

    DWORD dwChange = 0;
    CAutoPtrPrinterNotify pInfo;

    PRINTER_NOTIFY_OPTIONS opt = {2, 0, m_dwCount, m_arrNotifications };
    if( FindNextPrinterChangeNotification(m_shNotify, &dwChange,  &opt, pInfo.GetPPV()) )
    {
        // we hope the client callback will process this call quickly as there shouldn't 
        // be any delays here if we don't want to loose notifications.
        // we don't really care what the retirn value is here.
        m_spClient->PrinterChange(m_uCookie, dwChange, pInfo);
    }
}

////////////////////////////////////////////////
// class CMultilineEditBug
//

LRESULT CMultilineEditBug::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hDlg = GetParent(hwnd);
    if( hDlg && GetParent(hDlg) )
    {
        hDlg = GetParent(hDlg);
    }

    if( hDlg && WM_KEYDOWN == uMsg && VK_RETURN == wParam && GetKeyState(VK_CONTROL) >= 0 )
    {
        LRESULT lr = SendMessage(hDlg, DM_GETDEFID, 0, 0);
        if( lr && LOWORD(lr) && DC_HASDEFID == HIWORD(lr) )
        {
            HWND hwndButton = GetDlgItem(hDlg, LOWORD(lr));
            PostMessage(hDlg, WM_COMMAND, MAKEWPARAM(LOWORD(lr), BN_CLICKED), (LPARAM)hwndButton);
        }
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\spinterf.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation
All rights reserved.

Module Name:

    spinterf.cxx

Abstract:

    spooler private interfaces (private exports in winspool.drv)

Author:

    Lazar Ivanov (LazarI)  Jul-05-2000

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "spinterf.hxx"

/*++

Title:  

    MakePrnPersistError

Routine Description:    

    converts a PRN_PERSIST HRESULT to a Win32 error

Arguments:  

    hr  -   HRESULT to convert
    
Return Value:   

    Win32 error code
    
--*/
DWORD
MakePrnPersistError(HRESULT hr)
{
    DWORD   err;

    if(HRESULT_FACILITY(hr) == static_cast<HRESULT>(FACILITY_ITF))
    {
        err = ERROR_INVALID_ACCESS;
    }
    else
    {
        err = HRESULT_CODE(hr);
    }

    return err;

};

/*++

Title:  

    RestorePrinterSettings

Routine Description:    

    applies stored settings on specified printer

Arguments:  

    pszPrinterName	-- printer name 

    pszFileName		-- file name 

    flags           -- flags that specify which settings to restore

Return Value:   

    S_OK if succeeded
    PRN_PERSIST hresult ( FACILITY_ITF ) returned by IPrnStream::RestorePrinterInfo

Last Error:

    ERROR_INVALID_ACCESS if hr is a PRN_PERSIST HRESULT
    an Win32 error code if hr is a predefined HRESULT

--*/
HRESULT
RestorePrinterSettings(
	IN LPCTSTR	pszPrinterName,
	IN LPCTSTR	pszFileName,
    IN DWORD    flags
    )
{
	TStatusB    bStatus;
    TStatusH    hr;
    IPrnStream *pIPrnStream = NULL;
    
    
    CoInitialize( NULL );

    hr DBGCHK = CoCreateInstance( CLSID_PrintUIShellExtension, 0, CLSCTX_INPROC_SERVER, IID_IPrnStream, (VOID**)&pIPrnStream );

    if( SUCCEEDED( hr ) )
    {
        hr DBGCHK = pIPrnStream->BindPrinterAndFile(pszPrinterName,pszFileName);

        if(SUCCEEDED(hr))
        {
            hr DBGCHK = pIPrnStream->RestorePrinterInfo(flags);
        }

        pIPrnStream->Release();
    }
    
    CoUninitialize();

    if(FAILED(hr))
    {
        SetLastError(MakePrnPersistError(hr));
    }


    return hr;
    
}

/*++

Title:  

    StorePrinterSettings

Routine Description:    

    store printer settings into file

Arguments:  

    pszPrinterName	-- printer name 

    pszFileName		-- file name 

    flags           -- specify which settings to store 

Return Value:   

    S_OK if succeeded
    PRN_PERSIST hresult ( FACILITY_ITF ) returned by IPrnStream::StorePrinterInfo

Last Error:

    ERROR_INVALID_ACCESS if hr is a PRN_PERSIST HRESULT
    an Win32 error code if hr is a predefined HRESULT

--*/
HRESULT
StorePrinterSettings(
	IN LPTSTR	pszPrinterName,
	IN LPTSTR	pszFileName,
    IN DWORD    flags
    )
{
	TStatusB    bStatus;
    TStatusH    hr;
    IPrnStream *pIPrnStream = NULL;
    
    
    CoInitialize( NULL );

    hr DBGCHK = CoCreateInstance( CLSID_PrintUIShellExtension, 0, CLSCTX_INPROC_SERVER, IID_IPrnStream, (VOID**)&pIPrnStream );

    if( SUCCEEDED( hr ) )
    {
        hr DBGCHK = pIPrnStream->BindPrinterAndFile(pszPrinterName,pszFileName);

        if(SUCCEEDED(hr))
        {
            hr DBGCHK = pIPrnStream->StorePrinterInfo(flags);
        }

        pIPrnStream->Release();
    }
    
    CoUninitialize();


    if(FAILED(hr))
    {
        SetLastError(MakePrnPersistError(hr));
    }

    return hr;
}

extern "C" 
{

// prototypes of some private APIs exported from splcore.dll
typedef HRESULT WINAPI fnPrintUIWebPnpEntry(LPCTSTR lpszCmdLine);
typedef HRESULT WINAPI fnPrintUIWebPnpPostEntry(BOOL fConnection, LPCTSTR lpszBinFile, LPCTSTR lpszPortName, LPCTSTR lpszPrtName);
typedef HRESULT WINAPI fnPrintUICreateInstance(REFIID riid, void **ppv);

enum 
{
    // the export ordinals for each function
    ordPrintUIWebPnpEntry          = 226,
    ordPrintUIWebPnpPostEntry      = 227,
    ordPrintUICreateInstance       = 228,
};

} // extern "C" 

static HMODULE g_hWinspool          = NULL;
static fnPrintUIWebPnpEntry         *g_pfnPrintUIWebPnpEntry        = NULL;
static fnPrintUIWebPnpPostEntry     *g_pfnPrintUIWebPnpPostEntry    = NULL;
static fnPrintUICreateInstance      *g_pfnPrintUICreateInstance     = NULL;

HRESULT Winspool_WebPnpEntry(LPCTSTR lpszCmdLine)
{
    return g_pfnPrintUIWebPnpEntry ? g_pfnPrintUIWebPnpEntry(lpszCmdLine) : E_FAIL;
}

HRESULT Winspool_WebPnpPostEntry(BOOL fConnection, LPCTSTR lpszBinFile, LPCTSTR lpszPortName, LPCTSTR lpszPrtName)
{
    return g_pfnPrintUIWebPnpPostEntry ? g_pfnPrintUIWebPnpPostEntry(
        fConnection, lpszBinFile, lpszPortName, lpszPrtName) : E_FAIL;
}

HRESULT Winspool_CreateInstance(REFIID riid, void **ppv)
{
    return g_pfnPrintUICreateInstance ? g_pfnPrintUICreateInstance(riid, ppv) : E_FAIL;
}

// init/shutdown of splcore.dll 
HRESULT Winspool_Init()
{
    HRESULT hr = E_FAIL;
    g_hWinspool = LoadLibrary(TEXT("winspool.drv"));
    if( g_hWinspool )
    {
        g_pfnPrintUIWebPnpEntry        = reinterpret_cast<fnPrintUIWebPnpEntry*>(
            GetProcAddress(g_hWinspool, (LPCSTR)MAKEINTRESOURCE(ordPrintUIWebPnpEntry)));

        g_pfnPrintUIWebPnpPostEntry    = reinterpret_cast<fnPrintUIWebPnpPostEntry*>(
            GetProcAddress(g_hWinspool, (LPCSTR)MAKEINTRESOURCE(ordPrintUIWebPnpPostEntry)));

        g_pfnPrintUICreateInstance     = reinterpret_cast<fnPrintUICreateInstance*>(
            GetProcAddress(g_hWinspool, (LPCSTR)MAKEINTRESOURCE(ordPrintUICreateInstance)));

        if( g_pfnPrintUIWebPnpEntry && g_pfnPrintUIWebPnpPostEntry && g_pfnPrintUICreateInstance )
        {
            hr = S_OK;
        }
        else
        {
            g_pfnPrintUIWebPnpEntry        = NULL;
            g_pfnPrintUIWebPnpPostEntry    = NULL;
            g_pfnPrintUICreateInstance     = NULL;

            FreeLibrary(g_hWinspool);
            g_hWinspool = NULL;
        }
    }
    return hr;
}

HRESULT Winspool_Done()
{
    if( g_hWinspool )
    {
        g_pfnPrintUIWebPnpEntry        = NULL;
        g_pfnPrintUIWebPnpPostEntry    = NULL;
        g_pfnPrintUICreateInstance     = NULL;

        FreeLibrary(g_hWinspool);
        g_hWinspool = NULL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\svrprop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    svrprop.cxx

Abstract:

    Server Properties

Author:

    Steve Kiraly (SteveKi)  11/15/95

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "psetup.hxx"
#include "drvver.hxx"
#include "drvsetup.hxx"
#include "portslv.hxx"
#include "portdlg.hxx"
#include "driverif.hxx"
#include "driverlv.hxx"
#include "driverdt.hxx"
#include "svrprop.hxx"
#include "forms.hxx"
#include "time.hxx"
#include "instarch.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "archlv.hxx"
#include "detect.hxx"
#include "setup.hxx"
#include "prndata.hxx"
#include "persist.hxx"

/*++

Routine Description:

    WOW64 version.

    see vServerPropPages below.

Arguments:

    see vServerPropPages below.

Return Value:

--*/

VOID
vServerPropPagesWOW64(
    IN HWND     hwnd,
    IN LPCTSTR  pszServerName,
    IN INT      iCmdShow,
    IN LPARAM   lParam
    )
{
    //
    // This function potentially may load the driver UI so we call a private API
    // exported by winspool.drv, which will RPC the call to a special 64 bit surrogate
    // process where the 64 bit driver can be loaded.
    //
    CDllLoader dll(TEXT("winspool.drv"));
    if (dll)
    {
        ptr_PrintUIServerPropPages pfn =
            (ptr_PrintUIServerPropPages )dll.GetProcAddress(ord_PrintUIServerPropPages);

        if (pfn)
        {
            // call into winspool.drv
            pfn(hwnd, pszServerName, iCmdShow, lParam);
        }
    }
}

/*++

Routine Description:

    Native version.

    see vServerPropPages below.

Arguments:

    see vServerPropPages below.

Return Value:

--*/

VOID
vServerPropPagesNative(
    IN HWND     hwnd,
    IN LPCTSTR  pszServerName,
    IN INT      iCmdShow,
    IN LPARAM   lParam
    )
{
    DBGMSG( DBG_TRACE, ( "vServerPropPages\n") );

    BOOL bModal = FALSE;
    DWORD dwSheetNumber = LOWORD( lParam );
    //
    // If the high word is non zero then dialog is modal.
    //
    if( HIWORD( lParam ) ) {
        bModal = TRUE;
    }

    //
    // Create the server specific data.
    //
    TServerData *pServerData = new TServerData( pszServerName,
                                                iCmdShow,
                                                dwSheetNumber,
                                                hwnd,
                                                bModal );
    //
    // If errors were encountered creating document data.
    //
    if( !VALID_PTR( pServerData )){
        goto Fail;
    }

    //
    // If lparam is has the high word non zero the dialog is modal.
    //
    if( bModal ) {

        //
        // If a failure occured then the message has already been displayed,
        // therefore we just exit.
        //
        iServerPropPagesProc( pServerData );
        return;

    } else {

        //
        // Create the thread which handles the UI.  iServerPropPagesProc adopts
        // pServerData, therefore only on thread creation failure do we
        // release the data back to the heap.
        //
        DWORD dwIgnore;
        HANDLE hThread;
        hThread = TSafeThread::Create( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)iServerPropPagesProc,
                                pServerData,
                                0,
                                &dwIgnore );

        //
        // Check thread creation.
        //
        if( !hThread ){
            goto Fail;
        }

        //
        // Thread handle is not needed.
        //
        CloseHandle( hThread );
        return;
    }

Fail:

    if( !pServerData ){

        vShowResourceError( hwnd );

    } else {

        iMessage( hwnd,
                  IDS_SERVER_PROPERTIES_TITLE,
                  IDS_ERR_SERVER_PROP_CANNOT_VIEW,
                  MB_OK|MB_ICONSTOP,
                  kMsgGetLastError,
                  NULL );
    }

    delete pServerData;

}

/*++

Routine Description:

    This function opens the property sheet of specified server.

    We can't guarentee that this propset will perform all lengthy
    operations in a worker thread (we synchronously call things like
    ConfigurePort).  Therefore, we spawn off a separate thread to
    handle document properties.

Arguments:

    hwnd - Specifies the parent window (optional).
    pszPrinter - Specifies the printer name (e.g., "My HP LaserJet IIISi").
    nCmdShow - Initial show state
    lParam - May specify a sheet number to open to or if the high word
             is non zero then dialog is modal.

Return Value:

--*/
VOID
vServerPropPages(
    IN HWND     hwnd,
    IN LPCTSTR  pszServerName,
    IN INT      iCmdShow,
    IN LPARAM   lParam
    )
{
    if (IsRunningWOW64())
    {
        vServerPropPagesWOW64(hwnd, pszServerName, iCmdShow, lParam);
    }
    else
    {
        vServerPropPagesNative(hwnd, pszServerName, iCmdShow, lParam);
    }
}

/*++

aRoutine Name:

    iServerPropPagesProc

Routine Description:

    This is the routine called by the create thread call to display the
    server property sheets.

Arguments:

    pServerData - Pointer to the Server data set used by all property sheets.

Return Value:

    TRUE - if the property sheets were displayed.
    FALSE - error creating and displaying property sheets.

--*/
INT WINAPI
iServerPropPagesProc(
    IN TServerData *pServerData ADOPT
    )
{
    DBGMSG( DBG_TRACE, ( "iServerPropPagesProc\n") );

    BOOL bStatus = pServerData->bRegisterWindow( PRINTER_PIDL_TYPE_PROPERTIES );

    if( bStatus ){

        //
        // Check if the window is already present.
        //
        if( pServerData->bIsWindowPresent() ){
            DBGMSG( DBG_TRACE, ( "iServerPropPagesProc: currently running.\n" ) );
            bStatus = FALSE;
        }
    }

    if( bStatus ) {

        bStatus = pServerData->bLoad();

        if( !bStatus ){

            iMessage( pServerData->_hwnd,
                      IDS_SERVER_PROPERTIES_TITLE,
                      IDS_ERR_SERVER_PROP_CANNOT_VIEW,
                      MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                      kMsgGetLastError,
                      NULL );
        } else {

            //
            // Create the Server property sheet windows.
            //
            TServerWindows ServerWindows( pServerData );

            //
            // Were the document windows create
            //
            if( !VALID_OBJ( ServerWindows ) ){

                iMessage( pServerData->_hwnd,
                          IDS_SERVER_PROPERTIES_TITLE,
                          IDS_ERR_SERVER_PROP_CANNOT_VIEW,
                          MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                          kMsgGetLastError,
                          NULL );

                bStatus = FALSE;
            }

            //
            // Build the property pages.
            //
            if( bStatus ){
                if( !ServerWindows.bBuildPages( ) ){
                    vShowResourceError( NULL );
                    bStatus = FALSE;
                }
            }

            //
            // Display the property pages.
            //
            if( bStatus ){
                if( !ServerWindows.bDisplayPages( ) ){
                    vShowResourceError( NULL );
                    bStatus = FALSE;
                }
            }
        }
    }

    //
    // Ensure we release the document data.
    // We have adopted pSeverData, so we must free it.
    //
    delete pServerData;

    return bStatus;
}


/*++

Routine Name:

    TServerData

Routine Description:

    Server data property sheet constructor.

Arguments:

    pszPrinterName  - Name of printer or queue where jobs reside.
    JobId           - Job id to display properties of.
    iCmdShow        - Show dialog style.
    lParam          - Indicates which page to display initialy

Return Value:

    Nothing.

--*/

TServerData::
TServerData(
    IN LPCTSTR  pszServerName,
    IN INT      iCmdShow,
    IN LPARAM   lParam,
    IN HWND     hwnd,
    IN BOOL     bModal
    ) : MSingletonWin( pszServerName, hwnd, bModal ),
        _iCmdShow( iCmdShow ),
        _uStartPage( (UINT)lParam ),
        _bValid( FALSE ),
        _hPrintServer( NULL ),
        _hDefaultSmallIcon( NULL ),
        _bCancelButtonIsClose( FALSE ),
        _dwDriverVersion( 0 ),
        _bRemoteDownLevel( FALSE ),
        _bRebootRequired( FALSE )
{
    if( !MSingletonWin::bValid( )){
        return;
    }

    //
    // Retrieve icons.
    //
    LoadPrinterIcons( _strPrinterName, NULL, &_hDefaultSmallIcon );

    SPLASSERT( _hDefaultSmallIcon );

    //
    // Set the server name to NULL if it's local.
    //
    _pszServerName = _strPrinterName.bEmpty() ? NULL : (LPCTSTR)_strPrinterName;

    //
    // Get the machine name.
    //
    vCreateMachineName( _strPrinterName,
                        _pszServerName ? FALSE : TRUE,
                        _strMachineName );

    //
    // Get the print servers driver version, the driver
    // version corresponds to the actual spooler version, we
    // are using this for downlevel detection.
    //
    if( !bGetCurrentDriver( _pszServerName, &_dwDriverVersion ) )
    {
        //
        // Note this is not a fatal error, we won't have the
        // add/delete/configure ports buttons enabled.
        //
        DBGMSG( DBG_WARN, ( "Get driver version failed.\n" ) );
    }

    //
    // Check if we are remotely administering a downlevel machine
    //
    _bRemoteDownLevel = ( bIsRemote( _pszServerName ) && ( GetDriverVersion( _dwDriverVersion ) <= 2 ) ) ? TRUE : FALSE;

    _bValid = TRUE;
}

/*++

Routine Name:

    ~TServerData

Routine Description:

    Stores the document data back to the server.

Arguments:

    None.

Return Value:

    Nothing.

--*/

TServerData::
~TServerData(
    VOID
    )
{
    //
    // Insure we close the print server.
    //
    if( _hPrintServer ){
        ClosePrinter( _hPrintServer );
    }

    //
    // Destroy the printer icon.
    //
    if( _hDefaultSmallIcon ){
        DestroyIcon( _hDefaultSmallIcon );
    }

}

/*++

Routine Name:

    bValid

Routine Description:

    Returns objects state.

Arguments:

    None.

Return Value:

    TRUE object is in valid state, FALSE object is not valid.

--*/
BOOL
TServerData::
bValid(
    VOID
    )
{
    return _bValid;
}


/*++

Routine Name:

    vCreateMachineName

Routine Description:

    Create the machine name for display.  bLocal indicates the
    provided server name is for the local machine,  Since a
    local machine is often represented by the NULL pointer we
    will get the computer name if a local server name is passed.  If the
    bLocal is false strPrinterName contains the name of the remote
    printer server.

Arguments:

    strServerName - Name of the print server.
    bLocal - TRUE str server name is local, or FALSE strPrinterName is name of
            remote print server.
    strMachineName - Target of the fetched machine name.

Return Value:

    Nothing.

--*/
VOID
TServerData::
vCreateMachineName(
    IN const TString &strServerName,
    IN BOOL bLocal,
    IN TString &strMachineName
    )
{
    TStatusB bStatus;
    LPCTSTR pszBuffer;

    //
    // If a server name was provided then set the title to
    // the server name, otherwise get the computer name.
    //
    if( !bLocal ){

        //
        // Copy the server name.
        //
        bStatus DBGCHK = strMachineName.bUpdate( strServerName );

    } else {

        //
        // Server name is null, therefore it is the local machine.
        //
        bStatus DBGCHK = bGetMachineName( strMachineName );
    }

    //
    // Remove any leading slashes.
    //
    pszBuffer = (LPCTSTR)strMachineName;
    for( ; pszBuffer && (*pszBuffer == TEXT( '\\' )); pszBuffer++ )
        ;

    //
    // Update the name we display on the sheets.
    //
    bStatus DBGCHK = strMachineName.bUpdate( pszBuffer );
}

/*++

Routine Name:

    bLoad

Routine Description:

    Loads the property sheet specific data.

Arguments:

    None.

Return Value:

    TRUE    - Data loaded successfully,
    FALSE   - Data was not loaded.

--*/
BOOL
TServerData::
bLoad(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TServerData::bLoad\n") );

    //
    // Attempt to open print server with full access.
    //
    TStatus Status;
    DWORD dwAccess = 0;
    Status DBGCHK = TPrinter::sOpenPrinter( pszServerName(),
                                            &dwAccess,
                                            &_hPrintServer );

    if( Status == ERROR_SUCCESS ){

        //
        // Save administrator capability flag.
        //
        bAdministrator() = (dwAccess == SERVER_ALL_ACCESS);

        //
        // Get the default title from the resource file.
        //
        if( !_strTitle.bLoadString( ghInst, IDS_SERVER_SETTINGS_TITLE ) ){
            DBGMSG( DBG_WARN, ( "strTitle().bLoadString failed with %d\n", GetLastError () ) );
            vShowResourceError( hwnd() );
        }

        //
        // Null terminate the title buffer.
        //
        TCHAR szTitle[kStrMax+kPrinterBufMax] = {0};
        UINT nSize = COUNTOF( szTitle );

        //
        // Create the property sheet title.
        //
        if( pszServerName() ){
            _tcscpy( szTitle, pszServerName() );
            _tcscat( szTitle, TEXT( "\\" ) );
        }

        //
        // Build the title buffer.
        //
        _tcscat( szTitle, _strTitle );

        //
        // Format the title similar to the shell.
        //
        ConstructPrinterFriendlyName( szTitle, szTitle, &nSize );

        //
        // Update the property sheet title.
        //
        if( !_strTitle.bUpdate( szTitle ) ){
            DBGMSG( DBG_WARN, ( "strTitle().bUpdate failed with %d\n", GetLastError () ) );
            vShowResourceError( hwnd() );
        }
    }

    return Status == ERROR_SUCCESS;
}

/*++

Routine Name:

    bStore

Routine Description:

    Stores the document data from back to the printer system.

Arguments:

    None.

Return Value:

    TRUE - Server data stored successfully,
    FALSE - if document data was not stored.

--*/
BOOL
TServerData::
bStore(
    VOID
    )
{
    return TRUE;
}

/********************************************************************

    Server Property Base Class

********************************************************************/
/*++

Routine Name:

    TServerProp

Routine Description:

    Initialized the server property sheet base class

Arguments:

    pServerData - Pointer to server data needed for all property sheets.

Return Value:

    None.

--*/
TServerProp::
TServerProp(
    IN TServerData* pServerData
    ) : _pServerData( pServerData )
{
}

/*++

Routine Name:

    ~TServerProp

Routine Description:

    Base class desctuctor.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TServerProp::
~TServerProp(
    )
{

}

/*++

Routine Name:

    bValid

Routine Description:

    Determis if an object is in a valid state.

Arguments:

    None.

Return Value:

    TRUE object is valid.  FALSE object is not valid.
--*/
BOOL
TServerProp::
bValid(
    VOID
    )
{
    return ( _pServerData ) ? TRUE : FALSE;
}

/*++

Routine Name:

    vCancelToClose

Routine Description:

    Change the cancel button to close, the user has basically
    made a change that cannot be undone using the cancel button.

Arguments:

    None.

Return Value:

    Nothing.

--*/
VOID
TServerProp::
vCancelToClose(
    IN HWND hDlg
    )
{
    PropSheet_CancelToClose( GetParent( hDlg ) );
    _pServerData->bCancelButtonIsClose() = TRUE;
}

/*++

Routine Name:

    bHandleMessage

Routine Description:

    Base class message handler.  This routine is called by
    derived classes who do not want to handle the message.


Arguments:

    uMsg    - Windows message
    wParam  - Word parameter
    lParam  - Long parameter


Return Value:

    TRUE if message was handled, FALSE if message not handled.

--*/
BOOL
TServerProp::
bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL bStatus = TRUE;

    UNREFERENCED_PARAMETER( wParam );

    switch( uMsg ){

    //
    // Set the values on the UI.
    //
    case WM_INITDIALOG:
        bStatus = bSetUI();
        break;

    //
    // Handle help and context help.
    //
    case WM_HELP:
    case WM_CONTEXTMENU:
        bStatus = PrintUIHelp( uMsg, _hDlg, wParam, lParam );
        break;

    //
    // Save the data.
    //
    case WM_DESTROY:
        bStatus = FALSE;
        break;

    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code )
        {
        //
        // User switched to the next page.
        //
        case PSN_KILLACTIVE:
            bStatus = bReadUI();
            vSetDlgMsgResult( !bStatus );
            //
            // Must return true, to make the property sheet
            // control look at the dlg message result.
            //
            bStatus = TRUE;
            break;

        //
        // User has chosen the close or apply button.
        //
        case PSN_APPLY:
            {
                LPPSHNOTIFY pPSHNotify = (LPPSHNOTIFY)lParam;

                //
                // Save the UI to the system.
                //
                bStatus = bSaveUI();

                //
                // If there was a failure then switch to this page.
                //
                if( !bStatus )
                {
                    //
                    // Switch to page with the error.
                    //
                    PropSheet_SetCurSelByID( GetParent( _hDlg ), uGetPageId() );
                }

                //
                // If the lParam is true the close button was used to
                // dismiss the dialog.  Let the dialog exit if the close
                // button was clicked and one of the dialogs failed.
                //
                if( pPSHNotify->lParam == TRUE && bStatus == FALSE )
                {
                    //
                    // If the cancel button is has the closed text, then
                    // prompt the user if they want to exit on failure.
                    // The cancel button state is stored in the server data
                    // because it has to be global to all property sheets.
                    //
                    if( _pServerData->bCancelButtonIsClose() )
                    {
                        //
                        // Display the error message.
                        //
                        if( iMessage( _hDlg,
                                      IDS_SERVER_PROPERTIES_TITLE,
                                      IDS_ERR_WANT_TO_EXIT,
                                      MB_YESNO|MB_ICONSTOP,
                                      kMsgNone,
                                      NULL ) == IDYES )
                        {
                            bStatus = TRUE;
                        }
                    }
                }

                //
                // Indicate the return value to the property sheet control
                //
                vSetDlgMsgResult( bStatus == FALSE ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR );

                //
                // Must return true, to make the property sheet
                // control look at the dlg message result.
                //
                bStatus = TRUE;
            }

            break;

        //
        // Indicate the user chose the cancel button.
        //
        case PSN_QUERYCANCEL:
            bStatus = FALSE;
            break;

        default:
            bStatus = FALSE;
            break;
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }

    return bStatus;
}

/********************************************************************

    Forms Server Property Sheet.

********************************************************************/

/*++

Routine Name:

    TServerForms

Routine Description:

    Document property sheet derived class.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TServerForms::
TServerForms(
    IN TServerData *pServerData
    ) : TServerProp( pServerData )
{
    //
    // This does forms specific initialization.
    //
    _p = FormsInit( pServerData->pszServerName(),
                    pServerData->hPrintServer(),
                    pServerData->bAdministrator(),
                    pServerData->strMachineName() );
}

/*++

Routine Name:

    ~TServerForms

Routine Description:

    Document derived class destructor.

Arguments:

    None.

Return Value:

    Nothing.

--*/

TServerForms::
~TServerForms(
    VOID
    )
{
    //
    // Forms specific termination.
    //
    FormsFini( _p );
}

/*++

Routine Name:

    bValid

Routine Description:

    Document property sheet derived class valid object indicator.

Arguments:

    None.

Return Value:

    Returns the status of the base class.

--*/
BOOL
TServerForms::
bValid(
    VOID
    )
{
    return ( _p ) ? TRUE : FALSE;
}

/*++

Routine Name:

    bSetUI

Routine Description:

    Loads the property sheet dialog with the document data
    information.

Arguments:

    None.

Return Value:

    TRUE if data loaded successfully, FALSE if error occurred.

--*/
BOOL
TServerForms::
bSetUI(
    VOID
    )

{
    return TRUE;
}

/*++

Routine Name:

    bReadUI

Routine Description:

    Stores the property information to the print server.

Arguments:

    Nothing data is contained with in the class.

Return Value:

    TRUE if data is stores successfully, FALSE if error occurred.

--*/
BOOL
TServerForms::
bReadUI(
    VOID
    )
{
    return TRUE;
}

/*++

Routine Name:

    bSaveUI

Routine Description:

    Saves the UI data to some API call or print server.

Arguments:

    Nothing data is contained with in the class.

Return Value:

    TRUE if data is stores successfully, FALSE if error occurred.

--*/
BOOL
TServerForms::
bSaveUI(
    VOID
    )
{
    // force a save form event.
    bHandleMessage( WM_COMMAND,
                    (WPARAM)MAKELPARAM( IDD_FM_PB_SAVEFORM, kMagic ),
                    (LPARAM)GetDlgItem( _hDlg, IDD_FM_PB_SAVEFORM ));

    // check to see if failed
    return (ERROR_SUCCESS == Forms_GetLastError(_p));
}

/*++

Routine Name:

    bHandleMessage

Routine Description:

    Server property sheet message handler.  This handler only
    handles events it wants and the base class handle will do the
    standard message handling.

Arguments:

    uMsg    - Windows message
    wParam  - Word parameter
    lParam  - Long parameter


Return Value:

    TRUE if message was handled, FALSE if message not handled.

--*/

BOOL
TServerForms::
bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL bStatus = FALSE;
    LONG_PTR PrevValue;

    //
    // !!Hack!!
    //
    // This is code to get the borrowed forms dialog
    // code from printman, to work.  It is saving our "this" pointer and
    // placing the forms specific data in the GWL_USERDATA.
    //
    PrevValue = GetWindowLongPtr( _hDlg, GWLP_USERDATA );

    SetWindowLongPtr( _hDlg, GWLP_USERDATA, (LONG_PTR)_p );

    if( uMsg == WM_INITDIALOG )
    {
        lParam = (LPARAM)_p;
    }

    bStatus = FormsDlg( _hDlg, uMsg, wParam, lParam );

    SetWindowLongPtr( _hDlg, GWLP_USERDATA, PrevValue );

    //
    // If the message was handled - check to call PSM_CANCELTOCLOSE
    //
    if( bStatus && Forms_IsThereCommitedChanges(_p) )
    {
        vCancelToClose( _hDlg );
    }

    //
    // If the message was not handled pass it on to the derrived base class.
    //
    if( !bStatus )
    {
        bStatus = TServerProp::bHandleMessage( uMsg, wParam, lParam );
    }

    return bStatus;
}

/********************************************************************

    Settings Server Property Sheet.

********************************************************************/

/*++

Routine Name:

    TServerSettings

Routine Description:

    Document property sheet derived class.

Arguments:

    None.

Return Value:

    Nothing.

--*/
TServerSettings::
TServerSettings(
    IN TServerData *pServerData
    ) : TServerProp( pServerData ),
        _bBeepErrorJobs( FALSE ),
        _bEventLogging( FALSE ),
        _bNotifyPrintedJobs( FALSE ),
        _bNotifyLocalPrintedJobs( FALSE ),
        _bNotifyNetworkPrintedJobs( TRUE ),
        _bNotifyPrintedJobsComputer( FALSE ),
        _bChanged( FALSE ),
        _bDownLevelServer( TRUE ),
        _bNewOptionSupport( TRUE )
{
}

/*++

Routine Name:

    ~TServerSettings

Routine Description:

    Document derived class destructor.

Arguments:

    None.

Return Value:

    Nothing.

--*/

TServerSettings::
~TServerSettings(
    VOID
    )
{
}

/*++

Routine Name:

    bValid

Routine Description:

    Document property sheet derived class valid object indicator.

Arguments:

    None.

Return Value:

    Returns the status of the base class.

--*/
BOOL
TServerSettings::
bValid(
    VOID
    )
{
    return TServerProp::bValid();
}

/*++

Routine Name:

    bSetUI

Routine Description:

    Loads the property sheet dialog with the document data
    information.

Arguments:

    None.

Return Value:

    TRUE if data loaded successfully, FALSE if error occurred.

--*/
BOOL
TServerSettings::
bSetUI(
    VOID
    )

{
    return bSetUI( kServerAttributesLoad );
}

/*++

Routine Name:

    bSetUI

Routine Description:

    Loads the property sheet dialog with the document data
    information.

Arguments:

    The specified load type.

Return Value:

    TRUE if data loaded successfully, FALSE if error occurred.

--*/
BOOL
TServerSettings::
bSetUI(
    INT LoadType
    )

{
    DBGMSG( DBG_TRACE, ( "TServerSettings::bSetUI\n") );

    //
    // Set the printer title.
    //
    if( !bSetEditText( _hDlg, IDC_SERVER_NAME, _pServerData->strMachineName() ))
        return FALSE;

    //
    // Load the server attributes into the class variables.  If this fails
    // it is assumed the machine is either a downlevel server or something
    // went wrong.
    //
    if( sServerAttributes( LoadType ) == kStatusError ){

        //
        // Disable the controls.
        //
        vEnable( FALSE );

        //
        // Indicate the server is not compatible.
        //
        _bDownLevelServer = FALSE;

        //
        // Display the error message.
        //
        iMessage( _hDlg,
                  IDS_SERVER_PROPERTIES_TITLE,
                  IDS_ERR_SERVER_SETTINGS_NOT_AVAILABLE,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        return FALSE;
    }

    //
    // Set the spool directory edit control.
    //
    if( !bSetEditText( _hDlg, IDC_SERVER_SPOOL_DIRECTORY, _strSpoolDirectory ))
    {
        return FALSE;
    }

    //
    // Save a copy of the origianl spool directory.
    //
    if( !_strSpoolDirectoryOrig.bUpdate( _strSpoolDirectory ) )
    {
        return FALSE;
    }

    //
    // Reset the changed flag, the message handler sees a edit control
    // change message when we set the spool directory.
    //
    _bChanged = FALSE;

    //
    // Set check box states.
    //
    vSetCheck( _hDlg, IDC_SERVER_EVENT_LOGGING_ERROR, _bEventLogging & EVENTLOG_ERROR_TYPE       );
    vSetCheck( _hDlg, IDC_SERVER_EVENT_LOGGING_WARN,  _bEventLogging & EVENTLOG_WARNING_TYPE     );
    vSetCheck( _hDlg, IDC_SERVER_EVENT_LOGGING_INFO,  _bEventLogging & EVENTLOG_INFORMATION_TYPE );
    vSetCheck( _hDlg, IDC_SERVER_REMOTE_JOB_ERRORS,   _bBeepErrorJobs     );
    vSetCheck( _hDlg, IDC_SERVER_JOB_NOTIFY,          _bNotifyPrintedJobs );
    vSetCheck( _hDlg, IDC_SERVER_LOCAL_JOB_NOTIFY,    _bNotifyLocalPrintedJobs );
    vSetCheck( _hDlg, IDC_SERVER_NETWORK_JOB_NOTIFY,  _bNotifyNetworkPrintedJobs );
    vSetCheck( _hDlg, IDC_SERVER_JOB_NOTIFY_COMPUTER, _bNotifyPrintedJobsComputer );

    //
    // In remote case, we don't show the "notify user" check box and move the lower controls up.
    //
    if( bIsRemote( _pServerData->pszServerName() ) )
    {
        RECT rc;
        RECT rcUpper;
        int deltaY;

        ShowWindow( GetDlgItem( _hDlg, IDC_SERVER_LOCAL_JOB_NOTIFY ), SW_HIDE );
        ShowWindow( GetDlgItem( _hDlg, IDC_SERVER_NETWORK_JOB_NOTIFY ), SW_HIDE );

        GetWindowRect( GetDlgItem( _hDlg, IDC_SERVER_NETWORK_JOB_NOTIFY ), &rc );
        GetWindowRect( GetDlgItem( _hDlg, IDC_SERVER_REMOTE_JOB_ERRORS ), &rcUpper );
        deltaY = rcUpper.bottom - rc.bottom;

        MoveWindowWrap( GetDlgItem( _hDlg, IDC_DOWNLEVEL_LINE ), 0, deltaY );
        MoveWindowWrap( GetDlgItem( _hDlg, IDC_DOWNLEVEL_TEXT ), 0, deltaY );
        MoveWindowWrap( GetDlgItem( _hDlg, IDC_SERVER_JOB_NOTIFY ), 0, deltaY );
        MoveWindowWrap( GetDlgItem( _hDlg, IDC_SERVER_JOB_NOTIFY_COMPUTER ), 0, deltaY );
    }

    //
    // Only NT 5.0 and greater supports the SPLREG_NET_POPUP_TO_COMPUTER
    //
    if( !_bNewOptionSupport )
    {
        ShowWindow( GetDlgItem( _hDlg, IDC_SERVER_JOB_NOTIFY_COMPUTER ), SW_HIDE);
    }

    //
    // Enable of disable the UI based on the administrator state.
    //
    vEnable( _pServerData->bAdministrator() );

    return TRUE;
}

VOID
TServerSettings::
vEnable(
    BOOL bState
    )
{
    //
    // Set the UI control state.
    //
    vEnableCtl( _hDlg, IDC_SERVER_EVENT_LOGGING_ERROR,  bState );
    vEnableCtl( _hDlg, IDC_SERVER_EVENT_LOGGING_WARN,   bState );
    vEnableCtl( _hDlg, IDC_SERVER_EVENT_LOGGING_INFO,   bState );
    vEnableCtl( _hDlg, IDC_SPOOL_FOLDER_TEXT,           bState );
    vEnableCtl( _hDlg, IDC_SERVER_SPOOL_DIRECTORY,      bState );
    vEnableCtl( _hDlg, IDC_SERVER_REMOTE_JOB_ERRORS,    bState );
    vEnableCtl( _hDlg, IDC_DOWNLEVEL_TEXT,              bState );
    vEnableCtl( _hDlg, IDC_SERVER_JOB_NOTIFY,           bState );
    vEnableCtl( _hDlg, IDC_SERVER_JOB_NOTIFY_COMPUTER,  bState && _bNotifyPrintedJobs );
}


/*++

Routine Name:

    bReadUI

Routine Description:

    Read the UI data storing it back to this object.

Arguments:

    Nothing data is contained with in the class.

Return Value:

    TRUE if data is read successfully, FALSE if error occurred.

--*/
BOOL
TServerSettings::
bReadUI(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TServerSettings::bReadUI\n") );

    TStatusB bStatus;

    //
    // Read the spool directory edit box.
    //
    bStatus DBGCHK = bGetEditText( _hDlg, IDC_SERVER_SPOOL_DIRECTORY, _strSpoolDirectory );

    //
    // Do minor validation on the spool directory.
    //
    if( _strSpoolDirectory.bEmpty() && _bDownLevelServer )
    {
        //
        // Display the error message.
        //
        iMessage( _hDlg,
                  IDS_SERVER_PROPERTIES_TITLE,
                  IDS_ERR_SERVER_SETTINGS_INVALID_DIR,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );

        bStatus DBGNOCHK = FALSE;
    }

    if( bStatus )
    {
        //
        // Read settings check boxes.
        //
        _bEventLogging              = bGetCheck( _hDlg, IDC_SERVER_EVENT_LOGGING_ERROR ) << 0;
        _bEventLogging             |= bGetCheck( _hDlg, IDC_SERVER_EVENT_LOGGING_WARN )  << 1;
        _bEventLogging             |= bGetCheck( _hDlg, IDC_SERVER_EVENT_LOGGING_INFO )  << 2;
        _bBeepErrorJobs             = bGetCheck( _hDlg, IDC_SERVER_REMOTE_JOB_ERRORS );
        _bNotifyLocalPrintedJobs    = bGetCheck( _hDlg, IDC_SERVER_LOCAL_JOB_NOTIFY );
        _bNotifyNetworkPrintedJobs  = bGetCheck( _hDlg, IDC_SERVER_NETWORK_JOB_NOTIFY );
        _bNotifyPrintedJobs         = bGetCheck( _hDlg, IDC_SERVER_JOB_NOTIFY );
        _bNotifyPrintedJobsComputer = bGetCheck( _hDlg, IDC_SERVER_JOB_NOTIFY_COMPUTER );
    }

    return bStatus;
}

/*++

Routine Name:

    bSaveUI

Routine Description:

    Saves the UI data with some API call to the print server.

Arguments:

    Nothing data is contained with in the class.

Return Value:

    TRUE if data is stores successfully, FALSE if error occurred.

--*/
BOOL
TServerSettings::
bSaveUI(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ( "TServerSettings::bSaveUI\n") );

    BOOL bStatus = TRUE;
    BOOL bErrorShown = FALSE;

    //
    // If data was chagned save the settings.
    //
    if( _bChanged && _bDownLevelServer ) {

        if( lstrcmpi(_strSpoolDirectoryOrig, _strSpoolDirectory) ) {

            //
            // The spooler folder has been changed. Warn the user
            // for potential loose of the current printing jobs.
            //
            INT iResult = iMessage( _hDlg,
                                    IDS_SERVER_PROPERTIES_TITLE,
                                    IDS_SERVER_PROPERTIES_CHANGESPOOLFOLDER_WARN,
                                    MB_YESNO|MB_ICONEXCLAMATION|MB_DEFBUTTON2,
                                    kMsgNone,
                                    NULL );

            if( IDNO == iResult ) {

                //
                // The user did not what to continue, don't close the dialog.
                //
                SetLastError( ERROR_CANCELLED );
                bStatus = FALSE;

            }
        }

        if( bStatus ) {

            switch( sServerAttributes( kServerAttributesStore ) ){

            case kStatusCannotSaveUserNotification:

                //
                // Display the error message.
                //
                iMessage( _hDlg,
                          IDS_SERVER_PROPERTIES_TITLE,
                          IDS_ERR_GENERIC,
                          MB_OK|MB_ICONHAND,
                          kMsgNone,
                          NULL );

                bStatus = FALSE;
                bErrorShown = TRUE;
                break;

            case kStatusInvalidSpoolDirectory:

                //
                // Display the error message.
                //
                iMessage( _hDlg,
                          IDS_SERVER_PROPERTIES_TITLE,
                          IDS_ERR_SERVER_SETTINGS_INVALID_DIR,
                          MB_OK|MB_ICONSTOP,
                          kMsgNone,
                          NULL );
                //
                // Set focus to control with error.
                //
                SetFocus( GetDlgItem( _hDlg, IDC_SERVER_SPOOL_DIRECTORY ) );
                bStatus = FALSE;
                bErrorShown = TRUE;
                break;

            case kStatusSuccess:

                _bChanged = FALSE;
                bStatus = TRUE;
                break;

            case kStatusError:
            default:

                bStatus = FALSE;
                break;
            }

            if( bStatus && _pServerData->bAdministrator() ) {

                //
                // Update the new original spooler directory
                //
                bStatus = _strSpoolDirectoryOrig.bUpdate( _strSpoolDirectory );
            }
        }
    }

    if( !bStatus ) {

        //
        // Display the error message.
        //
        if( GetLastError() != ERROR_CANCELLED && !bErrorShown ) {
            iMessage( _hDlg,
                      IDS_SERVER_PROPERTIES_TITLE,
                      IDS_ERR_SERVER_SETTINGS_SAVE,
                      MB_OK|MB_ICONSTOP,
                      kMsgGetLastError,
                      NULL );
        }
    }


    return bStatus;
}

/*++

Routine Name:

    sServerAttributes

Routine Description:

    Loads and stores server attributes.

Arguments:

    Direction flag either kStore or kLoad pr kDefault

Return Value:

    Status values, see EStatus for for details.

--*/

INT
TServerSettings::
sServerAttributes(
    INT iFlag
    )
{
    INT         iStatus;
    TStatusH    hr;

    //
    // Create the printer data access class.
    //
    TPrinterDataAccess Data( _pServerData->_hPrintServer );
    TPersist NotifyUser( gszPrinterPositions, TPersist::kCreate|TPersist::kRead|TPersist::kWrite );

    //
    // Relax the return type checking, BOOL are not REG_DWORD but REG_BINARY
    //
    Data.RelaxReturnTypeCheck( TRUE );

    switch( iFlag )
    {

    //
    // Load from the spooler
    //
    case kServerAttributesLoad:

        hr DBGCHK = Data.Get( SPLREG_DEFAULT_SPOOL_DIRECTORY,  _strSpoolDirectory );
        hr DBGCHK = Data.Get( SPLREG_BEEP_ENABLED,             _bBeepErrorJobs );
        hr DBGCHK = Data.Get( SPLREG_EVENT_LOG,                _bEventLogging );
        hr DBGCHK = Data.Get( SPLREG_NET_POPUP,                _bNotifyPrintedJobs );

        hr DBGCHK = NotifyUser.bRead( gszLocalPrintNotification, _bNotifyLocalPrintedJobs ) ? S_OK : E_FAIL;
        hr DBGCHK = NotifyUser.bRead( gszNetworkPrintNotification, _bNotifyNetworkPrintedJobs ) ? S_OK : E_FAIL;
        hr DBGCHK = Data.Get( SPLREG_NET_POPUP_TO_COMPUTER,    _bNotifyPrintedJobsComputer );

        //
        // If we fail reading the net popup to computer with invalid parameter
        // we are talking to a downlevel machine pre nt 5.0 machine.  If this
        // is the case we simple do not show this option in the UI and continue
        // normally.
        //
        if( FAILED( hr ) && HRESULT_CODE( hr ) == ERROR_INVALID_PARAMETER )
        {
            _bNewOptionSupport = FALSE;
        }

        //
        // If were are talking to a downlevel machine pre nt 4.0,
        // get printer data calls will fail with error invalid handle.  We
        // only check the last value read, since this error code should never
        // happen on any calls to get printer data.
        //
        if( FAILED( hr ) && HRESULT_CODE( hr ) == ERROR_INVALID_HANDLE )
        {
            iStatus = kStatusError;
        }
        else
        {
            iStatus = kStatusSuccess;
        }
        break;

    //
    // Store to the spooler
    //
    case kServerAttributesStore:

        //
        // We save this data for local case
        //
        if( !bIsRemote( _pServerData->pszServerName() ) && VALID_OBJ( NotifyUser ) )
        {
            if( !NotifyUser.bWrite( gszLocalPrintNotification, _bNotifyLocalPrintedJobs ) ||
                !NotifyUser.bWrite( gszNetworkPrintNotification, _bNotifyNetworkPrintedJobs ) )
            {
                iStatus = kStatusCannotSaveUserNotification;
                break;
            }
        }

        //
        // If the current user is not administrator, we just return
        //
        if( !_pServerData->bAdministrator() )
        {
            iStatus = kStatusSuccess;
            break;
        }

        hr DBGCHK = Data.Set( SPLREG_DEFAULT_SPOOL_DIRECTORY,  _strSpoolDirectory );

        if( FAILED( hr ) )
        {
            iStatus = kStatusInvalidSpoolDirectory;
        }
        else
        {
            if( SUCCEEDED( hr ) )
            {
                hr DBGCHK = Data.Set( SPLREG_BEEP_ENABLED, _bBeepErrorJobs );
            }

            if( SUCCEEDED( hr ) )
            {
                hr DBGCHK = Data.Set( SPLREG_EVENT_LOG, _bEventLogging );
            }

            if( SUCCEEDED( hr ) )
            {
                hr DBGCHK = Data.Set( SPLREG_NET_POPUP, _bNotifyPrintedJobs );
            }

            if( SUCCEEDED( hr ) && _bNewOptionSupport )
            {
                hr DBGCHK = Data.Set( SPLREG_NET_POPUP_TO_COMPUTER, _bNotifyPrintedJobsComputer );
            }

            if( SUCCEEDED( hr ) )
            {
                iStatus = kStatusSuccess;

                if( HRESULT_CODE( hr ) == ERROR_SUCCESS_RESTART_REQUIRED )
                {
                    _pServerData->_bRebootRequired = TRUE;
                }
            }
            else
            {
                iStatus = kStatusError;
            }
        }

        break;

    //
    // Load defaults from the spooler.
    //
    case kServerAttributesDefault:

        iStatus = kStatusSuccess;
        break;

    //
    // Default is to return an error.
    //
    default:

        iStatus = kStatusError;
        break;
    }

    return iStatus;

}


/*++

Routine Name:

    bHandleMessage

Routine Description:

    Server property sheet message handler.  This handler only
    handles events it wants and the base class handle will do the
    standard message handling.

Arguments:

    uMsg    - Windows message
    wParam  - Word parameter
    lParam  - Long parameter


Return Value:

    TRUE if message was handled, FALSE if message not handled.

--*/

BOOL
TServerSettings::
bHandleMessage(
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL bStatus = FALSE;
    BOOL bChanged = FALSE;

    switch( uMsg ){

    case WM_COMMAND:

        //
        // Monitor changes in the UI to highlight the apply button.
        //
        switch( GET_WM_COMMAND_ID( wParam, lParam ) ) {

        case IDC_SERVER_SPOOL_DIRECTORY:
            bChanged = GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE;
            bStatus  = TRUE;
            break;

        case IDC_SERVER_REMOTE_JOB_ERRORS:
        case IDC_SERVER_LOCAL_JOB_NOTIFY:
        case IDC_SERVER_NETWORK_JOB_NOTIFY:
        case IDC_SERVER_JOB_NOTIFY:
        case IDC_SERVER_JOB_NOTIFY_COMPUTER:
        case IDC_SERVER_EVENT_LOGGING_ERROR:
        case IDC_SERVER_EVENT_LOGGING_WARN:
        case IDC_SERVER_EVENT_LOGGING_INFO:
            {
                if( IDC_SERVER_JOB_NOTIFY == GET_WM_COMMAND_ID( wParam, lParam ) )
                {
                    vEnableCtl( _hDlg, IDC_SERVER_JOB_NOTIFY_COMPUTER,
                        bGetCheck( _hDlg, IDC_SERVER_JOB_NOTIFY ) );
                }

                bChanged = TRUE;
                bStatus  = TRUE;
            }
            break;

        default:
            bStatus = FALSE;
            break;
        }
        break;

    default:
        bStatus = FALSE;
        break;
    }

    //
    // If something changed enable the apply button.
    //
    if( bChanged ){
        _bChanged = TRUE;
        PropSheet_Changed( GetParent( _hDlg ), _hDlg );
    }

    //
    // If the message was not handled let the base class handle it.
    //
    if( bStatus == FALSE )
        bStatus = TServerProp::bHandleMessage( uMsg, wParam, lParam );

    return bStatus;
}

/********************************************************************

    Port selection.

********************************************************************/
TServerPorts::
TServerPorts(
    IN TServerData *pServerData
    ) : TServerProp( pServerData )
{
}

TServerPorts::
~TServerPorts(
    VOID
    )
{
}

BOOL
TServerPorts::
bValid(
    VOID
    )
{
    return ( TServerProp::bValid() && _PortsLV.bValid() );
}

BOOL
TServerPorts::
bReadUI(
    VOID
    )
{
    return TRUE;
}

BOOL
TServerPorts::
bSaveUI(
    VOID
    )
{
    return TRUE;
}


/*++

Routine Name:

    bSetUI

Routine Description:

    Loads the property sheet dialog with the document data
    information.

Arguments:

    None.

Return Value:

    TRUE if data loaded successfully, FALSE if error occurred.

--*/
BOOL
TServerPorts::
bSetUI(
    VOID
    )
{
    //
    // Set the printer title.
    //
    if( !bSetEditText( _hDlg, IDC_SERVER_NAME, _pServerData->strMachineName() ))
    {
        vShowUnexpectedError( _pServerData->hwnd(), IDS_SERVER_PROPERTIES_TITLE );
        return FALSE;
    }

    //
    // Initialize the ports listview.
    //
    if( !_PortsLV.bSetUI( GetDlgItem( _hDlg, IDC_PORTS ), FALSE, FALSE, TRUE, _hDlg, 0, 0, IDC_PORT_DELETE ) )
    {
        DBGMSG( DBG_WARN, ( "ServerPort.vSetUI: failed %d\n", GetLastError( )));
        vShowUnexpectedError( _pServerData->hwnd(), IDS_SERVER_PROPERTIES_TITLE );
        return FALSE;
    }

    //
    // Load ports into the view.
    //
    if( !_PortsLV.bReloadPorts( _pServerData->pszServerName() ) )
    {
        DBGMSG( DBG_WARN, ( "ServerPort.vSetUI: bReloadPorts failed %d\n", GetLastError( )));
        vShowUnexpectedError( _pServerData->hwnd(), IDS_SERVER_PROPERTIES_TITLE );
        return FALSE;
    }

    //
    // Select the first item
    //
    _PortsLV.vSelectItem( 0 );

    //
    // Adding / deleting / configuring ports is not supported on remote downlevel machines.
    //
    if( !_pServerData->bAdministrator() || _pServerData->bRemoteDownLevel() )
    {
        //
        // Disable things if not administrator.
        //
        vEnableCtl( _hDlg, IDC_PORT_CREATE, FALSE );
        vEnableCtl( _hDlg, IDC_PORT_DELETE, FALSE );
        vEnableCtl( _hDlg, IDC_PROPERTIES,  FALSE );
    }

    //
    // Bidi support is currently disabled.
    //
    ShowWindow( GetDlgItem( _hDlg, IDC_ENABLE_BIDI ), SW_HIDE );

    return TRUE;

}

/*++

Routine Name:

    bHandleMessage

Routine Description:

    Server property sheet message handler.  This handler only
    handles events it wants and the base class handle will do the
    standard message handling.

Arguments:

    uMsg    - Windows message
    wParam  - Word parameter
    lParam  - Long parameter


Return Value:

    TRUE if message was handled, FALSE if message not handled.

--*/
BOOL
TServerPorts::
bHandleMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL bStatus = FALSE;

    switch( uMsg ){

    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ) ){

        case IDC_PORT_DELETE:
            {
                //
                // Delete the selected port.
                //
                HWND hwnd = GetDlgItem( _hDlg, IDC_PORT_DELETE );

                //
                // We will only delete the port if the button is enabled, this check is
                // necessary if the user uses the delete key on the keyboard to delete
                // the port.
                //
                if( IsWindowEnabled( hwnd ) )
                {
                    bStatus = _PortsLV.bDeletePorts( _hDlg, _pServerData->pszServerName( ));

                    if( bStatus )
                    {
                        SetFocus( hwnd );
                    }
                }
            }
            break;

        case IDC_PROPERTIES:

            //
            // Configure the selected port.
            //
            bStatus = _PortsLV.bConfigurePort( _hDlg, _pServerData->pszServerName( ));
            SetFocus( GetDlgItem( _hDlg, IDC_PROPERTIES ) );
            break;

        case IDC_PORT_CREATE:  {
            //
            // Create add ports class.
            //
            TAddPort AddPort( _hDlg,
                            _pServerData->pszServerName(),
                            TRUE );

            //
            // Insure the add port was created successfully.
            //
            bStatus = VALID_OBJ( AddPort );

            if( !bStatus ) {

                vShowUnexpectedError( _hDlg, TAddPort::kErrorMessage );

            } else {

                //
                // Interact with the Add Ports dialog.
                //
                bStatus = AddPort.bDoModal();

                if( bStatus ){

                    //
                    // Load the machine's ports into the listview.
                    //
                    bStatus = _PortsLV.bReloadPorts( _pServerData->pszServerName( ), TRUE );
                }
            }
        }
        break;

        default:
            bStatus = FALSE;
            break;
        }

        break;

    case WM_NOTIFY:

        //
        // Handle any ports list view messages.
        //
        switch( wParam )
        {
        case IDC_PORTS:

            //
            // Enable/disable buttons depending on the current status
            //
            if( _pServerData->bAdministrator() && ( ((LPNMHDR)lParam)->code == LVN_ITEMCHANGED ) )
            {
                if( _pServerData->bRemoteDownLevel() )
                {
                    // remote or downlevel case - all buttons will be disabled
                    vEnableCtl( _hDlg, IDC_PORT_CREATE, FALSE );
                    vEnableCtl( _hDlg, IDC_PORT_DELETE, FALSE );
                    vEnableCtl( _hDlg, IDC_PROPERTIES, FALSE );
                }
                else if( 0 == _PortsLV.cSelectedItems() )
                {
                    // no selection case. disable config & delete buttons
                    vEnableCtl( _hDlg, IDC_PORT_CREATE, TRUE );
                    vEnableCtl( _hDlg, IDC_PORT_DELETE, FALSE );
                    vEnableCtl( _hDlg, IDC_PROPERTIES, FALSE );
                }
                else if( 1 == _PortsLV.cSelectedItems() )
                {
                    // only one port is selected - enable all buttons
                    vEnableCtl( _hDlg, IDC_PORT_CREATE, TRUE );
                    vEnableCtl( _hDlg, IDC_PORT_DELETE, TRUE );
                    vEnableCtl( _hDlg, IDC_PROPERTIES, TRUE );
                }
                else
                {
                    // many ports are selected and we are not in remote and/or downlevel case
                    // enable only the create and delete buttons
                    vEnableCtl( _hDlg, IDC_PORT_CREATE, TRUE );
                    vEnableCtl( _hDlg, IDC_PORT_DELETE, TRUE );
                    vEnableCtl( _hDlg, IDC_PROPERTIES, FALSE );
                }
            }

            (VOID)_PortsLV.bHandleNotifyMessage( lParam );

            bStatus = FALSE;
            break;

        default:
            bStatus = FALSE;
            break;
        }
        break;

    default:
        bStatus = FALSE;
        break;

    }

    //
    // If the message was handled.
    //
    if( bStatus != FALSE )
    {
        vCancelToClose( _hDlg );
        return bStatus;
    }

    //
    // If the message was not handled pass it on to the base class.
    //
    if( bStatus == FALSE )
        bStatus = TServerProp::bHandleMessage( uMsg, wParam, lParam );

    return bStatus;

}

/********************************************************************

    Server Driver Administration.

********************************************************************/
TServerDrivers::
TServerDrivers(
    IN TServerData *pServerData
    ) : TServerProp( pServerData ),
        _bChanged( FALSE ),
        _bCanRemoveDrivers( TRUE )
{
}

TServerDrivers::
~TServerDrivers(
    VOID
    )
{
}

BOOL
TServerDrivers::
bValid(
    VOID
    )
{
    return TServerProp::bValid() && VALID_OBJ( _DriversLV );
}

BOOL
TServerDrivers::
bReadUI(
    VOID
    )
{
    return TRUE;
}

/*++

Routine Name:

    bSaveUI

Routine Description:

    Save the contenst of the UI to the system.

Arguments:

    None.

Return Value:

    TRUE if save was successful, FALSE if error occurred.

--*/
BOOL
TServerDrivers::
bSaveUI(
    VOID
    )
{
    //
    // Display the hour glass the refresh may take awhile.
    //
    TWaitCursor Cur;

    //
    // Create a driver noitfy.
    //
    TServerDriverNotify Notify ( this );

    //
    // Install / Remove / Update any drivers.
    //
    (VOID)_DriversLV.bSendDriverInfoNotification( Notify );

    //
    // Refesh the drivers list.
    //
    TStatusB bStatus;
    bStatus DBGCHK = _DriversLV.bRefresh();
    if( !bStatus )
    {
        //
        // Display the error message.
        //
        iMessage( _hDlg,
                  IDS_SERVER_PROPERTIES_TITLE,
                  IDS_ERR_DRIVERS_NOT_REFRESHED,
                  MB_OK|MB_ICONSTOP,
                  kMsgGetLastError,
                  NULL );
    }

    //
    // Sort the environment column.
    //
    (VOID)_DriversLV.bSortColumn( TDriversLV::kEnvironmentColumn );

    //
    // Sort the driver name.
    //
    (VOID)_DriversLV.bSortColumn( TDriversLV::kDriverNameColumn );

    //
    // Select the first item in the list view.
    //
    _DriversLV.vSelectItem( 0 );

    //
    // Return success only if there was not a falure and the refresh succeeded.
    //
    return bStatus;
}

/*++

Routine Name:

    bSetUI

Routine Description:

    Loads the property sheet dialog with the document data
    information.

Arguments:

    None.

Return Value:

    TRUE if data loaded successfully, FALSE if error occurred.

--*/
BOOL
TServerDrivers::
bSetUI(
    VOID
    )
{
    TStatusB bStatus;

    //
    // Set the printer title.
    //
    bStatus DBGCHK = bSetEditText( _hDlg, IDC_SERVER_NAME, _pServerData->strMachineName() );

    //
    // If we are an administrator handle the delete message.
    //
    UINT idRemove = _pServerData->bAdministrator() ? IDC_REMOVE_DRIVER : 0;

    //
    // Set the drivers list view.
    //
    bStatus DBGCHK = _DriversLV.bSetUI( _pServerData->pszServerName(), _hDlg, IDC_MORE_DETAILS, IDC_ITEM_SELECTED, idRemove );

    //
    // Load the list view with driver data.
    //
    bStatus DBGCHK = _DriversLV.bRefresh();

    //
    // Set the default sort order.
    //
    bStatus DBGCHK = _DriversLV.bSortColumn( TDriversLV::kEnvironmentColumn );

    //
    // Sort the driver name.
    //
    bStatus DBGCHK = _DriversLV.bSortColumn( TDriversLV::kDriverNameColumn );

    //
    // Update the button state.
    //
    vUpdateButtons();

    //
    // Select the first item in the list view.
    //
    _DriversLV.vSelectItem( 0 );

    //
    // If we are talking to a down level spooler then deleting printer drivers
    // can only be done with a call to DeletePrinterDriver, no ex version exists.
    // Because DeletePrinterDriver only allows the caller to delete all drivers
    // of a specific environment with out regards to version, we have decided to
    // not allow removing printer drivers on down level machines.  In addition
    // DeletePrinterDriver is as kind of broken since it does not actually remove
    // the driver files, it only removes the registry entries.
    //
    if( GetDriverVersion( _pServerData->dwDriverVersion() ) <= 2 )
    {
        _bCanRemoveDrivers = FALSE;
    }

    return bStatus;
}

/*++

Routine Name:

    vUpdateButtons

Routine Description:

    Update the dialog buttons.

Arguments:

    None.

Return Value:

    Nothing.

--*/
VOID
TServerDrivers::
vUpdateButtons(
    VOID
    )
{
    //
    // Default is the details button disabled.
    //
    vEnableCtl( _hDlg, IDC_MORE_DETAILS,    FALSE );
    vEnableCtl( _hDlg, IDC_UPDATE_DRIVER,   FALSE );
    vEnableCtl( _hDlg, IDC_REMOVE_DRIVER,   FALSE );

    //
    // If not an administrator then disable the add button.
    //
    if( !_pServerData->bAdministrator() )
    {
        vEnableCtl( _hDlg, IDC_ADD_DRIVER,      FALSE );
    }
}

/*++

Routine Name:

    bHandleMessage

Routine Description:

    Server property sheet message handler.  This handler only
    handles events it wants and the base class handle will do the
    standard message handling.

Arguments:

    uMsg    - Windows message
    wParam  - Word parameter
    lParam  - Long parameter


Return Value:

    TRUE if message was handled, FALSE if message not handled.

--*/
BOOL
TServerDrivers::
bHandleMessage(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    BOOL bStatus = TRUE;
    BOOL bChanged = FALSE;

    switch( uMsg )
    {
    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ) )
        {
        case IDC_ADD_DRIVER:
            if( bHandleAddDriver( uMsg, wParam, lParam ) )
                bChanged = TRUE;
            break;

        case IDC_UPDATE_DRIVER:
            if( bHandleUpdateDriver( uMsg, wParam, lParam ) )
                bChanged = TRUE;
            break;

        case IDC_REMOVE_DRIVER:
            if( bHandleRemoveDriver( uMsg, wParam, lParam ) )
                bChanged = TRUE;
            break;

        case IDC_MORE_DETAILS:
            bHandleDriverDetails( uMsg, wParam, lParam );
            break;

        case IDC_ITEM_SELECTED:
            bHandleDriverItemSelection( uMsg, wParam, lParam );
            break;

        default:
            bStatus = FALSE;
            break;

        }
        break;

    default:
        bStatus = FALSE;
        break;
    }

    //
    // If something changed save the changes and change the
    // the ok button to close and gray the cancel button.
    //
    if( bChanged ){

        //
        // Update the button state.
        //
        vUpdateButtons();

        //
        // Save the UI and convert CancelToClose
        //
        (VOID)bSaveUI();
        vCancelToClose( _hDlg );
    }

    //
    // Let the list view handle their message.
    //
    if( bStatus == FALSE )
        bStatus = _DriversLV.bHandleMessage( uMsg, wParam, lParam );

    //
    // If the message was not handled pass it on to the base class.
    //
    if( bStatus == FALSE )
        bStatus = TServerProp::bHandleMessage( uMsg, wParam, lParam );

    return bStatus;

}

BOOL
TServerDrivers::
bHandleDriverItemSelection(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDrivers::bHandleDriverItemSelection\n" ) );

    //
    // Get the button state in a local variable.
    //
    BOOL bButtonState = _DriversLV.bIsAnyItemSelcted();

    //
    // If any item is selected then enable the properties button.
    //
    vEnableCtl( _hDlg, IDC_MORE_DETAILS,  bButtonState );
    vEnableCtl( _hDlg, IDC_UPDATE_DRIVER, bButtonState && _pServerData->bAdministrator() );
    vEnableCtl( _hDlg, IDC_REMOVE_DRIVER, bButtonState && _pServerData->bAdministrator() && _bCanRemoveDrivers );

    return TRUE;
}

BOOL
TServerDrivers::
bHandleAddDriver(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDrivers::bHandleAddDriver\n" ) );

    TString strDriverName;
    TStatusB bStatus;
    BOOL bCanceled;
    UINT nDriverInstallCount = 0;

    //
    // Add any new drivers, displaying the add driver wizard.
    //
    bStatus DBGCHK = bInstallNewPrinterDriver( _hDlg,
                                               TWizard::kDriverInstall,
                                               _pServerData->pszServerName(),
                                               strDriverName,
                                               NULL,
                                               kDriverWizardDefault,
                                               &bCanceled,
                                               FALSE,
                                               &nDriverInstallCount );
    //
    // If any driver was installed then return true
    // inorder to indicate we need to refresh the driver list view.
    //
    if( nDriverInstallCount )
    {
        bStatus DBGNOCHK = TRUE;
    }

    return bStatus;
}

BOOL
TServerDrivers::
bHandleRemoveDriver(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDrivers::bHandleRemoveDriver\n" ) );

    //
    // If we cannot remove the drivers because we are administrating
    // a downlevel machine then do nothing.
    //
    if( !_bCanRemoveDrivers )
    {
        return FALSE;
    }

    TStatusB bStatus;

    //
    // Get a list of the selected items.
    //
    UINT nCount = 0;
    TDriverTransfer DriverTransfer;
    bStatus DBGCHK = _DriversLV.bGetSelectedDriverInfo( DriverTransfer, &nCount );

    DBGMSG( DBG_TRACE, ( "Selected count %d\n", nCount ) );

    //
    // Warn the user that they are about to delete a driver
    // from the system permently.
    //
    if( bStatus && nCount )
    {
        bStatus DBGNOCHK = bWarnUserDriverDeletion( DriverTransfer.DriverInfoList_pGetByIndex( 0 ), nCount );
    }

    //
    // Delete the driver if the count is non zero.
    //
    if( bStatus && nCount )
    {
        //
        // Initialize the list iterator.
        //
        TIter Iter;
        DriverTransfer.DriverInfoList_vIterInit( Iter );

        TDriverInfo *pDriverInfo;

        for( Iter.vNext(); Iter.bValid(); )
        {
            pDriverInfo = DriverTransfer.DriverInfoList_pConvert( Iter );
            Iter.vNext();

            DBGMSG( DBG_TRACE, ( "Selected Driver Name: "TSTR"\n", (LPCTSTR)pDriverInfo->strName() ) );

            //
            // If the driver was added but not installed then
            // removed it the item entirely.
            //
            if( pDriverInfo->vGetInfoState() == TDriverInfo::kAdd )
            {
                DBGMSG( DBG_TRACE, ( "Uninstalled driver was removed.\n" ) );
                pDriverInfo->vSetInfoState( TDriverInfo::kRemoved );
            }

            //
            // Mark the item to be removed.
            //
            else
            {
                DBGMSG( DBG_TRACE, ( "Driver removed.\n" ) );
                pDriverInfo->vSetInfoState( TDriverInfo::kRemove );
            }
        }
        //
        // Return the removed items back to the list and delete
        // these items form the UI part of the list view.
        //
        _DriversLV.vDeleteDriverInfoFromListView( DriverTransfer );
    }
    else
    {
        //
        // Return the selected items back to the list view.
        //
        _DriversLV.vReturnDriverInfoToListView( DriverTransfer );
    }

    //
    // If there are no more drivers in the list view then remove
    // default button state from the remove button and change it
    // to the add button, since the add button is always enabled.
    //
    if( !_DriversLV.uGetListViewItemCount() )
    {
        SendMessage( GetDlgItem( _hDlg, IDC_REMOVE_DRIVER ),
                                 BM_SETSTYLE,
                                 MAKEWPARAM( BS_PUSHBUTTON, 0 ),
                                 MAKELPARAM( TRUE, 0 ) );

        SendMessage( GetDlgItem( _hDlg, IDC_ADD_DRIVER ),
                                 BM_SETSTYLE,
                                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                                 MAKELPARAM( TRUE, 0 ) );

        SetFocus( GetDlgItem( _hDlg, IDC_ADD_DRIVER ) );
    }

    return bStatus;
}

BOOL
TServerDrivers::
bHandleUpdateDriver(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDrivers::bHandleUpdateDriver\n" ) );

    TStatusB bStatus;
    bStatus DBGNOCHK = FALSE;

    //
    // Get a list of the selected items.
    //
    UINT nCount = 0;
    TDriverTransfer DriverTransfer;
    bStatus DBGCHK = _DriversLV.bGetSelectedDriverInfo( DriverTransfer, &nCount );

    DBGMSG( DBG_TRACE, ( "Selected count %d\n", nCount ) );

    //
    // Warn the user that they are about to update a driver from the system permently.
    //
    if( bStatus && nCount )
    {
        bStatus DBGNOCHK = bWarnUserDriverUpdate( DriverTransfer.DriverInfoList_pGetByIndex( 0 ), nCount );
    }

    //
    // Delete the driver if the count is non zero.
    //
    if( bStatus && nCount )
    {
        //
        // Initialize the list iterator.
        //
        TIter Iter;
        DriverTransfer.DriverInfoList_vIterInit( Iter );

        TDriverInfo *pDriverInfo;

        for( Iter.vNext(); Iter.bValid(); Iter.vNext() )
        {
            pDriverInfo = DriverTransfer.DriverInfoList_pConvert( Iter );

            DBGMSG( DBG_TRACE, ( "Selected Driver Name: "TSTR"\n", (LPCTSTR)pDriverInfo->strName() ) );

            //
            // Mark all the selected driver as update canidates.
            //
            pDriverInfo->vSetInfoState( TDriverInfo::kUpdate );
        }
    }

    //
    // Return the selected items back to the list view.
    //
    _DriversLV.vReturnDriverInfoToListView( DriverTransfer );

    return bStatus;
}

BOOL
TServerDrivers::
bHandleDriverDetails(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDrivers::bHandleDetails\n" ) );

    TStatusB bStatus;
    TDriverInfo *pDriverInfo;
    TDriversLV::THandle Handle;

    for( bStatus DBGNOCHK = TRUE; bStatus ; )
    {
        bStatus DBGNOCHK = _DriversLV.bGetSelectedDriverInfo( &pDriverInfo, Handle );

        if( bStatus )
        {
            TDriverDetails Details( _hDlg, pDriverInfo );

            if( VALID_OBJ( Details ) )
            {
                Details.bDoModal();
            }
        }
    }

    return TRUE;
}

BOOL
TServerDrivers::
bWarnUserDriverDeletion(
    IN TDriverInfo *pDriverInfo,
    IN UINT         nCount
    ) const
{
    //
    // If there are multiple items selected then the warning message
    // is changed.
    //
    INT iMsg = nCount == 1 ? IDS_ERR_DELETE_PRINTER_DRIVER : IDS_ERR_DELETE_PRINTER_DRIVERN;

    //
    // Return success of the user was warned and decided to complete
    // the printer driver removal.
    //
    return iMessage( _hDlg,
                     IDS_SERVER_PROPERTIES_TITLE,
                     iMsg,
                     MB_YESNO | MB_ICONQUESTION,
                     kMsgNone,
                     NULL,
                     static_cast<LPCTSTR>( pDriverInfo->strName() ) ) == IDYES ? TRUE : FALSE;
}

BOOL
TServerDrivers::
bWarnUserDriverUpdate(
    IN TDriverInfo *pDriverInfo,
    IN UINT         nCount
    ) const
{
    //
    // If there are multiple items selected then the warning message
    // is changed.
    //
    INT iMsg = nCount == 1 ? IDS_ERR_UPDATE_PRINTER_DRIVER : IDS_ERR_UPDATE_PRINTER_DRIVERN;

    //
    // Return success of the user was warned and decided to complete
    // the printer driver removal.
    //
    return iMessage( _hDlg,
                     IDS_SERVER_PROPERTIES_TITLE,
                     iMsg,
                     MB_YESNO | MB_ICONQUESTION,
                     kMsgNone,
                     NULL,
                     static_cast<LPCTSTR>( pDriverInfo->strName() ) ) == IDYES ? TRUE : FALSE;
}

/********************************************************************

    Server Driver Notify

********************************************************************/
TServerDriverNotify::
TServerDriverNotify(
    TServerDrivers *pServerDrivers
    ) : _pServerDrivers( pServerDrivers ),
        _pDi( NULL ),
        _uNotifyCount( 0 ),
        _bActionFailed( FALSE )
{
}

TServerDriverNotify::
~TServerDriverNotify(
    VOID
    )
{
    //
    // Ensure we release the printer driver installation object.
    //
    delete _pDi;
}

/*++

Routine Name:

    bNotify

Routine Description:

    Called for all driver info classes in the list view.

Arguments:

    pDriverInfo - Pointer to driver info class.

Return Value:

    TRUE continue for the remaing driver info classes.
    FALSE stop notification.

--*/
BOOL
TServerDriverNotify::
bNotify(
    IN TDriverInfo *pDriverInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDriverNotify::bNotify\n" ) );

    //
    // Adjust the notify count, used for detection the multi selection
    //
    //
    _uNotifyCount++;

    BOOL    bStatus     = TRUE;
    INT     iMessageId  = 0;

    switch( pDriverInfo->vGetInfoState() )
    {
    case TDriverInfo::kRemove:
        bStatus = bRemove( pDriverInfo );
        iMessageId = IDS_ERR_ALL_DRIVER_NOT_REMOVED;
        break;

    case TDriverInfo::kAdd:
        bStatus = bInstall( pDriverInfo );
        iMessageId = IDS_ERR_ALL_DRIVER_NOT_INSTALLED;
        break;

    case TDriverInfo::kUpdate:
        bStatus = bUpdate( pDriverInfo );
        iMessageId = IDS_ERR_ALL_DRIVER_NOT_UPDATED;
        break;

    default:
        bStatus = TRUE;
        iMessageId = 0;
        break;
    }

    if( !bStatus )
    {
        if( iMessageId && GetLastError() != ERROR_CANCELLED )
        {
            //
            // Display the error message.
            //
            iMessage( _pServerDrivers->_hDlg,
                      IDS_SERVER_PROPERTIES_TITLE,
                      iMessageId,
                      MB_OK|MB_ICONSTOP,
                      kMsgGetLastError,
                      NULL,
                      static_cast<LPCTSTR>( pDriverInfo->strName() ),
                      static_cast<LPCTSTR>( pDriverInfo->strEnvironment() ),
                      static_cast<LPCTSTR>( pDriverInfo->strVersion() ) );
        }

        _bActionFailed = TRUE;

        //
        // Currently we continue if an error occurred.
        //
        bStatus = TRUE;
    }

    return bStatus;
}

BOOL
TServerDriverNotify::
bInstall(
    IN TDriverInfo *pDriverInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDriverNotify::bInstall\n" ) );
    SPLASSERT( FALSE );
    return TRUE;
}

BOOL
TServerDriverNotify::
bRemove(
    IN TDriverInfo *pDriverInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDriverNotify::bRemove\n" ) );

    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    //
    // Delete the specfied printer driver.
    //
    bStatus DBGCHK = DeletePrinterDriverEx( (LPTSTR)_pServerDrivers->_pServerData->pszServerName(),
                                            (LPTSTR)(LPCTSTR)pDriverInfo->strEnv(),
                                            (LPTSTR)(LPCTSTR)pDriverInfo->strName(),
                                            DPD_DELETE_UNUSED_FILES|DPD_DELETE_SPECIFIC_VERSION,
                                            pDriverInfo->dwVersion());

    //
    // If we are trying this action on a down level spooler.
    //
    if( !bStatus && GetLastError() == RPC_S_PROCNUM_OUT_OF_RANGE )
    {
        bStatus DBGCHK = DeletePrinterDriver( (LPTSTR)_pServerDrivers->_pServerData->pszServerName(),
                                              (LPTSTR)(LPCTSTR)pDriverInfo->strEnv(),
                                              (LPTSTR)(LPCTSTR)pDriverInfo->strName() );
    }

    //
    // If the driver was deleted then mark the driver structure as removed.
    //
    if( bStatus )
    {
        pDriverInfo->vSetInfoState( TDriverInfo::kRemoved );
    }
    return bStatus;
}

BOOL
TServerDriverNotify::
bUpdate(
    IN TDriverInfo *pDriverInfo
    )
{
    DBGMSG( DBG_TRACE, ( "TServerDriverNotify::bUpdate\n" ) );

    TStatusB bStatus;
    DWORD dwEncode              = 0;
    DWORD dwPrevInstallFlags    = 0;

    bStatus DBGNOCHK = TRUE;

    //
    // Lazy load the printer drivers installation class.
    //
    if( !_pDi )
    {
        _pDi = new TPrinterDriverInstallation( _pServerDrivers->_pServerData->pszServerName(),
                                               _pServerDrivers->_hDlg );

        bStatus DBGNOCHK = VALID_PTR( _pDi );
    }

    if( bStatus )
    {
        DBGMSG( DBG_TRACE, ( "Installing driver "TSTR"\n", (LPCTSTR)pDriverInfo->_strName ) );

        //
        // Encode the printer driver architercure and version
        //
        bStatus DBGCHK = bEncodeArchVersion( pDriverInfo->_strEnv,
                                             pDriverInfo->_dwVersion,
                                             &dwEncode );

        //
        // Get the current install flags.
        //
        dwPrevInstallFlags = _pDi->GetInstallFlags();

        //
        // We do not copy the inf for version 2 drivers.
        //
        if( GetDriverVersion( dwEncode ) == 2 )
        {
            //
            // We don't copy the inf for version 2 drivers.
            //
            _pDi->SetInstallFlags( DRVINST_DONOTCOPY_INF);
        }

        //
        // On NT5 and greater we can overwrite all the driver files,
        // however on less than NT5 we can only copy newer files.
        //
        DWORD dwAddPrinterDriverFlags   = APD_COPY_ALL_FILES;
        DWORD dwCurrentDriverEncode     = 0;

        if( _pDi->bGetCurrentDriverEncode( &dwCurrentDriverEncode ) )
        {
            if( GetDriverVersion( dwCurrentDriverEncode ) <= 2 )
            {
                dwAddPrinterDriverFlags = APD_COPY_NEW_FILES;
            }
        }

        //
        // Select and install the printer driver.
        //
        BOOL bOfferReplacementDriver = FALSE;
        dwAddPrinterDriverFlags |= APD_INSTALL_WARNED_DRIVER;
        bStatus DBGCHK = _pDi->bSetDriverName( pDriverInfo->_strName )  &&
                         _pDi->bInstallDriver( &pDriverInfo->_strName, bOfferReplacementDriver,
                            FALSE, _pServerDrivers->_hDlg, dwEncode, dwAddPrinterDriverFlags, TRUE );


        if( bStatus )
        {
            //
            // Indicate this driver has been installed.
            //
            pDriverInfo->vSetInfoState( TDriverInfo::kInstalled );
        }

        //
        // Restore the previous install flags.
        //
        _pDi->SetInstallFlags( dwPrevInstallFlags );
    }

    return bStatus;
}

/********************************************************************

    Server property windows.

********************************************************************/
TServerWindows::
TServerWindows(
    IN TServerData *pServerData
    ) : _pServerData( pServerData ),
        _Forms( pServerData ),
        _Ports( pServerData ),
        _Settings( pServerData ),
        _Drivers( pServerData )
{
}

TServerWindows::
~TServerWindows(
    )
{
}

/*++

Routine Name:

    bBuildPages

Routine Description:

    Builds the document property windows.

Arguments:

    None - class specific.

Return Value:

    TRUE pages built ok, FALSE failure building pages.

--*/
BOOL
TServerWindows::
bBuildPages(
    VOID
    )
{

    DBGMSG( DBG_TRACE, ( "TServerWindows bBuildPages\n") );

    struct SheetInitializer {
        MGenericProp   *pSheet;
        INT             iDialog;
    };

    SheetInitializer aSheetInit[] = {
        {&_Forms,        DLG_FORMS              },
        {&_Ports,        DLG_SERVER_PORTS       },
        {&_Drivers,      DLG_SERVER_DRIVERS     },
        {&_Settings,     DLG_SERVER_SETTINGS    },
        {NULL,           NULL,                  }
    };

    BOOL bReturn = FALSE;
    BOOL bSheetsDestroyed = FALSE;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE ahpsp[COUNTOF( aSheetInit )];
    PROPSHEETPAGE psp;

    ZeroMemory( &psp, sizeof( psp ));
    ZeroMemory( &psh, sizeof( psh ));
    ZeroMemory( ahpsp, sizeof( ahpsp ));

    psh.dwSize      = sizeof( psh );
    psh.hwndParent  = _pServerData->hwnd();
    psh.dwFlags     = PSH_USEHICON | PSH_PROPTITLE;
    psh.phpage      = ahpsp;
    psh.hIcon       = _pServerData->hDefaultSmallIcon();
    psh.nStartPage  = _pServerData->uStartPage();
    psh.hInstance   = ghInst;
    psh.pszCaption  = (LPCTSTR)_pServerData->strTitle();
    psh.nPages      = COUNTOF( ahpsp );

    psp.dwSize      = sizeof( psp );
    psp.hInstance   = ghInst;
    psp.pfnDlgProc  = MGenericProp::SetupDlgProc;

    //
    // Create the property sheets.
    //
    for( UINT i = 0; i < COUNTOF( ahpsp ); ++i ){
        psp.pszTemplate = MAKEINTRESOURCE( aSheetInit[i].iDialog );
        psp.lParam      = (LPARAM)(MGenericProp*)aSheetInit[i].pSheet;
        ahpsp[i]        = CreatePropertySheetPage( &psp );
    }

    //
    // Insure the index matches the number of pages.
    //
    SPLASSERT( i == psh.nPages );

    //
    // Verify all pages were created.
    //
    for( i = 0; i < COUNTOF( ahpsp ); ++i ){
        if( !ahpsp[i] ){
            DBGMSG( DBG_WARN, ( "Server Property sheet Unable to create page %d\n", i ));
            goto Done;
        }
    }

    //
    // Indicate we do not have to distory the property sheets.
    //
    bSheetsDestroyed = TRUE;

    //
    // Display the property sheets.
    //
    if( PropertySheet( &psh ) < 0 ){

        DBGMSG( DBG_WARN, ( "Server Property Sheet failed %d\n",  GetLastError()));
        vShowResourceError( _pServerData->hwnd() );

    } else {

        //
        // Check if the reboot flag was returned.
        //
        if( _pServerData->_bRebootRequired ) {

            //
            // Display message, reboot neccessary.
            //
            if (_pServerData->pszServerName()) {

                //
                // if the server name is not NULL, we assume it is a remote printers folder.
                // This is not true if user opens the local printers folder from
                // \\local-machine-name, but this is a rare case that we can ignore.
                //

                iMessage( _pServerData->hwnd(),
                          IDS_SERVER_PROPERTIES_TITLE,
                          IDS_SERVER_SETTINGS_CHANGED_REMOTE,
                          MB_ICONEXCLAMATION,
                          kMsgNone,
                          NULL,
                          _pServerData->pszServerName()
                          );
            }
            else {

                iMessage( _pServerData->hwnd(),
                          IDS_SERVER_PROPERTIES_TITLE,
                          IDS_SERVER_SETTINGS_CHANGED,
                          MB_ICONEXCLAMATION,
                          kMsgNone,
                          NULL
                          );
            }
        }

        bReturn = TRUE;

    }

Done:

    //
    // If Sheets weren't destoryed, do it now.
    //
    if( !bSheetsDestroyed ){

        for( i = 0; i < COUNTOF( ahpsp ); ++i ){
            if( ahpsp[i] ){
                DestroyPropertySheetPage( ahpsp[i] );
            }
        }
    }

    return bReturn;
}


/*++

Routine Name:

    bDisplayPages

Routine Description:

    Displays the document property pages.

Arguments:

    None.

Return Value:

    TRUE if pages were displayed, FALSE

--*/
BOOL
TServerWindows::
bDisplayPages(
    VOID
    )
{
    return TRUE;
}


/*++

Routine Name:

    bValid

Routine Description:

    Returns if class and its dat members are vaild.

Arguments:

    None.

Return Value:

    TRUE - class is valid, FALSE class is invalid.

--*/

BOOL
TServerWindows::
bValid(
    VOID
    )
{
    //
    // Validated all the known pages.
    //
    if( VALID_OBJ( _Forms ) &&
        VALID_OBJ( _Ports ) &&
        VALID_OBJ( _Drivers ) &&
        VALID_OBJ( _Settings ) ){

        return TRUE;
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\shellext.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999
All rights reserved.

Module Name:

    shellext.cxx

Abstract:

    Printer shell extension.

Author:

    Steve Kiraly (SteveKi)  02-Feb-1997

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "portslv.hxx"
#include "dsinterf.hxx"
#include "prtprop.hxx"
#include "physloc.hxx"
#include "locprop.hxx"
#include "findloc.hxx"
#include "shellext.hxx"
#include "spinterf.hxx"
#include "prtshare.hxx"

#include <initguid.h>
#include "winprtp.h"

/********************************************************************

    In-process server functions

********************************************************************/

/*++

Name:

    DllGetClassObject

Description:

    DllGetClassObject is called by the shell to
    create a class factory object.

Arguments:

    rclsid - Reference to class ID specifier
    riid   - Reference to interface ID specifier
    ppv    - Pointer to location to receive interface pointer

Return Value:

    HRESULT code signifying success or failure

--*/
STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID *ppv
    )
{
    *ppv = NULL;

    //
    // Make sure the class ID is CLSID_PrintUIExtension. Otherwise, the class
    // factory doesn't support the object type specified by rclsid.
    //
    if (!IsEqualCLSID (rclsid, CLSID_PrintUIShellExtension))
        return ResultFromScode (CLASS_E_CLASSNOTAVAILABLE);

    //
    // Instantiate a class factory object.
    //
    TClassFactory *pClassFactory = new TClassFactory ();

    if (pClassFactory == NULL)
        return ResultFromScode (E_OUTOFMEMORY);

    //
    // Get the interface pointer from QueryInterface and copy it to *ppv.
    //
    HRESULT hr = pClassFactory->QueryInterface (riid, ppv);
    pClassFactory->Release ();
    return hr;
}

/*++

Name:

    DllCanUnloadNow

Description:

    DllCanUnloadNow is called by the shell to find out if the
    DLL can be unloaded. The answer is yes if (and only if)
    the module reference count stored in gcRefThisDll is 0.

Arguments:

    None

Return Value:

    HRESULT code equal to S_OK if the DLL can be unloaded,
    S_FALSE if not.

--*/
STDAPI
DllCanUnloadNow(
    VOID
    )
{
    LONG lObjectsAlive = COMObjects_GetCount() + gcRefThisDll;

    return ResultFromScode( lObjectsAlive == 0 ? S_OK : S_FALSE );
}

////////////////////////////////
// QueryInterface tables

// TClassFactory
QITABLE_BEGIN(TClassFactory)
     QITABENT(TClassFactory, IClassFactory),        // IID_IClassFactory
QITABLE_END()

// TShellExtension
QITABLE_BEGIN(TShellExtension)
     QITABENT(TShellExtension, IShellExtInit),              // IID_IShellExtInit
     QITABENT(TShellExtension, IContextMenu),               // IID_IContextMenu
     QITABENT(TShellExtension, IShellPropSheetExt),         // IID_IShellPropSheetExt
     QITABENT(TShellExtension, IDsFolderProperties),        // IID_IDsFolderProperties
     QITABENT(TShellExtension, IDsPrinterProperties),       // IID_IDsPrinterProperties
     QITABENT(TShellExtension, IFindPrinter),               // IID_IFindPrinter
     QITABENT(TShellExtension, IPhysicalLocation),          // IID_IPhysicalLocation
     QITABENT(TShellExtension, IPrnStream),                 // IID_IPrnStream
     QITABENT(TShellExtension, IStream),                    // IID_IStream
     QITABENT(TShellExtension, IPrintUIServices),           // IID_IPrintUIServices
QITABLE_END()

/********************************************************************

    TClassFactory member functions

********************************************************************/

TClassFactory::
TClassFactory(
    VOID
    )
{
    InterlockedIncrement( &gcRefThisDll );
}

TClassFactory::
~TClassFactory(
    VOID
    )
{
    InterlockedDecrement( &gcRefThisDll );
}

/*++

Name:

    CreateInstance

Description:

    CreateInstance is called by the shell to create a
    shell extension object.

Arguments:

    pUnkOuter - Pointer to controlling unknown
    riid      - Reference to interface ID specifier
    ppvObj    - Pointer to location to receive interface pointer

Return Value:

    HRESULT code signifying success or failure

--*/
STDMETHODIMP
TClassFactory::
CreateInstance(
    LPUNKNOWN   pUnkOuter,
    REFIID      riid,
    LPVOID      *ppvObj
    )
{
    *ppvObj = NULL;

    //
    // Return an error code if pUnkOuter is not NULL,
    // we don't support aggregation.
    //
    if (pUnkOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    //
    // Instantiate a shell extension object.
    // ref count == 1 after construction.
    //
    TShellExtension *pShellExtension = new TShellExtension ();

    if( pShellExtension == NULL )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Get the specified interface pointer.
    //
    HRESULT hr = pShellExtension->QueryInterface( riid, ppvObj );

    //
    // Release initial reference.
    //
    pShellExtension->Release ();

    return hr;
}

/*++

Name:

    LockServer

Description:

    LockServer increments or decrements the DLL's lock count.
    Currently not implemented.

Arguments:

    fLock   - Increments or decrements the lock count.

Return Value:

    This method supports the standard return values E_FAIL,
    E_OUTOFMEMORY, and E_UNEXPECTED, as well as the following:
    S_OK The specified object was either locked ( fLock = TRUE)
    or unlocked from memory ( fLock = FALSE).

--*/
STDMETHODIMP
TClassFactory::
LockServer(
    BOOL fLock
    )
{
    return E_NOTIMPL;
}

/********************************************************************

    TShellExtension member functions

********************************************************************/

TShellExtension::
TShellExtension(
    VOID
    ):  _lpdobj( NULL ),
        _cItem( 0 ),
        _pPhysicalLocation( NULL ),
        _pLocationPropertySheet( NULL ),
        _pLocationDlg( NULL )
{
    DBGMSG( DBG_TRACE, ("TShellExtension::TShellExtension\n") );

    _szContextName[0] = 0;
    InterlockedIncrement( &gcRefThisDll );
}

TShellExtension::
~TShellExtension(
    VOID
    )
{
    DBGMSG( DBG_TRACE, ("TShellExtension::~TShellExtension\n") );

    if( _lpdobj )
    {
        _lpdobj->Release();
    }

    delete _pPhysicalLocation;
    delete _pLocationDlg;

    TLocationPropertySheetFrontEnd::Destroy( &_pLocationPropertySheet );

    InterlockedDecrement( &gcRefThisDll );
}

/*++

Name:

    Initialize

Description:

    Initialize is called by the shell to initialize a shell extension.

Arguments:

    pidlFolder - Pointer to ID list identifying parent folder
    lpdobj     - Pointer to IDataObject interface for selected object(s)
    hKeyProgId - Registry key handle

Return Value:

    HRESULT code signifying success or failure

--*/
STDMETHODIMP
TShellExtension::
Initialize(
    LPCITEMIDLIST   pidlFolder,
    LPDATAOBJECT    lpdobj,
    HKEY            hKeyProgID
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::Initialize\n" ) );

    if (_lpdobj)
    {
        _lpdobj->Release();
    }

    _lpdobj = lpdobj;

    if (_lpdobj)
    {
        _lpdobj->AddRef();

    }

    return NOERROR;
}

/*++

Name:

    QueryContextMenu

Description:

    QueryContextMenu is called before a context menu is displayed so the
    extension handler can add items to the menu.

Arguments:

    hMenu      - Context menu handle
    indexMenu  - Index for first new menu item
    idCmdFirst - Item ID for first new menu item
    idCmdLast  - Maximum menu item ID that can be used
    uFlags     - Flags, are bit field specifying in what context the shell

Return Value:

    HRESULT code signifying success or failure. If successful, the 'code'
    field specifies the number of items added to the context menu.

--*/
STDMETHODIMP
TShellExtension::
QueryContextMenu(
    HMENU hMenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::QueryContextMenu\n" ) );

    HRESULT hr = E_FAIL;

    return hr;
}

/*++

Name:

    InvokeCommand

Description:

    InvokeCommand is called when a menu item added
    by the extension handler is selected.

Arguments:

    lpcmi - Pointer to CMINVOKECOMMAND structure

Return Value:

    HRESULT code signifying success or failure

--*/
STDMETHODIMP
TShellExtension::
InvokeCommand(
    LPCMINVOKECOMMANDINFO lpcmi
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::InvokeCommand\n" ) );

    HRESULT hr = E_FAIL;

    //
    // Return an error code if we've been called programmatically.
    //
    if( !HIWORD( (ULONG_PTR)lpcmi->lpVerb ) )
    {
        //
        // Dispatch to the correct command.
        //
        switch( LOWORD( (ULONG_PTR)lpcmi->lpVerb ) )
        {
        case 1:
        default:
            hr = E_INVALIDARG;
            break;
        }
    }

        return hr;
}


/*++

Name:

    GetCommandString

Description:

    GetCommandString is called to retrieve a string of help text or a
    language-independent command string for an item added to the context
    menu.

Arguments:

    idCmd    - 0-based offset of menu item identifier
    uFlags   - Requested information type
    reserved - Pointer to reserved value (do not use)
    pszName  - Pointer to buffer to receive the string
    cchMax   - Buffer size

Return Value:

    HRESULT code signifying success or failure

--*/
STDMETHODIMP
TShellExtension::
GetCommandString(
    UINT_PTR    idCmd,
    UINT        uFlags,
    UINT        *Reserved,
    LPSTR       pszName,
    UINT        cchMax
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::GetCommandString\n" ) );

    HRESULT hr = E_INVALIDARG;

    TString strCmdString;

    switch( uFlags )
    {
    case GCS_HELPTEXT:
    case GCS_VALIDATE:
    case GCS_VERB:
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

/*++

Name:

    ContextMenuFormatToNumeric

Description:

    Converts the context menu format bit field to a numeric
    value.  The bit field is broken because CMF_NORMAL
    is definded as zero which need to be special cased.

Arguments:

    uFlags - Flags passed to QueryContextMenu()

Return Value:

    Context menu fromat enumeration.

--*/
UINT
TShellExtension::
ContextMenuFormatToNumeric(
    IN UINT uFlags
    ) const
{
    UINT ContextMenuFormat = kUnknown;

    //
    // The normal value is 0,  This is
    // so bogus, to define a bit field and
    // make one of the bits zero.
    //
    if( ( uFlags & 0x000F ) == CMF_NORMAL )
    {
        ContextMenuFormat = k_CMF_NORMAL;
    }
    else if( uFlags & CMF_VERBSONLY )
    {
        ContextMenuFormat = k_CMF_VERBSONLY;
    }
    else if( uFlags & CMF_EXPLORE )
    {
        ContextMenuFormat = k_CMF_EXPLORE;
    }
    else if( uFlags & CMF_DEFAULTONLY )
    {
        ContextMenuFormat = k_CMF_DEFAULTONLY;
    }
    else
    {
        ContextMenuFormat = kUnknown;
    }
    return ContextMenuFormat;
}

/*++

Name:

    bIsAddPrinterWizard

Description:

    bIsAddPrinterWizard checks if the object selected by this
    shell extension is actually the add printer wizard object.

Arguments:

    Nothing.

Return Value:

    TRUE object is add printer wizard, FALSE not add printer wizard.

--*/
BOOL
TShellExtension::
bIsAddPrinterWizard(
    VOID
    ) const
{
    FORMATETC fe = { (WORD)RegisterClipboardFormat( CFSTR_PRINTERGROUP ),
                     NULL,
                     DVASPECT_CONTENT,
                     -1,
                     TYMED_HGLOBAL };

    BOOL bRetval = FALSE;
    STGMEDIUM medium;
    TCHAR szFile[MAX_PATH];

    //
    // Fail the call if m_lpdobj is NULL.
    //
    if( _lpdobj && SUCCEEDED( _lpdobj->GetData( &fe, &medium ) ) )
    {
        //
        // Get the selected item name.
        //
        if( DragQueryFile( (HDROP)medium.hGlobal, 0, szFile, COUNTOF( szFile ) ) )
        {
            //
            // Check if this is the magic Add Printer Wizard shell object.
            // The check is not case sensitive.
            //
            if( !_tcscmp( szFile, gszNewObject ) )
            {
               DBGMSG( DBG_TRACE, ( "Magical Add Printer Wizard object found.\n" ) );
               bRetval = TRUE;
            }
        }

        //
        // Release the storge medium.
        //
        ReleaseStgMedium( &medium );
    }
    return bRetval;
}

/*++

Name:

    bGetContextName

Description:

    Routine to get the context name of the object in the shell.
    This routine will work properly with the remote printers folder.

Arguments:

    Nothing.

Return Value:

    TRUE context menu name retrieved and stored in the _szContextName
    buffer.  FLASE if name not retrieved.

--*/
BOOL
TShellExtension::
bGetContextName(
    VOID
    )
{
    FORMATETC fe = { (WORD)RegisterClipboardFormat( CFSTR_SHELLIDLIST ),
                     NULL,
                     DVASPECT_CONTENT,
                     -1,
                     TYMED_HGLOBAL };

    BOOL bRetval = FALSE;
    STGMEDIUM medium;

    //
    // Fail the call if m_lpdobj is NULL.
    //
    if( _lpdobj && SUCCEEDED( _lpdobj->GetData( &fe, &medium ) ) )
    {
        if (medium.hGlobal)
        {
            LPIDA pIDA = (LPIDA)medium.hGlobal;

            //
            // Save the item count.
            //
            _cItem = pIDA->cidl;

            LPCITEMIDLIST pidlContainer = (LPCITEMIDLIST)((LPBYTE)pIDA + pIDA->aoffset[0]);
            LPCITEMIDLIST pidl          = (LPCITEMIDLIST)((LPBYTE)pIDA + pIDA->aoffset[1]);

            //
            // Get the printer object context name.  Note: A remote printers
            // folder object needs the full context information on the object.
            // i.e. \\server_name\printer_name
            //
            if( bGetDisplayName( pidlContainer, pidl, _szContextName, COUNTOF( _szContextName ) ) )
            {
                DBGMSG( DBG_TRACE, ( "Context Name " TSTR "\n", _szContextName ) );
                bRetval = TRUE;
            }
        }

        //
        // Release the medium storage.
        //
        ReleaseStgMedium (&medium);
    }

    return bRetval;
}

/*++

Name:

    bGetDisplayName

Description:

    Routine to get the context name of the object in the shell.
    This routine will work properly with the remote printers folder.

Arguments:

    pidlContainer   - pidle of containter,
    pidl            - relative pidle passed by shell,
    pszDisplayName  - pointer to display name buffer,
    cchSize         - size in characters of display name buffer.

Return Value:

    TRUE display name fill into provided display name buffer.
    FLASE if display name was not returned in buffer.

--*/
BOOL
TShellExtension::
bGetDisplayName(
    LPCITEMIDLIST   pidlContainer,
    LPCITEMIDLIST   pidl,
    LPTSTR          pszDisplayName,
    UINT            cchSize
    )
{
    HRESULT         hres;
    LPSHELLFOLDER   psfDesktop;
    LPSHELLFOLDER   psf;

    if( !pidlContainer || !pidl )
    {
        DBGMSG( DBG_TRACE, ( "NULL pidl as argument\n" ) );
        return FALSE;
    }

    hres = SHGetDesktopFolder(&psfDesktop);

    if (SUCCEEDED(hres))
    {
        hres = psfDesktop->BindToObject(pidlContainer, NULL, IID_IShellFolder, (PVOID*)&psf);

        if (SUCCEEDED(hres))
        {
            STRRET str;

            hres = psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str);

            if (SUCCEEDED(hres))
            {
                if( str.uType == STRRET_WSTR )
                {
                    _tcsncpy( pszDisplayName, (LPTSTR)str.pOleStr, cchSize-1 );

                    //
                    // Since this string was alocated from the IMalloc heap
                    // we must free it to the same place.
                    //
                    IMalloc *pMalloc;
                    hres = CoGetMalloc( 1,  &pMalloc );
                    if( SUCCEEDED(hres))
                    {
                        pMalloc->Free( str.pOleStr );
                        pMalloc->Release();
                    }
                }

                else if( str.uType == STRRET_CSTR )
                {
                    _tcsncpy( pszDisplayName, (LPTSTR)str.cStr, cchSize-1 );
                }
            }

            psf->Release();
        }

        psfDesktop->Release();

    }

    return SUCCEEDED(hres) ? TRUE : FALSE;

}

/*++

Name:

    AddPages

Description:

    AddPages is called by the shell to give property sheet shell extensions
    the opportunity to add pages to a property sheet before it is displayed.

Arguments:

    lpfnAddPage - Pointer to function called to add a page
    lParam      - lParam parameter to be passed to lpfnAddPage

Return Value:

    HRESULT code signifying success or failure

--*/
STDMETHODIMP
TShellExtension::
AddPages(
    LPFNADDPROPSHEETPAGE    lpfnAddPage,
    LPARAM                  lParam
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::AddPages\n" ) );

    return TLocationPropertySheetFrontEnd::Create( &_pLocationPropertySheet, this, _lpdobj, lpfnAddPage, lParam );
}

/*++

Name:

    ReplacePage

Description:

    ReplacePage is called by the shell to give control panel extensions the
    opportunity to replace control panel property sheet pages. It is never
    called for conventional property sheet extensions, so we simply return
    a failure code if called.

Arguments:

    uPageID         - Page to replace
    lpfnReplaceWith - Pointer to function called to replace a page
    lParam          - lParam parameter to be passed to lpfnReplaceWith

Return Value:

    HRESULT code signifying success or failure

--*/
STDMETHODIMP
TShellExtension::
ReplacePage(
    UINT                    uPageID,
    LPFNADDPROPSHEETPAGE    lpfnReplaceWith,
    LPARAM                  lParam
    )
{
    return E_NOTIMPL;
}

/*++

Name:

    ShowProperties

Description:

    This is a private interface used to override the "Properties" verb
    displayed in the DS client UI.

Arguments:

    hwndParent  - Window handle of the calling window.

    pDataObject - Pointer to an IDataObject from the DS name client UI.


Return Value:

    S_FALSE no UI was displayed the the caller should display properties

--*/
STDMETHODIMP
TShellExtension::
ShowProperties(
    IN HWND         hwndParent,
    IN IDataObject *pDataObject
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::ShowProperties\n" ) );

    BOOL bDisplayed = FALSE;

    HRESULT hr = S_OK;

    DWORD dwStatus = dwPrinterPropPages( hwndParent, pDataObject, &bDisplayed );

    if( dwStatus != ERROR_SUCCESS )
    {
        if( !bDisplayed )
        {
            //
            // Display an error message indicating that properties cannot be displayed.
            //
            iMessage( hwndParent,
                      IDS_ERR_PRINTER_PROP_TITLE,
                      IDS_ERR_PRINTER_PROP_NONE,
                      MB_OK|MB_ICONSTOP,
                      kMsgNone,
                      NULL );
        }

        hr = E_FAIL;
    }

    return hr;
}

/*++

Name:

    ShowProperties

Description:

    This is a private interface used to override the "Properties" verb
    displayed in the DS client UI.

Arguments:

    hwndParent  - Window handle of the calling window.

    pszObjectProperties - Pointer to either DS path or Unc Name


Return Value:

    S_FALSE no UI was displayed the the caller should display properties

--*/
STDMETHODIMP
TShellExtension::
ShowProperties(
    IN HWND         hwndParent,
    IN LPCTSTR      pszObjectPath,
    IN PBOOL        pbDisplayed
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::ShowProperties\n" ) );

    HRESULT hr = S_OK;

    if( dwPrinterPropPages( hwndParent, pszObjectPath, pbDisplayed ) != ERROR_SUCCESS )
    {
        hr = E_FAIL;
    }

    return hr;
}

/*++

Name:

    FindPrinter

Description:

    This is a private interface used to find a printer either in the
    DS or on the network.

Arguments:

    hwndParent  - Window handle of the calling window.
    pszBuffer   - pointer to buffer where to store returned printer name.
    puSize      - input points to the size of the provided buffer in characters,
                  on return points to the size of the returned printer name.

Return Value:

    S_OK printer was found and buffer contains the returned name.

--*/
STDMETHODIMP
TShellExtension::
FindPrinter(
    IN      HWND     hwndParent,
    IN OUT  LPTSTR   pszBuffer,
    IN      UINT     *puSize
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::ShowProperties\n" ) );

    HRESULT hr = E_FAIL;

    if( bPrinterSetup( hwndParent, MSP_FINDPRINTER, *puSize, pszBuffer, puSize, NULL ) )
    {
        hr = S_OK;
    }
    else if( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*++

Name:

    DiscoverPhysicalLocation

Description:

    This routine is used to start the physical location discovery
    process.  The physical location discovery process will potentialy
    issue network calls which can take a large amount of time.
    Users of the IPhysicalLocation interface are required to call this
    method before getting the physical Location string, using
    GetPhyscialLocation.

Arguments:

    none.

Return Value:

    S_OK printer location was discovered, error code if the discovery
    process failed or a physical location string was not found.

--*/
STDMETHODIMP
TShellExtension::
DiscoverPhysicalLocation(
    VOID
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the physical location object if this is the first call.
    //
    if (!_pPhysicalLocation)
    {
        _pPhysicalLocation = new TPhysicalLocation;
    }

    //
    // Invoke the discover method if the physical location
    // object was create successfully.
    //
    if (VALID_PTR(_pPhysicalLocation))
    {
        hr = _pPhysicalLocation->Discover() ? S_OK : E_FAIL;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:

    GetExactPhysicalLocation

Description:

    This routine gets the physical location string of this machine.  Callers
    of this interface are required to call DiscoverPhysicalLocation prior to
    calling this method or this method will fail.

Arguments:

    pbsLocation - Contains a pointer to a BSTR where to return the location string.

Return Value:

    S_OK physical location was discovered, error code if the discovery
    process failed or a physical location string was not found.

--*/
STDMETHODIMP
TShellExtension::
GetExactPhysicalLocation(
    IN OUT BSTR *pbsLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::GetExactPhysicalLocation.\n" ) );

    HRESULT hr = E_FAIL;

    //
    // Was Discover called, is object initialized?
    //
    if (_pPhysicalLocation)
    {
        TString strLocation;

        //
        // Get the physical location search string.
        //
        hr = _pPhysicalLocation->GetExact( strLocation ) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            //
            // Allocate the location string.
            //
            *pbsLocation = SysAllocString( strLocation );

            hr = (*pbsLocation) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;

}

/*++

Name:

    GetSearchPhysicalLocation

Description:

    This routine gets the best physical location search string for this machine.
    Users of this interface are required to call DiscoverPhysicalLocation
    prior to calling this method or this method will fail.

Arguments:

    pbsLocation - Contains a pointer to a BSTR where to return the location string.

Return Value:

    S_OK physical location was discovered, error code if the discovery
    process failed or a physical location string was not found.

--*/
STDMETHODIMP
TShellExtension::
GetSearchPhysicalLocation(
    IN OUT BSTR *pbsLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::GetSearchPhysicalLocation.\n" ) );

    HRESULT hr = E_FAIL;

    //
    // Was Discover called, is object initialized?
    //
    if (_pPhysicalLocation)
    {
        TString strLocation;

        //
        // Get the physical location search string.
        //
        hr = _pPhysicalLocation->GetSearch( strLocation ) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            //
            // Allocate the location string.
            //
            *pbsLocation = SysAllocString( strLocation );

            hr = (*pbsLocation) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

/*++

Name:

    GetUserPhysicalLocation

Description:

    This routine gets the physical location string of the user object in the DS

Arguments:

    pbsLocation - Contains a pointer to a BSTR where to return the location string.

Return Value:

    S_OK physical location returned

--*/
STDMETHODIMP
TShellExtension::
GetUserPhysicalLocation(
    IN OUT BSTR *pbsLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::GetUserPhysicalLocation.\n" ) );

    HRESULT hr = E_FAIL;

    //
    // Create the physical location object if this is the first call.
    //
    if (!_pPhysicalLocation)
    {
        _pPhysicalLocation = new TPhysicalLocation;
    }

    if (VALID_PTR(_pPhysicalLocation))
    {
        TString strLocation;

        hr = _pPhysicalLocation->ReadUserLocationProperty( strLocation ) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            //
            // Allocate the location string.
            //
            *pbsLocation = SysAllocString( strLocation );

            hr = (*pbsLocation) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:

    GetMachinePhysicalLocation

Description:

    This routine gets the physical location string of this machine.  The physical
    location string of this object may come from either group policy or the DS.

Arguments:

    pbsLocation - Contains a pointer to a BSTR where to return the location string.

Return Value:

    S_OK physical location returned

--*/
STDMETHODIMP
TShellExtension::
GetMachinePhysicalLocation(
    IN OUT BSTR *pbsLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::GetMachinePhysicalLocation.\n" ) );

    HRESULT hr = E_FAIL;

    //
    // Create the physical location object if this is the first call.
    //
    if (!_pPhysicalLocation)
    {
        _pPhysicalLocation = new TPhysicalLocation;
    }

    if (VALID_PTR( _pPhysicalLocation ))
    {
        TString strLocation;

        //
        // First try the policy location.
        //
        hr = _pPhysicalLocation->ReadGroupPolicyLocationSetting( strLocation ) ? S_OK : E_FAIL;

        //
        // If the policy location was not found look in the DS.
        //
        if (FAILED(hr))
        {
            hr = _pPhysicalLocation->ReadMachinesLocationProperty( strLocation ) ? S_OK : E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            //
            // Allocate the location string.
            //
            *pbsLocation = SysAllocString( strLocation );

            hr = (*pbsLocation) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*++

Name:

    GetSubnetPhysicalLocation

Description:

    This routine gets the physical location string of the subnet object that closely
    matches this the subnet this machine is currently using.

Arguments:

    pbsLocation - Contains a pointer to a BSTR where to return the location string.

Return Value:

    S_OK physical location returned

--*/
STDMETHODIMP
TShellExtension::
GetSubnetPhysicalLocation(
    IN OUT BSTR *pbsLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::GetSubnetPhysicalLocation.\n" ) );

    HRESULT hr = E_FAIL;

    //
    // Create the physical location object if this is the first call.
    //
    if (!_pPhysicalLocation)
    {
        _pPhysicalLocation = new TPhysicalLocation;
    }

    if (VALID_PTR( _pPhysicalLocation ))
    {
        TString strLocation;

        hr = _pPhysicalLocation->ReadSubnetLocationProperty( strLocation ) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            //
            // Allocate the location string.
            //
            *pbsLocation = SysAllocString( strLocation );

            hr = (*pbsLocation) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:

    GetSitePhysicalLocation

Description:

    This routine gets the physical location string of the size this machine
    belongs to.

Arguments:

    pbsLocation - Contains a pointer to a BSTR where to return the location string.

Return Value:

    S_OK physical location returned

--*/
STDMETHODIMP
TShellExtension::
GetSitePhysicalLocation(
    IN OUT BSTR *pbsLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::GetSitePhysicalLocation.\n" ) );

    HRESULT hr = E_FAIL;

    //
    // Create the physical location object if this is the first call.
    //
    if (!_pPhysicalLocation)
    {
        _pPhysicalLocation = new TPhysicalLocation;
    }

    if (VALID_PTR( _pPhysicalLocation ))
    {
        TString strLocation;

        hr = _pPhysicalLocation->ReadSiteLocationProperty( strLocation ) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            //
            // Allocate the location string.
            //
            *pbsLocation = SysAllocString( strLocation );

            hr = (*pbsLocation) ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:

    BrowseForLocation

Description:

    Displays UI for selecting a slash-delimited location name from among those
    specified by the DS admin for subnet objects

Arguments:

    hParent     - HWND to use as parent of dialog window
    bsDefault  - location name to for initial tree expansion/selection
    pbsLocation - Receives selected location name

Return Value:

    S_OK location returned

Notes:

--*/

STDMETHODIMP
TShellExtension::
BrowseForLocation(
    IN HWND hParent,
    IN BSTR bsDefault,
    IN OUT BSTR *pbsLocation
    )
{
    DBGMSG( DBG_TRACE, ( "TShellExtension::BrowseLocation.\n" ) );

    TStatusB    bStatus;
    HRESULT     hr      = E_FAIL;

    //
    // Create the dialog object if this is the first call.
    //
    if (!_pLocationDlg)
    {
        _pLocationDlg = new TFindLocDlg;
    }

    //
    // Check if the location dialog is valid.
    //
    bStatus DBGNOCHK = VALID_PTR( _pLocationDlg );

    if( bStatus )
    {
        TString strLocation;
        TString strDefault;

        bStatus DBGCHK = strDefault.bUpdate( bsDefault );

        hr = _pLocationDlg->bDoModal( hParent, &strDefault ) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            hr = _pLocationDlg->bGetLocation( strLocation ) ? S_OK : E_FAIL;

            if (SUCCEEDED(hr))
            {
                //
                // Allocate the location string.
                //
                *pbsLocation = SysAllocString( strLocation );

                hr = (*pbsLocation) ? S_OK : E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*++

Name:
    TShellExtension::ShowPhysicalLocationUI

Description:
    Determine if Location Lite is enabled for this machine


Arguments:
    None

Return Value:
S_OK if enabled

Notes:


--*/

STDMETHODIMP
TShellExtension::
ShowPhysicalLocationUI(
    VOID
    )
{
    HRESULT hr = E_FAIL;

    //
    // Create the physical location object if this is the first call.
    //
    if (!_pPhysicalLocation)
    {
        _pPhysicalLocation = new TPhysicalLocation;
    }

    if (VALID_PTR(_pPhysicalLocation))
    {
        hr = _pPhysicalLocation->bLocationEnabled() ? S_OK : E_FAIL;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*++

Name:
    TShellExtension::CheckToCreateStreams

Description:

    Check to create m_spPrnStream & m_spStream

Arguments:

    None

Return Value:

    S_OK if succeeded

--*/
HRESULT 
TShellExtension::
CheckToCreateStreams(
    VOID
    )
{
    HRESULT hr = S_OK;

    if( !m_spPrnStream || !m_spStream )
    {
        // release the smart pointers first
        m_spPrnStream = NULL;
        m_spStream = NULL;

        // call into winspool.drv to create an instance
        hr = Winspool_CreateInstance(IID_IPrnStream, m_spPrnStream.GetPPV());

        if( SUCCEEDED(hr) )
        {
            hr = m_spPrnStream->QueryInterface(IID_IStream, m_spStream.GetPPV());
        }
    }

    return ((m_spPrnStream && m_spStream) ? hr : E_FAIL);
}

/*++

Name:
    TShellExtension::BindPrinterAndFile

Description:

    Creates a PrnStream object if it don't exists and bind it to a printer and a file

Arguments:

    printer name
    file name

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TShellExtension::
BindPrinterAndFile(
    IN LPCTSTR pszPrinter,
    IN LPCTSTR pszFile
    )
{
    HRESULT hr = E_FAIL;
    if( SUCCEEDED(hr = CheckToCreateStreams()) )
    {
        return m_spPrnStream->BindPrinterAndFile(pszPrinter, pszFile);
    }
    return hr;
}

/*++

Name:
    TShellExtension::StorePrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke StorePrinterInfo

Arguments:

    flags that specifies what settings to store

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TShellExtension::
StorePrinterInfo(
    IN DWORD   Flag
    )
{
    HRESULT hr = E_FAIL;
    if( SUCCEEDED(hr = CheckToCreateStreams()) )
    {
        return m_spPrnStream->StorePrinterInfo(Flag);
    }
    return hr;
}

/*++

Name:
    TShellExtension::RestorePrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke RestorePrinterInfo

Arguments:

    flags that specifies what settings to restore

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TShellExtension::
RestorePrinterInfo(
    IN DWORD   Flag
    )
{
    HRESULT hr = E_FAIL;
    if( SUCCEEDED(hr = CheckToCreateStreams()) )
    {
        return m_spPrnStream->RestorePrinterInfo(Flag);
    }
    return hr;
}

/*++

Name:
    TShellExtension::QueryPrinterInfo

Description:

    Creates a PrnStream object if it don't exists and invoke QueryPrinterInfo

Arguments:

    flags that specifies what settings to query

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TShellExtension::
QueryPrinterInfo(
    IN  PrinterPersistentQueryFlag   Flag,
    OUT PersistentInfo              *pPrstInfo
    )
{
    HRESULT hr = E_FAIL;
    if( SUCCEEDED(hr = CheckToCreateStreams()) )
    {
        return m_spPrnStream->QueryPrinterInfo(Flag, pPrstInfo);
    }
    return hr;
}

/*++

Name:
    TShellExtension::Read

Description:

    Creates a PrnStream object if it don't exists and invoke Read

Arguments:

    pv  -   The buffer that the bytes are read into
    cb  -   The offset in the stream to begin reading from.
    pcbRead -   The number of bytes to read

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TShellExtension::
Read(
    VOID * pv,
    ULONG cb,
    ULONG * pcbRead
    )
{
    HRESULT hr = E_FAIL;
    if( SUCCEEDED(hr = CheckToCreateStreams()) )
    {
        return m_spStream->Read(pv, cb, pcbRead);
    }
    return hr;
}

/*++

Name:
    TShellExtension::Write

Description:

    Creates a PrnStream object if it don't exists and invoke Write

Arguments:

    pv  -   The buffer to write from.
    cb  -   The offset in the array to begin writing from
    pcbRead -   The number of bytes to write

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TShellExtension::
Write(
    VOID const* pv,
    ULONG cb,
    ULONG * pcbWritten
    )
{
    HRESULT hr = E_FAIL;
    if( SUCCEEDED(hr = CheckToCreateStreams()) )
    {
        return m_spStream->Write(pv, cb, pcbWritten);
    }
    return hr;
}


/*++

Name:
    TShellExtension::Seek

Description:

    Creates a PrnStream object if it don't exists and invoke Seek

Arguments:

    dlibMove        -   The offset relative to dwOrigin
    dwOrigin        -   The origin of the offset
    plibNewPosition -   Pointer to value of the new seek pointer from the beginning of the stream

Return Value:

    S_OK if succeeded

--*/
STDMETHODIMP
TShellExtension::
Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER * plibNewPosition
    )
{
    HRESULT hr = E_FAIL;
    if( SUCCEEDED(hr = CheckToCreateStreams()) )
    {
        return m_spStream->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    return hr;
}

/*++

Name:
    TShellExtension::SetSize

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
SetSize(
     ULARGE_INTEGER nSize
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::CopyTo

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
CopyTo(
    LPSTREAM pStrm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER * pcbRead,
    ULARGE_INTEGER * pcbWritten
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::Commit

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
Commit(
    IN DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::Revert

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
Revert(
    VOID
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::LockRegion

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
LockRegion(
    ULARGE_INTEGER cbOffset,
    ULARGE_INTEGER cbLength,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::UnlockRegion

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
UnlockRegion(
    ULARGE_INTEGER cbOffset,
    ULARGE_INTEGER cbLength,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::Stat

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
Stat(
    STATSTG * pStatStg,
    DWORD dwFlags
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::Clone

Description:

Arguments:

Return Value:

    E_NOTIMPL

--*/
STDMETHODIMP
TShellExtension::
Clone(
    LPSTREAM * ppStrm
    )
{
    return E_NOTIMPL;
}

/*++

Name:
    TShellExtension::GenerateShareName

Description:

Arguments:
    lpszServer      - print server name
    lpszBaseName    - base name to start from
    lpszOut         - where to return the generated name
    cchMaxChars     - buffer size in characters

Return Value:

    S_OK on success or OLE error otherwise

--*/
STDMETHODIMP
TShellExtension::
GenerateShareName(
    LPCTSTR lpszServer, 
    LPCTSTR lpszBaseName, 
    LPTSTR lpszOut, 
    int cchMaxChars
    )
{
    HRESULT hr = E_INVALIDARG;

    // lpszServer can be NULL to specify the local server, 
    // but lpszBaseName & lpszOut shouldn't be.
    if( lpszBaseName && lpszOut )
    {
        TPrtShare prtShare(lpszServer);

        TString strShareName, strBaseName;
        strBaseName.bUpdate(lpszBaseName);

        if( VALID_OBJ(prtShare) && VALID_OBJ(strBaseName) &&
            prtShare.bNewShareName(strShareName, strBaseName) && strShareName.uLen() )
        {
            lstrcpyn(lpszOut, strShareName, cchMaxChars);
            hr = (0 == lstrcmp(lpszOut, strShareName)) ? S_OK : 
                HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\thread.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998
All rights reserved

Module Name:

    thread.cxx

Abstract:

    Contains the worker thread for the Connect To browsing dialog.
    This is a secondary thread spun off to call the spooler
    enumerate-printer APIs.
    EnumPrinters frequently takes a long time to return, especially
    across the network, so calling it on a separate thread enables
    the window to be painted without delays.

    There is a common data structure between the main thread and this
    worker thread, pBrowseDlgData, defined in browse.h.

Author:

    Created by AndrewBe on 1 Dec 1992
    Steve Kiraly (SteveKi) 1 May 1998
    Lazar Ivanov (LazarI) Jun-2000 (Win64 fixes)

Environment:

    User Mode -Win32

Revision History:

    1 May 1998 moved from winspool.drv to printui.dll

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "browse.hxx"
#include "thread.hxx"

#if DBG
//#define DBG_THREADINFO                DBG_INFO
#define DBG_THREADINFO                  DBG_NONE
#endif

PSAVED_BUFFER_SIZE pFirstSavedBufferSize = NULL;

VOID BrowseThread( PBROWSE_DLG_DATA pBrowseDlgData )
{
    DWORD  RequestId;
    LPTSTR pEnumerateName;   /* These may get overwritten before we return   */
    PVOID  pEnumerateObject; /* in the case of BROWSE_THREAD_GET_PRINTER,    */
                             /* so make sure we take a copy.                 */

    for( ; ; )
    {
        RECEIVE_BROWSE_THREAD_REQUEST( pBrowseDlgData, RequestId,
                                       pEnumerateName, pEnumerateObject );

        DBGMSG( DBG_THREADINFO, ( "BrowseThread: Request ID = %d\n", RequestId ) );

        switch( pBrowseDlgData->RequestId )
        {
        case BROWSE_THREAD_ENUM_OBJECTS:
            BrowseThreadEnumerate( pBrowseDlgData, (PCONNECTTO_OBJECT )pEnumerateObject, pEnumerateName );
            break;

        case BROWSE_THREAD_GET_PRINTER:
            BrowseThreadGetPrinter( pBrowseDlgData,  pEnumerateName, (PPRINTER_INFO_2)pEnumerateObject );
            break;

        case BROWSE_THREAD_TERMINATE:
            BrowseThreadDelete( pBrowseDlgData );
            BrowseThreadTerminate( pBrowseDlgData );
            ExitThread( 0 );
        }
    }
}

/* BrowseThreadEnumerate
 *
 * Called to enumerate objects on a given node.
 *
 */
VOID BrowseThreadEnumerate( PBROWSE_DLG_DATA pBrowseDlgData, PCONNECTTO_OBJECT pConnectToParent, LPTSTR pParentName )
{
    DWORD             cEnum;
    DWORD             Result;

    Result = EnumConnectToObjects( pBrowseDlgData, pConnectToParent, pParentName );

    DBGMSG( DBG_TRACE, ( "Sending WM_ENUM_OBJECTS_COMPLETE; cEnum == %d\n",
                         pConnectToParent->cSubObjects ) );

    ENTER_CRITICAL( pBrowseDlgData );

    cEnum = pConnectToParent->cSubObjects;

    SEND_BROWSE_THREAD_REQUEST_COMPLETE( pBrowseDlgData,
                                         WM_ENUM_OBJECTS_COMPLETE,
                                         pConnectToParent,
                                         cEnum );

    LEAVE_CRITICAL( pBrowseDlgData );

    DBGMSG( DBG_TRACE, ( "Sent WM_ENUM_OBJECTS_COMPLETE; cEnum == %d\n",
                         pConnectToParent->cSubObjects ) );

}


/*
 *
 */
VOID BrowseThreadGetPrinter( PBROWSE_DLG_DATA pBrowseDlgData,
                             LPTSTR           pPrinterName,
                             LPPRINTER_INFO_2 pPrinterInfo )
{
    HANDLE           hPrinter = NULL;
    LPPRINTER_INFO_2 pPrinter = NULL;
    DWORD            cbPrinter = 0;
    DWORD            cbNeeded = 0;
    BOOL             OK = FALSE;

    DBGMSG( DBG_TRACE, ( "BrowseThreadGetPrinter %s\n", pPrinterName ) );

    if( OpenPrinter( pPrinterName, &hPrinter, NULL ) )
    {
        /* We don't free up this memory until the thread terminates.
         * Just leave it so we can use it the next time we're called,
         * increasing the size when necessary:
         */
        if( cbPrinter = pBrowseDlgData->cbPrinterInfo )
            pPrinter = (PPRINTER_INFO_2)AllocSplMem( cbPrinter );

        if( pPrinter || !cbPrinter )
        {
            DBGMSG( DBG_TRACE, ( "GetPrinter( %x, %d, %08x, %x )\n",
                                 hPrinter, 2, pPrinter, cbPrinter ) );

            OK = GetPrinter( hPrinter, 2, (LPBYTE)pPrinter,
                             cbPrinter, &cbNeeded );

            DBGMSG( DBG_TRACE, ( "GetPrinter( %x, %d, %08x, %x ) returned %d; cbNeeded = %x\n",
                                 hPrinter, 2, pPrinter, cbPrinter, OK, cbNeeded ) );

            if( !OK )
            {
                if( GetLastError( ) == ERROR_INSUFFICIENT_BUFFER )
                {
                    DBGMSG( DBG_TRACE, ( "ReallocSplMem( %08x, %x, %x )\n",
                                         pPrinter, cbPrinter, cbNeeded ) );

                    if( pPrinter )
                        pPrinter = (PPRINTER_INFO_2)ReallocSplMem( pPrinter, cbPrinter, cbNeeded );
                    else
                        pPrinter = (PPRINTER_INFO_2)AllocSplMem( cbNeeded );

                    if( pPrinter )
                    {
                        cbPrinter = cbNeeded;

                        DBGMSG( DBG_TRACE, ( "GetPrinter( %x, %d, %08x, %x )\n",
                                             hPrinter, 2, pPrinter, cbPrinter ) );

                        OK = GetPrinter( hPrinter, 2, (LPBYTE)pPrinter,
                                         cbPrinter, &cbNeeded );

                        DBGMSG( DBG_TRACE, ( "GetPrinter( %x, %d, %08x, %x ) returned %d; cbNeeded = %x\n",
                                             hPrinter, 2, pPrinter, cbPrinter, OK, cbNeeded ) );
                    }

                }
            }
        }

        ClosePrinter(hPrinter);
    }

    else
    {
        DBGMSG( DBG_WARNING, ( "Couldn't open "TSTR"\n", pPrinterName ) );
    }



    ENTER_CRITICAL( pBrowseDlgData );

    if( pBrowseDlgData->pPrinterInfo )
        FreeSplMem( pBrowseDlgData->pPrinterInfo );
    pBrowseDlgData->pPrinterInfo = pPrinter;
    pBrowseDlgData->cbPrinterInfo = cbPrinter;

    LEAVE_CRITICAL( pBrowseDlgData );

    SEND_BROWSE_THREAD_REQUEST_COMPLETE( pBrowseDlgData,
                                         ( OK ? WM_GET_PRINTER_COMPLETE
                                              : WM_GET_PRINTER_ERROR ),
                                         pPrinterName,
                                         ( OK ? (ULONG_PTR)pPrinter
                                              : GetLastError( ) ) );
}



/* BrowseThreadDelete
 *
 * Called to delete objects on a given node.
 *
 */
VOID BrowseThreadDelete( PBROWSE_DLG_DATA pBrowseDlgData )
{
    PCONNECTTO_OBJECT pConnectToParent;
    DWORD             ObjectsDeleted;

    DBGMSG( DBG_TRACE, ( "BrowseThreadDelete\n" ) );

    pConnectToParent = pBrowseDlgData->pConnectToData;

    if( pConnectToParent )
    {
        ENTER_CRITICAL( pBrowseDlgData );

        ObjectsDeleted = FreeConnectToObjects( &pConnectToParent->pSubObject[0],
                                               pConnectToParent->cSubObjects,
                                               pConnectToParent->cbPrinterInfo );

        pConnectToParent->pSubObject    = NULL;
        pConnectToParent->cSubObjects   = 0;
        pConnectToParent->cbPrinterInfo = 0;

        LEAVE_CRITICAL( pBrowseDlgData );
    }
}


/* BrowseThreadTerminate
 *
 * Frees up the top-level connect-to object, deletes the critical section,
 * and closes the semaphore, then frees the dialog data.
 * Note, if there are remaining enumerated objects below the top-level
 * object, they should have been freed by BrowseThreadDelete.
 */
VOID BrowseThreadTerminate( PBROWSE_DLG_DATA pBrowseDlgData )
{
    DBGMSG( DBG_TRACE, ( "BrowseThreadTerminate\n" ) );
    pBrowseDlgData->cDecRef();
}


/* EnumConnectToObjects
 *
 * Calls GetPrinterInfo (which in turn calls EnumPrinters) on the requested
 * parent node.  It allocates an initial buffer and sets up the subobject
 * fields in the supplied CONNECTTO_OBJECT structure.
 *
 * Arguments:
 *
 *     pParentName - The object on which the enumeration is to be performed.
 *         This may be a domain or server name, depending upon the proprietory
 *         network implementation.  If this value is NULL, this indicates
 *         that the top-level objects should be enumerated.
 *
 *     pConnectToParent - A pointer to a CONNECTTO_OBJECT for the parent node.
 *         The subobject and cbPrinterInfo fields will be filled in
 *         by this function.
 *
 * Return:
 *
 *     FALSE if an error occurred, otherwise TRUE.
 *
 * Author:
 *
 *     andrewbe, July 1992
 *
 */
DWORD EnumConnectToObjects( PBROWSE_DLG_DATA pBrowseDlgData, PCONNECTTO_OBJECT pConnectToParent, LPTSTR pParentName )
{
    DWORD             i, j, cReturned;
    DWORD             cbNeeded;
    DWORD             cbPrinter;
    LPPRINTER_INFO_1  pPrinter;
    LPPRINTER_INFO_1  pOrderPrinter;
    PCONNECTTO_OBJECT pConnectToChildren;
    BOOL              Success = FALSE;
    DWORD             Error = 0;

    cbPrinter = GetSavedBufferSize( pParentName, NULL );

    /* Allocate a buffer that will probably be big enough to hold
     * all the information we'll need.
     * This is so that GetPrinterInfo doesn't have to call EnumPrinters twice.
     */
    pPrinter = (PPRINTER_INFO_1)AllocSplMem( cbPrinter );

    if( pPrinter )
    {
        pPrinter = (LPPRINTER_INFO_1)GetPrinterInfo( PRINTER_ENUM_NAME | PRINTER_ENUM_REMOTE,
                                                     pParentName, 1,
                                                     (LPBYTE)pPrinter, &cbPrinter,
                                                     &cReturned, &cbNeeded, &Error );

        if( pPrinter )
        {
            /* Allocate an array of CONNECTTO_OBJECTs, one for each object returned:
             */
            if( cReturned > 0 )
            {
                pConnectToChildren = (PCONNECTTO_OBJECT)AllocSplMem( cReturned * sizeof( CONNECTTO_OBJECT ) );
                SaveBufferSize( pParentName, cbPrinter );
            }
            else
            {
                FreeSplMem( pPrinter );
                cbPrinter = 0;
                pConnectToChildren = EMPTY_CONTAINER;
            }

            if( pConnectToChildren && ( pConnectToChildren != EMPTY_CONTAINER ) )
            {
                /*
                *   Allocate a buffer to sort the printer info entries.  Once ordered
                *   copy the entries back to original area and free the buffer.
                *                                                                                                                                        *
                */
                pOrderPrinter = (PPRINTER_INFO_1)AllocSplMem( cReturned * sizeof( PRINTER_INFO_1 ) );

                if( pOrderPrinter ) {

                    pOrderPrinter[0] = pPrinter[0];        /* Copy 1st printer info */

                    for( i = 1; i < cReturned; i++ )
                    {
                        for ( j = 0; j< i; j++ )
                        {
                            if ( _wcsicmp(pPrinter[i].pDescription, pOrderPrinter[j].pDescription) < 0 )
                            {
                                memmove(&pOrderPrinter[j+1], &pOrderPrinter[j], sizeof( PRINTER_INFO_1 ) * (i-j));
                                break;
                            }
                        }
                        pOrderPrinter[j] = pPrinter[i];
                    }

                    memmove(pPrinter, pOrderPrinter, cReturned * sizeof( PRINTER_INFO_1 ));

                    FreeSplMem( pOrderPrinter );
                }

                /*
                *  Build ConnectTo array
                */
                for( i = 0; i < cReturned; i++ )
                {
                    pConnectToChildren[i].pPrinterInfo = &pPrinter[i];
                    pConnectToChildren[i].pSubObject   = NULL;
                    pConnectToChildren[i].cSubObjects  = 0;
                    pConnectToChildren[i].cbPrinterInfo = 0;
                }

                ENTER_CRITICAL( pBrowseDlgData );

                pConnectToParent->pSubObject  = pConnectToChildren;
                pConnectToParent->cSubObjects = cReturned;
                pConnectToParent->cbPrinterInfo = cbPrinter;

                LEAVE_CRITICAL( pBrowseDlgData );

                Success = TRUE;
            }
        }
    }

    SetCursor( pBrowseDlgData->hcursorWait );

    return Error;
}



/* GetPrinterInfo
 *
 * Calls EnumPrinters using the supplied parameters.
 * If the buffer is not big enough, it is reallocated,
 * and a second attempt is made.
 *
 * Returns a pointer to the buffer of printer info.
 *
 * pPrinters may be NULL, in which case *pcbPrinters must equal 0.
 *
 * andrewbe, April 1992
 */
#define MAX_RETRIES 5   /* How many times we retry if we get
                           ERROR_INSUFFICIENT_BUFFER */

LPBYTE GetPrinterInfo( IN  DWORD   Flags,
                       IN  LPTSTR  Name,
                       IN  DWORD   Level,
                       IN  LPBYTE  pPrinters,
                       OUT LPDWORD pcbPrinters,
                       OUT LPDWORD pcReturned,
                       OUT LPDWORD pcbNeeded OPTIONAL,
                       OUT LPDWORD pError OPTIONAL )
{
    DWORD  cbCurrent;
    BOOL   rc;
    DWORD  cbNeeded;
    DWORD  Error = 0;
    DWORD  Retry;

    /* cbCurrent holds our current buffer size.
     * This will change if we have to realloc:
     */
    cbCurrent = *pcbPrinters;

    DBGMSG( DBG_TRACE, ( "Calling EnumPrinters( %08x, "TSTR", %d, %08x, 0x%x )\n",
                         Flags, ( Name ? Name : TEXT("NULL") ), Level, pPrinters, cbCurrent ) );

    rc = EnumPrinters( Flags, Name, Level, pPrinters, cbCurrent,
                       &cbNeeded, pcReturned );

    DBGMSG( DBG_TRACE, ( "EnumPrinters( %08x, "TSTR", %d, %08x, 0x%x ) returned %d; cbNeeded 0x%x; cReturned 0x%x\n",
                         Flags, ( Name ? Name : TEXT("NULL") ), Level, pPrinters, cbCurrent,
                         rc, cbNeeded, *pcReturned ) );

    Retry = 1;

    while (!rc) {

        Error = GetLastError( );

        if ( Error != ERROR_INSUFFICIENT_BUFFER ||
            Retry > MAX_RETRIES ) {

            break;
        }

        /* Hopefully the error will be buffer not big enough.
         * If not, we'll have to bomb out:
         */

        /* The problem here is that, the second time we call EnumPrinters,
         * the size of buffer we need may have increased because new devices
         * have come on line, or the server that provided the list of objects
         * has updated itself.  In this case, we should try again,
         * but don't keep trying indefinitely, because something might be amiss.
         */

        DBGMSG( DBG_THREADINFO, ( "EnumPrinters failed with ERROR_INSUFFICIENT_BUFFER; buffer size = %d\nRetry #%d with buffer size = %d\n",
                                cbCurrent, Retry, cbNeeded ) );

        if( cbCurrent != 0 )
            FreeSplMem(pPrinters);

        pPrinters = (PBYTE)AllocSplMem( cbNeeded );

        if( pPrinters )
        {
            cbCurrent = cbNeeded;

            DBGMSG( DBG_THREADINFO, ( "Calling EnumPrinters( %08x, "TSTR", %d, %08x, 0x%x )\n",
                                Flags, ( Name ? Name : TEXT("NULL") ), Level, pPrinters, cbCurrent ) );


            rc = EnumPrinters( Flags, Name, Level, pPrinters, cbCurrent,
                               &cbNeeded, pcReturned );

            DBGMSG( DBG_THREADINFO, ( "EnumPrinters( %08x, "TSTR", %d, %08x, 0x%x )\nreturned %d; cbNeeded 0x%x; cReturned 0x%x\n",
                                Flags, ( Name ? Name : TEXT("NULL") ), Level, pPrinters, cbCurrent,
                                rc, cbNeeded, *pcReturned ) );
        }

        Retry++;
    }

    if( !rc )
    {
        DBGMSG( DBG_WARNING, ( "EnumPrinters failed: Error %d\n", Error ) );

        if( cbCurrent != 0 )
            FreeSplMem(pPrinters);

        pPrinters = NULL;
        cbCurrent = 0;
        *pcReturned = 0;
        Error = GetLastError( );
    }


    *pcbPrinters = cbCurrent;

    if( pError )
        *pError = Error;

    return pPrinters;
}



DWORD GetSavedBufferSize( LPTSTR             pName,
                          PSAVED_BUFFER_SIZE *ppSavedBufferSize OPTIONAL )
{
    PSAVED_BUFFER_SIZE pSavedBufferSize;

    if( !pName )
        pName = TEXT("");

    pSavedBufferSize = pFirstSavedBufferSize;

    while( pSavedBufferSize )
    {
        if( !_tcscmp( pSavedBufferSize->pName, pName ) )
        {
            if( ppSavedBufferSize )
                *ppSavedBufferSize = pSavedBufferSize;
            return pSavedBufferSize->Size;
        }

        pSavedBufferSize = pSavedBufferSize->pNext;
    }

    if( ppSavedBufferSize )
        *ppSavedBufferSize = NULL;
    return 0;
}



VOID SaveBufferSize( LPTSTR pName, DWORD Size )
{
    PSAVED_BUFFER_SIZE pSavedBufferSize;

    if( !pName )
        pName = TEXT("");

    if( GetSavedBufferSize( pName, &pSavedBufferSize ) )
    {
        if( pSavedBufferSize->Size < Size )
        {
            DBGMSG( DBG_TRACE, ( "Updating buffer size for "TSTR" from %d (0x%x) to %d (0x%x)\n",
                                 ( pName ? pName : TEXT("NULL") ), pSavedBufferSize->Size,
                                 pSavedBufferSize->Size, Size, Size ) );

            pSavedBufferSize->Size = Size;
        }
    }
    else
    {
        DBGMSG( DBG_TRACE, ( "Saving buffer size %d (0x%x) for "TSTR"\n",
                             Size, Size, ( pName ? pName : TEXT("NULL") ) ) );

        if( pSavedBufferSize = (PSAVED_BUFFER_SIZE)AllocSplMem( sizeof( SAVED_BUFFER_SIZE ) ) )
        {
            pSavedBufferSize->pName = AllocSplStr( pName );
            pSavedBufferSize->Size = Size;
            pSavedBufferSize->pNext = pFirstSavedBufferSize;
            pFirstSavedBufferSize = pSavedBufferSize;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\traynot.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    traynot.cxx

Abstract:

    tray notifications and balloon help

Author:

    Lazar Ivanov (LazarI)  25-Apr-2000

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "prids.h"
#include "spllibex.hxx"
#include "persist.hxx"
#include "rtlmir.hxx"

////////////////////////////////////////////////////////
// debugging stuff
//

#if DBG
// #define DBG_TRAYNOTIFY               DBG_INFO
#define DBG_TRAYNOTIFY                  DBG_NONE
#define DBG_PROCESSPRNNOTIFY            DBG_NONE
#define DBG_JOBNOTIFY                   DBG_NONE
#define DBG_PRNNOTIFY                   DBG_NONE
#define DBG_TRAYUPDATE                  DBG_NONE
#define DBG_BALLOON                     DBG_NONE
#define DBG_NTFYICON                    DBG_NONE
#define DBG_MENUADJUST                  DBG_NONE
#define DBG_INITDONE                    DBG_NONE
#define DBG_JOBSTATUS                   DBG_NONE
#endif

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI PrintNotifyTray_Init();
BOOL WINAPI PrintNotifyTray_Exit();
BOOL WINAPI PrintNotifyTray_SelfShutdown();

} // extern "C"

//////////////////////////////////////////////
// CTrayNotify - tray notifications class
//

QITABLE_DECLARE(CTrayNotify)
class CTrayNotify: public CUnknownMT<QITABLE_GET(CTrayNotify)>,      // MT impl. of IUnknown
                   public IFolderNotify,
                   public IPrinterChangeCallback,
                   public CSimpleWndSubclass<CTrayNotify>
{
public:
    CTrayNotify();
    ~CTrayNotify();

    //////////////////
    // IUnknown
    //
    IMPLEMENT_IUNKNOWN()

    void SetUser(LPCTSTR pszUser = NULL);       // NULL means the current user
    void Touch();                               // resets the shutdown timer
    void Resurrect();                           // resurrects the tray after shutdown has been initiated
    BOOL Initialize();                          // initialize & start listening
    BOOL Shutdown();                            // stop listening & force shutdown
    BOOL CanShutdown();                         // check if shutdown criteria is met (SHUTDOWN_TIMEOUT sec. inactivity)

    // implement CSimpleWndSubclass<...> - has to be public
    LRESULT WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    ///////////////////
    // IFolderNotify
    //
    STDMETHODIMP_(BOOL) ProcessNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName);

    ///////////////////////////
    // IPrinterChangeCallback
    //
    STDMETHODIMP PrinterChange(ULONG_PTR uCookie, DWORD dwChange, const PRINTER_NOTIFY_INFO *pInfo);

private:
    // internal stuff, enums/data types/methods/members
    enum
    {
        // possible private messages coming to our special window
        WM_PRINTTRAY_FIRST                      =   WM_APP,
        WM_PRINTTRAY_PRIVATE_MSG,               // private msg (posted data by background threads)
        WM_PRINTTRAY_REQUEST_SHUTDOWN,          // request shutdown 
        WM_PRINTTRAY_ICON_NOTIFY,               // message comming back from shell
    };

    enum
    {
        // possible update events (see _RequestUpdate), we don't really care now, 
        // but it is useful for future extensibility
        UPDATE_REQUEST_JOB_ADD,                 // lParam = prnCookie
        UPDATE_REQUEST_JOB_DELETE,              // lParam = prnCookie
        UPDATE_REQUEST_JOB_STATUS,              // lParam = prnCookie

        UPDATE_REQUEST_PRN_FIRST,
        UPDATE_REQUEST_PRN_ADD,                 // lParam = prnCookie
        UPDATE_REQUEST_PRN_DELETE,              // lParam = 0, not used
        UPDATE_REQUEST_PRN_STATUS,              // lParam = prnCookie
        UPDATE_REQUEST_PRN_RENAME,              // lParam = prnCookie
    };

    enum
    {
        ENUM_MAX_RETRY          = 5,            // max attempts to call bFolderEnumPrinters/bFolderGetPrinter
        ICON_ID                 = 1,            // our icon ID
        DEFAULT_BALLOON_TIMEOUT = 10000,        // in miliseconds
        JOB_ERROR_BITS          = (JOB_STATUS_OFFLINE|JOB_STATUS_USER_INTERVENTION|JOB_STATUS_ERROR|JOB_STATUS_PAPEROUT),
        JOB_IGNORE_BITS         = (JOB_STATUS_DELETED|JOB_STATUS_PRINTED|JOB_STATUS_COMPLETE),
    };

    enum
    {
        SHUTDOWN_TIMER_ID       = 100,          // shutdown timer ID
        //SHUTDOWN_TIMEOUT        = 3*1000,       // timeout to shutdown the tray code when the user 
        SHUTDOWN_TIMEOUT        = 30*1000,      // timeout to shutdown the tray code when the user 
                                                // is not printing - 1 min.
    };

    enum
    {
        // balloon IDs
        BALLOON_ID_JOB_FAILED   = 1,            // balloon when a job failed to print
        BALLOON_ID_JOB_PRINTED  = 2,            // balloon when a job printed
        BALLOON_ID_PRN_CREATED  = 3,            // balloon when a local printer is created
    };

    enum
    {
        MAX_PRINTER_DISPLAYNAME =   48,
        MAX_DOC_DISPLAYNAME     =   32,
    };

    enum
    {
        // message types, see MsgInfo declaration below
        msgTypePrnNotify        =   100,        // why not?
        msgTypePrnCheckDelete,
        msgTypeJobNotify,
        msgTypeJobNotifyLost,
    };

    // job info
    typedef struct
    {
        DWORD           dwID;                           // job ID
        DWORD           dwStatus;                       // job status
        TCHAR           szDocName[255];                 // document name
        SYSTEMTIME      timeSubmitted;                  // when submited
        DWORD           dwTotalPages;                   // Total number of pages
    } JobInfo;

    // define JobInfo adaptor class
    class CJobInfoAdaptor: public Alg::CDefaultAdaptor<JobInfo, DWORD>
    { 
    public: 
        static DWORD Key(const JobInfo &i) { return i.dwID; }
    };

    // CJobInfoArray definition
    typedef CSortedArray<JobInfo, DWORD, CJobInfoAdaptor> CJobInfoArray;

    // printer info
    typedef struct
    {
        TCHAR szPrinter[kPrinterBufMax];        // the printer name
        DWORD dwStatus;                         // printer status
        CJobInfoArray *pUserJobs;               // the jobs pending on this printer
        CPrintNotify *pListener;                // notifications listener
        BOOL bUserInterventionReq;              // this printer requires user intervention
    } PrinterInfo;

    // define PrinterInfo adaptor class
    class CPrinterInfoAdaptor: public Alg::CDefaultAdaptor<PrinterInfo, LPCTSTR>
    { 
    public: 
        static LPCTSTR Key(const PrinterInfo &i) { return i.szPrinter; }
        static int Compare(LPCTSTR pszK1, LPCTSTR pszK2) { return lstrcmp(pszK1, pszK2); }
    };

    // CPrnInfoArray definition
    typedef CSortedArray<PrinterInfo, LPCTSTR, CPrinterInfoAdaptor> CPrnInfoArray;

    // balloon info
    typedef struct
    {
        UINT uBalloonID;                        // balloon ID (what action to take when clicked)
        LPCTSTR pszCaption;                     // balloon caption
        LPCTSTR pszText;                        // balloon text
        LPCTSTR pszSound;                       // canonical name of a special sound (can be NULL)
        DWORD dwFlags;                          // flags (NIIF_INFO, NIIF_WARNING, NIIF_ERROR)
        UINT uTimeout;                          // timeout
    } BalloonInfo;

    // private message info
    typedef struct
    {
        int iType;                              // private message type (msgTypePrnNotifymsgTypeJobNotify, msgTypeJobNotifyLost)
        FOLDER_NOTIFY_TYPE NotifyType;          // printer notify type (kFolder* constants defined in winprtp.h)
        TCHAR szPrinter[kPrinterBufMax];        // printer name

        // job notification fields
        struct 
        {
            WORD  Type;                          // PRINTER_NOTIFY_INFO_DATA.Type
            WORD  Field;                         // PRINTER_NOTIFY_INFO_DATA.Field
            DWORD Id;                            // PRINTER_NOTIFY_INFO_DATA.Id
            DWORD dwData;                        // PRINTER_NOTIFY_INFO_DATA.NotifyData.adwData[0]
        } jn;

        // auxiliary buffer
        TCHAR szAuxName[kPrinterBufMax];        // PRINTER_NOTIFY_INFO_DATA.NotifyData.Data.pBuf or pszNewName 
    } MsgInfo;

    // internal APIs
    BOOL _InternalInit();
    void _MsgLoop();
    void _ThreadProc();
    void _ProcessPrnNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName);
    BOOL _FindPrinter(LPCTSTR pszPrinter, int *pi) const;
    BOOL _FindUserJob(DWORD dwID, const PrinterInfo &info, int *pi) const;
    UINT _LastReservedMenuID() const;
    void _AdjustMenuIDs(HMENU hMenu, UINT uIDFrom, int iAdjustment) const;
    int  _Insert(const FOLDER_PRINTER_DATA &data);
    void _Delete(int iPos);
    HRESULT _GetPrinter(LPCTSTR pszPrinter, LPBYTE *ppData, PDWORD pcReturned);
    void _CheckToUpdateUserJobs(PrinterInfo &pi, const MsgInfo &msg);
    void _CheckUserJobs(int *piUserJobs, BOOL *pbUserJobPrinting, BOOL *pbUserInterventionReq);
    void _CheckToUpdateTray(BOOL bForceUpdate, const BalloonInfo *pBalloon, BOOL bForceDelete = FALSE);
    LRESULT _ProcessUserMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _ShowMenu();
    void _ShowPrnFolder() const;
    void _ShowBalloon(UINT uBalloonID, LPCTSTR pszCaption, LPCTSTR pszText, LPCTSTR pszSound,
        DWORD dwFlags = NIIF_INFO, UINT uTimeout = DEFAULT_BALLOON_TIMEOUT);
    void _JobFailed(LPCTSTR pszPrinter, JobInfo &ji);
    void _JobPrinted(LPCTSTR pszPrinter, JobInfo &ji);
    BOOL _TimeToString(const SYSTEMTIME &time, TString *pTime) const;
    void _DoRefresh(CPrintNotify *pListener);
    void _PostPrivateMsg(const MsgInfo &msg);
    void _RequestUpdate(int iEvent, LPCTSTR pszPrinter, LPCTSTR pszAux = NULL);
    void _BalloonClicked(UINT uBalloonID) const;
    BOOL _UpdateUserJob(PrinterInfo &pi, JobInfo &ji);
    void _ShowAllActivePrinters() const;
    void _AddPrinterToCtxMenu(HMENU hMenu, int i);
    HRESULT _ProcessJobNotifications(LPCTSTR pszPrinter, DWORD dwChange, 
        const PRINTER_NOTIFY_INFO *pInfo, PrinterInfo *ppi = NULL);
    void _ResetAll();
    BOOL _IsFaxPrinter(const FOLDER_PRINTER_DATA &data);
    HRESULT _CanNotify(LPCTSTR pszPrinterName, BOOL *pbCanNotify);  

    // msg loop thread proc
    static DWORD WINAPI _ThreadProc_MsgLoop(LPVOID lpParameter);

    // the callback called on refresh
    static HRESULT WINAPI _RefreshCallback(
        LPVOID lpCookie, ULONG_PTR uCookie, DWORD dwChange, const PRINTER_NOTIFY_INFO *pInfo);

    // some inlines
    int _EncodeMenuID(int i) const { return (i + _LastReservedMenuID() + 1); }
    int _DecodeMenuID(int i) const { return (i - _LastReservedMenuID() - 1); }

    // internal members
    int m_cxSmIcon;                             // the icon size X
    int m_cySmIcon;                             // the icon size Y
    UINT m_uTrayIcon;                           // the current tray icon
    int m_iUserJobs;                            // the user jobs (need to keep track of this to update the tooltip)
    BOOL m_bInRefresh;                          // if we are in refresh
    BOOL m_bIconShown;                          // if the icon is visible or not
    UINT m_uBalloonID;                          // the ID of the last balloon shown up
    UINT m_uBalloonsCount;                      // how many balloons has been currently displayed
    CAutoHandleNT m_shEventReady;               // event to sync Initialize & Shutdown
    CAutoHandleNT m_shThread;                   // notifications thread listener
    CAutoHandleIcon m_shIconShown;              // the tray icon shown
    CAutoHandleMenu m_shCtxMenu;                // the context menu
    HANDLE m_hFolder;                           // printer's folder cache
    CFastHeap<MsgInfo> m_heapMsgCache;          // messages cache
    CPrnInfoArray m_arrWatchList;               // printers holding documents for our (the current) user
    TString m_strUser;                          // our (usually the current) user
    TString m_strLastBalloonPrinter;            // the printer name of the last balloon
    DWORD m_dwLastTimeInactive;                 // the last time since the print icon has been inactive
    BOOL m_bSelfShutdownInitiated;              // is self-shutdown initiated?
};

// QueryInterface table
QITABLE_BEGIN(CTrayNotify)
     QITABENT(CTrayNotify, IFolderNotify),      // IID_IFolderNotify
QITABLE_END()

HRESULT CTrayNotify_CreateInstance(CTrayNotify **ppObj)
{
    HRESULT hr = E_INVALIDARG;

    if( ppObj )
    {
        *ppObj = new CTrayNotify;
        hr = (*ppObj) ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}

/////////////////////////////
// globals & constants
//
#define gszTrayListenerClassName TEXT("PrintTray_Notify_WndClass")

static WORD g_JobFields[] = 
{                                               // Job Fields we want notifications for
    JOB_NOTIFY_FIELD_STATUS,                    // Status bits
    JOB_NOTIFY_FIELD_NOTIFY_NAME,               // Name of the user who should be notified
    JOB_NOTIFY_FIELD_TOTAL_PAGES,               // Total number of pages
};

static PRINTER_NOTIFY_OPTIONS_TYPE g_Notifications[2] = 
{
    {
        JOB_NOTIFY_TYPE,                        // We want notifications on print jobs
        0, 0, 0,                                // Reserved, must be zeros
        sizeof(g_JobFields)/sizeof(g_JobFields[0]), // We specified 9 fields in the JobFields array
        g_JobFields                             // Precisely which fields we want notifications for
    }
};

static const UINT g_arrIcons[] = { 0, IDI_PRINTER, IDI_PRINTER_ERROR };

static const UINT g_arrReservedMenuIDs[] = 
{ 
    IDM_TRAYNOTIFY_DEFAULT, 
    IDM_TRAYNOTIFY_PRNFOLDER, 
    IDM_TRAYNOTIFY_REFRESH,
};

/////////////////////////////
// inlines
//
inline UINT CTrayNotify::_LastReservedMenuID() const
{
    UINT uMax = 0;
    for( int i=0; i<ARRAYSIZE(g_arrReservedMenuIDs); i++ )
    {
        if( g_arrReservedMenuIDs[i] > uMax )
        {
            uMax = g_arrReservedMenuIDs[i];
        }
    }
    return uMax;
}

inline BOOL CTrayNotify::_FindPrinter(LPCTSTR pszPrinter, int *pi) const
{
    return m_arrWatchList.FindItem(pszPrinter, pi);
}

inline BOOL CTrayNotify::_FindUserJob(DWORD dwID, const PrinterInfo &info, int *pi) const
{
    return info.pUserJobs->FindItem(dwID, pi);
}

/////////////////////////////
// CTrayNotify
//

CTrayNotify::CTrayNotify()
    : m_hFolder(NULL),
      m_cxSmIcon(0),
      m_cySmIcon(0),
      m_uTrayIcon(g_arrIcons[0]),
      m_iUserJobs(0),
      m_bInRefresh(FALSE),
      m_bIconShown(FALSE),
      m_uBalloonID(0),
      m_uBalloonsCount(0),
      m_dwLastTimeInactive(GetTickCount()),
      m_bSelfShutdownInitiated(FALSE)
{
    // nothing special
    DBGMSG(DBG_TRAYNOTIFY, ("TRAYNOTIFY: CTrayNotify::CTrayNotify()\n"));
}

CTrayNotify::~CTrayNotify()
{
    ASSERT(FALSE == IsAttached());
    ASSERT(NULL == m_hFolder);
    ASSERT(0 == m_arrWatchList.Count()); 

    DBGMSG(DBG_TRAYNOTIFY, ("TRAYNOTIFY: CTrayNotify::~CTrayNotify()\n"));
}

void CTrayNotify::SetUser(LPCTSTR pszUser)
{
    TCHAR szUserName[64];
    szUserName[0] = 0;

    if( NULL == pszUser || 0 == pszUser[0] )
    {
        // set the current user
        DWORD dwSize = COUNTOF(szUserName);
        if( GetUserName(szUserName, &dwSize) )
        {
            pszUser = szUserName;
        }
    }

    m_strUser.bUpdate(pszUser);
}

void CTrayNotify::Touch()
{
    m_dwLastTimeInactive = GetTickCount();
}

void CTrayNotify::Resurrect()
{
    if( m_bSelfShutdownInitiated )
    {
        // restart the shutdown timer & reset the state
        m_bSelfShutdownInitiated = FALSE;
        SetTimer(m_hwnd, SHUTDOWN_TIMER_ID, SHUTDOWN_TIMEOUT, NULL);
    }
}

BOOL CTrayNotify::Initialize()
{
    BOOL bReturn = FALSE;

    if( 0 == m_strUser.uLen() )
    {
        // assume listening for the currently logged on user
        SetUser(NULL);
    }

    m_shEventReady = CreateEvent(NULL, FALSE, FALSE, NULL);
    if( m_shEventReady )
    {
        DWORD dwThreadId;
        m_shThread = TSafeThread::Create(NULL, 0, (LPTHREAD_START_ROUTINE)_ThreadProc_MsgLoop, this, 0, &dwThreadId);

        if( m_shThread )
        {
            // wait the background thread to kick off
            WaitForSingleObject(m_shEventReady, INFINITE);

            if( IsAttached() )
            {
                // the message loop has started successfully, request full refresh
                m_shEventReady = NULL;

                // request an initial refresh
                MsgInfo msg = { msgTypePrnNotify, kFolderUpdateAll };
                _PostPrivateMsg(msg);

                // we are fine here
                bReturn = TRUE;
            }
        }
    }

    return bReturn;
}

BOOL CTrayNotify::Shutdown()
{
    if( IsAttached() )
    {
        PostMessage(m_hwnd, WM_PRINTTRAY_REQUEST_SHUTDOWN, 0, 0);

        // wait the background thread to cleanup
        WaitForSingleObject(m_shThread, INFINITE);
        return !IsAttached();
    }
    return FALSE;
}

BOOL CTrayNotify::CanShutdown()
{
    return ( !m_bIconShown && 
             (GetTickCount() > m_dwLastTimeInactive) &&
             (GetTickCount() - m_dwLastTimeInactive) > SHUTDOWN_TIMEOUT );
}

// private worker proc to shutdown the tray
static DWORD WINAPI ShutdownTray_WorkerProc(LPVOID lpParameter)
{
    // shutdown the tray code.
    PrintNotifyTray_SelfShutdown();
    return 0;
}

// implement CSimpleWndSubclass<...>
LRESULT CTrayNotify::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
        case WM_TIMER:
            {
                switch( wParam )
                {
                    case SHUTDOWN_TIMER_ID:
                        {
                            if( CanShutdown() && !m_bSelfShutdownInitiated )
                            {
                                // the tray icon has been inactive for more than SHUTDOWN_TIMEOUT
                                // initiate shutdown
                                if( SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(ShutdownTray_WorkerProc),
                                        NULL, 0, 0, NULL, "printui.dll", 0) )
                                {
                                    m_bSelfShutdownInitiated = TRUE;
                                    KillTimer(hwnd, SHUTDOWN_TIMER_ID);
                                }
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            break;

        case WM_PRINTTRAY_REQUEST_SHUTDOWN:
            {
                // unregister the folder notifications
                ASSERT(m_hFolder);
                UnregisterPrintNotify(NULL, this, &m_hFolder);
                m_hFolder = NULL;

                // reset all listeners
                _ResetAll();

                // force to delete the tray icon
                _CheckToUpdateTray(TRUE, NULL, TRUE);

                // detach from the window
                VERIFY(Detach());

                // our object is now detached - destroy the window 
                // and post a quit msg to terminate the thread.
                DestroyWindow(hwnd);
                PostQuitMessage(0);
                return 0;
            }
            break;

        default:
            if( m_hFolder )
            {
                // do not process user msgs if shutdown is in progress
                _ProcessUserMsg(hwnd, uMsg, wParam, lParam);
            }
            break;
    }

    // allways call the default processing
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

///////////////////
// IFolderNotify
//
STDMETHODIMP_(BOOL) CTrayNotify::ProcessNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName)
{
    // !IMPORTANT!
    // this is a callback from the background threads, so
    // we've got to be very carefull about what we are doing here.
    // the easiest way to syncronize is to quickly pass a private
    // message with the notification data into the foreground thread.
    MsgInfo msg = { msgTypePrnNotify, NotifyType };

    if( pszName )
    {
        lstrcpyn(msg.szPrinter, pszName, COUNTOF(msg.szPrinter));
    }

    if( pszNewName )
    {
        // this is not NULL only for kFolderRename
        lstrcpyn(msg.szAuxName, pszNewName, COUNTOF(msg.szAuxName));
    }

    // post a private message here...
    _PostPrivateMsg(msg);

    return TRUE;
}

///////////////////////////
// IPrinterChangeCallback
//
STDMETHODIMP CTrayNotify::PrinterChange(ULONG_PTR uCookie, DWORD dwChange, const PRINTER_NOTIFY_INFO *pInfo)
{
    // !IMPORTANT!
    // this is a callback from the background threads, so
    // we've got to be very carefull about what we are doing here.
    // the easiest way to syncronize is to quickly pass a private
    // message with the notification data into the foreground thread.
    CPrintNotify *pListener = reinterpret_cast<CPrintNotify*>(uCookie);
    return (pListener ? _ProcessJobNotifications(pListener->GetPrinter(), dwChange, pInfo, NULL) : E_INVALIDARG);
}

//////////////////////////////////
// private stuff _*
//
BOOL CTrayNotify::_InternalInit()
{
    BOOL bReturn = SUCCEEDED(m_arrWatchList.Create());

    if( bReturn )
    {
        WNDCLASS WndClass;

        WndClass.style          = 0L;
        WndClass.lpfnWndProc    = (WNDPROC)&::DefWindowProc;
        WndClass.cbClsExtra     = 0;
        WndClass.cbWndExtra     = 0;
        WndClass.hInstance      = 0;
        WndClass.hIcon          = NULL;
        WndClass.hCursor        = NULL;
        WndClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
        WndClass.lpszMenuName   = NULL;
        WndClass.lpszClassName  = gszTrayListenerClassName;

        if( RegisterClass(&WndClass) ||
            ERROR_CLASS_ALREADY_EXISTS == GetLastError() )
        {
            // create the worker window
            HWND hwnd = CreateWindowEx(
                bIsBiDiLocalizedSystem() ? kExStyleRTLMirrorWnd : 0,
                gszTrayListenerClassName, NULL, 
                WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, NULL, NULL, 0, NULL);

            if( hwnd )
            {
                Attach(hwnd);
            }
        }

        if( IsAttached() )
        {
            // register for print notifications in the printer's folder cache
            if( FAILED(RegisterPrintNotify(NULL, this, &m_hFolder, NULL)) )
            {
                // it will detach automatically
                DestroyWindow(m_hwnd);
            }
            else
            {
                // initialize a timer to shutdown the listening thread if there
                // is no activity for more than SHUTDOWN_TIMEOUT
                SetTimer(m_hwnd, SHUTDOWN_TIMER_ID, SHUTDOWN_TIMEOUT, NULL);
            }
        }
    }

    return bReturn;
}

void CTrayNotify::_MsgLoop()
{
    // spin the msg loop here
    MSG msg;
    ASSERT(m_hwnd);

    while( GetMessage(&msg, NULL, 0, 0) )
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void CTrayNotify::_ThreadProc()
{
    AddRef();
    _InternalInit();

    if( m_shEventReady )
    {
        // notify the foreground thread we are about to start the msg loop
        SetEvent(m_shEventReady);
    }

    if( IsAttached() )
    {
        // spin a standard windows msg loop here
        _MsgLoop();
    }

    Release();
}

void CTrayNotify::_ProcessPrnNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName)
{
    DBGMSG(DBG_PROCESSPRNNOTIFY, ("PROCESSPRNNOTIFY: event has arrived, NotifyType=%d\n", NotifyType));
    switch( NotifyType )
    {
        case kFolderUpdate:
        case kFolderAttributes:
        case kFolderCreate:
        case kFolderUpdateAll:
            {
                CAutoPtrArray<BYTE> spBuffer;
                DWORD i, cReturned = 0;

                if( kFolderUpdateAll == NotifyType )
                {
                    // reset all listeners...
                    _ResetAll();

                    // hide the icon, as this may take some time...
                    _CheckToUpdateTray(FALSE, NULL);
                }

                if( SUCCEEDED(_GetPrinter(kFolderUpdateAll == NotifyType ? 
                                    NULL : pszName, &spBuffer, &cReturned)) )
                {
                    // walk through the printers to see if we need to add/delete/update printer(s) to our watch list.
                    PFOLDER_PRINTER_DATA pPrinters = spBuffer.GetPtrAs<PFOLDER_PRINTER_DATA>();
                    DBGMSG(DBG_PROCESSPRNNOTIFY, ("PROCESSPRNNOTIFY: create/update event, Count=%d\n", cReturned));

                    for( i=0; i<cReturned; i++ )
                    {
                        DBGMSG(DBG_PROCESSPRNNOTIFY, ("PROCESSPRNNOTIFY: process printer: "TSTR", Jobs=%d\n", 
                            DBGSTR(pPrinters[i].pName), pPrinters[i].cJobs));

                        // important!: we can't watch printers in pending deletion state because once the printer is
                        // pending deletion it goes away without prior notification (when there is no jobs to print)

                        int iPos;
                        if( _FindPrinter(pPrinters[i].pName, &iPos) )
                        {
                            //
                            // we don't want to delete the printer from the watch list when jobs count goes
                            // to zero (0 == pPrinters[i].cJobs) because we rely on job notifications to show
                            // balloons and sometimes the job notifications come AFTER the printer notifications
                            //
                            // we handle this by posting msgTypePrnCheckDelete when job gets deleted
                            // so we can monitor the printer when there are no more user jobs in the queue and
                            // then we stop watching the printer. don't change this behaviour unless you want 
                            // many things broken.
                            //

                            // printer found in the watch list
                            if( PRINTER_STATUS_PENDING_DELETION & pPrinters[i].Status )
                            {
                                // no jobs or in pending deletion state - just delete.
                                DBGMSG(DBG_PROCESSPRNNOTIFY, ("PROCESSPRNNOTIFY:[delete] watched printer with no jobs, pszPrinter="TSTR"\n", 
                                    DBGSTR(pPrinters[i].pName)));

                                _Delete(iPos);
                                _RequestUpdate(UPDATE_REQUEST_PRN_DELETE, pPrinters[i].pName);
                            }
                            else
                            {
                                if( m_arrWatchList[iPos].dwStatus != pPrinters[i].Status )
                                {
                                    // update status
                                    DBGMSG(DBG_PROCESSPRNNOTIFY, ("PROCESSPRNNOTIFY:[update] watched printer with jobs, pszPrinter="TSTR"\n", 
                                        DBGSTR(pPrinters[i].pName)));

                                    m_arrWatchList[iPos].dwStatus = pPrinters[i].Status;
                                    _RequestUpdate(UPDATE_REQUEST_PRN_STATUS, pPrinters[i].pName);
                                }
                            }
                        }
                        else
                        {
                            // printer not found in the watch list
                            if( pPrinters[i].cJobs && !(PRINTER_STATUS_PENDING_DELETION & pPrinters[i].Status) && !_IsFaxPrinter(pPrinters[i]) )
                            {
                                // start listening on this printer
                                DBGMSG(DBG_PROCESSPRNNOTIFY, ("PROCESSPRNNOTIFY:[insert] non-watched printer with jobs, pszPrinter="TSTR"\n", 
                                    DBGSTR(pPrinters[i].pName)));

                                iPos = _Insert(pPrinters[i]);
                                if( -1 != iPos )
                                {
                                    _RequestUpdate(UPDATE_REQUEST_PRN_ADD, pPrinters[i].pName);
                                }
                            }
                        }
                    }
                }
            }
            break;

        case kFolderDelete:
        case kFolderRename:
            {
                int iPos;
                if( _FindPrinter(pszName, &iPos) )
                {
                    // ranaming is a bit tricky. we need to delete & reinsert the item
                    // to keep the array sorted & then update the context menu if necessary
                    DBGMSG(DBG_PROCESSPRNNOTIFY, ("PROCESSPRNNOTIFY:[delete] watched printer deleted, pszPrinter="TSTR"\n", 
                        DBGSTR(pszName)));

                    // first delete the printer which got renamed or deleted
                    _Delete(iPos);
                    _RequestUpdate(UPDATE_REQUEST_PRN_DELETE, pszName);

                    if( kFolderRename == NotifyType )
                    {
                        // if rename, request update, so this printer can be re-added with
                        // the new name.
                        MsgInfo msg = { msgTypePrnNotify, kFolderUpdate };
                        lstrcpyn(msg.szPrinter, pszNewName, COUNTOF(msg.szPrinter));
                        _PostPrivateMsg(msg);
                    }
                }
            }
            break;

        default:
            break;
    }
}

void CTrayNotify::_AdjustMenuIDs(HMENU hMenu, UINT uIDFrom, int iAdjustment) const
{
    MENUITEMINFO mii = { sizeof(mii), MIIM_ID, 0 };
    int i, iCount = GetMenuItemCount(hMenu);

    for( i=0; i<iCount; i++ )
    {
        if( GetMenuItemInfo(hMenu, i, TRUE, &mii) && mii.wID >= uIDFrom )
        {
            DBGMSG(DBG_MENUADJUST, ("MENUADJUST: %d -> %d\n", mii.wID,
                static_cast<UINT>(static_cast<int>(mii.wID) + iAdjustment)));

            // adjust the menu item ID
            mii.wID = static_cast<UINT>(static_cast<int>(mii.wID) + iAdjustment);
            ASSERT(_DecodeMenuID(mii.wID) < m_arrWatchList.Count());

            // update menu item here
            SetMenuItemInfo(hMenu, i, TRUE, &mii);
        }
    }
}

int CTrayNotify::_Insert(const FOLDER_PRINTER_DATA &data)
{
    CAutoPtr<CJobInfoArray> spUserJobs = new CJobInfoArray;
    CAutoPtr<CPrintNotify> spListener = new CPrintNotify(this, COUNTOF(g_Notifications), g_Notifications, PRINTER_CHANGE_JOB);

    int iPos = -1;
    if( spUserJobs && SUCCEEDED(spUserJobs->Create()) && 
        spListener && SUCCEEDED(spListener->Initialize(data.pName)) )
    {
        PrinterInfo infoPrn = {0};
        infoPrn.pListener = spListener;
        infoPrn.pUserJobs = spUserJobs;
        lstrcpyn(infoPrn.szPrinter, data.pName, COUNTOF(infoPrn.szPrinter));
        infoPrn.pListener->SetCookie(reinterpret_cast<ULONG_PTR>(infoPrn.pListener));

        ASSERT(!m_arrWatchList.FindItem(infoPrn.szPrinter, &iPos));
        iPos = m_arrWatchList.SortedInsert(infoPrn);

        if( -1 != iPos )
        {
            if( m_shCtxMenu )
            {
                DBGMSG(DBG_MENUADJUST, ("MENUADJUST: insert at pos: %d, Count=%d\n", iPos, m_arrWatchList.Count()));

                // if the context menu is opened then adjust the IDs
                _AdjustMenuIDs(m_shCtxMenu, _EncodeMenuID(iPos), 1);
            }

            // start listen on this printer
            DBGMSG(DBG_PRNNOTIFY, ("PRNNOTIFY: start listen printer: "TSTR"\n", DBGSTR(data.pName)));

            // they are hooked up already, detach from the smart pointers
            spListener.Detach();
            spUserJobs.Detach();

            // do an initial refresh and start listen
            _DoRefresh(infoPrn.pListener);
            infoPrn.pListener->StartListen();
        }
    }
    return iPos;
}

void CTrayNotify::_Delete(int iPos)
{
    // stop listen on this printer
    m_arrWatchList[iPos].pListener->StopListen();
    DBGMSG(DBG_PRNNOTIFY, ("PRNNOTIFY: stop listen printer: "TSTR"\n", DBGSTR(m_arrWatchList[iPos].szPrinter)));

    delete m_arrWatchList[iPos].pListener;
    delete m_arrWatchList[iPos].pUserJobs;
    m_arrWatchList.Delete(iPos);

    DBGMSG(DBG_MENUADJUST, ("MENUADJUST: delete at pos: %d, Count=%d\n", iPos, m_arrWatchList.Count()));

    // fix the context menu
    if( m_shCtxMenu )
    {
        MENUITEMINFO mii = { sizeof(mii), MIIM_ID, 0 };
        if( GetMenuItemInfo(m_shCtxMenu, _EncodeMenuID(iPos), FALSE, &mii) )
        {
            // make sure this menu item is deleted
            VERIFY(DeleteMenu(m_shCtxMenu, _EncodeMenuID(iPos), MF_BYCOMMAND));
        }

        // if the context menu is opened then adjust the IDs
        _AdjustMenuIDs(m_shCtxMenu, _EncodeMenuID(iPos), -1);
    }
}

HRESULT CTrayNotify::_GetPrinter(LPCTSTR pszPrinter, LPBYTE *ppData, PDWORD pcReturned)
{
    ASSERT(ppData);
    ASSERT(pcReturned);
    HRESULT hr = E_OUTOFMEMORY;

    int iTry = -1;
    DWORD cbNeeded = 0;
    DWORD cReturned = 0;
    CAutoPtrArray<BYTE> pData;
    BOOL bStatus = FALSE;

    for( ;; )
    {
        if( iTry++ >= ENUM_MAX_RETRY )
        {
            // max retry count reached. this is also 
            // considered out of memory case
            pData = NULL;
            break;
        }

        // call bFolderEnumPrinters/bFolderGetPrinter...
        bStatus = pszPrinter ? 
            bFolderGetPrinter(m_hFolder, pszPrinter, pData.GetPtrAs<PFOLDER_PRINTER_DATA>(), cbNeeded, &cbNeeded) :
            bFolderEnumPrinters(m_hFolder, pData.GetPtrAs<PFOLDER_PRINTER_DATA>(), cbNeeded, &cbNeeded, pcReturned);

        if( !bStatus && ERROR_INSUFFICIENT_BUFFER == GetLastError() && cbNeeded )
        {
            // buffer too small case
            pData = new BYTE[cbNeeded];

            if( pData )
            {
                continue;
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
                break;
            }
        }

        break;
    }

    // setup the error code properly
    hr = bStatus ? S_OK : GetLastError() != ERROR_SUCCESS ? HRESULT_FROM_WIN32(GetLastError()) : 
         !pData ? E_OUTOFMEMORY : E_FAIL;

    if( SUCCEEDED(hr) )
    {
        *ppData = pData.Detach();
        if( pszPrinter )
        {
            *pcReturned = 1;
        }
    }

    return hr;
}

void CTrayNotify::_CheckToUpdateUserJobs(PrinterInfo &pi, const MsgInfo &msg)
{
    int iPos = -1;
    BOOL bJobFound = _FindUserJob(msg.jn.Id, pi, &iPos);

    // process DBG_JOBNOTIFY
    DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: pszPrinter="TSTR", szAuxName="TSTR", Field: %d, dwData: %d\n", 
        DBGSTR(pi.szPrinter), DBGSTR(msg.szAuxName), msg.jn.Field, msg.jn.dwData));

    if( JOB_NOTIFY_FIELD_NOTIFY_NAME == msg.jn.Field )
    {
        // process JOB_NOTIFY_FIELD_NOTIFY_NAME here
        DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: JOB_NOTIFY_FIELD_NOTIFY_NAME, pszPrinter="TSTR"\n", 
            DBGSTR(pi.szPrinter)));

        if( 0 == lstrcmp(msg.szAuxName, m_strUser) )
        {
            // a user job - check to insert
            if( !bJobFound )
            {
                JobInfo ji = {msg.jn.Id};
                if( _UpdateUserJob(pi, ji) && -1 != pi.pUserJobs->SortedInsert(ji) )
                {
                    _RequestUpdate(UPDATE_REQUEST_JOB_ADD, pi.szPrinter);

                    DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: job added, JobID=%d, pszPrinter="TSTR"\n", 
                        msg.jn.Id, DBGSTR(pi.szPrinter)));
                }
            }
        }
        else
        {
            // not a user job - check to delete
            if( bJobFound )
            {
                DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: job deleted, JobID=%d, pszPrinter="TSTR"\n", 
                    pi.pUserJobs->operator[](iPos).dwID, DBGSTR(pi.szPrinter)));

                pi.pUserJobs->Delete(iPos);
                _RequestUpdate(UPDATE_REQUEST_JOB_DELETE, pi.szPrinter);
            }
        }
    }

    if( bJobFound && JOB_NOTIFY_FIELD_STATUS == msg.jn.Field )
    {
        // process JOB_NOTIFY_FIELD_STATUS here
        DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: JOB_NOTIFY_FIELD_STATUS, Status=%x, pszPrinter="TSTR"\n", 
            msg.jn.dwData, DBGSTR(pi.szPrinter)));

        // update the job status bits here, by saving the old status first
        JobInfo &ji = pi.pUserJobs->operator[](iPos);
        DWORD dwOldJobStatus = ji.dwStatus;
        ji.dwStatus = msg.jn.dwData;

        do
        {
            // dump the job status
            DBGMSG(DBG_JOBSTATUS, ("JOBSTATUS: old status=%x, new status=%x\n", 
                dwOldJobStatus, ji.dwStatus));

            if( ji.dwStatus & JOB_STATUS_DELETED )
            {
                // the job status has the JOB_STATUS_DELETED bit up. delete the job.
                DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: job deleted, JobID=%x, pszPrinter="TSTR"\n", 
                    pi.pUserJobs->operator[](iPos).dwID, DBGSTR(pi.szPrinter)));

                pi.pUserJobs->Delete(iPos);
                _RequestUpdate(UPDATE_REQUEST_JOB_DELETE, pi.szPrinter);
                break; // skip everything
            }

            if( FALSE == m_bInRefresh && (0 == (dwOldJobStatus & JOB_STATUS_PRINTED)) && 
                (JOB_STATUS_PRINTED & ji.dwStatus) && (0 == (ji.dwStatus & JOB_ERROR_BITS)) )
            {
                // JOB_STATUS_PRINTED bit is up, the previous status nas no JOB_STATUS_PRINTED bit up
                // and there are no error bits up - consider the job had just printed successfully.
                DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: job completed with sucesss, JobID=%x, pszPrinter="TSTR"\n", 
                    pi.pUserJobs->operator[](iPos).dwID, DBGSTR(pi.szPrinter)));

                _JobPrinted(pi.szPrinter, ji);
            }

            if( FALSE == m_bInRefresh && (0 == (dwOldJobStatus & JOB_ERROR_BITS)) && 
                (ji.dwStatus & JOB_ERROR_BITS) )
            {
                // if the job goes from non-error state into an error state
                // then we assume the job has failed or a user intervention is 
                // required. in both cases we show the job-failed balloon.
                DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: job failed to print, JobID=%x, pszPrinter="TSTR"\n", 
                    pi.pUserJobs->operator[](iPos).dwID, DBGSTR(pi.szPrinter)));

                _JobFailed(pi.szPrinter, ji);
            }

            // just check to update the job status
            if( dwOldJobStatus != ji.dwStatus )
            {
                ji.dwStatus = msg.jn.dwData;
                _RequestUpdate(UPDATE_REQUEST_JOB_STATUS, pi.szPrinter);

                DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: status updated, Status=%x, pszPrinter="TSTR"\n", 
                    ji.dwStatus, DBGSTR(pi.szPrinter)));
            }
        } 
        while( FALSE );
    }

    if( bJobFound && JOB_NOTIFY_FIELD_TOTAL_PAGES == msg.jn.Field &&
        pi.pUserJobs->operator[](iPos).dwTotalPages != msg.jn.dwData )

    {
        // save the number of total pages, so we can display this info 
        // later in the balloon when the job completes successfully.
        pi.pUserJobs->operator[](iPos).dwTotalPages = msg.jn.dwData;

        DBGMSG(DBG_JOBNOTIFY, ("JOBNOTIFY: total pages updated, TotalPages=%x, pszPrinter="TSTR"\n", 
            pi.pUserJobs->operator[](iPos).dwTotalPages, DBGSTR(pi.szPrinter)));
    }
}

void CTrayNotify::_CheckUserJobs(int *piUserJobs, BOOL *pbUserJobPrinting, BOOL *pbUserInterventionReq)
{
    ASSERT(piUserJobs);
    ASSERT(pbUserJobPrinting);
    ASSERT(pbUserInterventionReq);

    *piUserJobs = 0;
    *pbUserJobPrinting = *pbUserInterventionReq = FALSE;

    // walk through the watch list to see...
    int i, iCount = m_arrWatchList.Count();
    for( i=0; i<iCount; i++ )
    {
        m_arrWatchList[i].bUserInterventionReq = FALSE;
        CJobInfoArray &arrJobs = *m_arrWatchList[i].pUserJobs;

        int j, iJobCount = arrJobs.Count();
        for( j=0; j<iJobCount; j++ )
        {
            DWORD dwStatus = arrJobs[j].dwStatus;

            if( 0 == (dwStatus & JOB_IGNORE_BITS) )
            {
                (*piUserJobs)++;
            }

            if( dwStatus & JOB_ERROR_BITS )
            {
                // these job status bits are considered an error
                *pbUserInterventionReq = m_arrWatchList[i].bUserInterventionReq = TRUE;
            }

            if( dwStatus & JOB_STATUS_PRINTING )
            {
                // check if the job is printing now
                *pbUserJobPrinting = TRUE;
            }
        }
    }
}

void CTrayNotify::_CheckToUpdateTray(BOOL bForceUpdate, const BalloonInfo *pBalloon, BOOL bForceDelete)
{
    int     iUserJobs;
    BOOL    bUserJobPrinting, bUserInterventionReq;
    _CheckUserJobs(&iUserJobs, &bUserJobPrinting, &bUserInterventionReq);

    DBGMSG(DBG_TRAYUPDATE, ("TRAYUPDATE: _CheckToUpdateTray called, "
                            "iUserJobs=%d, bUserJobPrinting=%d, bUserInterventionReq=%d\n",
                             iUserJobs, bUserJobPrinting, bUserInterventionReq));

    UINT uTrayIcon = g_arrIcons[ ((iUserJobs != 0) || bUserJobPrinting || (0 != m_uBalloonID) || (0 != m_uBalloonsCount)) + bUserInterventionReq ];
    NOTIFYICONDATA nid = { sizeof(nid), m_hwnd, ICON_ID, NIF_MESSAGE, WM_PRINTTRAY_ICON_NOTIFY, NULL };

    // check to delete first
    if( bForceDelete || (uTrayIcon == g_arrIcons[0] && m_uTrayIcon != g_arrIcons[0]) )
    {
        if( m_bIconShown )
        {
            Shell_NotifyIcon(NIM_DELETE, &nid);
            
            // reset the shutdown timer
            Touch(); 

            DBGMSG(DBG_NTFYICON, ("NTFYICON: icon deleted.\n"));
        }

        m_uTrayIcon = g_arrIcons[0];
        m_cxSmIcon = m_cySmIcon = m_iUserJobs = 0;
        m_bIconShown = FALSE;
    }
    else
    {
        // check to add/modify the icon
        if( uTrayIcon != g_arrIcons[0] )
        {
            BOOL bPlayBalloonSound = FALSE;
            BOOL bBalloonRequested = FALSE;

            DWORD dwMsg = (m_uTrayIcon == g_arrIcons[0]) ? NIM_ADD : NIM_MODIFY;

            int cxSmIcon = GetSystemMetrics(SM_CXSMICON);
            int cySmIcon = GetSystemMetrics(SM_CYSMICON);

            // check to sync the icon
            if( uTrayIcon != m_uTrayIcon || cxSmIcon != m_cxSmIcon || m_cySmIcon != cySmIcon )
            {
                m_cxSmIcon = cxSmIcon;
                m_cySmIcon = cySmIcon;
                m_uTrayIcon = uTrayIcon;
                m_shIconShown = (HICON)LoadImage(ghInst, MAKEINTRESOURCE(m_uTrayIcon), IMAGE_ICON, m_cxSmIcon, m_cySmIcon, 0);
                nid.uFlags |= NIF_ICON;
                nid.hIcon = m_shIconShown;
            }

            // check to sync the tip (if the ctx menu is not open)
            if( bForceUpdate || m_iUserJobs != iUserJobs )
            {
                TString strTemplate, strTooltip;
                m_iUserJobs = iUserJobs;
                if( strTemplate.bLoadString(ghInst, IDS_TOOLTIP_TRAY) && 
                    strTooltip.bFormat(strTemplate, m_iUserJobs, static_cast<LPCTSTR>(m_strUser)) )
                {
                    nid.uFlags |= NIF_TIP;

                    if( m_shCtxMenu )
                    {
                        // clear the tip
                        nid.szTip[0] = 0;
                    }
                    else
                    {
                        // update the tip
                        lstrcpyn(nid.szTip, strTooltip, COUNTOF(nid.szTip));
                    }
                }
            }

            // check to sync the balloon (if the ctx menu is not open)
            if( bForceUpdate || pBalloon )
            {
                nid.uFlags |= NIF_INFO;

                if( m_shCtxMenu || NULL == pBalloon )
                {
                    // hide the ballon
                    nid.szInfoTitle[0] = 0;
                    nid.szInfo[0] = 0;
                }
                else
                {
                    // show up the balloon
                    nid.dwInfoFlags = pBalloon->dwFlags;
                    nid.uTimeout = pBalloon->uTimeout;
                    lstrcpyn(nid.szInfoTitle, pBalloon->pszCaption, COUNTOF(nid.szInfoTitle));
                    lstrcpyn(nid.szInfo, pBalloon->pszText, COUNTOF(nid.szInfo));

                    if( pBalloon->pszSound && pBalloon->pszSound[0] )
                    {
                        nid.dwInfoFlags |= NIIF_NOSOUND;
                        bPlayBalloonSound = TRUE;
                    }

                    bBalloonRequested = TRUE;
                }
            }

            if( bForceUpdate || !m_bIconShown || nid.uFlags != NIF_MESSAGE )
            {
                // sync icon data
                Shell_NotifyIcon(dwMsg, &nid);

                if( bPlayBalloonSound )
                {
                    PlaySound(pBalloon->pszSound, NULL, 
                        SND_ALIAS | SND_APPLICATION | SND_ASYNC | SND_NODEFAULT | SND_NOSTOP);
                }

                if( bBalloonRequested )
                {
                    m_uBalloonsCount++;
                }

                if( NIM_ADD == dwMsg )
                {
                    DBGMSG(DBG_NTFYICON, ("NTFYICON: icon added.\n"));
                }
                else
                {
                    DBGMSG(DBG_NTFYICON, ("NTFYICON: icon modified.\n"));
                }

                if( NIM_ADD == dwMsg )
                {
                    // make sure we use the correct version
                    nid.uVersion = NOTIFYICON_VERSION;
                    Shell_NotifyIcon(NIM_SETVERSION, &nid);

                    DBGMSG(DBG_NTFYICON, ("NTFYICON: icon set version.\n"));
                }
            }

            m_bIconShown = TRUE;
        }
    }
}

void CTrayNotify::_ShowMenu()
{
    // no need to synchronize as m_arrWatchList size can be 
    // changed only in the message loop
    int i, iCount = m_arrWatchList.Count();

    if( iCount )
    {
        // when loaded from the resource, the context menu contains only one
        if( m_shCtxMenu )
        {
            EndMenu();
        }

        // command - "Open Active Printers" corresponding to IDM_TRAYNOTIFY_DEFAULT
        m_shCtxMenu = ShellServices::LoadPopupMenu(ghInst, POPUP_TRAYNOTIFY_PRINTERS);

        if( m_shCtxMenu )
        {
            // build the context menu here
            InsertMenu(m_shCtxMenu, (UINT)-1, MF_SEPARATOR|MF_BYPOSITION, 0, NULL);

            for( i=0; i<iCount; i++ )
            {
                if( m_arrWatchList[i].pUserJobs->Count() )
                {
                    _AddPrinterToCtxMenu(m_shCtxMenu, i);
                }
            }

            // show up the context menu
            if( GetMenuItemCount(m_shCtxMenu) )
            {
                POINT pt;
                GetCursorPos(&pt);
                SetMenuDefaultItem(m_shCtxMenu, IDM_TRAYNOTIFY_DEFAULT, MF_BYCOMMAND);
                SetForegroundWindow(m_hwnd);

                // now after m_shCtxMenu is not NULL, disable the tooltips, 
                // while the menu is open
                _CheckToUpdateTray(TRUE, NULL);

                // show up the context menu here...
                // popup menus follows it's window owner when it comes to mirroring,
                // so we should pass a an owner window which is mirrored.
                int idCmd = TrackPopupMenu(m_shCtxMenu, 
                    TPM_NONOTIFY|TPM_RETURNCMD|TPM_RIGHTBUTTON|TPM_HORNEGANIMATION, 
                    pt.x, pt.y, 0, m_hwnd, NULL);

                if( idCmd != 0 )
                {
                    switch(idCmd)
                    {
                        case IDM_TRAYNOTIFY_DEFAULT:
                            {
                                // open the queues of all active printers
                                _ShowAllActivePrinters();
                            }
                            break;

                        case IDM_TRAYNOTIFY_PRNFOLDER:
                            {
                                // open the printer's folder
                                _ShowPrnFolder();
                            }
                            break;

                        case IDM_TRAYNOTIFY_REFRESH:
                            {
                                // just refresh the whole thing...
                                MsgInfo msg = { msgTypePrnNotify, kFolderUpdateAll };
                                _PostPrivateMsg(msg);
                            }
                            break;

                        default:
                            {
                                // open the selected printer
                                vQueueCreate(NULL, m_arrWatchList[_DecodeMenuID(idCmd)].szPrinter, 
                                    SW_SHOWNORMAL, static_cast<LPARAM>(FALSE));
                            }
                            break;
                    }
                }
            }
        }

        // destroy the menu
        m_shCtxMenu = NULL;

        // re-enable the tooltips after the menu is closed
        _CheckToUpdateTray(TRUE, NULL);
    }
}

void CTrayNotify::_ShowPrnFolder() const
{
    // find the printer's folder PIDL
    CAutoPtrPIDL pidlPrinters;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_PRINTERS, &pidlPrinters);

    if( SUCCEEDED(hr) )
    {
        // invoke ShellExecuteEx on that PIDL
        SHELLEXECUTEINFO seInfo;
        memset(&seInfo, 0, sizeof(seInfo));

        seInfo.cbSize = sizeof(seInfo);
        seInfo.fMask = SEE_MASK_IDLIST;
        seInfo.hwnd = m_hwnd;
        seInfo.nShow = SW_SHOWDEFAULT;
        seInfo.lpIDList = pidlPrinters;

        ShellExecuteEx(&seInfo);
    }
}

void CTrayNotify::_ShowBalloon(
    UINT uBalloonID,
    LPCTSTR pszCaption, 
    LPCTSTR pszText, 
    LPCTSTR pszSound,
    DWORD dwFlags,
    UINT uTimeout)
{
    // just show up the balloon...
    m_uBalloonID = uBalloonID;
    BalloonInfo bi = {m_uBalloonID, pszCaption, pszText, pszSound, dwFlags, uTimeout};
    _CheckToUpdateTray(FALSE, &bi);
}

void CTrayNotify::_JobFailed(LPCTSTR pszPrinter, JobInfo &ji)
{
    ASSERT(pszPrinter);

    // since the baloon text length is limited to 255 characters we need to abbreviate the printer name
    // and the document name if they are too long by adding ellipses at the end. 
    TString strPrinter, strDocName;
    if( SUCCEEDED(AbbreviateText(pszPrinter, MAX_PRINTER_DISPLAYNAME, &strPrinter)) &&
        SUCCEEDED(AbbreviateText(ji.szDocName, MAX_DOC_DISPLAYNAME, &strDocName)) )
    {
        TString strTimeSubmitted, strTemplate, strTitle, strText;

        TStatusB bStatus;
        bStatus DBGCHK = (ji.dwStatus & JOB_STATUS_PAPEROUT) ? 
            strTitle.bLoadString(ghInst, IDS_BALLOON_TITLE_JOB_FAILED_OOP) :
            strTitle.bLoadString(ghInst, IDS_BALLOON_TITLE_JOB_FAILED);

        if( bStatus && 
            _TimeToString(ji.timeSubmitted, &strTimeSubmitted) &&
            strTemplate.bLoadString(ghInst, IDS_BALLOON_TEXT_JOB_FAILED) &&
            strText.bFormat(strTemplate, 
                static_cast<LPCTSTR>(strDocName),
                static_cast<LPCTSTR>(strPrinter), 
                static_cast<LPCTSTR>(strTimeSubmitted)) )
        {
            _ShowBalloon(BALLOON_ID_JOB_FAILED, strTitle, strText, NULL, NIIF_WARNING);
            m_strLastBalloonPrinter.bUpdate(pszPrinter);
        }
    }
}

void CTrayNotify::_JobPrinted(LPCTSTR pszPrinter, JobInfo &ji)
{
    ASSERT(pszPrinter);

    // since the baloon text length is limited to 255 characters we need to abbreviate the printer name
    // and the document name if they are too long, by adding ellipses at the end. 
    TString strPrinter, strDocName;
    if( SUCCEEDED(AbbreviateText(pszPrinter, MAX_PRINTER_DISPLAYNAME, &strPrinter)) &&
        SUCCEEDED(AbbreviateText(ji.szDocName, MAX_DOC_DISPLAYNAME, &strDocName)) )
    {
        BOOL bCanNotify;
        TString strTimeSubmitted, strTemplate, strTitle, strText;

        // total pages can be zero when a downlevel document is printed (directly to the port) in 
        // this case StartDoc/EndDoc are not called and the spooler doesn't know the total pages of 
        // the document. in this case just display the balloon without total pages info.
        UINT uTextID = ji.dwTotalPages ? IDS_BALLOON_TEXT_JOB_PRINTED : IDS_BALLOON_TEXT_JOB_PRINTED_NOPAGES;

        if( SUCCEEDED(_CanNotify(pszPrinter, &bCanNotify)) && bCanNotify &&
            _TimeToString(ji.timeSubmitted, &strTimeSubmitted) &&
            strTitle.bLoadString(ghInst, IDS_BALLOON_TITLE_JOB_PRINTED) && 
            strTemplate.bLoadString(ghInst, uTextID) &&
            strText.bFormat(strTemplate, 
                static_cast<LPCTSTR>(strDocName),
                static_cast<LPCTSTR>(strPrinter), 
                static_cast<LPCTSTR>(strTimeSubmitted), 
                ji.dwTotalPages) )
        {
            _ShowBalloon(BALLOON_ID_JOB_PRINTED, strTitle, strText, gszBalloonSoundPrintComplete, NIIF_INFO);
            m_strLastBalloonPrinter.bUpdate(pszPrinter);
        }
    }
}

BOOL CTrayNotify::_TimeToString(const SYSTEMTIME &time, TString *pTime) const
{
    ASSERT(pTime);

    BOOL bReturn = FALSE;
    TCHAR szText[255];
    SYSTEMTIME timeLocal;

    if( SystemTimeToTzSpecificLocalTime(NULL, const_cast<LPSYSTEMTIME>(&time), &timeLocal) &&
        GetTimeFormat(LOCALE_USER_DEFAULT, 0, &timeLocal, NULL, szText, COUNTOF(szText)) )
    {
        pTime->bCat(szText);
        pTime->bCat(TEXT("  "));

        if( GetDateFormat(LOCALE_USER_DEFAULT, dwDateFormatFlags(m_hwnd), 
            &timeLocal, NULL, szText, COUNTOF(szText)) )
        {
            pTime->bCat(szText);
            bReturn = TRUE;
        }
    }

    return bReturn;
}

void CTrayNotify::_DoRefresh(CPrintNotify *pListener)
{
    m_bInRefresh = TRUE;
    pListener->Refresh(this, _RefreshCallback);
    m_bInRefresh = FALSE;

    // check to update the tray
    _CheckToUpdateTray(FALSE, NULL);
}

void CTrayNotify::_PostPrivateMsg(const MsgInfo &msg)
{
    HANDLE hItem;
    if( SUCCEEDED(m_heapMsgCache.Alloc(msg, &hItem)) )
    {
        // request a balloon to show up...
        PostMessage(m_hwnd, WM_PRINTTRAY_PRIVATE_MSG, reinterpret_cast<LPARAM>(hItem), 0);
    }
}

void CTrayNotify::_RequestUpdate(int iEvent, LPCTSTR pszPrinter, LPCTSTR pszAux)
{
    // check to update the context menu if shown
    int i = -1;
    switch( iEvent )
    {
        case UPDATE_REQUEST_JOB_ADD:
            {
                // check to add to the context menu
                MENUITEMINFO mii = { sizeof(mii), MIIM_ID, 0 };
                if( m_shCtxMenu && _FindPrinter(pszPrinter, &i) && 0 != m_arrWatchList[i].pUserJobs->Count() &&
                    FALSE == GetMenuItemInfo(m_shCtxMenu, _EncodeMenuID(i), FALSE, &mii) )
                {
                    // add this printer to the context menu
                    _AddPrinterToCtxMenu(m_shCtxMenu, i);
                }
            }
            break;

        case UPDATE_REQUEST_JOB_DELETE:
            {
                // check this printer to be deleted later
                MsgInfo msg = { msgTypePrnCheckDelete, kFolderNone };
                lstrcpyn(msg.szPrinter, pszPrinter, COUNTOF(msg.szPrinter));
                _PostPrivateMsg(msg);

                // check to delete from the context menu
                MENUITEMINFO mii = { sizeof(mii), MIIM_ID, 0 };
                if( m_shCtxMenu && _FindPrinter(pszPrinter, &i) && 0 == m_arrWatchList[i].pUserJobs->Count() &&
                    TRUE == GetMenuItemInfo(m_shCtxMenu, _EncodeMenuID(i), FALSE, &mii) )
                {
                    // delete this printer from the context menu
                    VERIFY(DeleteMenu(m_shCtxMenu, _EncodeMenuID(i), MF_BYCOMMAND));
                }
            }
            break;

        default:
            break;
    }

    // check to update tray if not in refresh
    if( !m_bInRefresh )
    {
        _CheckToUpdateTray(FALSE, NULL);
    }
}

void CTrayNotify::_BalloonClicked(UINT uBalloonID) const
{
    switch( uBalloonID )
    {
        case BALLOON_ID_JOB_FAILED:
            vQueueCreate(NULL, m_strLastBalloonPrinter, SW_SHOWNORMAL, static_cast<LPARAM>(FALSE));
            break;

        case BALLOON_ID_JOB_PRINTED:
            // do nothing
            break;

        case BALLOON_ID_PRN_CREATED:
            _ShowPrnFolder();
            break;

        default:
            ASSERT(FALSE);
            break;
    }
}

BOOL CTrayNotify::_UpdateUserJob(PrinterInfo &pi, JobInfo &ji)
{
    // get job info at level 1
    BOOL bReturn = FALSE;
    DWORD cbJob = 0;
    CAutoPtrSpl<JOB_INFO_2> spJob;

    if( VDataRefresh::bGetJob(pi.pListener->GetPrinterHandle(), ji.dwID, 2, spJob.GetPPV(), &cbJob) )
    {
        // the only thing we care about is the document name & job status
        ji.dwStatus = spJob->Status;
        lstrcpyn(ji.szDocName, spJob->pDocument, COUNTOF(ji.szDocName));
        ji.timeSubmitted = spJob->Submitted;
        ji.dwTotalPages = spJob->TotalPages;
        bReturn = TRUE;
    }
    return bReturn;
}

void CTrayNotify::_ShowAllActivePrinters() const
{
    // open all the active printers
    int i, iCount = m_arrWatchList.Count();
    for( i=0; i<iCount; i++ )
    {
        if( m_arrWatchList[i].pUserJobs->Count() )
        {
            vQueueCreate(NULL, m_arrWatchList[i].szPrinter, SW_SHOWNORMAL, static_cast<LPARAM>(FALSE));
        }
    }
}

void CTrayNotify::_AddPrinterToCtxMenu(HMENU hMenu, int i)
{
    // build the context menu here
    TString strPrinter;
    MENUITEMINFO mii = { sizeof(mii), MIIM_TYPE|MIIM_ID, MF_STRING };

    if( m_arrWatchList[i].bUserInterventionReq )
    {
        // this printer is in error state, add an (error) suffix
        TString strTemplate;
        strTemplate.bLoadString(ghInst, IDS_TRAY_TEXT_ERROR);
        strPrinter.bFormat(strTemplate, m_arrWatchList[i].szPrinter);
    }
    else
    {
        strPrinter.bUpdate(m_arrWatchList[i].szPrinter);
    }

    mii.wID = _EncodeMenuID(i);
    mii.dwTypeData = const_cast<LPTSTR>(static_cast<LPCTSTR>(strPrinter));
    mii.cch = lstrlen(mii.dwTypeData);

    InsertMenuItem(hMenu, (UINT)-1, MF_BYPOSITION, &mii);
}

HRESULT CTrayNotify::_ProcessJobNotifications(LPCTSTR pszPrinter, DWORD dwChange, 
    const PRINTER_NOTIFY_INFO *pInfo, PrinterInfo *ppi)
{
    if( pInfo && (PRINTER_NOTIFY_INFO_DISCARDED & pInfo->Flags) )
    {
        MsgInfo msg = { msgTypeJobNotifyLost, kFolderNone };
        lstrcpyn(msg.szPrinter, pszPrinter, COUNTOF(msg.szPrinter));

        if( ppi )
        {
            // called from the foreground thread: sync processing
            _CheckToUpdateUserJobs(*ppi, msg);
        }
        else
        {
            // called from the background threads: async processing
            _PostPrivateMsg(msg);
        }
    }
    else
    {
        // regular job notifications have arrived
        if( pInfo && pInfo->Count )
        {
            MsgInfo msg = { msgTypeJobNotify, kFolderNone };
            lstrcpyn(msg.szPrinter, pszPrinter, COUNTOF(msg.szPrinter));

            for( DWORD i=0; i<pInfo->Count; i++ )
            {
                if( JOB_NOTIFY_TYPE != pInfo->aData[i].Type )
                {
                    // we only care about job notifications here
                    continue;
                }

                msg.jn.Type = pInfo->aData[i].Type;
                msg.jn.Field = pInfo->aData[i].Field;
                msg.jn.Id = pInfo->aData[i].Id;
                msg.jn.dwData = pInfo->aData[i].NotifyData.adwData[0];

                if( JOB_NOTIFY_FIELD_NOTIFY_NAME == pInfo->aData[i].Field )
                {
                    // need to copy pBuf into the aux buffer (szAuxName)
                    lstrcpyn(msg.szAuxName, reinterpret_cast<LPCTSTR>(pInfo->aData[i].NotifyData.Data.pBuf), 
                        COUNTOF(msg.szAuxName));
                }

                if( ppi )
                {
                    // called from the foreground thread: sync processing
                    _CheckToUpdateUserJobs(*ppi, msg);
                }
                else
                {
                    // called from the background threads: async processing
                    _PostPrivateMsg(msg);
                }
            }
        }
    }

    return S_OK;
}

void CTrayNotify::_ResetAll()
{
    // close the context menu
    m_shCtxMenu = NULL;

    // cleanup the watch list (unregister all job notifications listeners)
    while( m_arrWatchList.Count() )
    {
        _Delete(0);
    }

    // flush the message queue here...
    MSG msg;
    while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
    {
        if( WM_PRINTTRAY_PRIVATE_MSG == msg.message )
        {
            // just free up the private message
            VERIFY(SUCCEEDED(m_heapMsgCache.Free(reinterpret_cast<HANDLE>(msg.wParam))));
        }
    }

    // update the tray
    _CheckToUpdateTray(FALSE, NULL);
}

BOOL CTrayNotify::_IsFaxPrinter(const FOLDER_PRINTER_DATA &data)
{
    return ((0 == lstrcmp(data.pDriverName, FAX_DRIVER_NAME)) ||
            (data.Attributes & PRINTER_ATTRIBUTE_FAX));
}

HRESULT CTrayNotify::_CanNotify(LPCTSTR pszPrinterName, BOOL *pbCanNotify)
{
    HRESULT hr = E_INVALIDARG;
    BOOL bIsNetworkPrinter;
    LPCTSTR pszServer;
    LPCTSTR pszPrinter;
    TCHAR szScratch[kStrMax+kPrinterBufMax];
    UINT nSize = COUNTOF(szScratch);

    if( pszPrinterName && *pszPrinterName && pbCanNotify )
    {
        //
        // Split the printer name into its components.
        //
        vPrinterSplitFullName(szScratch, pszPrinterName, &pszServer, &pszPrinter);
        bIsNetworkPrinter = bIsRemote(pszServer);

        // set default value
        *pbCanNotify = bIsNetworkPrinter ? TRUE : FALSE;

        TPersist NotifyUser(gszPrinterPositions, TPersist::kCreate|TPersist::kRead);

        if( NotifyUser.bValid() )
        {
            if( NotifyUser.bRead(bIsNetworkPrinter ? gszNetworkPrintNotification : gszLocalPrintNotification, *pbCanNotify) )
            {
                hr = S_OK;
            }
            else
            {
                hr = CreateHRFromWin32();
            }
        }
        else
        {
            hr = CreateHRFromWin32();
        }
    }

    return hr;
}

LRESULT CTrayNotify::_ProcessUserMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch( uMsg )
    {
        case WM_PRINTTRAY_PRIVATE_MSG:
            {
                MsgInfo *pmsg = NULL;
                HANDLE hItem = reinterpret_cast<HANDLE>(wParam);
                VERIFY(SUCCEEDED(m_heapMsgCache.GetItem(hItem, &pmsg)));

                switch( pmsg->iType )
                {
                    case msgTypePrnNotify:
                        {
                            _ProcessPrnNotify(pmsg->NotifyType, pmsg->szPrinter, pmsg->szAuxName);
                        }
                        break;

                    case msgTypePrnCheckDelete:
                        {
                            int iPos = -1;
                            if( _FindPrinter(pmsg->szPrinter, &iPos) && 0 == m_arrWatchList[iPos].pUserJobs->Count() )
                            {
                                // this printer has no active user jobs, so delete it.
                                _Delete(iPos);
                                _RequestUpdate(UPDATE_REQUEST_PRN_DELETE, pmsg->szPrinter);
                            }
                        }
                        break;

                    case msgTypeJobNotify:
                        {
                            int iPos = -1;
                            if( _FindPrinter(pmsg->szPrinter, &iPos) )
                            {
                                _CheckToUpdateUserJobs(m_arrWatchList[iPos], *pmsg);
                            }
                        }
                        break;

                    case msgTypeJobNotifyLost:
                        {
                            int iPos = -1;
                            if( _FindPrinter(pmsg->szPrinter, &iPos) )
                            {
                                PrinterInfo &pi = m_arrWatchList[iPos];

                                // do a full refresh here
                                pi.dwStatus = 0;
                                pi.pUserJobs->DeleteAll();
                                _RequestUpdate(UPDATE_REQUEST_JOB_DELETE, pi.szPrinter);

                                // update all
                                _DoRefresh(m_arrWatchList[iPos].pListener);
                            }
                        }
                        break;
                        

                    default:
                        ASSERT(FALSE);
                        break;
                }

                // free up the message
                VERIFY(SUCCEEDED(m_heapMsgCache.Free(hItem)));
            }
            break;

        case WM_PRINTTRAY_ICON_NOTIFY:
            {
                // the real uMsg is in lParam
                switch( lParam )
                {
                    case WM_CONTEXTMENU:
                        _ShowMenu();
                        break;

                    case WM_LBUTTONDBLCLK:
                        _ShowAllActivePrinters();
                        break;

                    case NIN_BALLOONUSERCLICK:
                    case NIN_BALLOONTIMEOUT:
                        {
                            m_uBalloonsCount--;

                            if( NIN_BALLOONUSERCLICK == lParam && m_uBalloonID )
                            {
                                _BalloonClicked(m_uBalloonID);
                            }

                            if( 0 == m_uBalloonsCount )
                            {
                                m_uBalloonID = 0;
                                m_strLastBalloonPrinter.bUpdate(NULL);
                                _CheckToUpdateTray(FALSE, NULL);
                            }
                        }
                        break;

                    default:
                        break;
                }
            }
            break;

        case WM_WININICHANGE:
        {
            // check to re-do the icon
            _CheckToUpdateTray(FALSE, NULL);
        }
        break;

        default:
            break;
    }

    return 0;
}

DWORD WINAPI CTrayNotify::_ThreadProc_MsgLoop(LPVOID lpParameter)
{
    CTrayNotify *pFolderNotify = (CTrayNotify *)lpParameter;

    if( pFolderNotify )
    {
        pFolderNotify->_ThreadProc();
        return EXIT_SUCCESS;
    }

    return EXIT_FAILURE;
}

// the callback called on refresh
HRESULT WINAPI CTrayNotify::_RefreshCallback(
    LPVOID lpCookie, ULONG_PTR uCookie, DWORD dwChange, const PRINTER_NOTIFY_INFO *pInfo)
{
    int iPos;
    HRESULT hr = E_INVALIDARG;
    CTrayNotify *pThis = reinterpret_cast<CTrayNotify*>(lpCookie);
    CPrintNotify *pListener = reinterpret_cast<CPrintNotify*>(uCookie);

    if( pThis && pListener && pThis->_FindPrinter(pListener->GetPrinter(), &iPos) )
    {
        hr = pThis->_ProcessJobNotifications(
            pListener->GetPrinter(), dwChange, pInfo, &pThis->m_arrWatchList[iPos]);
    }

    return hr;
}

//////////////////////////////////
// global & exported functions
//
static CTrayNotify *gpTrayNotify = NULL;

extern "C" {

BOOL WINAPI PrintNotifyTray_Init()
{
    ASSERT(gpTrayLock);

    // synchonize this with gpTrayLock
    CCSLock::Locker lock(*gpTrayLock);

    BOOL bReturn = FALSE;
    if( NULL == gpTrayNotify )
    {
        if( SUCCEEDED(CTrayNotify_CreateInstance(&gpTrayNotify)) )
        {
            bReturn = gpTrayNotify->Initialize();

            if( !bReturn )
            {
                gpTrayNotify->Release();
                gpTrayNotify = NULL;
            }
            else
            {
                DBGMSG(DBG_INITDONE, ("INITDONE: PrintTray - start listen! \n"));
            }
        }
    }
    else
    {
        // reset the shutdown timer
        gpTrayNotify->Touch();
    }

    return bReturn;
}

BOOL WINAPI PrintNotifyTray_Exit()
{
    ASSERT(gpTrayLock);

    // synchonize this with gpTrayLock
    CCSLock::Locker lock(*gpTrayLock);

    BOOL bReturn = FALSE;
    if( gpTrayNotify )
    {
        bReturn = gpTrayNotify->Shutdown();
        gpTrayNotify->Release();
        gpTrayNotify = NULL;

        DBGMSG(DBG_INITDONE, ("INITDONE: PrintTray - stop listen! \n"));
    }

    return bReturn;
}

BOOL WINAPI PrintNotifyTray_SelfShutdown()
{
    ASSERT(gpTrayLock);

    BOOL bReturn = FALSE;
    CTrayNotify *pTrayNotify = NULL;

    {
        // synchonize this with gpTrayLock
        CCSLock::Locker lock(*gpTrayLock);

        if( gpTrayNotify )
        {
            if( gpTrayNotify->CanShutdown() )
            {
                // mark for deletion and continue to exit the CS
                pTrayNotify = gpTrayNotify;
                gpTrayNotify = NULL;

                DBGMSG(DBG_INITDONE, ("INITDONE: PrintTray - stop listen! \n"));
            }
            else
            {
                // restart the shutdown timer
                gpTrayNotify->Resurrect();
            }
        }
    }

    if( pTrayNotify )
    {
        // marked for shutdown & release - shutdown without holding the CS
        bReturn = pTrayNotify->Shutdown();
        pTrayNotify->Release();
    }

    return bReturn;
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\wow64.c ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    wow64.h

Abstract:

    printui wow64 related functions.

Author:

    Lazar Ivanov (LazarI)  10-Mar-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>

#include "wow64.h"

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

//
// Win64 APIs, types and data structures.
//

ClientVersion
OSEnv_GetClientVer(
    VOID
    )
{
     return(sizeof(ULONG_PTR));
}

ServerVersion
OSEnv_GetServerVer(
    VOID
    )
{
    ULONG_PTR       ul;
    NTSTATUS        st;
    ServerVersion   serverVersion;

    st = NtQueryInformationProcess(NtCurrentProcess(), 
        ProcessWow64Information, &ul, sizeof(ul), NULL);

    if( NT_SUCCESS(st) )
    {
        // If this call succeeds, we're on Win2000 or newer machines.
        if( 0 != ul )
        {
            // 32-bit code running on Win64
            serverVersion = THUNKVERSION;
        } 
        else 
        {
            // 32-bit code running on Win2000 or later 32-bit OS
            serverVersion = NATIVEVERSION;
        }
    } 
    else 
    {
        serverVersion = NATIVEVERSION;
    }

    return serverVersion;
}

#if 0 // debug code
BOOL
IsRunningInSPLWOW(
    VOID
    )
{
    TCHAR   szSysDir[MAX_PATH];
    TCHAR   szSplWOW64Name[MAX_PATH];
    TCHAR   szModName[MAX_PATH];
    
    GetWindowsDirectory(szSysDir, ARRAYSIZE(szSysDir));

    _tcscpy(szSplWOW64Name, szSysDir);
    _tcscat(szSplWOW64Name, TEXT("\\splwow64.exe"));

    GetModuleFileName(NULL, szModName, ARRAYSIZE(szModName));

    return (0 == _tcsicmp(szSplWOW64Name, szModName));
}
#endif // 0

BOOL
IsRunningWOW64(
    VOID
    )
{
    // return !IsRunningInSPLWOW();
    return (RUN32BINVER == OSEnv_GetClientVer() &&
            THUNKVERSION == OSEnv_GetServerVer());
           
}

PlatformType
GetCurrentPlatform(
    VOID
    )
{
    if (RUN64BINVER == OSEnv_GetClientVer())
   {
       // this is a native 64bit process - i.e. the platform is IA64
       return kPlatform_IA64;
   }
   else
   {
       // this is 32 bit process. it can be either native - i.e. the platform is i386 - 
       // or wow64 - i.e. the platform is again IA64.
 
       if (THUNKVERSION == OSEnv_GetServerVer())
       {
           // the process is wow64 - the platform is IA64
           return kPlatform_IA64;
       }
       else
       {
           // the process is native - i.e. the platform is x86
           return kPlatform_x86;
       }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\tstpage.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999
All rights reserved.

Module Name:

    tstpage.cxx

Abstract:

    Print Test Page

Author:

    Steve Kiraly (SteveKi)  16-Jan-1996

Revision History:

    Lazar Ivanov (LazarI)  Jun-2000 (Win64 fixes)

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "tstpage.hxx"

/********************************************************************

    Message map used after the test page is printed.

********************************************************************/

//
// Check if the printer name contains a
// trailing spaces
//
BOOL
bContainTrailingSpaces(
    IN LPCTSTR  pszShareName
    )
{
    BOOL bResult = FALSE;

    if( pszShareName )
    {
        //
        // Check for trailing spaces here
        //
        int iLen = lstrlen(pszShareName);
        if( iLen > 0 && TEXT(' ') == pszShareName[iLen-1] )
        {
            bResult = TRUE;
        }
    }

    return bResult;
}

//
// Print test page to specified printer
//
BOOL
bPrintTestPage(
    IN HWND     hWnd,
    IN LPCTSTR  pszPrinterName,
    IN LPCTSTR  pszShareName
    )
{
    INT_PTR iStatus;

    DBGMSG( DBG_TRACE, ( "bPrintTestPage\n" ) );
    DBGMSG( DBG_TRACE, ( "PrinterName " TSTR "\n", pszPrinterName ) );

    //
    // Set the last error to a known value.  This will allow us to
    // display a reasonable error messege if some api fails to print
    // the test page.  The createDC call in particular may fail if
    // the driver does not exist on this machine.
    //
    SetLastError( ERROR_SUCCESS );

    //
    // We need to check the name for trailing spaces, which
    // can cause a problems with NT5 -> Win98 downlevel connections.
    // The problem is that CreateFile(...) function fails if
    // the printer share name contains trailing spaces.
    //
    if( bContainTrailingSpaces( pszShareName ) ) {

        //
        // Warn the user for eventual problems in this case
        //
        iMessage( hWnd,
                  IDS_ERR_PRINTER_PROP_TITLE,
                  IDS_WARN_TRAILINGSPACES_IN_PRINTERNAME,
                  MB_OK|MB_ICONEXCLAMATION,
                  kMsgNone,
                  NULL );
    }

    //
    // Insure we don't have a null printer name.
    // or the test page failed to print.
    //
    if( !pszPrinterName ||
        !bDoPrintTestPage(hWnd, pszPrinterName ) ){

        DBGMSG( DBG_WARN, ( "Print test page failed with %d\n", GetLastError() ));

        //
        // If the user canceled the operation then just exit.
        //
        if( GetLastError() == ERROR_CANCELLED ){
            return TRUE;
        }

        //
        // Ask the user if they want to goto the print
        // trouble shooter.
        //
        if( IDYES == iMessage( hWnd,
                               IDS_ERR_PRINTER_PROP_TITLE,
                               IDS_ERR_TESTPAGE,
                               MB_YESNO|MB_ICONEXCLAMATION,
                               kMsgGetLastError,
                               NULL ) ){

            //
            // This jumps to the windows printer help trouble shooter section. 
            // We have to execute the troubleshooter in a separate process because this 
            // code sometimes is executed in a rundll process, which goes away imediately 
            // and the help window goes away too. We don't want the help window to go away.
            //
            ShellExecute( hWnd, TEXT("open"), TEXT("helpctr.exe"), gszHelpTroubleShooterURL, NULL, SW_SHOWNORMAL );
        }
        return FALSE;
    }

    TString strMachineName;
    LPCTSTR pszServer, pszPrinter;
    TCHAR   szScratch[PRINTER_MAX_PATH];

    if( SUCCEEDED(PrinterSplitFullName(pszPrinterName, szScratch, ARRAYSIZE(szScratch), &pszServer, &pszPrinter)) &&
        bGetMachineName(strMachineName) &&
        0 == _tcsicmp(pszServer, strMachineName) )
    {
        // this is local printer - update the name
        pszPrinterName = pszPrinter;
    }

    //
    // Prompt user, asking if the test page printed ok.
    //
    iStatus = DialogBoxParam( ghInst,
                              MAKEINTRESOURCE( DLG_END_TESTPAGE ),
                              hWnd,
                              EndTestPageDlgProc,
                              (LPARAM)pszPrinterName );

    //
    // User indicated page did not print, display winhelp.
    //
    if( iStatus != IDOK ){

        //
        // This jumps to the windows printer help trouble shooter section. 
        // We have to execute the troubleshooter in a separate process because this 
        // code sometimes is executed in a rundll process, which goes away imediately 
        // and the help window goes away too. We don't want the help window to go away.
        //
        ShellExecute( hWnd, TEXT("open"), TEXT("helpctr.exe"), gszHelpTroubleShooterURL, NULL, SW_SHOWNORMAL );
        return FALSE;
    }

    //
    // Set proper return code.
    //
    return TRUE;

}

//
// Print test page to the specified printer.
//
BOOL
bDoPrintTestPage(
    IN HWND     hWnd,
    IN LPCTSTR  pszPrinterName
    )
{
    DOCINFO DocInfo;
    TCHAR   szBuf[kStrMax];
    RECT    rc;
    BOOL    bDocumentStarted    = FALSE;
    HDC     hdcPrint            = NULL;
    DWORD   dwLastError         = ERROR_SUCCESS;
    BOOL    bStatus             = FALSE;
    UINT    uRightAlign         = 0;

    //
    // Create a printer DC
    //
    hdcPrint = CreateDC( _T("WINSPOOL"), pszPrinterName, NULL, NULL );
    if( hdcPrint == NULL ){
        DBGMSG( DBG_WARN, ( "CreateDC failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // Load the test page name.
    //
    if( !LoadString( ghInst, IDS_TP_TESTPAGENAME, szBuf, COUNTOF(szBuf) ) ){
        DBGMSG( DBG_WARN, ( "Load test page name failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // Start the document
    //
    ZeroMemory( &DocInfo, sizeof( DOCINFO ));
    DocInfo.cbSize      = sizeof( DocInfo );
    DocInfo.lpszDocName = szBuf;
    DocInfo.lpszOutput  = NULL;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType      = 0;

    //
    // Start the print job.
    //
    if( StartDoc( hdcPrint, &DocInfo ) <= 0 ) {
        DBGMSG( DBG_WARN, ( "StartDoc failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // Indicate document was started
    //
    bDocumentStarted = TRUE;

    //
    // Start the test page.
    //
    if( StartPage( hdcPrint ) <= 0 ){
        DBGMSG( DBG_WARN, ( "StartPage failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    if (GetWindowLongPtr(hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) {
        uRightAlign = DT_RIGHT | DT_RTLREADING;
    }

    //
    // Get Margin clip box, Margins are expressed in 100th of an inch.
    //
    rc = GetMarginClipBox( hdcPrint, 50, 100, 100, 100 );

    //
    // Print Test Page Header
    //
    if( !bPrintTestPageHeader( hdcPrint, TRUE, TRUE, &rc, uRightAlign ) ){
        DBGMSG( DBG_WARN, ( "bPrintTestPageHeader failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // Print basic test page information.
    //
    if( !bPrintTestPageInfo( hdcPrint, &rc, pszPrinterName, uRightAlign ) ){
        DBGMSG( DBG_WARN, ( "bPrintTestPageInfo failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // End the page.
    //
    if( EndPage( hdcPrint ) <= 0 ){
        DBGMSG( DBG_WARN, ( "EndPage failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // End the print job.
    //
    if( EndDoc( hdcPrint ) <= 0 ){
        DBGMSG( DBG_WARN, ( "StartDoc failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // Set error status.
    //
    bDocumentStarted = FALSE;
    bStatus = TRUE;
    SetLastError( ERROR_SUCCESS );

    //
    // Cleanup any outstanding resources.
    //
Cleanup:


    if( !bStatus ){

        //
        // Save the last error state.
        //
        dwLastError = GetLastError();

        //
        // If the document was started then abort the document.
        //
        if( bDocumentStarted && AbortDoc( hdcPrint ) <= 0 ){
            DBGMSG( DBG_WARN, ( "AbortDoc failed with %d\n", GetLastError() ) );
        }
    }

    //
    // Release DC
    //
    if( hdcPrint ){
        DeleteDC( hdcPrint );
    }

    if( !bStatus ){
        //
        // Restore the last error state back to the caller.
        //
        SetLastError( dwLastError );
    }

    return bStatus;
}

/*++

Routine Name:

    GetMarginClipBox

Routine Description:

    Calculates the correct margin rectangle for the specifed DC.
    Note that a printer DC has non-printable regions on all sized,
    this routine takes these regions into account when calculating
    the correct margins.  Margins are measured from the extream
    physical edge of the page.

Arguments:

    hdcPrint - Printer device context
    iLeft   - Desired left margin
    iRight  - Desired left margin
    iTop    - Desired left margin
    iBottom - Desired left margin

Return Value:

    Rectangle which reflects the specified margins.  Note if the
    desired margins are smaller than what the device is capable
    of then the clip box is adjusted to the physical printers
    margin.

--*/
RECT
GetMarginClipBox(
    IN HDC  hdcPrint,
    IN INT iLeft,
    IN INT iRight,
    IN INT iTop,
    IN INT iBottom
    )
{
    INT npx = GetDeviceCaps( hdcPrint, PHYSICALOFFSETX );
    INT npy = GetDeviceCaps( hdcPrint, PHYSICALOFFSETY );

    INT iLogicPixelsX = GetDeviceCaps( hdcPrint, LOGPIXELSX );
    INT iLogicPixelsY = GetDeviceCaps( hdcPrint, LOGPIXELSY );

    RECT rcPage;
    rcPage.left = max( 0, iLogicPixelsX * iLeft / kInchConversion  - npx );
    rcPage.top  = max( 0, iLogicPixelsY * iTop / kInchConversion - npy );

    INT iPhysWidth      = GetDeviceCaps( hdcPrint, PHYSICALWIDTH );
    INT iPhysHeight     = GetDeviceCaps( hdcPrint, PHYSICALHEIGHT );

    INT iHorzRes = GetDeviceCaps( hdcPrint, HORZRES );
    INT iVertRes = GetDeviceCaps( hdcPrint, VERTRES );

    INT nprx = iPhysWidth - (npx + iHorzRes);
    INT npby = iPhysHeight - (npy + iVertRes);

    rcPage.right    = iHorzRes - max( 0, iLogicPixelsX * iRight / kInchConversion - nprx );
    rcPage.bottom   = iVertRes - max( 0, iLogicPixelsY * iBottom / kInchConversion - npby );

    return rcPage;

}

/*++

Routine Name:

    bPrintTestPageHeader

Routine Description:

    Print out a header for the test page

Arguments:

    hdcPrint - Printer device context
    bDisplayLogo - flag TRUE display logo, false do not display logo
    bDoGraphics - flag TRUE do graphics, false do not do graphics
    lpRect - Pointer to a rectangle which describes the margins
    uRightAlign - flags to print the test page right aligned

Return Value:

    TRUE if header was printed, FALSE if error occurred.

--*/
BOOL
bPrintTestPageHeader(
    IN  HDC     hdc,
    IN  BOOL    bDisplayLogo,
    IN  BOOL    bDoGraphics,
    IN  RECT   *lprcPage,
    IN  UINT    uRightAlign
    )
{
    enum Info { PLACEABLE_SIGNATURE = 0x9AC6CDD7,
                METAFILEHEADER_SIZE = 22,
                };

    BOOL bSuccess = TRUE;

    INT nXInch = GetDeviceCaps( hdc, LOGPIXELSX );
    INT nYInch = GetDeviceCaps( hdc, LOGPIXELSY );

    //
    // If device can do graphics.
    //
    if( RC_BITBLT & GetDeviceCaps( hdc, RASTERCAPS ) && bDoGraphics ){

        if( bDisplayLogo ) {

            HRSRC hRes = FindResource( ghInst,
                                       MAKEINTRESOURCE(IDR_MF_LOGO),
                                       TEXT("METAFILE") );

            if( hRes ) {

                //
                // Device can handle BitBlt calls--do graphic
                //
                LPBYTE lpMetaFile = (LPBYTE)LoadResource( ghInst, hRes );

                if( lpMetaFile ){

                    LPMETAHEADER lpMH;
                    HMETAFILE    hmf;

                    if(PLACEABLE_SIGNATURE==*((LPDWORD)lpMetaFile)) {
                        lpMetaFile+=METAFILEHEADER_SIZE;
                    }

                    lpMH=(LPMETAHEADER)lpMetaFile;

                    if( ( hmf=SetMetaFileBitsEx(lpMH->mtSize*sizeof(WORD),(LPBYTE)lpMH)) != NULL ){

                        INT nSavedDC=SaveDC(hdc);

                        SetMapMode(hdc,MM_ISOTROPIC);
                        SetWindowOrgEx(hdc,0,0,NULL);
                        SetWindowExtEx(hdc,100,100,NULL);
                        SetViewportExtEx(hdc,nXInch,nYInch,NULL);
                        SetViewportOrgEx(hdc,nXInch/2,nYInch/2,NULL);

                        bSuccess=PlayMetaFile(hdc,hmf);
                        DeleteMetaFile(hmf);

                        //
                        // Restore the previous GDI state
                        //
                        if(nSavedDC)
                            RestoreDC(hdc,nSavedDC);
                    }
                } 
            }
        }

        //
        // Output TrueType font at top of page in 36 point Times New Roman
        //
        HFONT  hOldFont;
        hOldFont = CreateAndSelectFont( hdc, IDS_TP_TIMESNEWROMAN, 36 );

        if( hOldFont ){

            //
            // Position text so it aligns with the graphic & is 2" into
            // the printable region.
            //
            lprcPage->top=nYInch/2;
            lprcPage->left=nXInch*2;

            //
            // Print the test page header.
            //
            bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_HEADER,'\0');

            //
            // Restore the margins.
            //
            lprcPage->top=nYInch*2;
            lprcPage->left=nXInch/2;

            //
            // Restore the font
            //
            DeleteObject( SelectObject( hdc, hOldFont ) );

        } else {

            DBGMSG( DBG_WARN, ( "CreateAndSelectFontFailed with %d.\n", GetLastError() ) );
            bSuccess = FALSE;

        }

    } else {

        DBGMSG( DBG_TRACE, ( "Printer does not do graphics.\n" ) );

        //
        // Device can't do graphics--use default font for title. Center it
        // horizontally, half an inch from the top of the printable area.
        //
        lprcPage->top=nYInch/2;

        //
        // Display normal text header.
        //
        bSuccess &= PrintString(hdc,lprcPage,DT_TOP|DT_CENTER,IDS_TP_HEADER,'\n');

        //
        // Display all of the other strings 1/2" from the left margin
        //
        lprcPage->left=nXInch/2;

    }

    return bSuccess;
}

/*++

Routine Name:

    bPrintTestPageInfo

Routine Description:

    Print out a printer info on the test page.

Arguments:

    hdcPrint - Printer device context
    lpRect - Pointer to a rectangle which describes the margins
    uRightAlign - flags to print the test page right aligned

Return Value:

    TRUE if header was printed, FALSE if error occurred.

--*/
BOOL
bPrintTestPageInfo(
    IN HDC              hdc,
    IN LPRECT           lprcPage,
    IN LPCTSTR          pszPrinterName,
    IN UINT             uRightAlign
    )
{
    TCHAR szBuffer[kServerBufMax];
    TCHAR szBuff[kStrMax];
    TEXTMETRIC      tm;
    LPCTSTR         pszBuffer       = NULL;
    DWORD           dwDriverVersion = 0;
    BOOL            bSuccess        = FALSE;
    HFONT           hOldFont        = NULL;
    DWORD           dwBufferSize    = COUNTOF( szBuffer );
    PPRINTER_INFO_2 lppi2           = NULL;
    PDRIVER_INFO_3  lpdi3           = NULL;
    HDC             hdcScreen       = NULL;
    UINT            nYInch;
    TString         strTemp;

    //
    // Get the screen device context.
    //
    hdcScreen = GetDC( NULL );
    if( !hdcScreen ){
        DBGMSG( DBG_WARN, ( "GetDC failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

#ifdef USE_DEVICE_FONT

    //
    // Get the logical pixes in the y direction.
    //
    nYInch = GetDeviceCaps( hdc, LOGPIXELSY);
    if( !nYInch ){
        DBGMSG( DBG_WARN, ( "GetDeviceCaps failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // This stuff is designed to be printed in a fixed-pitch font,
    // using the system character set. If the current font fails
    // any criterion, use CourierNew in the system charset.
    //
    if( !GetTextMetrics( hdc, &tm ) ||
      ( tm.tmPitchAndFamily & TMPF_FIXED_PITCH ) ||
      ( GetTextCharset(hdc) != GetTextCharset( hdcScreen ) ) ||
      ( tm.tmHeight > MulDiv( 12, nYInch, 72 ) ) ){

        DBGMSG( DBG_TRACE, ( "Creating font.\n" ) );

        hOldFont = CreateAndSelectFont( hdc, IDS_TP_FONTNAMEINFOTEXT, 10 );
        if( !hOldFont ){
            DBGMSG( DBG_WARN, ( "CreateAndSelectFont failed with %d\n", GetLastError() ) );
            goto Cleanup;
        }

    } else {

        DBGMSG( DBG_TRACE, ( "Using Default printer font.\n" ) );

    }

#else

    hOldFont = CreateAndSelectFont( hdc, IDS_TP_FONTNAMEINFOTEXT, 10 );
    if( !hOldFont ){
        DBGMSG( DBG_WARN, ( "CreateAndSelectFont failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

#endif

    //
    // Get the printer information to print.
    //
    if( !bGetPrinterInfo( pszPrinterName, &lppi2, &lpdi3 ) ){
        DBGMSG( DBG_WARN, ( "bGetPrinterInfo failed with %d\n", GetLastError() ) );
        goto Cleanup;
    }

    // Machine Name:
    if( lppi2->pServerName ){

        // If server name is not null copy string
        _tcscpy( szBuffer, lppi2->pServerName );
    } else {

        // Get the computer name.
        GetComputerName( szBuffer, &dwBufferSize );
    }

    // Remove any leading slashes
    for( pszBuffer = szBuffer; pszBuffer && ( *pszBuffer == TEXT( '\\' ) ); pszBuffer++ )
        ;

    bSuccess = TRUE;

    // Tell the user that we installed successfully.
    bSuccess &= PrintString( hdc, lprcPage, uRightAlign, IDS_TP_CONGRATULATIONS );

    // Tell the user what they installed.
    bSuccess &= PrintString( hdc, lprcPage, uRightAlign, IDS_TP_PRINTERISINSTALLED, lppi2->pDriverName, pszBuffer );

    // Get the time and date.
    bSuccess &= GetCurrentTimeAndDate( COUNTOF( szBuff ), szBuff );

    // Print the time and date.
    bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_TIMEDATE, szBuff );

    // Print the machine name.
    bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_MACHINENAME, pszBuffer );

    // Printer Name:
    if( SUCCEEDED(AbbreviateText(lppi2->pPrinterName, MAX_TESTPAGE_DISPLAYNAME, &strTemp)) )
    {
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_PRINTERNAME, (LPCTSTR)strTemp );
    }
    else
    {
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_PRINTERNAME, lppi2->pPrinterName );
    }

    // Printer Model:
    bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_PRINTERMODEL, lppi2->pDriverName);

    // Color Capability
    if( lppi2->pDevMode )
    {
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IsColorDevice(lppi2->pDevMode)?IDS_TP_COLOR:IDS_TP_MONO);
    }

    // Printer Port:
    if( lppi2->pPortName && SUCCEEDED(AbbreviateText(lppi2->pPortName, MAX_TESTPAGE_DISPLAYNAME, &strTemp)) )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_PORTNAME, (LPCTSTR)strTemp);

    // Data Type:
    if( lppi2->pDatatype )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_DATATYPE, lppi2->pDatatype);

    // Share Name
    if( lppi2->pShareName && SUCCEEDED(AbbreviateText(lppi2->pShareName, MAX_TESTPAGE_DISPLAYNAME, &strTemp)) )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_SHARE_NAME, (LPCTSTR)strTemp);

    // Location
    if( lppi2->pLocation && SUCCEEDED(AbbreviateText(lppi2->pLocation, MAX_TESTPAGE_DISPLAYNAME, &strTemp)) )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_LOCATION, (LPCTSTR)strTemp);

    // Comment
    if( lppi2->pComment && SUCCEEDED(AbbreviateText(lppi2->pComment, MAX_TESTPAGE_DISPLAYNAME, &strTemp)) )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_COMMENT, (LPCTSTR)strTemp);

    // DRV Name:
    bSuccess &= PrintBaseFileName(hdc,lpdi3->pDriverPath,lprcPage, IDS_TP_DRV_NAME, uRightAlign);

    // Data file  (if it's different from the driver name)
    if(lstrcmpi(lpdi3->pDriverPath,lpdi3->pDataFile))
    {
        bSuccess &= PrintBaseFileName(hdc,lpdi3->pDataFile,lprcPage, IDS_TP_DATA_FILE, uRightAlign);
    }

    // Config file (if it's different from the driver name)
    if(lstrcmpi(lpdi3->pDriverPath,lpdi3->pDataFile))
    {
        bSuccess &= PrintBaseFileName(hdc,lpdi3->pConfigFile,lprcPage,
            IDS_TP_CONFIG_FILE, uRightAlign);
    }

    // Help file
    if( lpdi3->pHelpFile )
    {
        bSuccess &= PrintBaseFileName(hdc,lpdi3->pHelpFile,lprcPage,IDS_TP_HELP_FILE, uRightAlign);
    }

    // Driver version, if available
    if((dwDriverVersion=DeviceCapabilities(lppi2->pPrinterName,lppi2->pPortName,DC_DRIVER,NULL,NULL)) != (DWORD)-1)
    {
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_DRV_VERSION,
            HIBYTE(LOWORD(dwDriverVersion)),
            LOBYTE(LOWORD(dwDriverVersion)));
    }

    // Environment
    if( lpdi3->pEnvironment )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_ENVIRONMENT,lpdi3->pEnvironment);

    // Monitor
    if( lpdi3->pMonitorName )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_MONITOR,lpdi3->pMonitorName);

    // Default Datatype
    if( lpdi3->pDefaultDataType )
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_DEFAULT_DATATYPE,lpdi3->pDefaultDataType);

    // Dependent Files:
    LPTSTR lpTest;
    lpTest = lpdi3->pDependentFiles;
    if(lpTest && *lpTest)
    {
        bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_DEPENDENTLIST);

        while(*lpTest)
        {
            bSuccess &= PrintDependentFile(hdc,lprcPage,lpTest, lpdi3->pDriverPath, uRightAlign);
            lpTest += (lstrlen(lpTest)+1);
        }
    }

    // Tell the user that we're done now
    bSuccess &= PrintString(hdc,lprcPage,uRightAlign,IDS_TP_TESTPAGEEND);

    //
    // Release the resources.
    //
Cleanup:

    FreeMem( lpdi3 );
    FreeMem( lppi2 );

    if( hOldFont ){
        DeleteObject( SelectObject( hdc, hOldFont ) );
    }

    if( hdcScreen ){
        ReleaseDC( NULL, hdcScreen );
    }

    return bSuccess;
}

//-------------------------------------------------------------------------
// Function: IsColorDevice(hdc)
//
// Action: Determine whether or not this device supports color
//
// Return: TRUE if it does, FALSE if it doesn't
//-------------------------------------------------------------------------
BOOL
IsColorDevice(
    IN DEVMODE *pDevMode
    )
{
    //
    // Assume monochrome.
    //
    DWORD dmColor = DMCOLOR_MONOCHROME;

    //
    // Get the color support if available.
    //
    if( pDevMode && ( pDevMode->dmFields & DM_COLOR ) )
        dmColor = pDevMode->dmColor;

    //
    // TRUE color supported, FALSE monochrome.
    //
    return dmColor == DMCOLOR_COLOR;
}

/*++

Routine Name:

    CreateAndSelectFont

Routine Description:

    Get a font with the face, style & point size for this device,
    and the character set from the screen DC, then select it in.

Arguments:

    hdc             - Currently selected dc
    uResFaceName    - Type face name resource ID
    uPtSize         - Desired point size

Return Value:

    The OLD font handle if successful, Failure NULL

--*/
HFONT
CreateAndSelectFont(
    IN HDC  hdc,
    IN UINT uResFaceName,
    IN UINT uPtSize
    )
{
    INT     nYInch      = 0;
    HDC     hdcScreen   = NULL;
    HFONT   hNewFont    = NULL;
    HFONT   hOldFont    = NULL;
    LOGFONT lf;

    //
    // Logical pixels in the y direction.
    //
    nYInch = GetDeviceCaps( hdc, LOGPIXELSY);

    //
    // Get a handle to the screen DC for creating a font.
    //
    hdcScreen = GetDC( NULL );
    if( !hdcScreen ){
        DBGMSG( DBG_TRACE, ( "CreateAndSelectFont - GetDC failed with %d.\n", GetLastError() ) );
        goto Cleanup;
    }

    ZeroMemory( &lf, sizeof( LOGFONT ) );

    lf.lfHeight         = MulDiv( uPtSize, nYInch, 72);
    lf.lfWeight         = 400;
    lf.lfCharSet        = (BYTE)GetTextCharset( hdcScreen );
    lf.lfQuality        = (BYTE)PROOF_QUALITY;
    lf.lfPitchAndFamily = FF_DONTCARE;

    //
    // Load the font face name from the resource file.
    //
    if( !LoadString( ghInst, uResFaceName, lf.lfFaceName, COUNTOF( lf.lfFaceName ) ) ){
        DBGMSG( DBG_TRACE, ( "CreateAndSelectFont - LoadString failed with %d.\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // Create the font.
    //
    hNewFont = CreateFontIndirect( &lf );
    if( !hNewFont ){
        DBGMSG( DBG_TRACE, ( "CreateAndSelectFont - CreateFontIndirect failed with %d.\n", GetLastError() ) );
        goto Cleanup;
    }

    //
    // Select the new font into the current dc and return the old font handle.
    //
    hOldFont = (HFONT)SelectObject( hdc, hNewFont );
    if( !hOldFont ||
        (ULONG_PTR)hOldFont == GDI_ERROR ){
        DBGMSG( DBG_TRACE, ( "CreateAndSelectFont - SelectObject failed with %d, %d.\n", hOldFont, GetLastError() ) );
        hOldFont = NULL; // Indicate failure to caller.
        goto Cleanup;
    }

Cleanup:

    //
    // Release the screen dc handle
    //
    if( hdcScreen ){
        ReleaseDC( NULL, hdcScreen );
    }

    return hOldFont;
}

//-------------------------------------------------------------------------
// Function: PrintString(hdc,lprcPage,uFlags,uResId,...)
//
// Action: Build a formatted string, then print it on the page using the
//         current font. Update lprcPage after the output.
//
// Return: TRUE if successful, FALSE if not
//-------------------------------------------------------------------------
BOOL
cdecl
PrintString(
    HDC       hdc,
    LPRECT    lprcPage,
    UINT      uFlags,
    UINT      uResId,
    ...
    )
{
    BOOL    bSuccess = FALSE;
    va_list pArgs;

    //
    // Get pointer to first un-named argument.
    //
    va_start( pArgs, uResId );

    //
    // Alocate the format and string buffer.
    //
    TCHAR npFormat[kStrMax];
    TCHAR npBuffer[1024];

    //
    // Load the string resource.
    //
    if( LoadString( ghInst, uResId, npFormat, COUNTOF( npFormat ) ) ){

        //
        // Format the string.
        //
        _vsntprintf( npBuffer, COUNTOF( npBuffer ), npFormat, pArgs );

        //
        // Output the string, updating the rectangle.
        //
        INT nHeight;
        nHeight = DrawText( hdc,
                            npBuffer,
                            -1,
                            lprcPage,
                            uFlags|DT_EXPANDTABS|DT_LEFT|DT_NOPREFIX|DT_WORDBREAK);
        //
        // If any text was drawn.
        //
        if( nHeight ){

            //
            // Update the rectangle
            //
            lprcPage->top += nHeight;
            bSuccess=TRUE;

        } else {
            DBGMSG( DBG_TRACE, ( "PrintString - DrawText failed with %d\n", GetLastError() ) );
        }
    } else {
        DBGMSG( DBG_TRACE, ( "PrintString - LoadString failed with %d\n", GetLastError() ) );
    }

    va_end( pArgs );

    return bSuccess;
}


//-------------------------------------------------------------------------
// Function: PrintBaseFileName(hdc,lpFile,lprcPage,uResID)
//
// Action: Print the base filename as part of a formatted string
//
// Return: Whatever PrintString returns
//-------------------------------------------------------------------------
BOOL
PrintBaseFileName(
    IN      HDC      hdc,
    IN      LPCTSTR  lpFile,
    IN OUT  LPRECT   lprcPage,
    IN      UINT     uResID,
    IN      UINT     uRightAlign
    )
{
    LPCTSTR lpTest;

    while( ( lpTest = _tcspbrk( lpFile, TEXT( "\\" ) ) ) != NULL )
        lpFile = ++lpTest;

    return PrintString( hdc, lprcPage, uRightAlign, uResID, lpFile );
}

//-------------------------------------------------------------------------
// Function: PrintDependentFile(hdc,lprcPage,lpFile,lpDriver)
//
// Action: Print a line for this dependent file. Include its full path.
//         Try to include its version information, and it this is the
//         actual driver file, see if it's a minidriver and include
//         that information.
//
// Return: TRUE if successful, FALSE if not
//-------------------------------------------------------------------------
BOOL
PrintDependentFile(
    IN HDC    hdc,
    IN LPRECT lprcPage,
    IN LPTSTR  lpFile,
    IN LPTSTR  lpDriver,
    IN UINT    uRightAlign
    )
{
    DWORD    dwSize;
    DWORD    dwHandle;
    WORD     wGPCVersion;
    LPBYTE   lpData         = NULL;
    LPWORD   lpVersion      = NULL;
    BOOL     bSuccess       = FALSE;

    static TCHAR cszTranslation[]       = TEXT( "\\VarFileInfo\\Translation" );
    static TCHAR cszFileVersion[]       = TEXT( "\\StringFileInfo\\%04X%04X\\FileVersion" );
    static TCHAR cszProductVersion[]    = TEXT( "\\StringFileInfo\\%04X%04X\\ProductVersion" );

    //
    // Get the file attributes.
    //
    if( HFILE_ERROR == GetFileAttributes( lpFile ) ){
        return FALSE;
    }

    dwSize = GetFileVersionInfoSize( lpFile, &dwHandle );
    if( dwSize ){

        lpData=(LPBYTE)AllocMem( dwSize );

        if( lpData ){

            UINT   uSize;
            TCHAR  szTemp[MAX_PATH];
            LPWORD lpTrans;

            if(GetFileVersionInfo(lpFile,dwHandle,dwSize,lpData) &&
                VerQueryValue(lpData,cszTranslation,(LPVOID*)&lpTrans,&uSize) &&
                uSize){

                wsprintf(szTemp,cszFileVersion,*lpTrans,*(lpTrans+1));

                if(!VerQueryValue(lpData,szTemp,(LPVOID*)&lpVersion,&uSize))
                {
                    wsprintf(szTemp,cszProductVersion,*lpTrans,*(lpTrans+1));
                    VerQueryValue(lpData,szTemp,(LPVOID*)&lpVersion,&uSize);
                }
            }
        }
    }

    UNREFERENCED_PARAMETER( lpDriver );
#if 0
    //
    // Check for GPC version if this is the driver
    //
    // !!LATER!!
    // Fetching the GPC version from Win32 API's is not suppored on NT.
    //
    if(!lstrcmpi(lpDriver,lpFile))
        wGPCVersion=GetGPCVersion(lpDriver);
    else
#endif
        wGPCVersion=0;


    // Now actually print the resulting string
    if(lpVersion)
    {
        bSuccess=PrintString(hdc,lprcPage,uRightAlign,wGPCVersion?
            IDS_TP_VERSIONANDGPC:IDS_TP_VERSIONONLY,
            lpFile,lpVersion,HIBYTE(wGPCVersion),LOBYTE(wGPCVersion));
    }
    else
    {
        bSuccess=PrintString(hdc,lprcPage,uRightAlign,wGPCVersion?
            IDS_TP_GPCONLY:IDS_TP_NOVERSIONINFO,
            lpFile,wGPCVersion);
    }

    FreeMem(lpData);

    return bSuccess;
}


/*++

Routine Name:

    EndTestPageDlgProc

Routine Description:

    Ask the user if the test pages was printed correctly.

Arguments:

    Normal window proc arguments.

Return Value:

    TRUE is message was processed, FALSE if not.

--*/
INT_PTR
CALLBACK
EndTestPageDlgProc(
    IN HWND     hDlg,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    BOOL bStatus = TRUE;

    switch( uMsg ){

    case WM_INITDIALOG:
        {
            SetForegroundWindow( hDlg );
            TCHAR szText[kStrMax+kPrinterBufMax];
            UINT nSize = COUNTOF(szText);
            ConstructPrinterFriendlyName( (LPCTSTR)lParam, szText, &nSize );
            SetWindowText( hDlg, szText );
            break;
        }

    case WM_COMMAND:
        switch( GET_WM_COMMAND_ID( wParam, lParam ) ){

        case IDCANCEL:
        case IDOK:
            EndDialog( hDlg, GET_WM_COMMAND_ID( wParam, lParam ) );
            break;

        default:
            bStatus = FALSE;
            break;
        }

        break;

    default:
        bStatus = FALSE;
    }

    return bStatus;
}

/*++

Routine Name:

    GetPrinterInfo

Routine Description:

    Routine to get the printer info 2 structures from
    the given printer name.

Arguments:

    pszPrinterName = pointer to printer name
    **ppInfo2 - pointer where to return pointer to info 2

Return Value:

    TRUE if both info pointers returned, otherwise FALSE.

--*/
BOOL
bGetPrinterInfo(
    IN LPCTSTR          pszPrinterName,
    IN PRINTER_INFO_2 **ppInfo2,
    IN DRIVER_INFO_3  **ppDrvInfo3
    )
{
    BOOL            bRetval     = FALSE;
    PPRINTER_INFO_2 pInfo2      = NULL;
    PDRIVER_INFO_3  pDrvInfo3   = NULL;
    DWORD           cbInfo      = 0;
    LONG            lResult     = 0;
    TStatusB bStatus( DBG_WARN, ERROR_ACCESS_DENIED, ERROR_INSUFFICIENT_BUFFER );

    //
    // Open the printer.
    //
    HANDLE hPrinter = NULL;
    DWORD dwAccess  = PRINTER_READ;
    TStatus Status( DBG_WARN );
    Status DBGCHK = TPrinter::sOpenPrinter( pszPrinterName,
                                            &dwAccess,
                                            &hPrinter );
    if( Status ){
        goto Cleanup;
    }

    //
    // Get the Printer info 2.
    //
    cbInfo = 0;
    bStatus DBGCHK = VDataRefresh::bGetPrinter( hPrinter,
                                                2,
                                                (PVOID*)&pInfo2,
                                                &cbInfo );
    if( !bStatus ){
        goto Cleanup;
    }

    //
    // Get the driver info 3.
    //
    cbInfo = 0;
    bStatus DBGCHK = VDataRefresh::bGetPrinterDriver( hPrinter,
                                                      NULL,
                                                      3,
                                                      (PVOID*)&pDrvInfo3,
                                                      &cbInfo );
    if( !bStatus ){
        goto Cleanup;
    }

    //
    // Success copy back the info pointers.
    //
    *ppInfo2    = pInfo2;
    *ppDrvInfo3 = pDrvInfo3;
    bRetval     = TRUE;

Cleanup:

    if( hPrinter ){
        ClosePrinter( hPrinter );
    }

    if( !bRetval ){

        FreeMem( pInfo2 );
        FreeMem( pDrvInfo3 );
    }

    return bRetval;
}


/*++

Routine Name:

    GetCurrentTimeAndDate

Routine Description:

    Routine to get the current time and date in a
    formatted string to print on the test page.

Arguments:

    cchText - size in characters of the provided buffer
    pszText - pointer to buffer where to place time and
              date text.

Return Value:

    TRUE is valid and returned in provided buffer, otherwise FALSE.

--*/
BOOL
GetCurrentTimeAndDate(
    IN UINT     cchText,
    IN LPTSTR   pszText
    )
{
    SPLASSERT( cchText );
    SPLASSERT( pszText );

    //
    // Initialy terminate the buffer.
    //
    pszText[0] = 0;

    //
    // Get the current local time.
    //
    SYSTEMTIME LocalTime;
    GetSystemTime( &LocalTime );

    if ( !SystemTimeToTzSpecificLocalTime( NULL,
                                           &LocalTime,
                                           &LocalTime ))
    {
        DBGMSG( DBG_TRACE, ( "SysTimeToTzSpecLocalTime failed %d\n", GetLastError( )));
        return FALSE;
    }

    if( !GetTimeFormat( LOCALE_USER_DEFAULT,
                        0,
                        &LocalTime,
                        NULL,
                        pszText,
                        cchText ))
    {
        DBGMSG( DBG_TRACE, ( "GetTimeFormat failed with %d", GetLastError( )));
        return FALSE;
    }

    _tcscat( pszText, gszSpace );
    cchText = _tcslen( pszText );
    pszText += cchText;

    if( !GetDateFormat( LOCALE_USER_DEFAULT,
                        0,
                        &LocalTime,
                        NULL,
                        pszText,
                        kStrMax - cchText ))
    {
        DBGMSG( DBG_TRACE, ( "GetDateFomat failed with %d\n", GetLastError( )));
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\time.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1998
All rights reserved.

Module Name:

    time.cxx

Abstract:

    time related functions.

Author:

    Steve Kiraly (SteveKi) 18-Dec-1997

--*/

#include "precomp.hxx"
#pragma hdrstop

#include "time.hxx"
#include "persist.hxx"


/*++

Routine Name:

    GetTimeZoneBias

Routine Description:

    Returns the time zone bias.

Arguments:

    Nothing.

Return Value:

    Value of the time zone specific bias.

--*/
LONG
lGetTimeZoneBias(
    VOID
    )
{
    LONG lBias;
    TIME_ZONE_INFORMATION tzi;

    //
    // Get the time zone specific bias.
    //
    switch( GetTimeZoneInformation( &tzi ) ){

    case TIME_ZONE_ID_DAYLIGHT:

        lBias = (tzi.Bias + tzi.DaylightBias);
        break;

    case TIME_ZONE_ID_STANDARD:

        lBias = (tzi.Bias + tzi.StandardBias);
        break;

    case TIME_ZONE_ID_UNKNOWN:			

        lBias = tzi.Bias;
        break;						

    default:
        DBGMSG(DBG_ERROR, ("GetTimeZoneInformation failed: %d\n", GetLastError()));
        lBias = 0;
        break;
    }

    return lBias;

}

/*++

Routine Name:

    SystemTimeToLocalTime

Routine Description:

    Converts the system time in minutes to local time in minutes.

Arguments:

    System time in minutes to convert.

Return Value:

    The converted local time in minutes if sucessful,
    otherwize returns the original system time.

--*/
DWORD
SystemTimeToLocalTime(
    IN DWORD Minutes
    )
{
    //
    // Ensure there is no wrap around.  Add a full day to
    // prevent biases
    //
    Minutes += (24*60);

    //
    // Adjust for bias.
    //
    Minutes -= lGetTimeZoneBias();

    //
    // Now discard extra day.
    //
    Minutes = Minutes % (24*60);

    return Minutes;

}


/*++

Routine Name:

    LocalTimeToSystemTime

Routine Description:

    Converts the local time in minutes to system time in minutes.

Arguments:

    Local time in minutes to convert.

Return Value:

    The converted system time in minutes if sucessful,
    otherwize returns the original local time.

--*/
DWORD
LocalTimeToSystemTime(
    IN DWORD Minutes
    )
{
    //
    // Ensure there is no wrap around.  Add a full day to
    // prevent biases
    //
    Minutes += (24*60);

    //
    // Adjust for bias.
    //
    Minutes += lGetTimeZoneBias();

    //
    // Now discard extra day.
    //
    Minutes = Minutes % (24*60);

    return Minutes;

}

/*++

Routine Name:

    bGetTimeFormatString(

Routine Description:

    Get the time format string for the time picker 
    control without the second specifier.

Arguments:

    Refernece to string class where to return string.

Return Value:

    TRUE format string returned. FALSE error occurred.

--*/
BOOL 
bGetTimeFormatString( 
    IN TString &strFormatString 
    )
{
    //
    // Setup the time picker controls to use a short time format with no seconds.
    //
    TCHAR   szTimeFormat[MAX_PATH]  = {0};
    TCHAR   szTimeSep[MAX_PATH]     = {0};
    LPTSTR  pszTimeFormat           = szTimeFormat;
    BOOL    bStatus                 = FALSE;

    if( GetLocaleInfo( LOCALE_USER_DEFAULT,
                       LOCALE_STIMEFORMAT,
                       szTimeFormat,
                       COUNTOF(szTimeFormat)) &&

        GetLocaleInfo( LOCALE_USER_DEFAULT,
                       LOCALE_STIME,
                       szTimeSep,
                       COUNTOF(szTimeSep)))
    {
        INT cchTimeSep = _tcslen(szTimeSep);

        TCHAR szShortTimeFormat[MAX_PATH];
        LPTSTR pszShortTimeFormat = szShortTimeFormat;

        //
        // Remove the seconds format string and preceeding separator.
        //
        while (*pszTimeFormat)
        {
            if ((*pszTimeFormat != TEXT('s')) && (*pszTimeFormat != TEXT('S')))
            {
                *pszShortTimeFormat++ = *pszTimeFormat;
            }
            else
            {
                *pszShortTimeFormat = TEXT('\0');

                bTrimString(szShortTimeFormat, TEXT(" "));
                bTrimString(szShortTimeFormat, szTimeSep);

                pszShortTimeFormat = szShortTimeFormat + lstrlen(szShortTimeFormat);
            }

            pszTimeFormat++;
        }

        *pszShortTimeFormat = TEXT('\0');

        bStatus = strFormatString.bUpdate( szShortTimeFormat );
    }

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\util.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    Util.cxx

Abstract:

    Misc util functions.

Author:

    Albert Ting (AlbertT)  27-Jan-1995

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#include <shgina.h>
#include "result.hxx"
#include "msgbox.hxx"
#include "spllibex.hxx"
#include "prndata.hxx"

//
// Global functions
//

static MSG_HLPMAP gMsgHelpTable [] =
    {
    { ERROR_INVALID_PRINTER_NAME, IDS_ERR_WITH_HELP1, gszHelpTroubleShooterURL},
    { ERROR_KM_DRIVER_BLOCKED, IDS_COULDNOTCONNECTTOPRINTER_BLOCKED_HELP, gszHelpTroubleShooterURL},
    { 0, 0, 0},
    };

enum
{
    //
    // Not mapped error code.
    // Show up the text from the GetLastError()
    //
    IDS_NOT_MAPPED  =   (UINT )(-1)
};

#define MAKERESOURCEINT(psz) PTR2UINT(psz)

//
// This global error mapping table is proposed to filter out
// the errors that are showed up to the end user to a certain
// well known set, which we have a good explanation for. All the
// rest of the errors will be mapped to the generic error text.
// if the message mapping is IDS_NOT_MAPPED it means the text
// coming from the GetLastError/FormatMessage APIs is good enough
// so we are going to use it. Otherwise the mapping ID is a
// resource id of the remapped text.
//
static MSG_ERRMAP gGlobalErrorMapTable[] =
{

    //
    // Category 1 - Print Spooler Error Codes
    //
    ERROR_UNKNOWN_PRINT_MONITOR,                IDS_NOT_MAPPED,
    ERROR_PRINTER_DRIVER_IN_USE,                IDS_NOT_MAPPED,
    ERROR_SPOOL_FILE_NOT_FOUND,                 IDS_ERRMAP_SPOOL_FILE_NOT_FOUND,
    ERROR_SPL_NO_STARTDOC,                      IDS_ERRMAP_SPL_NO_STARTDOC,
    ERROR_SPL_NO_ADDJOB,                        IDS_ERRMAP_SPL_NO_STARTDOC,
    ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED,    IDS_NOT_MAPPED,
    ERROR_PRINT_MONITOR_ALREADY_INSTALLED,      IDS_NOT_MAPPED,
    ERROR_INVALID_PRINT_MONITOR,                IDS_NOT_MAPPED,
    ERROR_PRINT_MONITOR_IN_USE,                 IDS_NOT_MAPPED,
    ERROR_PRINTER_HAS_JOBS_QUEUED,              IDS_NOT_MAPPED,
    ERROR_SUCCESS_REBOOT_REQUIRED,              IDS_NOT_MAPPED,
    ERROR_SUCCESS_RESTART_REQUIRED,             IDS_NOT_MAPPED,
    ERROR_PRINTER_NOT_FOUND,                    IDS_NOT_MAPPED,

    //
    // Category 2 - Print Subsystem Related Error Codes
    //
    ERROR_OUT_OF_PAPER,                         IDS_NOT_MAPPED,
    ERROR_PRINTQ_FULL,                          IDS_NOT_MAPPED,
    ERROR_NO_SPOOL_SPACE,                       IDS_ERRMAP_NO_SPOOL_SPACE,
    ERROR_PRINT_CANCELLED,                      IDS_NOT_MAPPED,
    ERROR_REDIR_PAUSED,                         IDS_NOT_MAPPED,
    ERROR_PRINTER_DRIVER_ALREADY_INSTALLED,     IDS_NOT_MAPPED,
    ERROR_UNKNOWN_PRINTER_DRIVER,               IDS_ERROR_UNKNOWN_DRIVER,
    ERROR_UNKNOWN_PRINTPROCESSOR,               IDS_ERRMAP_UNKNOWN_PRINTPROCESSOR,
    ERROR_INVALID_PRINTER_NAME,                 IDS_NOT_MAPPED,
    ERROR_PRINTER_ALREADY_EXISTS,               IDS_ERRMAP_PRINTER_ALREADY_EXISTS,
    ERROR_INVALID_PRINTER_COMMAND,              IDS_NOT_MAPPED,
    ERROR_ALREADY_WAITING,                      IDS_NOT_MAPPED,
    ERROR_PRINTER_DELETED,                      IDS_NOT_MAPPED,
    ERROR_INVALID_PRINTER_STATE,                IDS_NOT_MAPPED,
    ERROR_BAD_DRIVER,                           IDS_NOT_MAPPED,

    //
    // Category 3 - Common Win32/RPC
    //
    RPC_S_SERVER_UNAVAILABLE,                   IDS_ERRMAP_RPC_S_SERVER_UNAVAILABLE,
    RPC_S_INVALID_NET_ADDR,                     IDS_NOT_MAPPED,
    ERROR_ACCESS_DENIED,                        IDS_NOT_MAPPED,
    ERROR_DISK_FULL,                            IDS_ERRMAP_DISK_FULL,
    ERROR_NOT_READY,                            IDS_NOT_MAPPED,
    ERROR_DEVICE_NOT_AVAILABLE,                 IDS_NOT_MAPPED,
    ERROR_WRITE_PROTECT,                        IDS_NOT_MAPPED,
    ERROR_SHARING_VIOLATION,                    IDS_NOT_MAPPED,
    ERROR_LOCK_VIOLATION,                       IDS_NOT_MAPPED,
    ERROR_HANDLE_DISK_FULL,                     IDS_ERRMAP_DISK_FULL,
    ERROR_NETWORK_BUSY,                         IDS_NOT_MAPPED,
    ERROR_NETWORK_ACCESS_DENIED,                IDS_ERRMAP_NETWORK_ACCESS_DENIED,
    ERROR_NETNAME_DELETED,                      IDS_NOT_MAPPED,
    ERROR_CANNOT_MAKE,                          IDS_NOT_MAPPED,
    ERROR_NET_WRITE_FAULT,                      IDS_ERRMAP_NET_WRITE_FAULT,
    ERROR_INVALID_PASSWORD,                     IDS_NOT_MAPPED,
    ERROR_NOT_SUPPORTED,                        IDS_ERRMAP_NOT_SUPPORTED,
    ERROR_OUTOFMEMORY,                          IDS_ERRMAP_OUTOFMEMORY,
    ERROR_NOT_ENOUGH_MEMORY,                    IDS_ERRMAP_OUTOFMEMORY,
    ERROR_CANCELLED,                            IDS_NOT_MAPPED,
    ERROR_BAD_DRIVER,                           IDS_NOT_MAPPED,
    ERROR_DRIVE_LOCKED,                         IDS_NOT_MAPPED,
    ERROR_DEV_NOT_EXIST,                        IDS_NOT_MAPPED,
    ERROR_OPEN_FAILED,                          IDS_NOT_MAPPED,
    ERROR_DEVICE_DOOR_OPEN,                     IDS_NOT_MAPPED,
    ERROR_BAD_DEVICE,                           IDS_NOT_MAPPED,
    ERROR_INVALID_PROFILE,                      IDS_NOT_MAPPED,
    ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE,   IDS_NOT_MAPPED,
    ERROR_PROFILE_NOT_FOUND,                    IDS_NOT_MAPPED,
    ERROR_DEVICE_NOT_AVAILABLE,                 IDS_NOT_MAPPED,
    ERROR_NO_MEDIA_IN_DRIVE,                    IDS_NOT_MAPPED,
    ERROR_UNRECOGNIZED_MEDIA,                   IDS_NOT_MAPPED,
    ERROR_MEDIA_NOT_AVAILABLE,                  IDS_NOT_MAPPED,
    ERROR_UNKNOWN_PORT,                         IDS_NOT_MAPPED,
    ERROR_FILE_CORRUPT,                         IDS_ERRMAP_FILE_CORRUPT,
    ERROR_DISK_CORRUPT,                         IDS_NOT_MAPPED,
    ERROR_ALREADY_EXISTS,                       IDS_NOT_MAPPED,
    ERROR_KM_DRIVER_BLOCKED,                    IDS_NOT_MAPPED,
    ERROR_PRINTER_DRIVER_BLOCKED,               IDS_PRINTER_DRIVER_BLOCKED,
    ERROR_REQ_NOT_ACCEP,                        IDS_NOT_MAPPED,

    // end of the table
    0, 0

}; // gGlobalErrorMapTable

inline static HRESULT CreateError()
{
    DWORD dw = GetLastError();
    if (ERROR_SUCCESS == dw) return E_FAIL;
    return HRESULT_FROM_WIN32(dw);
}

LPTSTR
pszStrCat(
    IN OUT LPTSTR pszDest,
       OUT LPCTSTR pszSource, OPTIONAL
    IN OUT UINT& cchDest
    )

/*++

Routine Description:

    Copies pszSource to pszDest iff there is enough space in cchDest.

Arguments:

    pszDest - Destination buffer

    pszSource - Source string, may be NULL (no action taken)

    cchDest - char count size of pszDest, on return, space remaining

Return Value:

    LPTSTR - pointer to remaining space
    NULL - out of space.

--*/

{
    if( !pszSource ){
        return pszDest;
    }

    UINT cchSource = lstrlen( pszSource );

    //
    // Fail if dest can't hold source (equal case doesn't hold NULL term)
    // OR dest string is NULL.
    //
    if( !pszDest || cchDest <= cchSource + 1 ){
        return pszDest;
    }

    lstrcpy( pszDest, pszSource );
    cchDest -= cchSource;

    return pszDest + cchSource;
}


INT
iMessage(
    IN HWND                 hwnd,
    IN UINT                 idsTitle,
    IN UINT                 idsMessage,
    IN UINT                 uType,
    IN DWORD                dwLastError,
    IN const PMSG_ERRMAP    pMsgErrMap,
    ...
    )
/*++

Routine Description:

    Formats error message.

Arguments:

    See Internal_Message for details

Return Value:

    returns value from MessageBox on sucess
    and zero on failure

--*/
{
    va_list valist;
    va_start(valist, pMsgErrMap);

    INT iRetval = 0;
    if( FAILED(Internal_Message(&iRetval,
                                ghInst,
                                hwnd,
                                MAKEINTRESOURCE(idsTitle),
                                MAKEINTRESOURCE(idsMessage),
                                uType,
                                dwLastError,
                                pMsgErrMap,
                                NULL,
                                0,
                                valist)) )
    {
        // make sure we return zero in the failure case
        iRetval = 0;
    }

    va_end(valist);
    return iRetval;
}

INT
iMessage2(
    IN HWND    hwnd,
    IN LPCTSTR pszTitle,
    IN LPCTSTR pszMessage,
    IN UINT    uType,
    IN DWORD   dwLastError,
    IN const   PMSG_ERRMAP pMsgErrMap
    ...
    )
/*++

Routine Description:

    Formats error message.

Arguments:

    See Internal_Message for details
    pszTitle and pszMessage can be resource IDs i.e. MAKEINTRESOURCE(id)

Return Value:

    returns value from MessageBox on sucess
    and zero on failure

--*/
{
    va_list valist;
    va_start(valist, pMsgErrMap);

    INT iRetval = 0;
    if( FAILED(Internal_Message(&iRetval,
                                ghInst,
                                hwnd,
                                pszTitle,
                                pszMessage,
                                uType,
                                dwLastError,
                                pMsgErrMap,
                                NULL,
                                0,
                                valist)) )
    {
        // make sure we return zero in the failure case
        iRetval = 0;
    }

    va_end(valist);
    return iRetval;
}

INT
iMessageEx(
    IN HWND                 hwnd,
    IN UINT                 idsTitle,
    IN UINT                 idsMessage,
    IN UINT                 uType,
    IN DWORD                dwLastError,
    IN const PMSG_ERRMAP    pMsgErrMap,
    IN UINT                 idMessage,
    IN const PMSG_HLPMAP    pHlpErrMap,
    ...
    )
/*++

Routine Description:

    Formats error message.

Arguments:

    See Internal_Message for details

Return Value:

    returns value from MessageBox on sucess
    and zero on failure

--*/
{
    va_list valist;
    va_start(valist, pHlpErrMap);

    INT iRetval = 0;
    if( FAILED(Internal_Message(&iRetval,
                                 ghInst,
                                 hwnd,
                                 MAKEINTRESOURCE(idsTitle),
                                 MAKEINTRESOURCE(idsMessage),
                                 uType,
                                 dwLastError,
                                 pMsgErrMap,
                                 idMessage,
                                 pHlpErrMap,
                                 valist)) )
    {
        // make sure we return zero in the failure case
        iRetval = 0;
    }

    va_end(valist);
    return iRetval;
}


HRESULT
Internal_Message(
    OUT INT                     *piResult,
    IN  HINSTANCE               hModule,
    IN  HWND                    hwnd,
    IN  LPCTSTR                 pszTitle,
    IN  LPCTSTR                 pszMessage,
    IN  UINT                    uType,
    IN  DWORD                   dwLastError,
    IN  const PMSG_ERRMAP       pMsgErrMap,
    IN  UINT                    idHlpMessage,
    IN  const PMSG_HLPMAP       pHlpErrMap,
    IN  va_list                 valist
    )
/*++

Routine Description:

    Formats error message.

Arguments:

    piResult    - the message box return value (on success)

    hModule     - module where to load the resources from

    hwnd        - Parent windows.  This only be NULL if there is a synchronous
                  error (an error that occurs immediately after a user action).
                  If it is NULL, then we set it to foreground.

    pszTitle    - Title of message box. Can be a resource ID i.e. MAKEINTRESOURCE(id)

    pszMessage  - Message text.  May have inserts. Can be a resource ID too.

    uType       - Type of message box.  See MessageBox api.

    dwLastError - 0 indicates don't cat error string onto end of message text
                  kMsgGetLastError: Use GetLastError(). Other: format to LastError
                  text.

    pMsgErrMap  - Translate some error messages into friendlier text.
                  May be NULL.

    idMessage   - Help message ids to look for in the help message map.

    pHlpErrMap  - Pointer to error message map where look, If a match
                  is found in this map then the help button will be
                  displayed on the message box. May be MULL

    ... extra parameters to idsMessage follow.

Return Value:

    S_OK on success and COM error on failure

--*/

{
    TStatusB    bStatus;
    TString     strMappedMessage;
    TString     strMsgTemplate;
    TString     strMessage;
    TString     strTitle;
    INT         iResult = 0;
    BOOL        bFormatNeeded       = FALSE;
    MSG_HLPMAP  *pHelpMapEntry      = NULL;
    MSG_ERRMAP  *pErrMapEntry       = NULL;
    UINT        idsTitle            = IDS_NOT_MAPPED;
    UINT        idsMessage          = IDS_NOT_MAPPED;
    HRESULT     hr                  = S_OK;

    if( NULL == hModule )
    {
        hModule = ghInst;
    }

    HINSTANCE hInstTitle = hModule,
              hInstMessage = hModule;

    if( NULL == pszTitle )
    {
        pszTitle = MAKEINTRESOURCE(IDS_PRINTERS_TITLE);
        hInstTitle = ghInst;
    }

    if( NULL == pszMessage )
    {
        pszMessage = MAKEINTRESOURCE(IDS_ERR_GENERIC);
        hInstMessage = ghInst;
    }

    // first load the title and format strings and
    // then format the string with any following aguments.

    if( SUCCEEDED(hr) && IS_INTRESOURCE(pszTitle) )
    {
        idsTitle = MAKERESOURCEINT(pszTitle);
        bStatus DBGCHK = strTitle.bLoadString(hInstTitle, idsTitle);
        pszTitle = strTitle;

        if( !bStatus )
        {
            hr = CreateError();
        }
    }

    if( SUCCEEDED(hr) && IS_INTRESOURCE(pszMessage) )
    {
        idsMessage = MAKERESOURCEINT(pszMessage);
        bStatus DBGCHK = strMsgTemplate.bLoadString(hInstMessage, idsMessage);
        pszMessage = strMsgTemplate;

        if( !bStatus )
        {
            hr = CreateError();
        }
    }

    if( SUCCEEDED(hr) )
    {
        bStatus DBGCHK = strMessage.bvFormat(pszMessage, valist);

        if( !bStatus )
        {
            hr = CreateError();
        }
    }

    if( SUCCEEDED(hr) )
    {
        // check to see if last error format is needed
        switch( dwLastError )
        {
        case kMsgGetLastError:

            //
            // Get the last error.
            //
            dwLastError = GetLastError();

            //
            // If for some reason there wasn't an error code, don't
            // append the error string.
            //
            bFormatNeeded = !!dwLastError;
            break;

        case kMsgNone:

            //
            // No format message needed.
            //
            bFormatNeeded = FALSE;
            break;

        default:

            //
            // Format needed, use provided error value.
            //
            bFormatNeeded = TRUE;
            break;
        }

        if( bFormatNeeded )
        {
            //
            // If there was a help message map passed then look up the id in this
            // help message map, note this call does not use the last error for finding a match
            //
            if( bLookupHelpMessageMap(pHlpErrMap, idHlpMessage, &pHelpMapEntry) )
            {
                //
                // Extract the message string from the resource file.
                //
                bStatus DBGCHK = strMappedMessage.bLoadString(ghInst, pHelpMapEntry->uIdMessage);

                //
                // Indicate the message box should have the help button on it.
                //
                uType |= MB_HELP;
            }

            //
            // If there was not a remapped message then lookup this error value
            // to see if this message has help remapped to it.
            //
            else if( bLookupHelpMessageMap( gMsgHelpTable, dwLastError, &pHelpMapEntry ) )
            {
                //
                // Extract the message string from the resource file.
                //
                bStatus DBGCHK = strMappedMessage.bLoadString(ghInst, pHelpMapEntry->uIdMessage);

                //
                // Indicate the message box should have the help button on it.
                //
                uType |= MB_HELP;
            }

            //
            // Check if this last error has a remapped message in the provided message map.
            //
            else if( bLookupErrorMessageMap( pMsgErrMap, dwLastError, &pErrMapEntry ) )
            {
                //
                // Extract the message string from the resource file.
                //
                bStatus DBGCHK = strMappedMessage.bLoadString(ghInst, pErrMapEntry->idsString);
            }

            //
            // Check if this last error is a known error or the error code is pretty
            // useless for the end users (like "Invalid Handle"), so we need to re-map
            // the text to a generic error message.
            //
            else if( bLookupErrorMessageMap( gGlobalErrorMapTable, dwLastError, &pErrMapEntry ) )
            {
                if( CMsgBoxCounter::GetMsg() )
                {
                    // we have a message ID set based on the context where command
                    // gets executed - use this message ID instead the defaults
                    bStatus DBGCHK = strMappedMessage.bLoadString(ghInst, CMsgBoxCounter::GetMsg());
                }
                else if( IDS_NOT_MAPPED == pErrMapEntry->idsString )
                {
                    //
                    // The error text, which is coming from the GetLastError/FormatMessage
                    // APIs is good enough for this error, so we are going to use it. Just get
                    // the error string from the FormatMessage API.
                    //
                    TResult result(dwLastError);
                    if( VALID_OBJ(result) )
                    {
                        bStatus DBGCHK = result.bGetErrorString(strMappedMessage);
                    }
                }
                else
                {
                    //
                    // This error message is re-mapped to a better text. - Just
                    // load the re-mapped message string from the resource file.
                    //
                    bStatus DBGCHK = strMappedMessage.bLoadString(ghInst, pErrMapEntry->idsString);
                }
            }
            else
            {
                if( IDS_ERR_GENERIC != idsMessage )
                {
                    //
                    // This error code is unknown or useless to be displayed
                    // to the end user. Just load the generic error text string
                    // in this case.
                    //
                    bStatus DBGCHK = strMappedMessage.bLoadString(ghInst, IDS_ERR_GENERIC);
                }
            }

            if( !bStatus )
            {
                hr = CreateError();
            }

            if( SUCCEEDED(hr) && !strMappedMessage.bEmpty() )
            {
                //
                // Tack on the mapped, help or error string, with a two space separator.
                //
                bStatus DBGCHK = strMessage.bCat(TEXT(" ")) &&
                                 strMessage.bCat(strMappedMessage);

                if( !bStatus )
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        // if succeeded - show up the message box
        if( SUCCEEDED(hr) )
        {
            if( FAILED(GetCurrentThreadLastPopup(&hwnd)) )
            {
                // if the parent is going to be NULL then push in foreground
                uType |= MB_SETFOREGROUND;
            }

            // display the message box.
            iResult = PrintUIMessageBox(hwnd, strMessage, pszTitle, uType, UtilHelpCallback, pHelpMapEntry);

            // log this messsage into the message box counter
            CMsgBoxCounter::LogMessage(uType);
        }
    }

    if( SUCCEEDED(hr) && piResult )
    {
        *piResult = iResult;
    }

    return hr;
}

BOOL
WINAPI
UtilHelpCallback(
    IN HWND     hwnd,
    IN PVOID    pVoid
    )
/*++

Routine Name:

    UtilHelpCallback

Routine Description:

    This routine is the called back that is called when a
    message box is displayed with a help button and the user
    clicks on the help button.

Arguments:

    hwnd        - handle to windows that recieved the WM_HELP message.
    pVoid       - pointer to the user data passsed in the call to
                  PrintUIMessageBox.  The client can store any value
                  in this paramter.

Return Value:

    TRUE callback was successful, FALSE some error occurred.

--*/

{
    DBGMSG( DBG_TRACE, ( "UtilHelpCallback\n") );

    //
    // Get a usable pointer to the help map entry.
    //
    MSG_HLPMAP *pHelpMapEntry = reinterpret_cast<MSG_HLPMAP *>( pVoid );


    if (pHelpMapEntry)
    {
        //
        // Invoke troubleshooter for this topic
        //
        DWORD_PTR dwRet = (DWORD_PTR)ShellExecute(hwnd, gszOpen,
                                                  TEXT("helpctr.exe"),
                                                  pHelpMapEntry->pszHelpFile,
                                                  NULL,
                                                  SW_SHOWNORMAL);
        return dwRet > 32;
    }
    else
    {
        DBGMSG( DBG_ERROR, ( "UtilHelpCallback (pVoid == NULL)\n") );
        return FALSE;
    }
}


VOID
vShowResourceError(
    HWND hwnd
    )
{
    //
    // Show up the generic error message here.
    //
    vShowUnexpectedError(hwnd, IDS_PRINTERS_TITLE);
}

VOID
vShowUnexpectedError(
    HWND hwnd,
    UINT idsTitle
    )
{
    iMessage( hwnd,
              idsTitle,
              IDS_ERR_GENERIC,
              MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
              kMsgGetLastError,
              NULL );
}

VOID
vPrinterSplitFullName(
    IN LPTSTR pszScratch,
    IN LPCTSTR pszFullName,
    IN LPCTSTR *ppszServer,
    IN LPCTSTR *ppszPrinter
    )

/*++

Routine Description:

    Splits a fully qualified printer connection name into server and
    printer name parts.

Arguments:

    pszScratch - Scratch buffer used to store output strings.  Must
        be MAXNAMELENBUFFER in size.

    pszFullName - Input name of a printer.  If it is a printer
        connection (\\server\printer), then we will split it.  If
        it is a true local printer (not a masq) then the server is
        szNULL.

    ppszServer - Receives pointer to the server string.  If it is a
        local printer, szNULL is returned.

    ppszPrinter - Receives a pointer to the printer string.  OPTIONAL

Return Value:

--*/

{
    LPTSTR pszPrinter;

    lstrcpyn(pszScratch, pszFullName, kPrinterBufMax);

    if (pszFullName[0] != TEXT('\\') || pszFullName[1] != TEXT('\\'))
    {
        //
        // Set *ppszServer to szNULL since it's the local machine.
        //
        *ppszServer = gszNULL;
        pszPrinter = pszScratch;
    }
    else
    {
        *ppszServer = pszScratch;
        pszPrinter = _tcschr(*ppszServer + 2, TEXT('\\'));

        if (!pszPrinter)
        {
            //
            // We've encountered a printer called "\\server"
            // (only two backslashes in the string).  We'll treat
            // it as a local printer.  We should never hit this,
            // but the spooler doesn't enforce this.  We won't
            // format the string.  Server is local, so set to szNULL.
            //
            pszPrinter = pszScratch;
            *ppszServer = gszNULL;
        }
        else
        {
            //
            // We found the third backslash; null terminate our
            // copy and set bRemote TRUE to format the string.
            //
            *pszPrinter++ = 0;
        }
    }

    if (ppszPrinter)
    {
        *ppszPrinter = pszPrinter;
    }
}

BOOL
bBuildFullPrinterName(
    IN LPCTSTR pszServer,
    IN LPCTSTR pszPrinterName,
    IN TString &strFullName
    )

/*++

Routine Description:

    Builds a fully qualified printer name from a server name
    and a printer name.

Arguments:

    pszServer       - Pointer to server name, if this parameter is null
                      the machine name is used.  If this parameter is non
                      null it is assumed it is a server name of the form
                      \\server including the leading wacks.

    pszPrinterName  - Pointer to printer name.  This parameter must be a
                      a valid string.

    strFullName     - Reference where to return full printer name.

Return Value:

    TRUE strFullName contains a full printer name, FALSE error.

--*/
{
    SPLASSERT( pszPrinterName );

    TStatusB bStatus;
    bStatus DBGNOCHK = TRUE;

    bStatus DBGCHK = strFullName.bUpdate( NULL );

    //
    // If the printer name is already fully qualified then do
    // not prepend the server name.
    //
    if( bStatus && *(pszPrinterName+0) != TEXT('\\') && *(pszPrinterName+1) != TEXT('\\') )
    {
        //
        // If the server name is null, get the current machine name.
        //
        if( !pszServer || !*pszServer )
        {
            bStatus DBGCHK = bGetMachineName( strFullName, FALSE );
        }
        else
        {
            bStatus DBGCHK = strFullName.bUpdate( pszServer );
        }

        //
        // Append the wack separator.
        //
        if( bStatus )
        {
            bStatus DBGCHK = strFullName.bCat( gszWack );
        }
    }

    //
    // Append the printer name or copy the already fully qualified printer name.
    //
    if( bStatus )
    {
        bStatus DBGCHK = strFullName.bCat( pszPrinterName );
    }

    return bStatus;
}

/*++

    bGetMachineName

Routine Description:

    Get the machine name if the local machine.

Arguments:

    String to return machine name.
    Flag TRUE do not add leading slashes, FALSE add leading slashes.

Return Value:

    TRUE machine name returned.

--*/
BOOL
bGetMachineName(
    IN OUT TString &strMachineName,
    IN BOOL bNoLeadingSlashes
    )
{
    TCHAR szBuffer[2 + MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwBufferSize;
    BOOL bStatus = FALSE;
    DWORD dwSizeAdjust = 0;

    //
    // Prepend with the wack wack.
    //
    if( !bNoLeadingSlashes ){
        szBuffer[0] = TEXT( '\\' );
        szBuffer[1] = TEXT( '\\' );
        dwSizeAdjust = 2;
    }

    //
    // Get the computer name.
    //
    dwBufferSize = COUNTOF( szBuffer ) - dwSizeAdjust;
    if( GetComputerName( szBuffer+dwSizeAdjust, &dwBufferSize ) ){
        bStatus = strMachineName.bUpdate( szBuffer );
    }

    return bStatus;

}

/*++

    NewFriendlyName

Routine Description:

    Create a new (and unique) friendly name

Arguments:

    pszServerName   - print server name
    lpBaseName      - base printer name
    lpNewName       - new printer name is base name is not unique

    pwInstance      - [in,out],

                        if NULL (this is by default) then:
                            [in]  - assume instance equals to zero
                            [out] - <NA> (don't care)

                        if not NULL then:
                            [in]  - instance to start from
                            [out] - instance choosen

Return Value:

    TRUE if lpFriendlyName recevies new unique name, FALSE if not

--*/
BOOL
NewFriendlyName(
    IN LPCTSTR pszServerName,
    IN LPCTSTR lpBaseName,
    IN LPTSTR lpNewName,
    IN OUT WORD *pwInstance
    )
{
    TCHAR szTestName[kPrinterBufMax];
    WORD wCount                     = 0;
    DWORD cPrinterInfo2             = 0;
    DWORD cbPrinterInfo2            = 0;
    PRINTER_INFO_2 *pPrinterInfo2   = NULL;
    BOOL bStatus                    = FALSE;
    TStatusB bEnumStatus;

    if( pwInstance ){
        wCount = *pwInstance;
    }

    //
    // Enumerate the current printers.
    //
    bEnumStatus DBGCHK = VDataRefresh::bEnumPrinters(
                            PRINTER_ENUM_NAME,
                            (LPTSTR)pszServerName,
                            2,
                            (PVOID *)&pPrinterInfo2,
                            &cbPrinterInfo2,
                            &cPrinterInfo2 );
    //
    // Failure enumerating printers.
    //
    if( !bEnumStatus ){
        DBGMSG( DBG_WARN, ( "Error enumerating printers.\n" ) );
        bStatus = FALSE;
        goto Cleanup;
    }

    //
    // Set upper limit of 1000 tries, just to avoid hanging forever
    //
    bStatus = FALSE;
    for( ; wCount < 1000; wCount++ ){

        if( CreateUniqueName( szTestName, COUNTOF(szTestName), lpBaseName, wCount )){

            LPCTSTR pszName;
            BOOL bFound = FALSE;

            for ( UINT i = 0; i < cPrinterInfo2; i++ ){

                pszName = pPrinterInfo2[i].pPrinterName;

                //
                // Strip the server name if not the local machine.
                //
                if( pszServerName ){

                    if( pszName[0] == TEXT( '\\' ) &&
                        pszName[1] == TEXT( '\\' ) ){

                        pszName = _tcschr( &pszName[2], TEXT( '\\' ) );

                        if( !pszName ){
                            pszName = pPrinterInfo2[i].pPrinterName;
                        } else {
                            pszName += 1;
                        }
                    }
                }

                //
                // If name matches indicate found and continue trying to
                // create a unique name.
                //
                if( !lstrcmpi( szTestName, pszName ) ){
                    bFound = TRUE;
                    break;
                }

                //
                // Check if there is a printer share name that matches and
                // if so continue trying to create a unique name.
                //
                if( pPrinterInfo2[i].pShareName &&
                    pPrinterInfo2[i].pShareName[0] &&
                    !lstrcmpi( szTestName, pPrinterInfo2[i].pShareName ) ){
                    bFound = TRUE;
                    break;
                }
            }

            //
            // If a unique name was found and this was not the
            // first time trough the loop copy the new unique name
            // to the provided buffer.
            //
            if( bFound == FALSE ) {
                if( wCount != 0 ){
                    lstrcpyn( lpNewName, szTestName, kPrinterBufMax );
                    bStatus = TRUE;
                }
                break;
            }
        }
    }

    //
    // Insure we clean up.
    //
Cleanup:

    if( pPrinterInfo2 ){

        DBGMSG( DBG_TRACE, ( "Releaseing printer info 2 memory.\n" ) );
        FreeMem( pPrinterInfo2 );
    }

    if( pwInstance ){
        *pwInstance = wCount;
    }

    return bStatus;
}


/*++

    CreateUniqueName

Routine Description:

    Create a unique friendly name for this printer. If wInstance
    is 0, just copy the name over. Otherwise, play some games
    with truncating the name so it will fit.

Arguments:

    lpDest          - destination buffer
    cchMaxChars     - max number of chars in lpDest
    lpBaseName      - base printer name
    wInstance       - the instance number

Return Value:

    TRUE if we created a name, FALSE if something went wrong

Note:

    This code is from msprint2.dll! we should match their naming scheme.

--*/
BOOL
CreateUniqueName(
    IN LPTSTR lpDest,
    IN UINT cchMaxChars,
    IN LPCTSTR lpBaseName,
    IN WORD wInstance
    )
{
    BOOL bRet = FALSE;

    if (wInstance)
    {
        // We want to provide a fully localizable way to create a
        // unique friendly name for each instance. We start with
        // a single string from the resource, and call wsprintf
        // twice, getting something like this:
        //
        // "%%s (Copy %u)"             From resource
        // "%s (Copy 2)"               After first wsprintf
        // "Foobar Laser (Copy 2)"     After second wsprintf
        //
        // We can't make a single wsprintf call, since it has no
        // concept of limiting the string size. We truncate the
        // model name (in a DBCS-aware fashion) to the appropriate
        // size, so the whole string fits in kPrinterBufMax bytes. This
        // may cause some name truncation, but only in cases where
        // the model name is extremely long.

        CAutoPtrArray<TCHAR> spszFormat1 = new TCHAR[kPrinterBufMax];
        CAutoPtrArray<TCHAR> spszFormat2 = new TCHAR[kPrinterBufMax];

        if (spszFormat1 && spszFormat2)
        {
            if (LoadString(ghInst, IDS_PRTPROP_UNIQUE_FORMAT, spszFormat1, kPrinterBufMax))
            {
                // wFormatLength is length of format string before inserting
                // the model name. Subtract 2 to remove the "%s", and add
                // 1 to compensate for the terminating NULL, which is
                // counted in the total buffer length, but not the string length

                wnsprintf(spszFormat2, kPrinterBufMax, spszFormat1, wInstance);
                wnsprintf(lpDest, cchMaxChars, spszFormat2, lpBaseName);
                bRet = TRUE;
            }
        }
        else
        {
            // some of the allocations failed
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }
    else
    {
        // if wInstance is zero then just copy lpBaseName to lpDest
        lstrcpyn(lpDest, lpBaseName, cchMaxChars);
        bRet = TRUE;
    }

    return bRet;
}


/*++

    bSplitPath

Routine Description:

    splits a file path in to the path and file component.

Arguments:

    pszScratch      - pointer to sratch buffer, must be minimum max path.
    ppszFile        - pointer where to return file pointer, may be null.
    ppszPath        - pointer where to return path pointer, may be null.
    ppszExt         - pointer where to return ext pointer, may be null.
    pszFull         - pointer to fully qualified path\file

Return Value:

    TRUE file and path part split.

--*/
BOOL
bSplitPath(
    IN LPTSTR   pszScratch,
    IN LPCTSTR *ppszFile,
    IN LPCTSTR *ppszPath,
    IN LPCTSTR *ppszExt,
    IN LPCTSTR  pszFull
    )
{
    SPLASSERT( pszScratch );
    SPLASSERT( pszFull );

    BOOL bStatus    = FALSE;

    if( ppszFile )
        *ppszFile = NULL;

    if( ppszPath )
        *ppszPath = NULL;

    if( ppszExt )
        *ppszExt = NULL;

    if( pszScratch && pszFull )
    {
        _tcscpy( pszScratch, pszFull );

        //
        // Full is of the form d:\test
        //
        LPTSTR pszFile = _tcsrchr( pszScratch, TEXT('\\') );

        //
        // Full is of the form d:test
        //
        if( !pszFile )
        {
            pszFile = _tcsrchr( pszScratch, TEXT(':') );
        }

        if( pszFile )
        {
            *pszFile++ = NULL;

            //
            // Locate the file extension.
            //
            if( ppszExt )
            {
                LPTSTR pszExt = _tcsrchr( pszFile, TEXT('.') );

                if( pszExt )
                {
                    *ppszExt = pszExt + 1;
                }
            }

            if( ppszFile )
                *ppszFile = pszFile;

            if( ppszPath )
                *ppszPath = pszScratch;
        }

        //
        // Success.
        //
        bStatus = TRUE;
    }

    return bStatus;

}

/*++

    bCopyMultizString

Routine Description:

    Copies a multiz string.

Arguments:

    ppszCopy         - pointer where to return multiz string copy.
    pszMultizString  - pointer to multiz string.

Return Value:

    TRUE success, FALSE copy multiz string failed, out of memory etc.

--*/

BOOL
bCopyMultizString(
    IN LPTSTR *ppszMultizCopy,
    IN LPCTSTR pszMultizString
    )
{
    SPLASSERT( ppszMultizCopy );

    BOOL bStatus = TRUE;

    if( pszMultizString )
    {
        //
        // Calculate the length of the multiz string.
        //
        for( LPCTSTR psz = pszMultizString; psz && *psz; psz += _tcslen( psz ) + 1 );

        UINT uSize = (UINT)(psz - pszMultizString) + 1;

        if( uSize )
        {
            //
            // Alocate the new multiz string.
            //
            *ppszMultizCopy = new TCHAR[uSize];

            if( *ppszMultizCopy )
            {
                CopyMemory( *ppszMultizCopy, pszMultizString, uSize * sizeof( TCHAR ) );
            }
            else
            {
                bStatus = FALSE;
            }
        }
    }
    else
    {
        *ppszMultizCopy = NULL;
    }

    return bStatus;
}

/*++

Name:

    vStripTrailWhiteSpace

Routine Description:

    Strips trailing white space in a single forward scan.

Arguments:

    pszString - Pointer to a null terminated string.

Return Value:

    Nothing.

Notes:

    The string is modified in place.

--*/
VOID
vStripTrailWhiteSpace(
    IN      LPTSTR  pszString
    )
{
    for( LPTSTR pBlank = NULL; pszString && *pszString; ++pszString )
    {
        if( *pszString == TEXT(' ') )
            pBlank = pBlank == NULL ? pszString : pBlank;
        else
            pBlank = NULL;
    }
    if( pBlank )
    {
        *pBlank = 0;
    }
}

/*++

Routine Name:

    bTrimString

Routine Description:

    Trim the string pszTrimMe of any leading or trailing
    characters that are in pszTrimChars.

Return Value:

    TRUE if anything was stripped

--*/
BOOL
bTrimString(
    IN OUT LPTSTR  pszTrimMe,
    IN     LPCTSTR pszTrimChars
    )
{
    BOOL bRet = FALSE;
    LPTSTR psz;
    LPTSTR pszStartMeat;
    LPTSTR pszMark = NULL;

    SPLASSERT(pszTrimMe);
    SPLASSERT(pszTrimChars);

    if (pszTrimMe)
    {
        //
        // Trim leading characters.
        //
        psz = pszTrimMe;

        while (*psz && _tcschr(pszTrimChars, *psz))
            psz++;

        pszStartMeat = psz;

        //
        //  Trim trailing characters.
        //
        while (*psz)
        {
            if (_tcschr(pszTrimChars, *psz))
            {
                if (!pszMark)
                {
                    pszMark = psz;
                }
            }
            else
            {
                pszMark = NULL;
            }

            psz++;
        }

        //
        // Any trailing characters to clip?
        //
        if (pszMark)
        {
            *pszMark = '\0';
            bRet = TRUE;
        }

        //
        // Relocate stripped string.
        //
        if (pszStartMeat > pszTrimMe)
        {
            //
            // (+ 1) for null terminator.
            //
            MoveMemory(pszTrimMe, pszStartMeat, (_tcslen(pszStartMeat) + 1) * sizeof(TCHAR));
            bRet = TRUE;
        }
        else
        {
            SPLASSERT(pszStartMeat == pszTrimMe);
        }

        SPLASSERT(pszTrimMe);
    }

    return bRet;
}

/*++

Routine Name:

    bIsRemote

Routine Description:

    Determines if the specified name is a
    remote machine or local machine name.

Arguments:

    pszString - Pointer to string which contains the machine name.

Return Value:

    TRUE machine name is a remote machine name, FALSE local machine name.

--*/
BOOL
bIsRemote(
    IN LPCTSTR pszName
    )
{
    BOOL bRetval = FALSE;

    //
    // Null pointer or null string is assumed to be
    // the local machine. (Spooler's definition)
    //
    if( !pszName || !*pszName )
    {
        return bRetval;
    }

    //
    // Get the local machines name.
    //
    TString strLocalName;
    if( !bGetMachineName( strLocalName, TRUE ) )
    {
        DBGMSG( DBG_ERROR, ("bIsRemote::bGetMachineName Failed!") );
        return bRetval;
    }

    //
    // If the provided name has leading '\\' then compare with
    // '\\' else point to just after the '\\' and compare.
    //
    if( *(pszName+0) == TEXT('\\') && *(pszName+1) == TEXT('\\') )
    {
        pszName += 2;
    }

    //
    // If the machine names are different then the provided
    // name is assumed to be a remote machine.
    //
    if( _tcsicmp( pszName, strLocalName ) )
    {
        bRetval = TRUE;
    }

    return bRetval;
}

BOOL
bLookupErrorMessageMap(
    IN      const PMSG_ERRMAP   pMsgErrMap,
    IN      DWORD               dwLastError,
    IN OUT  MSG_ERRMAP        **ppErrMapEntry
    )
/*++

Routine Name:

    bLookupErrorMessageMap

Routine Description:

    Scanns the error message map for a matching
    last error.  If the message is found in the map
    the string is returned in the specified string
    mapped message object.

Arguments:

    pMsgErrMap          - pointer to error message map
    dwLastError         - last error to look for in error message map
    ppErrMapEntry       - pointer to error map entry where match was found

Return Value:

    TRUE success, FALSE error occurred.

--*/
{
    BOOL bStatus = FALSE;

    //
    // If there is a message map, use it.
    //
    if( pMsgErrMap )
    {
        for( UINT i = 0; pMsgErrMap[i].dwError; i++ )
        {
            //
            // If we have a matching error, then return a pointer to this entry.
            //
            if( dwLastError == pMsgErrMap[i].dwError )
            {
                *ppErrMapEntry = &pMsgErrMap[i];
                bStatus = TRUE;
                break;
            }
        }
    }

    return bStatus;
}

BOOL
bLookupHelpMessageMap(
    IN      const PMSG_HLPMAP   pMsgHlpMap,
    IN      DWORD               dwLastError,
    IN OUT  MSG_HLPMAP        **ppHelpMapEntry
    )
/*++

Routine Name:

    bLookupHelpMessageMap

Routine Description:

    Scans the error message map for a matching
    last error.  If the message is found in the map
    the string is returned in the specified string
    object.

Arguments:

    pMsgHlpMap          - pointer to help error message map
    dwLastError         - last error to look for in error message map
    ppHelpMapEntry      - pointer to help map entry where match was found

Return Value:

    TRUE success match found, FALSE error occurred.

--*/
{
    BOOL bStatus = FALSE;

    //
    // If there is a message map, use it.
    //
    if( pMsgHlpMap )
    {
        for( UINT i = 0; pMsgHlpMap[i].dwError; i++ )
        {
            //
            // If we have a matching error, then return a pointer to this entry.
            //
            if( dwLastError == pMsgHlpMap[i].dwError )
            {
                *ppHelpMapEntry = &pMsgHlpMap[i];
                bStatus = TRUE;
                break;
            }
        }
    }

    return bStatus;
}

BOOL
bGoodLastError(
    IN      DWORD               dwLastError
    )
/*++

Routine Description:

    Checks if this is a good last error - i.e. has
    a good real message associated with it.

Arguments:

    dwLastError - the last error to check for

Return Value:

    TRUE if good, FALSE if not good

--*/
{
    MSG_ERRMAP *pErrMapEntry = NULL;
    return bLookupErrorMessageMap( gGlobalErrorMapTable, dwLastError, &pErrMapEntry );
}

BOOL
StringA2W(
    IN  OUT LPWSTR   *ppResult,
    IN      LPCSTR   pString
    )
/*++

Routine Description:

    Convert an ansi string to a wide string returning
    a pointer to a newly allocated string.

Arguments:

    ppResult        - pointer to where to return pointer to new wide string.
    pString         - pointer to ansi string.

Return Value:

    TRUE success, FALSE error occurred.

--*/
{
    SPLASSERT( ppResult || pString );

    BOOL bReturn = FALSE;

    INT iLen = ( strlen( pString ) + 1 ) * sizeof( WCHAR );

    *ppResult = reinterpret_cast<LPWSTR>( AllocMem( iLen ) );

    if( *ppResult )
    {
        if( MultiByteToWideChar( CP_ACP, 0, pString, -1, *ppResult, iLen ) )
        {
            bReturn = TRUE;
        }
        else
        {
            FreeMem( *ppResult );
            *ppResult = NULL;
        }
    }

    return bReturn;
}

BOOL
StringW2A(
    IN  OUT LPSTR   *ppResult,
    IN      LPCWSTR pString
    )
/*++

Routine Description:

    Convert a wide string to and ansi string returning
    a pointer to a newly allocated string.

Arguments:

    ppResult        - pointer to where to return pointer to new ansi string.
    pString         - pointer to wide string.

Return Value:

    TRUE success, FALSE error occurred.

--*/
{
    SPLASSERT( ppResult || pString );

    BOOL bReturn = FALSE;

    INT iLen = ( wcslen( pString ) + 1 ) * sizeof( CHAR );

    *ppResult = reinterpret_cast<LPSTR>( AllocMem( iLen ) );

    if( *ppResult )
    {
        if( WideCharToMultiByte( CP_ACP, 0, pString, -1, *ppResult, iLen, NULL, NULL ) )
        {
            bReturn = TRUE;
        }
        else
        {
            FreeMem( *ppResult );
            *ppResult = NULL;
        }
    }

    return bReturn;
}

/*++

Routine Description:

    Centers a dialog relative to hwndContext

Arguments:

    hwndToCenter - window handle of dialog to center
    hwndContext  - window handle of window to center with respect to

Return Value:

    None.

--*/

VOID
CenterDialog(
    IN HWND hwndToCenter,
    IN HWND hwndContext
    )
{
    POINT point;
    RECT  rcContext, rcWindow;
    LONG  x, y, w, h;
    LONG  sx = GetSystemMetrics(SM_CXSCREEN);
    LONG  sy = GetSystemMetrics(SM_CYSCREEN);

    point.x = point.y = 0;
    if (hwndContext)
    {
        ClientToScreen(hwndContext, &point);
        GetClientRect (hwndContext, &rcContext);
    }
    else
    {
        rcContext.top = rcContext.left = 0;
        rcContext.right = sx;
        rcContext.bottom = sy;
    }
    GetWindowRect (hwndToCenter, &rcWindow);

    w = rcWindow.right  - rcWindow.left + 1;
    h = rcWindow.bottom - rcWindow.top  + 1;
    x = point.x + ((rcContext.right  - rcContext.left + 1 - w) / 2);
    y = point.y + ((rcContext.bottom - rcContext.top  + 1 - h) / 2);

    if (x + w > sx)
    {
        x = sx - w;
    }
    else if (x < 0)
    {
        x = 0;
    }

    if (y + h > sy)
    {
        y = sy - h;
    }
    else if (y < 0)
    {
        y = 0;
    }

    MoveWindow(hwndToCenter, x, y, w, h, FALSE);
}

/*++

Name:

    GetDomainName

Routine Description:

    Returns the DNS domain name where the current computer is located.

Arguments:

    pstrDomainName - pointer to a string refrence where to return the domain name.

Return Value:

    TRUE success, FALSE error occurred.

--*/

BOOL
GetDomainName(
    OUT TString &strDomainName
    )
{
    static TString *g_pstrDomainName = NULL;

    TStatusB bStatus;

    bStatus DBGNOCHK = FALSE;

    CCSLock::Locker CSL( *gpCritSec );

    if( !g_pstrDomainName )
    {
        g_pstrDomainName = new TString;

        if( VALID_PTR( g_pstrDomainName ) )
        {
            typedef DWORD (WINAPI *pfDsRoleGetPrimaryDomainInformation)( LPCTSTR, DSROLE_PRIMARY_DOMAIN_INFO_LEVEL, PBYTE * );
            typedef VOID (WINAPI *pfDsRoleFreeMemory)( PVOID );

            TLibrary Lib( gszNetApiLibrary );

            //
            // Check if the netapi library was loaded.
            //
            bStatus DBGNOCHK = VALID_OBJ( Lib );

            if (bStatus)
            {
                pfDsRoleGetPrimaryDomainInformation pfGetPrimrayDomainInformation = reinterpret_cast<pfDsRoleGetPrimaryDomainInformation>( Lib.pfnGetProc( "DsRoleGetPrimaryDomainInformation" ) );
                pfDsRoleFreeMemory                  pfFreeMemory                  = reinterpret_cast<pfDsRoleFreeMemory>( Lib.pfnGetProc( "DsRoleFreeMemory" ) );

                if( pfGetPrimrayDomainInformation && pfFreeMemory )
                {
                    DWORD                               dwStatus    = ERROR_SUCCESS;
                    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole     = NULL;

                    dwStatus = pfGetPrimrayDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *)&pDsRole);

                    if (dwStatus == ERROR_SUCCESS)
                    {
                        bStatus DBGCHK = g_pstrDomainName->bUpdate( pDsRole->DomainNameDns );

                        if( bStatus )
                        {
                            bStatus DBGCHK = strDomainName.bUpdate( *g_pstrDomainName );
                        }
                    }

                    if (pDsRole)
                    {
                        pfFreeMemory((PVOID) pDsRole);
                    }
                }
            }
        }
    }
    else
    {
        bStatus DBGCHK = strDomainName.bUpdate( *g_pstrDomainName );
    }

    DBGMSG( DBG_TRACE, ( "GetDomainName " TSTR "\n", DBGSTR((LPCTSTR)*g_pstrDomainName) ) );

    return bStatus;

}

/*++

Name:

    AreWeOnADomain

Routine Description:

    Returns whether we are on a domain.

Arguments:

    pbOnDomain  -   If TRUE, we are on a domain.

Return Value:

    TRUE success, FALSE error occurred.

--*/
BOOL
AreWeOnADomain(
        OUT BOOL        *pbOnDomain
    )
{
    typedef DWORD (WINAPI *pfDsRoleGetPrimaryDomainInformation)( LPCTSTR, DSROLE_PRIMARY_DOMAIN_INFO_LEVEL, PBYTE * );
    typedef VOID (WINAPI *pfDsRoleFreeMemory)( PVOID );

    BOOL        bOnDomain = FALSE;
    TStatusB    bStatus;

    TLibrary Lib(gszNetApiLibrary);

    //
    // Check if the netapi library was loaded.
    //
    bStatus DBGNOCHK = VALID_OBJ( Lib );

    if (bStatus)
    {
        pfDsRoleGetPrimaryDomainInformation pfGetPrimrayDomainInformation = NULL;
        pfDsRoleFreeMemory                  pfFreeMemory                  = NULL;
        PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole                       = NULL;

        pfGetPrimrayDomainInformation = reinterpret_cast<pfDsRoleGetPrimaryDomainInformation>(Lib.pfnGetProc("DsRoleGetPrimaryDomainInformation"));
        pfFreeMemory                  = reinterpret_cast<pfDsRoleFreeMemory>(Lib.pfnGetProc("DsRoleFreeMemory"));

        bStatus DBGCHK = pfGetPrimrayDomainInformation && pfFreeMemory;

        if (bStatus)
        {
            DWORD dwStatus = pfGetPrimrayDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *)&pDsRole);

            if (dwStatus)
            {
                SetLastError(dwStatus);
                bStatus DBGCHK = FALSE;
            }
        }

        if (bStatus)
        {
            bOnDomain = pDsRole->MachineRole == DsRole_RoleMemberWorkstation      ||
                        pDsRole->MachineRole == DsRole_RoleMemberServer           ||
                        pDsRole->MachineRole == DsRole_RoleBackupDomainController ||
                        pDsRole->MachineRole == DsRole_RolePrimaryDomainController;
        }

        if (pDsRole)
        {
            pfFreeMemory(pDsRole);
        }
    }

    *pbOnDomain = bOnDomain;

    return bStatus;
}

BOOL
ConstructPrinterFriendlyName(
    IN     LPCTSTR  pszFullPrinter,
    IN OUT LPTSTR   pszPrinterBuffer,
    IN OUT UINT     *pcchSize
    )
/*++

Routine Description:

    Returns printer name formatted like "printer on server." if the provided
    printer name is fully qualified, else it just returns the passed in
    printer name.

Arguments:

    pszPrinter          - pointer to printer name, if fully qualified the
                          name is formatted to printer on server, if not a
                          fully qualified name then the printer name is not
                          altered.
    pszPrinterBuffer    - Output buffer to receive the printer name. May be
                          NULL of the caller want only the size of the buffer
                          returned.
    pcchSize            - pointer to a variable that specifies the size
                          in characters of pszPrinterBuffer includeing the
                          null terminator.

Return Value:

    TRUE success, FALSE error occurred.

--*/
{
    LPCTSTR pszServer;
    LPCTSTR pszPrinter;
    LPCTSTR pszFriendly;
    TString strPrinter;
    TStatusB bStatus;
    TCHAR szScratch[kPrinterBufMax];

    //
    // Validate the printer name and buffer pointer size.
    //
    if( pszFullPrinter && pcchSize )
    {
        //
        // Split the printer name into its components.
        //
        vPrinterSplitFullName( szScratch, pszFullPrinter, &pszServer, &pszPrinter );

        //
        // If this printer has a server name component then construct a
        // 'printer on server' friendly name.
        //
        if( pszServer && *pszServer )
        {
            //
            // Strip the leading slashes.
            //
            if( *(pszServer+0) == _T('\\') && *(pszServer+1) == _T('\\') )
            {
                pszServer = pszServer + 2;
            }

            bStatus DBGCHK = bConstructMessageString( ghInst, strPrinter, IDS_DSPTEMPLATE_WITH_ON, pszPrinter, pszServer );

            if( bStatus )
            {
                pszFriendly = strPrinter;
            }
        }
        else
        {
            //
            // Just use the current printer name if it is not fully qualified.
            //
            bStatus DBGNOCHK = TRUE;
            pszFriendly = pszFullPrinter;
        }

        if( bStatus )
        {
            UINT uFriendlySize = _tcslen( pszFriendly );

            //
            // If a buffer was provided then check if it is large enough to
            // hold the friendly name.  If it is large enough then copy the
            // friendly name into it.
            //
            if( pszPrinterBuffer && ( *pcchSize > uFriendlySize ) )
            {
                _tcscpy( pszPrinterBuffer, pszFriendly );
            }
            else
            {
                bStatus DBGNOCHK = FALSE;
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
            }

            //
            // Return the friendly name size.
            //
            *pcchSize = uFriendlySize + 1;
        }
    }
    else
    {
        bStatus DBGNOCHK = FALSE;
        SetLastError( ERROR_INVALID_PARAMETER );
    }

    return bStatus;
}

BOOL
WINAPIV
bConstructMessageString(
    IN HINSTANCE    hInst,
    IN TString     &strString,
    IN INT          iResId,
    IN ...
    )
/*++

Routine Description:

    This routine formats the specified string using a format string.
    The format string is extracted from the resouce file using the
    passed in resouce id.  The format is of the form required by
    FormatMessage API.  See FormatMessage for more details.

Arguments:

    hInst       - Instance handle where resource is loaded.
    strString   - Place to return resultant formatted string,
    iResId      - Format string resource id.
    ..          - Variable number of arguments

Return Value:

    TRUE success, FALSE if error occurred.

--*/
{
    LPTSTR      pszRet  = NULL;
    DWORD       dwBytes = 0;
    TString     strRes;
    TStatusB    bStatus;
    va_list     pArgs;

    //
    // Load the resource string.
    //
    bStatus DBGCHK = strRes.bLoadString( hInst, iResId );

    if( bStatus )
    {
        va_start( pArgs, iResId );

        //
        // Format the message.
        //
        dwBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                                strRes,
                                0,
                                0,
                                (LPTSTR)&pszRet,
                                0,
                                &pArgs );
        va_end( pArgs );

        //
        // If the number of bytes is non zero the API formatted the
        // string.
        //
        if( dwBytes )
        {
            //
            // Update the return string object.
            //
            bStatus DBGCHK = strString.bUpdate( pszRet );

            //
            // Release the formated string.
            //
            if( pszRet )
            {
                LocalFree(pszRet);
            }
        }
        else
        {
            bStatus DBGNOCHK = FALSE;
        }
    }
    return bStatus;
}

BOOL
bIsLocalPrinterNameValid(
    IN LPCTSTR pszPrinter
    )
/*++

Routine Description:

    This routine checks if the specified local printer name contains
    any illegal characters.  Note the spooler also inforces the illegal
    characters but doing the check in the UI code is more efficent and
    nicer to the user, rather than having to call add printer with a
    printer name that is invalid.

Arguments:

    pszPrinter - pointer to local printer name

Return Value:

    TRUE printer name is valid, FALSE name contains illegal character

--*/
{
    BOOL bRetval = TRUE;

    //
    // Check if the name has any illegal characters.
    //
    for( LPCTSTR p = pszPrinter; p && *p; p++ )
    {
        if( *p == TEXT( ',' ) || *p == TEXT( '!' ) || *p == TEXT( '\\' ) )
        {
            bRetval = FALSE;
            break;
        }
    }

    return bRetval;
}

BOOL
CheckRestrictions(
    IN HWND           hwnd,
    IN RESTRICTIONS   rest
    )
/*++

Routine Description:

    Verify the resrtictions of the explorer policies

Arguments:

    hwnd - Handle to the parent window
    rest - Restriction to check.

Return Value:

    TRUE  - Restriction apply
    FALSE - Not restrcited

--*/
{
    if (SHRestricted(rest))
    {
        iMessage( hwnd,
                  IDS_RESTRICTIONSTITLE,
                  IDS_RESTRICTIONS,
                  MB_OK|MB_ICONSTOP,
                  kMsgNone,
                  NULL );
        return TRUE;
    }
    return FALSE;
}

VOID
vAdjustHeaderColumns(
    IN HWND hwndLV,
    IN UINT uColumnsCount,
    IN UINT uPercentages[]
    )
/*++

Routine Description:

    Adjusts the columns to a certan percentages
    in a list view

Arguments:

    hwndLV          - Handle to a list view control
    uColumnsCount   - Number of columns
    uPercentages    - The percentage of the total width
                      each column will take. 100 == SUM(uPercentages)

Return Value:

    None

--*/
{
    //
    // Calculate the header column width.
    //
    RECT rc;
    DWORD Interval = 20;    // why not

    if( GetClientRect( hwndLV, &rc ))
    {
        Interval = rc.right;
    }

    for( UINT iCol = 0; iCol < uColumnsCount; ++iCol )
    {
        ListView_SetColumnWidth( hwndLV, iCol, (Interval * uPercentages[iCol]) / 100 );
    }
}

VOID
LoadPrinterIcons(
    IN  LPCTSTR pszPrinterName,
    OUT HICON *phLargeIcon,
    OUT HICON *phSmallIcon
    )
/*++

Routine Description:

    Loads a printer icon with the requested size.

Arguments:

    IN pszPrinterName  - the printer name of the printer we want icon for
    OUT phLargeIcon - where to put the large icon
    OUT phSmallIcon - where to put the small icon

Return Value:

--*/
{
    // invoke shell to do the right thing
    Printer_LoadIcons(pszPrinterName, phLargeIcon, phSmallIcon);
}

BOOL
CommandConfirmationPurge(
    IN  HWND hwnd,
    IN  LPCTSTR pszPrinterName
    )
/*++

Routine Description:

    Dispalys confirmation message box for the purge command.

Arguments:

Return Value:

    TRUE user wants to execute command, FALSE cancel.

--*/
{
    TCHAR szText[kStrMax+kPrinterBufMax]    = {0};
    UINT nSize = COUNTOF( szText );

    //
    // Build the printer status string.
    //
    ConstructPrinterFriendlyName(pszPrinterName, szText, &nSize);

    return iMessage( hwnd,
                     IDS_PRINTERS_TITLE,
                     IDS_PRINTER_SUREPURGE,
                     MB_YESNO|MB_ICONQUESTION,
                     kMsgNone,
                     NULL,
                     szText ) == IDYES;
}

/********************************************************************

    Functions specific for the RTL (right-to-left) locales.
    For more information about how this function works
    contact SamerA.

********************************************************************/

BOOL
IsRTLLocale(
    LCID iLCID
    )
/*++

Routine Description:

    Check if a particular locale is RTL (right-to-left)
    locale

Arguments:

    iLCID - Locale to check

Return Value:

    TRUE  - The locale is RTL locale
    FALSE - Oterwise

--*/
{
    //
    // Length of font signature string
    //
    #define MAX_FONTSIGNATURE    16

    WORD wLCIDFontSignature[MAX_FONTSIGNATURE];
    BOOL bRet = FALSE;

    //
    //  Verify that this is an RTL (BiDi) locale.  Call GetLocaleInfo with
    //  LOCALE_FONTSIGNATURE which always gives back 16 WORDs.
    //
    if( GetLocaleInfo( iLCID,
                       LOCALE_FONTSIGNATURE,
                       (LPTSTR )&wLCIDFontSignature,
                       (sizeof(wLCIDFontSignature)/sizeof(wLCIDFontSignature[0]))))
    {
        //
        //  Verify the bits show a BiDi UI locale.
        //
        if( wLCIDFontSignature[7] & 0x0800 )
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

DWORD
dwDateFormatFlags(
    HWND hWnd
    )
/*++

Routine Description:

    Build appropriate flags for GetDateFormat(...) API
    depending on the current locale. Check if it is an
    RTL locale.

Arguments:

    hWnd - Window where the text will be drawn

Return Value:

    The appropriate flags to be passed to
    GetDateFormat(...)

--*/
{
    DWORD dwFlags = 0;

    //
    // Check if the default locale is RTL locale
    //
    if( IsRTLLocale( GetUserDefaultLCID( ) ) )
    {
        //
        // Check if this is a RTL (right-to-left) mirrored window
        // or normal LTR window
        //
        if( GetWindowLong( hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL )
        {
            dwFlags |= DATE_RTLREADING;
        }
        else
        {
            dwFlags |= DATE_LTRREADING;
        }
    }

    return dwFlags;
}

BOOL
bMatchTemplate(
    IN LPCTSTR pszTemplate,
    IN LPCTSTR pszText
    )
/*++

Routine Description:

    Simple template matching routine

Arguments:

    pszTemplate   - pointer to a simple template string
    pszText       - pointer to a text to match against the template

Return Value:

    TRUE matched, FALSE not matched

--*/
{
    int iLen = lstrlen(pszTemplate);
    if( iLen != lstrlen(pszText) )
    {
        return FALSE;
    }

    TString strText, strTemplate;
    if( strText.bUpdate(pszText) &&
        strTemplate.bUpdate(pszTemplate) )
    {
        // convert to uppercase prior the matching
        strText.vToUpper();
        strTemplate.vToUpper();

        for( int i = 0; i < iLen; i++ )
        {
            if( TEXT('?') == strTemplate[i] )
            {
                continue;
            }

            if( strTemplate[i] != strText[i] )
            {
                return FALSE;
            }
        }
    }
    else
    {
        // failed to allocate the strings
        return FALSE;
    }

    return TRUE;
}

BOOL
bIsFaxPort(
    IN LPCTSTR pszName,
    IN LPCTSTR pszMonitor
    )
/*++

Routine Description:

    Determins if this port is a fax port.  A fax
    port is a port managed by the fax port monitor.

Arguments:

    pszName         - pointer to port name.
    pszMonitor      - pointer to port monitor.

Return Value:

    TRUE port is a fax port, FALSE port is not a fax port.

--*/
{
    // the monitor name can be null on downlevel servers.
    return ((pszName && 0 == lstrcmp(pszName, FAX_MONITOR_PORT_NAME)) ||
            (pszMonitor &&  0 == lstrcmp(pszMonitor, FAX_MONITOR_NAME)));
}

/*++

Routine Description:

    shows up an appropriate error message based on the last error code
    (if spcified) this function is exported from printui to shell, so
    shell error messages can be consistent with us.

Arguments:

    piResult        - the result from MessageBox
    hModule         - module who contains the test resources
    hwnd            - parent window
    pszTitle        - msg title (uID or text)
    pszMessage      - msg itself or msg context (uID or text)
    uType           - msg type
    iLastError      - the last error (-1 means don't append the last error text)

Return Value:

    S_OK on success or COM error otherwise

--*/

HRESULT
ShowErrorMessageSC(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  DWORD                dwCode
    )
{
    return Internal_Message(piResult, hModule, hwnd, pszTitle, pszMessage,
        uType, dwCode, NULL, NULL, 0, NULL);
}

/*++

Routine Description:

    shows up an appropriate error message based on the last error code
    (if spcified) this function is exported from printui to shell, so
    shell error messages can be consistent with us.

Arguments:

    piResult        - the result from MessageBox
    hModule         - module who contains the test resources
    hwnd            - parent window
    pszTitle        - msg title (uID or text)
    pszMessage      - msg itself or msg context (uID or text)
    uType           - msg type
    iLastError      - the last error (-1 means don't append the last error text)

Return Value:

    S_OK on success or COM error otherwise

--*/

HRESULT
ShowErrorMessageHR(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  HRESULT              hr
    )
{
    return Internal_Message(piResult, hModule, hwnd, pszTitle, pszMessage,
        uType, SCODE_CODE(GetScode(hr)), NULL, NULL, 0, NULL);
}


/*++

Routine Description:

    abbreviates text by adding ellipses if text is longer than cchMaxChars

Arguments:

    pszText             - [in]      text to abbreviate
    cchMaxChars         - [in]      max characters of the output (abbreviated) text
    pstrAbbreviatedText - [out]     the abbreviated text

Return Value:

    S_OK on success or COM error otherwise

--*/

HRESULT
AbbreviateText(
    IN  LPCTSTR     pszText,
    IN  UINT        cchMaxChars,
    OUT TString    *pstrAbbreviatedText
    )
{
    HRESULT hr = E_INVALIDARG;
    if( pszText && cchMaxChars && pstrAbbreviatedText )
    {
        TStatusB bStatus;
        if( lstrlen(pszText) <= cchMaxChars )
        {
            // the text fits in the buffer, just copy it
            bStatus DBGCHK = pstrAbbreviatedText->bUpdate(pszText);
            hr = bStatus ? S_OK : E_OUTOFMEMORY;
        }
        else
        {
            // the text doesn't fit in the buffer, add ellipses
            TString strEllipses;
            bStatus DBGCHK = strEllipses.bLoadString(ghInst, IDS_TEXT_ELLIPSES);

            if( bStatus && strEllipses.uLen() < cchMaxChars )
            {
                TCHAR szBuffer[255];
                lstrcpyn(szBuffer, pszText, min(cchMaxChars - strEllipses.uLen(), ARRAYSIZE(szBuffer)));

                bStatus DBGCHK = pstrAbbreviatedText->bFormat(TEXT("%s%s"), szBuffer, static_cast<LPCTSTR>(strEllipses));
                hr = bStatus ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                // generate proper HRESULT from Win32 last error
                hr = CreateHRFromWin32();
            }
        }
    }
    return hr;
}

/*++

Routine Name:

    MoveWindowWrap

Routine Description:

    Move specific window by given offset.

Arguments:

    hWnd -- window handle
    deltaX -- horizonal offset
    deltaY -- vertical offset

Return Value:

    Return value by MoveWindow().

--*/
BOOL
MoveWindowWrap(
    HWND hwnd,
    int deltaX,
    int deltaY
    )
{
    RECT rect;

    GetWindowRect(hwnd, &rect);
    MapWindowPoints(HWND_DESKTOP, GetParent(hwnd), (LPPOINT)&rect, 2);
    return MoveWindow(hwnd, rect.left + deltaX, rect.top + deltaY,
        rect.right - rect.left, rect.bottom - rect.top, TRUE);
}

/*++

Routine Name:

    IsColorPrinter

Routine Description:

    Checks if a printer supports color

Arguments:

    pszPrinter - printer name
    pbColor    - pointer to bool

Return Value:

    S_OK          - the function succeded and pbColor can be used
    anything else - the function failed

--*/
HRESULT
IsColorPrinter(
    IN     LPCWSTR pszPrinter,
    IN OUT LPBOOL  pbColor
    )
{
    TStatusH hStatus;

    hStatus DBGNOCHK = E_INVALIDARG;

    if (pszPrinter && pbColor)
    {
        hStatus DBGNOCHK = E_FAIL;

        //
        // Create the printer data access class.
        //
        TPrinterDataAccess Data(pszPrinter,
                                TPrinterDataAccess::kResourcePrinter,
                                TPrinterDataAccess::kAccessRead);

        //
        // Relax the return type checking, BOOL are not REG_DWORD but REG_BINARY
        //
        Data.RelaxReturnTypeCheck(TRUE);

        //
        // Initialize the data class.
        //
        if (Data.Init())
        {
            hStatus DBGCHK = Data.Get(SPLDS_DRIVER_KEY, SPLDS_PRINT_COLOR, *pbColor);
        }
    }

    return hStatus;
}

/*++

Routine Name:

    IsGuestAccessMode

Routine Description:

    Checks if guest access mode is enabled for the local machine.

Arguments:

    pbGuestAccessMode - [out] TRUE if guest access mode is enabled
        for the local machine and FALSE otherwise.

Return Value:

    S_OK if succeded and OLE error otherwise.

History:

    Lazar Ivanov (LazarI), Mar-19-2001 - created.

--*/

HRESULT
IsGuestAccessMode(
    OUT BOOL *pbGuestAccessMode
    )
{
    HRESULT hr = S_OK;

    if (pbGuestAccessMode)
    {
        if (GetCurrentPlatform() == kPlatform_IA64)
        {
            //
            // Guest mode is always off for IA64 machine since we don't have
            // homenetworking wizard for IA64 machine
            //
            *pbGuestAccessMode = FALSE;
        }
        else if (IsOS(OS_PERSONAL))
        {
            //
            // Guest mode is always on for Personal.
            //
            *pbGuestAccessMode = TRUE;
        }
        else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
        {
            //
            // Professional, not in a domain. Check the "ForceGuest" value
            // in the registry.
            //
            LONG errCode;
            CAutoHandleHKEY shKey;
            DWORD dwValue = 0;
            DWORD dwValueSize = sizeof(dwValue);

            errCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                0, KEY_QUERY_VALUE, &shKey);

            if (errCode == ERROR_SUCCESS)
            {
                errCode = RegQueryValueEx(shKey, TEXT("ForceGuest"), NULL, NULL,
                    (LPBYTE)&dwValue, &dwValueSize);

                if (errCode == ERROR_SUCCESS)
                {
                    //
                    // Declare success here.
                    //
                    *pbGuestAccessMode = (1 == dwValue);
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(errCode);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(errCode);
            }
        }
        else
        {
            //
            // Not in guest mode.
            //
            *pbGuestAccessMode = FALSE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*++

Routine Name:

    IsGuestEnabledForNetworkAccess

Routine Description:

    Checks if the Guest account is enabled for network access.

Arguments:

    pbGuestEnabledForNetworkAccess - [out] TRUE if the Guest
        account is enabled for network access and FALSE otherwise.

Return Value:

    S_OK if succeded and OLE error otherwise.

History:

    Lazar Ivanov (LazarI), Mar-19-2001 - created.

--*/

HRESULT
IsGuestEnabledForNetworkAccess(
    OUT BOOL *pbGuestEnabledForNetworkAccess
    )
{
    HRESULT hr = S_OK;

    if (pbGuestEnabledForNetworkAccess)
    {
        CRefPtrCOM<ILocalMachine> spLM;
        VARIANT_BOOL vbEnabled = VARIANT_FALSE;

        //
        // Get pointer to ILocalMachine to check ILM_GUEST_NETWORK_LOGON
        //
        if (SUCCEEDED(hr = CoCreateInstance(CLSID_ShellLocalMachine, NULL,
                CLSCTX_INPROC_SERVER, IID_ILocalMachine, (void**)&spLM)) &&
            SUCCEEDED(hr = spLM->get_isGuestEnabled(ILM_GUEST_NETWORK_LOGON, &vbEnabled)))
        {
            //
            // Declare success here.
            //
            *pbGuestEnabledForNetworkAccess = (VARIANT_TRUE == vbEnabled);
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*++

Routine Name:

    IsSharingEnabled

Routine Description:

    Checks if sharing is enabled or we should launch the home
    networking wizard to enable sharing before allowing the
    users to share out printers.

Arguments:

    pbSharingEnabled - [out] TRUE if sharing is enabled and
        FALSE otherwise (in which case we should launch HNW)

Return Value:

    S_OK if succeded and OLE error otherwise.

History:

    Lazar Ivanov (LazarI), Mar-19-2001 - created.

--*/

HRESULT
IsSharingEnabled(
    OUT BOOL *pbSharingEnabled
    )
{
    HRESULT hr = S_OK;

    if (pbSharingEnabled)
    {
        BOOL bGuestAccessMode = FALSE;
        BOOL bGuestEnabledForNetworkAccess = FALSE;

        //
        // First get the values of bGuestAccessMode & bGuestEnabledForNetworkAccess
        //
        if (SUCCEEDED(hr = IsGuestAccessMode(&bGuestAccessMode)) &&
            SUCCEEDED(hr = IsGuestEnabledForNetworkAccess(&bGuestEnabledForNetworkAccess)))
        {
            //
            // Sharing is enabled *only* if not in guest mode OR the guest account is
            // enabled for network access.
            //
            *pbSharingEnabled = (!bGuestAccessMode || bGuestEnabledForNetworkAccess);
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*++

Routine Name:

    LaunchHomeNetworkingWizard

Routine Description:

    Launches the home networking wizard

Arguments:

    hwnd - [in] window handle to show the wizard modally against
    pbRebootRequired - [out] TRUE if the user made a change which
        requires to reboot the system.

Return Value:

    S_OK if succeded and OLE error otherwise.

History:

    Lazar Ivanov (LazarI), Mar-19-2001 - created.

--*/

HRESULT
LaunchHomeNetworkingWizard(
    IN  HWND hwnd,
    OUT BOOL *pbRebootRequired
    )
{
    HRESULT hr = S_OK;

    if (hwnd && pbRebootRequired)
    {
        CRefPtrCOM<IHomeNetworkWizard> spHNW;

        //
        // Get pointer to IHomeNetworkWizard, get the top level owner of hwnd
        // and then show the wizard.
        //
        if (SUCCEEDED(hr = CoCreateInstance(CLSID_HomeNetworkWizard, NULL,
                CLSCTX_INPROC_SERVER, IID_IHomeNetworkWizard, (void**)&spHNW)) &&
            SUCCEEDED(hr = GetCurrentThreadLastPopup(&hwnd)) &&
            SUCCEEDED(hr = spHNW->ShowWizard(hwnd, pbRebootRequired)))
        {
            //
            // Declare success here.
            //
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*++

Routine Name:

    IsRedirectedPort

Routine Description:

    Determines if the specified port name is a redirected port.

Arguments:

    pszPortName - Port name.

Return Value:

    Standard HRESULT value.

--*/
HRESULT
IsRedirectedPort(
    IN LPCTSTR pszPortName,
    OUT BOOL *pbIsRedirected
    )
{
    HRESULT hr = S_OK;

    if (!pszPortName || lstrlen(pszPortName) < 2)
    {
        *pbIsRedirected = FALSE;
    }
    else
    {
        *pbIsRedirected = (*(pszPortName+0) == TEXT('\\')) && (*(pszPortName+1) == TEXT('\\'));
    }

    return hr;
}


/*++

Routine Name:

    DisplayMessageFromOtherResourceDll

Routine Description:

    This displays a message where the message comes from another resource DLL, the
    title comes from printui.

Arguments:

    hwnd            -   Parent window for this window.
    idsTitle        -   The res id of the title to display
    pszMessageDll   -   The message DLL to load and display.
    idsMessage      -   The res id of the message
    uType           -   The type of message box to display.
    ...             -   Arguments formatted by idsMessage

Return Value:

    returns value from MessageBox on sucess
    and zero on failure

--*/
INT
DisplayMessageFromOtherResourceDll(
    IN  HWND                hwnd,
    IN  UINT                idsTitle,
    IN  PCWSTR              pszMessageDll,
    IN  UINT                idsMessage,
    IN  UINT                uType,
    ...
    )
{
    HMODULE   hMessage = NULL;
    TString   strTitle;
    INT       iRet = TRUE;

    if (pszMessageDll)
    {
        iRet = TRUE;
    }
    else
    {
        SetLastError(ERROR_INVALID_PARAMETER);

        iRet = FALSE;
    }


    if (iRet)
    {
        iRet = (hMessage = LoadLibraryEx(pszMessageDll, NULL, LOAD_LIBRARY_AS_DATAFILE)) != NULL;
    }

    if (iRet)
    {
        iRet = strTitle.bLoadString(ghInst, idsTitle);
    }

    if (iRet)
    {
        va_list valist;
        va_start(valist, uType);

        if(FAILED(Internal_Message(&iRet,
                                   hMessage,
                                   hwnd,
                                   strTitle,
                                   MAKEINTRESOURCE(idsMessage),
                                   uType,
                                   ERROR_SUCCESS,
                                   NULL,
                                   0,
                                   NULL,
                                   valist)) )
        {
            // make sure we return zero in the failure case
            iRet = 0;
        }

        va_end(valist);
    }


    if (hMessage)
    {
        FreeLibrary(hMessage);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipic\annot.cpp ===
#include "precomp.h"
#include "resource.h"
#include "duipic.h"
#include "annot.h"
#include "assert.h"
#pragma hdrstop

// #define Assert(x) (x)
#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif

// Private definitions of tag types and values

//
// Each entry in the annotation has a type
//
#define DEFAULTDATA    2
#define ANNOTMARK      5
#define MARKBLOCK      6

// Reserved names for named blocks. case sensitive
static const char c_szAnoDat[] = "OiAnoDat";
static const char c_szFilNam[] = "OiFilNam";
static const char c_szDIB[] = "OiDIB";
static const char c_szGroup[] = "OiGroup";
static const char c_szIndex[] = "OiIndex";
static const char c_szAnText[] = "OiAnText";
static const char c_szHypLnk[] = "OiHypLnk";
static const char c_szDefaultGroup[] = "[Untitled]";

#define CBHEADER      8 // unused 4 bytes plus int size specifier
#define CBDATATYPE    8 // type specifier plus data size
#define CBNAMEDBLOCK 12 // name of block + sizeof block
#define CBINDEX      10 // length of the index string
#define CBBLOCKNAME   8 // length of the name of the named block

static const SIZE_T c_cbDefaultData = 144;
static const BYTE c_pDefaultData[] = {
0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x55, 0x47, 0x72, 0x6f, 0x75, 0x70,
0x2a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65,
0x64, 0x5d, 0x00, 0x00, 0x5b, 0x00, 0x55, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
0x6c, 0x00, 0x65, 0x00, 0x64, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x00, 0x0c, 0x00,
0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x64, 0x5d, 0x00, 0x00, 0x02, 0x00,
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x4f, 0x69, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x00, 0x1e, 0x00,
0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE c_pDefaultUGroup [] = {
0x4f, 0x69, 0x55, 0x47, 0x72, 0x6f, 0x75, 0x70,
0x2a, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x5b, 0x55, 0x6e, 0x74, 0x69, 0x74, 0x6c, 0x65,
0x64, 0x5d, 0x00, 0x00, 0x5b, 0x00, 0x55, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x69, 0x00, 0x74, 0x00,
0x6c, 0x00, 0x65, 0x00, 0x64, 0x00, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static const INT AnnotHeader[] =
{
    0, 1
};
void SetAlpha(HGADGET hGadget, BYTE alpha)
{
    BUFFER_INFO bi = {0};
    bi.cbSize = sizeof(bi);
    bi.nMask = GBIM_ALPHA;
    bi.bAlpha =  alpha;
    SetGadgetBufferInfo(hGadget, &bi);    
}

void DumpMessage(LPCTSTR szFunc, EventMsg *pmsg)
{
    #ifdef VERBOSE
    TCHAR szOut[200];
    
    wsprintf (szOut, TEXT("Function:%s\n\tnMsg:%d, hgadMsg:%x, nMsgFlags:%x\n"), szFunc,
              pmsg->nMsg, pmsg->hgadMsg, pmsg->nMsgFlags);
    OutputDebugString(szOut);
    #endif
}

static void RotateHelper(LPPOINT ppoint, int cSize, int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    int nNewX, nNewY;
    for(int i=0;i<cSize;i++)
    {
        if (bClockwise)
        {
            nNewX = nNewImageWidth - ppoint[i].y;
            nNewY = ppoint[i].x;
        }
        else
        {
            nNewX = ppoint[i].y;
            nNewY = nNewImageHeight - ppoint[i].x;
        }
        ppoint[i].x = nNewX;
        ppoint[i].y = nNewY;
    }
}

void NormalizeRect(RECT *prect)
{
    int nTemp;
    if (prect->left > prect->right)
    {
        nTemp = prect->left;
        prect->left = prect->right;
        prect->right = nTemp;
    }
    if (prect->top > prect->bottom)
    {
        nTemp = prect->top;
        prect->top = prect->bottom;
        prect->bottom = nTemp;
    }
}

CAnnotationSet::CAnnotationSet()
    : _dpaMarks(NULL)
{
    _pDefaultData = (LPBYTE)c_pDefaultData;
    _cbDefaultData = c_cbDefaultData;
}

CAnnotationSet::~CAnnotationSet()
{
    _ClearMarkList ();
}

void CAnnotationSet::RenderAllMarks(Graphics &g)
{
    CAnnotation *pCur;

    if(_dpaMarks == NULL)
        return;

    for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pCur = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pCur)
        {
            pCur->Render (g);
        }
    }
}

CAnnotation* CAnnotationSet::GetAnnotation(INT_PTR nIndex)
{
    if(_dpaMarks == NULL)
        return NULL;

    if (nIndex >= 0 && nIndex < DPA_GetPtrCount(_dpaMarks))
    {
        CAnnotation *pCur;
        pCur = (CAnnotation *)DPA_GetPtr(_dpaMarks, nIndex);
        return pCur;
    }
    return NULL;
}

BOOL CAnnotationSet::AddAnnotation(CAnnotation *pMark)
{
    DPA_AppendPtr(_dpaMarks, pMark);
    return true;
}

BOOL CAnnotationSet::RemoveAnnotation(CAnnotation *pMark)
{
    CAnnotation *pCur;

    if(_dpaMarks == NULL)
        return true;

    for (int i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pCur = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pCur == pMark)
        {
            DPA_DeletePtr(_dpaMarks, i);
            return true;
        }
    }
    return false;
}

#define ANNOTFILTER GMFI_PAINT | GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE

void CAnnotationSet::SetImageData(Image *pimg, CImageGadget *pParent)
{
    _ClearMarkList();

    //
    // Create an invisible gadget that is a child of pParent 
    // to serve as the container of all annotation gadgets.
    //  
    _hGadget = CreateGadget(pParent->GetHandle(), GC_SIMPLE, AnnotParentProc, this);
    
    if (_hGadget)
    {
        SIZE sizeParent = {0};
        SetGadgetMessageFilter(_hGadget, NULL, 
                               ANNOTFILTER,
                               ANNOTFILTER);
        SetGadgetStyle(_hGadget, 
                       GS_VISIBLE | GS_BUFFERED | GS_OPAQUE, 
                       GS_VISIBLE | GS_BUFFERED | GS_OPAQUE|GS_CLIPINSIDE);
        GetGadgetSize(pParent->GetHandle(), &sizeParent);
        SetGadgetRect(_hGadget, 0, 0, sizeParent.cx, sizeParent.cy, SGR_PARENT|SGR_SIZE|SGR_MOVE);
        SetGadgetRect(_hGadget, 0, 0, sizeParent.cx, sizeParent.cy, SGR_CLIENT|SGR_SIZE);
    }

    _BuildMarkList(pimg);

}

//
// This function reassembles the in-file representation of the current
// annotations and writes it to the IPropertyStorage
//
HRESULT CAnnotationSet::CommitAnnotations(Image * pimg)
{
    HRESULT hr = E_OUTOFMEMORY;
    SIZE_T cbItem;
    CAnnotation *pItem;
    LPBYTE pData;

    if (NULL == _dpaMarks || DPA_GetPtrCount(_dpaMarks) == 0)
    {
        return _SaveAnnotationProperty(pimg, NULL, 0);
    }
    //
    // First, calculate the size of the buffer needed
    // Begin with the header and the size of the default data
    //
    SIZE_T cbBuffer = CBHEADER+_cbDefaultData;
    //
    // Now query the individual items' sizes
    //
    for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
    {
        pItem = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
        if (pItem)
        {
            if (SUCCEEDED(pItem->GetBlob(cbItem, NULL, c_szDefaultGroup, NULL)))
            {
                // cbItem includes the named blocks of the item as well
                // as the ANNOTATIONMARK struct
                cbBuffer += CBDATATYPE + cbItem;
            }
        }
    }
    //
    // Allocate the buffer to hold the annotations
    //
    pData = new BYTE[cbBuffer];
    if (pData)
    {
        LPBYTE pCur = pData;
        //
        // Copy in the header and the int size
        //
        CopyMemory(pCur, AnnotHeader, CBHEADER);
        pCur+=CBHEADER;
        //
        // Copy in the default data
        //
        CopyMemory(pCur, _pDefaultData, _cbDefaultData);
        pCur+=_cbDefaultData;
        //
        // Scan through the items again and have them copy in their data
        //
        for (INT_PTR i=0;i<DPA_GetPtrCount(_dpaMarks);i++)
        {
            pItem = (CAnnotation*)DPA_GetPtr(_dpaMarks, i);
            if (pItem)
            {
                UINT nIndex = (UINT)i;
                CHAR szIndex[11];
                ZeroMemory(szIndex, 11);

                wsprintfA(szIndex, "%d", nIndex);

                if (SUCCEEDED(pItem->GetBlob(cbItem, pCur+CBDATATYPE, c_szDefaultGroup, szIndex)))
                {
                    *(UNALIGNED UINT *)pCur = ANNOTMARK; // next item is an ANNOTATIONMARK
                    *(UNALIGNED UINT *)(pCur+4) = sizeof(ANNOTATIONMARK); // size of the mark
                    pCur+=CBDATATYPE + cbItem;
                }
            }
        }
        //
        // Now save the annotation blob as a property
        //
        hr = _SaveAnnotationProperty(pimg, pData, cbBuffer);
    }
    delete [] pData;
    return hr;
}

void CAnnotationSet::ClearAllMarks()
{
    _ClearMarkList();
}

//
// _BuildMarkList reads the PROPVARIANT for tag 32932 from the image.
// It walks through the data building a list of CAnnotation-derived objects
//
void CAnnotationSet::_BuildMarkList(Image * pimg)
{
    if(!pimg)
    {
        return;
    }
    
    _xDPI = (ULONG)pimg->GetHorizontalResolution();
    _yDPI = (ULONG)pimg->GetVerticalResolution();
    _dpaMarks = DPA_Create(16);
    if (_dpaMarks)
    {
        PropertyItem *pi;
        UINT uSize = pimg->GetPropertyItemSize(ANNOTATION_IMAGE_TAG);
        if (uSize)
        {
            pi = reinterpret_cast<PropertyItem*>(new BYTE[uSize]);
            if(pi)
            {
                if (Ok == pimg->GetPropertyItem(ANNOTATION_IMAGE_TAG,uSize,pi))
                {
                    _BuildListFromData(pi->value, pi->length);
                }
                delete [] reinterpret_cast<BYTE*>(pi);
            }            
        }        
    }
}

// Given the raw annotation data, do set up and then call _BuildListFromData
HRESULT CAnnotationSet::BuildAllMarksFromData(LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI)
{
    // check for bad params
    if (!pData)
    {
        return E_INVALIDARG;
    }

    // First, clear out any old marks...
    _ClearMarkList();

    // Set up DPI info
    _xDPI = xDPI;
    _yDPI = yDPI;

    //  Create DPA if it doesn't exist
    if (!_dpaMarks)
    {
        _dpaMarks = DPA_Create(16);

        if (!_dpaMarks)
        {
            return E_OUTOFMEMORY;
        }
    }

    // build list of marks
    _BuildListFromData(pData,cbSize);

    return S_OK;

}

// Given the raw annotation data, swizzle it to in-memory CAnnotation objects
// and add those object pointers to our list
void CAnnotationSet::_BuildListFromData(LPVOID pData, UINT cbSize)
{
    ANNOTATIONDESCRIPTOR *pDesc;
    LPBYTE   pNextData =(LPBYTE)pData;
    LPBYTE  pDefaultData;
    CAnnotation *pMark;

    if(!_dpaMarks)
    {
        return;
    }
    // Skip the 4 byte header
    pNextData += 4;
    // Make sure the int size is 32 bits
    if(!((UNALIGNED int *)*pNextData))
    {
        return;
    }
    // skip the int size marker
    pNextData += 4;
    pDefaultData = pNextData;
    // skip the default data. It gets stored for future use, as it will be appended to all
    // new marks the user creates on this image.
    INT cbNamedBlocks = _NamedBlockDataSize(2,pNextData,(LPBYTE)pData+cbSize);
    if (cbNamedBlocks > 0)
    {
        pNextData += cbNamedBlocks;
        _cbDefaultData = (SIZE_T)(pNextData-pDefaultData);
        _pDefaultData = new BYTE[_cbDefaultData];
    }
    if(_pDefaultData)
    {
        CopyMemory(_pDefaultData, pDefaultData, _cbDefaultData);
    }
    // pNextData now points to the first mark in the data.
    do
    {
        // Create a descriptor from the raw mark data
        pDesc = _ReadMark(pNextData, &pNextData,(LPBYTE)pData+cbSize);
        if(pDesc)
        {
            // Now create a CAnnotation from the descriptor and add it to the list
            pMark = CAnnotation::CreateAnnotation(pDesc, _yDPI, _hGadget);
            if(pMark)
            {
                DPA_AppendPtr(_dpaMarks, pMark);
            }
            delete pDesc;
        }
    }while(pNextData &&(((LPBYTE)pData+cbSize) > pNextData) );
}

#define CHECKEOD if(pCur>pEOD)return -1;

INT CAnnotationSet::_NamedBlockDataSize(UINT uType, LPBYTE pData, LPBYTE pEOD)
{
    LPBYTE pCur = pData;
    UINT cbSkip=0;

    while(pCur < pEOD && *(UNALIGNED UINT*)pCur == uType)
    {
        pCur+=4;
        CHECKEOD
        // skip type and size
        cbSkip +=8+*(UNALIGNED UINT*)pCur;
        pCur+=4;
        //skip name
        pCur+=8;
        CHECKEOD
        // skip size plus the actual data
        cbSkip+=*(UNALIGNED UINT*)pCur;
        pCur+=4+*(UNALIGNED UINT*)pCur;
    }
    return cbSkip;
}

ANNOTATIONDESCRIPTOR *CAnnotationSet::_ReadMark(LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD)
{
    assert(*(UNALIGNED UINT*)pMark == 5);
    LPBYTE pBegin;
    UINT cbMark;                // size of the ANNOTATIONMARK in pMark
    UINT cbNamedBlocks = -1;         // size of the named blocks in pMark
    UINT cbDesc = sizeof(UINT); // size of the ANNOTATIONDESCRIPTOR
    ANNOTATIONDESCRIPTOR *pDesc = NULL;

    *ppNext = NULL;
    if (pMark+8+sizeof(ANNOTATIONMARK)+sizeof(UINT) < pEOD)
    {
        // skip the type
        pMark+=4;
    //   point pBegin at the ANNOTATIONMARK struct
        pBegin=pMark+4;
        cbMark = *(UNALIGNED UINT*)pMark;
        assert(cbMark == sizeof(ANNOTATIONMARK));
        cbDesc+=cbMark;
        pMark+=4+cbMark;
        cbNamedBlocks = _NamedBlockDataSize(6, pMark, pEOD);
    }
    if (-1 != cbNamedBlocks)
    {
    
        cbDesc+=cbNamedBlocks;
        // Allocate the descriptor
        pDesc =(ANNOTATIONDESCRIPTOR *)new BYTE[cbDesc];
    }
    if(pDesc)
    {
        UINT uOffset = 0;
        // populate the descriptor
        pDesc->cbSize = cbDesc;
        CopyMemory(&pDesc->mark, pBegin, sizeof(pDesc->mark));
        // Set pBegin at the beginning of the named blocks and read them in
        pBegin+=cbMark;
        NAMEDBLOCK *pBlock =(NAMEDBLOCK*)(&pDesc->blocks);
        while(uOffset < cbNamedBlocks)
        {
            assert(*(UNALIGNED UINT*)(pBegin+uOffset) == 6);
            uOffset += 4;
            assert(*(UNALIGNED UINT*)(pBegin+uOffset) = 12); // name plus data size
            uOffset+=4;
            // Copy in the name of the block
            lstrcpynA(pBlock->szType,(LPCSTR)(pBegin+uOffset), ARRAYSIZE(pBlock->szType));
            uOffset+=8;
            cbMark = *(UNALIGNED UINT*)(pBegin+uOffset);
            // Calculate the total size of the NAMEDBLOCK structure
            pBlock->cbSize = sizeof(pBlock->cbSize)+sizeof(pBlock->szType)+cbMark;
            uOffset+=4;
            CopyMemory(&pBlock->data,pBegin+uOffset, cbMark);
            uOffset+=cbMark;
            // move our block pointer to the next chunk
            pBlock =(NAMEDBLOCK*)((LPBYTE)pBlock+pBlock->cbSize);
        }
        *ppNext =(LPBYTE)(pBegin+cbNamedBlocks);
    }
    return pDesc;
}

void CAnnotationSet::_ClearMarkList()
{
    if(_dpaMarks)
    {
        DPA_DestroyCallback(_dpaMarks, _FreeMarks, NULL);
        _dpaMarks = NULL;
    }
    if (_pDefaultData != c_pDefaultData)
    {
       delete[] _pDefaultData;
    }
    _pDefaultData = (LPBYTE)c_pDefaultData;
    _cbDefaultData = c_cbDefaultData;
}

int CALLBACK CAnnotationSet::_FreeMarks(LPVOID pMark, LPVOID pUnused)
{
    delete (CAnnotation*)pMark;
    return 1;
}

HRESULT CAnnotationSet::_SaveAnnotationProperty(Image* pimg, LPBYTE pData, SIZE_T cbBuffer)
{
    HRESULT hr = S_OK;
    if (!pData)
    {
        hr = (Ok == pimg->RemovePropertyItem(ANNOTATION_IMAGE_TAG));
    }
    else
    {
        PropertyItem pi;
        pi.id = ANNOTATION_IMAGE_TAG;
        pi.length = (ULONG)cbBuffer;
        pi.type = PropertyTagTypeByte;
        pi.value = pData;
        hr = (Ok == pimg->SetPropertyItem(&pi)) ? S_OK : E_FAIL;
    }
    return hr;
}

CAnnotation::CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor)
{
    NAMEDBLOCK *pb;

    CopyMemory(&_mark, &pDescriptor->mark, sizeof(_mark));
    // every annotation read from the image should have a group name
    // and an index
    m_bDragging = FALSE;
    _szGroup = NULL;
    pb = _FindNamedBlock("OiGroup", pDescriptor);
    if(pb)
    {
        _szGroup = new char[pb->cbSize-sizeof(pb->szType)];
        if(_szGroup)
        {
            lstrcpyA(_szGroup,(LPCSTR)(pb->data));
        }
    }
    _pUGroup = (FILENAMEDBLOCK*)c_pDefaultUGroup;
    pb = _FindNamedBlock("OiUGroup", pDescriptor);
    if (pb)
    {
        _pUGroup = (FILENAMEDBLOCK*)new BYTE[pb->cbSize-1];
        if (_pUGroup)
        {
            CopyMemory(_pUGroup->szType, pb->szType, ARRAYSIZE(_pUGroup->szType));
            _pUGroup->cbSize = pb->cbSize-CBNAMEDBLOCK-1;
            CopyMemory(_pUGroup->data, pb->data, _pUGroup->cbSize); 
        }
        else
        {
            _pUGroup = (FILENAMEDBLOCK*)c_pDefaultUGroup;
        }
    }
    _nCurrentOrientation = 0;
    _hGadget = NULL;
}

BOOL CAnnotation::Initialize(HGADGET hgadParent)
{
    BOOL bRet = TRUE;
    _hGadget = CreateGadget(hgadParent, GC_SIMPLE, AnnotGadgetProc, this);
    if (!_hGadget)
    {
        bRet= FALSE;
    }
    else
    {
        SetGadgetMessageFilter(_hGadget, NULL, 
                               ANNOTFILTER,
                               ANNOTFILTER);
        SetGadgetRect(_hGadget,
                      _mark.lrBounds.left,
                      _mark.lrBounds.top,
                      RECTWIDTH(&_mark.lrBounds),
                      RECTHEIGHT(&_mark.lrBounds),
                      SGR_PARENT | SGR_MOVE | SGR_SIZE);
        SetGadgetRect(_hGadget, 0, 0, RECTWIDTH(&_mark.lrBounds),
                      RECTHEIGHT(&_mark.lrBounds),SGR_CLIENT|SGR_SIZE);
        SetGadgetStyle(_hGadget, 
                       GS_MOUSEFOCUS | GS_VISIBLE | GS_BUFFERED | GS_OPAQUE | GS_VISIBLE, 
                       GS_MOUSEFOCUS | GS_VISIBLE | GS_BUFFERED | GS_OPAQUE | GS_VISIBLE);        
        if (_mark.bHighlighting)
        {
            SetAlpha(_hGadget, 150);
        }
        if (_nCurrentOrientation)
        {
            int nRestore = _nCurrentOrientation;
            // make sure the rect is correct
            if (_nCurrentOrientation == 900 || _nCurrentOrientation == 2700)
            {
                Rotate(RECTHEIGHT(&_mark.lrBounds), RECTWIDTH(&_mark.lrBounds), _nCurrentOrientation == 2700);
                _nCurrentOrientation = nRestore;
            }
            // make sure the text will be right
            SetGadgetCenterPoint(_hGadget, RECTWIDTH(&_mark.lrBounds)/(float)2.0, RECTHEIGHT(&_mark.lrBounds)/(float)2.0);
            VARIANT var = {0};
            VARIANT varStr = {0};
            var.vt = VT_R4;
            var.fltVal = (float)(PI*_nCurrentOrientation)/(float)1800.0;
            SetGadgetRotation(_hGadget, var.fltVal);
            VariantChangeType(&varStr, &var, 0, VT_BSTR);
            TCHAR szOut[MAX_PATH];
            wsprintf(szOut, TEXT("Value of text rotation: %d degrees, %ls radians\n"), _nCurrentOrientation, varStr.bstrVal);
            OutputDebugString(szOut);
            VariantClear(&varStr);
        }
    }
    return bRet;
}

// return a blank annotation object
CAnnotation *CAnnotation::CreateAnnotation(UINT type, ULONG uCreationScale, HGADGET hgadParent)
{
    ANNOTATIONDESCRIPTOR desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.cbSize = sizeof(desc.cbSize)+sizeof(desc.mark)+sizeof(desc.blocks);
    desc.mark.uType = type;
    // MSDN mentions this required permission value
    desc.mark.dwPermissions = 0x0ff83f;
    desc.mark.bVisible = 1;
    return CreateAnnotation(&desc, uCreationScale, hgadParent);
}

CAnnotation *CAnnotation::CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, HGADGET hgadParent)
{

    CAnnotation *pNew = NULL;
    switch(pDescriptor->mark.uType)
    {
        case MT_IMAGEEMBED:
        case MT_IMAGEREF:
            pNew = new CImageMark(pDescriptor, pDescriptor->mark.uType == MT_IMAGEEMBED);
            break;
        case MT_STRAIGHTLINE:
        case MT_FREEHANDLINE:
            pNew = new CLineMark(pDescriptor, pDescriptor->mark.uType == MT_FREEHANDLINE);
            break;
        case MT_FILLRECT:
        case MT_HOLLOWRECT:
            pNew = new CRectMark(pDescriptor);
            break;
        case MT_TYPEDTEXT:
            pNew = new CTypedTextMark(pDescriptor, uCreationScale);
            break;
        case MT_FILETEXT:
            pNew = new CFileTextMark(pDescriptor, uCreationScale);
            break;
        case MT_STAMP:
            pNew = new CTextStampMark(pDescriptor, uCreationScale);
            break;
        case MT_ATTACHANOTE:
            pNew = new CAttachNoteMark(pDescriptor, uCreationScale);
            break;
        default:

            break;
    }
    if (pNew && !pNew->Initialize(hgadParent))
    {
        delete pNew;
        pNew = NULL;
    }
    return pNew;
}

NAMEDBLOCK *CAnnotation::_FindNamedBlock(LPCSTR szName, ANNOTATIONDESCRIPTOR *pDescriptor)
{
    NAMEDBLOCK *pCur;
    NAMEDBLOCK *pRet = NULL;
    UINT uOffset;
    LPBYTE pb =(LPBYTE)pDescriptor;
    uOffset = sizeof(pDescriptor->cbSize)+sizeof(pDescriptor->mark);
    while(!pRet && uOffset < pDescriptor->cbSize)
    {
        pCur =(NAMEDBLOCK*)(pb+uOffset);
        if(!lstrcmpA(pCur->szType, szName))
        {
            pRet = pCur;
        }
        else
        {
            if (pCur->cbSize == 0)
                return NULL;

            uOffset+=pCur->cbSize;
        }
    }
    return pRet;
}

CAnnotation::~CAnnotation()
{
    if(_szGroup)
    {
        delete _szGroup;
    }
    if (_pUGroup && _pUGroup != (FILENAMEDBLOCK*)c_pDefaultUGroup)
    {
        delete [] (BYTE*)_pUGroup;
    }
    
}

// GetBlob writes out the ANNOTATIONMARK plus the group and index blocks
// It then queries the subclass through a virtual function to get
// extra named blocks
//
HRESULT CAnnotation::GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex)
{
    SIZE_T cbExtra = 0;
    HRESULT hr = S_OK;
    LPCSTR szGroup = _szGroup;
    if (szGroup == NULL)
        szGroup = szDefaultGroup;

    // add in the ANNOTATIONMARK
    cbSize = sizeof(_mark);
    // for the group and index, add in the
    cbSize += 2*(CBDATATYPE+CBNAMEDBLOCK);
    // add in the length of the group name
    cbSize += lstrlenA(szGroup)+1;
    // add in the size of the index string
    cbSize += CBINDEX;
    if (_pUGroup)
    {
        cbSize += CBDATATYPE+CBNAMEDBLOCK+_pUGroup->cbSize;
    }
    // Add in the size of any named blocks from the subclass
    _WriteBlocks(cbExtra, NULL);
    cbSize += cbExtra;
    if (pBuffer)
    {
        // now write the data
        CopyMemory (pBuffer, &_mark, sizeof(_mark));
        pBuffer += sizeof(_mark);
        // write the mark-specific blocks before the group and index blocks
        if (cbExtra)
        {
            if (SUCCEEDED(_WriteBlocks(cbExtra, pBuffer)))
            {
                pBuffer+=cbExtra;
            }
        }
        // write the group and index blocks
        if (_pUGroup)
        {
            *(UNALIGNED UINT*)pBuffer = 6;
            *(UNALIGNED UINT*)(pBuffer + 4) = CBNAMEDBLOCK;
            CopyMemory(pBuffer+CBDATATYPE,_pUGroup, CBNAMEDBLOCK+_pUGroup->cbSize);
            pBuffer += CBDATATYPE + CBNAMEDBLOCK+_pUGroup->cbSize;
        }
        pBuffer += _WriteStringBlock(pBuffer, 6, c_szGroup, szGroup, lstrlenA(szGroup)+1);
        pBuffer += _WriteStringBlock(pBuffer, 6, c_szIndex, szNextIndex, CBINDEX);
    }
    return hr;
}

void CAnnotation::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RECT rect = _mark.lrBounds;
    RotateHelper((LPPOINT)&rect, 2, nNewImageWidth, nNewImageHeight, bClockwise);
    NormalizeRect(&rect);
    _mark.lrBounds = rect;
}

void CAnnotation::GetFont(LOGFONTW& lfFont)
{
    lfFont.lfHeight = _mark.lfFont.lfHeight;
    lfFont.lfWidth = _mark.lfFont.lfWidth;
    lfFont.lfEscapement = _mark.lfFont.lfEscapement;
    lfFont.lfOrientation = _mark.lfFont.lfOrientation;
    lfFont.lfWeight = _mark.lfFont.lfWeight;
    lfFont.lfItalic = _mark.lfFont.lfItalic;
    lfFont.lfUnderline = _mark.lfFont.lfUnderline;
    lfFont.lfStrikeOut = _mark.lfFont.lfStrikeOut;
    lfFont.lfCharSet = _mark.lfFont.lfCharSet;
    lfFont.lfOutPrecision = _mark.lfFont.lfOutPrecision;
    lfFont.lfClipPrecision = _mark.lfFont.lfClipPrecision;
    lfFont.lfQuality = _mark.lfFont.lfQuality;
    lfFont.lfPitchAndFamily = _mark.lfFont.lfPitchAndFamily;

    ::MultiByteToWideChar(CP_ACP, 0, _mark.lfFont.lfFaceName, LF_FACESIZE, lfFont.lfFaceName, LF_FACESIZE);
}

void CAnnotation::SetFont(LOGFONTW& lfFont)
{
    _mark.lfFont.lfHeight = lfFont.lfHeight;
    _mark.lfFont.lfWidth = lfFont.lfWidth;
    _mark.lfFont.lfEscapement = lfFont.lfEscapement;
    _mark.lfFont.lfOrientation = lfFont.lfOrientation;
    _mark.lfFont.lfWeight = lfFont.lfWeight;
    _mark.lfFont.lfItalic = lfFont.lfItalic;
    _mark.lfFont.lfUnderline = lfFont.lfUnderline;
    _mark.lfFont.lfStrikeOut = lfFont.lfStrikeOut;
    _mark.lfFont.lfCharSet = lfFont.lfCharSet;
    _mark.lfFont.lfOutPrecision = lfFont.lfOutPrecision;
    _mark.lfFont.lfClipPrecision = lfFont.lfClipPrecision;
    _mark.lfFont.lfQuality = lfFont.lfQuality;
    _mark.lfFont.lfPitchAndFamily = lfFont.lfPitchAndFamily;

    ::WideCharToMultiByte(CP_ACP, 0, lfFont.lfFaceName, LF_FACESIZE, _mark.lfFont.lfFaceName, LF_FACESIZE, NULL, NULL);
}

SIZE_T CAnnotation::_WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT*)pBuffer = uType;
        *(UNALIGNED UINT*)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), szName, CBNAMEDBLOCK+1); // named block name
        *(UNALIGNED UINT*)(pBuffer + CBDATATYPE + 8) = (UINT)len; // the named block name isn't null terminated
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, szData, len);
    }
    return CBDATATYPE + CBNAMEDBLOCK + len;
}

SIZE_T CAnnotation::_WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints)
{
    UINT cbAnPoints = sizeof(int)+sizeof(int)+nPoints*sizeof(POINT);
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnoDat, CBNAMEDBLOCK+1);
        pBuffer += CBDATATYPE + 8;
        *(UNALIGNED UINT *)pBuffer = cbAnPoints;
        pBuffer+=4;
        // Write out the ANPOINTS equivalent
        *(UNALIGNED int*)pBuffer = nMaxPoints;
        *(UNALIGNED int*)(pBuffer+4) = nPoints;
        CopyMemory(pBuffer+8, ppts, nPoints*sizeof(POINT));
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbAnPoints;
}

SIZE_T CAnnotation::_WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnoDat, CBNAMEDBLOCK+1);
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = sizeof(ANROTATE);
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, pRotate, sizeof(ANROTATE));
    }
    return CBDATATYPE + CBNAMEDBLOCK + sizeof(ANROTATE);
}


SIZE_T CAnnotation::_WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen)
{
    LPCSTR pText = szText ? szText : "";
    UINT cbString =  min(lstrlenA(pText)+1, nMaxLen);
    UINT cbPrivData = sizeof(ANTEXTPRIVDATA)+cbString;

    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer + 4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnText, CBNAMEDBLOCK+1);
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = cbPrivData;
        // write out the ANTEXTPRIVDATA equivalent
        pBuffer += CBDATATYPE + CBNAMEDBLOCK;
        *(UNALIGNED int*)pBuffer = nOrient;
        *(UNALIGNED UINT *)(pBuffer+4) = 1000;
        *(UNALIGNED UINT *)(pBuffer+8) = uScale;
        *(UNALIGNED UINT *)(pBuffer+12) = cbString;
        lstrcpynA((LPSTR)(pBuffer+16), pText, nMaxLen);
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbPrivData;
}

SIZE_T CAnnotation::_WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib)
{
    if (pBuffer)
    {
        *(UNALIGNED UINT *)pBuffer = uType;
        *(UNALIGNED UINT *)(pBuffer+4) = CBNAMEDBLOCK;
        lstrcpynA((LPSTR)(pBuffer + CBDATATYPE), c_szAnText, CBNAMEDBLOCK+1);


/* REVIEW_SDK
        Now that I think about it, it might make sense to define a struct that could make this more clear.
        Something like:

        struct AnnoBlock
        {
                UINT uBlockType;
                UINT uBlockSize;
                CHAR sName[8]; // Not NULL terminated
                UINT uVariableDataSize;
                BYTE Data[];
        };

*/
        *(UNALIGNED UINT *)(pBuffer + CBDATATYPE + 8) = (UINT)cbDib;
        CopyMemory(pBuffer + CBDATATYPE + CBNAMEDBLOCK, pDib, cbDib);
    }
    return CBDATATYPE + CBNAMEDBLOCK + cbDib;
}

void CAnnotation::Resize(RECT rectNewSize) 
{ 
    _mark.lrBounds = rectNewSize; 
    NormalizeRect(&_mark.lrBounds);
    SetGadgetRect(_hGadget, _mark.lrBounds.left, _mark.lrBounds.top,
                  RECTWIDTH(&_mark.lrBounds), RECTHEIGHT(&_mark.lrBounds),
                  SGR_PARENT | SGR_MOVE | SGR_SIZE);
}

CRectMark::CRectMark(ANNOTATIONDESCRIPTOR *pDescriptor)
    : CAnnotation(pDescriptor)
{
    // rects have no named blocks to read
}

void CRectMark::Render(Graphics &g)
{
    BYTE a = _mark.bHighlighting ? 255 : 200;

    if (_mark.uType == MT_HOLLOWRECT)
    {
        Pen pen(Color(a, _mark.rgbColor1.rgbRed,_mark.rgbColor1.rgbGreen,_mark.rgbColor1.rgbBlue),
                max(1, (REAL)_mark.uLineSize));
        g.DrawRectangle(&pen, 0, 0, 
                      RECTWIDTH(&_mark.lrBounds), RECTHEIGHT(&_mark.lrBounds));
    }
    else
    {
        SolidBrush brush(Color(a, _mark.rgbColor1.rgbRed,_mark.rgbColor1.rgbGreen,_mark.rgbColor1.rgbBlue));
        g.FillRectangle(&brush, 0, 0, 
                      RECTWIDTH(&_mark.lrBounds), RECTHEIGHT(&_mark.lrBounds));
    }
}

CImageMark::CImageMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded) :
    CAnnotation(pDescriptor), _pBitmap(NULL), _pDib(NULL)
{
    ZeroMemory(&_rotation, sizeof(_rotation));
    NAMEDBLOCK *pb = _FindNamedBlock(c_szAnoDat, pDescriptor);
    UINT cb;
    _cbDib = 0;
    _bRotate = false;
    if (pb)
    {
        CopyMemory(&_rotation, pb->data, sizeof(_rotation));
    }
    pb= _FindNamedBlock(c_szFilNam, pDescriptor);
    if (pb)
    {
        cb = pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType);
        _szFilename = new char[cb+1];
        if (_szFilename)
        {
            lstrcpynA (_szFilename, (LPCSTR)(pb->data), cb+1);
        }
    }
    pb = _FindNamedBlock(c_szDIB, pDescriptor);
    if (pb)
    {
        assert (bEmbedded);
        cb = pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType);
        _pDib = new BYTE[cb];
        if (_pDib)
        {
            CopyMemory (_pDib, pb->data, cb);
            _cbDib = cb;
        }
        // what do we do if allocation fails?
    }
    // If an image has IoAnoDat, the structure is a rotation structure
    pb = _FindNamedBlock(c_szAnoDat, pDescriptor);
    if (pb)
    {
        assert(pb->cbSize-sizeof(pb->cbSize)-sizeof(pb->szType) == sizeof(_rotation));
        _bRotate = true;
        CopyMemory(&_rotation, pb->data, sizeof(_rotation));
    }
}

CImageMark::~CImageMark()
{
    if (_pDib)
    {
        delete [] _pDib;
    }
    if (_szFilename)
    {
        delete [] _szFilename;
    }
}

HRESULT CImageMark::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    cbSize = 0;
    if (_szFilename)
    {
        cbSize += _WriteStringBlock(pBuffer, 6, c_szFilNam, _szFilename, lstrlenA(_szFilename)+1);
    }
    if (_pDib)
    {
        cbSize += _WriteImageBlock(pBuffer, 6, _pDib, _cbDib);
    }
    if (_bRotate)
    {
        cbSize += _WriteRotateBlock(pBuffer, 6, &_rotation);
    }
    return S_OK;
}

void CImageMark::Render(Graphics &g)
{

}

CLineMark::CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand)
    : CAnnotation(pDescriptor)
{
    NAMEDBLOCK *pb=_FindNamedBlock(c_szAnoDat, pDescriptor);
    _points = NULL;
    _nPoints = 0;
    if (pb)
    {
        ANPOINTS *ppts = (ANPOINTS*)&pb->data;
        _iMaxPts = bFreehand ? ppts->nMaxPoints : 2;

        assert(_nPoints > 2?bFreehand:TRUE);
        _points = new POINT[_iMaxPts];
        if (_points)
        {
            _nPoints = ppts->nPoints;
            CopyMemory (_points, &ppts->ptPoint, sizeof(POINT)*_nPoints);
            /*
            // each point is relative to the upper left corner of _mark.lrBounds
            for (int i=0;i<_nPoints;i++)
            {
                _points[i].x; += _mark.lrBounds.left;
                _points[i].y; += _mark.lrBounds.top;
            }
            */
        }
    }
}

CLineMark::~CLineMark()
{
    if (_points)
    {
        delete [] _points;
    }
}

void CLineMark::SetPoints(POINT* pPoints, int cPoints)
{
    assert(_mark.uType == MT_FREEHANDLINE);

    if (_points != NULL)
        delete[] _points;

    _points = pPoints;
    _nPoints = cPoints;
    _iMaxPts = _nPoints;

    RECT rect;
    rect.left = _points[0].x;
    rect.top = _points[0].y;
    rect.right = _points[0].x;
    rect.bottom = _points[0].y;

    for(int i = 1; i < _nPoints; i++)
    {
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

void CLineMark::Render(Graphics &g)
{
    BYTE a = _mark.bHighlighting ? 255 : 200;

    Pen pen(Color(a, _mark.rgbColor1.rgbRed,_mark.rgbColor1.rgbGreen,_mark.rgbColor1.rgbBlue),
                  max(1, (REAL)_mark.uLineSize));
    Point *pts = new Point[_nPoints];
    if (pts)
    {
        for (int i=0;i<_nPoints;i++)
        {
            pts[i].X = _points[i].x;
            pts[i].Y = _points[i].y;
        }
        g.DrawLines(&pen,  pts, _nPoints);
        delete [] pts;
    }
}

void CLineMark::GetRect(RECT &rect)
{
    int nPadding = (_mark.uLineSize / 2) + 6;
    rect = _mark.lrBounds;
    // one because LineTo is inclusive
    // one for rounding error on odd line widths
    // one for rounding error in scaling large files
    // and three more just so we don't have to tweak this again
    
    rect = _mark.lrBounds;
    InflateRect(&rect, nPadding , nPadding);
}

// Usually we are interested in the bounding rect of the line above
// but if we are directly manipulating the line we need a way to get 
// to the unadjusted points (left, top) and (right, bottom)
void CLineMark::GetPointsRect(RECT &rect)
{
    if (_nPoints != 2)
        return;

    rect.top = _points[0].y;
    rect.left = _points[0].x;
    rect.bottom = _points[1].y;
    rect.right = _points[1].x;
}

void CLineMark::Move(SIZE sizeOffset)
{
    _points[0].x += sizeOffset.cx;
    _points[0].y += sizeOffset.cy;

    RECT rect;
    rect.left = _points[0].x;
    rect.top = _points[0].y;
    rect.right = _points[0].x;
    rect.bottom = _points[0].y;

    for(int i = 1; i < _nPoints; i++)
    {
        _points[i].x += sizeOffset.cx;
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        _points[i].y += sizeOffset.cy;
        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

void CLineMark::Resize(RECT rectNewSize)
{
    if ((_points == NULL) && (_mark.uType == MT_STRAIGHTLINE))
    {
      _iMaxPts = _nPoints = 2;
      _points = new POINT[_iMaxPts];
    }

    if ((_nPoints == 2) && (_points != NULL))
    {
        _points[0].y = rectNewSize.top;
        _points[0].x = rectNewSize.left;
        _points[1].y = rectNewSize.bottom;
        _points[1].x = rectNewSize.right;
        
        _mark.lrBounds = rectNewSize;

        NormalizeRect(&_mark.lrBounds);
    }
}

void CLineMark::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RotateHelper(_points, _nPoints, nNewImageWidth, nNewImageHeight, bClockwise);

    RECT rect;
    rect.left = _points[0].x;
    rect.top = _points[0].y;
    rect.right =  _points[0].x;
    rect.bottom = _points[0].y;
    for(int i = 1; i < _nPoints; i++)
    {
        if (rect.left > _points[i].x)
            rect.left = _points[i].x;
        else if (rect.right < _points[i].x)
            rect.right = _points[i].x;

        if (rect.top > _points[i].y)
            rect.top = _points[i].y;
        else if (rect.bottom < _points[i].y)
            rect.bottom = _points[i].y;
    }

    _mark.lrBounds = rect;
}

HRESULT CLineMark::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    if (_points)
    {
        for (int i=0;i<_nPoints;i++)
        {
            _points[i].x -= _mark.lrBounds.left;
            _points[i].y -= _mark.lrBounds.top;
        }

        cbSize = _WritePointsBlock(pBuffer, 6, _points, _nPoints, _iMaxPts);

        for (int i=0;i<_nPoints;i++)
        {
            _points[i].x += _mark.lrBounds.left;
            _points[i].y += _mark.lrBounds.top;
        }
    }

    return S_OK;
}

CTextAnnotation::CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxLen, bool bUseColor2 )
    : CAnnotation(pDescriptor)
{
    NAMEDBLOCK *pb = _FindNamedBlock(c_szAnText, pDescriptor);
    _nCurrentOrientation  = 0;
    _uCreationScale = 0;
    _uAnoTextLength = 0;
    _szText = NULL;
    _nMaxText = nMaxLen;
    _bUseColor2 = bUseColor2;
    if (pb)
    {
        ANTEXTPRIVDATA *pData = (ANTEXTPRIVDATA*)&pb->data;
        _szText = new char[pData->uAnoTextLength+1];
        if (_szText)
        {
            _nCurrentOrientation = pData->nCurrentOrientation;
            switch (_nCurrentOrientation)
            {
                case 900:
                    _nCurrentOrientation = 2700; // spec is opposite of duser
                    break;
                case 2700:
                    _nCurrentOrientation = 900;
                    break;
            }
            _uCreationScale = pData->uCreationScale;
            _uAnoTextLength = pData->uAnoTextLength;
            lstrcpynA (_szText, pData->szAnoText, _uAnoTextLength+1);
        }
    }
    if (_uCreationScale == 0)
    {
        _uCreationScale = 72000 / uCreationScale;
    }
    
}

CTextAnnotation::~CTextAnnotation()
{
    if (_szText)
    {
        delete [] _szText;
    }
}

void CTextAnnotation::Render(Graphics &g)
{                
    if (_mark.uType == MT_ATTACHANOTE)
    {
        SolidBrush brush(Color(_mark.rgbColor1.rgbRed,_mark.rgbColor1.rgbGreen,_mark.rgbColor1.rgbBlue));
        g.FillRectangle(&brush, 0, 0, RECTWIDTH(&_mark.lrBounds), RECTHEIGHT(&_mark.lrBounds));
    }
    LOGFONT lf;
    GetFont(lf);

    lf.lfHeight = GetFontHeight(g);

    HFONT hFont = CreateFontIndirect(&lf);
    HDC hdc = g.GetHDC();
    Font font(hdc, hFont);
    g.ReleaseHDC(hdc);
    BSTR bstrText = GetText();
    RectF rcString(0, 0, (REAL)RECTWIDTH(&_mark.lrBounds), (REAL)RECTHEIGHT(&_mark.lrBounds));
    SolidBrush brush(Color(_mark.rgbColor2.rgbRed,_mark.rgbColor2.rgbGreen,_mark.rgbColor2.rgbBlue));
    g.DrawString(bstrText, SysStringLen(bstrText), &font, rcString, NULL, &brush);
    
}

LONG CTextAnnotation::GetFontHeight(Graphics &g)
{
    LONG lHeight = MulDiv(_mark.lfFont.lfHeight, 96, 72);
//> REVIEW : This needs work, the 1000 below is rather random and should be fixed after Beta1
    lHeight = MulDiv(lHeight, 1000, _uCreationScale);
    lHeight = max(lHeight, 2);

    return lHeight;
}

BSTR CTextAnnotation::GetText()
{
    if (_szText == NULL)
        return NULL;

    int nLen = ::MultiByteToWideChar(CP_ACP, 0, _szText, -1, NULL, NULL);

    BSTR bstrResult = ::SysAllocStringLen(NULL, nLen);
    if (bstrResult != NULL)
    {
        ::MultiByteToWideChar(CP_ACP, 0, _szText, -1, bstrResult, nLen);
    }
    return bstrResult;
}

void CTextAnnotation::SetText(BSTR bstrText)
{
    UINT nLen = ::WideCharToMultiByte(CP_ACP, 0, bstrText, -1, NULL, 0, NULL, NULL);
    if (nLen > _nMaxText)
        return;

    if (nLen > _uAnoTextLength)
    {
        if (_szText != NULL)
        {
            delete [] _szText;
        }
        _uAnoTextLength = nLen - 1;
        _szText = new char[_uAnoTextLength+1];
    }

    if (_szText)
        ::WideCharToMultiByte(CP_ACP, 0, bstrText, -1, _szText, nLen, NULL, NULL);
}

void CTextAnnotation::Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise)
{
    RotateHelper((LPPOINT)&_mark.lrBounds, 2, nNewImageWidth, nNewImageHeight, bClockwise);
    NormalizeRect(&_mark.lrBounds);
    
    if (bClockwise)
        _nCurrentOrientation += 2700;
    else
        _nCurrentOrientation += 900;

    _nCurrentOrientation = _nCurrentOrientation % 3600;
}


HRESULT CTextAnnotation::_WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer)
{
    cbSize = _WriteTextBlock(pBuffer,
                             6,
                             _nCurrentOrientation,
                             _uCreationScale,
                             _szText,
                             _nMaxText);
    return S_OK;
}

CTypedTextMark::CTypedTextMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale)
{
}


CFileTextMark::CFileTextMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale)
{
}


CTextStampMark::CTextStampMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale, 255)
{
}

CAttachNoteMark::CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale)
    : CTextAnnotation(pDescriptor, uCreationScale, 65536, true)
{
}



HRESULT CAnnotationSet::AnnotParentProc(HGADGET hGadget, LPVOID pv, EventMsg *pmsg)
{
    HRESULT hr = DU_S_NOTHANDLED;
    DumpMessage(TEXT("CAnnotationSet::AnnotParentProc"), pmsg);
    return hr;
}

HRESULT CAnnotation::AnnotGadgetProc(HGADGET hGadget, LPVOID pv, EventMsg *pmsg)
{
    HRESULT hr = DU_S_NOTHANDLED;
    CAnnotation *pThis = reinterpret_cast<CAnnotation*>(pv);
    DumpMessage(TEXT("CAnnotation::AnnotGadgetProc"), pmsg);
    if (GET_EVENT_DEST(pmsg) == GMF_DIRECT)
    {
        switch (pmsg->nMsg)
        {
            case GM_PAINT:
            {
                GMSG_PAINT * pmsgP = reinterpret_cast<GMSG_PAINT *>(pmsg);
                if ((pmsgP->nCmd == GPAINT_RENDER))
                {
                    if (pmsgP->nSurfaceType == GSURFACE_GPGRAPHICS )
                    {
                        pThis->Render(*(reinterpret_cast<GMSG_PAINTRENDERF *>(pmsgP)->pgpgr));
                    }
                    hr = DU_S_COMPLETE;
                }
            }
            break;
            case GM_INPUT:
            {
                GMSG_INPUT *pmsgI = reinterpret_cast<GMSG_INPUT*>(pmsg);
                switch (pmsgI->nCode)
                {
                    case GMOUSE_DOWN:
                        hr = pThis->OnMouseDown(reinterpret_cast<GMSG_MOUSE*>(pmsg));
                    break;
                    case GMOUSE_DRAG:
                        pThis->OnMouseDrag(reinterpret_cast<GMSG_MOUSEDRAG*>(pmsg));
                        hr = DU_S_COMPLETE;
                    break;
                    case GMOUSE_UP:
                        hr = pThis->OnMouseUp(reinterpret_cast<GMSG_MOUSE*>(pmsg));
                    break;
                }
            }
            break;
        }
    }
    return hr;
}

HRESULT
CAnnotation::OnMouseDown(GMSG_MOUSE *pmsg)
{
    HRESULT hr = DU_S_NOTHANDLED;
    if (pmsg->bButton == GBUTTON_LEFT)
    {
        m_bDragging = TRUE;
        SetGadgetOrder(_hGadget, NULL, GORDER_TOP);
        hr = DU_S_COMPLETE;
    }
    return hr;
}

void
CAnnotation::OnMouseDrag(GMSG_MOUSEDRAG *pmsgM)
{
    if (m_bDragging)
    {
        float flX;
        float flY;
        int cx;
        int cy;
        GetGadgetScale(_hGadget, &flX, &flY);
        cx = (int)(flX*pmsgM->sizeDelta.cx);
        cy = (int)(flY*pmsgM->sizeDelta.cy);
        SetGadgetRect(_hGadget, 
                      cx,cy,
                      0, 0, SGR_MOVE | SGR_OFFSET);
        OffsetRect(&_mark.lrBounds, cx ,cy);        
    }
}

HRESULT
CAnnotation::OnMouseUp(GMSG_MOUSE *pmsg)
{
    HRESULT hr = DU_S_NOTHANDLED;
    if (pmsg->bButton == GBUTTON_LEFT)
    {
        m_bDragging = FALSE;
        hr = DU_S_COMPLETE;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\printui\wow64.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999
All rights reserved.

Module Name:

    wow64.h

Abstract:

    printui wow64 related functions.

Author:

    Lazar Ivanov (LazarI)  10-Mar-2000

Revision History:

--*/

#ifndef _WOW64_H
#define _WOW64_H

#ifdef __cplusplus
extern "C" 
{
#endif

//
// Win64 APIs, types and data structures.
//

typedef enum
{
    RUN32BINVER     = 4,
    RUN64BINVER     = 8
} ClientVersion;

typedef enum
{
    NATIVEVERSION   = 0,
    THUNKVERSION    = 1
} ServerVersion;

typedef enum 
{
   kPlatform_IA64,
   kPlatform_x86,
} PlatformType;
 
ClientVersion
OSEnv_GetClientVer(
    VOID
    );

ServerVersion
OSEnv_GetServerVer(
    VOID
    );

BOOL
IsRunningWOW64(
    VOID
    );

PlatformType
GetCurrentPlatform(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _WOW64_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipic\duipic.cpp ===
#include <precomp.h>
#include "resource.h"
#include <shellapi.h>
#include "duipic.h"
#include "annot.h"
#pragma hdrstop

//
// This is a just a first stab at trying out DirectUser. We create
// a parent window and a dialog with controls for controlling various aspects
// of the currently loaded image. The image is hosted in a gadget.
// We use GDI+ to render the image, and DUser to set the attributes of the 
// gadget. Eventually we will replace the win32 config controls with DirectUI
// controls.

#define WM_SETIMAGEFILE WM_USER+100
#define WM_RESET        WM_USER+101

CComModule _Module;

class CGraphicsInit
{
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        GdiplusStartupInput gsi;
        GdiplusStartupOutput gso;
        GdiplusStartup(&_token, &gsi, &gso);
    };
    ~CGraphicsInit()
    {
        GdiplusShutdown(_token);
    };

};


class CConfigWindow : public CDialogImpl<CConfigWindow>
{
public:
    CConfigWindow();
    ~CConfigWindow();
    enum {IDD = IDD_CONTROL};
    VOID SetGadget(CImageGadget *pGadget);

    BEGIN_MSG_MAP(CConfigWindow)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
        COMMAND_ID_HANDLER(IDC_RESET, OnReset)
        COMMAND_ID_HANDLER(IDC_CHOOSEFILE, OnChooseFile)
        MESSAGE_HANDLER(WM_RESET, OnReset)
    END_MSG_MAP()

private:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled);
    LRESULT OnScroll(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled);
    LRESULT OnReset(WORD wCode, WORD wId, HWND hCtrl, BOOL &bHandled);
    LRESULT OnChooseFile(WORD wCode, WORD wId, HWND hCtrl, BOOL &bHandled);
    LRESULT OnReset(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled);
    CImageGadget *m_pGadget;
    struct _GeometryVal 
    {
        HWND hScroll;
        float rVal;
    } m_aScroll[3];
    enum ScrollIndex
    {
        XScale = 0,
        YScale,
        Rotation
    };
};

class CMainWindow : public CWindowImpl<CMainWindow>
{
public:
    CMainWindow();
    ~CMainWindow();

    BEGIN_MSG_MAP(CMainWindow)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
        MESSAGE_HANDLER(WM_CLOSE, OnClose)
        MESSAGE_HANDLER(WM_SETIMAGEFILE, OnImageFile)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_DROPFILES, OnDropFiles)
    END_MSG_MAP()

    DECLARE_WND_CLASS(TEXT("DuiPic:FrameWnd"));

private:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnImageFile(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDropFiles(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    CImageGadget* _CreateGadgetFromFile(LPCWSTR szFilename);
    
    HGADGET m_hgadForm;
    CGraphicsInit m_cgi;
};

static CConfigWindow *pConfigWindow;

CMainWindow::CMainWindow()    
{

}

CMainWindow::~CMainWindow()
{

}

LRESULT 
CMainWindow::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    pConfigWindow = new CConfigWindow();
    pConfigWindow->Create(m_hWnd);
    DragAcceptFiles(TRUE);
    //
    // Turn this window into a DUser container of gadgets
    m_hgadForm = CreateGadget(m_hWnd, GC_HWNDHOST, NULL, NULL);
    ROOT_INFO ri = {0};
    ri.cbSize = sizeof(ri);
    ri.nMask = GRIM_SURFACE;
    ri.nSurface = GSURFACE_GPGRAPHICS;
    SetGadgetRootInfo(m_hgadForm, &ri);
    SetGadgetStyle(m_hgadForm, GS_BUFFERED | GS_OPAQUE, GS_BUFFERED | GS_OPAQUE);
    SetGadgetFillF(m_hgadForm, new SolidBrush(Color::Gray));
    bHandled = TRUE;
    return 0;
}

LRESULT 
CMainWindow::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    pConfigWindow->DestroyWindow();
    DestroyWindow();
    bHandled = TRUE;
    return 0;
}

LRESULT 
CMainWindow::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PostQuitMessage(0);
    bHandled = TRUE;
    return 0;
}

LRESULT 
CMainWindow::OnImageFile(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    pConfigWindow->SetGadget(_CreateGadgetFromFile(reinterpret_cast<LPCWSTR>(lParam)));    
    InvalidateRect(NULL);
    UpdateWindow();
    ShowWindow(SW_SHOW);
    
    return 0;
}

CImageGadget*
CMainWindow::_CreateGadgetFromFile(LPCWSTR szFilename)
{
    CImageGadget *pGadget = new CImageGadget();
    if (pGadget)
    {
        if (!pGadget->Initialize(m_hgadForm, szFilename))
        {
            delete pGadget;
            pGadget = NULL;
        }
    }
    return pGadget;
}

LRESULT
CMainWindow::OnDropFiles(UINT msg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    HDROP hdrop = reinterpret_cast<HDROP>(wp);
    //
    // only 1 file at a time
    //
    TCHAR szFilename[MAX_PATH];
    if (DragQueryFile(hdrop, 0, szFilename, MAX_PATH))
    {
        OnImageFile(WM_SETIMAGEFILE, 0, reinterpret_cast<LPARAM>(szFilename), bHandled);
        bHandled=TRUE;
    }
    return 0;
}

CConfigWindow::CConfigWindow()
{
    m_pGadget = NULL;
}

CConfigWindow::~CConfigWindow()
{    
}



LRESULT 
CConfigWindow::OnInitDialog(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    //
    // Set the default values for max scale, then update the scrollbars
    //
    SetDlgItemInt(IDC_XSCALE_MAX, 5, FALSE);
    SetDlgItemInt(IDC_YSCALE_MAX, 5, FALSE);
    m_aScroll[XScale].hScroll = GetDlgItem(IDC_XSCALE);
    m_aScroll[YScale].hScroll = GetDlgItem(IDC_YSCALE);
    m_aScroll[Rotation].hScroll = GetDlgItem(IDC_ROTATION);

/*    SendDlgItemMessage(IDC_XSCALE, SBM_ENABLE_ARROWS, ESB_DISABLE_BOTH);
    SendDlgItemMessage(IDC_YSCALE, SBM_ENABLE_ARROWS, ESB_DISABLE_BOTH);
    SendDlgItemMessage(IDC_ROTATION, SBM_ENABLE_ARROWS, ESB_DISABLE_BOTH);*/
    OnReset(WM_RESET, 1L, (LPARAM)0L, bHandled);
    bHandled = TRUE;
    ShowWindow(SW_SHOW);
    return TRUE;
}

LRESULT 
CConfigWindow::OnScroll(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    SCROLLINFO si = {0};
    HWND hScroll = reinterpret_cast<HWND>(lp);
    BOOL bScroll = FALSE;
    si.cbSize = sizeof(si);
    float rVal;
    HGADGET h = m_pGadget->GetHandle();
    switch (LOWORD(wp))
    {
        case SB_THUMBTRACK:
        {
            si.fMask = SIF_TRACKPOS;
            ::GetScrollInfo(hScroll, SB_CTL, &si);
            //  
            //  Convert the position to a floating point number
            // The range max is 10000 times the displayed integer
            //
            rVal = (float)si.nTrackPos/(float)10000.0;
            bScroll = TRUE;
            
        }
        break;
        case SB_ENDSCROLL:
            ::SetScrollPos(m_aScroll[XScale].hScroll, SB_CTL, (int)(m_aScroll[XScale].rVal*10000.0), TRUE);
            ::SetScrollPos(m_aScroll[YScale].hScroll, SB_CTL, (int)(m_aScroll[YScale].rVal*10000.0), TRUE);
            ::SetScrollPos(m_aScroll[Rotation].hScroll, SB_CTL, (int)(m_aScroll[Rotation].rVal*10000.0), TRUE);
        break;
        case SB_PAGELEFT:
        case SB_LINELEFT:
        case SB_LEFT:
            bScroll = TRUE;
            si.fMask = SIF_POS;
            ::GetScrollInfo(hScroll, SB_CTL, &si);
            rVal = (float)si.nPos/(float)10000.0 - (float)0.1;           
            break;
        case SB_LINERIGHT:
        case SB_RIGHT:
        case SB_PAGERIGHT:
            bScroll = TRUE;
            si.fMask = SIF_POS;
            ::GetScrollInfo(hScroll, SB_CTL, &si);
            rVal = (float)si.nPos/(float)10000.0 + (float)0.1;           
            break;
    }  
    bHandled = TRUE;
    if (bScroll)
    {
        if (hScroll == m_aScroll[XScale].hScroll)
        {            
            SetGadgetScale(h, rVal, m_aScroll[YScale].rVal);
            m_aScroll[XScale].rVal = rVal;
            SetDlgItemInt(IDC_XSCALE_VAL, (UINT)rVal, FALSE);
        }
        else if (hScroll == m_aScroll[YScale].hScroll)
        {            
            SetGadgetScale(h, m_aScroll[XScale].rVal, rVal);
            m_aScroll[YScale].rVal = rVal;
            SetDlgItemInt(IDC_YSCALE_VAL, (UINT)rVal, FALSE);
        }
        else if (hScroll == m_aScroll[Rotation].hScroll)
        {
            SetGadgetRotation(h, rVal);
            m_aScroll[Rotation].rVal = rVal;
            SetDlgItemInt(IDC_ROTATION_VAL, (UINT)(rVal*180.0/PI), FALSE);
        }
    }
    return 0;
}

LRESULT 
CConfigWindow::OnReset(WORD wCode, WORD wId, HWND hCtrl, BOOL &bHandled)
{
    return OnReset(WM_RESET, 1L, (LPARAM)0L, bHandled);
}

LRESULT CConfigWindow::OnReset(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    UINT iVal = max(1,GetDlgItemInt(IDC_XSCALE_MAX, NULL, FALSE));    
    ::SetScrollRange(m_aScroll[XScale].hScroll, SB_CTL, 0, iVal*10000, FALSE);
    iVal = max(1,GetDlgItemInt(IDC_YSCALE_MAX, NULL, FALSE));
    ::SetScrollRange(m_aScroll[YScale].hScroll, SB_CTL, 0, iVal*10000, FALSE);
    ::SetScrollRange(m_aScroll[Rotation].hScroll, SB_CTL, 0, 62832, FALSE);
    
    if (wp)
    {
        m_aScroll[XScale].rVal = 1.0;
        m_aScroll[YScale].rVal = 1.0;
        m_aScroll[Rotation].rVal = 0.0;
        SetDlgItemInt(IDC_XSCALE_VAL, 1, FALSE);
        SetDlgItemInt(IDC_YSCALE_VAL, 1, FALSE);
        SetDlgItemInt(IDC_ROTATION_VAL, 0, FALSE);

        if (m_pGadget)
        {
            SetGadgetRotation(m_pGadget->GetHandle(), 0.0);
            SetGadgetScale(m_pGadget->GetHandle(),1.0, 1.0);
            SetGadgetRect(m_pGadget->GetHandle(), 0, 0, 0, 0, SGR_PARENT | SGR_MOVE);
        }
    }
    else
    {
        GetGadgetScale(m_pGadget->GetHandle(), &m_aScroll[XScale].rVal, &m_aScroll[YScale].rVal);
        GetGadgetRotation(m_pGadget->GetHandle(), &m_aScroll[Rotation].rVal);
    }
    ::SetScrollPos(m_aScroll[XScale].hScroll, SB_CTL, (int)(m_aScroll[XScale].rVal*(float)10000.0) , TRUE);
    ::SetScrollPos(m_aScroll[YScale].hScroll, SB_CTL, (int)(m_aScroll[YScale].rVal*(float)10000.0), TRUE);
    ::SetScrollPos(m_aScroll[Rotation].hScroll, SB_CTL, (int)(m_aScroll[Rotation].rVal*(float)10000.0), TRUE);
    bHandled = TRUE;
    return 0;
}
    
LRESULT 
CConfigWindow::OnChooseFile(WORD wCode, WORD wId, HWND hCtrl, BOOL &bHandled)
{
    bHandled = FALSE;
    return 0;
}

void
CConfigWindow::SetGadget(CImageGadget *pGadget)
{
    //
    // change the alpha of the active gadget to 255
    // the last active gadget gets 200
    BUFFER_INFO bi = {0};
    bi.cbSize = sizeof(bi);
    bi.nMask = GBIM_ALPHA;
    bi.bAlpha = 255;
    SetGadgetBufferInfo(pGadget->GetHandle(), &bi);
    InvalidateGadget(pGadget->GetHandle());
    if (m_pGadget && m_pGadget != pGadget)
    {
        SetGadgetOrder(pGadget->GetHandle(), NULL, GORDER_TOP);
        bi.bAlpha = 200;
        SetGadgetBufferInfo(m_pGadget->GetHandle(), &bi);
        InvalidateGadget(m_pGadget->GetHandle());

    }
    m_pGadget = pGadget;
    PostMessage(WM_RESET, 0, 0);
}

CImageGadget::CImageGadget()
{
    m_pImage = NULL;
    m_hGadget = NULL;
    m_alpha = 255;
    m_bDragging = 0;
}
    
CImageGadget::~CImageGadget()
{
    delete m_pImage;
    delete m_pAnnotations;    
}

#define GADGETMSG GMFI_PAINT | GMFI_CHANGESTATE | GMFI_INPUTMOUSEMOVE | GMFI_INPUTMOUSE
BOOL 
CImageGadget::Initialize(HGADGET hgadParent, LPCWSTR pszFilename)
{
    BOOL bRet = FALSE;
    m_pImage = new Image(pszFilename);
    if (m_pImage)
    {
        m_hGadget = CreateGadget(hgadParent, GC_SIMPLE, ImgGadgetProc, this);
        if (m_hGadget)
        {
            SetGadgetStyle(m_hGadget, 
                           GS_BUFFERED | GS_OPAQUE| GS_MOUSEFOCUS, 
                           GS_BUFFERED | GS_OPAQUE| GS_MOUSEFOCUS|GS_CLIPINSIDE);
            SetGadgetMessageFilter(m_hGadget, 
                                   NULL, 
                                   GADGETMSG,
                                   GADGETMSG);
            _SetAlpha(FALSE);
            SetGadgetFillF(m_hGadget, new SolidBrush(Color::White));

            SetGadgetRect(m_hGadget,
                          0, 0, 
                          m_pImage->GetWidth(), m_pImage->GetHeight(),
                          SGR_CLIENT | SGR_SIZE);
            SetGadgetRect(m_hGadget, 
                          0, 0, 0, 0,
                          SGR_PARENT | SGR_MOVE);
            SetGadgetCenterPoint(m_hGadget, m_pImage->GetWidth()/(float)2.0, m_pImage->GetHeight()/(float)2.0);
            m_pAnnotations = new CAnnotationSet();
            if (m_pAnnotations)
            {
                m_pAnnotations->SetImageData(m_pImage, this);
            }
            bRet=  TRUE;
        }
        else
        {
            delete m_pImage;
            m_pImage = NULL;
        }
    }
    return bRet;
}

HRESULT 
CImageGadget::ImgGadgetProc(HGADGET hGadget, void *pv, EventMsg *pmsg)
{
    HRESULT hr = DU_S_NOTHANDLED;
    CImageGadget *pThis = reinterpret_cast<CImageGadget*>(pv);
    if (GET_EVENT_DEST(pmsg) == GMF_DIRECT)
    {
        switch (pmsg->nMsg)
        {
            case GM_PAINT:
            {
                GMSG_PAINT * pmsgP = reinterpret_cast<GMSG_PAINT *>(pmsg);
                if ((pmsgP->nCmd == GPAINT_RENDER))
                {
                    if (pmsgP->nSurfaceType == GSURFACE_GPGRAPHICS )
                    {
                        pThis->OnRender((GMSG_PAINTRENDERF *) pmsgP);
                    }
                    else
                    {
                        pThis->OnRender((GMSG_PAINTRENDERI *) pmsgP);
                    }
                    hr = DU_S_COMPLETE;
                }
            }
            break;
            case GM_CHANGESTATE:
            {
                GMSG_CHANGESTATE * pmsgS = reinterpret_cast<GMSG_CHANGESTATE *>(pmsg);
                switch (pmsgS->nCode)
                {
                    case GSTATE_MOUSEFOCUS:
                    {
                        pThis->OnChangeMouseFocus(pmsgS);
                        hr = DU_S_COMPLETE;
                    }
                    break;

                }
            }
            break;
            case GM_INPUT:
            {
                GMSG_INPUT *pmsgI = reinterpret_cast<GMSG_INPUT*>(pmsg);
                switch (pmsgI->nCode)
                {
                    case GMOUSE_DOWN:
                        hr = pThis->OnMouseDown(reinterpret_cast<GMSG_MOUSE*>(pmsg));
                    break;
                    case GMOUSE_DRAG:
                        pThis->OnMouseDrag(reinterpret_cast<GMSG_MOUSEDRAG*>(pmsg));
                        hr = DU_S_COMPLETE;
                    break;
                    case GMOUSE_UP:
                        hr = pThis->OnMouseUp(reinterpret_cast<GMSG_MOUSE*>(pmsg));
                    break;
                }
            }
            break;
            case GM_DESTROY:
            {
                GMSG_DESTROY * pmsgD = reinterpret_cast<GMSG_DESTROY *>(pmsg);
                if (pmsgD->nCode == GDESTROY_FINAL) 
                {
                    delete pThis;
                }
            }
            break;
        }
    }
    return hr;
}
    

void 
CImageGadget::OnRender(GMSG_PAINTRENDERF * pmsg)
{
    if (m_pImage)
    {
        pmsg->pgpgr->DrawImage(m_pImage, *pmsg->prcGadgetPxl);
    }
}

void 
CImageGadget::OnRender(GMSG_PAINTRENDERI * pmsg)
{
    Graphics g(pmsg->hdc);
    if (m_pImage)
    {
        g.SetPageUnit(UnitPixel);
        Rect rc(pmsg->prcGadgetPxl->left, pmsg->prcGadgetPxl->top,
                RECTWIDTH(pmsg->prcGadgetPxl), RECTHEIGHT(pmsg->prcGadgetPxl));
        
        g.DrawImage(m_pImage, rc);
    }
}

void
CImageGadget::OnChangeMouseFocus(GMSG_CHANGESTATE *pmsgS)
{

}

HRESULT
CImageGadget::OnMouseDown(GMSG_MOUSE *pmsg)
{
    HRESULT hr = DU_S_NOTHANDLED;
    if (pmsg->bButton == GBUTTON_LEFT)
    {
        m_bDragging = TRUE;
        pConfigWindow->SetGadget(this);
        hr = DU_S_COMPLETE;
    }
    return hr;
}

void
CImageGadget::OnMouseDrag(GMSG_MOUSEDRAG *pmsgM)
{
    if (m_bDragging)
    {
        float flX;
        float flY;
        GetGadgetScale(m_hGadget, &flX, &flY);
        SetGadgetRect(m_hGadget, 
                      (int)(flX*pmsgM->sizeDelta.cx), 
                      (int)(flY*pmsgM->sizeDelta.cy), 
                      0, 0, SGR_MOVE | SGR_OFFSET);
        
    }
}

HRESULT
CImageGadget::OnMouseUp(GMSG_MOUSE *pmsg)
{
    HRESULT hr = DU_S_NOTHANDLED;
    if (pmsg->bButton == GBUTTON_LEFT)
    {
        m_bDragging = FALSE;
        hr = DU_S_COMPLETE;
    }
    return hr;
}

void CImageGadget::_SetAlpha(BOOL bUpdate)
{
    BUFFER_INFO bi = {0};
    bi.cbSize = sizeof(bi);
    bi.nMask = GBIM_ALPHA;
    bi.bAlpha =  m_alpha;
    SetGadgetBufferInfo(m_hGadget, &bi);
    if (bUpdate)
    {
        InvalidateGadget(m_hGadget);
    }
}

extern "C" int WINAPI _tWinMain( HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    SHFusionInitialize(NULL);
    int nArgs;
    LPWSTR *pszArgs = CommandLineToArgvW(GetCommandLineW(), &nArgs);
    CMainWindow wndMain;
    RECT rc = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
    _Module.Init(NULL, hInstance);
    INITGADGET ig = {0};
    ig.cbSize       = sizeof(ig);
    ig.nThreadMode  = IGTM_SINGLE;
    ig.nMsgMode     = IGMM_ADVANCED;
    HDCONTEXT hctx  = InitGadgets(&ig);

    if (hctx == NULL) {
        return -1;
    }
    InitGadgetComponent(IGC_GDIPLUS);
    wndMain.Create(NULL, rc, TEXT("DUser Pic Viewer"), 
                   WS_OVERLAPPEDWINDOW, WS_EX_ACCEPTFILES);
    if (nArgs > 1)
    {
        wndMain.SendMessage(WM_SETIMAGEFILE, 0, reinterpret_cast<LPARAM>(pszArgs[1]));
    }

    wndMain.ShowWindow(SW_SHOW);
    MSG msg;
    while (GetMessageEx(&msg, NULL, 0, 0))
    {
        if (!pConfigWindow->IsDialogMessage(&msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    DeleteHandle(hctx);
    _Module.Term();
    return (int) msg.wParam;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipic\precomp.h ===
#include <windows.h>


#include <atlbase.h>
extern CComModule _Module;
#include <atlwin.h>
#include <commctrl.h>
#include <shfusion.h>
#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_GDIPLUS
#include <gdiplus.h>
#include <duser.h>

#include <comctrlp.h>
using namespace Gdiplus;

#define RECTWIDTH(rc)   ((rc)->right-(rc)->left)
#define RECTHEIGHT(rc)  ((rc)->bottom-(rc)->top)
#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipic\annot.h ===
#ifndef _ANNOT_H_
#define _ANNOT_H_



// This file defines classes used to render and edit TIFF 6.0 annotations.
// These annotations are stored in tag #32932. The specification for these annotations
// is defined by Eastman Software, the spec version is 1.00.06.
#define ANNOTATION_IMAGE_TAG 32932

// These structures define the in-file layout of the annotations. 
// Note that most of the structs are variable-sized.
// The annotation parser reads the annotations into these structures, wraps them in a descriptor
// and passes the descriptor to the annotation factory object to construct 
// CAnnotationMark-derived classes that implement
// the rendering, editing, and saving of the different types of marks. 

// MT_* used in ANNOTATIONMARK::uType
#define MT_IMAGEEMBED         1
#define MT_IMAGEREF           2
#define MT_STRAIGHTLINE       3
#define MT_FREEHANDLINE       4
#define MT_HOLLOWRECT         5
#define MT_FILLRECT           6
#define MT_TYPEDTEXT          7
#define MT_FILETEXT           8
#define MT_STAMP              9
#define MT_ATTACHANOTE       10
#define MT_FORM              11
#define MT_OCR               12 // unsupported

// ANNOTATIONMARK is fixed size and exists for every mark in the file
// We only support files with 4 byte integers
// this struct is not declared as UNALIGNED because we never typecast a variable
// as this type.
struct ANNOTATIONMARK
{
    UINT uType;                 /* The type of the mark (or operation).
                                    This will be ignored for sets.*/
    RECT lrBounds;             /* Rect in FULLSIZE units.
                                    This could be a rect or 2 points.*/
    RGBQUAD rgbColor1;          /* This is the main color. (Example: This is the
                                    color of all lines, rects, and stand alone
                                    text.*/
    RGBQUAD rgbColor2;          /* This is the secondary color. (Example: This
                                    is the color of the text of an ATTACH_A_NOTE.)*/
    BOOL bHighlighting;         /* TRUE = The mark will be drawn highlighted.
                                    This attribute is currently only valid
                                    for lines, rectangles, and freehand.*/
    BOOL bTransparent;          /* TRUE = The mark will be drawn transparent.
                                    If the mark is drawn transparent, then white
                                    pixels are not drawn (ie. there is nothing
                                    drawn for this mark where it contains white
                                    pixels. This attribute is currently only
                                    available for images. This attribute being
                                    set to TRUE will cause significant
                                    performance reduction.*/
    UINT uLineSize;             /* The size of the line etc. This is passed
                                    onto Windows and is currently in logical
                                    pixels for lines and rectangles.*/
    UINT uStartingPoint;        /* The shape put on the starting of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    UINT uEndPoint;             /* The shape put on the end of a
                                    line (arrow, circle, square, etc).
                                    For this release, this must be set to 0.*/
    LOGFONTA lfFont;             /* The font information for the text. */
    BOOL bMinimizable;          /* TRUE = This mark can be minimized
                                    by the user. This flag is only used for
                                    marks that have a minimizable
                                    characteristic such as ATTACH_A_NOTE.*/
    UINT  Time;                /* The time that the mark was first saved.
                                    in seconds from 00:00:00 1-1-1970 (GMT).*/
    BOOL bVisible;              /* TRUE means that the layer is currently set
                                    to be visible.*/
    DWORD dwPermissions;        /* Reserved. Must be set to 0x0ff83f */
    UINT lReserved[10];         /* Reserved for future expansion.
                                    For this release these must be set to 0.*/
};


// ANNOTATIONHEADER is the first 4 bytes of data in the annotation property.
struct _ANNOTATIONHEADER
{
    BYTE reserved[4];
    UINT IntIs32Bit;
};

typedef UNALIGNED struct _ANNOTATIONHEADER ANNOTATIONHEADER;
//
// for OiAnoDat
//
struct _ANPOINTS
{
    int nMaxPoints;
    int nPoints;
    POINT ptPoint[1];
};

typedef UNALIGNED struct _ANPOINTS ANPOINTS;

struct _ANROTATE
{
    int rotation;
    int scale;
    int nHRes;
    int nVRes;
    int nOrigHRes;
    int nOrigVRes;
    BOOL bReserved1;
    BOOL bReserved2;
    int nReserved[6];
};

typedef UNALIGNED struct _ANROTATE ANROTATE;
// for OiFilNam
struct _ANNAME
{
    char szName[1];
};

typedef UNALIGNED struct _ANNAME ANNAME;
// for OiDIB
struct _ANIMAGE
{
    BYTE dibInfo[1]; // standard memory DIB
};

typedef UNALIGNED struct _ANIMAGE ANIMAGE;
// for OiAnText
struct _ANTEXTPRIVDATA
{
    int nCurrentOrientation;
    UINT uReserved1; // always 1000 when writing, ignore when reading
    UINT uCreationScale; // always 72000 divided by the vertical resolution of the base image when writing.
                         // Used to modify the Attributes.lfFont.lfHeight variable for display
    UINT uAnoTextLength; // 64k byte limit, except 255 byte limit for text stamp
    char szAnoText[1];
};

typedef UNALIGNED struct _ANTEXTPRIVDATA ANTEXTPRIVDATA;

// These structures provide descriptors for the data read from the annotation property blob.
// The extra data includes the size of each annotation structure
// _NAMEDBLOCK is our in-memory representation
struct _NAMEDBLOCK
{
    UINT cbSize;    
    char szType[9];    
    BYTE data[1];
};

typedef UNALIGNED struct _NAMEDBLOCK NAMEDBLOCK;

// _FILENAMEDBLOCK is what the namedblock looks like in the file
struct _FILENAMEDBLOCK
{
    char szType[8];
    UINT cbSize;
    BYTE data[1];
};
 
typedef UNALIGNED struct _FILENAMEDBLOCK FILENAMEDBLOCK;

struct ANNOTATIONDESCRIPTOR
{
    UINT cbSize;
    ANNOTATIONMARK mark;    
    BYTE blocks[1];
};

// Define a base class for the various annotation types
class CAnnotation
{
public:
    static CAnnotation* CreateAnnotation(UINT type, ULONG uCreationScale, HGADGET hParent);
    static CAnnotation* CreateAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, HGADGET hParent);
    virtual ~CAnnotation();

    // render to the given rectangle in window client coordinates.
    virtual void Render(Graphics &g) { return; }
    // return the in-file representation of this annotation, as well as its total size
    HRESULT GetBlob(SIZE_T &cbSize, LPBYTE pBuffer, LPCSTR szDefaultGroup, LPCSTR szNextIndex);
    // return our image coordinates
    virtual void GetRect(RECT &rect) {rect = _mark.lrBounds;}
    // return the type of Annotation Mark used to change the selection handles for straight lines
    virtual UINT GetType() { return _mark.uType; }
    // moves the annotation on the page by the specified offset
    virtual void Move(SIZE sizeOffset) { OffsetRect(&_mark.lrBounds, sizeOffset.cx, sizeOffset.cy); }
    // return true if the object can be resized (true for every thing but freehand lines and images)
    virtual BOOL CanResize() { return true; }
    // resizes the annotation on the page to the new rect specified
    virtual void Resize(RECT rectNewSize);

    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);

    virtual BOOL HasWidth() { return true; }
    virtual UINT GetWidth() const { return _mark.uLineSize; }
    virtual void SetWidth(UINT nWidth) { _mark.uLineSize = nWidth; }

    virtual BOOL HasTransparent() { return true; }
    virtual BOOL GetTransparent() const { return _mark.bHighlighting; }
    virtual void SetTransparent(BOOL bTransparent) { _mark.bHighlighting = bTransparent; }

    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetColor() const { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }
  
    virtual BOOL HasFont() { return true; }
    virtual void GetFont(LOGFONTA& lfFont) { CopyMemory (&lfFont, &_mark.lfFont, sizeof(lfFont)); }                        
    virtual void GetFont(LOGFONTW& lfFont);
    virtual void SetFont(LOGFONTA& lfFont) { CopyMemory (&_mark.lfFont, &lfFont, sizeof(lfFont)); }
    virtual void SetFont(LOGFONTW& lfFont);
    virtual LONG GetFontHeight(Graphics &g) { return _mark.lfFont.lfHeight; }
    
    virtual COLORREF GetFontColor() const { return RGB(_mark.rgbColor1.rgbRed, _mark.rgbColor1.rgbGreen, _mark.rgbColor1.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor1.rgbRed = GetRValue(crColor); _mark.rgbColor1.rgbGreen = GetGValue(crColor); _mark.rgbColor1.rgbBlue = GetBValue(crColor); }

protected:
    CAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor);
    BOOL Initialize(HGADGET hGadget);
    NAMEDBLOCK *_FindNamedBlock (LPCSTR szName, ANNOTATIONDESCRIPTOR *pDesc);
    virtual HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer) {return E_NOTIMPL;};
    // define helper functions for writing the different named block types
    SIZE_T _WriteStringBlock(LPBYTE pBuffer, UINT uType, LPCSTR szName, LPCSTR szData, SIZE_T len);
    SIZE_T _WritePointsBlock(LPBYTE pBuffer, UINT uType, const POINT *ppts, int nPoints, int nMaxPoints);
    SIZE_T _WriteRotateBlock(LPBYTE pBuffer, UINT uType, const ANROTATE *pRotate);
    SIZE_T _WriteTextBlock(LPBYTE pBuffer, UINT uType, int nOrient, UINT uScale, LPCSTR szText, int nMaxLen);
    SIZE_T _WriteImageBlock(LPBYTE pBuffer, UINT uType, LPBYTE pDib, SIZE_T cbDib);
    // gadget functions and message handlers
    static HRESULT AnnotGadgetProc(HGADGET hGadget, void *pv, EventMsg *pMsg);
    void OnMouseDrag(GMSG_MOUSEDRAG *pmsg);
    HRESULT OnMouseDown(GMSG_MOUSE *pmsg);
    HRESULT OnMouseUp(GMSG_MOUSE *pmsg);

    ANNOTATIONMARK _mark;
    LPSTR          _szGroup;
    FILENAMEDBLOCK *   _pUGroup;
    HGADGET        _hGadget;
    BOOL           m_bDragging;
    int            _nCurrentOrientation;    
};

class CRectMark : public CAnnotation
{
public:
    CRectMark (ANNOTATIONDESCRIPTOR *pDescriptor);
    void Render (Graphics &g);

    virtual BOOL HasWidth() { return (_mark.uType == MT_HOLLOWRECT); }
    virtual BOOL HasFont() { return false; }
};

class CImageMark : public CAnnotation
{
public:
    CImageMark (ANNOTATIONDESCRIPTOR *pDescriptor, bool bEmbedded);
    ~CImageMark();
    void Render (Graphics &g);
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);
    virtual BOOL CanResize() { return false; };
    virtual void Resize(RECT rectNewSize) { return; };

private:
    Bitmap* _pBitmap; // cached image for quicker render
    LPBYTE _pDib;        // the DIB data from the annotation. If NULL, this is a reference mark 
    ANROTATE _rotation;  // rotation info
    LPSTR    _szFilename;  // image file name from the annotation    
    bool     _bRotate; //REVIEW_SDK: Shouldn't there just be a known blank rotation value? If I rotate something 0 degrees shouldn't just not write the rotation record?
    SIZE_T   _cbDib;
};

class CLineMark : public CAnnotation
{
public:
    CLineMark(ANNOTATIONDESCRIPTOR *pDescriptor, bool bFreehand);
    ~CLineMark();
    void Render(Graphics &g);
    void GetRect(RECT &rect);
    void SetPoints(POINT* pPoints, int cPoints);
    void GetPointsRect(RECT &rect);
    virtual void Move(SIZE sizeOffset);
    virtual BOOL CanResize() { return (_nPoints == 2); };
    virtual void Resize(RECT rectNewSize);
    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);
    
    virtual BOOL HasFont() { return false; }

    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

private:
    int    _iMaxPts;
    int    _nPoints;
    POINT *_points; // 2 points for a straight line, more for a freehand line
};

// all text annotations render and initialize the same way so use a common base class
class CTextAnnotation : public CAnnotation 
{
public:
    CTextAnnotation(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale, UINT nMaxText=65536, bool _bUseColor2=false);
    void Render(Graphics &g);
    virtual ~CTextAnnotation();
    HRESULT _WriteBlocks(SIZE_T &cbSize, LPBYTE pBuffer);

    virtual BOOL HasWidth() { return false; }
    virtual BOOL HasTransparent() { return false; }
    virtual BOOL HasColor() { return false; }
    virtual LONG GetFontHeight(Graphics &g);
    virtual int GetOrientation() { return _nCurrentOrientation; }

    BSTR GetText();
    void SetText(BSTR bstrText);
    
    virtual void Rotate(int nNewImageWidth, int nNewImageHeight, BOOL bClockwise = TRUE);
    
private:
    
    UINT _uCreationScale;                          
    UINT _uAnoTextLength; 
    UINT _nMaxText;
    LPSTR _szText;
    bool _bUseColor2;
};

class CTypedTextMark : public CTextAnnotation
{
public:
    CTypedTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CFileTextMark : public CTextAnnotation
{
public:
    CFileTextMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CTextStampMark : public CTextAnnotation
{
public:
    CTextStampMark(ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
};

class CAttachNoteMark : public CTextAnnotation
{
public:
    CAttachNoteMark (ANNOTATIONDESCRIPTOR *pDescriptor, ULONG uCreationScale);
    virtual BOOL HasColor() { return true; }
    virtual COLORREF GetFontColor() const { return RGB(_mark.rgbColor2.rgbRed, _mark.rgbColor2.rgbGreen, _mark.rgbColor2.rgbBlue); }
    virtual void SetFontColor(COLORREF crColor) { _mark.rgbColor2.rgbRed = GetRValue(crColor); _mark.rgbColor2.rgbGreen = GetGValue(crColor); _mark.rgbColor2.rgbBlue = GetBValue(crColor); }
};

class CAnnotationSet 
{
public:
    CAnnotationSet ();
    ~CAnnotationSet ();

    // Draw all the marks
    void RenderAllMarks (Graphics &g);
        // construct annotation set from raw data
    HRESULT BuildAllMarksFromData( LPVOID pData, UINT cbSize, ULONG xDPI, ULONG yDPI );
    // Return the annotation at this point in image coordinates
    CAnnotation* GetAnnotation (INT_PTR nIndex);
    // Add a new annotation to the list. Should only be called from a CAnnotation
    BOOL AddAnnotation(CAnnotation *pMark);
    // Remove an annotation from the list. Should only be called from a CAnnotation
    BOOL RemoveAnnotation (CAnnotation *pMark);
    // Save the current set of annotations to the image
    HRESULT CommitAnnotations (Image *pimg);
    // Forget our old annotations and load new ones
    void SetImageData (Image *pimg, CImageGadget *pParent);
    INT_PTR GetCount () 
    { 
        if (_dpaMarks) 
            return DPA_GetPtrCount(_dpaMarks);
        return 0;
    };

    UINT GetCreationScale();
    void ShowAnnotations(BOOL bShow) {if (_hGadget) SetGadgetStyle(_hGadget, bShow ? GS_VISIBLE : 0, GS_VISIBLE);}
    void ClearAllMarks();

private:
    HDPA    _dpaMarks;
    LPBYTE  _pDefaultData;
    SIZE_T  _cbDefaultData;
    ULONG   _xDPI;
    ULONG   _yDPI;
    HGADGET _hGadget;
    static int CALLBACK _FreeMarks(LPVOID pMark, LPVOID pUnused);
    static HRESULT AnnotParentProc(HGADGET hGadget, LPVOID pv, EventMsg *pmsg);
    void   _ClearMarkList ();
    void   _BuildMarkList (Image *pimg);
    void   _BuildListFromData (LPVOID pData, UINT cbSize);
    INT    _NamedBlockDataSize (UINT uType, LPBYTE pData, LPBYTE pEOD);
    LPBYTE _MakeAnnotationBlob ();
    HRESULT _SaveAnnotationProperty(Image *pimg, LPBYTE pData, SIZE_T cbBuffer);
    ANNOTATIONDESCRIPTOR *_ReadMark (LPBYTE pMark, LPBYTE *ppNext, LPBYTE pEOD);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by duipic.rc
//
#define IDD_CONTROL                     107
#define IDC_XSCALE_LABEL                1000
#define IDC_XSCALE                      1001
#define IDC_XSCALE_MAX                  1002
#define IDC_XSCALE_VAL                  1003
#define IDC_YSCALE_LABEL                1004
#define IDC_YSCALE                      1005
#define IDC_YSCALE_MAX                  1006
#define IDC_YSCALE_VAL                  1007
#define IDC_ROTATION                    1008
#define IDC_ROTATION_VAL                1010
#define IDC_ROTATION_LABEL              1011
#define IDC_CHOOSEFILE                  1012
#define IDC_RESET                       1013
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipic\duipic.h ===
#ifndef _DUIPIC_H_
#define _DUIPIC_H_

class CAnnotationSet;
class CImageGadget
{
public:
    CImageGadget();
    ~CImageGadget();
    BOOL Initialize(HGADGET hgadParent, LPCWSTR pszFilename);
    inline HGADGET GetHandle() const {return m_hGadget;}
    
private:
    static HRESULT ImgGadgetProc(HGADGET hGadget, void *pv, EventMsg *pMsg);
    void OnRender(GMSG_PAINTRENDERF * pmsg);
    void OnRender(GMSG_PAINTRENDERI * pmsg);
    void OnMouseDrag(GMSG_MOUSEDRAG *pmsg);
    void OnChangeMouseFocus(GMSG_CHANGESTATE *pmsg);
    HRESULT OnMouseDown(GMSG_MOUSE *pmsg);
    HRESULT OnMouseUp(GMSG_MOUSE *pmsg);
    void _SetAlpha(BOOL bUpdate = TRUE);
    Image *m_pImage;
    HGADGET m_hGadget;
    BYTE m_alpha;
    BOOL m_bDragging;
    CAnnotationSet *m_pAnnotations;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipreview\duipreview.cpp ===
#include <precomp.h>
#include "resource.h"
#include "hwndcontainer.h"

//
// CPreviewApp is the outermost element in the element hierarchy
// 

class CPreviewApp : public Element
{
public:
    static HRESULT Create(OUT Element **ppElement);
    virtual void OnEvent(Event *pEvent);

    void SetInitialFile(LPWSTR szFile);
    void AcceptFile(IDataObject *pdo);

    CPreviewApp();
    virtual ~CPreviewApp();

public:
    static IClassInfo *Class;
    virtual IClassInfo *GetClassInfo() {return Class;}
    static HRESULT Register();

private:
    void _SetBackground();
    CSimpleDynamicArray<LPITEMIDLIST> m_aidl;
    Value *m_pvalCurrentGraphic;
    Value *m_pvalPrevGraphic;
    Value *m_pvalNextGraphic;
};

CPreviewApp::CPreviewApp()
    : m_pvalCurrentGraphic(NULL),
      m_pvalPrevGraphic(NULL),
      m_pvalNextGraphic(NULL)
{

}

CPreviewApp::~CPreviewApp()
{
    if (m_pvalCurrentGraphic)
    {
        m_pvalCurrentGraphic->Release();
    }
    if (m_pvalPrevGraphic)
    {
        m_pvalPrevGraphic->Release();
    }
    if (m_pvalNextGraphic)
    {
        m_pvalNextGraphic->Release();
    }
}

CPreviewApp* pApp;

HRESULT CPreviewApp::Create(OUT Element** ppElement)
{
    *ppElement = NULL;
    
    CPreviewApp* ph;
    if (pApp)
    {
        ph = pApp;
    }
    else
    {
        ph = HNew<CPreviewApp>();
        pApp = ph;
    }
    if (!ph)
        return E_OUTOFMEMORY;

    HRESULT hr = ph->Initialize(0);
    if (FAILED(hr))
    {
        ph->Destroy();
        pApp = NULL;
        return hr;
    }

    *ppElement = ph;

    return S_OK;
}

void CPreviewApp::OnEvent(Event *pEvent)
{
}
void CPreviewApp::SetInitialFile(LPWSTR szFile)
{
    m_pvalCurrentGraphic = Value::CreateGraphic(szFile);
    _SetBackground();
}

void CPreviewApp::AcceptFile(IDataObject *pdo)
{

}

void CPreviewApp::_SetBackground()
{
    if (m_pvalCurrentGraphic)
    {
        FindDescendent(FindAtomW(L"preview"))->SetValue(ContentProp,PI_Local, m_pvalCurrentGraphic);
    }
    else
    {
        FindDescendent(FindAtomW(L"preview"))->SetBackgroundColor(ARGB(0,0,0,0), ARGB(0,64,64,255));
    }
}
////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties
// Define class info with type and base type, set static class pointer

IClassInfo* CPreviewApp::Class = NULL;
HRESULT CPreviewApp::Register()
{
    return ClassInfo<CPreviewApp, Element>::Register(L"PreviewApp", NULL, 0);
}

////////////////////////////////////////////////////////
// Hello entry point

void CALLBACK ParserError(LPCWSTR pszError, LPCWSTR pszToken, int dLine)
{
    WCHAR szParseError[201];
    if (dLine != -1)
        wsprintf(szParseError, L"%s '%s' at line %d", pszError, pszToken, dLine);
    else
        wsprintf(szParseError, L"%s '%s'", pszError, pszToken);

    MessageBoxW(NULL, szParseError, L"Error!", MB_OK);
}

class CGraphicsInit
{
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        GdiplusStartupInput gsi;
        GdiplusStartupOutput gso;
        GdiplusStartup(&_token, &gsi, &gso);
    };
    ~CGraphicsInit()
    {
        GdiplusShutdown(_token);
    };

};


extern "C" int WINAPI wWinMain( HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    HRESULT hr;
    CGraphicsInit cgi;
    Parser* pParser = NULL;
    HWNDContainer* phc = NULL;
    pApp = NULL;
    // DirectUI init thread in caller
    InitProcess();
    HWNDContainer::Register();
    CPreviewApp::Register();
    if (SUCCEEDED(InitThread()))
    {
        Element::StartDefer();

        Parser::Create(IDR_MainWnd, hInstance, ParserError, &pParser);
        
        if (pParser && !pParser->WasParseError())
        {
            // Create host (top-level HWND with a contained HWNDElement)
            hr = HWNDContainer::Create(L"Windows Picture Viewer", 0, 
                                       WS_OVERLAPPEDWINDOW, 
                                       CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
                                       NULL, NULL, hInstance, NULL, &phc);
            if (SUCCEEDED(hr))
            {                
                Element *pe;
                hr = pParser->CreateElement(L"main", NULL, &pe);
                if (SUCCEEDED(hr))
                {
                    hr = phc->Add(pe);
                    if (SUCCEEDED(hr))
                    {
                        LPWSTR *argvw;
                        int argc;
                        argvw = CommandLineToArgvW(GetCommandLineW(), &argc);
                        if (argc > 1)
                        {
                            pApp->SetInitialFile(argvw[1]);
                        }                        
                        phc->Show(SW_SHOW);
                    }                   
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
        
        Element::EndDefer();
        if (SUCCEEDED(hr))
        {
            StartMessagePump();
        }
    }

    // phc (and entire tree) destroyed when top-level HWND destroyed

    if (pParser)
    {
        pParser->Destroy();
    }

    UnInitThread();
    UnInitProcess();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipreview\makefile.inc ===
mainwnd.uipp: mainwnd.ui
    cl /nologo /EP mainwnd.ui > mainwnd.uipp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipreview\hwndcontainer.h ===
// ----------------------------------------------------------------
//
//  Generic HWNDContainer
//
//   in terms of translating to message tables, just ignore this;
//   assume it's just a class coming out of DUI like Button
//
// ----------------------------------------------------------------

class HWNDContainer : public HWNDElement
{
public:
    static HRESULT Create(OUT Element** ppElement);
    static HRESULT Create(LPWSTR lpszTitle, DWORD dwExStyle, DWORD dwStyle, int x, int y, int cx, int cy, HMENU hMenu, HWND hwndParent, HINSTANCE hInstance, VOID* lpCreateParams, OUT HWNDContainer** pphc);

    void Show(int nCmdShow);

    static HRESULT Create(NativeHWNDHost* pnhh, OUT Element** pphc);

    HWNDContainer() { }
    virtual ~HWNDContainer() { if (_pnhh) _pnhh->Destroy(); }
    HRESULT Initialize(NativeHWNDHost* pnhh) { return HWNDElement::Initialize(pnhh->GetHWND(), true, 0); }

private:
    NativeHWNDHost* _pnhh;

public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
};

////////////////////////////////////////////////////////
// Frame construction

HRESULT HWNDContainer::Create(LPWSTR lpszTitle, DWORD dwExStyle, DWORD dwStyle, int x, int y, int cx, int cy, HMENU hMenu, HWND hwndParent, HINSTANCE hInstance, VOID* lpCreateParams, OUT HWNDContainer** pphc)
{
    UNREFERENCED_PARAMETER(x);
    UNREFERENCED_PARAMETER(y);
    UNREFERENCED_PARAMETER(dwExStyle);
    UNREFERENCED_PARAMETER(hMenu);
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpCreateParams);

    // Create native host
    NativeHWNDHost* pnhh;
    
    HRESULT hr = NativeHWNDHost::Create(lpszTitle, hwndParent, NULL, x, y, cx, cy, dwExStyle, dwStyle, 0, &pnhh);

    if (FAILED(hr))
        return hr;

    // HWND Root
    hr = HWNDContainer::Create(pnhh, (Element**)pphc);

    if (FAILED(hr))
    {
        pnhh->Destroy();
        return hr;
    }

    // Set visible and host
    (*pphc)->SetVisible(true);
    pnhh->Host(*pphc);
    
    return S_OK;
}

HRESULT HWNDContainer::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT HWNDContainer::Create(NativeHWNDHost* pnhh, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDContainer* phc = HNew<HWNDContainer>();
    if (!phc)
        return E_OUTOFMEMORY;

    HRESULT hr = phc->Initialize(pnhh);
    if (FAILED(hr))
        return hr;

    phc->_pnhh = pnhh;

    FillLayout* pfl;
    hr = FillLayout::Create((Layout **) &pfl);
    if (FAILED(hr))
    {
        phc->Destroy();
        return hr;
    }
    phc->SetLayout(pfl);

    *ppElement = phc;
    
    return S_OK;
}

void HWNDContainer::Show(int nCmdShow)
{
    UNREFERENCED_PARAMETER(nCmdShow);

    if (_pnhh)
        _pnhh->ShowWindow();
}


////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDContainer::Class = NULL;
HRESULT HWNDContainer::Register()
{
    return ClassInfo<HWNDContainer,HWNDElement>::Register(L"HWNDContainer", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipreview\resource.h ===
#define IDR_MainWnd   1000
#define IDB_SEPARATOR 2000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\dll.cpp ===
// camocx.cpp : Implementation of DLL Exports.

#include "precomp.h"
#pragma hdrstop
#include "imgurl.h"
#include "imageurl.h"

#include "imgurl_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ImgProtocol, CImgProtocol)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_WIAImageFileLib);
        DisableThreadLibraryCalls(hInstance);        
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {        
        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;
    hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\duipreview\precomp.h ===
#include <windows.h>
#include <shlobj.h>
#include <shellapi.h>
#include <uxtheme.h>
#include <commctrl.h>

 #include <gdiplus.h>
 #define GADGET_ENABLE_TRANSITIONS
 #define GADGET_ENABLE_GDIPLUS
 #define GADGET_ENABLE_CONTROLS
#include <duser.h>
#include <directui.h>

#include "uicommon.h"
using namespace Gdiplus;
using namespace DirectUI;
#define RECTWIDTH(rc)   ((rc)->right-(rc)->left)
#define RECTHEIGHT(rc)  ((rc)->bottom-(rc)->top)
#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\imageurl.cpp ===
#include <precomp.h>
#include "imgurl.h"
#include "imageurl.h"
#include "resource.h"
#include "multimime.h"
const WCHAR*    k_wszProtocolName   = L"image";
const WCHAR*    k_wszColonSlash     = L"://";
const WCHAR*    k_wszSeparator      = L"?";
const WCHAR*    k_wszThumb          = L"thumb";
const int       k_cchProtocolName   = 5;


const WCHAR     k_wchSeparator      = L'?';
const WCHAR     k_wchColon          = L':';
const WCHAR     k_wchFrontSlash     = L'/';
const WCHAR     k_wchPeriod         = L'.';
const WCHAR     k_wchEOS            = L'\0';

enum 
{
    k_dwTransferPending             = 0,
    k_dwTransferComplete            = 1,
};

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

UINT FindInDecoderList(ImageCodecInfo *pici, UINT cDecoders, LPCTSTR pszFile)
{
    LPCTSTR pszExt = PathFindExtension(pszFile);    // speed up PathMatchSpec calls
        
    // look at the list of decoders to see if this format is there
    for (UINT i = 0; i < cDecoders; i++)
    {
        if (PathMatchSpec(pszExt, pici[i].FilenameExtension))
            return i;
    }
    return (UINT)-1;    // not found!
}

class CEncoderInfo
{
public:
    Status GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt);
    Status GetEncoderList();
    Status GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder);
    CEncoderInfo();
    ~CEncoderInfo();

private:
    UINT _cEncoders;                    // number of encoders discovered
    ImageCodecInfo *_pici;              // array of image encoder classes
};


CEncoderInfo::CEncoderInfo()
{
    _cEncoders = 0;
    _pici = NULL;
}

CEncoderInfo::~CEncoderInfo()
{
    LocalFree (_pici);
}
Status CEncoderInfo::GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt)
{
    *pguidFmt = GUID_NULL;

    Status s = GetEncoderList();
    if (Ok == s)
    {
        UINT i = FindInDecoderList(_pici, _cEncoders, pszPath);
        if (-1 != i)
        {
            *pguidFmt = _pici[i].FormatID;            
        }
        else
        {
            s = GenericError;
        }
    }
    return s;
}

Status CEncoderInfo::GetEncoderList()
{
    Status s = Ok;
    if (!_pici)
    {
        // lets pick up the list of encoders, first we get the encoder size which
        // gives us the CB and the number of encoders that are installed on the
        // machine.

        UINT cb;
        s = GetImageEncodersSize(&_cEncoders, &cb);
        if (Ok == s)
        {
            // allocate the buffer for the encoders and then fill it
            // with the encoder list.

            _pici = (ImageCodecInfo*)LocalAlloc(LPTR, cb);
            if (_pici)
            {
                s = GetImageEncoders(_cEncoders, cb, _pici);
                if (Ok != s)
                {
                    LocalFree(_pici);
                    _pici = NULL;
                }
            }
            else
            {
                s = OutOfMemory;
            }
        }
    }
    return s;
}


Status CEncoderInfo::GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder)
{
    Status s = GetEncoderList();
    if (Ok == s)
    {
        s = GenericError;
        for (UINT i = 0; i != _cEncoders; i++)
        {
            if (_pici[i].FormatID == *pfmt)
            {
                if (pclsidEncoder)
                {
                    *pclsidEncoder = _pici[i].Clsid; // return the CLSID of the encoder so we can create again
                }
                s = Ok;
                break;
            }
        }
    }
    return s;
}

CImgProtocol::CImgProtocol()
    : m_ulOffset(0)
{
    m_pd.dwState = k_dwTransferPending;
}

STDMETHODIMP_(void)
CImgProtocol::FinalRelease()
{
    if (m_pd.pData)
    {
        LocalFree(m_pd.pData);
    }
}

STDMETHODIMP
CImgProtocol::Start(LPCWSTR szUrl, 
                    IInternetProtocolSink* pOIProtSink,
                    IInternetBindInfo* pOIBindInfo, 
                    DWORD grfPI, 
                    HANDLE_PTR dwReserved)
{
    //
    // Create an Image object from the given file path. 
    // If successful, spin a thread to read the requested property.
    HRESULT hr = _GetImagePathFromURL(szUrl);   
    if (SUCCEEDED(hr))
    {
        m_pSink = pOIProtSink;
        AddRef();
        DWORD dw;
        HANDLE hThread = CreateThread(NULL, 0,
                                      _ImageTagThreadProc,
                                      this, 0, &dw);
        if (!hThread)
        {
            Release();
            hr = INET_E_DOWNLOAD_FAILURE;
        }
        else
        {
            CloseHandle(hThread);
        }
    }   
    return hr;
}

STDMETHODIMP
CImgProtocol::Continue(PROTOCOLDATA *pData)
{
    if ( k_dwTransferComplete == m_pd.dwState )
        return E_UNEXPECTED;

    CopyMemory(&m_pd, pData, sizeof(m_pd));
    return S_OK;
}

STDMETHODIMP
CImgProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImgProtocol::Terminate(DWORD dwOptions)
{
    return S_OK;
}

STDMETHODIMP
CImgProtocol::Suspend()
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImgProtocol::Resume()
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImgProtocol::Read( void* pv, ULONG cb, ULONG* pcbRead)
{
    // validate our arguments
    if ( !pv || !pcbRead )
        return E_POINTER;

    *pcbRead = 0;
    
    // is the transfer currently pending? if so then
    // we don't actually want to do anything here.
    if ( k_dwTransferPending == m_pd.dwState )
        return E_PENDING;

    // do we actually have data to copy? if the offset is greater
    // or equal to the size of our data then we don't have any data to
    // copy so return S_FALSE
    if ( m_ulOffset >= m_pd.cbData )
        return S_FALSE;

    // figure out how much we are going to copy
    DWORD dwCopy = m_pd.cbData - m_ulOffset;
    if ( dwCopy >= cb )
        dwCopy = cb;

    // if we have negative memory to copy, or 0, then we are done and we don't
    // actually want to do anything besides return S_FALSE
    if ( dwCopy <= 0 )
        return S_FALSE;

    // do the memcpy and setup our state and the return value
    memcpy( pv, reinterpret_cast<BYTE*>(m_pd.pData) + m_ulOffset, dwCopy );
    m_ulOffset += dwCopy;
    *pcbRead = dwCopy;

    return ( dwCopy == cb ? S_OK : S_FALSE );
}

STDMETHODIMP
CImgProtocol::Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
{
    return E_FAIL;
}

STDMETHODIMP
CImgProtocol::LockRequest( DWORD dwOptions )
{
    //Don't support locking
    return S_OK;
}

STDMETHODIMP
CImgProtocol::UnlockRequest()
{
    //Don't support locking
    return S_OK;
}

HRESULT
CImgProtocol::_GetImagePathFromURL(LPCWSTR szURL)
{
    WCHAR awch[INTERNET_MAX_URL_LENGTH] = {0};
    HRESULT hr = INET_E_INVALID_URL;
    WCHAR *pwchUrl = const_cast<WCHAR*>(szURL);
    WCHAR *pwch = NULL;

    // our url looks like "image://foo.jpg?1234"
    if (!StrCmpNIW(k_wszProtocolName, pwchUrl, k_cchProtocolName))
    {
        pwchUrl += k_cchProtocolName;
        while (*pwchUrl == k_wchColon || *pwchUrl == k_wchFrontSlash)
        {
            pwchUrl++;
        }
        if (*pwchUrl)
        {
            pwch = StrChrIW(pwchUrl, k_wchSeparator);
            if (pwch)
            {
                StrCpyNW(awch, pwchUrl, (int)(pwch-pwchUrl+1));
                m_strPath = awch;
                // skip the "?"
                pwchUrl = pwch+1;
                if (*pwchUrl)
                {
                    m_strProperty = pwchUrl;
                    if (m_strProperty.Length())
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }
    return hr;
}

static const CHAR cszNoData[] = "No Data";
DWORD 
CImgProtocol::_ImageTagThreadProc(void *pv)
{
    CImgProtocol *pThis = reinterpret_cast<CImgProtocol*>(pv);
    
    HRESULT hr = E_FAIL;
    HRESULT hrCo = CoInitialize(NULL); 
    if (SUCCEEDED(hrCo))
    {
        // first make sure we can get an Image
        CComPtr<IStream> pStrm;
        // For now just load the whole file right away
        if (SUCCEEDED(URLOpenBlockingStream(NULL, 
                                            pThis->m_strPath.String(),
                                            &pStrm,
                                            0, NULL)))
        {
            Image img(pStrm);
            if (Ok == img.GetLastStatus())
            {
                PROTOCOLDATA *ppd = new PROTOCOLDATA;
                if (ppd)
                {
                    LPCWSTR pszMime = L"text/plain";
                    // if anything fails just return an empty string
                    ppd->dwState = k_dwTransferComplete;
                    ppd->grfFlags = 0;
                    ppd->cbData = 0;
                    ppd->pData = NULL;
                    if (FAILED(pThis->_GetImageProperty(&img, &ppd->pData, &ppd->cbData, &pszMime)))
                    {
                        if (ppd->pData)
                        {
                            LocalFree(ppd->pData);
                        }
                        ppd->pData = LocalAlloc(GPTR, sizeof(cszNoData));
                        if (ppd->pData)
                        {
                            hr = S_OK;
                            ppd->cbData = sizeof(cszNoData);
                            lstrcpyA(reinterpret_cast<LPSTR>(ppd->pData), cszNoData);
                        }                       
                    }
                    pThis->m_pSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pszMime); 
                    pThis->m_pSink->Switch(ppd);
                    pThis->m_pSink->ReportData(BSCF_LASTDATANOTIFICATION, ppd->cbData, ppd->cbData);     
                    delete ppd;
                }
            }
        }        
    }
    pThis->m_pSink->ReportResult(hr, hr, NULL);
    pThis->Release();
    if (SUCCEEDED(hrCo))
    {
        CoUninitialize();
    }
    return 0;
}

HRESULT PropImgToPropvar(PropertyItem *pi, PROPVARIANT *pvar, BOOL bUnicode)
{
    HRESULT hr = S_OK;
    if (!pi->length)
    {
        return E_FAIL;
    }
    switch (pi->type)
    {
    case PropertyTagTypeByte:
        pvar->vt = VT_UI1;
        // check for multi-valued property and convert to safearray or unicode string if found
        if (pi->length > sizeof(UCHAR))
        {
            if (!bUnicode)
            {
                SAFEARRAYBOUND bound;
                bound.cElements = pi->length/sizeof(UCHAR);
                bound.lLbound = 0;
                pvar->vt |= VT_ARRAY; 
                hr = E_OUTOFMEMORY;
                pvar->parray = SafeArrayCreate(VT_UI1, 1, &bound);                              
                if (pvar->parray)
                {
                    void *pv;
                    hr = SafeArrayAccessData(pvar->parray, &pv);
                    if (SUCCEEDED(hr))
                    {
                        CopyMemory(pv, pi->value, pi->length);
                        SafeArrayUnaccessData(pvar->parray);                        
                    }
                    else
                    {
                        SafeArrayDestroy(pvar->parray);
                    }
                }
            }
            else
            {
                pvar->vt = VT_LPWSTR;
                hr = SHStrDupW((LPCWSTR)pi->value, &pvar->pwszVal);
            }
        }
        else
        {
            pvar->bVal = *((UCHAR*)pi->value);
        }
        
        break;
        
    case PropertyTagTypeShort:
        pvar->vt = VT_UI2;
        pvar->uiVal = *((USHORT*)pi->value);
        break;
        
    case PropertyTagTypeSLONG:
    case PropertyTagTypeLong:
        pvar->vt = VT_UI4;
        if (pi->length > sizeof(ULONG))
        {
            SAFEARRAYBOUND bound;
            bound.cElements = pi->length/sizeof(ULONG);
            bound.lLbound = 0;
            pvar->vt |= VT_ARRAY; 
            hr = E_OUTOFMEMORY;
            pvar->parray = SafeArrayCreate(VT_UI4, 1, &bound);                              
            if (pvar->parray)
            {
                void *pv;
                hr = SafeArrayAccessData (pvar->parray, &pv);
                if (SUCCEEDED(hr))
                {
                    CopyMemory (pv, pi->value, pi->length);
                    SafeArrayUnaccessData(pvar->parray);                        
                }
                else
                {
                    SafeArrayDestroy(pvar->parray);
                }
            }
        }
        else
        {
            pvar->ulVal = *((ULONG*)pi->value);
        }
        break;
        
    case PropertyTagTypeASCII:
        // special case for date taken
        if (pi->id == PropertyTagExifDTOrig)
        {
            SYSTEMTIME st = {0};
            sscanf((LPSTR)pi->value, "%hd:%hd:%hd %hd:%hd:%hd",
                   &st.wYear, &st.wMonth,
                   &st.wDay, &st.wHour,
                   &st.wMinute, &st.wSecond);
            if (st.wYear) 
            {
                FILETIME ftUTC;
                FILETIME ftLocal;            
                // we expect cameras to return local times. Need to convert to UTC.
                SystemTimeToFileTime(&st, &ftLocal);
                LocalFileTimeToFileTime(&ftLocal, &ftUTC);
                FileTimeToSystemTime(&ftUTC, &st);
                SystemTimeToVariantTime(&st, &pvar->date);
                pvar->vt = VT_DATE;
            }
            else
            {
                pvar->vt = VT_EMPTY;
            }
        }
        else 
        {
            hr = SHStrDupA(pi->value ? (LPSTR)pi->value : "", &pvar->pwszVal);
            if (SUCCEEDED(hr))
            {
                pvar->vt = VT_LPWSTR;
            }
        }
        break;
        
    case PropertyTagTypeSRational:
    case PropertyTagTypeRational:
        {
            LONG *pl = (LONG*)pi->value;
            LONG num = pl[0];
            LONG den = pl[1];
            
            pvar->vt = VT_R8;            
            if (0 == den)
                pvar->dblVal = 0;           // don't divide by zero
            else
                pvar->dblVal = ((double)num)/((double)den);
            
            break;
        }
        
    case PropertyTagTypeUndefined:
    default:
        hr = E_UNEXPECTED;
        break;
    }
    
    return hr;
}

PropertyItem *GetPropertyItem(Image *pimg, PROPID pid)
{
    PropertyItem *ppi = NULL;
    UINT cbProp = pimg->GetPropertyItemSize(pid); 
    if (cbProp) 
    {
        ppi = reinterpret_cast<PropertyItem*>(LocalAlloc(GPTR, cbProp));
        if (ppi)
        {
            if (Ok != pimg->GetPropertyItem(pid, cbProp, ppi))
            {
                LocalFree(ppi);
                ppi = NULL;
            }
        }
    }
    return ppi;
}

HRESULT
PidToString(Image *pimg, PROPID pid, WCHAR *szString, ULONG cch)
{
    HRESULT hr = S_FALSE;
    PropertyItem *ppi = GetPropertyItem(pimg, pid);
    if (ppi)
    {
        // Convert the PropertyItem to a PropVariant
        // Load IPropertyUI and format the property into a string
        PROPVARIANT pv = {0};
        if (SUCCEEDED(PropImgToPropvar(reinterpret_cast<PropertyItem*>(ppi), &pv, FALSE)))
        {
            CComPtr<IPropertyUI> pui;
            
            if (SUCCEEDED(CoCreateInstance(CLSID_PropertiesUI,
                                           NULL, 
                                           CLSCTX_INPROC_SERVER,
                                           IID_PPV_ARG(IPropertyUI,&pui))))
            {
                hr = pui->FormatForDisplay(FMTID_ImageProperties, 
                                           pid, 
                                           &pv,
                                           PUIFFDF_DEFAULT,
                                           szString,
                                           cch);
            }
            PropVariantClear(&pv);
        }
        LocalFree(ppi);
    }
    else
    {
        lstrcpynW(szString, TEXT("Unknown"), cch);
    }
    return hr;
}


HRESULT
GetThumbnail(Image *pimg, PROPID pid, void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType)
{
    HRESULT hr = E_FAIL;
    PropertyItem *ppi = GetPropertyItem(pimg, pid);
    if (ppi && ppi->length)
    {
        *ppvData = LocalAlloc(GPTR, ppi->length);
        if (*ppvData)
        {
            *pcb = ppi->length;
            CopyMemory(*ppvData, ppi->value, *pcb);
            if (ppszMimeType)
            {
                *ppszMimeType = L"image/jpeg";
            }
            hr = S_OK;
            
        }
        LocalFree(ppi);
    }
    else
    {
        Image *pThumb = pimg->GetThumbnailImage(160, 120);
        CComPtr<IStream> pstrm;
        if (pThumb)
        {
            hr = CreateStreamOnHGlobal(NULL, TRUE, &pstrm);
            if (SUCCEEDED(hr))
            {
                CEncoderInfo ei;
                CLSID clsidEncoder;
                ei.GetEncoderFromFormat(&ImageFormatJPEG, &clsidEncoder);
                if (Ok == pThumb->Save(pstrm, &clsidEncoder))
                {
                    LARGE_INTEGER zero = {0};
                    ULARGE_INTEGER ulSize = {0};
                    pstrm->Seek(zero, STREAM_SEEK_END, &ulSize);
                    pstrm->Seek(zero, STREAM_SEEK_SET, NULL);
                    *ppvData = LocalAlloc(LPTR, ulSize.LowPart);
                    hr = pstrm->Read(*ppvData, ulSize.LowPart, NULL); 
                    if (SUCCEEDED(hr))
                    {
                        *pcb = ulSize.LowPart;
                        if (ppszMimeType)
                        {
                            *ppszMimeType = L"image/jpeg";
                        }
                    }
                }
            }
            delete pThumb;
        }
    }
    return hr;
}

static const WCHAR wszHTML[] = 
L"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\"><html><head><title>Image Properties</title></head><body><table><tr><td>Thumbnail</td><td><img src=\"file:///image.jpg?thumbnail\"></img></td></tr><tr><td>Camera Model</td><td>%ls</td></tr></table></body></html>";

HRESULT
GetSummaryProps(Image *pimg, PROPID pid, void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType)
{
    WCHAR szModel[MAX_PATH];
    WCHAR szHtml[2048];
    void *pvThumbnail;
    ULONG cbThumbnail;
    CMimeDocument doc;
    HRESULT hr = doc.Initialize();
    if (SUCCEEDED(hr))
    {
        hr = PidToString(pimg, PropertyTagEquipModel, szModel, ARRAYSIZE(szModel));
        if (SUCCEEDED(hr))
        {
            wnsprintf(szHtml, ARRAYSIZE(szHtml), wszHTML, szModel);
            hr = doc.AddHTMLSegment(szHtml);
            if (SUCCEEDED(hr))
            {
                LPCWSTR pszThumbnailMime;
                hr = GetThumbnail(pimg, PropertyTagThumbnailData, &pvThumbnail, &cbThumbnail, &pszThumbnailMime);
                if (SUCCEEDED(hr))
                {
                    hr = doc.AddThumbnail(pvThumbnail, cbThumbnail, L"image.jpg", pszThumbnailMime);
                    LocalFree(pvThumbnail);
                    if (SUCCEEDED(hr))
                    {
                        hr = doc.GetDocument(ppvData, pcb, ppszMimeType);                       
                    }
                }
            }
        }
    }
    return hr;
}
//
// Create a table to map friendly names to property IDs and content generator routines
struct CPropEntry
{
    PROPID    nId;
    const wchar_t *pszCanonical; // name in the URL
    const wchar_t *pszString;    // name shown in the HTML stream
    TagProc fnFormat;            
};

#define MKFLAG(x) { (x), L#x, L#x, NULL }
#define MKFLAG2(a,x,y,z) { (a), TEXT(x), TEXT(y), (z) }


    
    static CPropEntry s_PropertyIds[] =
    {
        MKFLAG2(PropertyTagArtist, "Artist", "Artist", NULL),
        MKFLAG2(PropertyTagBitsPerSample, "BPS", "Bits per Sample", NULL),
        MKFLAG2(PropertyTagCellHeight, "CellHeight", "Cell Height", NULL),
        MKFLAG2(PropertyTagCellWidth, "CellWidth", "Cell Width", NULL),
        MKFLAG2(PropertyTagChrominanceTable, "", "Chrominance Table", NULL),
        MKFLAG(PropertyTagColorMap),
        MKFLAG(PropertyTagColorTransferFunction),
        MKFLAG(PropertyTagCompression),
        MKFLAG(PropertyTagCopyright),
        MKFLAG(PropertyTagDateTime),
        MKFLAG(PropertyTagDocumentName),
        MKFLAG(PropertyTagDotRange),
        MKFLAG2(PropertyTagEquipMake, "Make", "Camera Make", NULL),
        MKFLAG2(PropertyTagEquipModel, "Model", "Camera Model", NULL),
        MKFLAG2(PropertyTagExifAperture, "Aperture", "Aperture", NULL),
        MKFLAG2(PropertyTagExifBrightness, "Brightness", "Brightness", NULL),
        MKFLAG(PropertyTagExifCfaPattern),
        MKFLAG2(PropertyTagExifColorSpace, "ColorSpace", "Color Space", NULL),
        MKFLAG(PropertyTagExifCompBPP),
        MKFLAG(PropertyTagExifCompConfig),
        MKFLAG(PropertyTagExifDTDigSS),
        MKFLAG(PropertyTagExifDTDigitized),
        MKFLAG2(PropertyTagExifDTOrig, "DateTaken", "Date Taken", NULL),
        MKFLAG(PropertyTagExifDTOrigSS),
        MKFLAG(PropertyTagExifDTSubsec),
        MKFLAG(PropertyTagExifExposureBias),
        MKFLAG(PropertyTagExifExposureIndex),
        MKFLAG2(PropertyTagExifExposureProg, "ExpProg", "Exposure Program", NULL),
        MKFLAG2(PropertyTagExifExposureTime, "ExpTime", "Exposure Time", NULL),
        MKFLAG2(PropertyTagExifFNumber, "FStop", "F Stop", NULL),
        MKFLAG(PropertyTagExifFPXVer),
        MKFLAG(PropertyTagExifFileSource),
        MKFLAG2(PropertyTagExifFlash, "Flash", "Flash Mode", NULL),
        MKFLAG2(PropertyTagExifFlashEnergy, "FlashEnergy", "Flash Energy", NULL),
        MKFLAG2(PropertyTagExifFocalLength, "FocalLength", "Focal Length", NULL),
        MKFLAG(PropertyTagExifFocalResUnit),
        MKFLAG(PropertyTagExifFocalXRes),
        MKFLAG(PropertyTagExifFocalYRes),
        MKFLAG(PropertyTagExifIFD),
        MKFLAG2(PropertyTagExifISOSpeed, "ISOSpeed", "ISO Speed", NULL),
        MKFLAG(PropertyTagExifInterop),
        MKFLAG2(PropertyTagExifLightSource, "Light", "Light Source", NULL),
        MKFLAG2(PropertyTagExifMakerNote, "MakerNote", "Maker Note", NULL),
        MKFLAG(PropertyTagExifMaxAperture),
        MKFLAG2(PropertyTagExifMeteringMode, "MeterMode", "Metering Mode", NULL),
        MKFLAG(PropertyTagExifOECF),
        MKFLAG(PropertyTagExifPixXDim),
        MKFLAG(PropertyTagExifPixYDim),
        MKFLAG(PropertyTagExifRelatedWav),
        MKFLAG(PropertyTagExifSceneType),
        MKFLAG(PropertyTagExifSensingMethod),
        MKFLAG2(PropertyTagExifShutterSpeed, "Shutter", "Shutter Speed", NULL),
        MKFLAG(PropertyTagExifSpatialFR),
        MKFLAG(PropertyTagExifSpectralSense),
        MKFLAG2(PropertyTagExifSubjectDist, "Distance", "Subject Distance", NULL),
        MKFLAG(PropertyTagExifSubjectLoc),
        MKFLAG2(PropertyTagExifUserComment, "Comment", "User Comment", NULL),
        MKFLAG(PropertyTagExifVer),
        MKFLAG(PropertyTagExtraSamples),
        MKFLAG(PropertyTagFillOrder),
        MKFLAG(PropertyTagFrameDelay),
        MKFLAG(PropertyTagFreeByteCounts),
        MKFLAG(PropertyTagFreeOffset),
        MKFLAG(PropertyTagGamma),
        MKFLAG(PropertyTagGrayResponseCurve),
        MKFLAG(PropertyTagGrayResponseUnit),
        MKFLAG(PropertyTagGridSize),
        MKFLAG(PropertyTagHalftoneDegree),
        MKFLAG(PropertyTagHalftoneHints),
        MKFLAG(PropertyTagHalftoneLPI),
        MKFLAG(PropertyTagHalftoneLPIUnit),
        MKFLAG(PropertyTagHalftoneMisc),
        MKFLAG(PropertyTagHalftoneScreen),
        MKFLAG(PropertyTagHalftoneShape),
        MKFLAG(PropertyTagHostComputer),
        MKFLAG(PropertyTagICCProfile),
        MKFLAG(PropertyTagICCProfileDescriptor),
        MKFLAG2(PropertyTagImageDescription, "Description", "Description", NULL),
        MKFLAG2(PropertyTagImageHeight, "Height", "Height", NULL),
        MKFLAG2(PropertyTagImageTitle, "Title", "Title", NULL),
        MKFLAG2(PropertyTagImageWidth, "Width", "Width", NULL),
        MKFLAG(PropertyTagInkNames),
        MKFLAG(PropertyTagInkSet),
        MKFLAG(PropertyTagJPEGACTables),
        MKFLAG(PropertyTagJPEGDCTables),
        MKFLAG(PropertyTagJPEGInterFormat),
        MKFLAG(PropertyTagJPEGInterLength),
        MKFLAG(PropertyTagJPEGLosslessPredictors),
        MKFLAG(PropertyTagJPEGPointTransforms),
        MKFLAG(PropertyTagJPEGProc),
        MKFLAG(PropertyTagJPEGQTables),
        MKFLAG2(PropertyTagJPEGQuality, "Quality", "JPEG Quality", NULL),
        MKFLAG(PropertyTagJPEGRestartInterval),
        MKFLAG(PropertyTagLoopCount),
        MKFLAG(PropertyTagLuminanceTable),
        MKFLAG(PropertyTagMaxSampleValue),
        MKFLAG(PropertyTagMinSampleValue),
        MKFLAG(PropertyTagNewSubfileType),
        MKFLAG(PropertyTagNumberOfInks),
        MKFLAG(PropertyTagOrientation),
        MKFLAG(PropertyTagPageName),
        MKFLAG(PropertyTagPageNumber),
        MKFLAG(PropertyTagPaletteHistogram),
        MKFLAG(PropertyTagPhotometricInterp),
        MKFLAG(PropertyTagPixelPerUnitX),
        MKFLAG(PropertyTagPixelPerUnitY),
        MKFLAG(PropertyTagPixelUnit),
        MKFLAG(PropertyTagPlanarConfig),
        MKFLAG(PropertyTagPredictor),
        MKFLAG(PropertyTagPrimaryChromaticities),
        MKFLAG(PropertyTagPrintFlags),
        MKFLAG(PropertyTagPrintFlagsBleedWidth),
        MKFLAG(PropertyTagPrintFlagsBleedWidthScale),
        MKFLAG(PropertyTagPrintFlagsCrop),
        MKFLAG(PropertyTagPrintFlagsVersion),
        MKFLAG(PropertyTagREFBlackWhite),
        MKFLAG(PropertyTagResolutionUnit),
        MKFLAG(PropertyTagResolutionXLengthUnit),
        MKFLAG(PropertyTagResolutionXUnit),
        MKFLAG(PropertyTagResolutionYLengthUnit),
        MKFLAG(PropertyTagResolutionYUnit),
        MKFLAG(PropertyTagRowsPerStrip),
        MKFLAG(PropertyTagSMaxSampleValue),
        MKFLAG(PropertyTagSMinSampleValue),
        MKFLAG(PropertyTagSRGBRenderingIntent),
        MKFLAG(PropertyTagSampleFormat),
        MKFLAG(PropertyTagSamplesPerPixel),
        MKFLAG(PropertyTagSoftwareUsed),
        MKFLAG(PropertyTagStripBytesCount),
        MKFLAG(PropertyTagStripOffsets),
        MKFLAG(PropertyTagSubfileType),
        MKFLAG(PropertyTagT4Option),
        MKFLAG(PropertyTagT6Option),
        MKFLAG(PropertyTagTargetPrinter),
        MKFLAG(PropertyTagThreshHolding),
        MKFLAG(PropertyTagThumbnailArtist),
        MKFLAG(PropertyTagThumbnailBitsPerSample),
        MKFLAG(PropertyTagThumbnailColorDepth),
        MKFLAG(PropertyTagThumbnailCompressedSize),
        MKFLAG(PropertyTagThumbnailCompression),
        MKFLAG(PropertyTagThumbnailCopyRight),
        MKFLAG2(PropertyTagThumbnailData, "Thumbnail", "Thumbnail", GetThumbnail),
        MKFLAG(PropertyTagThumbnailDateTime),
        MKFLAG(PropertyTagThumbnailEquipMake),
        MKFLAG(PropertyTagThumbnailEquipModel),
        MKFLAG(PropertyTagThumbnailFormat),
        MKFLAG(PropertyTagThumbnailHeight),
        MKFLAG(PropertyTagThumbnailImageDescription),
        MKFLAG(PropertyTagThumbnailImageHeight),
        MKFLAG(PropertyTagThumbnailImageWidth),
        MKFLAG(PropertyTagThumbnailOrientation),
        MKFLAG(PropertyTagThumbnailPhotometricInterp),
        MKFLAG(PropertyTagThumbnailPlanarConfig),
        MKFLAG(PropertyTagThumbnailPlanes),
        MKFLAG(PropertyTagThumbnailPrimaryChromaticities),
        MKFLAG(PropertyTagThumbnailRawBytes),
        MKFLAG(PropertyTagThumbnailRefBlackWhite),
        MKFLAG(PropertyTagThumbnailResolutionUnit),
        MKFLAG(PropertyTagThumbnailResolutionX),
        MKFLAG(PropertyTagThumbnailResolutionY),
        MKFLAG(PropertyTagThumbnailRowsPerStrip),
        MKFLAG(PropertyTagThumbnailSamplesPerPixel),
        MKFLAG(PropertyTagThumbnailSize),
        MKFLAG(PropertyTagThumbnailSoftwareUsed),
        MKFLAG(PropertyTagThumbnailStripBytesCount),
        MKFLAG(PropertyTagThumbnailStripOffsets),
        MKFLAG(PropertyTagThumbnailTransferFunction),
        MKFLAG(PropertyTagThumbnailWhitePoint),
        MKFLAG(PropertyTagThumbnailWidth),
        MKFLAG(PropertyTagThumbnailYCbCrCoefficients),
        MKFLAG(PropertyTagThumbnailYCbCrPositioning),
        MKFLAG(PropertyTagThumbnailYCbCrSubsampling),
        MKFLAG(PropertyTagTileByteCounts),
        MKFLAG(PropertyTagTileLength),
        MKFLAG(PropertyTagTileOffset),
        MKFLAG(PropertyTagTileWidth),
        MKFLAG(PropertyTagTransferFuncition),
        MKFLAG(PropertyTagTransferRange),
        MKFLAG(PropertyTagWhitePoint),
        MKFLAG(PropertyTagXPosition),
        MKFLAG2(PropertyTagXResolution, "Xdpi", "DPI X", NULL),
        MKFLAG(PropertyTagYCbCrCoefficients),
        MKFLAG(PropertyTagYCbCrPositioning),
        MKFLAG(PropertyTagYCbCrSubsampling),
        MKFLAG(PropertyTagYPosition),
        MKFLAG2(PropertyTagYResolution, "Ydpi", "DPI Y", NULL),
        MKFLAG2(0xffff, "Properties", "Properties", GetSummaryProps)
    };

CPropEntry *FindPropertyEntry(LPCWSTR pszPropid ) 
{
    PROPID pid = (PROPID)_wtol(pszPropid);
    CPropEntry *pRet = NULL;
    for (UINT i=0;!pRet && i<ARRAYSIZE(s_PropertyIds);i++)
    {
        if (s_PropertyIds[i].nId == pid || !lstrcmpiW(s_PropertyIds[i].pszCanonical, pszPropid))
        {
            pRet = s_PropertyIds+i;
        }
    }
    return pRet;
}



HRESULT 
CImgProtocol::_GetImageProperty(Image *pimg, void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType)
{
    //
    // TODO: Build a multi-part MIME encoding so we can return multiple properties
    // with one URL. Also, make "?Properties" a macro for a bunch of useful properties.
    //
    HRESULT hr = E_FAIL;
    CPropEntry *pProp = FindPropertyEntry(m_strProperty);
    if (pProp)
    {
        TagProc fnTagProc = pProp->fnFormat ? pProp->fnFormat : _DefaultTagProc;
        hr = fnTagProc(pimg, pProp->nId, ppvData, pcb, ppszMimeType); 
    }
    return hr;
}


HRESULT
CImgProtocol::_DefaultTagProc(Image *pimg, PROPID pid, void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType)
{
    WCHAR wszText[MAX_PATH];
    HRESULT hr = PidToString(pimg, pid, wszText, ARRAYSIZE(wszText)); 
    if (SUCCEEDED(hr))
    {
        *pcb = WideCharToMultiByte(CP_ACP, 0, wszText, -1, NULL, 0, NULL, NULL);
        if (*pcb)
        {
            *ppvData = LocalAlloc(LPTR, *pcb);
            if (*ppvData)
            {
                WideCharToMultiByte(CP_ACP, 0, wszText, -1, 
                                    reinterpret_cast<LPSTR>(*ppvData), *pcb, NULL, NULL); 
                hr = S_OK;
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\imageurl.h ===
#ifndef __imageurl_H_
#define __imageurl_H_

#include "resource.h"

class ATL_NO_VTABLE CImgProtocol : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CImgProtocol, &CLSID_ImgProtocol>,
    public IInternetProtocol
{
public:
    CImgProtocol();
    ~CImgProtocol(){};
    DECLARE_REGISTRY_RESOURCEID(IDR_IMGPROTOCOL)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CImgProtocol)
        COM_INTERFACE_ENTRY(IInternetProtocolRoot)
        COM_INTERFACE_ENTRY(IInternetProtocol)
    END_COM_MAP()

    STDMETHOD_(void,FinalRelease)();
    
    //IInternetProtocolRoot

    STDMETHOD(Start)( LPCWSTR szUrl, 
                      IInternetProtocolSink* pOIProtSink,
                      IInternetBindInfo* pOIBindInfo, 
                      DWORD grfPI, 
                      HANDLE_PTR dwReserved );
    STDMETHOD(Continue)( PROTOCOLDATA* pProtocolData );        
    STDMETHOD(Abort)( HRESULT hrReason, DWORD dwOptions );
    STDMETHOD(Terminate)( DWORD dwOptions );
    STDMETHOD(Suspend)();   
    STDMETHOD(Resume)();    

    //IInternetProtocol

    STDMETHOD(Read)( void* pv, ULONG cb, ULONG* pcbRead);
    STDMETHOD(Seek)( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    STDMETHOD(LockRequest)( DWORD dwOptions );
    STDMETHOD(UnlockRequest)( void );

private:

    PROTOCOLDATA           m_pd;
    ULONG                  m_ulOffset;
    CGraphicsInit          m_cgi;
    CSimpleStringWide      m_strProperty; // either a canonical name or a tag id
    CSimpleStringWide      m_strPath;
    CComPtr<IInternetProtocolSink> m_pSink;

    HRESULT _GetImagePathFromURL(LPCWSTR szUrl);
    static DWORD _ImageTagThreadProc(void *pv);   
    HRESULT    _GetImageProperty(Image *pimg, void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType);
    static HRESULT _DefaultTagProc(Image *pimg, PROPID pid, void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType);
};

typedef HRESULT(*TagProc)(Image *pimg, PROPID pid, void **ppv, ULONG *pcb, LPCWSTR *ppszMime);

#endif //__imageurl_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\multimime.cpp ===
#include "precomp.h"
#include "multimime.h"
#pragma hdrstop



CMimeDocument::CMimeDocument()
{   
}

HRESULT
CMimeDocument::Initialize()
{
    HRESULT hr = CoCreateInstance(CLSID_IMimeMessage, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_PPV_ARG(IMimeMessage,&m_pmsg));
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> pInit(m_pmsg);
        // Initialize the Message
        hr = pInit->InitNew();
        if (SUCCEEDED(hr))
        {
            PROPVARIANT pv = {0};
            pv.vt = VT_LPSTR;
            pv.pszVal = "multipart/related";
            m_pmsg->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), PDF_ENCODED, &pv);
        }
    }
    return hr;
}

HRESULT CMimeDocument::_CreateStreamFromData(void *pv, ULONG cb, IStream **ppstrm)
{
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, ppstrm);
    if (SUCCEEDED(hr))
    {
        ULARGE_INTEGER ul = {0};
        ul.LowPart = cb;
        (*ppstrm)->SetSize(ul);
        hr = (*ppstrm)->Write(pv, cb, &cb);
    }
    return hr;
}

HRESULT
CMimeDocument::AddHTMLSegment(LPCWSTR pszHTML)
{
    CComPtr<IStream> pstrm;
    HRESULT hr = _CreateStreamFromData((void*)pszHTML, (wcslen(pszHTML)+1)*sizeof(WCHAR), &pstrm);
    if (SUCCEEDED(hr))
    {
        HBODY h;
        hr = m_pmsg->SetTextBody(TXT_HTML, IET_UNICODE, NULL, pstrm, &h);
    }
    return hr;
}

HRESULT 
CMimeDocument::AddThumbnail(void *pBits, ULONG cb, LPCWSTR pszName, LPCWSTR pszMimeType)
{
    CComPtr<IStream> pstrm;
    char szThumbURL[MAX_PATH];
    wnsprintfA(szThumbURL, MAX_PATH, "file:///%ls?thumbnail", pszName);
    HRESULT hr = _CreateStreamFromData(pBits, cb, &pstrm);
    if (SUCCEEDED(hr))
    {
        HBODY h;
        hr = m_pmsg->AttachURL(NULL, szThumbURL, 0, pstrm, NULL, &h);
        if (SUCCEEDED(hr))
        {
            PROPVARIANT pv = {0};
            pv.vt= VT_LPWSTR;
            pv.pwszVal = const_cast<LPWSTR>(pszMimeType);
            m_pmsg->SetBodyProp(h, PIDTOSTR(PID_HDR_CNTTYPE), PDF_ENCODED, &pv); 
        }
    }
    return hr;
}

HRESULT
CMimeDocument::GetDocument(void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType)
{
    CComPtr<IPersistStreamInit> pInit;
    HRESULT hr = m_pmsg->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &pInit));
    if (SUCCEEDED(hr))
    {
        //
        // Get the size of the buffer
        //
        CComPtr<IStream> pstrm;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pstrm);
        if (SUCCEEDED(hr))
        {
            hr = pInit->Save(pstrm, TRUE);
            if (SUCCEEDED(hr))
            {
                LARGE_INTEGER zero = {0};
                ULARGE_INTEGER ulSize = {0};
                pstrm->Seek(zero, STREAM_SEEK_END, &ulSize);
                pstrm->Seek(zero, STREAM_SEEK_SET, NULL);
                *ppvData = LocalAlloc(LPTR, ulSize.LowPart);
                if (*ppvData)
                {
                    *pcb = ulSize.LowPart;
                    hr = pstrm->Read(*ppvData, ulSize.LowPart, NULL);
                    if (FAILED(hr))
                    {
                        LocalFree(*ppvData);
                        *ppvData = NULL;
                        *pcb = 0;
                    }
                    else
                    {
                        *ppszMimeType = L"message/rfc822";
                    }
                }
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\resource.h ===
#define IDR_IMGPROTOCOL 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\precomp.h ===
#ifndef _pch_h
#define _pch_h


#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif


#include <windows.h>
#include <gdiplus.h>
using namespace Gdiplus;
#include "uicommon.h"
#define _ATL_APARTMENT_THREADED
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#include <wininet.h>
#include <urlmon.h>
#include <shobjidl.h>
#include <shlguid.h>
#include <initguid.h>
#include <mimeole.h>

#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))

class CGraphicsInit
{
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        GdiplusStartupInput gsi;
        GdiplusStartupOutput gso;
        gsi.SuppressBackgroundThread = TRUE;
        GdiplusStartup(&_token, &gsi,&gso);
    }
    ~CGraphicsInit()
    {
        if (_token)
        {
            GdiplusShutdown(_token);
        }
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\prototypes\imageurl\multimime.h ===
//
// Define a class for constructing multi-part MIME content.
// Our document consists of some HTML with an embedded thumbnail image.
// The thumbnail might be jpeg or bmp
//
class CMimeDocument
{
public:
    CMimeDocument();

    HRESULT Initialize();
    HRESULT AddHTMLSegment(LPCWSTR szHTML);
    HRESULT AddThumbnail(void *pBits, ULONG cb, LPCWSTR pszName, LPCWSTR pszMimeType);
    HRESULT GetDocument(void **ppvData, ULONG *pcb, LPCWSTR *ppszMimeType);

private:
    CComPtr<IMimeMessage> m_pmsg;   
    HRESULT _CreateStreamFromData(void *pv, ULONG cb, IStream **ppstrm);
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\scandlg.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANDLG.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Scan Dialog Implementation
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "uiexthlp.h"
#include "simrect.h"
#include "movewnd.h"
#include "dlgunits.h"
#include "wiaregst.h"
#include "gwiaevnt.h"
#include "wiacsh.h"

//
// Context Help IDs
//
static const DWORD g_HelpIDs[] =
{
    IDC_LARGE_TITLE,           -1,
    IDC_SCANDLG_SELECT_PROMPT, -1,
    IDC_INTENT_ICON_1,         IDH_WIA_PIC_TYPE,
    IDC_INTENT_ICON_2,         IDH_WIA_PIC_TYPE,
    IDC_INTENT_ICON_3,         IDH_WIA_PIC_TYPE,
    IDC_INTENT_ICON_4,         IDH_WIA_PIC_TYPE,
    IDC_INTENT_1,              IDH_WIA_PIC_TYPE,
    IDC_INTENT_2,              IDH_WIA_PIC_TYPE,
    IDC_INTENT_3,              IDH_WIA_PIC_TYPE,
    IDC_INTENT_4,              IDH_WIA_PIC_TYPE,
    IDC_SCANDLG_PAPERSOURCE,   IDH_WIA_PAPER_SOURCE,
    IDC_SCANDLG_PAPERSIZE,     IDH_WIA_PAGE_SIZE,
    IDC_SCANDLG_RESCAN,        IDH_WIA_PREVIEW_BUTTON,
    IDC_SCANDLG_SCAN,          IDH_WIA_SCAN_BUTTON,
    IDC_SCANDLG_PREVIEW,       IDH_WIA_IMAGE_PREVIEW,
    IDC_INNER_PREVIEW_WINDOW,  IDH_WIA_IMAGE_PREVIEW,
    IDC_YOU_CAN_ALSO,          IDH_WIA_CUSTOM_SETTINGS,
    IDC_SCANDLG_ADVANCED,      IDH_WIA_CUSTOM_SETTINGS,
    IDCANCEL,                  IDH_CANCEL,
    0, 0
};

#define REGSTR_PATH_USER_SETTINGS_SCANDLG        REGSTR_PATH_USER_SETTINGS TEXT("\\WiaCommonScannerDialog")
#define REGSTR_KEYNAME_USER_SETTINGS_SCANDLG     TEXT("CommonDialogCustomSettings")

extern HINSTANCE g_hInstance;

#define IDC_SIZEBOX         1212

#define PWM_WIAEVENT (WM_USER+1)

//
// Associate a document handling flag with a string resource
//
static const struct
{
    int nFlag;
    int nStringId;
}
g_SupportedDocumentHandlingTypes[] =
{
    { FLATBED, IDS_SCANDLG_FLATBED },
    { FEEDER,  IDS_SCANDLG_ADF }
};

//
// Associate an icon control's resource id with a radio button's resource id
//
static const struct
{
    int nIconId;
    int nRadioId;
}
g_IntentRadioButtonIconPairs[] =
{
    { IDC_INTENT_ICON_1, IDC_INTENT_1},
    { IDC_INTENT_ICON_2, IDC_INTENT_2},
    { IDC_INTENT_ICON_3, IDC_INTENT_3},
    { IDC_INTENT_ICON_4, IDC_INTENT_4}
};
static const int gs_nCountIntentRadioButtonIconPairs = ARRAYSIZE(g_IntentRadioButtonIconPairs);

/*
 * Sole constructor
 */
CScannerAcquireDialog::CScannerAcquireDialog( HWND hwnd )
  : m_hWnd(hwnd),
    m_pDeviceDialogData(NULL),
    m_nMsgScanBegin(RegisterWindowMessage(SCAN_NOTIFYBEGINSCAN)),
    m_nMsgScanEnd(RegisterWindowMessage(SCAN_NOTIFYENDSCAN)),
    m_nMsgScanProgress(RegisterWindowMessage(SCAN_NOTIFYPROGRESS)),
    m_bScanning(false),
    m_hBigTitleFont(NULL),
    m_hIconLarge(NULL),
    m_hIconSmall(NULL),
    m_bHasFlatBed(false),
    m_bHasDocFeed(false),
    m_pScannerItem(NULL),
    m_hBitmapDefaultPreviewBitmap(NULL)
{
    ZeroMemory( &m_sizeDocfeed, sizeof(m_sizeDocfeed) );
    ZeroMemory( &m_sizeFlatbed, sizeof(m_sizeFlatbed) );
}

/*
 * Destructor
 */
CScannerAcquireDialog::~CScannerAcquireDialog(void)
{
    //
    // Free resources
    //
    if (m_hBigTitleFont)
    {
        DeleteObject(m_hBigTitleFont);
        m_hBigTitleFont = NULL;
    }
    if (m_hIconLarge)
    {
        DestroyIcon(m_hIconLarge);
        m_hIconLarge = NULL;
    }
    if (m_hIconSmall)
    {
        DestroyIcon(m_hIconSmall);
        m_hIconSmall = NULL;
    }
    if (m_hBitmapDefaultPreviewBitmap)
    {
        DeleteObject(m_hBitmapDefaultPreviewBitmap);
        m_hBitmapDefaultPreviewBitmap = NULL;
    }

    //
    // Free the paper sizes
    //
    if (m_pPaperSizes)
    {
        CComPtr<IWiaScannerPaperSizes> pWiaScannerPaperSizes;
        HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaScannerPaperSizes, (void**)&pWiaScannerPaperSizes );
        if (SUCCEEDED(hr))
        {
            hr = pWiaScannerPaperSizes->FreePaperSizes( &m_pPaperSizes, &m_nPaperSizeCount );
        }
    }
}

LRESULT CScannerAcquireDialog::OnSize( WPARAM wParam, LPARAM lParam )
{
    if (wParam == SIZE_RESTORED || wParam == SIZE_MAXIMIZED)
    {
        CSimpleRect rcClient( m_hWnd, CSimpleRect::ClientRect );
        CDialogUnits dialogUnits(m_hWnd);
        CMoveWindow mw;

        //
        // Get the button rects
        //
        CSimpleRect rcPreviewButton( GetDlgItem( m_hWnd, IDC_SCANDLG_RESCAN ), CSimpleRect::WindowRect );
        CSimpleRect rcScanButton( GetDlgItem( m_hWnd, IDC_SCANDLG_SCAN ), CSimpleRect::WindowRect );
        CSimpleRect rcCancelButton( GetDlgItem( m_hWnd, IDCANCEL ), CSimpleRect::WindowRect );

        //
        // We need to find the left hand side of the preview control
        //
        CSimpleRect rcPreview( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), CSimpleRect::WindowRect );
        rcPreview.ScreenToClient(m_hWnd).left;

        //
        // Move the preview control
        //
        mw.Size( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ),
                 rcClient.Width() - rcPreview.ScreenToClient(m_hWnd).left - dialogUnits.X(7),
                 rcClient.Height() - dialogUnits.Y(7) - dialogUnits.Y(7) - dialogUnits.Y(7) - rcPreviewButton.Height() );

        //
        // Move the buttons
        //
        mw.Move( GetDlgItem( m_hWnd, IDC_SCANDLG_RESCAN ),
                 rcClient.Width() - dialogUnits.X(7) - rcPreviewButton.Width() - rcScanButton.Width() - rcCancelButton.Width() - dialogUnits.X(8),
                 rcClient.Height() - rcPreviewButton.Height() - dialogUnits.Y(7) );
        mw.Move( GetDlgItem( m_hWnd, IDC_SCANDLG_SCAN ),
                 rcClient.Width() - dialogUnits.X(7) - rcScanButton.Width() - rcCancelButton.Width() - dialogUnits.X(4),
                 rcClient.Height() - rcPreviewButton.Height() - dialogUnits.Y(7) );
        mw.Move( GetDlgItem( m_hWnd, IDCANCEL ),
                 rcClient.Width() - dialogUnits.X(7) - rcCancelButton.Width(),
                 rcClient.Height() - rcPreviewButton.Height() - dialogUnits.Y(7) );

        //
        // Move the resizing handle
        //
        mw.Move( GetDlgItem( m_hWnd, IDC_SIZEBOX ),
                 rcClient.Width() - GetSystemMetrics(SM_CXVSCROLL),
                 rcClient.Height() - GetSystemMetrics(SM_CYHSCROLL)
               );

    }
    return(0);
}

LRESULT CScannerAcquireDialog::OnInitDialog( WPARAM, LPARAM lParam )
{
    //
    // Validate the creation parameters
    //
    m_pDeviceDialogData = reinterpret_cast<DEVICEDIALOGDATA*>(lParam);
    if (!m_pDeviceDialogData)
    {
        WIA_ERROR((TEXT("SCANDLG: Invalid parameter: DEVICEDIALOGDATA*")));
        EndDialog( m_hWnd, E_INVALIDARG );
        return(0);
    }
    if (m_pDeviceDialogData->cbSize != sizeof(DEVICEDIALOGDATA))
    {
        WIA_ERROR((TEXT("SCANDLG: Invalid parameter: DEVICEDIALOGDATA*/PROPSHEETPAGE* (no known sizeof matches lParam)")));
        EndDialog( m_hWnd, E_INVALIDARG );
        return(0);
    }

    //
    // Initialialize our return stuff
    //
    m_pDeviceDialogData->lItemCount = 0;
    if (m_pDeviceDialogData->ppWiaItems)
    {
        *m_pDeviceDialogData->ppWiaItems = NULL;
    }

    //
    // Make sure we have valid a valid device
    //
    if (!m_pDeviceDialogData->pIWiaItemRoot)
    {
        WIA_ERROR((TEXT("SCANDLG: Invalid paramaters: pIWiaItem")));
        EndDialog( m_hWnd, E_INVALIDARG );
        return(0);
    }

    //
    // Find all of the scanner items
    //
    HRESULT hr = m_ScanItemList.Enumerate( m_pDeviceDialogData->pIWiaItemRoot );
    if (FAILED(hr))
    {
        WIA_PRINTHRESULT((hr,TEXT("SCANDLG: m_ScanItemList.Enumerate failed")));
        EndDialog( m_hWnd, hr );
        return(0);
    }

    //
    // Get the first child item and save it.
    //
    CScanItemList::Iterator CurItem = m_ScanItemList.CurrentItem();
    if (CurItem == m_ScanItemList.End())
    {
        hr = E_FAIL;
        EndDialog( m_hWnd, hr );
        return(0);
    }
    m_pScannerItem = &(*CurItem);


    //
    // Make sure we have a valid item
    //
    hr = WiaUiUtil::VerifyScannerProperties(m_pScannerItem->Item());
    if (!SUCCEEDED(hr))
    {
        hr = E_FAIL;
        EndDialog( m_hWnd, hr );
        return(0);
    }

    WIA_TRACE((TEXT("Here is the list of scan items:")));
    for (CScanItemList::Iterator x=m_ScanItemList.Begin();x != m_ScanItemList.End();++x)
    {
        WIA_TRACE((TEXT("x = %p"), (*x).Item() ));
    }

    //
    // Get the page sizes
    //
    CComPtr<IWiaScannerPaperSizes> pWiaScannerPaperSizes;
    hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaScannerPaperSizes, (void**)&pWiaScannerPaperSizes );
    if (SUCCEEDED(hr))
    {
        hr = pWiaScannerPaperSizes->GetPaperSizes( &m_pPaperSizes, &m_nPaperSizeCount );
        if (FAILED(hr))
        {
            EndDialog( m_hWnd, hr );
            return 0;
        }

    }

    //
    // Create and set the big font
    //
    m_hBigTitleFont = WiaUiUtil::CreateFontWithPointSizeFromWindow( GetDlgItem(m_hWnd,IDC_LARGE_TITLE), 14, false, false );
    if (m_hBigTitleFont)
    {
        SendDlgItemMessage( m_hWnd, IDC_LARGE_TITLE, WM_SETFONT, reinterpret_cast<WPARAM>(m_hBigTitleFont), MAKELPARAM(TRUE,0));
    }

    //
    // Get the flatbed aspect ratio
    //
    PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_HORIZONTAL_BED_SIZE, m_sizeFlatbed.cx );
    PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_VERTICAL_BED_SIZE, m_sizeFlatbed.cy );

    //
    // Get the sheet feeder aspect ratio
    //
    PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE, m_sizeDocfeed.cx );
    PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_VERTICAL_SHEET_FEED_SIZE, m_sizeDocfeed.cy );

    // Get the minimum size of the window
    RECT rcWindow;
    GetWindowRect( m_hWnd, &rcWindow );
    m_sizeMinimumWindowSize.cx = (rcWindow.right - rcWindow.left);
    m_sizeMinimumWindowSize.cy = (rcWindow.bottom - rcWindow.top);

    //
    // Initialize the selection rectangle
    //
    WiaPreviewControl_ClearSelection( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ) );

    //
    // Ensure that the aspect ratio is correct
    //
    WiaPreviewControl_SetDefAspectRatio( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), &m_sizeFlatbed );

    //
    // Add all of the intents
    //
    PopulateIntentList();

    //
    // Set the title of the dialog
    //
    CSimpleStringWide strwDeviceName;
    if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DIP_DEV_NAME, strwDeviceName ))
    {
        CSimpleString().Format( IDS_DIALOG_TITLE, g_hInstance, CSimpleStringConvert::NaturalString(strwDeviceName).String() ).SetWindowText( m_hWnd );
    }

    //
    // Center the window on the client
    //
    WiaUiUtil::CenterWindow( m_hWnd, m_pDeviceDialogData->hwndParent );

    //
    // Get the device icons
    //
    CSimpleStringWide strwDeviceId, strwClassId;
    LONG nDeviceType;
    if (PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_UI_CLSID,strwClassId) &&
        PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_DEV_ID,strwDeviceId) &&
        PropStorageHelpers::GetProperty(m_pDeviceDialogData->pIWiaItemRoot,WIA_DIP_DEV_TYPE,nDeviceType))
    {
        //
        // Get the device icons
        //
        if (SUCCEEDED(WiaUiExtensionHelper::GetDeviceIcons( CSimpleBStr(strwClassId), nDeviceType, &m_hIconSmall, &m_hIconLarge )))
        {
            if (m_hIconSmall)
            {
                SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(m_hIconSmall) );
            }
            if (m_hIconLarge)
            {
                SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(m_hIconLarge) );
            }
        }

        //
        // Register for disconnect event
        //
        CGenericWiaEventHandler::RegisterForWiaEvent( strwDeviceId.String(), WIA_EVENT_DEVICE_DISCONNECTED, &m_DisconnectEvent, m_hWnd, PWM_WIAEVENT );
    }


    //
    // We are only resizeable if we have a preview control
    //
    if (GetDlgItem(m_hWnd,IDC_SCANDLG_PREVIEW))
    {
        //
        // Create the sizing control
        //
        (void)CreateWindowEx( 0, TEXT("scrollbar"), TEXT(""),
            WS_CHILD|WS_VISIBLE|SBS_SIZEGRIP|WS_CLIPSIBLINGS|SBS_SIZEBOXBOTTOMRIGHTALIGN|SBS_BOTTOMALIGN|WS_GROUP,
            CSimpleRect(m_hWnd).Width()-GetSystemMetrics(SM_CXVSCROLL),
            CSimpleRect(m_hWnd).Height()-GetSystemMetrics(SM_CYHSCROLL),
            GetSystemMetrics(SM_CXVSCROLL),
            GetSystemMetrics(SM_CYHSCROLL),
            m_hWnd, reinterpret_cast<HMENU>(IDC_SIZEBOX),
            g_hInstance, NULL );
    }

    //
    // Set a bitmap, so we can select stuff even if the user doesn't do a preview scan
    //
    m_hBitmapDefaultPreviewBitmap = reinterpret_cast<HBITMAP>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_DEFAULT_BITMAP), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION|LR_DEFAULTCOLOR ));
    if (m_hBitmapDefaultPreviewBitmap)
    {
        WiaPreviewControl_SetBitmap( GetDlgItem(m_hWnd,IDC_SCANDLG_PREVIEW), TRUE, TRUE, m_hBitmapDefaultPreviewBitmap );
    }

    //
    // If the scanner has document handling, it has an ADF.
    //
    LONG nDocumentHandlingSelect = 0;
    if (PropStorageHelpers::GetPropertyFlags( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, nDocumentHandlingSelect ) && (nDocumentHandlingSelect & FEEDER))
    {
        m_bHasDocFeed = true;
    }
    else
    {
        m_bHasDocFeed = false;
    }

    //
    // If the scanner has a vertical bed size, it has a flatbed
    //
    LONG nVerticalBedSize = 0;
    if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_VERTICAL_BED_SIZE, nVerticalBedSize ) && nVerticalBedSize)
    {
        m_bHasFlatBed = true;
    }
    else
    {
        m_bHasFlatBed = false;
    }

    PopulateDocumentHandling();

    PopulatePageSize();

    HandlePaperSourceSelChange();

    HandlePaperSizeSelChange();

    SetForegroundWindow(m_hWnd);

    return FALSE;
}


bool CScannerAcquireDialog::ApplyCurrentIntent(void)
{
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::ApplyCurrentIntent"));
    CWaitCursor wc;
    if (m_pScannerItem)
    {
        for (int i=0;i<gs_nCountIntentRadioButtonIconPairs;i++)
        {
            if (SendDlgItemMessage( m_hWnd, g_IntentRadioButtonIconPairs[i].nRadioId, BM_GETCHECK, 0, 0 )==BST_CHECKED)
            {
                LONG lIntent = static_cast<LONG>(GetWindowLongPtr( GetDlgItem( m_hWnd, g_IntentRadioButtonIconPairs[i].nRadioId ), GWLP_USERDATA ) );
                if (lIntent)
                {
                    //
                    // This is a normal intent
                    //
                    return m_pScannerItem->SetIntent( lIntent );
                }
                else if (m_pScannerItem->CustomPropertyStream().IsValid()) // This is the "custom" intent
                {
                    //
                    // This is the custom settings pseudo-intent
                    //
                    return (SUCCEEDED(m_pScannerItem->CustomPropertyStream().ApplyToWiaItem( m_pScannerItem->Item())));
                }
                break;
            }
        }
    }
    return false;
}


void CScannerAcquireDialog::PopulateDocumentHandling(void)
{
    HWND hWndDocumentHandling = GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSOURCE );
    if (m_bHasDocFeed && hWndDocumentHandling)
    {
        LONG nDocumentHandlingSelectFlags = 0;
        PropStorageHelpers::GetPropertyFlags( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, nDocumentHandlingSelectFlags );

        LONG nDocumentHandlingSelect = 0;
        PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, nDocumentHandlingSelect );

        if (!nDocumentHandlingSelectFlags)
        {
            nDocumentHandlingSelectFlags = FLATBED;
        }
        if (!nDocumentHandlingSelect)
        {
            nDocumentHandlingSelect = FLATBED;
        }

        int nSelectIndex = 0;
        for (int i=0;i<ARRAYSIZE(g_SupportedDocumentHandlingTypes);i++)
        {
            if (nDocumentHandlingSelectFlags & g_SupportedDocumentHandlingTypes[i].nFlag)
            {
                CSimpleString strDocumentHandlingName( g_SupportedDocumentHandlingTypes[i].nStringId, g_hInstance );
                if (strDocumentHandlingName.Length())
                {
                    LRESULT nIndex = SendMessage( hWndDocumentHandling, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(strDocumentHandlingName.String()));
                    if (nIndex != CB_ERR)
                    {
                        SendMessage( hWndDocumentHandling, CB_SETITEMDATA, nIndex, g_SupportedDocumentHandlingTypes[i].nFlag );
                        if (nDocumentHandlingSelect == g_SupportedDocumentHandlingTypes[i].nFlag)
                        {
                            nSelectIndex = (int)nIndex;
                        }
                    }
                }
            }
        }
        SendMessage( hWndDocumentHandling, CB_SETCURSEL, nSelectIndex, 0 );

        //
        // Make sure all of the strings fit
        //
        WiaUiUtil::ModifyComboBoxDropWidth(hWndDocumentHandling);
    }
}


void CScannerAcquireDialog::PopulatePageSize(void)
{
    HWND hWndPaperSize = GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE );
    if (m_bHasDocFeed && hWndPaperSize)
    {
        LONG nWidth=0, nHeight=0;
        PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE, nWidth );
        PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_VERTICAL_SHEET_FEED_SIZE, nHeight );

        //
        // Which index will initially be selected?
        //
        LRESULT nSelectIndex = 0;

        //
        // Save the largest sheet as our initially selected size
        //
        __int64 nMaximumArea = 0;
        for (UINT i=0;i<m_nPaperSizeCount;i++)
        {
            //
            // If this page will fit in the scanner...
            //
            if (m_pPaperSizes[i].nWidth <= static_cast<UINT>(nWidth) && m_pPaperSizes[i].nHeight <= static_cast<UINT>(nHeight))
            {
                //
                // Get the string name for this paper size
                //
                CSimpleString strPaperSizeName( CSimpleStringConvert::NaturalString(CSimpleStringWide(m_pPaperSizes[i].pszName)) );
                if (strPaperSizeName.Length())
                {
                    //
                    // Add the string to the combobox
                    //
                    LRESULT nIndex = SendMessage( hWndPaperSize, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(strPaperSizeName.String()));
                    if (nIndex != CB_ERR)
                    {
                        //
                        // Save the index into our global array
                        //
                        SendMessage( hWndPaperSize, CB_SETITEMDATA, nIndex, i );

                        //
                        // Check to see if this is the largest page, if it is, save the area and the index
                        //
                        if (((__int64)m_pPaperSizes[i].nWidth * m_pPaperSizes[i].nHeight) > nMaximumArea)
                        {
                            nMaximumArea = m_pPaperSizes[i].nWidth * m_pPaperSizes[i].nHeight;
                            nSelectIndex = nIndex;
                        }
                    }
                }
            }
        }
        //
        // Select the default size
        //
        SendMessage( hWndPaperSize, CB_SETCURSEL, nSelectIndex, 0 );

        //
        // Make sure all of the strings fit
        //
        WiaUiUtil::ModifyComboBoxDropWidth(hWndPaperSize);
    }
}


// Responds to WM_COMMAND notifications from the radio buttons
void CScannerAcquireDialog::OnIntentChange( WPARAM, LPARAM )
{
}

// Check a particular intent, and apply it to the current item
void CScannerAcquireDialog::SetIntentCheck( LONG nIntent )
{
    for (int i=0;i<gs_nCountIntentRadioButtonIconPairs;i++)
    {
        HWND hWndBtn = GetDlgItem( m_hWnd, g_IntentRadioButtonIconPairs[i].nRadioId );
        if (hWndBtn)
        {
            // If this intent is the same as the one we've been asked to set, check it
            if (static_cast<LONG>(GetWindowLongPtr(hWndBtn,GWLP_USERDATA)) == nIntent)
            {
                SendMessage( hWndBtn, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                // Uncheck all others
                SendMessage( hWndBtn, BM_SETCHECK, BST_UNCHECKED, 0 );
            }
        }
    }
}

// Set up the intent controls
void CScannerAcquireDialog::PopulateIntentList(void)
{
    WIA_PUSHFUNCTION(TEXT("PopulateIntentList"));
    //
    // We will be hiding any controls that are not used
    //
    int nCurControlSet = 0;
    if (m_pScannerItem)
    {
        static const struct
        {
            int      nIconId;
            int      nStringId;
            LONG_PTR nIntent;
        }
        s_Intents[] =
        {
            { IDI_COLORPHOTO,      IDS_INTENT_COLOR_PHOTO_TITLE, WIA_INTENT_IMAGE_TYPE_COLOR},
            { IDI_GRAYPHOTO,       IDS_INTENT_GRAYSCALE_TITLE,   WIA_INTENT_IMAGE_TYPE_GRAYSCALE},
            { IDI_TEXT_OR_LINEART, IDS_INTENT_TEXT_TITLE,        WIA_INTENT_IMAGE_TYPE_TEXT},
            { IDI_CUSTOM,          IDS_INTENT_CUSTOM_TITLE,      0}
        };
        static const int s_nIntents = ARRAYSIZE(s_Intents);


        LONG nIntents;
        WIA_TRACE((TEXT("Value of the current scanner item: %p"), m_pScannerItem->Item()));
        if (PropStorageHelpers::GetPropertyFlags( m_pScannerItem->Item(), WIA_IPS_CUR_INTENT, nIntents ))
        {
            WIA_TRACE((TEXT("Supported intents for this device: %08X"), nIntents ));

            for (int i=0;i<s_nIntents;i++)
            {
                //
                // Make sure it is not the special custom intent, OR it is a supported intent
                //
                if (!s_Intents[i].nIntent || (nIntents & s_Intents[i].nIntent))
                {
                    //
                    // Load the intent icon
                    //
                    HICON hIcon = reinterpret_cast<HICON>(LoadImage( g_hInstance, MAKEINTRESOURCE(s_Intents[i].nIconId), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR ));

                    //
                    // Set the icon for this intent
                    //
                    SendDlgItemMessage( m_hWnd, g_IntentRadioButtonIconPairs[nCurControlSet].nIconId, STM_SETICON, reinterpret_cast<WPARAM>(hIcon), 0 );

                    //
                    // Set the name of this intent
                    //
                    CSimpleString( s_Intents[i].nStringId, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, g_IntentRadioButtonIconPairs[nCurControlSet].nRadioId ) );

                    //
                    // Add in the size intent
                    //
                    LONG_PTR nIntent = s_Intents[i].nIntent;
                    if (nIntent)
                    {
                        nIntent |= (WIA_INTENT_SIZE_MASK & m_pDeviceDialogData->lIntent);
                    }

                    //
                    // Save the intent with this item
                    //
                    SetWindowLongPtr( GetDlgItem( m_hWnd, g_IntentRadioButtonIconPairs[nCurControlSet].nRadioId ), GWLP_USERDATA, nIntent );
                    nCurControlSet++;
                }
            }
        }
        else
        {
            WIA_ERROR((TEXT("Unable to get supported intents!")));
        }

        //
        // Set the default intent to be the first in the list
        //
        SetIntentCheck(static_cast<LONG>(GetWindowLongPtr(GetDlgItem(m_hWnd, g_IntentRadioButtonIconPairs[0].nRadioId ), GWLP_USERDATA )));

        //
        // Try to get our persisted settings and set them.  If an error occurs, we will get new custom settings.
        //
        if (!m_pScannerItem->CustomPropertyStream().ReadFromRegistry( m_pScannerItem->Item(), HKEY_CURRENT_USER,  REGSTR_PATH_USER_SETTINGS_SCANDLG, REGSTR_KEYNAME_USER_SETTINGS_SCANDLG ) ||
            FAILED(m_pScannerItem->CustomPropertyStream().ApplyToWiaItem(m_pScannerItem->Item())))
        {
            //
            // Apply the current intent before getting the new custom intent
            //
            ApplyCurrentIntent();

            //
            // Get the default custom property stream
            //
            m_pScannerItem->CustomPropertyStream().AssignFromWiaItem(m_pScannerItem->Item());
        }
    }
    else
    {
        WIA_ERROR((TEXT("There doesn't appear to be a scanner item")));
    }

    //
    // Hide the remaining controls
    //
    for (int i=nCurControlSet;i<gs_nCountIntentRadioButtonIconPairs;i++)
    {
        ShowWindow( GetDlgItem( m_hWnd, g_IntentRadioButtonIconPairs[i].nRadioId ), SW_HIDE );
        ShowWindow( GetDlgItem( m_hWnd, g_IntentRadioButtonIconPairs[i].nIconId ), SW_HIDE );
    }
}

/*
 * WM_COMMAND handler that rescans the full bed and replaces the image in the preview window
 */
void CScannerAcquireDialog::OnRescan( WPARAM, LPARAM )
{
    if (m_pScannerItem)
    {
        if (!ApplyCurrentIntent())
        {
            //
            // If we can't set the intent, tell the user and return
            //
            MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
            return;
        }
        HANDLE hThread = m_pScannerItem->Scan( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), m_hWnd );
        if (hThread)
        {
            m_bScanning = true;
            CloseHandle(hThread);
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString( IDS_PREVIEWSCAN_ERROR, g_hInstance ), CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
        }
    }
}

/*
 * User pressed the OK (scan) button
 */
void CScannerAcquireDialog::OnScan( WPARAM, LPARAM )
{
    //
    // Assume we'll use the preview window's settings, instead of the page size
    //
    bool bUsePreviewSettings = true;

    HRESULT hr = E_FAIL;
    if (m_pScannerItem)
    {
        if (!ApplyCurrentIntent())
        {
            //
            // If we can't set the intent, tell the user and return
            //
            MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
            return;
        }

        //
        // Find out if we're in the ADF capable dialog and if we are in document feeder mode
        //
        HWND hWndPaperSize = GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE );
        if (hWndPaperSize)
        {
            if (InDocFeedMode())
            {
                //
                // Get the selected paper size
                //
                LRESULT nCurSel = SendMessage( hWndPaperSize, CB_GETCURSEL, 0, 0 );
                if (nCurSel != CB_ERR)
                {
                    //
                    // Which entry in the global table is it?
                    //
                    LRESULT nPaperSizeIndex = SendMessage( hWndPaperSize, CB_GETITEMDATA, nCurSel, 0 );

                    //
                    // If we have a valid page size
                    //
                    if (m_pPaperSizes[nPaperSizeIndex].nWidth && m_pPaperSizes[nPaperSizeIndex].nHeight)
                    {
                        //
                        // We won't be using the preview window
                        //
                        bUsePreviewSettings = false;

                        //
                        // Assume this is not going to work
                        //
                        bool bSucceeded = false;

                        //
                        // Assume upper-left registration
                        //
                        POINT ptOrigin = { 0, 0 };
                        SIZE sizeExtent = { m_pPaperSizes[nPaperSizeIndex].nWidth, m_pPaperSizes[nPaperSizeIndex].nHeight };

                        //
                        // Get the registration, and shift the coordinates as necessary
                        //
                        LONG nSheetFeederRegistration;
                        if (!PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_SHEET_FEEDER_REGISTRATION, nSheetFeederRegistration ))
                        {
                            nSheetFeederRegistration = LEFT_JUSTIFIED;
                        }
                        if (nSheetFeederRegistration == CENTERED)
                        {
                            ptOrigin.x = (m_sizeDocfeed.cx - sizeExtent.cx) / 2;
                        }
                        else if (nSheetFeederRegistration == RIGHT_JUSTIFIED)
                        {
                            ptOrigin.x = m_sizeDocfeed.cx - sizeExtent.cx;
                        }

                        //
                        // Get the current resolution, so we can calculate the full-bed resolution in terms of the current DPI
                        //
                        LONG nXRes = 0, nYRes = 0;
                        if (PropStorageHelpers::GetProperty( m_pScannerItem->Item(), WIA_IPS_XRES, nXRes ) &&
                            PropStorageHelpers::GetProperty( m_pScannerItem->Item(), WIA_IPS_YRES, nYRes ))
                        {
                            //
                            // Make sure these are valid resolution settings
                            //
                            if (nXRes && nYRes)
                            {
                                //
                                //  Calculate the full bed resolution in the current DPI
                                //
                                SIZE sizeFullBedResolution = { 0, 0 };
                                sizeFullBedResolution.cx = WiaUiUtil::MulDivNoRound( nXRes, m_sizeDocfeed.cx, 1000 );
                                sizeFullBedResolution.cy = WiaUiUtil::MulDivNoRound( nYRes, m_sizeDocfeed.cy, 1000 );

                                //
                                // Make sure these resolution numbers are valid
                                //
                                if (sizeFullBedResolution.cx && sizeFullBedResolution.cy)
                                {
                                    //
                                    // Calculate the origin and extent in terms of the current DPI
                                    //
                                    ptOrigin.x = WiaUiUtil::MulDivNoRound( ptOrigin.x, sizeFullBedResolution.cx, m_sizeDocfeed.cx );
                                    ptOrigin.y = WiaUiUtil::MulDivNoRound( ptOrigin.y, sizeFullBedResolution.cy, m_sizeDocfeed.cy );

                                    sizeExtent.cx = WiaUiUtil::MulDivNoRound( sizeExtent.cx, sizeFullBedResolution.cx, m_sizeDocfeed.cx );
                                    sizeExtent.cy = WiaUiUtil::MulDivNoRound( sizeExtent.cy, sizeFullBedResolution.cy, m_sizeDocfeed.cy );

                                    //
                                    // Write the properties
                                    //
                                    if (PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_XPOS, ptOrigin.x ) &&
                                        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_YPOS, ptOrigin.y ) &&
                                        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_XEXTENT, sizeExtent.cx ) &&
                                        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_YEXTENT, sizeExtent.cy ))
                                    {
                                        //
                                        // Tell the scanner to scan from the ADF and to scan one page only
                                        //
                                        if (PropStorageHelpers::SetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, FEEDER ) &&
                                            PropStorageHelpers::SetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_PAGES, 1 ))
                                        {

                                            //
                                            // Everything seemed to work.  This item is ready for transfer.
                                            //
                                            bSucceeded = true;
                                        }
                                    }
                                }
                            }
                        }

                        if (!bSucceeded)
                        {
                            //
                            // If that icky code above failed, tell the user and return
                            //
                            MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
                            return;
                        }
                    }
                }
            }
            //
            // Else, we are not in document feeder mode
            //
            else
            {
                //
                // Tell the scanner to scan from the flatbed and and clear the page count
                //
                if (!PropStorageHelpers::SetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, FLATBED ) ||
                    !PropStorageHelpers::SetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_PAGES, 0 ))
                {
                    //
                    // If we can't set the document handling, tell the user and return
                    //
                    MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
                    return;
                }
            }
        }

        //
        // This means we are in sheet feeder mode
        //
        else if (!GetDlgItem(m_hWnd,IDC_SCANDLG_PREVIEW))
        {
            //
            // Set the origin to 0,0 and the extent to max,0
            //

            //
            // Get the current x resolution, so we can calculate the full-bed width in terms of the current DPI
            //
            LONG nXRes = 0;
            if (PropStorageHelpers::GetProperty( m_pScannerItem->Item(), WIA_IPS_XRES, nXRes ))
            {
                //
                // Make sure this is a valid resolution
                //
                if (nXRes)
                {
                    //
                    //  Calculate the full bed resolution in the current DPI
                    //
                    LONG nWidth = WiaUiUtil::MulDivNoRound( nXRes, m_sizeDocfeed.cx, 1000 );
                    if (nWidth)
                    {
                        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_XPOS, 0 );
                        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_YPOS, 0 );
                        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_XEXTENT, nWidth );
                        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_IPS_YEXTENT, 0 );
                        bUsePreviewSettings = false;
                    }
                }
            }
        }

        //
        // If we are scanning from the flatbed, or using custom page size settings, apply the preview window settings
        //
        if (bUsePreviewSettings)
        {
            m_pScannerItem->ApplyCurrentPreviewWindowSettings( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ) );
        }

        //
        // Turn off preview scanning.
        //
        PropStorageHelpers::SetProperty( m_pScannerItem->Item(), WIA_DPS_PREVIEW, WIA_FINAL_SCAN );

        //
        // Save the scanner item in the result array and return
        //
        hr = S_OK;
        m_pDeviceDialogData->ppWiaItems = (IWiaItem**)CoTaskMemAlloc( sizeof(IWiaItem*) * 1 );
        if (m_pDeviceDialogData->ppWiaItems)
        {
            m_pScannerItem->CustomPropertyStream().WriteToRegistry( m_pScannerItem->Item(), HKEY_CURRENT_USER,  REGSTR_PATH_USER_SETTINGS_SCANDLG, REGSTR_KEYNAME_USER_SETTINGS_SCANDLG );
            m_pDeviceDialogData->lItemCount = 1;
            m_pDeviceDialogData->ppWiaItems[0] = m_pScannerItem->Item();
            m_pDeviceDialogData->ppWiaItems[0]->AddRef();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            m_pDeviceDialogData->lItemCount = 0;
            m_pDeviceDialogData->ppWiaItems = NULL;
        }
    }

    EndDialog(m_hWnd,hr);
}

/*
 * User cancelled
 */
void CScannerAcquireDialog::OnCancel( WPARAM, LPARAM )
{
    if (m_bScanning)
    {
        if (m_pScannerItem)
        {
            m_pScannerItem->CancelEvent().Signal();

            //
            // Issue a cancel io command for this item
            //
            WiaUiUtil::IssueWiaCancelIO(m_pScannerItem->Item());
        }
        CSimpleString( IDS_WAIT, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDCANCEL ) );
    }
    else
    {
        EndDialog(m_hWnd,S_FALSE);
    }
}

void CScannerAcquireDialog::OnPreviewSelChange( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::OnPreviewSelChange"));
}

void CScannerAcquireDialog::OnAdvanced( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::OnAdvanced"));

    CWaitCursor wc;
    if (m_pScannerItem)
    {
        if (!ApplyCurrentIntent())
        {
            //
            // If we can't set the intent, tell the user and return
            //
            MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
            return;
        }

        IWiaItem *pWiaItem = m_pScannerItem->Item();
        if (pWiaItem)
        {
            HRESULT hr = WiaUiUtil::SystemPropertySheet( g_hInstance, m_hWnd, pWiaItem, CSimpleString(IDS_ADVANCEDPROPERTIES, g_hInstance) );
            if (S_OK == hr)
            {
                m_pScannerItem->CustomPropertyStream().AssignFromWiaItem(m_pScannerItem->Item());
                if (m_pScannerItem->CustomPropertyStream().IsValid())
                {
                    SetDefaultButton( IDC_SCANDLG_RESCAN, true );
                    SetIntentCheck(0);
                }
                else WIA_ERROR((TEXT("Unknown error: m_CustomPropertyStream is not valid")));
            }
            else if (FAILED(hr))
            {
                MessageBox( m_hWnd, CSimpleString( IDS_SCANDLG_PROPSHEETERROR, g_hInstance ), CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
                WIA_PRINTHRESULT((hr,TEXT("SystemPropertySheet failed")));
            }

        }
        else WIA_TRACE((TEXT("pWiaItem is NULL")));
    }
    else WIA_TRACE((TEXT("No current item")));
}

LRESULT CScannerAcquireDialog::OnGetMinMaxInfo( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::OnGetMinMaxInfo"));
    PMINMAXINFO pMinMaxInfo = reinterpret_cast<PMINMAXINFO>(lParam);
    if (pMinMaxInfo)
    {
        pMinMaxInfo->ptMinTrackSize.x = m_sizeMinimumWindowSize.cx;
        pMinMaxInfo->ptMinTrackSize.y = m_sizeMinimumWindowSize.cy;
    }
    return(0);
}

void CScannerAcquireDialog::SetDefaultButton( int nId, bool bFocus )
{
    static const int nButtonIds[] = {IDC_SCANDLG_RESCAN,IDC_SCANDLG_SCAN,IDCANCEL,0};
    for (int i=0;nButtonIds[i];i++)
        if (nButtonIds[i] != nId)
            SendDlgItemMessage( m_hWnd, nButtonIds[i], BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0) );
    SendMessage( m_hWnd, DM_SETDEFID, nId, 0 );
    SendDlgItemMessage( m_hWnd, nId, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE,0) );
    if (bFocus)
        SetFocus( GetDlgItem( m_hWnd, nId ) );
}

LRESULT CScannerAcquireDialog::OnScanBegin( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::OnScanBegin"));
    SetDefaultButton( IDCANCEL, true );
    CSimpleString( IDS_SCANDLG_INITIALIZING_SCANNER, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ) );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_SCAN ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_RESCAN ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_ADVANCED ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_1 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_2 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_3 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_4 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_1 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_2 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_3 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_4 ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_YOU_CAN_ALSO ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSOURCE ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSOURCE_STATIC ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE_STATIC ), FALSE );
    return(0);
}


LRESULT CScannerAcquireDialog::OnScanEnd( WPARAM wParam, LPARAM )
{
    CWaitCursor wc;
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::OnScanEnd"));
    HRESULT hr = static_cast<HRESULT>(wParam);
    if (SUCCEEDED(hr))
    {
        //
        // Only do the region detection if the user hasn't changed it manually,
        // and only if we are not in document feeder mode.
        //
        if (!InDocFeedMode() && !WiaPreviewControl_GetUserChangedSelection( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW )))
        {
            WiaPreviewControl_DetectRegions( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ) );
        }
    }
    else
    {
        CSimpleString strMessage;
        switch (hr)
        {
        case WIA_ERROR_PAPER_EMPTY:
            strMessage.LoadString( IDS_ERROR_OUTOFPAPER, g_hInstance );
            break;

        default:
            strMessage.LoadString( IDS_PREVIEWSCAN_ERROR, g_hInstance );
            break;
        }
        MessageBox( m_hWnd, strMessage, CSimpleString( IDS_SCANDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
    }
    m_bScanning = false;
    SetWindowText( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TEXT("") );
    WiaPreviewControl_SetProgress( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), FALSE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_SCAN ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_RESCAN ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_ADVANCED ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_1 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_2 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_3 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_4 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_1 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_2 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_3 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_INTENT_ICON_4 ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_YOU_CAN_ALSO ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSOURCE ), TRUE );
    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSOURCE_STATIC ), TRUE );
    if (InDocFeedMode())
    {
        EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE ), TRUE );
        EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE_STATIC ), TRUE );
    }
    SetDefaultButton( IDC_SCANDLG_SCAN, true );
    CSimpleString( IDS_CANCEL, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDCANCEL ) );
    return(0);
}


LRESULT CScannerAcquireDialog::OnScanProgress( WPARAM wParam, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::OnScanProgress"));
    switch (wParam)
    {
    case SCAN_PROGRESS_CLEAR:
        break;

    case SCAN_PROGRESS_INITIALIZING:
        {
            //
            // Start the warming up animation
            //
            WiaPreviewControl_SetProgress( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE );
        }
        break;

    case SCAN_PROGRESS_SCANNING:
        
        //
        // End the warming up animation
        //
        WiaPreviewControl_SetProgress( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), FALSE );

        //
        // Set the text that says we are now scanning
        //
        CSimpleString( IDS_SCANDLG_SCANNINGPREVIEW, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ) );

        break;

    case SCAN_PROGRESS_COMPLETE:
        break;
    }
    return(0);
}

LRESULT CScannerAcquireDialog::OnEnterSizeMove( WPARAM, LPARAM )
{
    SendDlgItemMessage( m_hWnd, IDC_SCANDLG_PREVIEW, WM_ENTERSIZEMOVE, 0, 0 );
    return(0);
}

LRESULT CScannerAcquireDialog::OnExitSizeMove( WPARAM, LPARAM )
{
    SendDlgItemMessage( m_hWnd, IDC_SCANDLG_PREVIEW, WM_EXITSIZEMOVE, 0, 0 );
    return(0);
}

LRESULT CScannerAcquireDialog::OnWiaEvent( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraAcquireDialog::OnWiaEvent"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        if (pEventMessage->EventId() == WIA_EVENT_DEVICE_DISCONNECTED)
        {
            WIA_TRACE((TEXT("Received disconnect event")));
            EndDialog( m_hWnd, WIA_ERROR_OFFLINE );
        }
        delete pEventMessage;
    }
    return HANDLED_EVENT_MESSAGE;
}

bool CScannerAcquireDialog::InDocFeedMode(void)
{
    HWND hWndPaperSource = GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSOURCE );
    if (hWndPaperSource)
    {
        LRESULT nCurSel = SendMessage( hWndPaperSource, CB_GETCURSEL, 0, 0 );
        if (nCurSel != CB_ERR)
        {
            LRESULT nPaperSource = SendMessage( hWndPaperSource, CB_GETITEMDATA, nCurSel, 0 );
            if (nPaperSource)
            {
                if (nPaperSource & FEEDER)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

void CScannerAcquireDialog::EnableControl( int nControl, BOOL bEnable )
{
    HWND hWndControl = GetDlgItem( m_hWnd, nControl );
    if (hWndControl)
    {
        BOOL bEnabled = (IsWindowEnabled( hWndControl ) != FALSE);
        if (bEnable != bEnabled)
        {
            EnableWindow( hWndControl, bEnable );
        }
    }
}

void CScannerAcquireDialog::ShowControl( int nControl, BOOL bShow )
{
    HWND hWndControl = GetDlgItem( m_hWnd, nControl );
    if (hWndControl)
    {
        ShowWindow( hWndControl, bShow ? SW_SHOW : SW_HIDE );
        if (!bShow)
        {
            EnableControl( nControl, FALSE );
        }
    }
}


void CScannerAcquireDialog::UpdatePreviewControlState(void)
{
    //
    // Assume we will be showing the preview control
    //
    BOOL bShowPreview = TRUE;

    //
    // First of all, we know we don't allow preview when we are in the dialog that doesn't support
    // preview
    //
    if (GetWindowLong(m_hWnd,GWL_ID) == IDD_SCAN_NO_PREVIEW)
    {
        bShowPreview = FALSE;
    }
    else
    {
        //
        // If we are in feeder mode, we won't show the preview UNLESS the driver explicitly tells us to do so.
        //
        LONG nCurrentPaperSource = 0;
        if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, static_cast<LONG>(nCurrentPaperSource)))
        {
            if (FEEDER & nCurrentPaperSource)
            {
                //
                // Remove the tabstop setting from the preview control if we are in feeder mode
                //
                SetWindowLongPtr( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), GWL_STYLE, GetWindowLongPtr( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), GWL_STYLE ) & ~WS_TABSTOP );

                LONG nShowPreviewControl = WIA_DONT_SHOW_PREVIEW_CONTROL;
                if (PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_SHOW_PREVIEW_CONTROL, static_cast<LONG>(nShowPreviewControl)))
                {
                    if (WIA_DONT_SHOW_PREVIEW_CONTROL == nShowPreviewControl)
                    {
                        bShowPreview = FALSE;
                    }
                }
                else
                {
                    bShowPreview = FALSE;
                }
            }
            else
            {
                //
                // Add the tabstop setting to the preview control if we are in flatbed mode
                //
                SetWindowLongPtr( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), GWL_STYLE, GetWindowLongPtr( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), GWL_STYLE ) | WS_TABSTOP );
            }
        }
    }


    //
    // Update the preview related controls
    //

    WIA_TRACE((TEXT("bShowPreview = %d"), bShowPreview ));
    if (bShowPreview)
    {
        ShowControl( IDC_SCANDLG_PREVIEW, TRUE );
        ShowControl( IDC_SCANDLG_RESCAN, TRUE );
        EnableControl( IDC_SCANDLG_PREVIEW, TRUE );
        EnableControl( IDC_SCANDLG_RESCAN, TRUE );
    }
    else
    {
        ShowControl( IDC_SCANDLG_PREVIEW, FALSE );
        ShowControl( IDC_SCANDLG_RESCAN, FALSE );
    }
}

void CScannerAcquireDialog::HandlePaperSourceSelChange(void)
{
    HWND hWndPaperSource = GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSOURCE );
    if (hWndPaperSource)
    {
        LRESULT nCurSel = SendMessage( hWndPaperSource, CB_GETCURSEL, 0, 0 );
        if (nCurSel != CB_ERR)
        {
            LRESULT nPaperSource = SendMessage( hWndPaperSource, CB_GETITEMDATA, nCurSel, 0 );
            if (nPaperSource)
            {
                PropStorageHelpers::SetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, static_cast<LONG>(nPaperSource) );

                if (nPaperSource & FLATBED)
                {
                    //
                    // Adjust the preview control settings for allowing region selection
                    //
                    WiaPreviewControl_SetDefAspectRatio( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), &m_sizeFlatbed );
                    WiaPreviewControl_DisableSelection( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), FALSE );
                    WiaPreviewControl_SetBorderStyle( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE, PS_DOT, 0 );
                    WiaPreviewControl_SetHandleSize( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE, 6 );

                    //
                    // Disable the paper size controls
                    //
                    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE ), FALSE );
                    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE_STATIC ), FALSE );
                }
                else
                {
                    //
                    // Adjust the preview control settings for displaying paper selection
                    //
                    WiaPreviewControl_SetDefAspectRatio( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), &m_sizeDocfeed );
                    WiaPreviewControl_DisableSelection( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE );
                    WiaPreviewControl_SetBorderStyle( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE, PS_SOLID, 0 );
                    WiaPreviewControl_SetHandleSize( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE, 0 );

                    //
                    // Enable the paper size controls
                    //
                    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE ), TRUE );
                    EnableWindow( GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE_STATIC ), TRUE );

                    //
                    // Update the region selection feedback
                    //
                    HandlePaperSizeSelChange();
                }
            }
        }
        UpdatePreviewControlState();
    }
}


void CScannerAcquireDialog::HandlePaperSizeSelChange(void)
{
    HWND hWndPaperSize = GetDlgItem( m_hWnd, IDC_SCANDLG_PAPERSIZE );
    if (InDocFeedMode() && hWndPaperSize)
    {
        LRESULT nCurSel = SendMessage( hWndPaperSize, CB_GETCURSEL, 0, 0 );
        if (nCurSel != CB_ERR)
        {
            LRESULT nPaperSizeIndex = SendMessage( hWndPaperSize, CB_GETITEMDATA, nCurSel, 0 );
            POINT ptOrigin = { 0, 0 };
            SIZE sizeExtent = { m_pPaperSizes[nPaperSizeIndex].nWidth, m_pPaperSizes[nPaperSizeIndex].nHeight };

            if (!sizeExtent.cx)
            {
                sizeExtent.cx = m_sizeDocfeed.cx;
            }
            if (!sizeExtent.cy)
            {
                sizeExtent.cy = m_sizeDocfeed.cy;
            }

            LONG nSheetFeederRegistration;
            if (!PropStorageHelpers::GetProperty( m_pDeviceDialogData->pIWiaItemRoot, WIA_DPS_SHEET_FEEDER_REGISTRATION, nSheetFeederRegistration ))
            {
                nSheetFeederRegistration = LEFT_JUSTIFIED;
            }
            if (nSheetFeederRegistration == CENTERED)
            {
                ptOrigin.x = (m_sizeDocfeed.cx - sizeExtent.cx) / 2;
            }
            else if (nSheetFeederRegistration == RIGHT_JUSTIFIED)
            {
                ptOrigin.x = m_sizeDocfeed.cx - sizeExtent.cx;
            }
            WiaPreviewControl_SetResolution( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), &m_sizeDocfeed );
            WiaPreviewControl_SetSelOrigin( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), 0, FALSE, &ptOrigin );
            WiaPreviewControl_SetSelExtent( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), 0, FALSE, &sizeExtent );
        }
    }
}

void CScannerAcquireDialog::OnPaperSourceSelChange( WPARAM, LPARAM )
{
    HandlePaperSourceSelChange();
}

void CScannerAcquireDialog::OnPaperSizeSelChange( WPARAM, LPARAM )
{
    HandlePaperSizeSelChange();
}


LRESULT CScannerAcquireDialog::OnHelp( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmHelp( wParam, lParam, g_HelpIDs );
}

LRESULT CScannerAcquireDialog::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmContextMenu( wParam, lParam, g_HelpIDs );
}

LRESULT CScannerAcquireDialog::OnDestroy( WPARAM, LPARAM )
{
    for (int i=0;i<gs_nCountIntentRadioButtonIconPairs;i++)
    {
        HICON hIcon = reinterpret_cast<HICON>(SendDlgItemMessage( m_hWnd, g_IntentRadioButtonIconPairs[i].nIconId, STM_SETICON, 0, 0 ));
        if (hIcon)
        {
            DestroyIcon(hIcon);
        }
    }
    return 0;
}

LRESULT CScannerAcquireDialog::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE, TRUE, GetSysColor(COLOR_WINDOW) );
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_SCANDLG_PREVIEW ), TRUE, FALSE, GetSysColor(COLOR_WINDOW) );
    SendDlgItemMessage( m_hWnd, IDC_SCANDLG_ADVANCED, WM_SYSCOLORCHANGE, wParam, lParam );
    return 0;
}

LRESULT CScannerAcquireDialog::OnCommand( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CScannerAcquireDialog::OnCommand"));
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND( IDC_SCANDLG_RESCAN, OnRescan );
        SC_HANDLE_COMMAND( IDC_SCANDLG_SCAN, OnScan );
        SC_HANDLE_COMMAND( IDCANCEL, OnCancel );
        SC_HANDLE_COMMAND( IDC_SCANDLG_ADVANCED, OnAdvanced );
        SC_HANDLE_COMMAND( IDC_INTENT_1,OnIntentChange );
        SC_HANDLE_COMMAND( IDC_INTENT_2,OnIntentChange );
        SC_HANDLE_COMMAND( IDC_INTENT_3,OnIntentChange );
        SC_HANDLE_COMMAND( IDC_INTENT_4,OnIntentChange );
        SC_HANDLE_COMMAND_NOTIFY( PWN_SELCHANGE, IDC_SCANDLG_PREVIEW, OnPreviewSelChange );
        SC_HANDLE_COMMAND_NOTIFY( CBN_SELCHANGE, IDC_SCANDLG_PAPERSOURCE, OnPaperSourceSelChange );
        SC_HANDLE_COMMAND_NOTIFY( CBN_SELCHANGE, IDC_SCANDLG_PAPERSIZE, OnPaperSizeSelChange );
    }
    SC_END_COMMAND_HANDLERS();
}

INT_PTR CALLBACK CScannerAcquireDialog::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CScannerAcquireDialog)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_SIZE, OnSize );
        SC_HANDLE_DIALOG_MESSAGE( WM_GETMINMAXINFO, OnGetMinMaxInfo );
        SC_HANDLE_DIALOG_MESSAGE( WM_ENTERSIZEMOVE, OnEnterSizeMove );
        SC_HANDLE_DIALOG_MESSAGE( WM_EXITSIZEMOVE, OnExitSizeMove );
        SC_HANDLE_DIALOG_MESSAGE( WM_HELP, OnHelp );
        SC_HANDLE_DIALOG_MESSAGE( WM_CONTEXTMENU, OnContextMenu );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( PWM_WIAEVENT, OnWiaEvent );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE(m_nMsgScanBegin,OnScanBegin);
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE(m_nMsgScanEnd,OnScanEnd);
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE(m_nMsgScanProgress,OnScanProgress);
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for scan dialog
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <atlbase.h>
#include <commctrl.h>
#include <objbase.h>
#include <propidl.h>
#include <wia.h>

#include "scanlib.rh"
#include "wiadebug.h"
#include "wianew.h"
#include "wiadevd.h"

#include "pshelper.h"
#include "uicommon.h"
#include "miscutil.h"

#include "simcrack.h"
#include "simbstr.h"
#include "simevent.h"

#include "scandlg.h"
#include "multistr.h"
#include "scanntfy.h"
#include "pviewids.h"
#include "dlgunits.h"
#include "proparry.h"
#include "scanitem.h"
#include "scanproc.h"
#include "sitemlst.h"
#include "waitcurs.h"
#include "dbgtimer.h"
#include <shfusion.h>

extern HINSTANCE g_hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\scandlg.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANDLG.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Scan dialog
 *
 *******************************************************************************/
#ifndef _SCANDLG_H_INCLUDED
#define _SCANDLG_H_INCLUDED

#include "wiadevd.h"
#include "scanitem.h"
#include "propstrm.h"
#include "sitemlst.h"
#include "itranhlp.h"

class CScannerAcquireDialog
{
private:
    HWND                m_hWnd;
    DEVICEDIALOGDATA   *m_pDeviceDialogData;
    CScanItemList       m_ScanItemList;
    SIZE                m_sizeFlatbed;
    SIZE                m_sizeDocfeed;
    SIZE                m_sizeMinimumWindowSize;
    UINT                m_nMsgScanBegin;
    UINT                m_nMsgScanEnd;
    UINT                m_nMsgScanProgress;
    bool                m_bScanning;
    HFONT               m_hBigTitleFont;
    HICON               m_hIconLarge;
    HICON               m_hIconSmall;
    CComPtr<IUnknown>   m_DisconnectEvent;
    CScannerItem       *m_pScannerItem;
    CWiaPaperSize      *m_pPaperSizes;
    UINT                m_nPaperSizeCount;
                                     
    bool                m_bHasFlatBed;
    bool                m_bHasDocFeed;
    HBITMAP             m_hBitmapDefaultPreviewBitmap;

private:
    // No implementation
    CScannerAcquireDialog(void);
    CScannerAcquireDialog( const CScannerAcquireDialog & );
    CScannerAcquireDialog &operator=( const CScannerAcquireDialog & );

private:
    // Constructor, destructor
    explicit CScannerAcquireDialog( HWND hwnd );  // Only implemented constructor
    virtual ~CScannerAcquireDialog(void);

    // Helpers
    void PopulateIntentList(void);
    void SetDefaultButton( int nId, bool bFocus );
    bool ApplyCurrentIntent(void);
    void SetIntentCheck( LONG nIntent );
    void PopulateDocumentHandling(void);
    void PopulatePageSize(void);
    void HandlePaperSourceSelChange(void);
    void HandlePaperSizeSelChange(void);
    bool InDocFeedMode(void);
    void UpdatePreviewControlState(void);
    void EnableControl( int nControl, BOOL bEnable );
    void ShowControl( int nControl, BOOL bShow );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnGetMinMaxInfo( WPARAM, LPARAM );
    LRESULT OnSize( WPARAM, LPARAM );
    LRESULT OnScanBegin( WPARAM, LPARAM );
    LRESULT OnScanEnd( WPARAM, LPARAM );
    LRESULT OnScanProgress( WPARAM, LPARAM );
    LRESULT OnEnterSizeMove( WPARAM, LPARAM );
    LRESULT OnExitSizeMove( WPARAM, LPARAM );
    LRESULT OnWiaEvent( WPARAM, LPARAM );
    LRESULT OnHelp( WPARAM, LPARAM );
    LRESULT OnContextMenu( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );

    // WM_COMMAND handlers
    void OnIntentChange( WPARAM, LPARAM );
    void OnPreviewSelChange( WPARAM, LPARAM );
    void OnRescan( WPARAM, LPARAM );
    void OnScan( WPARAM, LPARAM );
    void OnCancel( WPARAM, LPARAM );
    void OnAdvanced( WPARAM, LPARAM );
    void OnPaperSourceSelChange( WPARAM, LPARAM );
    void OnPaperSizeSelChange( WPARAM, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\scanntfy.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANNTFY.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Scan notification messages
 *
 *******************************************************************************/
#ifndef __SCANNTFY_H_INCLUDED
#define __SCANNTFY_H_INCLUDED

// Scan progress notification messages
#define SCAN_NOTIFYBEGINSCAN TEXT("ScanNotifyBeginScan")
#define SCAN_NOTIFYENDSCAN   TEXT("ScanNotifyEndScan")
#define SCAN_NOTIFYPROGRESS  TEXT("ScanNotifyProgress")

#define SCAN_PROGRESS_CLEAR         0
#define SCAN_PROGRESS_INITIALIZING  1
#define SCAN_PROGRESS_SCANNING      2
#define SCAN_PROGRESS_COMPLETE      3
#define SCAN_PROGRESS_ERROR         4

// Menu item ids
#define SCAN_SCAN            TEXT("ScanScan")
#define SCAN_PREVIEW         TEXT("ScanPreview")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\scanproc.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANPROC.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Scan Thread
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop

// Constructor
CScanPreviewThread::CScanPreviewThread(
                                      DWORD dwIWiaItemCookie,                   // specifies the entry in the global interface table
                                      HWND hwndPreview,                         // handle to the preview window
                                      HWND hwndNotify,                          // handle to the window that receives notifications
                                      const POINT &ptOrigin,                    // Origin
                                      const SIZE &sizeResolution,               // Resolution
                                      const SIZE &sizeExtent,                   // Extent
                                      const CSimpleEvent &CancelEvent           // Cancel event name
                                      )
  : m_dwIWiaItemCookie(dwIWiaItemCookie),
    m_hwndPreview(hwndPreview),
    m_hwndNotify(hwndNotify),
    m_ptOrigin(ptOrigin),
    m_sizeResolution(sizeResolution),
    m_sizeExtent(sizeExtent),
    m_nMsgBegin(RegisterWindowMessage(SCAN_NOTIFYBEGINSCAN)),
    m_nMsgEnd(RegisterWindowMessage(SCAN_NOTIFYENDSCAN)),
    m_nMsgProgress(RegisterWindowMessage(SCAN_NOTIFYPROGRESS)),
    m_sCancelEvent(CancelEvent),
    m_bFirstTransfer(true),
    m_nImageSize(0)
{
}

// Destructor
CScanPreviewThread::~CScanPreviewThread(void)
{
}


HRESULT _stdcall CScanPreviewThread::BandedDataCallback( LONG lMessage,
                                                         LONG lStatus,
                                                         LONG lPercentComplete,
                                                         LONG lOffset,
                                                         LONG lLength,
                                                         LONG lReserved,
                                                         LONG lResLength,
                                                         BYTE *pbBuffer )
{
    WIA_TRACE((TEXT("ImageDataCallback: lMessage: %d, lStatus: %d, lPercentComplete: %d, lOffset: %d, lLength: %d, lReserved: %d"), lMessage, lStatus, lPercentComplete, lOffset, lLength, lReserved ));
    HRESULT hr = S_OK;
    if (!m_sCancelEvent.Signalled())
    {
        switch (lMessage)
        {
        case IT_MSG_DATA_HEADER:
            {
                m_bFirstTransfer = true;
                break;
            } // IT_MSG_DATA_HEADER

        case IT_MSG_DATA:
            if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT)
            {
                if (m_bFirstTransfer)
                {
                    // Assuming there is no way we could get a lLength smaller than the image header size
                    m_bFirstTransfer = false;
                    m_sImageData.Initialize( reinterpret_cast<PBITMAPINFO>(pbBuffer) );
                    lLength -= WiaUiUtil::GetBmiSize(reinterpret_cast<PBITMAPINFO>(pbBuffer));
                    lOffset += WiaUiUtil::GetBmiSize(reinterpret_cast<PBITMAPINFO>(pbBuffer));
                }
                if (SUCCEEDED(hr))
                {
                    if (lLength)
                    {
                        // Figure out which line we are on
                        int nCurrentLine = (lOffset - m_sImageData.GetHeaderLength())/m_sImageData.GetUnpackedWidthInBytes();

                        // BUGBUG: This should be an even number of lines.  If it isn't, things are going to get messed up
                        int nLineCount = lLength / m_sImageData.GetUnpackedWidthInBytes();

                        // Copy the data to our bitmap
                        m_sImageData.SetUnpackedData( pbBuffer, nCurrentLine, nLineCount );

                        // Tell the preview window to repaint the DIB
                        if (IsWindow(m_hwndPreview))
                        {
                            PostMessage( m_hwndPreview, PWM_SETBITMAP, MAKEWPARAM(1,1), (LPARAM)m_sImageData.Bitmap() );
                        }

                        // Tell the notify window we've made progress
                        if (IsWindow(m_hwndNotify))
                        {
                            PostMessage( m_hwndNotify, m_nMsgProgress, SCAN_PROGRESS_SCANNING, lPercentComplete );
                        }
                    }
                }
            } // IT_STATUS_TRANSFER_TO_CLIENT
            break;

        case IT_MSG_STATUS:
            {
            } // IT_MSG_STATUS
            break;

        case IT_MSG_TERMINATION:
            {
            } // IT_MSG_TERMINATION
            break;

        default:
            WIA_ERROR((TEXT("ImageDataCallback, unknown lMessage: %d"), lMessage ));
            break;
        }
    }
    else hr = S_FALSE;
    return(hr);
}


// The actual thread proc for this thread
DWORD CScanPreviewThread::ThreadProc( LPVOID pParam )
{
    DWORD dwResult = 0;
    CScanPreviewThread *This = (CScanPreviewThread *)pParam;
    if (This)
    {
        WIA_TRACE((TEXT("Beginning scan")));
        dwResult = (DWORD)This->Scan();
        WIA_TRACE((TEXT("Ending scan")));
        delete This;
    }
    return(dwResult);
}


// Returns a handle to the created thread
HANDLE CScanPreviewThread::Scan(
                               DWORD dwIWiaItemCookie,                  // specifies the entry in the global interface table
                               HWND hwndPreview,                        // handle to the preview window
                               HWND hwndNotify,                         // handle to the window that receives notifications
                               const POINT &ptOrigin,                   // Origin
                               const SIZE &sizeResolution,              // Resolution
                               const SIZE &sizeExtent,                  // Extent
                               const CSimpleEvent &CancelEvent         // Cancel event name
                               )
{
    CScanPreviewThread *scanThread = new CScanPreviewThread( dwIWiaItemCookie, hwndPreview, hwndNotify, ptOrigin, sizeResolution, sizeExtent, CancelEvent );
    if (scanThread)
    {
        DWORD dwThreadId;
        return CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, scanThread, 0, &dwThreadId );
    }
    return NULL;
}

HRESULT CScanPreviewThread::ScanBandedTransfer( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CScanPreviewThread::ScanBandedTransfer"));
    CComPtr<IWiaDataTransfer> pWiaDataTransfer;
    WIA_DATA_TRANSFER_INFO wiaDataTransInfo;
    HRESULT hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void**)&pWiaDataTransfer);
    if (SUCCEEDED(hr))
    {
        CComPtr<IWiaDataCallback> pWiaDataCallback;
        hr = this->QueryInterface(IID_IWiaDataCallback,(void **)&pWiaDataCallback);
        if (SUCCEEDED(hr))
        {
            LONG nItemSize = 0;
            if (PropStorageHelpers::GetProperty( pIWiaItem, WIA_IPA_ITEM_SIZE, nItemSize ))
            {
                ZeroMemory(&wiaDataTransInfo, sizeof(WIA_DATA_TRANSFER_INFO));
                wiaDataTransInfo.ulSize = sizeof(WIA_DATA_TRANSFER_INFO);
                wiaDataTransInfo.ulBufferSize = WiaUiUtil::Max<ULONG>( nItemSize / 8, (sizeof(BITMAPINFO)+sizeof(RGBQUAD)*255) );
                hr = pWiaDataTransfer->idtGetBandedData( &wiaDataTransInfo, pWiaDataCallback );
                if (FAILED(hr))
                {
                    WIA_PRINTHRESULT((hr,TEXT("CScanPreviewThread::Scan, itGetImage failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("CScanPreviewThread::Scan, unable to get image size")));
                hr = E_FAIL;
            }
        }
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("CScanPreviewThread::Scan, QI of IID_IImageTransfer failed")));
    }
    WIA_TRACE((TEXT("End CScanPreviewThread::ScanBandedTransfer")));
    return(hr);
}

/*
 * The worker which does the actual scan
 */
bool CScanPreviewThread::Scan(void)
{
    WIA_PUSHFUNCTION(TEXT("CScanPreviewThread::Scan"));
    if (IsWindow(m_hwndNotify))
    {
        PostMessage( m_hwndNotify, m_nMsgBegin, 0, 0 );
    }
    if (IsWindow(m_hwndNotify))
    {
        PostMessage( m_hwndNotify, m_nMsgProgress, SCAN_PROGRESS_INITIALIZING, 0 );
    }
    HRESULT hr = CoInitialize( NULL );
    if (SUCCEEDED(hr))
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGlobalInterfaceTable );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            pGlobalInterfaceTable->GetInterfaceFromGlobal( m_dwIWiaItemCookie, IID_IWiaItem, (LPVOID*)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
                if (PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPS_CUR_INTENT, (LONG)WIA_INTENT_NONE))
                {
                    CPropertyStream SavedProperties;
                    hr = SavedProperties.AssignFromWiaItem(pIWiaItem);
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Set the new properties
                        //
                        if (PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPS_XRES, m_sizeResolution.cx ) &&
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPS_YRES, m_sizeResolution.cy ) &&
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPS_XPOS, m_ptOrigin.x) &&
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPS_YPOS, m_ptOrigin.y) &&
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPS_XEXTENT, m_sizeExtent.cx ) &&
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPS_YEXTENT, m_sizeExtent.cy ) &&
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPA_FORMAT, WiaImgFmt_MEMORYBMP ) &&
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_IPA_TYMED, (LONG)TYMED_CALLBACK ))
                        {
                            //
                            // Set the preview property.  Ignore failure (it is an optional property)
                            //
                            PropStorageHelpers::SetProperty( pIWiaItem, WIA_DPS_PREVIEW, 1 );

                            CPropertyStorageArray(pIWiaItem).Dump();
                            WIA_TRACE((TEXT("SCANPROC.CPP: Making sure pIWiaItem is not NULL")));
                            // Make sure pIWiaItem is not NULL
                            if (pIWiaItem)
                            {
                                WIA_TRACE((TEXT("SCANPROC.CPP: Attempting banded transfer")));
                                hr = ScanBandedTransfer( pIWiaItem );
                                if (SUCCEEDED(hr))
                                {
                                    if (IsWindow(m_hwndNotify))
                                        PostMessage( m_hwndNotify, m_nMsgProgress, SCAN_PROGRESS_SCANNING, 100 );
                                    if (IsWindow(m_hwndPreview))
                                        PostMessage( m_hwndPreview, PWM_SETBITMAP, MAKEWPARAM(1,0), (LPARAM)m_sImageData.DetachBitmap() );
                                }
                                else
                                {
                                    WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: ScanBandedTransfer failed, attempting IDataObject transfer")));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("SCANPROC.CPP: pIWiaItem was null")));
                                hr = MAKE_HRESULT(3,FACILITY_WIN32,ERROR_INVALID_FUNCTION);
                            }
                        }
                        else
                        {
                            WIA_ERROR((TEXT("SCANPROC.CPP: Error setting scanner properties")));
                            hr = MAKE_HRESULT(3,FACILITY_WIN32,ERROR_INVALID_FUNCTION);
                        }
                        // Restore the saved properties
                        SavedProperties.ApplyToWiaItem(pIWiaItem);
                    }
                    else
                    {
                        WIA_ERROR((TEXT("SCANPROC.CPP: Error saving scanner properties")));
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("SCANPROC.CPP: Unable to clear intent")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: Unable to unmarshall IWiaItem * from global interface table" )));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: Unable to QI global interface table" )));
        }
        CoUninitialize();
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: CoInitialize failed" )));
    }
    if (IsWindow(m_hwndNotify))
        PostMessage( m_hwndNotify, m_nMsgEnd, hr, 0 );
    if (IsWindow(m_hwndNotify))
        PostMessage( m_hwndNotify, m_nMsgProgress, SCAN_PROGRESS_COMPLETE, 0 );
    return(SUCCEEDED(hr));
}


// COM stuff
HRESULT _stdcall CScanPreviewThread::QueryInterface( const IID& riid, void** ppvObject )
{
    if (IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObject = static_cast<IWiaDataCallback*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaDataCallback ))
    {
        *ppvObject = static_cast<IWiaDataCallback*>(this);
    }
    else
    {
        *ppvObject = NULL;
        return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
    return(S_OK);
}

ULONG _stdcall CScanPreviewThread::AddRef()
{
    return(1);
}

ULONG _stdcall CScanPreviewThread::Release()
{
    return(1);
}


/*************************************************************************************************************************

 CScanToFileThread

 Scans to a file

**************************************************************************************************************************/


CScanToFileThread::CScanToFileThread(
                                    DWORD dwIWiaItemCookie,                   // specifies the entry in the global interface table
                                    HWND hwndNotify,                          // handle to the window that receives notifications
                                    GUID guidFormat,
                                    const CSimpleStringWide &strFilename          // Filename to scan to
                                    )
  : m_dwIWiaItemCookie(dwIWiaItemCookie),
    m_hwndNotify(hwndNotify),
    m_nMsgBegin(RegisterWindowMessage(SCAN_NOTIFYBEGINSCAN)),
    m_nMsgEnd(RegisterWindowMessage(SCAN_NOTIFYENDSCAN)),
    m_nMsgProgress(RegisterWindowMessage(SCAN_NOTIFYPROGRESS)),
    m_guidFormat(guidFormat),
    m_strFilename(strFilename)
{
}


// The actual thread proc for this thread
DWORD CScanToFileThread::ThreadProc( LPVOID pParam )
{
    DWORD dwResult = 0;
    CScanToFileThread *This = (CScanToFileThread *)pParam;
    if (This)
    {
        WIA_TRACE((TEXT("Beginning scan")));
        dwResult = (DWORD)This->Scan();
        WIA_TRACE((TEXT("Ending scan")));
        delete This;
    }
    return(dwResult);
}


// Returns a handle to the created thread
HANDLE CScanToFileThread::Scan(
                              DWORD dwIWiaItemCookie,                     // specifies the entry in the global interface table
                              HWND hwndNotify,                         // handle to the window that receives notifications
                              GUID guidFormat,
                              const CSimpleStringWide &strFilename          // Filename to save to
                              )
{
    CScanToFileThread *scanThread = new CScanToFileThread( dwIWiaItemCookie, hwndNotify, guidFormat, strFilename );
    if (scanThread)
    {
        DWORD dwThreadId;
        return(::CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, scanThread, 0, &dwThreadId ));
    }
    return(NULL);
}

CScanToFileThread::~CScanToFileThread(void)
{
}


/*
 * The worker which does the actual scan
 */
bool CScanToFileThread::Scan(void)
{
    WIA_PUSHFUNCTION(TEXT("CScanToFileThread::Scan"));
    if (IsWindow(m_hwndNotify))
        PostMessage( m_hwndNotify, m_nMsgBegin, 0, 0 );
    HRESULT hr = CoInitialize( NULL );
    if (SUCCEEDED(hr))
    {
        CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
        hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGlobalInterfaceTable );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pIWiaItem;
            WIA_TRACE((TEXT("SCANPROC.CPP: Calling GetInterfaceFromGlobal(%08X) for IID_IWiaItem"),m_dwIWiaItemCookie));
            pGlobalInterfaceTable->GetInterfaceFromGlobal( m_dwIWiaItemCookie, IID_IWiaItem, (LPVOID*)&pIWiaItem );
            if (SUCCEEDED(hr))
            {
                CComPtr<IWiaTransferHelper> pWiaTransferHelper;
                hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaTransferHelper, (void**)&pWiaTransferHelper );
                if (SUCCEEDED(hr))
                {
                    hr = pWiaTransferHelper->TransferItemFile( pIWiaItem, m_hwndNotify, 0, m_guidFormat, m_strFilename.String(), NULL, TYMED_FILE );
                    if (!SUCCEEDED(hr))
                    {
                        WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: pWiaTransferHelper->TransferItemFile failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: CoCreateInstance on IID_IWiaTransferHelper failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: Unable to unmarshall IWiaItem * from global interface table" )));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: Unable to QI global interface table" )));
        }
        CoUninitialize();
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("SCANPROC.CPP: CoInitialize failed" )));
    }
    if (IsWindow(m_hwndNotify))
        PostMessage( m_hwndNotify, m_nMsgEnd, hr, 0 );
    return(SUCCEEDED(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\scanproc.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANPROC.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Scan threads
 *
 *******************************************************************************/
#ifndef __SCANPROC_H_INCLUDED
#define __SCANPROC_H_INCLUDED

#include "scanntfy.h" // Registered windows messages names
#include "memdib.h"
#include "simevent.h"
#include "itranhlp.h"
#include "wiadevdp.h"

class CScanPreviewThread : public IWiaDataCallback
{
private:
    DWORD                  m_dwIWiaItemCookie;
    HWND                   m_hwndPreview;
    HWND                   m_hwndNotify;
    POINT                  m_ptOrigin;
    SIZE                   m_sizeResolution;
    SIZE                   m_sizeExtent;
    UINT                   m_nMsgBegin;
    UINT                   m_nMsgEnd;
    UINT                   m_nMsgProgress;
    CMemoryDib             m_sImageData;
    CSimpleEvent           m_sCancelEvent;

    bool                   m_bFirstTransfer;
    UINT                   m_nImageSize;

private:
    // No implementation
    CScanPreviewThread( const CScanPreviewThread & );
    CScanPreviewThread(void);
    CScanPreviewThread &operator=( const CScanPreviewThread & );
private:

    // These interfaces are all private to make sure that nobody tries to instantiate this class directly

    // Constructor
    CScanPreviewThread(
               DWORD dwIWiaItemCookie,                   // specifies the entry in the global interface table
               HWND hwndPreview,                         // handle to the preview window
               HWND hwndNotify,                          // handle to the window that receives notifications
               const POINT &ptOrigin,                    // Origin
               const SIZE &sizeResolution,               // Resolution
               const SIZE &sizeExtent,                   // Extent
               const CSimpleEvent &CancelEvent           // Cancel event
               );
    // Destructor
    ~CScanPreviewThread(void);


    static DWORD ThreadProc( LPVOID pParam );
    bool Scan(void);
    HRESULT ScanBandedTransfer( IWiaItem *pIWiaItem );
public:
    static HANDLE Scan(
                      DWORD dwIWiaItemCookie,                  // specifies the entry in the global interface table
                      HWND hwndPreview,                        // handle to the preview window
                      HWND hwndNotify,                         // handle to the window that receives notifications
                      const POINT &ptOrigin,                   // Origin
                      const SIZE &sizeResolution,              // Resolution
                      const SIZE &sizeExtent,                  // Extent
                      const CSimpleEvent &CancelEvent          // Cancel event name
                      );

public:
    // IUnknown
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObject );
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IWiaDataCallback
    STDMETHODIMP BandedDataCallback( LONG, LONG, LONG, LONG, LONG, LONG, LONG, PBYTE );
};


class CScanToFileThread
{
private:
    DWORD                  m_dwIWiaItemCookie;
    HWND                   m_hwndNotify;
    UINT                   m_nMsgBegin, m_nMsgEnd, m_nMsgProgress;
    GUID                   m_guidFormat;
    CSimpleStringWide      m_strFilename;

private:
    // No implementation
    CScanToFileThread( const CScanToFileThread & );
    CScanToFileThread(void);
    CScanToFileThread &operator=( const CScanToFileThread & );
private:
    // These interfaces are all private to make sure that nobody tries to instantiate this class directly
    CScanToFileThread(
               DWORD dwIWiaItemCookie,                    // specifies the entry in the global interface table
               HWND  hwndNotify,                          // handle to the window that receives notifications
               GUID  guidFormat,                          // Image format
               const CSimpleStringWide &strFilename       // Filename to save to
               );
    ~CScanToFileThread(void);

    static DWORD ThreadProc( LPVOID pParam );
    bool Scan(void);
public:
    static HANDLE Scan(
                      DWORD dwIWiaItemCookie,                   // specifies the entry in the global interface table
                      HWND hwndNotify,                          // handle to the window that receives notifications
                      GUID guidFormat,                          // Image format
                      const CSimpleStringWide &strFilename      // Filename to save to
                      );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\scanitem.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANITEM.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: WIA Item wrapper for scanner items
 *
 *******************************************************************************/
#ifndef __SCANITEM_H_INCLUDED
#define __SCANITEM_H_INCLUDED

#include "simevent.h"
#include "propstrm.h"

class CScannerItem
{
private:
    CComPtr<IWiaItem>       m_pIWiaItem;         // Item COM pointer
    SIZE                    m_AspectRatio;
    DWORD                   m_dwIWiaItemCookie;  // Global interface table entry
    CSimpleEvent            m_CancelEvent;
    CPropertyStream         m_SavedPropertyStream;
    CPropertyStream         m_CustomPropertyStream;

public:
    CScannerItem( IWiaItem *pIWiaItem );
    CScannerItem( void );
    CScannerItem(const CScannerItem &other);
    ~CScannerItem(void);
    CComPtr<IWiaItem> Item(void) const;
    SIZE AspectRatio(void) const;
    DWORD Cookie(void) const;
    CScannerItem &Assign( const CScannerItem &other );
    bool operator==( const CScannerItem & );
    CScannerItem &operator=( const CScannerItem &other );
    HRESULT Destroy(void);
    HRESULT Initialize( IWiaItem *pIWiaItem );
    bool GetInitialBedSize( SIZE &sizeBed );
    bool GetAspectRatio( SIZE &sizeAspectRatio );
    bool ApplyCurrentPreviewWindowSettings( HWND hWndPreview );
    bool GetFullResolution( const SIZE &sizeResultionPerInch, SIZE &sizeRes );
    void Cancel(void);
    bool CalculatePreviewResolution( SIZE &sizeResolution );
    HANDLE Scan( HWND hWndNotify, HWND hWndPreview );
    HANDLE Scan( HWND hWndNotify, GUID guidFormat, const CSimpleStringWide &strFilename );
    bool SetIntent( int nIntent );
    CSimpleEvent CancelEvent(void) const;

    CPropertyStream &SavedPropertyStream(void)
    {
        return m_SavedPropertyStream;
    }
    const CPropertyStream &SavedPropertyStream(void) const
    {
        return m_SavedPropertyStream;
    }

    CPropertyStream &CustomPropertyStream(void)
    {
        return m_CustomPropertyStream;
    }
    const CPropertyStream &CustomPropertyStream(void) const
    {
        return m_CustomPropertyStream;
    }


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\scanitem.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANITEM.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <vwiaset.h>

CScannerItem::CScannerItem(void)
  : m_dwIWiaItemCookie(0)
{
    m_AspectRatio.cx = m_AspectRatio.cy = 0;
}


CScannerItem::CScannerItem( const CScannerItem &other )
  : m_dwIWiaItemCookie(0)
{
    m_AspectRatio.cx = m_AspectRatio.cy = 0;
    Assign(other);
}

CScannerItem::CScannerItem( IWiaItem *pIWiaItem )
  : m_dwIWiaItemCookie(0)
{
    m_AspectRatio.cx = m_AspectRatio.cy = 0;
    Initialize( pIWiaItem );
}


CScannerItem::~CScannerItem(void)
{
    Destroy();
}


CComPtr<IWiaItem> CScannerItem::Item(void) const
{
    return(m_pIWiaItem);
}


SIZE CScannerItem::AspectRatio(void) const
{
    return(m_AspectRatio);
}


DWORD CScannerItem::Cookie(void) const
{
    return(m_dwIWiaItemCookie);
}


CScannerItem &CScannerItem::Assign( const CScannerItem &other )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::Assign"));
    if (&other == this)
        return(*this);
    Initialize( other.Item() );
    return(*this);
}

bool CScannerItem::operator==( const CScannerItem &other )
{
    return(m_pIWiaItem.p == other.Item().p);
}


CScannerItem &CScannerItem::operator=( const CScannerItem &other )
{
    return(Assign(other));
}


HRESULT CScannerItem::Destroy(void)
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::Destroy"));
    HRESULT hr = E_FAIL;
    if (m_dwIWiaItemCookie)
    {
        CComPtr<IGlobalInterfaceTable>  pGlobalInterfaceTable;
        hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGlobalInterfaceTable );
        if (SUCCEEDED(hr))
        {
            WIA_TRACE((TEXT("Calling RevokeInterfaceFromGlobal on %08X"), m_dwIWiaItemCookie ));
            hr = pGlobalInterfaceTable->RevokeInterfaceFromGlobal( m_dwIWiaItemCookie );
        }
        m_dwIWiaItemCookie = 0;
    }
    m_pIWiaItem = NULL;
    return(hr);
}


HRESULT CScannerItem::Initialize( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::Initialize"));
    Destroy();
    HRESULT             hr = E_FAIL;
    IWiaPropertyStorage *pIWiaPropertyStorage;

    if (pIWiaItem)
    {
        m_pIWiaItem = pIWiaItem;
        CComPtr<IGlobalInterfaceTable>  pGlobalInterfaceTable;
        hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (void **)&pGlobalInterfaceTable );
        if (SUCCEEDED(hr))
        {
            hr = pGlobalInterfaceTable->RegisterInterfaceInGlobal( m_pIWiaItem, IID_IWiaItem, &m_dwIWiaItemCookie );
            if (SUCCEEDED(hr))
            {
                hr = m_pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropertyStorage);
                if (SUCCEEDED(hr))
                {
                    hr = m_SavedPropertyStream.AssignFromWiaItem(m_pIWiaItem);
                    if (SUCCEEDED(hr))
                    {
                        IWiaItem *pRootItem = NULL;
                        hr = m_pIWiaItem->GetRootItem(&pRootItem);
                        if (SUCCEEDED(hr))
                        {
                            LONG lBedSizeX, lBedSizeY;
                            if (PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_HORIZONTAL_BED_SIZE, lBedSizeX ) &&
                                PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_VERTICAL_BED_SIZE, lBedSizeY ))
                            {
                                m_AspectRatio.cx = lBedSizeX;
                                m_AspectRatio.cy = lBedSizeY;
                            }
                            pRootItem->Release();
                        }
                    }
                    pIWiaPropertyStorage->Release();
                }
            }
        }
    }
    if (!SUCCEEDED(hr))
    {
        Destroy();
    }
    return(hr);
}


bool CScannerItem::GetAspectRatio( SIZE &sizeAspectRatio )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::GetAspectRatio"));
    if (m_AspectRatio.cx && m_AspectRatio.cy)
    {
        sizeAspectRatio = m_AspectRatio;
        return(true);
    }
    return(false);
}

bool CScannerItem::ApplyCurrentPreviewWindowSettings( HWND hWndPreview )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::ApplyCurrentPreviewWindowSettings"));
    SIZE sizeCurrentRes, sizeFullRes;
    SIZE sizeExtent;
    POINT ptOrigin;
    //
    // Get the current resolution
    //
    if (PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_XRES, sizeCurrentRes.cx ) &&
        PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_YRES, sizeCurrentRes.cy ))
    {
        //
        // Compute the full page resolution of the item
        //
        if (GetFullResolution( sizeCurrentRes, sizeFullRes ))
        {
            //
            // Set the resolution in the preview control
            //
            SendMessage( hWndPreview, PWM_SETRESOLUTION, 0, (LPARAM)&sizeFullRes );

            //
            // Get the origin and extent
            //
            SendMessage( hWndPreview, PWM_GETSELORIGIN, MAKEWPARAM(0,0), (LPARAM)&ptOrigin );
            SendMessage( hWndPreview, PWM_GETSELEXTENT, MAKEWPARAM(0,0), (LPARAM)&sizeExtent );

            WIA_TRACE(( TEXT("Current DPI: (%d,%d), Full Bed Res: (%d,%d), Origin: (%d,%d), Extent: (%d,%d)"), sizeCurrentRes.cx, sizeCurrentRes.cy, sizeFullRes.cx, sizeFullRes.cy, ptOrigin.x, ptOrigin.y, sizeExtent.cx, sizeExtent.cy ));

            //
            // Set the origin and extents.  We don't set them directly, because they might not be a correct multiple
            //
            CValidWiaSettings::SetNumericPropertyOnBoundary( m_pIWiaItem, WIA_IPS_XPOS, ptOrigin.x );
            CValidWiaSettings::SetNumericPropertyOnBoundary( m_pIWiaItem, WIA_IPS_YPOS, ptOrigin.y );
            CValidWiaSettings::SetNumericPropertyOnBoundary( m_pIWiaItem, WIA_IPS_XEXTENT, sizeExtent.cx );
            CValidWiaSettings::SetNumericPropertyOnBoundary( m_pIWiaItem, WIA_IPS_YEXTENT, sizeExtent.cy );
            return(true);
        }
    }
    return(false);
}


/* Calculate the maximum scan size using the give DPI */
bool CScannerItem::GetFullResolution( const SIZE &sizeResolutionPerInch, SIZE &sizeRes )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::GetFullResolution"));
    CComPtr<IWiaItem> pRootItem;
    if (SUCCEEDED(m_pIWiaItem->GetRootItem(&pRootItem)) && pRootItem)
    {
        LONG lBedSizeX, lBedSizeY, nPaperSource;
        if (PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_DOCUMENT_HANDLING_SELECT, static_cast<LONG>(nPaperSource)) && nPaperSource & FEEDER)
        {
            if (PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE, lBedSizeX ) &&
                PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_VERTICAL_SHEET_FEED_SIZE, lBedSizeY ))
            {
                sizeRes.cx = WiaUiUtil::MulDivNoRound( sizeResolutionPerInch.cx, lBedSizeX, 1000 );
                sizeRes.cy = WiaUiUtil::MulDivNoRound( sizeResolutionPerInch.cy, lBedSizeY, 1000 );
                return(true);
            }
        }
        if (PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_HORIZONTAL_BED_SIZE, lBedSizeX ) &&
            PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_VERTICAL_BED_SIZE, lBedSizeY ))
        {
            sizeRes.cx = WiaUiUtil::MulDivNoRound( sizeResolutionPerInch.cx, lBedSizeX, 1000 );
            sizeRes.cy = WiaUiUtil::MulDivNoRound( sizeResolutionPerInch.cy, lBedSizeY, 1000 );
            return(true);
        }
    }
    return(false);
}



void CScannerItem::Cancel(void)
{
    m_CancelEvent.Signal();
}


bool CScannerItem::CalculatePreviewResolution( SIZE &sizeResolution )
{
    const LONG nDesiredResolution = 50;
    PropStorageHelpers::CPropertyRange XResolutionRange, YResolutionRange;
    if (PropStorageHelpers::GetPropertyRange( m_pIWiaItem, WIA_IPS_XRES, XResolutionRange ) &&
        PropStorageHelpers::GetPropertyRange( m_pIWiaItem, WIA_IPS_YRES, YResolutionRange ))
    {
        sizeResolution.cx = WiaUiUtil::GetMinimum<LONG>( XResolutionRange.nMin, nDesiredResolution, XResolutionRange.nStep );
        sizeResolution.cy = WiaUiUtil::GetMinimum<LONG>( YResolutionRange.nMin, nDesiredResolution, YResolutionRange.nStep );
        return(true);
    }
    else
    {
        CSimpleDynamicArray<LONG> XResolutionList, YResolutionList;
        if (PropStorageHelpers::GetPropertyList( m_pIWiaItem, WIA_IPS_XRES, XResolutionList ) &&
            PropStorageHelpers::GetPropertyList( m_pIWiaItem, WIA_IPS_YRES, YResolutionList ))
        {
            for (int i=0;i<XResolutionList.Size();i++)
            {
                sizeResolution.cx = XResolutionList[i];
                if (sizeResolution.cx >= nDesiredResolution)
                    break;
            }
            for (i=0;i<YResolutionList.Size();i++)
            {
                sizeResolution.cy = YResolutionList[i];
                if (sizeResolution.cy >= nDesiredResolution)
                    break;
            }
            return(true);
        }
    }
    return(false);
}


/*
 * Scan: Prepare scan parameters and spawn the scanning thread.
 */
HANDLE CScannerItem::Scan( HWND hWndPreview, HWND hWndNotify )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::Scan"));
    POINT ptOrigin;
    SIZE sizeExtent;
    SIZE sizeResolution;
    if (hWndPreview)
    {
        ptOrigin.x = ptOrigin.y = 0;
        if (!CalculatePreviewResolution(sizeResolution))
        {
            WIA_ERROR((TEXT("Unable to calculate the preview resolution")));
            return(NULL);
        }
        if (!GetFullResolution(sizeResolution,sizeExtent))
        {
            WIA_ERROR((TEXT("Unable to calculate the preview resolution size")));
            return(NULL);
        }
    }
    else
    {
        if (!PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_XRES, sizeResolution.cx ) ||
            !PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_YRES, sizeResolution.cy ) ||
            !PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_XPOS, ptOrigin.x) ||
            !PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_YPOS, ptOrigin.y) ||
            !PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_XEXTENT, sizeExtent.cx) ||
            !PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPS_YEXTENT, sizeExtent.cy))
        {
            return(NULL);
        }
    }
    m_CancelEvent.Reset();
    HANDLE hScan = CScanPreviewThread::Scan(
                                           m_dwIWiaItemCookie,
                                           hWndPreview,
                                           hWndNotify,
                                           ptOrigin,
                                           sizeResolution,
                                           sizeExtent,
                                           m_CancelEvent
                                           );
    return(hScan);
}


HANDLE CScannerItem::Scan( HWND hWndNotify, GUID guidFormat, const CSimpleStringWide &strFilename )
{
    return CScanToFileThread::Scan( m_dwIWiaItemCookie, hWndNotify, guidFormat, strFilename );
}

bool CScannerItem::SetIntent( int nIntent )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::SetIntent"));
    CWaitCursor wc;
    // Restore the properties to their initial pristine settings first
    if (SUCCEEDED(m_SavedPropertyStream.ApplyToWiaItem(m_pIWiaItem)))
    {
        return(PropStorageHelpers::SetProperty( m_pIWiaItem, WIA_IPS_CUR_INTENT, nIntent ) &&
               PropStorageHelpers::SetProperty( m_pIWiaItem, WIA_IPS_CUR_INTENT, 0 ));
    }
    return false;
}

CSimpleEvent CScannerItem::CancelEvent(void) const
{
    return(m_CancelEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\sources.inc ===
#
# Builds the ImageIn common ui library, COMMON.LIB
#

!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETPATH=$(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)

ATL_VER         = 30
USE_STATIC_ATL  = 1

INCLUDES=   $(INCLUDES);\
            $(PROJECT_ROOT)\ui\prevwnd;

TARGETNAME=scanlib
TARGETTYPE=LIBRARY

SOURCES=\
        ..\scandlg.cpp \
        ..\scanitem.cpp \
        ..\wiascand.cpp \
        ..\scanproc.cpp


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\wiascand.h ===
#ifndef __WIASCAND_H_INCLUDED
#define __WIASCAND_H_INCLUDED

#include <windows.h>
#include "wiadevd.h"

HRESULT WINAPI ScannerDeviceDialog( PDEVICEDIALOGDATA pDialogDeviceData );

#endif // __WIASCAND_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\wiascand.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <initguid.h>
#include "pviewids.h"
#include "wiatextc.h"
#include "wiascand.h"
#include "pshelper.h"
#include "devprop.h"

HRESULT WINAPI ScannerDeviceDialog( PDEVICEDIALOGDATA pDialogDeviceData )
{
    HRESULT hr = E_FAIL;
    if (pDialogDeviceData && pDialogDeviceData->cbSize == sizeof(DEVICEDIALOGDATA))
    {
        InitCommonControls();
        RegisterWiaPreviewClasses( g_hInstance );
        CWiaTextControl::RegisterClass( g_hInstance );
        WIA_ERROR((TEXT("GetWindowThreadProcessId( pDialogDeviceData->hwndParent ): %08X, GetCurrentThreadId(): %08X"), GetWindowThreadProcessId( pDialogDeviceData->hwndParent, NULL ), GetCurrentThreadId() ));

        LONG nProps = ScannerProperties::GetDeviceProps( pDialogDeviceData->pIWiaItemRoot );

        int nDialogId = 0;

        //
        // Determine which dialog resource to use, based on which properties the scanner has, as follows:
        //
        // HasFlatBed         HasDocumentFeeder   SupportsPreview     SupportsPageSize
        // 1                  1                   1                   1                   IDD_SCAN_ADF
        // 1                  0                   1                   0                   IDD_SCAN_NORMAL
        // 0                  1                   1                   1                   IDD_SCAN_ADF
        // 0                  1                   0                   0                   IDD_SCAN_NO_PREVIEW
        //
        // otheriwse return E_NOTIMPL
        //
        const int nMaxControllingProps = 4;
        static struct
        {
            LONG ControllingProps[nMaxControllingProps];
            int pszDialogTemplate;
        }
        s_DialogResourceData[] =
        {
            { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, NULL },
            { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, IDD_SCAN_ADF },
            { ScannerProperties::HasFlatBed, 0,                                    ScannerProperties::SupportsPreview, 0,                                   IDD_SCAN },
            { 0,                             ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, IDD_SCAN_ADF },
            { 0,                             ScannerProperties::HasDocumentFeeder, 0,                                  0,                                   IDD_SCAN_NO_PREVIEW },
            { 0,                             ScannerProperties::HasDocumentFeeder, 0,                                  ScannerProperties::SupportsPageSize, IDD_SCAN_ADF },
            { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, 0,                                  ScannerProperties::SupportsPageSize, IDD_SCAN_ADF }
        };

        //
        // Find the set of flags that match this device.  If they match, use this resource.
        // Loop through each resource description.
        //
        for (int nCurrentResourceFlags=1;nCurrentResourceFlags<ARRAYSIZE(s_DialogResourceData) && !nDialogId;nCurrentResourceFlags++)
        {
            //
            // Loop through each controlling property
            //
            for (int nControllingProp=0;nControllingProp<nMaxControllingProps;nControllingProp++)
            {
                //
                // If this property DOESN'T match, break out prematurely
                //
                if ((nProps & s_DialogResourceData[0].ControllingProps[nControllingProp]) != s_DialogResourceData[nCurrentResourceFlags].ControllingProps[nControllingProp])
                {
                    break;
                }
            }
            //
            // If the current controlling property is equal to the maximum controlling property,
            // we had matches all the way through, so use this resource
            //
            if (nControllingProp == nMaxControllingProps)
            {
                nDialogId = s_DialogResourceData[nCurrentResourceFlags].pszDialogTemplate;
            }
        }

        //
        // If we didn't find a match, return E_NOTIMPL
        //
        if (!nDialogId)
        {
            return E_NOTIMPL;
        }

        //
        // Open the dialog
        //
        INT_PTR nResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(nDialogId), pDialogDeviceData->hwndParent, CScannerAcquireDialog::DialogProc, (LPARAM)pDialogDeviceData );

        if (-1 == nResult)
        {
            //
            // Some kind of system error occurred
            //
            hr = HRESULT_FROM_WIN32(GetLastError());

            //
            // Make sure we return some kind of error
            //
            if (hr == S_OK)
            {
                hr = E_FAIL;
            }
        }
        else
        {
            //
            // Just cast the return value to an HRESULT
            //
            hr = static_cast<HRESULT>(nResult);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\scanlib\sitemlst.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SITEMLST.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Scan Item List
 *
 *******************************************************************************/
#ifndef __SITEMLST_H_INCLUDED
#define __SITEMLST_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "simlist.h"
#include "scanitem.h"

class CScanItemList : public CSimpleLinkedList<CScannerItem>
{
public:
    CScanItemList( IWiaItem *pRootItem = NULL )
    {
        Enumerate(pRootItem);
    }
    Iterator CurrentItem(void) const
    {
        return Begin();
    }
    HRESULT Enumerate( IWiaItem *pRootItem )
    {
        WIA_PUSH_FUNCTION((TEXT("CScanItemList::Enumerate(%p)"),pRootItem));
        HRESULT hr = E_FAIL;
        if (pRootItem)
        {
            CComPtr<IEnumWiaItem> pIEnumWiaItem;
            hr = pRootItem->EnumChildItems(&pIEnumWiaItem);
            if (SUCCEEDED(hr))
            {
                ULONG cFetched=0;
                while (hr == S_OK)
                {
                    IWiaItem *pItem = NULL;
                    hr = pIEnumWiaItem->Next(1, &pItem, &cFetched);
                    if (SUCCEEDED(hr))
                    {
                        if (hr == S_OK)
                        {
                            WIA_TRACE((TEXT("Calling Append on (%p)"),pItem));
                            Append(CScannerItem(pItem));
                        }
                    }
                    else
                    {
                        WIA_ERROR((TEXT("pIEnumWiaItem->Next failed")));
                    }
                }
            }
            else
            {
                WIA_ERROR((TEXT("EnumRootItems failed")));
            }
        }
        return(hr);
    }
};

#endif // __SITEMLST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\select\choosdlg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
*
*  TITLE:       CHOOSDLG.CPP
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        5/12/1998
*
*  DESCRIPTION: Dialog class for selecting an WIA device
*
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <uiexthlp.h>
#include <modlock.h>
#include <wiacsh.h>
#include <wiadevdp.h>
#include <gwiaevnt.h>
#include <psutil.h>

static const DWORD g_HelpIDs[] =
{
    IDC_VENDORSTRING_PROMPT,      IDH_WIA_MAKER,
    IDC_VENDORSTRING,             IDH_WIA_MAKER,
    IDC_DESCRIPTIONSTRING_PROMPT, IDH_WIA_DESCRIBE,
    IDC_DESCRIPTIONSTRING,        IDH_WIA_DESCRIBE,
    IDC_DEVICELIST,               IDH_WIA_DEVICE_LIST,
    IDC_SELDLG_PROPERTIES,        IDH_WIA_BUTTON_PROP,
    IDOK,                         IDH_OK,
    IDCANCEL,                     IDH_CANCEL,
    IDC_BIG_TITLE,                -1,
    IDC_SETTINGS_GROUP,           -1,
    0, 0
};

/*
 * Add a device to the list view control.  We use the LPARAM in the list control
 * to store each interface pointer and any other per-device data we need
 */
CChooseDeviceDialog::CChooseDeviceDialog( HWND hwnd )
    : m_pChooseDeviceDialogParams(NULL),
      m_hWnd(hwnd),
      m_hBigFont(NULL)
{
}

/*
 * Destructor
 */
CChooseDeviceDialog::~CChooseDeviceDialog(void)
{
    m_pChooseDeviceDialogParams = NULL;
    m_hWnd = NULL;
}

/*
 * Find an item that matches the unique device string.  Return <0 if not found.
 */
int CChooseDeviceDialog::FindItemMatch( const CSimpleStringWide &strw )
{
    WIA_PUSH_FUNCTION((TEXT("CChooseDeviceDialog::FindItemMatch( %ws )"), strw.String() ));
    HWND hwndList = GetDlgItem( m_hWnd, IDC_DEVICELIST );
    if (!hwndList)
        return -1;
    int iCount = ListView_GetItemCount(hwndList);
    if (!iCount)
        return -1;
    CSimpleString str = CSimpleStringConvert::NaturalString(strw);
    for (int i=0;i<iCount;i++)
    {
        LV_ITEM lvItem;
        ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = i;
        ListView_GetItem( hwndList, &lvItem );

        CSimpleStringWide strwDeviceId;
        CDeviceInfo *pDevInfo = (CDeviceInfo *)lvItem.lParam;
        if (!pDevInfo)
            continue;
        if (!pDevInfo->GetProperty(WIA_DIP_DEV_ID,strwDeviceId))
            continue;
        CSimpleString strDeviceId = CSimpleStringConvert::NaturalString(strwDeviceId);
        WIA_TRACE((TEXT("Comparing %s to %s"), str.String(), strDeviceId.String()));
        if (str.CompareNoCase(strDeviceId)==0)
        {
            WIA_TRACE((TEXT("Found a match (%s == %s), returning index %d"), str.String(), strDeviceId.String(), i ));
            return i;
        }
    }
    return -1;
}

/*
 * Set the specified item to selected and focused, all others to neither.
 */
bool CChooseDeviceDialog::SetSelectedItem( int iItem )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_DEVICELIST );
    if (!hwndList)
        return false;
    int iCount = ListView_GetItemCount(hwndList);
    if (!iCount)
        return false;
    for (int i=0;i<iCount;i++)
    {
        UINT state = 0;
        if ((iItem < 0 && i == 0) || (i == iItem))
            state = LVIS_FOCUSED | LVIS_SELECTED;
        ListView_SetItemState( hwndList, i, state, (LVIS_FOCUSED|LVIS_SELECTED));
    }
    return true;
}


HICON CChooseDeviceDialog::LoadDeviceIcon( CDeviceInfo *pdi )
{
    CSimpleStringWide strwClassId;
    LONG nDeviceType;
    HICON hIconLarge = NULL;
    if (pdi->GetProperty( WIA_DIP_UI_CLSID, strwClassId ) &&
        pdi->GetProperty( WIA_DIP_DEV_TYPE, nDeviceType ))
    {
        WiaUiExtensionHelper::GetDeviceIcons(CSimpleBStr(strwClassId), nDeviceType, NULL, &hIconLarge );
    }
    return hIconLarge;
}

/*
 * Add a device to the list view control.  We use the LPARAM in the list control
 * to store each interface pointer and any other per-device data we need
 */
LRESULT CChooseDeviceDialog::OnInitDialog( WPARAM, LPARAM lParam )
{
    m_pChooseDeviceDialogParams = (CChooseDeviceDialogParams*)lParam;
    if (!m_pChooseDeviceDialogParams || !m_pChooseDeviceDialogParams->pSelectDeviceDlg || !m_pChooseDeviceDialogParams->pDeviceList)
    {
        EndDialog( m_hWnd, E_INVALIDARG );
        return 0;
    }

    SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(LoadIcon(g_hInstance,MAKEINTRESOURCE(IDI_DEFAULT))));

    //
    // Create the icon image list
    //
    HIMAGELIST hLargeDeviceIcons = ImageList_Create( GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), ILC_MASK|PrintScanUtil::CalculateImageListColorDepth(), 5, 5 );

    //
    // Set the image lists for the device list
    //
    if (hLargeDeviceIcons)
    {
        SendDlgItemMessage( m_hWnd, IDC_DEVICELIST, LVM_SETIMAGELIST, LVSIL_NORMAL, (LPARAM)hLargeDeviceIcons );
    }

    //
    // Reduce flicker
    //
    ListView_SetExtendedListViewStyleEx( GetDlgItem(m_hWnd, IDC_DEVICELIST), LVS_EX_DOUBLEBUFFER, LVS_EX_DOUBLEBUFFER );

    //
    // Create the large title
    //
    m_hBigFont = WiaUiUtil::CreateFontWithPointSizeFromWindow( GetDlgItem(m_hWnd,IDC_BIG_TITLE), 14, false, false );
    if (m_hBigFont)
    {
        SendDlgItemMessage( m_hWnd, IDC_BIG_TITLE, WM_SETFONT, reinterpret_cast<WPARAM>(m_hBigFont), MAKELPARAM(TRUE,0));
    }


    //
    // Register for device connection and disconnection events
    //
    CGenericWiaEventHandler::RegisterForWiaEvent( NULL, WIA_EVENT_DEVICE_DISCONNECTED, &m_pDisconnectEvent, m_hWnd, PWM_WIA_EVENT );
    CGenericWiaEventHandler::RegisterForWiaEvent( NULL, WIA_EVENT_DEVICE_CONNECTED, &m_pConnectEvent, m_hWnd, PWM_WIA_EVENT );


    AddDevices();
    SetSelectedItem(FindItemMatch(m_pChooseDeviceDialogParams->pSelectDeviceDlg->pwszInitialDeviceId));
    UpdateDeviceInformation();
    WiaUiUtil::CenterWindow(m_hWnd,m_pChooseDeviceDialogParams->pSelectDeviceDlg->hwndParent);
    SetForegroundWindow( m_hWnd );
    return 0;
}


LRESULT CChooseDeviceDialog::OnDblClkDeviceList( WPARAM, LPARAM )
{
    SendMessage( m_hWnd, WM_COMMAND, MAKEWPARAM(IDOK,0), 0 );
    return 0;
}

LRESULT CChooseDeviceDialog::OnItemChangedDeviceList( WPARAM, LPARAM )
{
    UpdateDeviceInformation();
    return 0;
}

LRESULT CChooseDeviceDialog::OnItemDeletedDeviceList( WPARAM, LPARAM lParam )
{
    //
    // Get the notification information for this message
    //
    NMLISTVIEW *pNmListView = reinterpret_cast<NMLISTVIEW*>(lParam);
    if (pNmListView)
    {
        //
        // Get the lParam, which is a CDeviceInfo *
        //
        CDeviceInfo *pDeviceInfo = reinterpret_cast<CDeviceInfo*>(pNmListView->lParam);
        if (pDeviceInfo)
        {
            //
            // Free it
            //
            delete pDeviceInfo;
        }
    }
    return 0;
}

/*
 * Handle WM_NOTIFY messages.
 */
LRESULT CChooseDeviceDialog::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( NM_DBLCLK, IDC_DEVICELIST, OnDblClkDeviceList );
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( LVN_ITEMCHANGED, IDC_DEVICELIST, OnItemChangedDeviceList );
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL( LVN_DELETEITEM, IDC_DEVICELIST, OnItemDeletedDeviceList );
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

/*
 * Handle WM_DESTROY message, and free all the memory associated with this dialog
 */
LRESULT CChooseDeviceDialog::OnDestroy( WPARAM, LPARAM )
{
    if (m_hBigFont)
    {
        DeleteObject( m_hBigFont );
        m_hBigFont = NULL;
    }

    //
    // Clear the image list and list view.  This should be unnecessary, but BoundsChecker
    // complains if I don't do it.
    //
    HWND hWndList = GetDlgItem( m_hWnd, IDC_DEVICELIST );
    if (hWndList)
    {
        //
        //  Remove all of the list view's items
        //
        ListView_DeleteAllItems( hWndList );

        //
        // Destroy the list view's image list
        //
        HIMAGELIST hImgList = ListView_SetImageList( hWndList, NULL, LVSIL_NORMAL );
        if (hImgList)
        {
            ImageList_Destroy(hImgList);
        }
    }

    return 0;
}

/*
 * Return the index of the first selected item in the list control
 */
int CChooseDeviceDialog::GetFirstSelectedDevice(void)
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_DEVICELIST );
    if (!hwndList)
        return -1;
    int iCount = ListView_GetItemCount(hwndList);
    if (!iCount)
        return -1;
    for (int i=0;i<iCount;i++)
        if (ListView_GetItemState(hwndList,i,LVIS_FOCUSED) & LVIS_FOCUSED)
            return i;
    return -1;
}

void CChooseDeviceDialog::OnProperties( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CChooseDeviceDialog::OnProperties"));
    int iSelIndex = GetFirstSelectedDevice();
    if (iSelIndex < 0)
    {
        WIA_ERROR((TEXT("GetFirstSelectedDevice failed")));
        return;
    }

    CDeviceInfo *pDevInfo = GetDeviceInfoFromList(iSelIndex);
    if (!pDevInfo)
    {
        WIA_ERROR((TEXT("GetDeviceInfoFromList")));
        return;
    }

    HRESULT hr;
    CSimpleStringWide strDeviceId;
    if (pDevInfo->GetProperty( WIA_DIP_DEV_ID, strDeviceId ))
    {
        CSimpleStringWide strName;
        if (pDevInfo->GetProperty( WIA_DIP_DEV_NAME, strName ))
        {
            CComPtr<IWiaItem> pRootItem;
            hr = CreateDeviceIfNecessary( pDevInfo, m_hWnd, &pRootItem, NULL );
            if (SUCCEEDED(hr))
            {
                CSimpleString strPropertyPageTitle;
                strPropertyPageTitle.Format( IDS_DEVICE_PROPPAGE_TITLE, g_hInstance, CSimpleStringConvert::NaturalString(strName).String() );
                hr = WiaUiUtil::SystemPropertySheet( g_hInstance, m_hWnd, pRootItem, strPropertyPageTitle );
            }
        }
        else
        {
            WIA_ERROR((TEXT("Unable to get property WIA_DIP_DEV_NAME")));
            hr = E_FAIL;
        }
    }
    else
    {
        WIA_ERROR((TEXT("Unable to get property WIA_DIP_DEV_ID")));
        hr = E_FAIL;
    }

    if (!SUCCEEDED(hr))
    {
        MessageBox( m_hWnd, CSimpleString( IDS_SELDLG_PROPSHEETERROR, g_hInstance ), CSimpleString( IDS_SELDLG_ERROR_TITLE, g_hInstance ), MB_ICONINFORMATION );
        WIA_PRINTHRESULT((hr,TEXT("Unable to display property sheet")));
    }
}

void CChooseDeviceDialog::OnOk( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CChooseDeviceDialog::OnOk"));
    int iSelIndex = GetFirstSelectedDevice();
    WIA_TRACE((TEXT("Selected item: %d\n"), iSelIndex ));
    if (iSelIndex < 0)
        return;
    CDeviceInfo *pDevInfo = GetDeviceInfoFromList(iSelIndex);
    if (!pDevInfo)
        return;
    WIA_TRACE((TEXT("pDevInfo: %08X\n"), pDevInfo ));
    CComPtr<IWiaItem> pRootItem;
    HRESULT hr = CreateDeviceIfNecessary( pDevInfo,
                                          m_pChooseDeviceDialogParams->pSelectDeviceDlg->hwndParent,
                                          m_pChooseDeviceDialogParams->pSelectDeviceDlg->ppWiaItemRoot,
                                          m_pChooseDeviceDialogParams->pSelectDeviceDlg->pbstrDeviceID );
    EndDialog(m_hWnd,hr);
}

void CChooseDeviceDialog::OnCancel( WPARAM, LPARAM )
{
    EndDialog(m_hWnd,S_FALSE);
}

/*
 * WM_COMMAND handler.  IDOK causes the DevInfo interface pointer to be stored in the
 * dialog info structure for use elsewhere.  Then we delete and zero out that item's
 * LPARAM so it won't get deleted in WM_DESTROY.
 */
LRESULT CChooseDeviceDialog::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND( IDOK, OnOk );
        SC_HANDLE_COMMAND( IDCANCEL, OnCancel );
        SC_HANDLE_COMMAND( IDC_SELDLG_PROPERTIES, OnProperties );
    }
    SC_END_COMMAND_HANDLERS();
}

/*
 * Shortcut to get the LPARAM (CDeviceInfo*) from a given list control item
 */
CChooseDeviceDialog::CDeviceInfo *CChooseDeviceDialog::GetDeviceInfoFromList( int iIndex )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_DEVICELIST );
    if (!hwndList)
        return NULL;
    LV_ITEM lvItem;
    ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iIndex;
    if (!ListView_GetItem( hwndList, &lvItem ))
        return NULL;
    return ((CDeviceInfo*)lvItem.lParam);
}


/*
 * Set the description strings for the currently selected device.
 */
void CChooseDeviceDialog::UpdateDeviceInformation(void)
{
    CSimpleStringWide strVendorDescription;
    CSimpleStringWide strDeviceDescription;
    int iIndex = GetFirstSelectedDevice();
    if (iIndex < 0)
    {
        EnableWindow( GetDlgItem(m_hWnd,IDOK), FALSE );
        EnableWindow( GetDlgItem(m_hWnd,IDC_SELDLG_PROPERTIES), FALSE );
    }
    else
    {
        EnableWindow( GetDlgItem(m_hWnd,IDOK), TRUE );
        EnableWindow( GetDlgItem(m_hWnd,IDC_SELDLG_PROPERTIES), TRUE );
        CDeviceInfo *pDevInfo = GetDeviceInfoFromList( iIndex );
        if (pDevInfo)
        {
            (void)pDevInfo->GetProperty( WIA_DIP_VEND_DESC, strVendorDescription );
            (void)pDevInfo->GetProperty( WIA_DIP_DEV_DESC, strDeviceDescription );
        }
    }
    CSimpleStringConvert::NaturalString(strVendorDescription).SetWindowText( GetDlgItem( m_hWnd, IDC_VENDORSTRING ) );
    CSimpleStringConvert::NaturalString(strDeviceDescription).SetWindowText( GetDlgItem( m_hWnd, IDC_DESCRIPTIONSTRING ) );
}


/*
 * Add a device to the list view control.  We use the LPARAM in the list control
 * to store each interface pointer and any other per-device data we need
 */
BOOL CChooseDeviceDialog::AddDevice( IWiaPropertyStorage *pIWiaPropertyStorage, int iDevNo )
{
    //
    // Assume failure
    //
    BOOL bResult = FALSE;

    CDeviceInfo *pDeviceInfo = new CDeviceInfo;
    if (pDeviceInfo)
    {
        CSimpleStringWide strFriendlyName, strServerName;
        pDeviceInfo->Initialize(pIWiaPropertyStorage);
        pDeviceInfo->GetProperty( WIA_DIP_DEV_NAME, strFriendlyName );
        pDeviceInfo->GetProperty( WIA_DIP_SERVER_NAME, strServerName );

        //
        // Load the icon, and add it to the image list
        //
        HICON hIcon = LoadDeviceIcon( pDeviceInfo );
        if (hIcon)
        {
            HIMAGELIST hNormalImageList = ListView_GetImageList( GetDlgItem( m_hWnd, IDC_DEVICELIST ), LVSIL_NORMAL );
            if (hNormalImageList)
            {
                int iIconIndex = ImageList_AddIcon( hNormalImageList, hIcon );

                //
                // Get the device's name
                //
                CSimpleString strNaturalFriendlyName = CSimpleStringConvert::NaturalString(strFriendlyName);
                CSimpleString strNaturalServerName = CSimpleStringConvert::NaturalString(strServerName);

                //
                // Perpare the LV_ITEM struct to add it to the list view
                //
                LV_ITEM lvItem;
                ::ZeroMemory(&lvItem,sizeof(LV_ITEM));
                lvItem.lParam = reinterpret_cast<LPARAM>(pDeviceInfo);
                lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                lvItem.iItem = iDevNo;

                //
                // Append the server name, if there is one
                //
                if (strServerName.Length() && CSimpleStringConvert::NaturalString(strServerName) != CSimpleString(TEXT("local")))
                {
                    strNaturalFriendlyName += CSimpleString(TEXT(" ("));
                    strNaturalFriendlyName += strNaturalServerName;
                    strNaturalFriendlyName += CSimpleString(TEXT(")"));
                }
                lvItem.pszText = (LPTSTR)strNaturalFriendlyName.String();
                lvItem.cchTextMax = strNaturalFriendlyName.Length() + 1;
                lvItem.iImage = iIconIndex;

                //
                // Add it to the list view
                //
                bResult = (ListView_InsertItem( GetDlgItem( m_hWnd, IDC_DEVICELIST ), &lvItem ) >= 0);
            }

            //
            // Free the icon
            //
            DestroyIcon( hIcon );
        }

        //
        // If we couldn't add the item for some reason, free the deviceinfo struct
        //
        if (!bResult)
        {
            delete pDeviceInfo;
        }
    }
    return bResult;
}



/*
 * Enumerate devices and add each to the list
 */
bool CChooseDeviceDialog::AddDevices(void)
{
    CWaitCursor wc;
    for (int i=0;i<m_pChooseDeviceDialogParams->pDeviceList->Size();i++)
    {
        AddDevice( m_pChooseDeviceDialogParams->pDeviceList->operator[](i), i );
    }
    return true;
}

HRESULT CChooseDeviceDialog::CreateDeviceIfNecessary( CDeviceInfo *pDevInfo, HWND hWndParent, IWiaItem **ppRootItem, BSTR *pbstrDeviceId )
{
    if (!pDevInfo)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    CSimpleStringWide strDeviceId;
    if (pDevInfo->GetProperty( WIA_DIP_DEV_ID, strDeviceId ))
    {
        if (pDevInfo->RootItem())
        {
            if (ppRootItem)
            {
                *ppRootItem = pDevInfo->RootItem();
                (*ppRootItem)->AddRef();
            }
            if (pbstrDeviceId)
            {
                *pbstrDeviceId = SysAllocString( strDeviceId );
                if (!pbstrDeviceId)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            CComPtr<IWiaDevMgr> pWiaDevMgr;
            hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
            if (SUCCEEDED(hr))
            {
                hr = CreateWiaDevice( pWiaDevMgr, pDevInfo->WiaPropertyStorage(), hWndParent, ppRootItem, pbstrDeviceId );
                if (SUCCEEDED(hr))
                {
                    if (ppRootItem)
                    {
                        pDevInfo->RootItem(*ppRootItem);
                    }
                }
            }
        }
    }
    else
    {
        hr = E_FAIL;
        WIA_ERROR((TEXT("Unable to get property WIA_DIP_DEV_ID")));
    }
    return hr;
}

// Static helper function for creating a device
HRESULT CChooseDeviceDialog::CreateWiaDevice( IWiaDevMgr *pWiaDevMgr, IWiaPropertyStorage *pWiaPropertyStorage, HWND hWndParent, IWiaItem **ppWiaRootItem, BSTR *pbstrDeviceId )
{
    WIA_PUSH_FUNCTION((TEXT("CChooseDeviceDialog::CreateWiaDevice")));
    //
    // Validate parameters
    //
    if (!pWiaPropertyStorage || !pWiaDevMgr)
    {
        return(E_INVALIDARG);
    }

    //
    // Get the device ID
    //
    CSimpleStringWide strDeviceId;
    if (!PropStorageHelpers::GetProperty( pWiaPropertyStorage, WIA_DIP_DEV_ID, strDeviceId ))
    {
        return(E_INVALIDARG);
    }
    WIA_TRACE((TEXT("DeviceID: %ws"), strDeviceId.String()));

    //
    // Assume success
    //
    HRESULT hr = S_OK;

    //
    // It is OK to have a NULL item, that means we won't be creating the device
    //
    if (ppWiaRootItem)
    {
        //
        // Initialize the device pointer to NULL
        //
        *ppWiaRootItem = NULL;

        //
        // Get the friendly name for the status dialog
        //
        CSimpleStringWide strwFriendlyName;
        if (!PropStorageHelpers::GetProperty( pWiaPropertyStorage, WIA_DIP_DEV_NAME, strwFriendlyName ))
        {
            return(E_INVALIDARG);
        }

        WIA_TRACE((TEXT("DeviceName: %ws"), strwFriendlyName.String()));

        //
        // Convert the device name to ANSI if needed
        //
        CSimpleString strFriendlyName = CSimpleStringConvert::NaturalString(strwFriendlyName);

        //
        // Get the device type for the status dialog
        //
        LONG nDeviceType;
        if (!PropStorageHelpers::GetProperty( pWiaPropertyStorage, WIA_DIP_DEV_TYPE, nDeviceType ))
        {
            return(E_INVALIDARG);
        }
        WIA_TRACE((TEXT("DeviceType: %08X"), nDeviceType));

        //
        // Create the progress dialog
        //
        CComPtr<IWiaProgressDialog> pWiaProgressDialog;
        hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&pWiaProgressDialog );
        if (SUCCEEDED(hr))
        {
            //
            // Figure out which animation to use
            //
            int nAnimationType = WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE;
            if (StiDeviceTypeScanner == GET_STIDEVICE_TYPE(nDeviceType))
            {
                nAnimationType = WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE;
            }
            else if (StiDeviceTypeStreamingVideo == GET_STIDEVICE_TYPE(nDeviceType))
            {
                nAnimationType = WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE;
            }

            //
            // Initialize the progress dialog
            //
            pWiaProgressDialog->Create( hWndParent, nAnimationType|WIA_PROGRESSDLG_NO_PROGRESS|WIA_PROGRESSDLG_NO_CANCEL|WIA_PROGRESSDLG_NO_TITLE );
            pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString(IDS_SELECT_PROGDLG_TITLE,g_hInstance)));
            pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString().Format(IDS_SELECT_PROGDLG_MESSAGE,g_hInstance,strFriendlyName.String())));

            //
            // Show the progress dialog
            //
            pWiaProgressDialog->Show();

            //
            // Create the device
            //
            WIA_TRACE((TEXT("Calling pWiaDevMgr->CreateDevice")));
            hr = pWiaDevMgr->CreateDevice( CSimpleBStr(strDeviceId), ppWiaRootItem );
            WIA_PRINTHRESULT((hr,TEXT("pWiaDevMgr->CreateDevice returned")));

            //
            // Tell the wait dialog to go away
            //
            pWiaProgressDialog->Destroy();
        }
    }

    //
    // If everything is still OK, and the caller wants a device ID, store it.
    //
    if (SUCCEEDED(hr) && pbstrDeviceId)
    {
        *pbstrDeviceId = SysAllocString( strDeviceId );
        if (!pbstrDeviceId)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    WIA_PRINTHRESULT((hr,TEXT("CChooseDeviceDialog::CreateWiaDevice returned")));
    return(hr);
}


LRESULT CChooseDeviceDialog::OnWiaEvent( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnEventNotification"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        //
        // If this is the connect event, and it matches the allowed device types, add the device to the list
        //
        if (pEventMessage->EventId() == WIA_EVENT_DEVICE_CONNECTED)
        {
            IWiaPropertyStorage *pWiaPropertyStorage = NULL;
            if (SUCCEEDED(WiaUiUtil::GetDeviceInfoFromId( pEventMessage->DeviceId(), &pWiaPropertyStorage )) && pWiaPropertyStorage)
            {
                LONG nDeviceType;
                if (PropStorageHelpers::GetProperty( pWiaPropertyStorage, WIA_DIP_DEV_TYPE, nDeviceType ))
                {
                    if (m_pChooseDeviceDialogParams->pSelectDeviceDlg->nDeviceType == StiDeviceTypeDefault || (m_pChooseDeviceDialogParams->pSelectDeviceDlg->nDeviceType == GET_STIDEVICE_TYPE(nDeviceType)))
                    {
                        AddDevice( pWiaPropertyStorage, ListView_GetItemCount( GetDlgItem( m_hWnd, IDC_DEVICELIST )));
                    }
                    else
                    {
                        pWiaPropertyStorage->Release();
                    }
                }
                else
                {
                    pWiaPropertyStorage->Release();
                }
            }
        }
        //
        // If this is the disconnect event, remove it from the list
        //
        else if (pEventMessage->EventId() == WIA_EVENT_DEVICE_DISCONNECTED)
        {
            int nItemIndex = FindItemMatch( pEventMessage->DeviceId() );
            if (nItemIndex >= 0)
            {
                WIA_TRACE((TEXT("Removing device %ws (%d)"), pEventMessage->DeviceId().String(), nItemIndex ));
                int nSelectedItem = GetFirstSelectedDevice();
                ListView_DeleteItem( GetDlgItem( m_hWnd, IDC_DEVICELIST ), nItemIndex );
                int nItemCount = ListView_GetItemCount(GetDlgItem( m_hWnd, IDC_DEVICELIST ));
                if (nItemCount)
                {
                    if (nSelectedItem == nItemIndex)
                    {
                        nSelectedItem = nItemCount-1;
                    }
                    SetSelectedItem( nSelectedItem );
                }
            }
        }
        //
        // Delete the message
        //
        delete pEventMessage;
    }

    //
    // Update all of the controls
    //
    UpdateDeviceInformation();

    return HANDLED_EVENT_MESSAGE;
}


LRESULT CChooseDeviceDialog::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    SendDlgItemMessage( m_hWnd, IDC_DEVICELIST, WM_SYSCOLORCHANGE, wParam, lParam );
    return 0;
}


LRESULT CChooseDeviceDialog::OnHelp( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmHelp( wParam, lParam, g_HelpIDs );
}

LRESULT CChooseDeviceDialog::OnContextMenu( WPARAM wParam, LPARAM lParam )
{
    return WiaHelp::HandleWmContextMenu( wParam, lParam, g_HelpIDs );
}

/*
 * Main dialog proc
 */
INT_PTR CALLBACK CChooseDeviceDialog::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CChooseDeviceDialog)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( PWM_WIA_EVENT, OnWiaEvent );
        SC_HANDLE_DIALOG_MESSAGE( WM_HELP, OnHelp );
        SC_HANDLE_DIALOG_MESSAGE( WM_CONTEXTMENU, OnContextMenu );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\select\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for selection dialog
 *
 *****************************************************************************/

#ifndef _pch_h
#define _pch_h

#include <windows.h>
#include <commctrl.h>
#include <objbase.h>
#include <atlbase.h>
#include <sti.h>

#include "wia.h"
#include "wiadebug.h"

#include "uicommon.h"

#include "wiaseld.h"
#include "wiaseld.rh"
#include "choosdlg.h"
#include "simcrack.h"
#include "proparry.h"
#include "devlist.h"
#include "dbgtimer.h"
#include <shfusion.h>

extern HINSTANCE g_hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\select\choosdlg.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       CHOOSDLG.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/12/1998
 *
 *  DESCRIPTION: Declarations for the WIA device selection dialog box
 *
 *******************************************************************************/
#ifndef __CHOOSDLG_H
#define __CHOOSDLG_H

#include <windows.h>
#include <objbase.h>
#include <wia.h>
#include <simstr.h>
#include <devlist.h>
#include <wiaseld.h>


#define PWM_WIA_EVENT (WM_USER+111)


struct CChooseDeviceDialogParams
{
    SELECTDEVICEDLG *pSelectDeviceDlg;
    CDeviceList     *pDeviceList;
};


class CChooseDeviceDialog
{
private:
    CChooseDeviceDialogParams *m_pChooseDeviceDialogParams;
    HWND                       m_hWnd;
    HFONT                      m_hBigFont;
    CComPtr<IUnknown>          m_pDisconnectEvent;
    CComPtr<IUnknown>          m_pConnectEvent;

private:
    //
    // No implementation
    //
    CChooseDeviceDialog(void);
    CChooseDeviceDialog( const CChooseDeviceDialog & );
    CChooseDeviceDialog &operator=( const CChooseDeviceDialog & );

public:
    static INT_PTR CALLBACK DialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    //
    // This is stored as data with each icon
    //
    class CDeviceInfo
    {
    private:
        CComPtr<IWiaPropertyStorage> m_pPropertyStorage;
        CComPtr<IWiaItem>            m_pRootItem;

    private:
        //
        // No implementation
        //
        CDeviceInfo &operator=( const CDeviceInfo & );
        CDeviceInfo( const CDeviceInfo & );

    public:
        CDeviceInfo( IUnknown *pIUnknown=NULL )
        {
            Initialize(pIUnknown);
        }
        ~CDeviceInfo(void)
        {
            m_pPropertyStorage.Release();
        }
        IWiaPropertyStorage *WiaPropertyStorage(void)
        {
            return m_pPropertyStorage.p;
        }
        HRESULT Initialize( IUnknown *pIUnknown )
        {
            m_pPropertyStorage = NULL;
            if (!pIUnknown)
            {
                return E_POINTER;
            }
            return pIUnknown->QueryInterface( IID_IWiaPropertyStorage, (void**)&m_pPropertyStorage );
        }
        bool GetProperty( PROPID propId, CSimpleStringWide &strPropertyValue )
        {
            return PropStorageHelpers::GetProperty( m_pPropertyStorage, propId, strPropertyValue );
        }
        bool GetProperty( PROPID propId, LONG &nValue )
        {
            return PropStorageHelpers::GetProperty( m_pPropertyStorage, propId, nValue );
        }
        void RootItem( IWiaItem *pRootItem )
        {
            m_pRootItem = pRootItem;
        }
        IWiaItem *RootItem(void)
        {
            return m_pRootItem;
        }
    };


private:
    //
    // Only constructor and destructor
    //
    explicit CChooseDeviceDialog( HWND hwnd );
    ~CChooseDeviceDialog(void);

    //
    // Message handlers
    //
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM wParam, LPARAM lParam );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );
    LRESULT OnDblClkDeviceList( WPARAM wParam, LPARAM lParam );
    LRESULT OnItemChangedDeviceList( WPARAM wParam, LPARAM lParam );
    LRESULT OnItemDeletedDeviceList( WPARAM, LPARAM lParam );
    LRESULT OnWiaEvent( WPARAM wParam, LPARAM lParam );
    LRESULT OnHelp( WPARAM, LPARAM );
    LRESULT OnContextMenu( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );

    //
    // WM_COMMAND handlers
    //
    void OnProperties( WPARAM wParam, LPARAM lParam );
    void OnOk( WPARAM wParam, LPARAM lParam );
    void OnCancel( WPARAM wParam, LPARAM lParam );

    //
    // Helper functions
    //
    int FindItemMatch( const CSimpleStringWide &str );
    bool SetSelectedItem( int iItem );
    HICON LoadDeviceIcon( CDeviceInfo *pdi );
    int GetFirstSelectedDevice(void);
    CDeviceInfo *GetDeviceInfoFromList( int iIndex );
    bool AddDevices(void);
    BOOL AddDevice( IWiaPropertyStorage *pIWiaPropertyStorage, int iDevNo );
    void UpdateDeviceInformation(void);
    HRESULT CreateDeviceIfNecessary( CDeviceInfo *pDevInfo, HWND hWndParent, IWiaItem **ppRootItem, BSTR *pbstrDeviceId );

public:
    static HRESULT CreateWiaDevice( IWiaDevMgr *pWiaDevMgr, IWiaPropertyStorage *pWiaPropertyStorage, HWND hWndParent, IWiaItem **ppWiaRootItem, BSTR *pbstrDeviceId );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\select\sources.inc ===
!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETNAME=selectd
TARGETTYPE=LIBRARY
TARGETPATHLIB = $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)

ATL_VER         = 30
USE_STATIC_ATL  = 1

TARGETPATH=$(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)

SOURCES=    ..\wiaseld.cpp    \
            ..\choosdlg.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\common\dbmem.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dbmem.cpp
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
/ Title;
/   dbmem.cpp
/
/ Authors;
/   David De Vorchik (daviddv)
/
/ Notes;
/   Wrappers for memory allocation (for tracking leaks etc)
/----------------------------------------------------------------------------*/
#include "precomp.hxx"
#include "stdio.h"
#pragma hdrstop


#ifdef DEBUG


/*-----------------------------------------------------------------------------
/ Locals & helper functions
/----------------------------------------------------------------------------*/

// Ensure that we don't recurse
#undef LocalAlloc
#undef LocalFree


/*-----------------------------------------------------------------------------
/ DebugLocalAlloc
/ ---------------
/   Perform a LocalAlloc with suitable tracking of the block.
/
/ In:
/   uFlags = flags
/   cbSize = size of allocation
/
/ Out:
/   HLOCAL
/----------------------------------------------------------------------------*/
HLOCAL DebugLocalAlloc(UINT uFlags, SIZE_T cbSize)
{
    HLOCAL hResult;

    TraceEnter(TRACE_COMMON_MEMORY, "DebugLocalAlloc");
    Trace(TEXT("Flags %08x, Size %d (%08x)"), uFlags, cbSize, cbSize);

    hResult = LocalAlloc(uFlags, cbSize);

    TraceLeaveValue(hResult);
}


/*-----------------------------------------------------------------------------
/ DebugLocalFree
/ --------------
/   Wrapper for local free that releases the memory allocation.
/
/ In:
/   hLocal = allocation to be free'd
/
/ Out:
/   HLOCAL
/----------------------------------------------------------------------------*/
HLOCAL DebugLocalFree(HLOCAL hLocal)
{
    HLOCAL hResult;

    TraceEnter(TRACE_COMMON_MEMORY, "DebugLocalAlloc");
    Trace(TEXT("Freeing handle %08x"), hLocal);

    hResult = LocalFree(hLocal);

    TraceLeaveValue(hResult);
}


#endif      // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\select\wiaseld.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIASELD.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/12/1998
 *
 *  DESCRIPTION: Interface definitions for ChooseWIADevice API
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop

HRESULT WINAPI SelectDeviceDlg( PSELECTDEVICEDLG pSelectDeviceDlg )
{
    //
    // Double check arguments
    //
    if (!pSelectDeviceDlg)
        return(E_POINTER);
    if (pSelectDeviceDlg->cbSize != sizeof(SELECTDEVICEDLG))
        return(E_INVALIDARG);

    // Put up a wait cursor
    CWaitCursor wc;

    CComPtr<IWiaDevMgr> pWiaDevMgr;
    HRESULT hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr);
    if (SUCCEEDED(hr))
    {
        CDeviceList DeviceList( pWiaDevMgr, pSelectDeviceDlg->nDeviceType );
        if (DeviceList.Size() == 0)
        {
            return WIA_S_NO_DEVICE_AVAILABLE;
        }
        else if (DeviceList.Size() == 1 && !(pSelectDeviceDlg->nFlags & WIA_SELECT_DEVICE_NODEFAULT))
        {
            hr = CChooseDeviceDialog::CreateWiaDevice( pWiaDevMgr, DeviceList[0], NULL, pSelectDeviceDlg->ppWiaItemRoot, pSelectDeviceDlg->pbstrDeviceID );
        }
        else
        {
            // BUGBUG: I have to register ComboBoxEx32 class too, since it is
            // used by the shell property pages.  Perhaps I will move it out of
            // here...
            INITCOMMONCONTROLSEX icex;
            icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
            icex.dwICC = ICC_WIN95_CLASSES | ICC_USEREX_CLASSES;
            InitCommonControlsEx(&icex);

            CChooseDeviceDialogParams ChooseDeviceDialogParams;
            ChooseDeviceDialogParams.pSelectDeviceDlg = pSelectDeviceDlg;
            ChooseDeviceDialogParams.pDeviceList = &DeviceList;
            hr = (HRESULT)DialogBoxParam(
                                        g_hInstance,
                                        MAKEINTRESOURCE(IDD_CHOOSEWIADEVICE),
                                        pSelectDeviceDlg->hwndParent,
                                        reinterpret_cast<DLGPROC>(CChooseDeviceDialog::DialogProc),
                                        reinterpret_cast<LPARAM>(&ChooseDeviceDialogParams)
                                        );
        }
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\common\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       debug.cpp
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
/ Title;
/   debug.cpp
/
/ Authors;
/   David De Vorchik (daviddv)
/
/ Notes;
/   Provides printf style debug output
/----------------------------------------------------------------------------*/
#include "precomp.hxx"
#include "stdio.h"
#pragma hdrstop


#ifdef DEBUG


/*-----------------------------------------------------------------------------
/ Locals & helper functions
/----------------------------------------------------------------------------*/

#define GETDEPTH(x)  (x)=reinterpret_cast<UINT_PTR>(TlsGetValue (g_dwMargin));
#define SETDEPTH(x)  TlsSetValue (g_dwMargin, reinterpret_cast<LPVOID>((x)));


DWORD g_dwMargin=0;
DWORD g_dwTraceMask = 0;

#define MAX_CALL_DEPTH  64


#define BUFFER_SIZE 4096




/*-----------------------------------------------------------------------------
/ _indent
/ -------
/   Output to the debug stream indented by n columns.
/
/ In:
/   i = column to indent to.
/   pString -> string to be indented
/
/ Out:
/   -
/----------------------------------------------------------------------------*/

void _indent(UINT_PTR i, LPCTSTR pString)
{
    TCHAR szIndentBuffer[BUFFER_SIZE];
    szIndentBuffer[0] = TEXT('\0');

    wsprintf(szIndentBuffer, TEXT("%08x "), GetCurrentThreadId());

    for ( ; i > 0 ; i-- )
        lstrcat(szIndentBuffer, TEXT(" "));

    lstrcat(szIndentBuffer, pString);
    lstrcat(szIndentBuffer, TEXT("\n"));

    OutputDebugString(szIndentBuffer);
}





/*-----------------------------------------------------------------------------
/ DoTraceSetMask
/ --------------
/   Adjust the trace mask to reflect the state given.
/
/ In:
/   dwMask = mask for enabling / disable trace output
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask)
{

    g_dwTraceMask = dwMask;
}


/*-----------------------------------------------------------------------------
/ DoTraceEnter
/ ------------
/   Display the name of the function we are in.
/
/ In:
/   pName -> function name to be displayed in subsequent trace output.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceEnter(DWORD dwMask, LPCTSTR pName)
{
    UINT_PTR uDepth=0;
    TCHAR szStr[300];
    GETDEPTH(uDepth);
    uDepth++;
    SETDEPTH(uDepth);

    if ( !pName )
           pName = TEXT("<no name>");         // no function name given

    wsprintf (szStr, TEXT("ENTER: %s"), pName);
    _indent (uDepth, szStr);
}


/*-----------------------------------------------------------------------------
/ DoTraceLeave
/ ------------
/   On exit from a function, decrement the margin
/
/ In:
/    -
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceLeave(void)
{
    UINT_PTR uDepth;
        GETDEPTH (uDepth);
        uDepth--;
        SETDEPTH(uDepth);

}


/*-----------------------------------------------------------------------------
/ DoTrace
/ -------
/   Perform printf formatting to the debugging stream.  We indent the output
/   and stream the function name as required to give some indication of
/   call stack depth.
/
/ In:
/   pFormat -> printf style formatting string
/   ... = arguments as required for the formatting
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTrace(LPCTSTR pFormat, ...)
{
    va_list va;
    TCHAR szTraceBuffer[BUFFER_SIZE];
    UINT_PTR uDepth;
    GETDEPTH(uDepth);
    if ( uDepth < MAX_CALL_DEPTH  )
    {
        va_start(va, pFormat);
        wvsprintf(szTraceBuffer, pFormat, va);
        va_end(va);

        _indent(uDepth+1, szTraceBuffer);
    }
}


/*-----------------------------------------------------------------------------
/ DoTraceGuid
/ -----------
/   Given a GUID output it into the debug string, first we try and map it
/   to a name (ie. IShellFolder), if that didn't work then we convert it
/   to its human readable form.
/
/ In:
/   pszPrefix -> prefix string
/   lpGuid -> guid to be streamed
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
#ifdef UNICODE
#define MAP_GUID(x)     &x, TEXT(""L#x)
#else
#define MAP_GUID(x)     &x, TEXT(""#x)
#endif

#define MAP_GUID2(x,y)  MAP_GUID(x), MAP_GUID(y)

const struct
{
    const GUID* m_pGUID;
    LPCTSTR     m_pName;
}
_guid_map[] =
{
    MAP_GUID(IID_IUnknown),
    MAP_GUID(IID_IClassFactory),
    MAP_GUID(IID_IDropTarget),
    MAP_GUID(IID_IDataObject),
    MAP_GUID(IID_IPersist),
    MAP_GUID(IID_IPersistStream),
    MAP_GUID(IID_IPersistFolder),
    MAP_GUID(IID_IPersistFolder2),
    MAP_GUID(IID_IPersistFile),
    MAP_GUID(IID_IOleWindow),
    MAP_GUID2(IID_INewShortcutHookA, IID_INewShortcutHookW),
    MAP_GUID(IID_IShellBrowser),
    MAP_GUID(IID_IShellView),
    MAP_GUID(IID_IContextMenu),
    MAP_GUID(IID_IShellIcon),
    MAP_GUID(IID_IShellFolder),
    MAP_GUID(IID_IShellExtInit),
    MAP_GUID(IID_IShellPropSheetExt),
    MAP_GUID2(IID_IExtractIconA, IID_IExtractIconW),
    MAP_GUID2(IID_IShellLinkA, IID_IShellLinkW),
    MAP_GUID2(IID_IShellCopyHookA, IID_IShellCopyHookW),
    MAP_GUID2(IID_IFileViewerA, IID_IFileViewerW),
    MAP_GUID(IID_ICommDlgBrowser),
    MAP_GUID(IID_IEnumIDList),
    MAP_GUID(IID_IFileViewerSite),
    MAP_GUID(IID_IContextMenu2),
    MAP_GUID2(IID_IShellExecuteHookA, IID_IShellExecuteHookW),
    MAP_GUID(IID_IPropSheetPage),
    MAP_GUID(IID_IShellView2),
    MAP_GUID(IID_IUniformResourceLocator),
    MAP_GUID(IID_IShellDetails),
    MAP_GUID(IID_IShellExtInit),
    MAP_GUID(IID_IShellPropSheetExt),
    MAP_GUID(IID_IShellIconOverlay),
    MAP_GUID(IID_IExtractImage),
    MAP_GUID(IID_IExtractImage2),
    MAP_GUID(IID_IQueryInfo),
    MAP_GUID(IID_IShellDetails3),
    MAP_GUID(IID_IShellView2),
    MAP_GUID(IID_IShellFolder2),
    MAP_GUID(IID_IShellIconOverlay),
    MAP_GUID(IID_IMoniker),
    MAP_GUID(IID_IStream),
    MAP_GUID(IID_ISequentialStream),
    MAP_GUID(IID_IPersistFreeThreadedObject),
};

void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID)
{
    TCHAR szGUID[GUIDSTR_MAX];
    TCHAR szBuffer[1024];
    LPCTSTR pName = NULL;
    size_t i;
    UINT_PTR uDepth;
    GETDEPTH(uDepth);
    if (  uDepth < MAX_CALL_DEPTH  )
    {
        for ( i = 0 ; i < ARRAYSIZE(_guid_map); i++ )
        {
            if ( IsEqualGUID(rGUID, *_guid_map[i].m_pGUID) )
            {
                pName = _guid_map[i].m_pName;
                break;
            }
        }

        if ( !pName )
        {
            SHStringFromGUID(rGUID, szGUID, ARRAYSIZE(szGUID));
            pName = szGUID;
        }

        wsprintf(szBuffer, TEXT("%s %s"), pPrefix, pName);
        _indent(uDepth+1, szBuffer);
    }
}

/*-----------------------------------------------------------------------------
/ DoTraceViewMsg
/ --------------
/   Given a view msg (SFVM_ && DVM_), print out the corresponding text...
/
/ In:
/   uMsg -> msg to be streamed
/   wParam -> wParam value for message
/   lParam -> lParam value for message
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
#ifdef UNICODE
#define MAP_MSG(x)     x, TEXT(""L#x)
#else
#define MAP_MSG(x)     x, TEXT(""#x)
#endif

const struct
{
    UINT       m_uMsg;
    LPCTSTR    m_pName;
}
_view_msg_map[] =
{
    MAP_MSG(SFVM_MERGEMENU),
    MAP_MSG(SFVM_INVOKECOMMAND),
    MAP_MSG(SFVM_GETHELPTEXT),
    MAP_MSG(SFVM_GETTOOLTIPTEXT),
    MAP_MSG(SFVM_GETBUTTONINFO),
    MAP_MSG(SFVM_GETBUTTONS),
    MAP_MSG(SFVM_INITMENUPOPUP),
    MAP_MSG(SFVM_SELCHANGE),
    MAP_MSG(SFVM_DRAWITEM),
    MAP_MSG(SFVM_MEASUREITEM),
    MAP_MSG(SFVM_EXITMENULOOP),
    MAP_MSG(SFVM_PRERELEASE),
    MAP_MSG(SFVM_GETCCHMAX),
    MAP_MSG(SFVM_FSNOTIFY),
    MAP_MSG(SFVM_WINDOWCREATED),
    MAP_MSG(SFVM_WINDOWDESTROY),
    MAP_MSG(SFVM_REFRESH),
    MAP_MSG(SFVM_SETFOCUS),
    MAP_MSG(SFVM_QUERYCOPYHOOK),
    MAP_MSG(SFVM_NOTIFYCOPYHOOK),
    MAP_MSG(SFVM_GETDETAILSOF),
    MAP_MSG(SFVM_COLUMNCLICK),
    MAP_MSG(SFVM_QUERYFSNOTIFY),
    MAP_MSG(SFVM_DEFITEMCOUNT),
    MAP_MSG(SFVM_DEFVIEWMODE),
    MAP_MSG(SFVM_UNMERGEMENU),
    MAP_MSG(SFVM_INSERTITEM),
    MAP_MSG(SFVM_DELETEITEM),
    MAP_MSG(SFVM_UPDATESTATUSBAR),
    MAP_MSG(SFVM_BACKGROUNDENUM),
    MAP_MSG(SFVM_GETWORKINGDIR),
    MAP_MSG(SFVM_GETCOLSAVESTREAM),
    MAP_MSG(SFVM_SELECTALL),
    MAP_MSG(SFVM_DIDDRAGDROP),
    MAP_MSG(SFVM_SUPPORTSIDENTITY),
    MAP_MSG(SFVM_FOLDERISPARENT),
    MAP_MSG(SFVM_SETISFV),
    MAP_MSG(SFVM_GETVIEWS),
    MAP_MSG(SFVM_THISIDLIST),
    MAP_MSG(SFVM_GETITEMIDLIST),
    MAP_MSG(SFVM_SETITEMIDLIST),
    MAP_MSG(SFVM_INDEXOFITEMIDLIST),
    MAP_MSG(SFVM_ODFINDITEM),
    MAP_MSG(SFVM_HWNDMAIN),
    MAP_MSG(SFVM_ADDPROPERTYPAGES),
    MAP_MSG(SFVM_BACKGROUNDENUMDONE),
    MAP_MSG(SFVM_GETNOTIFY),
    MAP_MSG(SFVM_ARRANGE),
    MAP_MSG(SFVM_QUERYSTANDARDVIEWS),
    MAP_MSG(SFVM_QUERYREUSEEXTVIEW),
    MAP_MSG(SFVM_GETSORTDEFAULTS),
    MAP_MSG(SFVM_GETEMPTYTEXT),
    MAP_MSG(SFVM_GETITEMICONINDEX),
    MAP_MSG(SFVM_DONTCUSTOMIZE),
    MAP_MSG(SFVM_SIZE),
    MAP_MSG(SFVM_GETZONE),
    MAP_MSG(SFVM_GETPANE),
    MAP_MSG(SFVM_ISOWNERDATA),
    MAP_MSG(SFVM_GETODRANGEOBJECT),
    MAP_MSG(SFVM_ODCACHEHINT),
    MAP_MSG(SFVM_GETHELPTOPIC),
    MAP_MSG(SFVM_OVERRIDEITEMCOUNT),
    MAP_MSG(SFVM_GETHELPTEXTW),
    MAP_MSG(SFVM_GETTOOLTIPTEXTW),
    MAP_MSG(SFVM_GETIPERSISTHISTORY),
    MAP_MSG(SFVM_GETANIMATION),

};


const struct
{
    UINT       m_uMsg;
    LPCTSTR    m_pName;
}
_shcn_msg_map[] =
{
    MAP_MSG(SHCNE_RENAMEITEM),
    MAP_MSG(SHCNE_CREATE),
    MAP_MSG(SHCNE_DELETE),
    MAP_MSG(SHCNE_MKDIR),
    MAP_MSG(SHCNE_RMDIR),
    MAP_MSG(SHCNE_MEDIAINSERTED),
    MAP_MSG(SHCNE_MEDIAREMOVED),
    MAP_MSG(SHCNE_DRIVEREMOVED),
    MAP_MSG(SHCNE_DRIVEADD),
    MAP_MSG(SHCNE_NETSHARE),
    MAP_MSG(SHCNE_NETUNSHARE),
    MAP_MSG(SHCNE_ATTRIBUTES),
    MAP_MSG(SHCNE_UPDATEDIR),
    MAP_MSG(SHCNE_UPDATEITEM),
    MAP_MSG(SHCNE_SERVERDISCONNECT),
    MAP_MSG(SHCNE_UPDATEIMAGE),
    MAP_MSG(SHCNE_DRIVEADDGUI),
    MAP_MSG(SHCNE_RENAMEFOLDER),
    MAP_MSG(SHCNE_FREESPACE),
};




void DoTraceViewMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPCTSTR pName = NULL;
    TCHAR szBuffer[1024];
    TCHAR szTmp[25];
    TCHAR szTmp2[25];
    size_t i;
    UINT_PTR uDepth;
    GETDEPTH(uDepth);
    if (   uDepth < MAX_CALL_DEPTH )
    {
            for ( i = 0 ; i < ARRAYSIZE(_view_msg_map); i++ )
            {
                if ( _view_msg_map[i].m_uMsg == uMsg )
                {
                    pName = _view_msg_map[i].m_pName;
                    break;
                }
            }

            if (!pName)
            {
                wsprintf( szTmp, TEXT("SFVM_(%d)"), uMsg );
                pName = szTmp;
            }

            if (uMsg == SFVM_FSNOTIFY)
            {
                LPCTSTR pEvent = NULL;

                for (i= 0; i < ARRAYSIZE(_shcn_msg_map); i++)
                {
                    if ( _shcn_msg_map[i].m_uMsg == uMsg )
                    {
                        pEvent = _shcn_msg_map[i].m_pName;
                        break;
                    }
                }

                if (!pEvent)
                {
                    lstrcpy(szTmp2,TEXT("Unknown"));
                    pEvent = szTmp2;
                }

                wsprintf(szBuffer, TEXT("%s w(%08X) l(%08X == %s)"), pName, wParam, lParam, pEvent);
                _indent(uDepth+1, szBuffer);

            }
            else
            {
                wsprintf(szBuffer, TEXT("%s w(%08X) l(%08X)"), pName, wParam, lParam);
                _indent(uDepth+1, szBuffer);
            }
    }
}

const struct
{
    UINT       m_uMsg;
    LPCTSTR    m_pName;
}
_menu_msg_map[] =
{
    MAP_MSG(DFM_MERGECONTEXTMENU),
    MAP_MSG(DFM_INVOKECOMMAND),
    MAP_MSG(DFM_ADDREF),
    MAP_MSG(DFM_RELEASE),
    MAP_MSG(DFM_GETHELPTEXT),
    MAP_MSG(DFM_WM_MEASUREITEM),
    MAP_MSG(DFM_WM_DRAWITEM),
    MAP_MSG(DFM_WM_INITMENUPOPUP),
    MAP_MSG(DFM_VALIDATECMD),
    MAP_MSG(DFM_MERGECONTEXTMENU_TOP),
    MAP_MSG(DFM_GETHELPTEXTW),
    MAP_MSG(DFM_INVOKECOMMANDEX),
    MAP_MSG(DFM_MAPCOMMANDNAME),
    MAP_MSG(DFM_GETDEFSTATICID),
    MAP_MSG(DFM_GETVERBW),

};

const struct
{
    WPARAM     m_uMsg;
    LPCTSTR    m_pName;
}
_menu_invk_cmd_msg_map[] =
{
    MAP_MSG(DFM_CMD_RENAME),
    MAP_MSG(DFM_CMD_MODALPROP),
    MAP_MSG(DFM_CMD_PASTESPECIAL),
    MAP_MSG(DFM_CMD_PASTELINK),
    MAP_MSG(DFM_CMD_VIEWDETAILS),
    MAP_MSG(DFM_CMD_VIEWLIST),
    MAP_MSG(DFM_CMD_PASTE),
    MAP_MSG(DFM_CMD_NEWFOLDER),
    MAP_MSG(DFM_CMD_PROPERTIES),
    MAP_MSG(DFM_CMD_LINK),
    MAP_MSG(DFM_CMD_COPY),
    MAP_MSG(DFM_CMD_MOVE),
    MAP_MSG(DFM_CMD_DELETE),

};



void DoTraceMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPCTSTR pName = NULL;
    TCHAR szBuffer[1024];
    TCHAR szTmp[25];
    size_t i;
    UINT_PTR uDepth;
    GETDEPTH (uDepth);
    if (  uDepth < MAX_CALL_DEPTH  )
    {

            for ( i = 0 ; i < ARRAYSIZE(_menu_msg_map); i++ )
            {
                if ( _menu_msg_map[i].m_uMsg == uMsg )
                {
                    pName = _menu_msg_map[i].m_pName;
                    break;
                }
            }

            if (!pName)
            {
                wsprintf( szTmp, TEXT("DFM_(%d)"), uMsg );
                pName = szTmp;
            }

            if ((uMsg == DFM_INVOKECOMMAND) && (wParam >= DFM_CMD_RENAME))
            {
                wsprintf(szBuffer, TEXT("%s w(%s) l(%08X)"), pName, _menu_invk_cmd_msg_map[wParam-DFM_CMD_RENAME].m_pName, lParam);
            }
            else
            {
                wsprintf(szBuffer, TEXT("%s w(%08X) l(%08X)"), pName, wParam, lParam);
            }
            _indent(uDepth+1, szBuffer);

    }
}


/*-----------------------------------------------------------------------------
/ DoTraceAssert
/ -------------
/   Our assert handler, out faults it the trace mask as enabled assert
/   faulting.
/
/ In:
/   iLine = line
/   pFilename -> filename of the file we asserted in
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void DoTraceAssert(int iLine, LPTSTR pFilename)
{
    TCHAR szBuffer[1024];
    UINT_PTR uDepth;
    GETDEPTH(uDepth);

    wsprintf(szBuffer, TEXT("Assert failed in %s, line %d"), pFilename, iLine);

    _indent(uDepth+1, szBuffer);

    if ( g_dwTraceMask & TRACE_COMMON_ASSERT )
        DebugBreak();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\common\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

!include          $(PROJECT_ROOT)\ui\uienv.inc
EXT_DIR         = $(PROJECT_ROOT)\ui\shellext
NO_BROWSER_FILE = 1
TARGETNAME      = common
TARGETPATH      = $(PROJECT_ROOT)\ui\shellext\lib\$(PLATFORM_SUFFIX)
TARGETTYPE      = LIBRARY

!IF $(ALPHA)
USE_NTDLL=1
!ELSE
USE_NOLIBS=1
!ENDIF

INCLUDES=   $(INCLUDES); \
            $(EXT_DIR)\inc; \
            $(EXT_DIR)\src; \
            $(EXT_DIR)\common

SOURCES=    ..\debug.cpp   \
            ..\unknown.cpp \
            ..\dbmem.cpp   \
            ..\strings.cpp

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\inc\dbmem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dbmem.h
//
//--------------------------------------------------------------------------

#ifndef __dbmem_h
#define __dbmem_h

#ifdef DEBUG

//
// When building with debug then build in the debugging allocator
//

HLOCAL DebugLocalAlloc(UINT uFlags, SIZE_T cbSize);
HLOCAL DebugLocalFree(HLOCAL hLocal);

#define LocalAlloc(flags, size) DebugLocalAlloc(flags, size)
#define LocalFree(handle)       DebugLocalFree(handle)

#endif      // DEBUG
#endif      // __dbmem_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\inc\cunknown.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       unknown.h
//
//--------------------------------------------------------------------------

#ifndef _unknown_h
#define _unknown_h


// Global count of number of active objects

extern LONG g_cRefCount;
#define GLOBAL_REFCOUNT     (g_cRefCount)


// CUnknown

typedef struct
{
    const IID* piid;            // interface ID
    LPVOID  pvObject;           // pointer to the object
} INTERFACES, * LPINTERFACES;

class CUnknown
{
    protected:
        LONG m_cRefCount;

    public:
        CUnknown();


        STDMETHODIMP         HandleQueryInterface(REFIID riid, LPVOID* ppvObject, LPINTERFACES aInterfaces, int cif);
        STDMETHODIMP_(ULONG) HandleAddRef();
        STDMETHODIMP_(ULONG) HandleRelease();
    protected:
        virtual ~CUnknown();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\inc\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef __common_h
#define __common_h

//
// Avoid bringing in C runtime code for NO reason
//
#include "wianew.h"

#include "debug.h"
#include "dbmem.h"
#include "cunknown.h"
#include "strings.h"
#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif
#ifndef SIZEOF
#define SIZEOF(a)       sizeof(a)
#endif


/*-----------------------------------------------------------------------------
/ Flags to control the trace output from parts of the common library
/----------------------------------------------------------------------------*/
#define TRACE_COMMON_STR       0x80000000
#define TRACE_COMMON_ASSERT    0x40000000
#define TRACE_COMMON_MEMORY    0x20000000


/*-----------------------------------------------------------------------------
/ Exit macros for macro
/   - these assume that a label "exit_gracefully:" prefixes the prolog
/     to your function
/----------------------------------------------------------------------------*/
#define ExitGracefully(hr, result, text)            \
            { TraceMsg(text); hr = result; goto exit_gracefully; }

#define FailGracefully(hr, text)                    \
            { if ( FAILED(hr) ) { TraceMsg(text); goto exit_gracefully; } }


/*-----------------------------------------------------------------------------
/ Object / memory release macros
/----------------------------------------------------------------------------*/

#define DoRelease(pInterface)                       \
        { if ( pInterface ) { pInterface->Release(); pInterface = NULL; } }

#define DoILFree(pidl)                              \
        { if (pidl) {ILFree((LPITEMIDLIST)pidl); pidl = NULL;} }

#define DoLocalFree(p)                              \
        { if (p) {LocalFree((HLOCAL)p); p = NULL;} }

#define DoCloseHandle(h)                            \
        { if (h) {CloseHandle((HANDLE)h); h = NULL;} }

#define DoDelete(ptr)                               \
        { if (ptr) {delete ptr; ptr=NULL;}}

/*-----------------------------------------------------------------------------
/ String helper macros
/----------------------------------------------------------------------------*/
#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*SIZEOF(TCHAR))


/*-----------------------------------------------------------------------------
/ Other helpful macros
/----------------------------------------------------------------------------*/
#define ByteOffset(base, offset)                    \
        (((LPBYTE)base)+offset)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\common\unknown.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       unknown.cpp
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
/ Title;
/   unknown.cpp
/
/ Authors;
/   David De Vorchik (daviddv)
/
/ Notes;
/   Helper functions for handling IUnknown
/----------------------------------------------------------------------------*/
#include "precomp.hxx"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ CUnknown
/   Helper functions to aid the implementation of IUnknown within objects,
/   handles not only AddRef and Release, but also QueryInterface.
/----------------------------------------------------------------------------*/

LONG g_cRefCount = 0;          // global reference count

CUnknown::CUnknown()
{
    m_cRefCount = 1;
    InterlockedIncrement(&g_cRefCount);
}

CUnknown::~CUnknown()
{
    TraceAssert( m_cRefCount == 0 );
    InterlockedDecrement(&g_cRefCount);
}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleQueryInterface
/ ------------------------------
/   A table driven implementation of QueryInterface that scans through trying
/   to find a suitable match for the object.
/
/ In:
/   riid = interface being requested
/   ppvObject -> receives a pointer to the object
/   aIntefaces = array of interface descriptions
/   cif = number of interfaces in array
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
STDMETHODIMP CUnknown::HandleQueryInterface(REFIID riid, LPVOID* ppvObject, LPINTERFACES aInterfaces, int cif)
{
    HRESULT hr = S_OK;
    int i;

    TraceAssert(ppvObject);
    TraceAssert(aInterfaces);
    TraceAssert(cif);

    if (ppvObject)
    {
        *ppvObject = NULL;          // no interface yet
    }



    for ( i = 0; aInterfaces && ppvObject && (i != cif); i++ )
    {
        if ( IsEqualIID(riid, *aInterfaces[i].piid) || IsEqualIID(riid, IID_IUnknown) )
        {
            *ppvObject = aInterfaces[i].pvObject;
            goto exit_gracefully;
        }
    }

    hr = E_NOINTERFACE;         // failed.

exit_gracefully:

    if ( ppvObject && SUCCEEDED(hr) )
        ((LPUNKNOWN)*ppvObject)->AddRef();

    return hr;
}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleAddRef
/ ----------------------
/   Increase the objects reference count.  Global reference count increase
/   by the constructor.
/
/ In:
/   -
/ Out:
/   current reference count
/----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CUnknown::HandleAddRef()
{
    return InterlockedIncrement(&m_cRefCount);

}


/*-----------------------------------------------------------------------------
/ CUnknown::HandleRelease
/ -----------------------
/   Decrease the reference counts, when the objects reaches zero then
/   destroy it (which inturn will decrease the global reference count).
/
/ In:
/   -
/ Out:
/   current reference count == 0 if destroyed
/----------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) CUnknown::HandleRelease()
{
    ULONG cRefCount;

    cRefCount = InterlockedDecrement(&m_cRefCount);

    if ( cRefCount )
        return cRefCount;

    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\inc\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       debug.h
//
//--------------------------------------------------------------------------

#ifndef __debug_h
#define __debug_h




/*-----------------------------------------------------------------------------
/ Macros to ease the use of the debugging APIS.
/----------------------------------------------------------------------------*/

#if defined(DBG) || defined(DEBUG)

#ifndef DEBUG
#define DEBUG
#endif
extern DWORD g_dwTraceMask;
#else

#undef  DEBUG

#endif


#ifdef DEBUG
#define TraceSetMask(dwMask)    DoTraceSetMask(dwMask)
#define TraceEnter(dwMask, fn)  LPCTSTR _szf = TEXT(fn);BOOL DO_LOG=((dwMask) & g_dwTraceMask);if (DO_LOG) DoTraceEnter(dwMask, TEXT(fn))
#define TraceLeave              if (DO_LOG) DoTraceLeave

#define Trace                   if (DO_LOG) DoTrace
#define TraceMsg(s)             if (DO_LOG) DoTrace(TEXT(s))
#define TraceGUID(s, rGUID)     if (DO_LOG) DoTraceGUID(TEXT(s), rGUID)
#define TraceViewMsg(m, w, l)   if (DO_LOG) DoTraceViewMsg(m, w, l)
#define TraceMenuMsg(m, w, l)   if (DO_LOG) DoTraceMenuMsg(m, w, l)


/*-----------------------------------------------------------------------------
/ Debugging APIs (use the Macros, they make it easier and cope with correctly
/ removing debugging when it is disabled at built time).
/----------------------------------------------------------------------------*/
void DoTraceSetMask(DWORD dwMask);
void DoTraceEnter(DWORD dwMask, LPCTSTR pName);
void DoTraceLeave(void);
void DoTrace(LPCTSTR pFormat, ...);
void DoTraceGUID(LPCTSTR pPrefix, REFGUID rGUID);
void DoTraceViewMsg( UINT uMsg, WPARAM wParam, LPARAM lParam );
void DoTraceMenuMsg( UINT uMsg, WPARAM wParam, LPARAM lParam );
void DoTraceAssert(int iLine, LPTSTR pFilename);


#define TraceAssert(x) \
                { if ( !(x) ) DoTraceAssert(__LINE__, TEXT(__FILE__)); }

#define TraceLeaveResult(hr) \
             { HRESULT __hr = hr; if (FAILED(__hr)) Trace(TEXT("%s Failed (%08x)"), _szf, hr ); TraceLeave(); return __hr; }

#define TraceLeaveResultNoRet(hr) \
             { HRESULT __hr = hr; if (FAILED(__hr)) Trace(TEXT("Failed (%08x)"), hr); TraceLeave(); }

#define TraceLeaveVoid() \
              { TraceLeave(); return; }

#define TraceLeaveValue(value) \
              { TraceLeave(); return(value); }

#define TraceCheckResult(hr,x) \
             { HRESULT __hr = hr; if (FAILED(__hr)) DoTrace( TEXT("%s (hr=%08X)"), TEXT(x), hr ); }

#else

#define TraceSetMask(dwMask)
#define TraceEnter(dwMask, fn)
#define TraceLeave()

#define Trace if (FALSE)
#define TraceMsg(s)
#define TraceGUID(s, rGUID)
#define TraceViewMsg(m, w, l)
#define TraceMenuMsg(m, w, l)
#define TraceCheckResult(hr,x) { ; }


#define TraceAssert(x)
#define TraceLeaveResult(hr)    { return hr; }
#define TraceLeaveVoid()        { return; }
#define TraceLeaveValue(value)  { return(value); }
#define TraceLeaveResultNoRet(hr) { return; }
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\common\strings.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       strings.cpp
//
//--------------------------------------------------------------------------

/*----------------------------------------------------------------------------
/ Title;
/   strings.cpp
/
/ Authors;
/   Rick Turner (ricktu)
/
/ Notes;
/   Useful string manipulation functions.
/----------------------------------------------------------------------------*/
#include "precomp.hxx"
#pragma hdrstop


/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    HRESULT hr;

    TraceEnter(TRACE_COMMON_STR, "LocalAllocString");

    TraceAssert(ppResult);
    TraceAssert(pString);

    if ( !ppResult || !pString )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments");

    *ppResult = (LPTSTR)LocalAlloc(LPTR, StringByteSize(pString) );

    if ( !*ppResult )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate buffer");

    lstrcpy(*ppResult, pString);
    hr = S_OK;                          //  success

exit_gracefully:

    TraceLeaveResult(hr);
}


/*----------------------------------------------------------------------------
/ LocalAllocStringLen
/ ---------------------
/   Given a length return a buffer of that size.
/
/ In:
/   ppResult -> receives the pointer to the string
/   cLen = length in characters to allocate
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen)
{
    HRESULT hr;

    TraceEnter(TRACE_COMMON_STR, "LocalAllocStringLen");

    TraceAssert(ppResult);

    if ( !ppResult || cLen == 0 )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments (length or buffer)");

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (cLen+1) * SIZEOF(TCHAR));

    hr = *ppResult ? S_OK:E_OUTOFMEMORY;

exit_gracefully:

    TraceLeaveResult(hr);
}


/*-----------------------------------------------------------------------------
/ LocalFreeString
/ -----------------
/   Release the string pointed to be *ppString (which can be null) and
/   then reset the pointer back to NULL.
/
/ In:
/   ppString -> pointer to string pointer to be free'd
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void LocalFreeString(LPTSTR* ppString)
{
    TraceEnter(TRACE_COMMON_STR, "LocalFreeString");
    TraceAssert(ppString);

    if ( ppString )
    {
        if ( *ppString )
            LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }

    TraceLeave();
}



/*-----------------------------------------------------------------------------
/ StrRetFromString
/ -----------------
/   Package a WIDE string into a LPSTRRET structure.
/
/ In:
/   pStrRet -> receieves the newly allocate string
/   pString -> string to be copied.
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
HRESULT StrRetFromString(LPSTRRET lpStrRet, LPCWSTR pString)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_COMMON_STR, "StrRetFromString");
    Trace(TEXT("pStrRet %08x, lpszString -%ls-"), lpStrRet, pString);

    TraceAssert(lpStrRet);
    TraceAssert(pString);

    if (!lpStrRet || !pString)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        lpStrRet->pOleStr = reinterpret_cast<LPWSTR>(SHAlloc((wcslen(pString)+1)*sizeof(WCHAR)));
        if ( !(lpStrRet->pOleStr) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            lpStrRet->uType = STRRET_WSTR;
            wcscpy(lpStrRet->pOleStr, pString);
        }
    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\inc\imguids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       imguids.h
//
//--------------------------------------------------------------------------

#ifndef _IMGUIDS_H
#define _IMGUIDS_H

//
// {e211b736-43fd-11d1-9efb-0000f8757fcd}   CLSID_ImageExt
//

DEFINE_GUID(CLSID_ImageExt,
            0xE211B736, 0x43FD, 0x11D1,
            0x9E, 0xFB, 0x00, 0x00, 0xF8, 0x75, 0x7F, 0xCD);

DEFINE_GUID(CLSID_MyComputer,
            0x20D04FE0, 0x3AEA, 0x1069,
            0xA2, 0xD8, 0x08, 0x00, 0x2B, 0x30, 0x30, 0x9D);

DEFINE_GUID(CLSID_ThumbnailViewExt,
            0x8BEBB290, 0x52D0, 0x11D0,
            0xB7, 0xF4, 0x00, 0xC0, 0x4F, 0xD7, 0x06, 0xEC);

DEFINE_GUID(CLSID_DeviceImageExt,
            0xFB0C9C8A, 0x6C50, 0x11D1,
            0x9F, 0x1D, 0x00, 0x00, 0xF8, 0x75, 0x7F, 0xCD);

DEFINE_GUID(IID_IImageFolder,
            0x2acaf655, 0x4057, 0x45b9,
            0x8c, 0x36, 0x13, 0x12, 0xcb, 0x69, 0x28, 0x07);

DEFINE_GUID(CLSID_ShellEventCallback,
            0x2964ce36, 0xbb97, 0x11d2,
            0x80, 0x8f, 0x00, 0x80, 0x5f, 0x65, 0x96,0xd2);


DEFINE_GUID (CLSID_WiaCntxMenu,
             0x303e8f3a,0xdbd6,0x11d2,
             0x80,0xb4,0x00,0x80,0x5f,0x65,0x96,0xd2);
#endif // _IMGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\inc\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef __strings_h
#define __strings_h

HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString);
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen);
void    LocalFreeString(LPTSTR* ppString);

HRESULT StrRetFromString(LPSTRRET lpStrRet, LPCWSTR pString);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\baseview.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       baseview.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      DavidShi
 *
 *  DATE:        3/1/99
 *
 *  DESCRIPTION: Definition for CBaseView class
 *
 *****************************************************************************/

#ifndef __baseview_h
#define __baseview_h

#define SHCNE_DEVICE_DISCONNECT 0x0FFFFFFF

struct EVENTDATA
    {
        const GUID *pEventGuid;
        IUnknown *pUnk;
    };
class CBaseView : public IShellFolderViewCB, public IObjectWithSite, public IWiaEventCallback, public CUnknown
{
public:
    CBaseView (CImageFolder *pFolder, folder_type ft = FOLDER_IS_ROOT);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellFolderViewCB
    STDMETHOD(MessageSFVCB)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IObjectWithSite
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppv);
    STDMETHOD(ImageEventCallback)(const GUID __RPC_FAR *pEventGUID,
                                      BSTR bstrEventDescription,
                                      BSTR bstrDeviceID,
                                      BSTR bstrDeviceDescription,
                                      DWORD dwDeviceType,
                                      BSTR bstrFullItemName,
                                      ULONG *pulEventType,
                                      ULONG ulReserved)=0;


protected:
    virtual ~CBaseView ();

private:

    // must be set by the subclasses
    virtual EVENTDATA *GetEvents(){return NULL;};
    virtual BSTR GetEventDevice (){return NULL;};
    VOID RegisterDeviceEvents ();
    VOID UnregisterDeviceEvents ();
    // derived classes implement HandleMessage, not MessageSFVCB
    virtual
    HRESULT
    HandleMessage (UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;

    HRESULT
    OnSFVM_GetViewInfo (WPARAM wp, SFVM_VIEWINFO_DATA * lp);

    HRESULT
    OnSFVM_GetNotify (WPARAM wp, LPARAM lp);

    HRESULT
    OnSFVM_Refresh (BOOL fPreOrPost);

    HRESULT
    OnSFVM_InvokeCommand (WPARAM wp, LPARAM lp);

    HRESULT
    OnSFVM_GetHelpText (WPARAM wp, LPARAM lp);

protected:
    CComPtr<IShellBrowser> m_psb;
    CComPtr<IShellFolderView> m_psfv;
    HWND m_hwnd;
    CImageFolder *m_pFolder;
    EVENTDATA *m_pEvents;
    folder_type m_type;
};

// CRootView is a view on the root of our namespace
class CRootView : public CBaseView
{

public:
    CRootView (CImageFolder *pFolder)  : CBaseView (pFolder) {};

    STDMETHOD(ImageEventCallback)(const GUID __RPC_FAR *pEventGUID,
                                      BSTR bstrEventDescription,
                                      BSTR bstrDeviceID,
                                      BSTR bstrDeviceDescription,
                                      DWORD dwDeviceType,
                                      BSTR bstrFullItemName,
                                      ULONG *pulEventType,
                                      ULONG ulReserved);

    static HRESULT SupportsWizard(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState);
    static HRESULT SupportsProperties(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState);
    static HRESULT InvokeWizard(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT InvokeProperties(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT AddDevice(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc);

private:
    HRESULT
    HandleMessage (UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT
    OnSFVM_InsertItem (LPITEMIDLIST pidl);

    HRESULT
    OnSFVM_GetHelpTopic (WPARAM wp, LPARAM lp);

    HRESULT
    OnSFVM_GetWebviewLayout(WPARAM wp, SFVM_WEBVIEW_LAYOUT_DATA* pData);

    HRESULT
    OnSFVM_GetWebviewContent(SFVM_WEBVIEW_CONTENT_DATA* pData);

    HRESULT
    OnSFVM_GetWebviewTasks(SFVM_WEBVIEW_TASKSECTION_DATA* pData);


    EVENTDATA *
    GetEvents ();
};

// CCameraView is a view on a folder within a camera
class CCameraView : public CBaseView
{
public:
    CCameraView (CImageFolder *pFolder, LPCWSTR szDeviceId, folder_type ft);

    STDMETHOD(ImageEventCallback)(const GUID __RPC_FAR *pEventGUID,
                                      BSTR bstrEventDescription,
                                      BSTR bstrDeviceID,
                                      BSTR bstrDeviceDescription,
                                      DWORD dwDeviceType,
                                      BSTR bstrFullItemName,
                                      ULONG *pulEventType,
                                      ULONG ulReserved);

    static HRESULT SupportsSnapshot(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState);
    static HRESULT SupportsWizard(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState);
    static HRESULT InvokeWizard(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT InvokeSnapshot(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT InvokeProperties(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT InvokeDeleteAll(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc);

private:

    ~CCameraView ();

    HRESULT
    HandleMessage (UINT uMsg, WPARAM wParam, LPARAM lParam);


    HRESULT
    OnSFVM_GetAnimation (WPARAM wp, LPARAM lp);

    HRESULT
    OnSFVM_FsNotify (LPCITEMIDLIST pidl, LPARAM lEvent);

    HRESULT
    OnSFVM_InsertItem (LPITEMIDLIST pidl);

    HRESULT
    OnSFVM_GetWebviewLayout(WPARAM wp, SFVM_WEBVIEW_LAYOUT_DATA* pData);

    HRESULT
    OnSFVM_GetWebviewContent(SFVM_WEBVIEW_CONTENT_DATA* pData);

    HRESULT
    OnSFVM_GetWebviewTasks(SFVM_WEBVIEW_TASKSECTION_DATA* pData);

    EVENTDATA*
    GetEvents ();

    BSTR
    GetEventDevice() {return (BSTR)m_strDeviceId;};

    CComBSTR m_strDeviceId;

    DWORD       m_dwCookie;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\baseview.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 2001
 *
 *  TITLE:       baseview.cpp
 *
 *
 *  DESCRIPTION: This code implements the a base class and derived classes
 *               that handle view related messages.
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop
#include "wiaview.h"

DEFINE_GUID(CLSID_VideoPreview,0x457A23DF,0x6F2A,0x4684,0x91,0xD0,0x31,0x7F,0xB7,0x68,0xD8,0x7C);
// d82237ec-5be9-4760-b950-b7afa51b0ba9
DEFINE_GUID(IID_IVideoPreview, 0xd82237ec,0x5be9,0x4760,0xb9,0x50,0xb7,0xaf,0xa5,0x1b,0x0b,0xa9);


BOOL    _CanTakePicture (CImageFolder *pFolder, LPITEMIDLIST pidl);


/*****************************************************************************

   CBaseView constructor / destructor

   Stores / releases the folder pointer

 *****************************************************************************/

CBaseView::CBaseView (CImageFolder *pFolder, folder_type ft)
{
    TraceEnter (TRACE_VIEW, "CBaseView::CBaseView");
    m_pFolder= pFolder;
    m_pFolder->AddRef();
    m_pEvents = NULL;
    m_type = ft;
    TraceLeave ();
}


CBaseView::~CBaseView ()
{
    TraceEnter (TRACE_VIEW, "CBaseView::~CBaseView");
    DoRelease (m_pFolder);

    TraceLeave ();
}


/*****************************************************************************

   CBaseView::IUnknown stuff

   Use our common implementation of IUnknown methods

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CBaseView
#include "unknown.inc"


/*****************************************************************************

   CBaseView::QI Wrapper

   Use our common implementation of QI.

 *****************************************************************************/

STDMETHODIMP
CBaseView::QueryInterface (REFIID riid, LPVOID *ppv)
{
    HRESULT hr;

    TraceEnter( TRACE_QI, "CBaseView::QueryInterface" );
    TraceGUID("Interface requested", riid);

    INTERFACES iface[] =
    {
        &IID_IShellFolderViewCB,static_cast<IShellFolderViewCB*>( this),
        &IID_IObjectWithSite,   static_cast<IObjectWithSite*> (this),
        &IID_IWiaEventCallback, static_cast<IWiaEventCallback*> (this)
    };


    hr = HandleQueryInterface(riid, ppv, iface, ARRAYSIZE(iface));

    TraceLeaveResult(hr);

}


/*****************************************************************************

   CBaseView::MessageSFVCB

   Passes view callback messages to the derived class.
   Handles any messages not handled by the derived class.

 *****************************************************************************/

STDMETHODIMP
CBaseView::MessageSFVCB (UINT msg, WPARAM wp, LPARAM lp)
{
    HRESULT hr;
    TraceEnter (TRACE_VIEW, "CBaseView::MessageSFVCB");

    // get the shell browser
    if (!m_psb)
    {
        // Attempt to get IShellBrowser
        CComQIPtr <IServiceProvider, &IID_IServiceProvider> psp(m_psfv);
        if (psp.p)
        {
            psp->QueryService (SID_STopLevelBrowser,
                               IID_IShellBrowser,
                               reinterpret_cast<LPVOID*>(&m_psb));
        }
    }
    // Give the derived class the first look
    hr = HandleMessage (msg, wp, lp);
    // if not handled by the derived class, try our default processing.
    // E_NOTIMPL may mean the derived class processed it but still
    // wants the default processing too
    if (E_NOTIMPL == hr )
    {
        hr = S_OK;
        switch (msg)
        {

            case SFVM_GETVIEWINFO:
                hr = OnSFVM_GetViewInfo (wp, reinterpret_cast<SFVM_VIEWINFO_DATA *>(lp));
                break;

            case SFVM_REFRESH:
                hr = OnSFVM_Refresh (static_cast<BOOL>(wp));
                break;

            case SFVM_GETNOTIFY:
                hr = OnSFVM_GetNotify (wp, lp);
                break;

            case SFVM_INVOKECOMMAND:
                hr = OnSFVM_InvokeCommand (wp, lp);
                break;

            case SFVM_GETHELPTEXT:
                hr = OnSFVM_GetHelpText (wp, lp);
                break;

            case SFVM_BACKGROUNDENUM:

                break;

            case SFVM_QUERYSTANDARDVIEWS:
                *(reinterpret_cast<BOOL *>(lp)) = TRUE;
                break;

            case SFVM_DONTCUSTOMIZE:
                *reinterpret_cast<BOOL *>(lp) = FALSE;

                break;

            case SFVM_WINDOWCREATED:
                m_hwnd = reinterpret_cast<HWND>(wp);
                m_pFolder->ViewWindow(&m_hwnd);
                RegisterDeviceEvents ();
                break;

            case SFVM_WINDOWDESTROY:
                m_hwnd = reinterpret_cast<HWND>(wp);
                TraceAssert (m_hwnd);
                m_hwnd = NULL;
                UnregisterDeviceEvents ();
                break;


            default:
                hr = E_NOTIMPL;
                break;
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************

CBaseView::OnSFVM_Refresh

When the view is about to refresh by user choice, invalidate the cache

******************************************************************************/

HRESULT
CBaseView::OnSFVM_Refresh (BOOL fPreOrPost)
{
    TraceEnter (TRACE_VIEW, "CBaseView::OnSFVM_Refresh");
    if (fPreOrPost) // Pre
    {
        // invalidate the cache
        InvalidateDeviceCache ();

    }
    TraceLeaveResult (S_OK);
}
/*****************************************************************************

   CBaseView::SetSite

   Lets us know what view we correspond to

 *****************************************************************************/

STDMETHODIMP
CBaseView::SetSite (IUnknown *punkSite)
{
    HRESULT hr = NOERROR;
    TraceEnter (TRACE_VIEW, "CBaseView::SetSite");


    if (punkSite)
    {
        m_psfv = NULL;
        hr = punkSite->QueryInterface (IID_IShellFolderView,
                                  reinterpret_cast<LPVOID*>(&m_psfv));

    }
    else
    {
        m_psfv.Release();
    }

    TraceLeaveResult (hr);
}


/*****************************************************************************

   CBaseView::GetSite

   Called to get an interface pointer of our view

 *****************************************************************************/

STDMETHODIMP
CBaseView::GetSite (REFIID riid, LPVOID *ppv)
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_VIEW, "CBaseView::GetSite");
    *ppv = NULL;
    if (m_psfv)
    {
        hr = m_psfv->QueryInterface (riid, ppv);
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CBaseView::OnSFVM_GetNotify

   Returns the mask of the SHChangeNotify flags we want to know about.
   Maybe we shouldn't implement this? The default or thumbnail view
   ends up processing our notifications for us anyway.

 *****************************************************************************/

HRESULT
CBaseView::OnSFVM_GetNotify (WPARAM wp, LPARAM lp)
{

    HRESULT hr = S_OK;
    TraceEnter (TRACE_VIEW, "CBaseView::OnSFVM_GetNotify");
    *reinterpret_cast<LPVOID*>(wp) = NULL;
    *reinterpret_cast<LPLONG>(lp)  = SHCNE_DELETE     | SHCNE_CREATE      |
                                     SHCNE_UPDATEITEM | SHCNE_UPDATEIMAGE |
                                     SHCNE_UPDATEDIR  | SHCNE_ATTRIBUTES;
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CBaseView::OnSFVM_InvokeCommand

   Called when the user chooses an item in the View menu

 *****************************************************************************/

HRESULT
CBaseView::OnSFVM_InvokeCommand (WPARAM wp, LPARAM lp)
{
    UINT idCmd = static_cast<UINT>(wp);
    HRESULT hr = S_OK;
    TraceEnter (TRACE_VIEW, "CBaseView::OnSFVM_InvokeCommand");
    switch ( idCmd )
    {
        case IMVMID_ARRANGEBYNAME:
        case IMVMID_ARRANGEBYCLASS:
        case IMVMID_ARRANGEBYSIZE:
        case IMVMID_ARRANGEBYDATE:
            ShellFolderView_ReArrange(m_hwnd, idCmd);
            break;

        default:
            hr = E_NOTIMPL;
            break;
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CBaseView::OnSFVM_GetHelpText

   Provides help text for items in the view menu

 *****************************************************************************/

HRESULT
CBaseView::OnSFVM_GetHelpText (WPARAM wp, LPARAM lp)
{
    HRESULT hr = S_OK;

    TraceEnter (TRACE_VIEW, "CBaseView::OnSFVM_GetHelpText");
    switch ( LOWORD(wp) )
    {
        case IMVMID_ARRANGEBYNAME:
            LoadString(GLOBAL_HINSTANCE, IDS_BYOBJECTNAME, (LPTSTR)lp, HIWORD(wp));
            break;

        case IMVMID_ARRANGEBYCLASS:
            LoadString(GLOBAL_HINSTANCE, IDS_BYTYPE, (LPTSTR)lp, HIWORD(wp));
            break;

        case IMVMID_ARRANGEBYDATE:
            LoadString(GLOBAL_HINSTANCE, IDS_BYDATE, (LPTSTR)lp, HIWORD(wp));
            break;

        case IMVMID_ARRANGEBYSIZE:
            LoadString(GLOBAL_HINSTANCE, IDS_BYSIZE, (LPTSTR)lp, HIWORD(wp));
            break;

        default:
            hr = E_NOTIMPL;
            break;
    }
    TraceLeaveResult (hr);
}

VOID
CBaseView::RegisterDeviceEvents ()
{
    TraceEnter(TRACE_VIEW, "CBaseView::RegisterDeviceEvents");

    // quit if we're already registered
    if (!m_pEvents)
    {
        m_pEvents = GetEvents ();
        if (m_pEvents)
        {
            HRESULT hr;
            CComPtr<IWiaDevMgr> pDevMgr;
            hr = GetDevMgrObject (reinterpret_cast<LPVOID*>(&pDevMgr));
            for (int i=0;SUCCEEDED(hr) && m_pEvents[i].pEventGuid;i++)
            {
                hr = pDevMgr->RegisterEventCallbackInterface (WIA_REGISTER_EVENT_CALLBACK,
                                                      GetEventDevice(),
                                                      m_pEvents[i].pEventGuid,
                                                      this,
                                                      &m_pEvents[i].pUnk);
            }
        }
    }
    TraceLeave ();
}

VOID
CBaseView::UnregisterDeviceEvents()
{
    TraceEnter (TRACE_VIEW, "CBaseView::UnregisterDeviceEvents");
    if (m_pEvents)
    {
        for (int i=0;m_pEvents[i].pEventGuid;i++)
        {
            DoRelease (m_pEvents[i].pUnk);
        }
        delete [] m_pEvents;
    }
    TraceLeave ();
}
/*****************************************************************************

   CCameraView constructor / destructor


 *****************************************************************************/

CCameraView::CCameraView (CImageFolder *pFolder, LPCWSTR szDeviceId, folder_type ft)
             : CBaseView (pFolder, ft)
{
    m_strDeviceId = szDeviceId;
    m_dwCookie = -1;
}

CCameraView::~CCameraView ()
{

}


/*****************************************************************************

   CCameraView::HandleMessage

   <Notes>

 *****************************************************************************/
#ifndef SFVM_FORCEWEBVIEW
#define SFVM_FORCEWEBVIEW 75
#endif

HRESULT
CCameraView::HandleMessage (UINT uMsg, WPARAM wp, LPARAM lp)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_VIEW, "CCameraView::HandleMessage");
    TraceViewMsg (uMsg, wp, lp);
    switch (uMsg)
    {

        case SFVM_GETANIMATION:
            hr = OnSFVM_GetAnimation (wp, lp);
            break;


        case SFVM_FSNOTIFY:
            hr = OnSFVM_FsNotify (reinterpret_cast<LPCITEMIDLIST>(wp), lp);
            break;

        case SFVM_DELETEITEM:
            hr = S_OK;
            break;


//        case SFVM_INSERTITEM:
  //          hr = OnSFVM_InsertItem (reinterpret_cast<LPITEMIDLIST>(lp));
    //        break;

        case SFVM_FORCEWEBVIEW:
            // always use web view on video devices
            if (m_type == FOLDER_IS_VIDEO_DEVICE)
            {
                *(reinterpret_cast<BOOL*>(wp)) = TRUE;
            }
            else
            {
                hr = E_FAIL;
            }

            break;

        case SFVM_DEFVIEWMODE:
            {
                FOLDERVIEWMODE *pMode = reinterpret_cast<FOLDERVIEWMODE*>(lp);
                *pMode = FVM_THUMBNAIL;
            }
            break;
        // hide filenames in thumbnail view
        case SFVM_FOLDERSETTINGSFLAGS:
            *reinterpret_cast<DWORD*>(lp) |= FWF_HIDEFILENAMES;
            break;

        case SFVM_GETWEBVIEWLAYOUT:
            hr = OnSFVM_GetWebviewLayout(wp, reinterpret_cast<SFVM_WEBVIEW_LAYOUT_DATA*>(lp));
            break;

        case SFVM_GETWEBVIEWCONTENT:
            hr = OnSFVM_GetWebviewContent(reinterpret_cast<SFVM_WEBVIEW_CONTENT_DATA*>(lp));
            break;

        case SFVM_GETWEBVIEWTASKS:
            hr = OnSFVM_GetWebviewTasks(reinterpret_cast<SFVM_WEBVIEW_TASKSECTION_DATA*>(lp));
            break;

        default:
            hr = E_NOTIMPL;
            break;

    }

    TraceLeaveResult (hr);
}


/*****************************************************************************

   CCameraView::OnSFVM_GetAnimation

   Return an AVI for the shell to show while it waits for us
   to show thumbnails

 *****************************************************************************/

HRESULT
CCameraView::OnSFVM_GetAnimation (WPARAM wp, LPARAM lp)
{

    HRESULT hr = S_OK;
    TraceEnter (TRACE_VIEW, "CCameraView::OnSFVM_GetAnimation");
    if (wp && lp)
    {
        *(reinterpret_cast<HINSTANCE *>(wp)) = GLOBAL_HINSTANCE;
        lstrcpyW( reinterpret_cast<LPWSTR>(lp), L"CAMERA_CONNECT_AVI" );
    }
    TraceLeaveResult( hr );
}


/*****************************************************************************

   CBaseView::OnSFVM_GetViewInfo

   Returns the set of views we support

 *****************************************************************************/

HRESULT
CBaseView::OnSFVM_GetViewInfo (WPARAM mode, SFVM_VIEWINFO_DATA *pData)
{
    HRESULT hr = S_OK;


    TraceEnter (TRACE_VIEW, "CBaseView::OnSFVM_GetViewInfo");

    ZeroMemory(pData, sizeof(*pData));
    // we support every view
    pData->dwOptions = SFVMQVI_NORMAL;
    Trace(TEXT("bWantWebView: %d, dwOptions: %d, szWebView: %ls"),
          pData->bWantWebview, pData->dwOptions, pData->szWebView);
    TraceLeaveResult (hr);
}




/*****************************************************************************

CCameraView::OnSFVM_FsNotify

When the user takes a picture using the web view or some other external code
manipulates the camera, it should call SHChangeNotify to let the shell
know what happened. We handle the update here. For device disconnect, we
dismiss the view and return to the Scanners and Cameras folder or My Computer

*****************************************************************************/

HRESULT
CCameraView::OnSFVM_FsNotify (LPCITEMIDLIST pidl, LPARAM lEvent)
{
    HRESULT hr = E_NOTIMPL;
    TraceEnter (TRACE_VIEW, "CCameraView::OnSFVM_FsNotify");

    TraceLeaveResult (hr);
}

enum ViewAction
{
    Disconnect=0, Delete,Create,NoAction
};

STDMETHODIMP
CCameraView::ImageEventCallback (const GUID __RPC_FAR *pEventGUID,
                                      BSTR bstrEventDescription,
                                      BSTR bstrDeviceID,
                                      BSTR bstrDeviceDescription,
                                      DWORD dwDeviceType,
                                      BSTR bstrFullItemName,
                                      ULONG *pulEventType,
                                      ULONG ulReserved)
{
    TraceEnter (TRACE_VIEW, "CCameraView::ImageEventCallback");
    ViewAction act = NoAction;

    if (IsEqualGUID(*pEventGUID, WIA_EVENT_DEVICE_DISCONNECTED) &&
        !wcscmp(m_strDeviceId, bstrDeviceID))
    {

        LPITEMIDLIST pidlRootFolder;
        if (SUCCEEDED(SHGetSpecialFolderLocation (NULL, CSIDL_DRIVES, &pidlRootFolder)))
        {
            if (m_psb.p)
            {
                m_psb->BrowseObject (const_cast<LPCITEMIDLIST>(pidlRootFolder),
                                     SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
            }
            ILFree (pidlRootFolder);
        }
        act = Disconnect;
        InvalidateDeviceCache();
    }
    else if (IsEqualGUID (*pEventGUID, WIA_EVENT_ITEM_DELETED))
    {
        act = Delete;
    }
    else if (IsEqualGUID(*pEventGUID, WIA_EVENT_ITEM_CREATED))
    {
        act = Create;
    }

    // Even though the WIA event info has the name of the item that was
    // added or deleted, we can't rely on it being the only new or deleted item.
    //  Therefore if we get one we can make sure the folder is up to date,
    // but we don't do a more specific SHChangeNotify because we have to do
    // one from our TakeAPicture and RemoveItem functions and want to avoid
    // duplicate creates/deletes.
    if (NoAction != act)
    {
        LPITEMIDLIST pidlFolder;
        m_pFolder->GetCurFolder (&pidlFolder);
        if (pidlFolder)
        {
            SHChangeNotify ((Disconnect == act) ? SHCNE_DELETE : SHCNE_UPDATEDIR,
                SHCNF_IDLIST,
                pidlFolder, 0);
            ILFree (pidlFolder);
        }
    }
    TraceLeaveResult (S_OK);
}


/*****************************************************************************
    CCameraView::OnSFVM_InsertItem

    Reject attempts to insert pidls that don't belong here

*****************************************************************************/
HRESULT
CCameraView::OnSFVM_InsertItem (LPITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_VIEW, "CCameraView::OnSFVM_InsertItem");
    if (!IsCameraItemIDL(pidl))
    {
        hr = S_FALSE;
    }
    else
    {
        // verify the path to this item is the same as the path to the folder
        CComBSTR strPath;
        LPITEMIDLIST pidlFolder;
        CComBSTR strPathFolder;
        UINT nFolder;
        UINT nItem;

        IMGetFullPathNameFromIDL (pidl, &strPath);
        m_pFolder->GetPidl (&pidlFolder);
        pidlFolder = ILFindLastID(pidlFolder);
        if (IsDeviceIDL(pidlFolder))
        {
            CSimpleStringWide strDeviceId;
            CSimpleStringWide strP;
            IMGetDeviceIdFromIDL (pidlFolder, strDeviceId);
            strP = strDeviceId.SubStr(strDeviceId.Find(L'\\')+1);
            strP.Concat ( L"\\Root");
            strPathFolder = strP;
        }
        else
        {
            IMGetFullPathNameFromIDL (pidlFolder, &strPathFolder);
        }

        nFolder = SysStringLen (strPathFolder);


        Trace(TEXT("Trying to add %ls to %ls"), strPath, strPathFolder);
        // verify folder path shorter than strpath
        if (nFolder >= SysStringLen (strPath))
        {
            hr = S_FALSE;
        }
        // verify folderpath matches strPath
        else if (_wcsnicmp (strPathFolder, strPath, nFolder))
        {
            hr = S_FALSE;
        }
        // verify strPath-FolderPath == itemname
        else
        {
            CSimpleStringWide strName;
            IMGetNameFromIDL (pidl, strName);

            nItem = strName.Length();

            // check that folderPath+itemName+'\' == strPath
            if (nItem+nFolder+1 != SysStringLen (strPath) )
            {
                hr = S_FALSE;
            }
        }
    }
    Trace(TEXT("Returning %d"), hr);
    TraceLeaveResult (hr);
}

static const WVTASKITEM c_CameraTasksHeader =
    WVTI_HEADER(L"wiashext.dll", IDS_CAMERA_TASKS_HEADER, IDS_CAMERA_TASKS_HEADER);

static const WVTASKITEM c_CameraTasks[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"wiashext.dll", IDS_USE_WIZARD, IDS_USE_WIZARD, IDI_USE_WIZARD, CCameraView::SupportsWizard, CCameraView::InvokeWizard),
    WVTI_ENTRY_ALL(CLSID_NULL, L"wiashext.dll", IDS_TAKE_PICTURE, IDS_TAKE_PICTURE, IDI_TAKE_PICTURE, CCameraView::SupportsSnapshot, CCameraView::InvokeSnapshot),
    WVTI_ENTRY_ALL(CLSID_NULL, L"wiashext.dll", IDS_CAMERA_PROPERTIES, IDS_CAMERA_PROPERTIES, IDI_SHOW_PROPERTIES, CCameraView::SupportsWizard, CCameraView::InvokeProperties),
    WVTI_ENTRY_ALL(CLSID_NULL, L"wiashext.dll", IDS_DELETE_ALL, IDS_DELETE_ALL, IDI_DELETE_ALL_IMAGES, NULL, CCameraView::InvokeDeleteAll),
};


HRESULT
CCameraView::OnSFVM_GetWebviewLayout(WPARAM wp, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    TraceEnter(TRACE_VIEW, "CCameraView::OnSFVM_GetWebviewLayout");
    //
    // set reasonable defaults
    //
    pData->dwLayout = SFVMWVL_FILES ;
    pData->punkPreview = NULL;
    if (FOLDER_IS_VIDEO_DEVICE == m_type)
    {
        CComPtr<IVideoPreview> pPreview;

        if (SUCCEEDED(CoCreateInstance(CLSID_VideoPreview, NULL, CLSCTX_INPROC_SERVER, IID_IVideoPreview, reinterpret_cast<LPVOID*>(&pPreview))))
        {
            LPITEMIDLIST pidl;
            CComPtr<IWiaItem> pItem;
            m_pFolder->GetPidl(&pidl);
            CSimpleStringWide strDeviceId;
            IMGetDeviceIdFromIDL(ILFindLastID(pidl), strDeviceId);
            if (SUCCEEDED(GetDeviceFromDeviceId(strDeviceId, IID_IWiaItem, reinterpret_cast<LPVOID*>(&pItem), FALSE)))
            {
                if (SUCCEEDED(pPreview->Device(pItem)))
                {
                    pData->dwLayout |= SFVMWVL_PREVIEW;
                    pPreview->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>(&pData->punkPreview));
                }
            }
        }
    }
    TraceLeaveResult(S_OK);
}


HRESULT
CCameraView::OnSFVM_GetWebviewContent(SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    TraceEnter(TRACE_VIEW, "CCameraView::OnSFVM_GetWebviewContent");
    ZeroMemory(pData, sizeof(*pData));
    Create_IUIElement(&c_CameraTasksHeader, &pData->pSpecialTaskHeader);
    TraceLeaveResult(S_OK);
}

HRESULT
CCameraView::OnSFVM_GetWebviewTasks(SFVM_WEBVIEW_TASKSECTION_DATA* pData)
{
    TraceEnter(TRACE_VIEW, "CCameraView::OnSFVM_GetWebviewTasks");
    IUnknown *pUnk;
    m_pFolder->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>(&pUnk));
    Create_IEnumUICommand(pUnk, c_CameraTasks, ARRAYSIZE(c_CameraTasks), &pData->penumSpecialTasks);
    DoRelease(pUnk);
    pData->penumFolderTasks = NULL;
    pData->dwUpdateFlags = SFVMWVTSDF_CONTENTSCHANGE; // make details update when contents change
    TraceLeaveResult(S_OK);
}

HRESULT
CCameraView::SupportsWizard(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState)
{
    CComQIPtr<IImageFolder, &IID_IImageFolder> pFolder(punk);
    folder_type type = FOLDER_IS_UNKNOWN;
    *puiState = UIS_HIDDEN;
    if (pFolder.p)
    {
        pFolder->GetFolderType(&type);
    }
    if (FOLDER_IS_CAMERA_DEVICE == type)
    {
        *puiState = UIS_ENABLED;
    }
    return S_OK;
}

HRESULT
CCameraView::SupportsSnapshot(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState)
{
    CComQIPtr<IImageFolder, &IID_IImageFolder> pFolder(punk);
    LPITEMIDLIST pidl = NULL;
    if (pFolder.p)
    {
        pFolder->GetPidl(&pidl);
        if (pidl)
        {
            pidl = ILFindLastID(pidl);
            if (pidl)
            {
                if (_CanTakePicture(NULL, pidl))
                {
                    if (puiState)
                    {
                        *puiState = UIS_ENABLED;
                    }
                }
            }
        }
    }
    return S_OK;
}


// These invoke functions have a ton of common code, should try to
// optimize these later
//
HRESULT
CCameraView::InvokeWizard(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    //
    // To prevent reentrancy into the shell via COM's message loop, run
    // the wiz on a background thread
    CComQIPtr<IImageFolder, &IID_IImageFolder> pFolder(punk);
    LPITEMIDLIST pidl = NULL;
    CSimpleStringWide strDeviceId;
    if (pFolder.p)
    {
        pFolder->GetPidl(&pidl);
        if (pidl)
        {
            pidl = ILFindLastID(pidl);
            if (pidl)
            {
                IMGetDeviceIdFromIDL(pidl, strDeviceId);
                RunWizardAsync(strDeviceId);                
            }
        }
    }
    return S_OK;
}

INT_PTR TakePictureDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

HRESULT
CCameraView::InvokeSnapshot(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CComQIPtr<IImageFolder, &IID_IImageFolder> pFolder(punk);
    LPITEMIDLIST pidl = NULL;
    CSimpleStringWide strDeviceId;
    if (pFolder.p)
    {
        pFolder->GetPidl(&pidl);
        if (pidl)
        {
            pidl = ILFindLastID(pidl);
            if (pidl)
            {
                IMGetDeviceIdFromIDL (pidl, strDeviceId);
                CreateDialogParam (GLOBAL_HINSTANCE,
                                   MAKEINTRESOURCE(IDD_TAKEPICTURE),
                                   NULL,
                                   TakePictureDlgProc,
                                   reinterpret_cast<LPARAM>(SysAllocString(strDeviceId)));
            }
        }
    }
    return S_OK;
}

HRESULT
CCameraView::InvokeProperties(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CComQIPtr<IImageFolder, &IID_IImageFolder> pFolder(punk);
    LPITEMIDLIST pidl = NULL;
    SHELLEXECUTEINFO sei = {0};

    if (pFolder.p)
    {
        pFolder->GetPidl(&pidl);
        if (pidl)
        {
            sei.cbSize = sizeof(sei);
            sei.lpIDList = pidl;
            sei.fMask = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST;
            sei.lpVerb = TEXT("properties");
            return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
        }
    }

    return E_FAIL;
}


HRESULT
CCameraView::InvokeDeleteAll(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CComQIPtr<IImageFolder, &IID_IImageFolder> pFolder(punk);
    LPITEMIDLIST pidl = NULL;
    CSimpleStringWide strDeviceId;
    if (pFolder.p)
    {
        pFolder->GetPidl(&pidl);
        if (pidl)
        {
            pidl = ILFindLastID(pidl);
            if (pidl)
            {
                HWND hwnd = NULL;
                pFolder->ViewWindow(&hwnd);
                IMGetDeviceIdFromIDL (pidl, strDeviceId);
                DoDeleteAllItems(CComBSTR(strDeviceId), hwnd);
            }
        }
    }
    return S_OK;
}

/******************************************************************************

    CCameraView::GetEvents

******************************************************************************/

static const GUID *c_CamEvents[] =
{
    &WIA_EVENT_DEVICE_DISCONNECTED,
    &WIA_EVENT_TREE_UPDATED,
    &WIA_EVENT_ITEM_DELETED,
    &WIA_EVENT_ITEM_CREATED
};

EVENTDATA *
CCameraView::GetEvents ()
{
    int nEvents = ARRAYSIZE(c_CamEvents);
    EVENTDATA *pRet = new EVENTDATA[nEvents+1];
    if (pRet)
    {

        ZeroMemory (pRet, sizeof(EVENTDATA)*(nEvents+1));
        for (int i = 0;i<nEvents;i++)
        {
            pRet[i].pEventGuid = c_CamEvents[i];
        }
    }
    return pRet;
}
/******************************************************************************

   CRootView::HandleMessage

   <Notes>

 *****************************************************************************/

HRESULT
CRootView::HandleMessage (UINT uMsg, WPARAM wp, LPARAM lp)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_VIEW, "CRootView::HandleMessage");
    TraceViewMsg (uMsg, wp, lp);
    switch (uMsg)
    {

        case SFVM_INSERTITEM:
            hr =  OnSFVM_InsertItem (reinterpret_cast<LPITEMIDLIST>(lp));
            break;

        case SFVM_GETHELPTOPIC:
            hr = OnSFVM_GetHelpTopic (wp, lp);
            break;

        case SFVM_GETWEBVIEWLAYOUT:
            hr = OnSFVM_GetWebviewLayout(wp, reinterpret_cast<SFVM_WEBVIEW_LAYOUT_DATA*>(lp));
            break;

        case SFVM_GETWEBVIEWCONTENT:
            hr = OnSFVM_GetWebviewContent(reinterpret_cast<SFVM_WEBVIEW_CONTENT_DATA*>(lp));
            break;

        case SFVM_GETWEBVIEWTASKS:
            hr = OnSFVM_GetWebviewTasks(reinterpret_cast<SFVM_WEBVIEW_TASKSECTION_DATA*>(lp));
            break;

        case SFVM_DEFVIEWMODE:
            *(reinterpret_cast<FOLDERVIEWMODE*>(lp)) = FVM_TILE;
            break;

        default:
            hr = E_NOTIMPL;
            break;

    }
    TraceLeaveResult (hr);
}




/*****************************************************************************

   CRootView::OnSFVM_GetHelpTopic

   Use Camera.chm as our help topic file, instead of the generic system help
   Windows XP uses a hcp URL for non-server boxes

 *****************************************************************************/

HRESULT
CRootView::OnSFVM_GetHelpTopic (WPARAM wp, LPARAM lp)
{
    HRESULT hr = S_OK;
    SFVM_HELPTOPIC_DATA *psd = reinterpret_cast<SFVM_HELPTOPIC_DATA *>(lp);
    TraceEnter (TRACE_VIEW, "CBaseView::OnSFVM_GetHelpTopic");
    if (!psd)
    {
        hr = E_INVALIDARG;
    }
    else if (IsOS(OS_ANYSERVER))
    {
        wcscpy (psd->wszHelpFile, L"camera.chm");
        wcscpy (psd->wszHelpTopic, L"");
    }
    else
    {
        wcscpy (psd->wszHelpTopic, L"hcp://services/layout/xml?definition=MS-ITS%3A%25HELP_LOCATION%25%5Cntdef.chm%3A%3A/Scanners_and_Cameras.xml");
        wcscpy (psd->wszHelpFile, L"");
    }
    TraceLeaveResult (hr);
}

/******************************************************************************

   CRootView::OnSFVM_InsertItem

   Reject attempts to insert non-device pidls

 *****************************************************************************/

HRESULT
CRootView::OnSFVM_InsertItem (LPITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_VIEW, "CRootView::OnSFVM_InsertItem");
    if (!IsDeviceIDL(pidl) && !IsSTIDeviceIDL(pidl) &&!IsAddDeviceIDL(pidl))
    {
        hr = S_FALSE;
    }
    TraceLeaveResult (hr);
}


STDMETHODIMP
CRootView::ImageEventCallback (const GUID __RPC_FAR *pEventGUID,
                                      BSTR bstrEventDescription,
                                      BSTR bstrDeviceID,
                                      BSTR bstrDeviceDescription,
                                      DWORD dwDeviceType,
                                      BSTR bstrFullItemName,
                                      ULONG *pulEventType,
                                      ULONG ulReserved)

{
    TraceEnter (TRACE_VIEW, "CRootView::ImageEventCallback");
    // just update our view
    LPITEMIDLIST pidlFolder;
    InvalidateDeviceCache ();
    m_pFolder->GetCurFolder (&pidlFolder);
    if (pidlFolder)
    {
        SHChangeNotify (SHCNE_UPDATEDIR,
                        SHCNF_IDLIST,
                        pidlFolder, 0);
        ILFree (pidlFolder);
    }
    TraceLeaveResult (S_OK);
}

/******************************************************************************

    CRootView::GetEvents

******************************************************************************/

static const GUID *c_RootEvents[] =
{
    &WIA_EVENT_DEVICE_CONNECTED,
    &WIA_EVENT_DEVICE_DISCONNECTED,
};

EVENTDATA *
CRootView::GetEvents ()
{
    int nEvents = ARRAYSIZE(c_RootEvents);
    EVENTDATA *pRet = new EVENTDATA[nEvents+1];
    if (pRet)
    {

        ZeroMemory (pRet, sizeof(EVENTDATA)*(nEvents+1));
        for (int i = 0;i<nEvents;i++)
        {
            pRet[i].pEventGuid = c_RootEvents[i];
        }
    }
    return pRet;
}



static const WVTASKITEM c_ScanCamTaskIntro =
    WVTI_HEADER(L"wiashext.dll",IDS_SCANCAM_INTRO,IDS_SCANCAM_INTRO);

static const WVTASKITEM c_ScanCamDeviceTasks[] =
{
    WVTI_ENTRY_NOSELECTION(CLSID_NULL, L"wiashext.dll", IDS_SCANCAM_NOSELTEXT, IDS_SCANCAM_ADDDEVICE_TIP, IDI_ADDDEVICE, NULL, CRootView::AddDevice),
    WVTI_ENTRY(CLSID_NULL, L"wiashext.dll",  IDS_SCANCAM_GETPIX, IDS_SCANCAM_GETPIX_TIP, IDI_USE_WIZARD, CRootView::SupportsWizard, CRootView::InvokeWizard),
    WVTI_ENTRY(CLSID_NULL, L"wiashext.dll", IDS_SCANCAM_PROPERTIES, IDS_SCANCAM_PROPERTIES_TIP, IDI_SHOW_PROPERTIES, CRootView::SupportsProperties, CRootView::InvokeProperties)
};

static const WVTASKITEM c_ScanCamDeviceTasksHeader =
    WVTI_HEADER(L"wiashext.dll", IDS_SCANCAM_TASKS_HEADER, IDS_SCANCAM_TASKS_HEADER_TIP);


/******************************************************************************

    CRootView::OnSFVM_GetWebviewLayout

******************************************************************************/

HRESULT
CRootView::OnSFVM_GetWebviewLayout(WPARAM wp, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    TraceEnter(TRACE_VIEW, "CRootView::OnSFVM_GetWebviewLayout");
    pData->dwLayout = SFVMWVL_NORMAL;
    TraceLeaveResult(S_OK);
}


HRESULT
CRootView::OnSFVM_GetWebviewContent(SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    TraceEnter(TRACE_VIEW, "CRootView::OnSFVM_GetWebviewContent");
    ZeroMemory(pData, sizeof(*pData));
    Create_IUIElement(&c_ScanCamDeviceTasksHeader, &pData->pFolderTaskHeader);
    Create_IUIElement(&c_ScanCamTaskIntro, &pData->pIntroText);
    TraceLeaveResult(S_OK);
}

HRESULT
CRootView::OnSFVM_GetWebviewTasks(SFVM_WEBVIEW_TASKSECTION_DATA* pData)
{
    TraceEnter(TRACE_VIEW, "CRootView::OnSFVM_GetWebviewTasks");
    IUnknown *pUnk;
    m_pFolder->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>(&pUnk));
    Create_IEnumUICommand(pUnk, c_ScanCamDeviceTasks, ARRAYSIZE(c_ScanCamDeviceTasks), &pData->penumFolderTasks);
    DoRelease(pUnk);
    pData->penumSpecialTasks = NULL;
    TraceLeaveResult(S_OK);
}

HRESULT
CRootView::SupportsWizard(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState)
{
    HRESULT hr = E_FAIL;

    if (psiItemArray)
    {
        IDataObject *pdo;

        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_IDataObject,(void **) &pdo);

        if (SUCCEEDED(hr))
        {
            LPIDA pida;

            if (SUCCEEDED(hr = GetIDAFromDataObject(pdo, &pida, true)))
            {
                *puiState = UIS_HIDDEN;
                if (pida && pida->cidl == 1)
                {
                    LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
                    if (IsDeviceIDL(pidl))
                    {
                        *puiState = UIS_ENABLED;
                    }
                }

                LocalFree(pida);
            }

            pdo->Release();
        }
    }

    return hr;
}

HRESULT
CRootView::SupportsProperties(IUnknown *punk, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE *puiState)
{
    HRESULT hr = E_FAIL;

    if (psiItemArray)
    {
        IDataObject *pdo;

        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_IDataObject,(void **) &pdo);
        
        if (SUCCEEDED(hr))
        {
            LPIDA pida;

            hr = GetIDAFromDataObject(pdo, &pida, true);

            if (SUCCEEDED(hr))
            {
                *puiState = UIS_ENABLED;
                if (pida && pida->cidl == 1)
                {
                    LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
                    if (IsAddDeviceIDL(pidl))
                    {
                        *puiState = UIS_HIDDEN;
                    }
                }

                LocalFree(pida); 
            }

            pdo->Release();
        }
    }

    return hr;
}

HRESULT
CRootView::InvokeWizard(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = E_FAIL;

    if (psiItemArray)
    {
        IDataObject *pdo;

        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_IDataObject,(void **) &pdo);
        
        if (SUCCEEDED(hr))
        {
            DoWizardVerb(NULL, pdo);
            pdo->Release();
        }
    }

    return hr;
}

HRESULT
CRootView::InvokeProperties(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = E_FAIL;
    IDataObject *pdo = NULL;

    if (psiItemArray)
    {
        if (FAILED(psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_IDataObject,(void **) &pdo)))
        {
            pdo = NULL;
        }
    }

    CComQIPtr<IImageFolder, &IID_IImageFolder> pFolder = punk;

    if (pFolder.p && pdo)
    {
        hr = pFolder->DoProperties(pdo);
    }

    if (pdo)
    {
        pdo->Release();
    }

    return hr;
}

void AddDeviceWasChosen(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);

DWORD WINAPI _AddDeviceThread(void *pUnused)
{
    InterlockedIncrement(&GLOBAL_REFCOUNT);
    AddDeviceWasChosen(NULL, GLOBAL_HINSTANCE, NULL, SW_SHOW);
    InterlockedDecrement(&GLOBAL_REFCOUNT);
    return 0;
}

HRESULT 
CRootView::AddDevice(IUnknown *punk, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    DWORD dw;
    HANDLE hThread = CreateThread(NULL, 0,
                                  _AddDeviceThread,
                                  NULL, 0, &dw);
    if (hThread)
    {
        CloseHandle(hThread);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\dataobj2.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       dataobj2.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        4/20/98
 *
 *  DESCRIPTION: Cleanup of original IDataObject implementation for
 *               WIA shell extension.
 *
 *****************************************************************************/
#pragma warning(disable:4100)
#include "precomp.hxx"
#include "32bitdib.h"
#include "gdiplus.h"
#include "gphelper.h"
#include <wiadevd.h>
#pragma hdrstop

using namespace Gdiplus;
/*****************************************************************************

   Forward define helper Functions

 *****************************************************************************/

HRESULT
AllocStorageMedium( FORMATETC* pFmt,
                    STGMEDIUM* pMedium,
                    SIZE_T cbStruct,
                    LPVOID* ppAlloc
                   );

HRESULT
CopyStorageMedium( STGMEDIUM* pMediumDst,
                   STGMEDIUM* pMediumSrc,
                   FORMATETC* pFmt
                  );


HRESULT
GetShellIDListArray( CImageDataObject* pThis,
                     FORMATETC* pFmt,
                     STGMEDIUM* pMedium
                    );

HRESULT
GetMyIDListArray( CImageDataObject* pThis,
                     FORMATETC* pFmt,
                     STGMEDIUM* pMedium
                    );

HRESULT
GetFileDescriptor( CImageDataObject* pThis,
                    FORMATETC* pFmt,
                    STGMEDIUM* pMedium
                   );


HRESULT
GetFileContents( CImageDataObject* pThis,
                 FORMATETC* pFmt,
                 STGMEDIUM* pMedium
                );

HRESULT
GetSupportedFormat( CImageDataObject* pThis,
                    FORMATETC* pFmt,
                    STGMEDIUM* pMedium
                   );

HRESULT
GetPreferredEffect( CImageDataObject* pThis,
                    FORMATETC* pFmt,
                    STGMEDIUM* pMedium
                   );

HRESULT
GetDeviceName (CImageDataObject *pThis,
               FORMATETC *pFmt,
               STGMEDIUM *pMedium);


HRESULT
GetPersistObj (CImageDataObject *pThis,
               FORMATETC *pFmt,
               STGMEDIUM *pMedium);

HRESULT
GetExtNames (CImageDataObject *pThis,
          FORMATETC *pFmt,
          STGMEDIUM *pMedium);

#ifdef DEBUG
LPTSTR BadCFFormat( UINT cfFormat );
#endif

static TCHAR cszCFName [] = TEXT("STIDeviceName");
static TCHAR cszOlePersist [] = TEXT("OleClipboardPersistOnFlush");
TCHAR cszExtensibilityNames [] = TEXT("WIAItemNames"); // used by extensibility clients and prop sheets
static TCHAR cszMyIDListArray [] =TEXT("WIAPrivateIDListArray");
FORMAT_TABLE g_clipboardFormats[IMCF_MAX] =
{
    {      0, CFSTR_SHELLIDLIST,            GetShellIDListArray },
    {      0, CFSTR_FILEDESCRIPTORA,        GetFileDescriptor  },
    {      0, CFSTR_FILEDESCRIPTORW,        GetFileDescriptor  },
    {      0, CFSTR_FILECONTENTS,           GetFileContents     },
    #ifdef UNICODE
    // no CF_DIB for win9x because it doesn't support IPersistStream for clipboard objects
    { CF_DIB, NULL,                         GetSupportedFormat  },
    #else
    {      0, NULL, NULL },
    #endif
    {      0, CFSTR_PREFERREDDROPEFFECT,    GetPreferredEffect  },
    {      0, cszCFName,                    GetDeviceName},
    {      0, cszOlePersist,                GetPersistObj},
    {      0, cszExtensibilityNames,        GetExtNames },
    {      0, cszMyIDListArray,             GetMyIDListArray }
};

INT
_EnumDeleteFD (LPVOID pVoid, LPVOID pData)
{
    GlobalFree (pVoid);
    return 1;
}

/*****************************************************************************

   GetImageFromCamera

   Does the actual download

 *****************************************************************************/

HRESULT
GetImageFromCamera (LPSTGMEDIUM pStg, WIA_FORMAT_INFO &fmt, LPITEMIDLIST pidl, HWND hwndOwner )
{
    ULONG cbImage;
    CSimpleStringWide strDeviceId;
    CComBSTR bstrFullPath;

    CWiaDataCallback *pWiaDataCB = NULL;
    CComPtr<IWiaItem> pWiaItemRoot;
    CComPtr<IWiaItem> pItem;
    CComQIPtr<IWiaDataTransfer, &IID_IWiaDataTransfer> pWiaDataTran;
    CComQIPtr<IWiaDataCallback, &IID_IWiaDataCallback> pWiaDataCallback;

    HRESULT hr;
    TraceEnter (TRACE_DATAOBJ, "GetImageFromCamera");

    cbImage = 0;
    //
    // Get the DeviceId and image name
    //

    IMGetNameFromIDL( pidl, strDeviceId );
    pWiaDataCB = new CWiaDataCallback( CSimpleStringConvert::NaturalString(strDeviceId).String(), cbImage, hwndOwner );

    hr = IMGetDeviceIdFromIDL( pidl, strDeviceId );
    FailGracefully( hr, "couldn't get DeviceId string!" );

    //
    // Create the device...
    //

    hr = GetDeviceFromDeviceId( strDeviceId, IID_IWiaItem, (LPVOID *)&pWiaItemRoot, TRUE );
    FailGracefully( hr, "couldn't get Camera device from DeviceId string..." );

    //
    // Get actual item in question...
    //

    hr = IMGetFullPathNameFromIDL( pidl, &bstrFullPath );
    FailGracefully( hr, "couldn't get full path name for item" );

    hr = pWiaItemRoot->FindItemByName( 0, bstrFullPath, &pItem );

    FailGracefully( hr, "couldn't find item using full path name" );

    SetTransferFormat (pItem, fmt);
    cbImage = GetRealSizeFromItem (pItem);

    //
    // Set up callback so we can show progress...
    //

    if (! pWiaDataCB)
    {
        ExitGracefully (hr, E_OUTOFMEMORY, "");
    }
    pWiaDataCallback = pWiaDataCB;

    if (!pWiaDataCallback)
    {
        ExitGracefully( hr, E_FAIL, "QI for IID_IWiaDataCallback failed" );
    }

    //
    // QI to get BandedTransfer interface on CameraItem
    //


    pWiaDataTran = pItem;
    if (!pWiaDataTran)
    {
        ExitGracefully (hr, E_FAIL, "");
    }


    //
    // Get the picture data...
    //

    hr = pWiaDataTran->idtGetData( pStg, pWiaDataCallback);
    FailGracefully( hr, "IWiaDataTransfer->idtGetData Failed" );

exit_gracefully:
    DoRelease( pWiaDataCB );

    TraceLeaveResult( hr );

}

/*****************************************************************************

   DownloadPicture

   This function copies the actual picture bits to the given filename.

 *****************************************************************************/

HRESULT
DownloadPicture( LPTSTR pFile,
                 LPITEMIDLIST pidl,
                 HWND hwndOwner
                )
{

    HRESULT               hr;
    WIA_FORMAT_INFO       Format;
    STGMEDIUM             Stgmed;
    LPTSTR                pExt;
    TCHAR                 szExt[MAX_PATH];
    DWORD                 dwAtt;
    TraceEnter(TRACE_DATAOBJ, "DownloadPicture");

    //
    // fill out structures for IBandedTransfer
    //


    hr = IMGetImagePreferredFormatFromIDL( pidl,
                                           &Format.guidFormatID,
                                           szExt
                                          );

    if (FAILED(hr))
    {
        Format.guidFormatID = WiaImgFmt_BMP;
        lstrcpy (szExt, TEXT(".bmp"));
    }

    Format.lTymed          = TYMED_FILE;

    Stgmed.tymed          = TYMED_FILE;
    Stgmed.pUnkForRelease = NULL;
    Stgmed.lpszFileName   = NULL;

    hr = GetImageFromCamera (&Stgmed, Format, pidl, hwndOwner );
    FailGracefully (hr, "GetImageFromCamera failed in DownloadPicture");

    //
    // Move the file from the returned name to the new name...
    //

    pExt = PathFindExtension( pFile );
    if (pExt && (*pExt==0))
    {
        lstrcpy (pExt, szExt);

    }

    //
    // make sure the file is over-writable if it already exists
    //
    dwAtt = GetFileAttributes (pFile);
    Trace(TEXT("Attributes for [%s] are 0x%x"),pFile,dwAtt);
    if ((dwAtt != -1) && (dwAtt & FILE_ATTRIBUTE_READONLY))
    {
        dwAtt &= ~FILE_ATTRIBUTE_READONLY;
        if (!SetFileAttributes (pFile, dwAtt))
        {
            Trace(TEXT("Tried to reset READONLY on [%s] by calling SFA( 0x%x ), GLE=%d"),pFile,dwAtt,GetLastError());
        }
        else
        {
            Trace(TEXT("Set attributes to 0x%x for file [%s]"),dwAtt,pFile);
        }
    }


    //
    // Delete destination if it already exists
    //
    if (!DeleteFile(pFile))
    {
        Trace(TEXT("DeleteFile( %s ) failed w/GLE=%d"), pFile, GetLastError());
    }

#ifdef UNICODE

    if (!MoveFile( Stgmed.lpszFileName, pFile))
    {
        Trace( TEXT("MoveFile( %s, %s ) failed w/GLE=%d"),
               Stgmed.lpszFileName,
               pFile,
               GetLastError()
              );
    }
#else
    TCHAR szFile[ MAX_PATH ];

    WideCharToMultiByte( CP_ACP,
                         0,
                         Stgmed.lpszFileName,
                         -1,
                         szFile,
                         ARRAYSIZE(szFile),
                         NULL,
                         NULL );

    if (!MoveFile( szFile, pFile ))
    {
        Trace( TEXT("MoveFile( %s, %s ) failed w/GLE=%d"),
               szFile,
               pFile,
               GetLastError()
              );
    }
#endif


exit_gracefully:

    if (Stgmed.lpszFileName)
    {
        ReleaseStgMedium( &Stgmed );
    }

    TraceLeaveResult( hr );
}


/*****************************************************************************

   RegisterImageClipboardFormats

   Registers the clipboard formats that are used by our dataobject.  We
   only do this once, even though it is called each time one of our
   IDataoObject's is created.

 *****************************************************************************/

void
RegisterImageClipboardFormats( void )
{
    TraceEnter(TRACE_DATAOBJ, "RegisterImageClipboardFormats");

    if ( !g_clipboardFormats[0].cfFormat )
    {
        g_cfShellIDList     = static_cast<WORD>(RegisterClipboardFormat(CFSTR_SHELLIDLIST));
        g_cfFileDescriptorA = static_cast<WORD>(RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA));
        g_cfFileDescriptorW = static_cast<WORD>(RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW));
        g_cfFileContents    = static_cast<WORD>(RegisterClipboardFormat(CFSTR_FILECONTENTS));
        g_cfPreferredEffect = static_cast<WORD>(RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT));
        g_cfName            = static_cast<WORD>(RegisterClipboardFormat(cszCFName));
        g_cfOlePersist      = static_cast<WORD>(RegisterClipboardFormat(cszOlePersist));
        g_cfExtNames        = static_cast<WORD>(RegisterClipboardFormat(cszExtensibilityNames));
        g_cfMyIDList        = static_cast<WORD>(RegisterClipboardFormat(cszMyIDListArray));
        Trace(TEXT("g_cfShellIDList %08x"),     g_cfShellIDList);
        Trace(TEXT("g_cfFileDescriptorA %08x"), g_cfFileDescriptorA);
        Trace(TEXT("g_cfFileDescriptorW %08x"), g_cfFileDescriptorW);
        Trace(TEXT("g_cfFileContents %08x"),    g_cfFileContents);
        Trace(TEXT("g_cfPreferredDropEffect %08x"), g_cfPreferredEffect);
    }
    TraceLeave();
}



/*****************************************************************************

   CImageDataObject::CImageDataObject

   Constructor for our IDataObject implementation

 *****************************************************************************/

CImageDataObject::CImageDataObject(
                                    IWiaItem *pItem
                                   )
    : m_hidl(0),
      m_hformats(0),
      m_pItem(pItem),
      m_pidl(NULL),
      m_hidlFull( NULL),
      m_dpaFilesW ( NULL),
      m_dpaFilesA (NULL),
      m_bCanAsync (TRUE),
      m_bInOp(FALSE),
      m_bHasPropertyPidls(FALSE)

{
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::CImageDataObject");
    TraceLeave();
}

/*****************************************************************************

    CImageDataObject::Init

    Does the real work for initializing the object.


*****************************************************************************/
HRESULT
CImageDataObject::Init(LPCITEMIDLIST pidlRoot,
                       INT cidl,
                       LPCITEMIDLIST* aidl,
                       IMalloc *pm)
{

    INT i;
    LPITEMIDLIST pidl;
    IMAGE_FORMAT* pif;
    HRESULT hr = S_OK;
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::Init");
    m_pMalloc = pm;

    //
    // Check for bad params
    //


    if (!aidl)
    {
        ExitGracefully( hr, E_INVALIDARG, "aidl is NULL!" );
    }

    if (cidl)
    {
        for (i=0;i<cidl;i++)
        {
            if (!aidl[i])
            {
                ExitGracefully( hr, E_INVALIDARG, "a member of aidl was null!" );
            }
        }
    }

    //
    // Initialize stuff...
    //

    if (pidlRoot)
    {
        m_pidl = ILClone(pidlRoot);
    }

    //
    // Construct a DPA and clone the IDLISTs into it
    //

    m_hidl = DPA_Create(4);

    if (m_hidl)
    {
        for ( i = 0 ; i < cidl ; i++ )
        {
            pidl = ILClone(aidl[i]);

            Trace(TEXT("Cloned IDLIST %08x to %08x"), aidl[i], pidl);

            if ( pidl )
            {
                if ( -1 == DPA_AppendPtr(m_hidl, pidl) )
                {
                    TraceMsg("Failed to insert pidl into the DPA");
                    DoILFree(pidl);
                }
                if (IMItemHasSound(pidl))
                {
                    LPITEMIDLIST pAudio = IMCreatePropertyIDL (pidl, WIA_IPC_AUDIO_DATA, pm);
                    if (pAudio)
                    {
                        if (-1 == DPA_AppendPtr (m_hidl, pAudio))
                        {
                            TraceMsg("Failed to insert pAudio into the DPA");
                            DoILFree(pAudio);
                        }
                        else
                        {
                            m_bHasPropertyPidls = TRUE;
                        }
                    }
                }
            }
        }
    }


    //
    // Construct a DPA and put the supported formats into it.
    //

    RegisterImageClipboardFormats();    // ensure our private formats are registered

    m_hformats = DPA_Create(IMCF_MAX);

    if (m_hformats)
    {
        //
        // If the item supports audio, add CF_WAVE
        //
        if (cidl==1 && IMItemHasSound(const_cast<LPITEMIDLIST>(aidl[0])))
        {
            pif = reinterpret_cast<IMAGE_FORMAT *>(LocalAlloc (LPTR, sizeof(IMAGE_FORMAT)));
            if (pif)
            {
                pif->fmt.cfFormat = CF_WAVE;
                pif->fmt.dwAspect = DVASPECT_CONTENT;
                pif->fmt.lindex = -1;
                pif->fmt.tymed = TYMED_HGLOBAL;
                pif->pfn = GetSupportedFormat;
                if ( -1 == DPA_AppendPtr( m_hformats, pif ) )
                {
                    TraceMsg("Failed to insert CF_WAVE/TYMED_HGLOBAL format into the DPA");
                    LocalFree( (HLOCAL)pif );
                }
            }
            pif = reinterpret_cast<IMAGE_FORMAT *>(LocalAlloc (LPTR, sizeof(IMAGE_FORMAT)));
            if (pif)
            {
                pif->fmt.cfFormat = CF_WAVE;
                pif->fmt.dwAspect = DVASPECT_CONTENT;
                pif->fmt.lindex = -1;
                pif->fmt.tymed = TYMED_FILE;
                pif->pfn = GetSupportedFormat;
                if ( -1 == DPA_AppendPtr( m_hformats, pif ) )
                {
                    TraceMsg("Failed to insert CF_WAVE/TYMED_FILE format into the DPA");
                    LocalFree( (HLOCAL)pif );
                }
            }
        }
        for( i = 0; i < ARRAYSIZE(g_clipboardFormats); i++ )
        {

            // only do DIB for 1 item
            if (cidl > 1 && g_clipboardFormats[i].cfFormat == CF_DIB)
            {
                continue;
            }
            // make sure it's a valid format
            if (!(g_clipboardFormats[i].cfFormat))
            {
                continue;
            }
            pif = (IMAGE_FORMAT *)LocalAlloc( LPTR, sizeof(IMAGE_FORMAT) );
            if (pif)
            {

                pif->fmt.cfFormat = g_clipboardFormats[i].cfFormat;
                pif->fmt.dwAspect = DVASPECT_CONTENT;
                pif->fmt.lindex   = -1;
                pif->fmt.tymed    = TYMED_HGLOBAL;
                pif->pfn          = g_clipboardFormats[i].pfn;

                if (pif->fmt.cfFormat == g_cfFileContents)
                {
                    pif->fmt.tymed |= TYMED_ISTREAM;
                }

                if ( -1 == DPA_AppendPtr( m_hformats, pif ) )
                {
                    TraceMsg("Failed to insert format into the DPA");
                    LocalFree( (HLOCAL)pif );
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

exit_gracefully:

    TraceLeaveResult(hr);
}




/*****************************************************************************

   _hformatsDestroyCB

   In our destructor, we destroy the item DPA via DPA_DestroyCallback.  This
   function is thus called for each item in the DPA before it is destroyed.
   This allows us to free the contents of each DPA pointer before it's
   released from the DPA.

 *****************************************************************************/

INT
_hformatsDestroyCB( LPVOID pVoid,
                    LPVOID pData
                   )
{
    LPIMAGE_FORMAT pif = (LPIMAGE_FORMAT)pVoid;

    TraceEnter(TRACE_DATAOBJ, "_hformatsDestroyCB");

    if (pif)
    {
        if (pif->pStg)
        {
            ReleaseStgMedium( pif->pStg );
        }

        LocalFree( (HLOCAL)pif );
    }

    TraceLeaveValue(TRUE);
}



/*****************************************************************************

   CImageDataObject::~CImageDataObject

   Desctructor for our IDataObject class.

 *****************************************************************************/

CImageDataObject::~CImageDataObject()
{
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::~CImageDataObject");

    DPA_DestroyCallback(m_hidl, _EnumDestroyCB, NULL);
    DPA_DestroyCallback(m_hformats, _hformatsDestroyCB, NULL);
    DPA_DestroyCallback(m_dpaFilesA, _EnumDeleteFD, NULL);
    DPA_DestroyCallback(m_dpaFilesW, _EnumDeleteFD, NULL);
    DPA_DestroyCallback(m_hidlFull, _EnumDestroyCB, NULL);
    DoILFree( m_pidl );

    TraceLeave();
}



/*****************************************************************************

   CImageDataObject IUnknown implementation

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CImageDataObject
#include "unknown.inc"


/*****************************************************************************

   CImageDataObject::QueryInterface

   This is where we place the special handling and normal goo to make
   our QI helper function work

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::QueryInterface( REFIID riid,
                                  LPVOID* ppvObject
                                 )
{
    // turn off IAsyncOperation until we figure out a better method of rapid response.
    // using this interface breaks the acquisition manager right now
    HRESULT hr = E_NOINTERFACE;
    INTERFACES iface[]=
    {
        &IID_IDataObject, static_cast<LPDATAOBJECT>(this),
        &IID_IPersistStream, static_cast<IPersistStream*>(this),
        &IID_IAsyncOperation, static_cast<IAsyncOperation*>(this),
    };

    TraceEnter( TRACE_QI, "CImageDataObject::QueryInterface" );
    TraceGUID("Interface requested", riid);

    //
    // HACK! In order for property sheets to share a common IWiaItem pointer,
    // let them QI for the pointer we have
    //

    if (IsEqualGUID (riid, IID_IWiaItem))
    {
        if (!!m_pItem)
        {
            hr = m_pItem->QueryInterface (riid, ppvObject);
        }
    }
    else
    {
        hr = HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
    }

    TraceLeaveResult( hr );
}



/*****************************************************************************

   CImageDataObject::GetData

   Actually return the data to the calling client

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::GetData( FORMATETC* pFmt,
                           STGMEDIUM* pMedium
                          )
{
    HRESULT       hr = DV_E_FORMATETC;
    INT           count,i;
    IMAGE_FORMAT* pif;
#ifdef DEBUG
    TCHAR         szBuffer[MAX_PATH];
    LPTSTR        pName = szBuffer;
#endif

    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::GetData");

    if ( !pFmt || !pMedium )
        ExitGracefully(hr, E_INVALIDARG, "Bad arguments to GetData");


#ifdef DEBUG
    if ( !GetClipboardFormatName(pFmt->cfFormat, szBuffer, ARRAYSIZE(szBuffer)) )
    {
        pName = BadCFFormat( pFmt->cfFormat );
    }

    Trace(TEXT("Caller is asking for cfFormat (%s) (%08x)"), pName, pFmt->cfFormat);

#endif

    //
    // Loop through the list of formats and then return the requested
    // one via either a stored STGMEDIUM or through a function.
    //

    m_cs.Enter ();

    count = DPA_GetPtrCount( m_hformats );

    for (i = 0; i < count; i++)
    {
        pif = (IMAGE_FORMAT *)DPA_FastGetPtr( m_hformats, i );
        if (pif && (pif->fmt.cfFormat == pFmt->cfFormat))
        {
            if (pif->pfn)
            {
                Trace(TEXT("Format supported, need to build STGMEDIUM"));
                hr = pif->pfn( this, pFmt, pMedium );
                break;
            }
            else if (pif->pStg)
            {
                Trace(TEXT("Format supported, need to copy stored STGMEDIUM"));
                hr = CopyStorageMedium( pMedium, pif->pStg, pFmt );
                break;
            }
        }
    }

    m_cs.Leave();

    if (FAILED(hr))
    {
        Trace(TEXT("Either couldn't build, couldn't copy, or didn't have requested format!"));
    }

exit_gracefully:

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageDataObject::GetDataHere

   <Not Implemented>

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::GetDataHere( FORMATETC* pFmt,
                               STGMEDIUM* pMedium
                              )
{
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::GetDataHere");
    TraceLeaveResult(E_NOTIMPL);
}



/*****************************************************************************

   CImageDataObject::QueryGetData

   Let the world know what formats we currently have available

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::QueryGetData( FORMATETC* pFmt
                                )
{
    HRESULT       hr = DV_E_FORMATETC;
    INT           count, i;
    IMAGE_FORMAT* pif;

    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::QueryGetData");

    //
    // Check to see if we support the format being asked of us
    //

    m_cs.Enter ();

    count = DPA_GetPtrCount( m_hformats );

    for (i = 0; i < count; i++)
    {
        pif = (IMAGE_FORMAT*)DPA_FastGetPtr( m_hformats, i );

        if (pif && (pif->fmt.cfFormat == pFmt->cfFormat))
        {
            hr = S_OK;
            break;
        }
    }

    m_cs.Leave();

    if (FAILED(hr))
    {
#ifdef DEBUG
        TCHAR szBuffer[MAX_PATH];
        LPTSTR pName = szBuffer;

        if ( !GetClipboardFormatName(pFmt->cfFormat, szBuffer, ARRAYSIZE(szBuffer)) )
        {
            pName = BadCFFormat( pFmt->cfFormat );
        }

        Trace(TEXT("Bad cfFormat given (%s) (%08x)"), pName, pFmt->cfFormat);
#endif
        ExitGracefully(hr, DV_E_FORMATETC, "Bad format passed to QueryGetData");
    }

    //
    // Format looks good, so now check that we can create a StgMedium for it
    //

    if ( !( pFmt->tymed & (TYMED_HGLOBAL | TYMED_ISTREAM)) )
        ExitGracefully(hr, E_INVALIDARG, "Non HGLOBAL or IStream StgMedium requested");

    if ( ( pFmt->ptd ) || !( pFmt->dwAspect & DVASPECT_CONTENT) || !( pFmt->lindex == -1 ) )
        ExitGracefully(hr, E_INVALIDARG, "Bad format requested");

    hr = S_OK;              // successs

exit_gracefully:

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageDataObject::GetCanonicalFormatEtc

   We just let everyone know it's the same as the normal FormatETC.

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::GetCanonicalFormatEtc( FORMATETC* pFmtIn,
                                         FORMATETC *pFmtOut
                                        )
{
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::GetCanonicalFormatEtc");

    // The easiest way to implement this is to tell the world that the
    // formats would be identical, therefore leaving nothing to be done.

    TraceLeaveResult(DATA_S_SAMEFORMATETC);
}



/*****************************************************************************

   CImageDataObject::SetData

   We accept and store anything anyone wants to give us.

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::SetData( FORMATETC* pFormatEtc,
                           STGMEDIUM* pMedium,
                           BOOL fRelease
                          )
{
    HRESULT       hr      = E_NOTIMPL;
    IMAGE_FORMAT* pif = NULL;
    INT           count,i;

    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::SetData");

#ifdef DEBUG
    {
        TCHAR szBuffer[MAX_PATH];
        LPTSTR pName = szBuffer;

        if ( !GetClipboardFormatName(pFormatEtc->cfFormat, szBuffer, ARRAYSIZE(szBuffer)) )
        {
            pName = TEXT("<unknown>");
        }

        Trace(TEXT("Trying to set cfFormat (%s) (%08x)"), pName, pFormatEtc->cfFormat);

    }
#endif
    //
    // If the shell is trying to store idlist offsets from the view, and we have added fake property PIDLS
    // to our list of items, don't allow the set.
    //

    static CLIPFORMAT cfOffsets = 0;
    if (!cfOffsets)
    {
        cfOffsets = static_cast<CLIPFORMAT>(RegisterClipboardFormat(CFSTR_SHELLIDLISTOFFSET));
    }

    m_cs.Enter( );
    
    if (m_bHasPropertyPidls && cfOffsets == pFormatEtc->cfFormat)
    {
        ExitGracefully(hr, E_FAIL, "Unable to accept shell offsets because of property pidls");
    }
        //
    // Store the given format in our list
    //
    count = DPA_GetPtrCount( m_hformats );

    //
    // first, see if we already have this format stored...
    //

    for (i = 0; i < count; i++)
    {
        pif = (IMAGE_FORMAT*)DPA_FastGetPtr( m_hformats, i );

        if ( pif &&
             (pif->fmt.cfFormat == pFormatEtc->cfFormat) &&
             (pif->pStg) &&
             ((pFormatEtc->tymed & TYMED_HGLOBAL) || (pFormatEtc->tymed & TYMED_ISTREAM))
            )
        {
            break;
        }

        pif = NULL;
    }

    if (pif)
    {
        //
        // We had this previously, delete it and store the new one...
        //

        Trace(TEXT("We already had this format, releasing and storing again..."));
        ReleaseStgMedium( pif->pStg );
    }
    else
    {
        pif = (IMAGE_FORMAT *)LocalAlloc( LPTR, sizeof( IMAGE_FORMAT ) );
        if (!pif)
        {
            ExitGracefully( hr, E_OUTOFMEMORY, "Failed to allocate a new pif" );
        }
        pif->pfn = NULL;
        pif->fmt  = *pFormatEtc;
        pif->pStg = &pif->medium;

        if (-1 == DPA_AppendPtr( m_hformats, pif ) )
        {
            ExitGracefully( hr, E_OUTOFMEMORY, "Failed to add pif to m_hformats" );
        }
    }

    //
    // Do we have full ownership of the storage medium?
    //

    if (fRelease)
    {
        //
        // Yep, then just hold onto it...
        //

        *(pif->pStg) = *pMedium;
        hr = S_OK;

    }
    else
    {
        //
        // Nope, we need to copy everything...
        //

        hr = CopyStorageMedium( pif->pStg, pMedium, pFormatEtc );
    }

exit_gracefully:

    m_cs.Leave( );
    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageDataObject::EnumFormatEtc

   Hands off a FORMATETC enumerator.

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::EnumFormatEtc( DWORD dwDirection,
                                 IEnumFORMATETC** ppEnumFormatEtc
                                )
{
    HRESULT hr;

    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::EnumFormatEtc");

    // Check the direction parameter, if this is READ then we support it,
    // otherwise we don't.

    if ( dwDirection != DATADIR_GET )
        ExitGracefully(hr, E_NOTIMPL, "We only support DATADIR_GET");

    *ppEnumFormatEtc = (IEnumFORMATETC*)new CImageEnumFormatETC( this );

    if ( !*ppEnumFormatEtc )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to enumerate the formats");

    hr = S_OK;

exit_gracefully:

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageDataObject::DAdvise, ::Unadvise, ::EnumAdvise

   We don't support these.

 *****************************************************************************/

STDMETHODIMP
CImageDataObject::DAdvise( FORMATETC* pFormatEtc,
                           DWORD advf,
                           IAdviseSink* pAdvSink,
                           DWORD* pdwConnection
                          )
{
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::DAdvise");
    TraceLeaveResult(OLE_E_ADVISENOTSUPPORTED);
}

STDMETHODIMP CImageDataObject::DUnadvise( DWORD dwConnection )
{
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::DUnadvise");
    TraceLeaveResult(OLE_E_ADVISENOTSUPPORTED);
}

STDMETHODIMP CImageDataObject::EnumDAdvise( IEnumSTATDATA** ppenumAdvise )
{
    TraceEnter(TRACE_DATAOBJ, "CImageDataObject::EnumDAdvise");
    TraceLeaveResult(OLE_E_ADVISENOTSUPPORTED);
}

/*****************************************************************************

    CImageDataObject::Load [IPersistStream]

    Construct the dataobject from the given stream

    The stream looks like this:
    LONG nPidls->LONG sizeRootIdl->ITEMIDLIST pidlRoot->ITEMIDLIST[nPidls]

*****************************************************************************/
STDMETHODIMP
CImageDataObject::Load (IStream *pstm)
{
    HRESULT hr;
    LONG nPidls = 0;

    TraceEnter (TRACE_DATAOBJ, "CImageDataObject::Load");
    hr = pstm->Read (&nPidls, sizeof(nPidls), NULL);
    if (SUCCEEDED(hr) && nPidls)
    {
        LPBYTE pidlRoot = NULL;
        //
        // Allocate the IDA
        //
        LPBYTE *pida = new LPBYTE[nPidls];
        LONG sizeRootIDL;

        if (!pida)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // Find out the size of the pidlRoot
            pstm->Read (&sizeRootIDL, sizeof(sizeRootIDL), NULL);
            if (sizeRootIDL)
            {
                pidlRoot = new BYTE[sizeRootIDL];
            }

            if (sizeRootIDL && !pidlRoot)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                WORD cbSize;
                // Read in pidlRoot

                if (sizeRootIDL)
                {
                    hr = pstm->Read (pidlRoot,
                                     sizeRootIDL,
                                     NULL);
                }

                // Now read the relative idls
                // Note that we read cbSize bytes to include the zero terminator
                for (LONG i=0;SUCCEEDED(hr) && i<nPidls;i++)
                {
                    pstm->Read (&cbSize, sizeof(cbSize), NULL);
                    pida[i] = new BYTE[cbSize+sizeof(cbSize)];
                    if (pida[i])
                    {
                        *(reinterpret_cast<LPWORD>(pida[i])) = cbSize;
                        hr = pstm->Read (pida[i]+sizeof(cbSize),
                                    cbSize,
                                    NULL);

                    }
                }
                if (SUCCEEDED(hr))
                {

                    // We have read all the pidls into memory,
                    // now init the dataobject
                    hr = Init (reinterpret_cast<LPCITEMIDLIST>(pidlRoot),
                               nPidls,
                               const_cast<LPCITEMIDLIST*>(reinterpret_cast<LPITEMIDLIST*>(pida)),
                               NULL);
                }
                // cleanup
                for (i=0;i<nPidls;i++)
                {
                    if (pida[i])
                    {
                        delete [] pida[i];
                    }
                }
                if (pidlRoot)
                {
                    delete [] pidlRoot;
                }
            }
            delete [] pida;
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************

    CImageDataObject::Save [IPersistStream]

    Save our pidl info to the given stream

    The stream looks like this:
    LONG nPidls->LONG sizeRootIDL->ITEMIDLIST pidlRoot->ITEMIDLIST[nPidls]

*****************************************************************************/

STDMETHODIMP
CImageDataObject::Save(IStream *pstm, BOOL bPersist)
{
    HRESULT hr;
    TraceEnter (TRACE_DATAOBJ, "CImageDataObject::Save");

    LONG nPidls = DPA_GetPtrCount (m_hidl);
    LONG sizeRootIDL = 0;

    if (m_pidl)
    {
        sizeRootIDL = ILGetSize (m_pidl);
    }
    hr = pstm->Write (&nPidls, sizeof(nPidls), NULL);
    if (SUCCEEDED(hr))
    {
        // since the first Write worked, assume the rest will
        // if they happen to fail, do we really care? When OLE calls
        // our Load, it will fail on the malformed stream anyway.


        LPITEMIDLIST pidl;

        // First write the parent folder pidl and its size
        pstm->Write (&sizeRootIDL,
                     sizeof(sizeRootIDL),
                     NULL);

        if (sizeRootIDL)
        {
            pstm->Write (m_pidl,
                         sizeRootIDL,
                         NULL);
        }
        // now write the child pidls
        // For each Write, make sure we include the zero terminator
        for (INT i=0;i<nPidls;i++)
        {
            pidl = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr (m_hidl, i));
            pstm->Write (pidl,
                         pidl->mkid.cb+sizeof(pidl->mkid.cb),
                         NULL);
        }
    }

    TraceLeaveResult (hr);
}

STDMETHODIMP
CImageDataObject::IsDirty()
{
    return S_OK;
}

STDMETHODIMP
CImageDataObject::GetSizeMax(ULARGE_INTEGER *ulMax)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_DATAOBJ, "CImageDataObject::GetSizeMax");
    INT nPidls = DPA_GetPtrCount (m_hidl);
    INT sizeRootIDL = ILGetSize (m_pidl);
    LPITEMIDLIST pidl;
    ulMax->HighPart = 0;
    ulMax->LowPart = sizeof(nPidls)+sizeof(sizeRootIDL)+sizeRootIDL;
    for (INT i=0;i<nPidls;i++)
    {
        pidl = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr (m_hidl, i));
        if (pidl)
        {
            ulMax->LowPart += pidl->mkid.cb+sizeof(pidl->mkid.cb);
        }
    }
    TraceLeaveResult (hr);
}

STDMETHODIMP
CImageDataObject::GetClassID (GUID *pclsid)
{
    *pclsid = CLSID_ImageFolderDataObj;
    return S_OK;
}

STDMETHODIMP
CImageDataObject::SetAsyncMode(BOOL fDoOpAsync)
{
    m_bCanAsync = fDoOpAsync;
    return S_OK;
}
STDMETHODIMP
CImageDataObject::GetAsyncMode(BOOL *pfIsOpAsync)
{
    HRESULT hr = E_INVALIDARG;
    if (pfIsOpAsync)
    {
        *pfIsOpAsync = m_bCanAsync;
        hr = S_OK;
    }
    return hr;

}
STDMETHODIMP
CImageDataObject::StartOperation(IBindCtx *pbcReserved)
{
    m_bInOp = TRUE;
    return S_OK;
}
STDMETHODIMP
CImageDataObject::InOperation(BOOL *pfInAsyncOp)
{
    HRESULT hr = E_INVALIDARG;
    if (pfInAsyncOp)
    {
        *pfInAsyncOp = m_bInOp;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP
CImageDataObject::EndOperation(HRESULT hResult,
                          IBindCtx *pbcReserved,
                          DWORD dwEffects)
{
    m_bInOp = FALSE;
    return S_OK;
}
/*****************************************************************************

   CImageEnumFormatETC::CImageEnumFormatETC

   Constructor/Destructor for EnumFormatETC class.

 *****************************************************************************/

CImageEnumFormatETC::CImageEnumFormatETC( CImageDataObject* pThis )
    : m_index(0)
{
    TraceEnter(TRACE_DATAOBJ, "CImageEnumFormatETC::CImageEnumFormatETC");

    if (pThis)
    {
        m_pThis = pThis;
        m_pThis->AddRef();
    }

    TraceLeave();
}

CImageEnumFormatETC::~CImageEnumFormatETC()
{
    TraceEnter(TRACE_DATAOBJ, "CImageEnumFormatETC::~CImageEnumFormatETC");


    DoRelease( m_pThis );
    m_pThis = NULL;

    TraceLeave();
}

/*****************************************************************************

   CImageEnumFormatETC IUnknown implementation

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CImageEnumFormatETC
#include "unknown.inc"


/*****************************************************************************

   CImageEnumFormatETC::QueryInterface

   QI stuff.

 *****************************************************************************/

STDMETHODIMP
CImageEnumFormatETC::QueryInterface( REFIID riid,
                                     LPVOID* ppvObject
                                    )
{
    INTERFACES iface[]=
    {
        &IID_IEnumFORMATETC, (LPENUMFORMATETC)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}

/*****************************************************************************

   CImageEnumFormatETC::Next

   Give back the next format supported.

 *****************************************************************************/

STDMETHODIMP
CImageEnumFormatETC::Next( ULONG celt,
                           FORMATETC* rgelt,
                           ULONG* pceltFetched
                          )
{
    HRESULT hr;
    ULONG fetched = 0;
    ULONG celtSave = celt;
    INT   count;

    TraceEnter(TRACE_DATAOBJ, "CImageEnumFormatETC::Next");

    if ( !celt || !rgelt || !m_pThis)
        ExitGracefully(hr, E_INVALIDARG, "Bad count/return pointer passed or null m_pThis");

    // Look through all the formats that we have started at our stored
    // index, if either the output buffer runs out, or we have no
    // more formats to enumerate then bail


    m_pThis->m_cs.Enter();

    count = DPA_GetPtrCount( m_pThis->m_hformats );

    for ( fetched = 0 ; celt && (m_index < count) ; celt--, m_index++, fetched++ )
    {
        IMAGE_FORMAT * pif = (IMAGE_FORMAT *)DPA_FastGetPtr( m_pThis->m_hformats, m_index );

        if (pif)
        {
            rgelt[fetched] = pif->fmt;
#ifdef DEBUG
            {
                TCHAR szBuffer[MAX_PATH];
                LPTSTR pName = szBuffer;

                if ( !GetClipboardFormatName(pif->fmt.cfFormat, szBuffer, ARRAYSIZE(szBuffer)) )
                {
                    pName = BadCFFormat( pif->fmt.cfFormat );
                }

                Trace(TEXT("Returning supported format (%s) (%08x)"), pName, pif->fmt.cfFormat);
            }
#endif

        }
    }

    hr = ( fetched == celtSave) ? S_OK:S_FALSE;

    m_pThis->m_cs.Leave();

exit_gracefully:

    if ( pceltFetched )
        *pceltFetched = fetched;

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageEnumFormatETC::Skip

   Skip ahead the specified amount in the list.

 *****************************************************************************/

STDMETHODIMP
CImageEnumFormatETC::Skip( ULONG celt )
{
    TraceEnter(TRACE_DATAOBJ, "CImageEnumFormatETC::Skip");
    TraceLeaveResult(E_NOTIMPL);
}



/*****************************************************************************

   CImageEnumFormatETC::Reset

   Reset the enumeration to the first item in the list.

 *****************************************************************************/

STDMETHODIMP CImageEnumFormatETC::Reset()
{
    TraceEnter(TRACE_DATAOBJ, "CImageEnumFormatETC::Reset");

    m_index = 0;                // simple as that really

    TraceLeaveResult(S_OK);
}


/*****************************************************************************

   CImageEnumFormatETC::Clone

   Clone the enumeration and hand back the clone.

 *****************************************************************************/

STDMETHODIMP CImageEnumFormatETC::Clone(LPENUMFORMATETC* ppenum)
{
    TraceEnter(TRACE_DATAOBJ, "CImageEnumFormatETC::Clone");
    TraceLeaveResult(E_NOTIMPL);
}


/*****************************************************************************

   CopyStorageMedium

   Copies a STGMEDIUM and the data in an HGLOBAL.
   Only works for TYMED_HGLOBAL.

 *****************************************************************************/

HRESULT
CopyStorageMedium( STGMEDIUM* pMediumDst,
                   STGMEDIUM* pMediumSrc,
                   FORMATETC* pFmt
                  )
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_DATAOBJ, "CopyStorageMedium");

    if (pFmt->tymed & TYMED_HGLOBAL)
    {
        SIZE_T cbStruct = GlobalSize( (HGLOBAL)pMediumSrc->hGlobal );
        HGLOBAL hGlobal;
        LPVOID lpSrc, lpDst;

        hr = AllocStorageMedium( pFmt, pMediumDst, cbStruct, NULL );
        hGlobal = pMediumDst->hGlobal;
        FailGracefully( hr, "Unable to allocate storage medium" );

        *pMediumDst = *pMediumSrc;
        pMediumDst->hGlobal = hGlobal;

        lpSrc = GlobalLock( pMediumSrc->hGlobal );
        lpDst = GlobalLock( pMediumDst->hGlobal );

        CopyMemory (lpDst, lpSrc, cbStruct);

        GlobalUnlock( pMediumSrc->hGlobal );
        GlobalUnlock( pMediumDst->hGlobal );

        hr = S_OK;
    }
    else if (pFmt->tymed & TYMED_ISTREAM)
    {
        *pMediumDst = *pMediumSrc;
        pMediumDst->pstm->AddRef();
        hr = S_OK;
    }

exit_gracefully:

    TraceLeaveResult(hr);

}



/*****************************************************************************

   AllocStorageMedium

   Allocate a storage medium (validating the clipboard format as required).
   In:
     pFmt, pMedium -> describe the allocation
     cbStruct = size of allocation
     ppAlloc -> receives a pointer to the allocation / = NULL

     The caller must unlock pMedium->hGlobal after filling in the buffer

 *****************************************************************************/

HRESULT
AllocStorageMedium( FORMATETC* pFmt,
                    STGMEDIUM* pMedium,
                    SIZE_T cbStruct,
                    LPVOID* ppAlloc
                   )
{
    HRESULT hr;

    TraceEnter(TRACE_DATAOBJ, "AllocStorageMedium");

    TraceAssert(pFmt);
    TraceAssert(pMedium);

    // Validate parameters

    if ( ( cbStruct == 0 ) || !( pFmt->tymed & TYMED_HGLOBAL ) )
    {
        Trace(TEXT("cbStruct = 0x%x"), cbStruct );
        Trace(TEXT("pFmt->tymed = 0x%x"), pFmt->tymed);
        ExitGracefully(hr, E_INVALIDARG, "Zero size stored medium requested or non HGLOBAL");
    }

    if ( ( pFmt->ptd ) || !( pFmt->dwAspect & DVASPECT_CONTENT))
    {
        Trace(TEXT("pFmt->ptd = 0x%x"),pFmt->ptd);
        Trace(TEXT("pFmt->dwAspect = 0x%x"),pFmt->dwAspect);
        ExitGracefully(hr, E_INVALIDARG, "Bad format requested");
    }

    // Allocate the medium via GlobalAlloc

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = GlobalAlloc(GHND, cbStruct);
    pMedium->pUnkForRelease = NULL;

    if ( !(pMedium->hGlobal) )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate StgMedium");

    hr = S_OK;                  // success

exit_gracefully:

    if ( ppAlloc )
        *ppAlloc = SUCCEEDED(hr) ? GlobalLock(pMedium->hGlobal):NULL;

    TraceLeaveResult(hr);
}



/*****************************************************************************

   BuildIDListArray

   Return an IDLISt array packed as a clipboard format to the caller. When the
   shell queries for it, ignore property idls.

 *****************************************************************************/

HRESULT
BuildIDListArray (CImageDataObject* pThis,
                  FORMATETC*        pFmt,
                  STGMEDIUM*        pMedium,
                  bool bIncludeAudio)
{

    HRESULT         hr;
    LPIDA           pIDArray = NULL;
    UINT          cbStruct=0, offset;
    INT             i, count, actual, x;
    LPITEMIDLIST   pidl;

    TraceEnter(TRACE_DATAOBJ, "GetShellIDListArray");

    // Compute the structure size (to allocate the medium)

    count = DPA_GetPtrCount(pThis->m_hidl);
    Trace(TEXT("Item count is %d"), count);

    actual = count;

    for ( i = 0 ; i < count ; i++ )
    {
        pidl = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr(pThis->m_hidl, i));
        if ( IsPropertyIDL(pidl) && !bIncludeAudio)
        {
            actual--;
        }
        else
        {
            cbStruct += ILGetSize(pidl);
        }

    }
    offset = sizeof(CIDA) + sizeof(UINT) * actual;
    cbStruct += offset + ILGetSize(pThis->m_pidl);

    hr = AllocStorageMedium(pFmt, pMedium, cbStruct, (LPVOID*)&pIDArray);
    FailGracefully(hr, "Failed to allocate storage medium");

    // Fill the structure with an array of IDLISTs, we use a trick where by the
    // first offset (0) is the root IDLIST of the folder we are dealing with.

    pIDArray->cidl = actual;
    pidl = pThis->m_pidl;       // start with the parent object in offset 0

    for ( i = 0,x=0 ;x<=actual; i++ )
    {
        if (!( IsPropertyIDL(pidl) && !bIncludeAudio))
        {

            UINT cbSize = ILGetSize(pidl);
            Trace(TEXT("Adding IDLIST %08x, at offset %d, index %d"), pidl, offset, x);

            pIDArray->aoffset[x] = offset;
            memcpy(ByteOffset(pIDArray, offset), pidl, cbSize);
            offset += cbSize;
            x++;
        }
        pidl = (LPITEMIDLIST)DPA_GetPtr( pThis->m_hidl, i );
    }

    hr = S_OK;          // success

exit_gracefully:

    if (pIDArray)
    {
        GlobalUnlock (pMedium->hGlobal);
    }
    if ( FAILED(hr) )
        ReleaseStgMedium(pMedium);

    TraceLeaveResult(hr);
}

HRESULT
GetShellIDListArray( CImageDataObject* pThis,
                     FORMATETC*        pFmt,
                     STGMEDIUM*        pMedium
                    )
{
    return BuildIDListArray (pThis, pFmt, pMedium, false);
}

HRESULT
GetMyIDListArray ( CImageDataObject* pThis,
                     FORMATETC*        pFmt,
                     STGMEDIUM*        pMedium
                    )
{
    return BuildIDListArray (pThis, pFmt, pMedium, true);
}

/*****************************************************************************

   SetAudioDescriptorInfo

   Fill in the audio file descriptor info.

 *****************************************************************************/

HRESULT
SetAudioDescriptorInfo( LPFILEDESCRIPTOR pfd,
                        LPITEMIDLIST     pidl,
                        CSimpleStringWide &strName, // must be writable
                        BOOL             bUnicode
                  )
{
    HRESULT          hr;
    CSimpleStringWide strExt;
    TraceEnter (TRACE_DATAOBJ, "SetAudioDescriptorInfo");
    // append the extension
    IMGetAudioFormat (pidl, strExt);
    strName.Concat (strExt);
    // store the new filename

    if (bUnicode)
    {
        wcscpy( ((LPFILEDESCRIPTORW)pfd)->cFileName, strName );
    }
       else
    {
        lstrcpyA( ((LPFILEDESCRIPTORA)pfd)->cFileName, CSimpleStringConvert::AnsiString (strName) );
    }


    Trace(TEXT("Setting name as: %ls"),strName.String());

    //////////////////////////////////////////////////
    // Use the shell UI                             //
    //////////////////////////////////////////////////
    pfd->dwFlags = FD_PROGRESSUI;

    //////////////////////////////////////////////////
    // Try to get the time the picture was taken... //
    //////////////////////////////////////////////////

    hr = IMGetCreateTimeFromIDL( pidl, &pfd->ftCreationTime );
    if (SUCCEEDED(hr))
    {
        pfd->ftLastWriteTime = pfd->ftCreationTime;
        pfd->dwFlags |= (FD_CREATETIME | FD_WRITESTIME);
    }
    else
    {
        Trace(TEXT("Unable to get time from ITEM!!!!"));
        hr = S_OK;
    }


    TraceLeaveResult (hr);
}


/*****************************************************************************

   SetDescriptorInfo

   Fill in the file descriptor info.

 *****************************************************************************/

HRESULT
SetDescriptorInfo( LPFILEDESCRIPTOR pfd,
                   LPITEMIDLIST     pidl,
                   const CSimpleStringWide    &strPrefix,
                   BOOL             bUnicode
                  )
{
    HRESULT          hr;
    CSimpleStringWide strName(strPrefix);
    LPWSTR           pTmp;
    ULONG            ulSize = 0;

    TraceEnter(TRACE_DATAOBJ, "SetDescriptorInfo");

    //
    // First, zero out the file descriptor and prop variant
    //

    ZeroMemory( pfd, bUnicode? SIZEOF(FILEDESCRIPTORW) : SIZEOF(FILEDESCRIPTORA) );


    //
    // Can we get the display name?
    //
    CSimpleStringWide strNew;
    hr = IMGetNameFromIDL( pidl, strNew );

    FailGracefully( hr, "Couldn't get display name for item" );
    strName.Concat (strNew);
    //
    // Defer to the audio property descriptor if needed
    //
    if (IsPropertyIDL (pidl))
    {
        hr = SetAudioDescriptorInfo (pfd, pidl, strName, bUnicode);
        ExitGracefully (hr, hr, "");
    }
    if (IsContainerIDL (pidl))
    {
        pfd->dwFlags = FD_PROGRESSUI | FD_ATTRIBUTES;
        pfd->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_NORMAL ;
    }
    else
    {
        //
        // Get the sizes
        //

        hr = IMGetImageSizeFromIDL( pidl, &ulSize );
        pfd->nFileSizeLow = ulSize;
        //
        // Make sure there's an extension on the name, otherwise
        // tack on a meaningfull one...
        //

        pTmp = PathFindExtensionW(strName.String());
        if (pTmp && (!(*pTmp)))
        {
            GUID guidFormat;
            TCHAR szExt[MAX_PATH];
            hr = IMGetImagePreferredFormatFromIDL( pidl, &guidFormat, szExt );
            if (FAILED(hr))
            {
                CSimpleString bmp( IDS_BMP_EXT, GLOBAL_HINSTANCE );

                lstrcpy( szExt, bmp );
            }
            strName.Concat (CSimpleStringConvert::WideString(CSimpleString(szExt)));
        }

        //////////////////////////////////////////////////
        // Use the shell UI                             //
        //////////////////////////////////////////////////
        pfd->dwFlags = FD_PROGRESSUI | FD_FILESIZE;

        //////////////////////////////////////////////////
        // Try to get the time the picture was taken... //
        //////////////////////////////////////////////////

        hr = IMGetCreateTimeFromIDL( pidl, &pfd->ftCreationTime );
        if (SUCCEEDED(hr))
        {
            pfd->ftLastWriteTime = pfd->ftCreationTime;
            pfd->dwFlags |= (FD_CREATETIME | FD_WRITESTIME);
        }
        else
        {
            Trace(TEXT("Unable to get time from ITEM!!!!"));
            hr = S_OK;
        }
    }


    if (bUnicode)
    {
        wcscpy( ((LPFILEDESCRIPTORW)pfd)->cFileName, CSimpleStringConvert::WideString(strName) );
    }
    else
    {
        lstrcpyA( ((LPFILEDESCRIPTORA)pfd)->cFileName, CSimpleStringConvert::AnsiString(strName) );
    }


    Trace(TEXT("Setting name as: %ls"),strName.String());



exit_gracefully:

    TraceLeaveResult(hr);
}


/*****************************************************************************

    RecursiveGetDescriptorInfo

    Creates a DPA of FILEDESCRIPTORW structs for the IWiaItem tree rooted
    at the given pidl. Also appends the current item's PIDL to m_hidlFull for
    future retrieval during GetData

*****************************************************************************/

HRESULT
RecursiveSetDescriptorInfo (HDPA dpaFiles,
                            HDPA dpaPidls,
                            LPITEMIDLIST pidlRoot,
                            const CSimpleStringWide &strPrefix,
                            bool bUnicode,
                            IMalloc *pm)
{
    HRESULT hr = E_OUTOFMEMORY;
    TraceEnter (TRACE_DATAOBJ, "RecursiveGetDescriptorInfo");
    FILEDESCRIPTOR *pdesc;
    //
    // Allocate the descriptor
    pdesc = reinterpret_cast<LPFILEDESCRIPTOR>(GlobalAlloc (GPTR,
                                                            bUnicode? sizeof(FILEDESCRIPTORW):
                                                                      sizeof(FILEDESCRIPTORA)));
    if (pdesc)
    {
        //
        // Now fill in the descriptor
        //
        hr = SetDescriptorInfo (pdesc, pidlRoot, strPrefix, bUnicode);
        if (SUCCEEDED(hr))
        {
            //
            // Append the pidl to dpaPidls
            DPA_AppendPtr (dpaPidls, ILClone(pidlRoot));
            //
            // Append this descriptor to the list of descriptors
            //
            DPA_AppendPtr (dpaFiles, pdesc);

            //
            // If this is a folder, enum its children and recurse
            //
            if (IsContainerIDL(pidlRoot))
            {
                CComBSTR strPath;
                HDPA dpaChildren = NULL;
                CSimpleStringWide strDeviceId;
                CSimpleStringWide strName;
                INT i;
                INT count = 0;
                // Append this folder's name to the prefix
                CSimpleStringWide strNewPrefix(strPrefix);
                IMGetNameFromIDL (pidlRoot, strName);
                strNewPrefix.Concat (strName);
                strNewPrefix.Concat (L"\\");
                // query the cache for the child items.
                // be sure to include audio items
                _AddItemsFromCameraOrContainer (pidlRoot,
                                            &dpaChildren,
                                            SHCONTF_FOLDERS | SHCONTF_NONFOLDERS,
                                            pm,
                                            true);

                if (dpaChildren)
                {
                    count = DPA_GetPtrCount(dpaChildren);


                    for (i=0;i<count;i++)
                    {

                        pidlRoot = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr(dpaChildren, i));
                        hr = RecursiveSetDescriptorInfo (dpaFiles,
                                                         dpaPidls,
                                                         pidlRoot,
                                                         strNewPrefix,
                                                         bUnicode,
                                                         pm);
                    }
                    DPA_DestroyCallback (dpaChildren, _EnumDestroyCB, NULL);
                }
            }
        }
        else
        {
            GlobalFree (pdesc);
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************

   GetFileDescriptor

   Fill in file descriptor info.

 *****************************************************************************/

HRESULT
GetFileDescriptor( CImageDataObject* pThis,
                    FORMATETC*        pFmt,
                    STGMEDIUM*        pMedium
                   )
{
    HRESULT hr = S_OK;
    LONG count;
    INT i;
    LPVOID pfgd = NULL;
    LPITEMIDLIST pidlRoot;
    bool bUnicode = (pFmt->cfFormat == g_cfFileDescriptorW);
    HDPA dpaBuild = NULL;
    bool doBuild = false;
    TraceEnter(TRACE_DATAOBJ, "GetFileDescriptor");


    if (bUnicode)
    {
        if (!(pThis->m_dpaFilesW))
        {
            doBuild = true;
            pThis->m_dpaFilesW = DPA_Create(10);

        }
        dpaBuild = pThis->m_dpaFilesW;
    }
    else
    {
        if (!(pThis->m_dpaFilesA))
        {
            doBuild = true;
            pThis->m_dpaFilesA = DPA_Create(10);
        }
        dpaBuild = pThis->m_dpaFilesA;
    }
    if (doBuild)

    {

        if (pThis->m_hidlFull)
        {
            DPA_DestroyCallback (pThis->m_hidlFull, _EnumDestroyCB, NULL);
        }

        pThis->m_hidlFull = DPA_Create(10);
        count = DPA_GetPtrCount(pThis->m_hidl);

        for (i = 0; i < count; i++)
        {
            // this builds UNICODE filegroup descriptors
            hr = RecursiveSetDescriptorInfo( dpaBuild,
                                             pThis->m_hidlFull,
                                             reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr( pThis->m_hidl, i )),
                                             CSimpleStringWide(L""),
                                             bUnicode,
                                             pThis->m_pMalloc);
        }
    }
    if (SUCCEEDED(hr))
    {
        size_t n = bUnicode ? sizeof(FILEGROUPDESCRIPTORW) : sizeof (FILEGROUPDESCRIPTORA);
        size_t m = bUnicode ? sizeof(FILEDESCRIPTORW) : sizeof(FILEDESCRIPTORA);
        count = DPA_GetPtrCount(pThis->m_hidlFull);
        Trace(TEXT("Item count is %d"), count);

        hr = AllocStorageMedium( pFmt,
                                 pMedium,
                                 n + (m * (count - 1) ),
                                 &pfgd );

        if (pfgd)
        {
            if (bUnicode)
            {
                LPFILEGROUPDESCRIPTORW pfgdW = reinterpret_cast<LPFILEGROUPDESCRIPTORW>(pfgd);
                pfgdW->cItems = count;
                for (LONG x=0;x<count;x++)
                {
                    CopyMemory (&pfgdW->fgd[x], DPA_FastGetPtr(dpaBuild, x), sizeof(FILEDESCRIPTORW));
                    Trace(TEXT("Uni File name is %ls"), pfgdW->fgd[x].cFileName);
                }
            }
            else
            {
                LPFILEGROUPDESCRIPTORA pfgdA = reinterpret_cast<LPFILEGROUPDESCRIPTORA>(pfgd);
                pfgdA->cItems = count;
                for (LONG x=0;x<count;x++)
                {
                    CopyMemory (&pfgdA->fgd[x], DPA_FastGetPtr(dpaBuild, x), sizeof(FILEDESCRIPTORA));
                    Trace(TEXT("File name is %s"), pfgdA->fgd[x].cFileName);
                }
            }
        }
    }

    if (pfgd)
    {
        GlobalUnlock (pMedium->hGlobal);
    }
    if ( FAILED(hr) )
        ReleaseStgMedium(pMedium);


    TraceLeaveResult(hr);
}




/*****************************************************************************

   GetFileContentsUsingStream

   Return an IStream pointer in the storage medium that can be
   used to stream the file contents.

 *****************************************************************************/

HRESULT
GetFileContentsUsingStream( CImageDataObject* pThis,
                            FORMATETC*        pFmt,
                            STGMEDIUM*        pMedium
                           )
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl;
    TraceEnter(TRACE_DATAOBJ, "GetFileContentsUsingStream" );


    pidl = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr( pThis->m_hidlFull, pFmt->lindex ));
    pMedium->tymed          = TYMED_ISTREAM;
    pMedium->pUnkForRelease = NULL;

    if (IsPropertyIDL (pidl))
    {
        HGLOBAL hData;
        hr = IMGetPropertyFromIDL (pidl, &hData);
        if (SUCCEEDED(hr))
        {
            hr = CreateStreamOnHGlobal (hData, TRUE, &pMedium->pstm);
        }
    }
    else
    {

        if (SUCCEEDED(hr))
        {


            CImageStream * pImageStream = new CImageStream( pThis->m_pidl,
                                                    pidl,
                                                    FALSE);
            if (pImageStream)
            {
                hr = pImageStream->QueryInterface( IID_IStream, (LPVOID *)&pMedium->pstm );
                pImageStream->Release ();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    }

    TraceLeaveResult(hr);

}


/*****************************************************************************

   GetFileContents

   Return the contents of the file in the HGLOBAL.

 *****************************************************************************/

HRESULT
GetFileContents( CImageDataObject* pThis,
                 FORMATETC*        pFmt,
                 STGMEDIUM*        pMedium
                )
{
    HRESULT hr = S_OK;
    TCHAR szName[ MAX_PATH ] = TEXT("\0");
    DWORD dwFileSize, dwbr;
    PVOID pv = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    TraceEnter(TRACE_DATAOBJ, "GetFileContents");
    Trace(TEXT("pFmt->lindex = %d"), pFmt->lindex);

    if (pFmt->lindex < 0)
    {
        ExitGracefully (hr, DV_E_FORMATETC, "Negative index for CF_FILECONTENTS.");
    }
    //
    // Does the caller accept a stream?
    //

    if (pFmt->tymed & TYMED_ISTREAM)
    {
        hr = GetFileContentsUsingStream( pThis, pFmt, pMedium );
        goto leave_gracefully;
    }



    //
    // BUGBUG: Need to cache this!!!
    //

    GetTempPath( ARRAYSIZE(szName), szName );
    lstrcat( szName, TEXT("rtlt") );

    hr = DownloadPicture( szName, (LPITEMIDLIST)DPA_FastGetPtr( pThis->m_hidlFull, pFmt->lindex ), NULL );
    FailGracefully(hr, "Couldn't download picture" );

    //
    // now, transfer contents to memory buffer...
    //

    hFile = CreateFile( szName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        Trace(TEXT("GLE = %d"), GetLastError());
        ExitGracefully( hr, E_FAIL, "CreateFile failed" );
    }

    dwFileSize = GetFileSize( hFile, NULL );
    if (dwFileSize == 0xFFFFFFFF)
    {
        Trace(TEXT("GLE = %d"), GetLastError());
        ExitGracefully( hr, E_FAIL, "couldn't get file size" );
    }

    hr = AllocStorageMedium( pFmt, pMedium, dwFileSize, &pv );
    FailGracefully( hr, "Unable to create stgmedium" );

    if (!ReadFile( hFile, pv, dwFileSize, &dwbr, NULL ))
    {
        Trace(TEXT("GLE = %d"), GetLastError());
        ExitGracefully( hr, E_FAIL, "ReadFile failed" );
    }

exit_gracefully:

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle( hFile );
    }

    if (pv)
    {
        GlobalUnlock (pMedium->hGlobal);
    }
    if ( FAILED(hr) )
        ReleaseStgMedium(pMedium);

    if (szName[0])
    {
        DeleteFile( szName );
    }

leave_gracefully:

    TraceLeaveResult(hr);
}

struct DOWNLOADDATA
{
    LPITEMIDLIST pidl;
    LPSTGMEDIUM pStg;
    LPFORMATETC pFmt;
    HRESULT hr;
};

/*****************************************************************************

   GetDIBFromCamera

   Download a DIB as either a file or an HGLOBAL from the camera. Done in separate
   thread because this is called in response to a sent message (input synchronous)

*******************************************************************************/

VOID
GetDIBFromCamera (DOWNLOADDATA *pData)
{

    WIA_FORMAT_INFO wfi;


    TraceEnter (TRACE_DATAOBJ, "GetDIBFromCamera");
    if (SUCCEEDED(CoInitialize (NULL)) && pData)
    {
        // first get the file. WIA doesn't support TYMED_HGLOBAL
        wfi.lTymed = TYMED_FILE;
        wfi.guidFormatID = WiaImgFmt_BMP;

        pData->hr = GetImageFromCamera (pData->pStg, wfi, pData->pidl, NULL );
        if (S_OK == pData->hr && pData->pFmt->tymed == TYMED_HGLOBAL)
        {
            HBITMAP hbmp;
            CGdiPlusInit gdipInit;
            CSimpleStringWide strTempFile = pData->pStg->lpszFileName;
            Bitmap img(strTempFile, 1);
            // convert from file to HGLOBAL
            pData->hr  = ((Ok == img.GetHBITMAP(NULL, &hbmp)) ? S_OK : E_FAIL);

            if (SUCCEEDED(pData->hr))
            {
                HDC hdc = GetDC(NULL);                
                pData->pStg->tymed = TYMED_HGLOBAL;
                pData->pStg->hGlobal= BitmapToDIB(hdc, hbmp);
                ReleaseDC(NULL, hdc);
                DeleteObject(hbmp);
            }
            // Now delete the temp file
            #ifdef UNICODE
            DeleteFile (strTempFile);
            #else
            CSimpleString strPathA = CSimpleStringConvert::NaturalString(strTempFile);
            DeleteFile (strPathA);
            #endif //UNICODE
         
        }
        MyCoUninitialize ();
    }
    TraceLeave();
}

/*****************************************************************************

   GetSoundFromCamera

   Download the audio property of an IWiaItem as a memory WAV file

******************************************************************************/

VOID
GetSoundFromCamera (DOWNLOADDATA *pData)
{
    pData->hr = E_FAIL;
    TraceEnter (TRACE_CORE, "GetSoundFromCamera");
    TraceAssert (IMItemHasSound(pData->pidl));
    TraceAssert (CF_WAVE == pData->pFmt->cfFormat);
    HRESULT hrCo = CoInitialize (NULL); 
    if (SUCCEEDED(hrCo))
    {

        CComPtr<IWiaItem> pItem;
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps;

        IMGetItemFromIDL (pData->pidl, &pItem);

        // For hglobal just read the bits straight into a memory object
        if (pData->pFmt->tymed == TYMED_HGLOBAL)
        {
            PROPVARIANT pv;
            PROPSPEC ps;
            ps.propid = WIA_IPC_AUDIO_DATA;
            ps.ulKind = PRSPEC_PROPID;

            pps = pItem;
            if (pps && S_OK == pps->ReadMultiple(1, &ps, &pv))
            {
                pData->pStg->hGlobal = GlobalAlloc (GHND, pv.caub.cElems);
                if (pData->pStg->hGlobal)
                {
                    LPBYTE pBits = reinterpret_cast<LPBYTE>(GlobalLock (pData->pStg->hGlobal));
                    //sometimes globallock can fail
                    if (pBits)
                    {
                        CopyMemory (pBits, pv.caub.pElems, pv.caub.cElems);
                        pData->pStg->tymed = TYMED_HGLOBAL;
                        GlobalUnlock (pData->pStg->hGlobal);
                    }
                    else
                    {
                        GlobalFree (pData->pStg->hGlobal);
                        pData->pStg->hGlobal = NULL;
                        pData->hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    pData->hr = E_OUTOFMEMORY;
                }
            }
        }
        else if (pData->pFmt->tymed == TYMED_FILE)
        {
            // if pStg is already initialized with a filename , use that one
            CSimpleString strFile;
            bool bTemp = true;
            if (pData->pStg->lpszFileName && *(pData->pStg->lpszFileName))
            {
                bTemp = false;
                strFile = CSimpleStringConvert::NaturalString(CSimpleStringWide(pData->pStg->lpszFileName));
            }
            else // use a temp file
            {
                TCHAR szFileName[MAX_PATH] = TEXT("\0");
                GetTempPath (MAX_PATH, szFileName);
                GetTempFileName (szFileName, TEXT("CAM"), 0, szFileName);
                strFile = szFileName;
            }
            pData->hr = SaveSoundToFile (pItem, strFile);
            if (SUCCEEDED(pData->hr))
            {
                if (bTemp)
                {
                    pData->pStg->lpszFileName = SysAllocString (CSimpleStringConvert::WideString(CSimpleString(strFile)));
                }

                pData->pStg->tymed = TYMED_FILE;
            }
        }
        else
        {
            pData->hr = DV_E_TYMED;
        }
    }
    if (SUCCEEDED(hrCo))
    {
        MyCoUninitialize();
    }
    TraceLeave ();
}
/*****************************************************************************

   GetSupportedFormat

   Return the contents of the file for the supported format. Use a separate
   thread to avoid trying to call out of process during input message processing.

 *****************************************************************************/

HRESULT
GetSupportedFormat( CImageDataObject* pThis,
                    FORMATETC*        pFmt,
                    STGMEDIUM*        pMedium
                   )
{
    HRESULT               hr = DV_E_FORMATETC;
    LPITEMIDLIST          pidl;
    INT                  nItems;

    TraceEnter(TRACE_DATAOBJ, "GetSupportedFormat");

    nItems = DPA_GetPtrCount (pThis->m_hidl);
    // Ignore the audio property pidl if it exists
    //
    pidl = (LPITEMIDLIST)DPA_FastGetPtr( pThis->m_hidl, 0 );
    if (IMItemHasSound(pidl))
    {
        nItems--;
    }
    if (nItems == 1)
    {
        DOWNLOADDATA data;
        HANDLE hThread = NULL;
        DWORD dw;
        data.pFmt = pFmt;
        data.pidl = pidl;
        data.pStg = pMedium;

        switch (pFmt->cfFormat)
        {

            case CF_DIB:
                hThread =CreateThread (NULL, 0,
                                       reinterpret_cast<LPTHREAD_START_ROUTINE>( GetDIBFromCamera),
                                       reinterpret_cast<LPVOID>(&data),
                                       0, &dw);

                break;

            case CF_WAVE:
                hThread =CreateThread (NULL, 0,
                                       reinterpret_cast<LPTHREAD_START_ROUTINE>( GetSoundFromCamera),
                                       reinterpret_cast<LPVOID>(&data),
                                       0, &dw);
                break;
        }
        if (hThread)
        {
            WaitForSingleObject (hThread, INFINITE);
            CloseHandle (hThread);
            hr = data.hr;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TraceLeaveResult( hr );

}



/*****************************************************************************

   GetPreferredEffect

   Returns the preferred drop effect for drag & drop operations

 *****************************************************************************/

HRESULT
GetPreferredEffect( CImageDataObject* pThis,
                    FORMATETC*        pFmt,
                    STGMEDIUM*        pMedium
                   )
{
    HRESULT hr;
    DWORD * lpdw = NULL;

    TraceEnter(TRACE_DATAOBJ, "GetPreferredEffect" );

    hr = AllocStorageMedium( pFmt,
                             pMedium,
                             sizeof(DWORD),
                             (LPVOID *)&lpdw );

    if (SUCCEEDED(hr) && lpdw)
    {
        *lpdw = DROPEFFECT_COPY;
        GlobalUnlock (pMedium->hGlobal);
    }


    TraceLeaveResult( hr );
}

/*****************************************************************************

    GetDeviceName

    Return the STI device name. Only works for singular objects

******************************************************************************/

HRESULT
GetDeviceName (CImageDataObject *pThis,
               FORMATETC *pFmt,
               STGMEDIUM *pMedium)
{
    HRESULT               hr;
    LPITEMIDLIST          pidl;
    CSimpleStringWide     strDeviceName;
    UINT cbSize;
    TraceEnter(TRACE_DATAOBJ, "GetDeviceName");

    if (!pFmt->tymed & TYMED_HGLOBAL)
    {
        ExitGracefully (hr, DV_E_TYMED, "");
    }
    if (DPA_GetPtrCount( pThis->m_hidl ) > 1)
    {
        ExitGracefully( hr, E_INVALIDARG, "can't get contents for more than one file" );
    }

    pidl = (LPITEMIDLIST)DPA_FastGetPtr( pThis->m_hidl, 0 );

    hr = IMGetDeviceIdFromIDL (pidl, strDeviceName);

    FailGracefully (hr, "");
    pMedium->tymed = TYMED_HGLOBAL;
    cbSize = (strDeviceName.Length()+1)*sizeof(WCHAR);
    pMedium->hGlobal = GlobalAlloc (GPTR, cbSize);
    pMedium->pUnkForRelease = NULL;

    if (!(pMedium->hGlobal))
    {
        ExitGracefully (hr, E_OUTOFMEMORY, "");
    }
    CopyMemory (pMedium->hGlobal, strDeviceName.String(), cbSize);
exit_gracefully:
    TraceLeaveResult( hr );

}

/****************************************************************************

    GetExtNames

    Return a struct that has the full path names of the items for which
    properties are being queried.
    The path name is <deviceid>::<full item name>
    full item name is empty for devices. We publish this format in the DDK and
    SDK for extensibility

****************************************************************************/

HRESULT
GetExtNames (CImageDataObject *pThis,
          FORMATETC *pFmt,
          STGMEDIUM *pMedium)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_DATAOBJ, "GetExtNames");
    CSimpleDynamicArray<CSimpleStringWide> aNames;
    CSimpleStringWide strCurrent;
    int cItems;
    size_t nChars = 0;
    if (!(pFmt->tymed & TYMED_HGLOBAL))
    {
        hr = DV_E_TYMED;
    }
    if (SUCCEEDED(hr))
    {
        // build an array of item names
        LPWSTR pData;
        LPITEMIDLIST pidlCur;
        cItems = DPA_GetPtrCount (pThis->m_hidl);
        TraceAssert (cItems);
        for (int i=0;i<cItems;i++)
        {
            pidlCur = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr(pThis->m_hidl, i));
            IMGetDeviceIdFromIDL (pidlCur, strCurrent);
            strCurrent.Concat (L"::");
            if (IsCameraItemIDL (pidlCur))
            {
                CComBSTR strName;
                IMGetFullPathNameFromIDL (pidlCur, &strName);
                strCurrent.Concat (CSimpleStringWide(strName));
            }
            nChars += strCurrent.Length () + 1;
            aNames.Insert (strCurrent, i);

        }
        nChars++; // double-NULL terminator
        //
        // Alloc the stgmedium
        hr = AllocStorageMedium (pFmt,
                                 pMedium,
                                 nChars*sizeof(WCHAR),
                                 reinterpret_cast<LPVOID*>(&pData));

        if (SUCCEEDED(hr))
        {
            ZeroMemory (pData, nChars*sizeof(WCHAR));
            // fill in the buffer with the names from the array
            for (i=0;i<cItems;i++)
            {
                strCurrent = aNames[i];
                wcscpy (pData, strCurrent);
                pData += strCurrent.Length()+1;
            }
            GlobalUnlock (pMedium->hGlobal);
        }
    }
    TraceLeaveResult (hr);

}
/*****************************************************************************
    GetPersistObj

    When the copy source goes away (the process or apartment shuts down), it calls
    OleFlushClipboard.  OLE will then copy our data, release us, and then
    give out our data later.  This works for most things except for CF_DIB, where
    we don't want to copy from the camera unless someone actually asks for it.

   To get around this problem, we want OLE to recreate us when some possible
   paste target calls OleGetClipboard.  We want OLE to call OleLoadFromStream()
   to have us CoCreated and reload our persisted data via IPersistStream.
   OLE doesn't want to do this by default or they may have backward compat
   problems so they want a sign from the heavens, or at least from us, that
   we will work.  They ping our "OleClipboardPersistOnFlush" clipboard format
   to ask this.
*****************************************************************************/

HRESULT
GetPersistObj (CImageDataObject *pThis,
               FORMATETC *pFmt,
               STGMEDIUM *pMedium)
{
    TraceEnter (TRACE_DATAOBJ, "GetPersistObj");
    // The actual cookie value is opaque to the outside world.  Since
    // we don't use it either, we just leave it at zero in case we use
    // it in the future.  Its mere existence will cause OLE to
    // use our IPersistStream, which is what we want.
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwCookie = 0;
    LPVOID p;
    pMedium->hGlobal = GlobalAlloc (GHND, sizeof(dwCookie));
    if (pMedium->hGlobal)
    {
        p = GlobalLock (pMedium->hGlobal);
        CopyMemory (p, &dwCookie, sizeof(dwCookie));
        GlobalUnlock (pMedium->hGlobal);
        hr = S_OK;
    }

    TraceLeaveResult (hr);
}

/******************************************************************************
    ProgramDataObjectForExtension
    
    In the single-selection case we need to support 
    a useful way of sharing the IWiaItem interface among all
    interested pages. The old WinME based way of using QueryInterface
    on the IDataObject violates COM rules (different IUnknowns) and
    doesn't allow the IDataObject to be marshalled across thread boundaries 
    if needed. So we marshal an IWiaItem from the current thread
    into an IStream to be unmarshalled as needed by an interested page.
    Eventually all our own extensions should operate on this shared item.
    
******************************************************************************/

VOID ProgramDataObjectForExtension (IDataObject *pdo, LPITEMIDLIST pidl)
{
    CComPtr<IWiaItem> pItem;
    if (SUCCEEDED(IMGetItemFromIDL (pidl, &pItem)))
    {
        ProgramDataObjectForExtension (pdo, pItem);
    }
}

VOID ProgramDataObjectForExtension (IDataObject *pdo, IWiaItem *pItem)
{
    FORMATETC fmt;
    STGMEDIUM stgm = {0};
    fmt.cfFormat = static_cast<CLIPFORMAT>(RegisterClipboardFormat (CFSTR_WIAITEMPTR));
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex = -1;
    fmt.ptd = NULL;
    fmt.tymed = TYMED_ISTREAM;
    stgm.tymed = TYMED_ISTREAM;
    CoMarshalInterThreadInterfaceInStream (IID_IWiaItem, pItem, &stgm.pstm);
    if (FAILED(pdo->SetData (&fmt, &stgm, TRUE)))
    {
        ReleaseStgMedium(&stgm);
    }
}

#ifdef DEBUG
LPTSTR BadCFFormat( UINT cfFormat )
{

    LPTSTR pName = TEXT("unknown");

    switch (cfFormat)
    {
    case CF_TEXT:
        pName = TEXT("CF_TEXT");
        break;

    case CF_BITMAP:
        pName = TEXT("CF_BITMAP");
        break;

    case CF_METAFILEPICT:
        pName = TEXT("CF_METAFILEPICT");
        break;

    case CF_SYLK:
        pName = TEXT("CF_SYLK");
        break;

    case CF_DIF:
        pName = TEXT("CF_DIF");
        break;

    case CF_TIFF:
        pName = TEXT("CF_TIFF");
        break;

    case CF_OEMTEXT:
        pName = TEXT("CF_OEMTEXT");
        break;

    case CF_DIB:
        pName = TEXT("CF_DIB");
        break;

    case CF_PALETTE:
        pName = TEXT("CF_PALETTE");
        break;

    case CF_PENDATA:
        pName = TEXT("CF_PENDATA");
        break;

    case CF_RIFF:
        pName = TEXT("CF_RIFF");
        break;

    case CF_WAVE:
        pName = TEXT("CF_WAVE");
        break;

    case CF_UNICODETEXT:
        pName = TEXT("CF_UNICODETEXT");
        break;

    case CF_ENHMETAFILE:
        pName = TEXT("CF_ENHMETAFILE");
        break;

    }

    return pName;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\inc\unknown.inc ===
/*----------------------------------------------------------------------------
/ Title;
/   unknown.inc
/
/ Authors;
/   David De Vorchik (daviddv)
/
/ Notes;
/   Magic include file to help with implementing IUnknown
/----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------
/ Macros to handle AddRef & Release (by calling CUnknown methods)
/----------------------------------------------------------------------------*/

STDMETHODIMP_(ULONG) CLASS_NAME::AddRef()
{
    return CUnknown::HandleAddRef();
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP_(ULONG) CLASS_NAME::Release()
{
    return CUnknown::HandleRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\details.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       details.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      DavidShi
 *
 *  DATE:        4/1/99
 *
 *  DESCRIPTION: CFolderDetails defintion
 *
 *****************************************************************************/

#ifndef __details_h
#define __details_h

enum folder_type {
    FOLDER_IS_UNKNOWN = 0,
    FOLDER_IS_ROOT,
    FOLDER_IS_SCANNER_DEVICE,
    FOLDER_IS_CAMERA_DEVICE,
    FOLDER_IS_VIDEO_DEVICE,
    FOLDER_IS_CONTAINER,
    FOLDER_IS_CAMERA_ITEM
    };

// Implement IShellDetails in a separate object because of method name
// collision with IShellFolder2

class CFolderDetails : public IShellDetails, public CUnknown
{
 public:
    CFolderDetails (folder_type type) : m_type(type) {};
    //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    // IShellDetails
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails);
    STDMETHOD(ColumnClick)(UINT iColumn);
    static HRESULT GetDetailsForPidl (LPCITEMIDLIST pidl, INT idColName, LPSHELLDETAILS pDetails);

 private:

     folder_type m_type;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\dataobj2.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       dataobj2.h
 *
 *
 *  DESCRIPTION: Cleanup of dataobj.h, which is the IDataObject
 *               implementation for the WIA shell extension.
 *
 *****************************************************************************/

#ifndef __dataobj_h
#define __dataobj_h

/*****************************************************************************

   Registered clipboard formats

 *****************************************************************************/

void RegisterImageClipboardFormats(void);
HRESULT DownloadPicture( LPTSTR pFile, LPITEMIDLIST pidl, HWND hwndOwner );

class CImageDataObject;

typedef HRESULT (*PFNFORMATFUNC)(CImageDataObject* pThis, FORMATETC* pFmt, STGMEDIUM* pMedium);

typedef struct {
    FORMATETC     fmt;
    STGMEDIUM     medium;
    STGMEDIUM*    pStg;
    PFNFORMATFUNC pfn;
} IMAGE_FORMAT, *LPIMAGE_FORMAT;

typedef struct {
    WORD cfFormat;
    LPTSTR szName;
    PFNFORMATFUNC pfn;
} FORMAT_TABLE;

#define IMCF_SHELLIDLIST        0
#define IMCF_FILEDESCRIPTORA    1
#define IMCF_FILEDESCRIPTORW    2
#define IMCF_FILECONTENTS       3
#define IMCF_CFDIB              4
#define IMCF_PREFERREDEFFECT    5
#define IMCF_NAME               6
#define IMCF_OLEPERSIST         7
#define IMCF_EXTNAMES           8
#define IMCF_IDLIST             9
#define IMCF_MAX                10

extern FORMAT_TABLE g_clipboardFormats[IMCF_MAX];
extern const GUID CLSID_ImageFolderDataObj;

#define g_cfShellIDList         g_clipboardFormats[IMCF_SHELLIDLIST].cfFormat
#define g_cfFileDescriptorA     g_clipboardFormats[IMCF_FILEDESCRIPTORA].cfFormat
#define g_cfFileDescriptorW     g_clipboardFormats[IMCF_FILEDESCRIPTORW].cfFormat
#define g_cfFileContents        g_clipboardFormats[IMCF_FILECONTENTS].cfFormat
#define g_cfCF_DIB              g_clipboardFormats[IMCF_CFDIB].cfFormat
#define g_cfPreferredEffect     g_clipboardFormats[IMCF_PREFERREDEFFECT].cfFormat
#define g_cfName                g_clipboardFormats[IMCF_NAME].cfFormat
#define g_cfOlePersist          g_clipboardFormats[IMCF_OLEPERSIST].cfFormat
#define g_cfExtNames            g_clipboardFormats[IMCF_EXTNAMES].cfFormat
#define g_cfMyIDList            g_clipboardFormats[IMCF_IDLIST].cfFormat


/*****************************************************************************

   CImageDataObject definition

 *****************************************************************************/

class CImageDataObject : public IDataObject, IPersistStream, IAsyncOperation, CUnknown
{
    private:


        ~CImageDataObject();
        CComPtr<IWiaItem>   m_pItem;


        // no copy constructor or assignment operator should work
        CImageDataObject &CImageDataObject::operator =(IN const CImageDataObject &rhs);
        CImageDataObject::CImageDataObject(IN const CImageDataObject &rhs);
        BOOL m_bCanAsync;
        BOOL m_bInOp;
        BOOL m_bHasPropertyPidls;

    public:


        HDPA                m_hidl;
        HDPA                m_hidlFull; // fully expanded tree
        HDPA                m_hformats;
        HDPA                m_dpaFilesW;
        HDPA                m_dpaFilesA;
        LPITEMIDLIST        m_pidl;
        CSimpleCriticalSection m_cs;
        CComPtr<IMalloc>    m_pMalloc;

        CImageDataObject( IWiaItem *pItem = NULL);
        HRESULT Init (LPCITEMIDLIST pidlRoot, INT cidl, LPCITEMIDLIST *aidl, IMalloc *pm);

        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IDataObject
        STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
        STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
        STDMETHODIMP QueryGetData(FORMATETC *pformatetc);
        STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn, FORMATETC *pformatetcOut);
        STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease);
        STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc);
        STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection);
        STDMETHODIMP DUnadvise(DWORD dwConnection);
        STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

        // IPersistStream
        STDMETHODIMP Load (IStream *pstm);
        STDMETHODIMP Save (IStream *pstm, BOOL bPersist);
        STDMETHODIMP IsDirty ();
        STDMETHODIMP GetSizeMax (ULARGE_INTEGER *ulMax);
        STDMETHODIMP GetClassID (GUID *pclsid);

        // IAsyncOperation
        STDMETHODIMP SetAsyncMode(BOOL fDoOpAsync);
        STDMETHODIMP GetAsyncMode(BOOL *pfIsOpAsync);
        STDMETHODIMP StartOperation(IBindCtx *pbcReserved) ;
        STDMETHODIMP InOperation(BOOL *pfInAsyncOp) ;
        STDMETHODIMP EndOperation(HRESULT hResult,
                                  IBindCtx *pbcReserved,
                                  DWORD dwEffects);
};



/*****************************************************************************

   CImageEnumFormatETC definition

 *****************************************************************************/

class CImageEnumFormatETC : public IEnumFORMATETC, CUnknown
{
    private:
        INT m_index;
        CImageDataObject* m_pThis;
        ~CImageEnumFormatETC();

    public:
        CImageEnumFormatETC( CImageDataObject *pThis );

        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IEnumIDList
        STDMETHODIMP Next(ULONG celt, FORMATETC* rgelt, ULONG* pceltFetched);
        STDMETHODIMP Skip(ULONG celt);
        STDMETHODIMP Reset();
        STDMETHODIMP Clone(LPENUMFORMATETC* ppenum);
};

VOID ProgramDataObjectForExtension (IDataObject *pdo, LPITEMIDLIST pidl);
VOID ProgramDataObjectForExtension (IDataObject *pdo, IWiaItem *pItem);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\dll.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       dll.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: dll init code & various other helper routines such as
 *               server registration.
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

//
// Some ATL support routines
//

#include <atlimpl.cpp>

//#define IMAGE_LOGFILE 1


/*****************************************************************************

   Globals for this module

 *****************************************************************************/

const GUID CLSID_ImageFolderDataObj   = {0x3f953603L,0x1008,0x4f6e,{0xa7,0x3a,0x04,0xaa,0xc7,0xa9,0x92,0xf1}}; // {3F953603-1008-4f6e-A73A-04AAC7A992F1}

HINSTANCE g_hInstance = 0;


#ifdef DEBUG
extern DWORD g_dwMargin;
#endif
extern DWORD g_tls;
#ifdef IMAGE_LOGFILE
extern CRITICAL_SECTION cs;
extern TCHAR szLogFile[MAX_PATH];
#endif


/*****************************************************************************

   DllMain

   Main entry point for this dll.  We are passed reason codes and assorted
   other information when loaded or closed down.

 *****************************************************************************/

EXTERN_C BOOL DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID pReserved )
{
    BOOL bRet = TRUE;
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
        {
            SHFusionInitializeFromModuleID( hInstance, 123 );

#ifdef IMAGE_LOGFILE
            InitializeCriticalSection( &cs );
            GetSystemDirectory( szLogFile, ARRAYSIZE(szLogFile) );
            lstrcat( szLogFile, TEXT("\\wiashext.log") );
#endif

#ifdef DEBUG
            // set the debug margin index before any debug output

            g_dwMargin = TlsAlloc();
            DllSetTraceMask();
#endif
            TraceEnter( TRACE_SETUP, "DLL_PROCESS_ATTACH" );


            g_hInstance = hInstance;
            Trace( TEXT("g_hInstance = 0x%x"), g_hInstance );
            // if our TLS index fails to allocate, we're ok. We'll just
            // take a big perf hit because we can't cache
            // IWiaItem root pointers on a per thread basis.
            g_tls = TlsAlloc();


            TraceLeave( );
            break;
        }

        case DLL_THREAD_DETACH:
            {
                TLSDATA *pv =   reinterpret_cast<TLSDATA*>(TlsGetValue (g_tls));
                if (pv)
                {
                    delete pv;
                }
            }
            break;

        case DLL_PROCESS_DETACH:
        {
            SHFusionUninitialize();
            TlsFree (g_tls);
#ifdef IMAGE_LOGFILE
            DeleteCriticalSection( &cs );
#endif
#ifdef DEBUG
            TlsFree (g_dwMargin);
#endif
            break;
        }
    }

    return bRet;
}



/*****************************************************************************

   DllCanUnloadNow

   Called by the outside world to determine if our DLL can be
   unloaded.  If we have any objects in existance then we must
   not unload.

 *****************************************************************************/

STDAPI DllCanUnloadNow( void )
{
    return GLOBAL_REFCOUNT ? S_FALSE : S_OK;
}



/*****************************************************************************

   DllGetClassObject

   Given a class ID and an interface ID, return the relevant object.
   This is used by the outside world to access the objects implemented
   in this DLL.


 *****************************************************************************/

STDAPI DllGetClassObject( REFCLSID rCLSID, REFIID riid, LPVOID* ppVoid)
{
    HRESULT hr = E_OUTOFMEMORY;
    CImageClassFactory* pClassFactory = NULL;

    TraceEnter(TRACE_CORE, "DllGetClassObject");
    TraceGUID("Object requested", rCLSID);
    TraceGUID("Interface requested", riid);

    *ppVoid = NULL;

    if ( IsEqualIID(riid, IID_IClassFactory) )
    {
        pClassFactory = new CImageClassFactory(rCLSID);

        if ( !pClassFactory )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create the class factory");

        hr = pClassFactory->QueryInterface(riid, ppVoid);

    }
    else
    {
        ExitGracefully(hr, E_NOINTERFACE, "IID_IClassFactory not passed as an interface");
    }

exit_gracefully:
    DoRelease (pClassFactory);
    TraceLeaveResult(hr);
}


/*****************************************************************************

   DllRegisterServer

   Called by regsvr32 to register this component.

 *****************************************************************************/

EXTERN_C STDAPI DllRegisterServer( void )
{
    HRESULT hr = S_OK;
    bool bInstallAllViews;
    TraceEnter(TRACE_SETUP, "DllRegisterServer");

    //
    // Do our dll reg from .inf first...
    //

#ifdef WINNT
    hr = WiaUiUtil::InstallInfFromResource( GLOBAL_HINSTANCE, "RegDllNT" );
#else
    hr = WiaUiUtil::InstallInfFromResource( GLOBAL_HINSTANCE, "RegDllWin98" );
#endif

    TraceLeaveResult( hr );
}



/*****************************************************************************

   DllUnregisterServer

   Called by regsvr32 to unregister our dll

 *****************************************************************************/

EXTERN_C STDAPI DllUnregisterServer( void )
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_SETUP, "DllUnregisterServer");

    //
    // Try to remove the HKCR\CLSID\{our clsid} key...
    //

#ifdef WINNT
    hr = WiaUiUtil::InstallInfFromResource( GLOBAL_HINSTANCE, "UnregDllNT" );
#else
    hr = WiaUiUtil::InstallInfFromResource( GLOBAL_HINSTANCE, "UnregDllWin98" );
#endif


    TraceLeaveResult(hr);

}




/*****************************************************************************

   DllSetTraceMask

   Read from the registry and setup the debug level based on the
   flags stored there.

 *****************************************************************************/

#ifdef DEBUG
void DllSetTraceMask(void)
{
    DWORD dwTraceMask;

    CSimpleReg keyCLSID( HKEY_CLASSES_ROOT,
                         REGSTR_PATH_NAMESPACE_CLSID,
                         false,
                         KEY_READ
                        );
    dwTraceMask = keyCLSID.Query( TEXT("TraceMask"), (DWORD)0 );
    TraceSetMask( dwTraceMask );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\dll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dll.h
//
//--------------------------------------------------------------------------

#ifndef __dll_h
#define __dll_h

extern HINSTANCE g_hInstance;
#define GLOBAL_HINSTANCE (g_hInstance)

EXTERN_C BOOL DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID pReserved );
STDAPI DllCanUnloadNow( void );
STDAPI DllGetClassObject( REFCLSID rCLSID, REFIID riid, LPVOID* ppvVoid );

HRESULT CallRegInstall(HINSTANCE hInstance, LPSTR szSection);

#ifdef DEBUG
void DllSetTraceMask(void);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\details.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       details.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      DavidShi
 *
 *  DATE:        4/1/99
 *
 *  DESCRIPTION: This code implements the IShellDetails interface (and
 *               associated interfaces) for the WIA shell extension.
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

HRESULT IMGetPropFromIDL (LPITEMIDLIST pidl, PROPID pid, PROPVARIANT &pv);

DEFINE_SCID(SCID_DEVNAME, PSGUID_WIAPROPS, WIA_DIP_DEV_NAME);
DEFINE_SCID(SCID_DEVCLASS, PSGUID_WIAPROPS, WIA_DIP_DEV_TYPE);

enum
{
    DEVCOL_NAME = 0,
    DEVCOL_CLASS

};

static const COL_DATA c_device_cols [] =
{
    {DEVCOL_NAME, IDS_DEVICENAME, 32, LVCFMT_LEFT, &SCID_DEVNAME},
    {DEVCOL_CLASS, IDS_DEVICECLASS, 16, LVCFMT_LEFT, &SCID_DEVCLASS},

};

DEFINE_SCID(SCID_ITEMNAME, PSGUID_STORAGE,  PID_STG_NAME);
DEFINE_SCID(SCID_ITEMTYPE, PSGUID_WIAPROPS, WIA_IPA_ITEM_FLAGS);
DEFINE_SCID(SCID_ITEMDATE, PSGUID_STORAGE,  PID_STG_WRITETIME);
DEFINE_SCID(SCID_ITEMSIZE, PSGUID_STORAGE,  PID_STG_SIZE);

enum
{
    CAMCOL_NAME=0,
    CAMCOL_TYPE,
    CAMCOL_DATE,
    CAMCOL_SIZE
};

static const COL_DATA c_camera_cols [] =
{
    {CAMCOL_NAME, IDS_ITEMNAME, 32, LVCFMT_LEFT, &SCID_ITEMNAME},
    {CAMCOL_TYPE, IDS_ITEMTYPE, 16, LVCFMT_LEFT, &SCID_ITEMTYPE},
    {CAMCOL_DATE, IDS_ITEMDATE, 16, LVCFMT_LEFT, &SCID_ITEMDATE},
    {CAMCOL_SIZE, IDS_ITEMSIZE, 16, LVCFMT_LEFT, &SCID_ITEMSIZE},

};


#define PID_CANTAKEPICTURE    0
#define PID_PICSTAKEN         1
#define PID_FOLDERPATH        2

static const WEBVW_DATA c_webview_props [] =
{
    {PID_CANTAKEPICTURE, CanTakePicture},
    {PID_PICSTAKEN, NumPicsTaken},
    {PID_FOLDERPATH, GetFolderPath}
};
// we want to use our camera item details in the web view Detail section
static const WCHAR c_szWebvwDetails[] = L"prop:{38276c8a-dcad-49e8-85e2-b73892fffc84}4098;{38276c8a-dcad-49e8-85e2-b73892fffc84}4101;{38276c8a-dcad-49e8-85e2-b73892fffc84}4100;{38276c8a-dcad-49e8-85e2-b73892fffc84}4116";

// a different detail for the camera itself, shown when no picture is selected in the view
static const WCHAR c_szCameraDetails[] = L"prop:{b725f130-47ef-101a-a5f1-02608c9eebac}10;{38276c8a-dcad-49e8-85e2-b73892fffc84}4101;{6e79e3c5-fd7f-488f-a10d-156636e1c71c}1";

const GUID FMTID_WEBVWPROPS = {0x6e79e3c5,0xfd7f,0x488f,{0xa1, 0x0d, 0x15, 0x66, 0x36, 0xe1, 0xc7, 0x1c}};




/*****************************************************************************

   CImageFolder::GetDetailsOf [IShellFolder2]

   Returns details for the given item

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetDetailsOf( LPCITEMIDLIST pidl,
                            UINT iColumn,
                            LPSHELLDETAILS pDetails
                           )
{

    HRESULT hr = E_OUTOFMEMORY;


    TraceEnter(TRACE_DETAILS, "CImageFolder::GetDetailsOf" );
    if (!m_pShellDetails)
    {
        m_pShellDetails = new CFolderDetails (m_type);
    }

    if (m_pShellDetails)
    {
        hr = m_pShellDetails->GetDetailsOf (pidl, iColumn, pDetails);
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CImageFolder::GetDefaultColumnState [IShellFolder2]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetDefaultColumnState( UINT iColumn,
                                     DWORD *pbState
                                    )
{
    TraceEnter(TRACE_DETAILS, "CImageFolder::GetDefaultColumnState" );
    *pbState = SHCOLSTATE_ONBYDEFAULT;
    TraceLeaveResult(S_OK);
}



/*****************************************************************************

   CImageFolder::GetDefaultColumn [IShellFolder2]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetDefaultColumn (DWORD dwReserved, ULONG *pSort, ULONG *pDisplay)
{

    HRESULT hr = S_OK;
    TraceEnter (TRACE_DETAILS, "CImageFolder::GetDefaultColumn");
    if (pSort)
    {
        *pSort = 0;
    }
    if (pDisplay)
    {
        *pDisplay = 0;
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CImageFolder::GetWebviewProperty

   Find the function to generate the appropriate VARIANT and call it

*****************************************************************************/
HRESULT
CImageFolder::GetWebviewProperty (LPITEMIDLIST pidl, const FMTID &fmtid, DWORD dwPid, VARIANT *pv)
{
    HRESULT hr = S_OK;
    const WEBVW_DATA *pData;
    size_t n = 0;

    TraceEnter (TRACE_DETAILS, "CImageFolder::GetWebviewProperty");
    TraceAssert(IsEqualGUID(fmtid, FMTID_WEBVWPROPS))
    pData = c_webview_props;
    n = ARRAYSIZE(c_webview_props);
    
    for (size_t i=0;i<n;i++)
    {
        if (pData[i].dwPid == dwPid)
        {
            hr = pData[i].fnProp (this, pidl, dwPid, pv);
        }
    }
    TraceLeaveResult (hr);
}
#ifndef SHDID_COMPUTER_IMAGING
#define SHDID_COMPUTER_IMAGING      18
#endif
/*****************************************************************************

    CImageFolder::GetShellDetail
    
    Return properties that we support under FMTID_ShellDetails
    
*****************************************************************************/
HRESULT 
CImageFolder::GetShellDetail (LPITEMIDLIST pidl, DWORD dwPid, VARIANT *pv)
{
    HRESULT hr = E_NOTIMPL;
    if (IsDeviceIDL(pidl) && PID_DESCRIPTIONID == dwPid)
    {
        SHDESCRIPTIONID did;
        did.clsid = CLSID_NULL;
        did.dwDescriptionId = SHDID_COMPUTER_IMAGING;
        SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1, 0, sizeof(did));   // create a one-dimensional safe array
        if (psa) 
        {
            memcpy(psa->pvData, &did, sizeof(did));

            memset(pv, 0, sizeof(*pv));  // VariantInit()
            pv->vt = VT_ARRAY | VT_UI1;
            pv->parray = psa;
            hr = S_OK;
        }
        else
        {        
            hr = E_OUTOFMEMORY;
        }        
    }
    return hr;
}
/*****************************************************************************

   CImageFolder::GetDetailsEx [IShellFolder2]

   Map the given column FMTID and PROPID to the corresponding value for the
   given pidl.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetDetailsEx( LPCITEMIDLIST pidl,
                            const SHCOLUMNID *pscid,
                            VARIANT *pv
                           )
{
    HRESULT hr = E_NOTIMPL;
    SHELLDETAILS details;
    INT idColName = -1;
    WCHAR szBuf[MAX_PATH];
    const COL_DATA *pCol = NULL;
    UINT nCols = 0;
    TraceEnter(TRACE_DETAILS, "CImageFolder::GetDetailsEx " );


    TraceGUID ("fmtid: ", pscid->fmtid);
    Trace(TEXT("pid:%x"), pscid->pid);
    // Most of our details now use FMTID_Storage propids for better shell integration
    if (IsEqualGUID(pscid->fmtid, FMTID_Storage))
    {
        LPITEMIDLIST p = const_cast<LPITEMIDLIST>(pidl);
        CSimpleString str;
        hr = S_OK;
        switch (pscid->pid)
        {
            case  PID_STG_STORAGETYPE:

            {
                if (IsDeviceIDL(p) || IsSTIDeviceIDL(p))
                {

                    switch (IMGetDeviceTypeFromIDL(p))
                    {
                        case StiDeviceTypeStreamingVideo:
                        case StiDeviceTypeDigitalCamera:
                            str.LoadString (IDS_CAMERADEVICE, GLOBAL_HINSTANCE);
                            break;

                        case StiDeviceTypeScanner:
                            str.LoadString (IDS_SCANNERDEVICE, GLOBAL_HINSTANCE);
                            break;

                        default:
                            str.LoadString (IDS_UNKNOWNDEVICE, GLOBAL_HINSTANCE);
                            break;
                    }
                }
                else if (IsAddDeviceIDL(p))
                {
                    str.LoadString (IDS_WIZARD_TYPE, GLOBAL_HINSTANCE);
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            break;

            case PID_STG_NAME:
            {
                CSimpleStringWide strName;
                IMGetNameFromIDL (p, strName);
                str = CSimpleStringConvert::NaturalString(strName);
            }

            break;

            case PID_STG_SIZE:
            {
                ULONG ulSize;
                hr = IMGetImageSizeFromIDL (p, &ulSize); 
                if (SUCCEEDED(hr))
                {
                    pv->ullVal = (ULONGLONG)ulSize;
                    pv->vt = VT_UI8;
                }
                
            }
            break;
            case PID_STG_WRITETIME:
            {
                PROPVARIANT propVar;
                hr = IMGetPropFromIDL (p, WIA_IPA_ITEM_TIME,propVar);
                if (SUCCEEDED(hr)&&propVar.caub.cElems)
                {
                    SystemTimeToVariantTime (reinterpret_cast<SYSTEMTIME*>(propVar.caub.pElems), &pv->date);
                    pv->vt = VT_DATE;
                }
                else
                {
                    hr = E_NOTIMPL;
                }                               
            }
            break;
            default:
                hr = E_INVALIDARG;
                break;
        }
        if (str.Length())
        {
            pv->vt = VT_BSTR;
            pv->bstrVal = SysAllocString (CSimpleStringConvert::WideString(str).String());

        }
        pCol = NULL;
    }
    else if (IsEqualGUID(pscid->fmtid, FMTID_WEBVWPROPS))
    {
        hr = GetWebviewProperty (const_cast<LPITEMIDLIST>(pidl), pscid->fmtid, pscid->pid, pv);
    }
    // inform the webview of our details information
    else if (IsEqualGUID(pscid->fmtid, FMTID_WebView))
    {
        if (pscid->pid == PID_DISPLAY_PROPERTIES)
        {
            hr = S_OK;
            LPCWSTR szDetail;
            DWORD dwType = IMGetDeviceTypeFromIDL(const_cast<LPITEMIDLIST>(pidl));
            if (!IsDeviceIDL(const_cast<LPITEMIDLIST>(pidl)))
            {
                szDetail = c_szWebvwDetails;
            }
            else if (dwType == StiDeviceTypeDigitalCamera || dwType == StiDeviceTypeStreamingVideo)
            {
                szDetail = c_szCameraDetails;
            }
            else
            {
                hr = E_FAIL;
            }
            if (SUCCEEDED(hr))
            {
                Trace(TEXT("Returning web view props %ls"), szDetail);
                pv->vt = VT_BSTR;
                pv->bstrVal = SysAllocString (szDetail);
                if (pv->bstrVal)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    } 
    // support grouping category in My Computer
    else if (IsEqualGUID(pscid->fmtid, FMTID_ShellDetails))
    {
        hr = GetShellDetail (const_cast<LPITEMIDLIST>(pidl), pscid->pid, pv);
    }
    else switch (m_type)
    {
        case FOLDER_IS_ROOT:

            pCol = c_device_cols;
            nCols = ARRAYSIZE(c_device_cols);
            break;

        case FOLDER_IS_VIDEO_DEVICE:
        case FOLDER_IS_CAMERA_DEVICE:
        case FOLDER_IS_CONTAINER:

            pCol = c_camera_cols;
            nCols = ARRAYSIZE(c_camera_cols);
            break;

        default:
            pCol = NULL;
            TraceAssert (FALSE);
            break;
    }
    if (pCol)
    {

        for (UINT i=0;i<nCols;i++)
        {
            if (!memcmp (pscid, pCol[i].pscid, sizeof(SHCOLUMNID)) )
            {
                idColName = pCol[i].ids;
            }
        }
        if (idColName >= 0)
        {
            hr = CFolderDetails::GetDetailsForPidl (pidl, idColName, &details);
        }
        else
        {
            hr = E_INVALIDARG;
        }
        if (SUCCEEDED(hr))
        {
            StrRetToBufW (&details.str, NULL, szBuf, ARRAYSIZE(szBuf));
            pv->vt = VT_BSTR;
            pv->bstrVal = SysAllocString (szBuf);
            if (!(pv->bstrVal))
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::GetDefaultSearchGUID [IShellFolder2]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetDefaultSearchGUID(LPGUID lpGUID)
{
    TraceEnter(TRACE_DETAILS, "CImageFolder::GetDefaultSearchGUID (not implemented)" );
    TraceLeaveResult(E_NOTIMPL);
}


/*****************************************************************************

   CImageFolder::MapColumnToSCID [IShellFolder2]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CImageFolder::MapColumnToSCID( UINT idCol,
                             SHCOLUMNID *pscid
                            )
{
    HRESULT hr = E_NOTIMPL;
    const COL_DATA *pCols;
    UINT nCols;
    TraceEnter(TRACE_DETAILS, "CImageFolder(IShellDetails3)::MapColumnToSCID" );
    switch (m_type)
    {
        case FOLDER_IS_ROOT:
            pCols = c_device_cols;
            nCols = ARRAYSIZE (c_device_cols);
            break;


        case FOLDER_IS_CONTAINER:
        case FOLDER_IS_CAMERA_DEVICE:
        case FOLDER_IS_VIDEO_DEVICE:
            pCols = c_camera_cols;
            nCols = ARRAYSIZE(c_camera_cols);
            break;

        default:
            pCols = NULL;
            nCols = 0;
            hr = E_NOTIMPL;
            break;
    }
    if (pCols && idCol < nCols)
    {
        *pscid = *(pCols[idCol].pscid);
        hr = S_OK;
    }
    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::EnumSearches [IShellFolder2]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CImageFolder::EnumSearches( IEnumExtraSearch **ppEnum)
{
    TraceEnter (TRACE_DETAILS, "CImageFolder::EnumSearches");
    TraceLeaveResult (E_NOTIMPL);
}


/*****************************************************************************

   CImageFolder::GetDefaultSearchGUID [IShellFolder2]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
GetDefaultSearchGUID( LPGUID lpGUID)
{
    TraceEnter (TRACE_DETAILS, "CImageFolder::GetDefaultSearchGUID");
    TraceLeaveResult (E_NOTIMPL);
}


/*****************************************************************************

   CFolderDetails::GetDetailsOf [IShellDetails]

   Return detail information for the given item.

 *****************************************************************************/

STDMETHODIMP
CFolderDetails::GetDetailsOf( LPCITEMIDLIST pidl,
                            UINT iColumn,
                            LPSHELLDETAILS pDetails
                           )
{
    HRESULT hr = S_OK;

    const COL_DATA *pCol = NULL;
    UINT nCols = 0;
    TraceEnter (TRACE_DETAILS, "CFolderDetails::GetDetailsOf");
    switch( m_type )
    {

        case FOLDER_IS_VIDEO_DEVICE:
        case FOLDER_IS_CAMERA_DEVICE:
        case FOLDER_IS_CONTAINER:
            pCol = c_camera_cols;
            nCols = ARRAYSIZE(c_camera_cols);
            break;


        case FOLDER_IS_ROOT:
            pCol = c_device_cols;
            nCols = ARRAYSIZE(c_device_cols);
            break;

        default:
            hr = E_FAIL;
            break;
    }
    if (pCol)
    {
        if ( iColumn >= nCols)
            ExitGracefully(hr, E_INVALIDARG, "Bad column index");

        //
        // Fill out the structure with the formatting information,
        // and a dummy string in case we fail.
        //

        pDetails->fmt           = pCol[iColumn].iFmt;
        pDetails->cxChar        = pCol[iColumn].cchCol;

        if ( !pidl )
        {
            CSimpleString strTemp (pCol[iColumn].ids, GLOBAL_HINSTANCE);
            hr = StrRetFromString(&pDetails->str, CSimpleStringConvert::WideString (strTemp));
        }
        else 
        {
            hr = GetDetailsForPidl (pidl, pCol[iColumn].ids, pDetails);
        }        
    }
exit_gracefully:

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CFolderDetails::GetDetailsForPidl

   Internal function to get details for one of our pidls

 *****************************************************************************/

HRESULT
CFolderDetails::GetDetailsForPidl ( LPCITEMIDLIST pidl,
                                  INT idColName,
                                  LPSHELLDETAILS pDetails)
{
    HRESULT hr = S_OK;
    bool bConvert = true;
    TCHAR szData[MAX_PATH];
    TraceEnter (TRACE_DETAILS, "CImageFolder::GetDetailsForPidl");
    Trace(TEXT("idColName: %d"), idColName);
    *szData = TEXT('\0');
    LPITEMIDLIST pidlIn = const_cast<LPITEMIDLIST>(pidl);
    
    switch (idColName)
    {
        case IDS_ITEMNAME:
        case IDS_DEVICENAME:
        {
            if (IsAddDeviceIDL(pidlIn))
            {
                LoadString(GLOBAL_HINSTANCE, IDS_WIZARD, szData, ARRAYSIZE(szData));                
            }
            else
            {
                CSimpleStringWide strName;
                hr = IMGetNameFromIDL(pidlIn, strName);
                if (SUCCEEDED(hr))
                {
                    wcscpy(reinterpret_cast<LPWSTR>(szData), strName);
                }
            }
            bConvert = false;
        }
        break;
        case IDS_DEVICECLASS:
        {
            INT   strId;
            DWORD dwType;
            if (!IsAddDeviceIDL(pidlIn))
            {
                dwType = IMGetDeviceTypeFromIDL (pidlIn);
                switch (dwType)
                {
                    case StiDeviceTypeStreamingVideo:
                    case StiDeviceTypeDigitalCamera:
                        strId = IDS_CAMERADEVICE;
                        break;
                    case StiDeviceTypeScanner:
                        strId = IDS_SCANNERDEVICE;
                        break;
                    default:
                        strId = IDS_UNKNOWNDEVICE;
                        break;
                }                
            }    
            else
            {
                strId = IDS_WIZARD_TYPE;
            }

            LoadString (GLOBAL_HINSTANCE, strId, szData, ARRAYSIZE(szData));
        }
        break;
        case IDS_ITEMTYPE:
        {
            INT strId = 0;
            ULONG ulType;
            ulType = IMGetItemTypeFromIDL (pidlIn);
            if (ulType & WiaItemTypeImage)
            {
                TCHAR szExt[MAX_PATH];
                SHFILEINFO sfi;

                IMGetImagePreferredFormatFromIDL (pidlIn, NULL, szExt);
                SHGetFileInfo (szExt, FILE_ATTRIBUTE_NORMAL, &sfi, sizeof(sfi), SHGFI_TYPENAME|SHGFI_USEFILEATTRIBUTES);
                lstrcpy (szData, sfi.szTypeName);
            }
            else if (ulType & WiaItemTypeAudio)
            {
                strId = IDS_AUDIOITEM;
            }
            else if (ulType & WiaItemTypeFolder)
            {
                strId = IDS_FOLDER;
            }
            else
            {
                strId = IDS_UNKNOWNTYPE;
            }
            if (strId)
            {
                LoadString (GLOBAL_HINSTANCE, strId, szData, ARRAYSIZE(szData));
            }
        }
        break;

        case IDS_ITEMDATE:
        {
            FILETIME ft;
            SYSTEMTIME st;

            if SUCCEEDED(IMGetCreateTimeFromIDL (pidlIn, &ft))
            {
                FileTimeToSystemTime (&ft, &st);
                // get the date part only
                TimeToStrings (&st,NULL, szData);                
            }
        }
        break;

        case IDS_ITEMSIZE:
        {
            ULONG ulType = IMGetItemTypeFromIDL (pidlIn);
            if (ulType & WiaItemTypeFile)
            {
                ULONG ulSize;
                IMGetImageSizeFromIDL (pidlIn, &ulSize);
                StrFormatByteSize (ulSize, szData, ARRAYSIZE(szData));
            }
        }
        break;

        default:
            Trace (TEXT("Unknown column string id in GetDetailsForPidl"));
            break;

    }
    if (bConvert)
    {
        hr = StrRetFromString(&pDetails->str, CSimpleStringConvert::WideString(CSimpleString(szData)));
    }
    else
    {
        hr = StrRetFromString(&pDetails->str, reinterpret_cast<LPCWSTR>(szData));
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CFolderDetails::ColumnClick [IShellDetails]

   User clicked a column in details view

 *****************************************************************************/

STDMETHODIMP
CFolderDetails::ColumnClick( UINT iColumn )
{
    HRESULT hr;

    TraceEnter(TRACE_DETAILS, "CImageFolder(IShellDetails)::ColumnClick" );

    hr = S_FALSE; // bounce to the shellfolderviewCB

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CFolderDetails::IUnknown stuff

   Use our common implementation for IUnknown methods.

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CFolderDetails
#include "unknown.inc"


/*****************************************************************************

   CFolderDetails::QI Wrapper

   Use our common implementation to handle QI calls

 *****************************************************************************/

STDMETHODIMP
CFolderDetails::QueryInterface (REFIID riid, LPVOID *ppv)
{
    HRESULT hr;

    TraceEnter( TRACE_QI, "CFolderDetails::QueryInterface" );
    TraceGUID("Interface requested", riid);

    INTERFACES iface[] =
    {
        &IID_IShellDetails,static_cast<IShellDetails*>( this),
    };


    hr = HandleQueryInterface(riid, ppv, iface, ARRAYSIZE(iface));

    TraceLeaveResult(hr);

}

// Put Webview property functions here

/*****************************************************************************

   CanTakePicture

   Determines if the current device is a WIA camera and supports
   the take picture event.
************************************************************