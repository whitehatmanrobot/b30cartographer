ndows 95
#define ualstrlenW  lstrlenW
#define ualstrcpyW  StrCpyW      // lstrcpyW is stubbed out on Windows 95

#endif // ALIGNMENT_MACHINE

#define ualstrcpynA lstrcpynA
#define ualstrcmpiA lstrcmpiA
#define ualstrcmpA  lstrcmpA
#define ualstrlenA  lstrlenA
#define ualstrcpyA  lstrcpyA

#ifdef UNICODE
#define ualstrcpyn ualstrcpynW
#define ualstrcmpi ualstrcmpiW
#define ualstrcmp  ualstrcmpW
#define ualstrlen  ualstrlenW
#define ualstrcpy  ualstrcpyW
#else
#define ualstrcpyn ualstrcpynA
#define ualstrcmpi ualstrcmpiA
#define ualstrcmp  ualstrcmpA
#define ualstrlen  ualstrlenA
#define ualstrcpy  ualstrcpyA
#endif

#ifdef __cplusplus
}       // extern "C"
#endif

#endif // _UASTRFNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\uxthemep.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File   : uxthemep.h
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _UXTHEMEP_H_                   
#define _UXTHEMEP_H_                   
//---------------------------------------------------------------------------
#include <uxtheme.h> 
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// The following routines are provided for use by Theme Selection UI.
//---------------------------------------------------------------------------

//---- bits returned by QueryThemeServices() ----

#define QTS_AVAILABLE  (1 << 0)  // services are available
#define QTS_RUNNING    (1 << 1)  // services are running

//---------------------------------------------------------------------------
//  QueryThemeServices()
//                      - returns flags about theme services (see above)
//---------------------------------------------------------------------------
THEMEAPI_(DWORD) QueryThemeServices();

//---------------------------------------------------------------------------
typedef HANDLE HTHEMEFILE;    // handle to a loaded theme file

//---------------------------------------------------------------------------
//  OpenThemeFile()    - Load specified theme into memory (doesn't apply it)
//
//  pszThemePath       - full path of .msstyles file to load
//
//  pszColorScheme     - (optional) name of theme color scheme to load
//
//  pszSize            - (optional) name of theme size to load
//
//  phThemeFile        - if a theme is successfully opened, this handle
//                        is set to a non-NULL value and holds a ref-count 
//                        on the theme to keep it in loaded in memory.
//
//  fGlobalTheme       - FALSE if it's a preview, TRUE if the theme is intended
//                         to be made permanent for the user
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFile(LPCWSTR pszThemePath, OPTIONAL LPCWSTR pszColorParam,
   OPTIONAL LPCWSTR pszSizeParam, OUT HTHEMEFILE *phThemeFile, BOOL fGlobalTheme);

//---------------------------------------------------------------------------
//  CloseThemeFile()   - decrements the ref-count for the theme identified
//                       by the hThemeFile handle
//
//  hThemeFile         - open handle to the loaded theme file
//---------------------------------------------------------------------------
THEMEAPI CloseThemeFile(HTHEMEFILE hThemeFile);

//---------------------------------------------------------------------------
//--- WM_THEMECHANGED msg parameters (internal use only) ----
//---   "wParam" is the "change number" ----

//---- lParam bits ----
#define WTC_THEMEACTIVE     (1 << 0)        // new theme is now active
#define WTC_CUSTOMTHEME     (1 << 1)        // this msg for custom-themed apps

//---------------------------------------------------------------------------
//---- option flags for ApplyTheme() ----

#define AT_LOAD_SYSMETRICS          (1 << 0)        // apply the theme's metrics w/theme
                                                    // or default classic metrics when
                                                    // turning themes off.

#define AT_PROCESS                  (1 << 1)        // apply to current process only
#define AT_EXCLUDE                  (1 << 2)        // all but the specified process/window
#define AT_CACHETHEME               (1 << 3)        // cache this theme file, if applied

#define AT_NOREGUPDATE              (1 << 4)        // don't update the CU registry for theme info
#define AT_SYNC_LOADMETRICS         (1 << 5)        // load system metrics on calling thread

//---- below flags currently not supported ----
#define AT_DISABLE_FRAME_THEMING    (1 << 10)
#define AT_DISABLE_DIALOG_THEMING   (1 << 11)

//---------------------------------------------------------------------------
//  ApplyTheme()        - Apply (or remove) a loaded theme file globally
//                        or to specified apps/windows.
//
//                        Note that when a theme is applied globally
//                        (hwndTarget is NULL), the theme services manager 
//                        will hold a refcount on the theme file.  This
//                        means that the caller can close his HTHEMEFILE 
//                        handle after the ApplyTheme() call.
//
//                        When the global theme is removed, the theme
//                        services manager will drop is refcount.      
//
//      hThemeFile      - (optional)handle to the loaded theme file. 
//                        if NULL then any theme on target app/windows 
//                        will be removed.
//
//      dwApplyFlags    - options for applying theme (see above)
//
//      hwndTarget      - (optional) only theme this window
//---------------------------------------------------------------------------
THEMEAPI ApplyTheme(OPTIONAL HTHEMEFILE hThemeFile, DWORD dwApplyFlags,
    OPTIONAL HWND hwndTarget);

//---------------------------------------------------------------------------
//  RegisterDefaultTheme()
//                      - registers the specified theme as the default
//                        for all users on the system.
//
//  pszThemeFileName    - the name of the theme file (NULL = no theme)
//
//  fOverride           - if TRUE, will override current default theme
//---------------------------------------------------------------------------
THEMEAPI RegisterDefaultTheme(LPCWSTR pszFileName, BOOL fOverride);

//---------------------------------------------------------------------------
//  THEMECALLBACK is a enum describing the type of callback being done
//---------------------------------------------------------------------------
typedef enum THEMECALLBACK
{
    TCB_THEMENAME,      // theme name enumeration
    TCB_COLORSCHEME,    // color scheme enumeration
    TCB_SIZENAME,       // size name enumeration
    TCB_SUBSTTABLE,     // substitution table enumeration
    TCB_CDFILENAME,     // classdata file name enumeration
    TCB_CDFILECOMBO,    // classdata file color/size combinations

    TCB_FILENAME,         // parsed a filename
    TCB_DOCPROPERTY,      // parsed a standard doc property
    TCB_NEEDSUBST,        // callback to get a substituted symbol
    TCB_MINCOLORDEPTH,    // parsed the min color depth

    //---- localizable property callbacks ----
    TCB_FONT,             // parsed a font string
    TCB_MIRRORIMAGE,      // parsed the MirrorImage property
    TCB_LOCALIZABLE_RECT, // parsed a RECT property that needs to be localizable
};

//---------------------------------------------------------------------------
typedef struct 
{
    WCHAR szName[MAX_PATH+1];
    WCHAR szDisplayName[MAX_PATH+1];
    WCHAR szToolTip[MAX_PATH+1];
} THEMENAMEINFO;

//---------------------------------------------------------------------------
//  THEMEENUMPROC()     - callback used by the theme enum/parsing functions.
//                        the return value is used to continue or abort
//                        the enumeration.
//
//  tcbType             - callback type being made 
//  pszName             - simple name of the item being enumerated
//  pszName2            - varies by callback type
//  pszName3            - varies by callback type
//  iIndex              - index number associated with some items
//  lParam              - callback param supplied by caller
//---------------------------------------------------------------------------
typedef BOOL (CALLBACK* THEMEENUMPROC)(enum THEMECALLBACK tcbType,
    LPCWSTR pszName, OPTIONAL LPCWSTR pszName2, 
    OPTIONAL LPCWSTR pszName3, OPTIONAL int iIndex, LPARAM lParam);

//---------------------------------------------------------------------------
//  EnumThemes()        - calls the callback function "lpEnumFunc" with each 
//                        theme.  During the callback, the filename,
//                        Display name, and tooltip string for each theme
//                        are returned.
//
//  pszThemeRoot        - the theme root directory; each theme DLL found in 
//                        a separate subdir immediately under the theme root 
//                        dir is enumerated.  The root name of the DLL must 
//                        match its containing subdir name
//
//  lpEnumFunc          - ptr to the caller's callback function which will
//                        be called for each theme enumerated
//
//  lParam              - caller's callback parameter (will be passed to
//                        lpEnumFunc())
//---------------------------------------------------------------------------
THEMEAPI EnumThemes(LPCWSTR pszThemeRoot, THEMEENUMPROC lpEnumFunc, 
    LPARAM lParam);

//---------------------------------------------------------------------------
//  EnumThemeSizes()    - support direct enumeration of all available theme
//                        sizes.  
//
//  pszThemeName        - is the name of the theme file.
//  pszColorScheme      - (optional) only sizes for this color are enum-ed
//  dwSizeIndex         - 0-relative index of the size being queryed
//  ptn                 - ptr to struct to receive name strings
//---------------------------------------------------------------------------
THEMEAPI EnumThemeSizes(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszColorScheme, DWORD dwSizeIndex, 
    OUT THEMENAMEINFO *ptn);

//---------------------------------------------------------------------------
//  EnumThemeColors()   - support direct enumeration of all available theme
//                        color schemes.  
//
//  pszThemeName        - name of the theme file.
//  pszSizeName         - (optional) only colors for this size are enum-ed
//  dwColorIndex        - 0-relative index of the color being queryed
//  ptn                 - ptr to struct to receive name strings
//---------------------------------------------------------------------------
THEMEAPI EnumThemeColors(LPCWSTR pszThemeName, 
    OPTIONAL LPCWSTR pszSizeName, DWORD dwColorIndex, 
    OUT THEMENAMEINFO *ptn);

//---------------------------------------------------------------------------
//  GetThemeDefaults() - returns the default Color name and default Size
//                       name for the specified theme file
//
//  pszThemeName        - name of the theme file
//
//  pszDefaultColor     - buffer to receive the default color name
//                        (the canonical name, not the display version)
//  cchMaxColorChars    - max chars that pszDefaultColor can contain
//
//  pszDefaultSize      - buffer to receive the default size name
//                        (the canonical name, not the display version)
//  cchMaxSizeChars     - max chars that pszDefaultSize can contain
//---------------------------------------------------------------------------
THEMEAPI GetThemeDefaults(LPCWSTR pszThemeName,
    OUT OPTIONAL LPWSTR pszDefaultColor, int cchMaxColorChars, 
    OUT OPTIONAL LPWSTR pszDefaultSize, int cchMaxSizeChars);

//---------------------------------------------------------------------------
#define PTF_CONTAINER_PARSE         0x0001  // parse as a "themes.ini" file
#define PTF_CLASSDATA_PARSE         0x0002  // parse as a "bigred.ini" classdata file

#define PTF_CALLBACK_COLORSECTION   0x0004  // callback on all [colorscheme.xxx] sections
#define PTF_CALLBACK_SIZESECTION    0x0008  // callback on all [size.xxx] sections
#define PTF_CALLBACK_FILESECTION    0x0010  // callback on all [file.xxx] sections 

#define PTF_CALLBACK_FILENAMES      0x0020  // callback on all "filename=" properties
#define PTF_CALLBACK_LOCALIZATIONS  0x0040  // callback on all localizable properties
#define PTF_CALLBACK_DOCPROPERTIES  0x0080  // callback on all standard properties in [doc] section
#define PTF_QUERY_DOCPROPERTY       0x0100  // query for value of specified property (internal)
#define PTF_CALLBACK_SUBSTTABLE     0x0400  // callback on all [subst.xxx] sections 
#define PTF_CALLBACK_SUBSTSYMBOLS   0x0800  // callback on a substituted symbol (##)
#define PTF_CALLBACK_MINCOLORDEPTH  0x1000  // callback on "MinColorDepth="

//---------------------------------------------------------------------------
//  ParseThemeIniFile() - Parse the "themes.inc" file specified by 
//                        "pszFileName". 

//  pzFileName          - name of the theme.inc file to parse
//  dwParseFlags        - flags that control parsing & callback options
//  pfnCallBack         - ptr to caller-supplied callback function
//  lparam              - caller's callback param
//---------------------------------------------------------------------------
THEMEAPI ParseThemeIniFile(LPCWSTR pszFileName, DWORD dwParseFlags,
    OPTIONAL THEMEENUMPROC pFnCallBack, OPTIONAL LPARAM lparam);

//---------------------------------------------------------------------------
#define THEME_PARSING_ERROR(hr)  (SCODE_CODE(hr) == ERROR_UNKNOWN_PROPERTY)

typedef struct _PARSE_ERROR_INFO
{
    DWORD dwSize;                   // of this structure

    //---- last parse error info ----
    DWORD dwParseErrCode;           // error code from last error
    WCHAR szMsg[2*MAX_PATH];    // value of first param for msg
    WCHAR szFileName[MAX_PATH];     // associated source filename
    WCHAR szSourceLine[MAX_PATH];   // source line
    int iLineNum;                   // source line number
} 
PARSE_ERROR_INFO, *PPARSE_ERROR_INFO;
//---------------------------------------------------------------------------
//  GetThemeParseErrorInfo()
//                      - fill in the PARSE_ERROR_CONTEXT structure
//                        with needed information about the last theme API 
//                        parse error.
//
//  pInfo               - ptr to the PARSE_ERROR_INFO to be filled
//---------------------------------------------------------------------------
THEMEAPI GetThemeParseErrorInfo(OUT PARSE_ERROR_INFO *pInfo);

//---------------------------------------------------------------------------
// resource base numbers for localizable string tables in a .msstyles file
//---------------------------------------------------------------------------
#define RES_BASENUM_COLORDISPLAYS   1000
#define RES_BASENUM_COLORTOOLTIPS   2000

#define RES_BASENUM_SIZEDISPLAYS    3000
#define RES_BASENUM_SIZETOOLTIPS    4000

#define RES_BASENUM_DOCPROPERTIES   5000        // in order shown in TmSchema.h

#define RES_BASENUM_PROPVALUEPAIRS  6000        // property names & localizable values

//---------------------------------------------------------------------------
//  DrawNCPreview()     - Previews the theme for the NC area of a window
//
//  hdc                 - HDC for preview to be draw into
//  prc                 - RECT for preview
//
//---------------------------------------------------------------------------
#define NCPREV_INACTIVEWINDOW   0x00000001
#define NCPREV_ACTIVEWINDOW     0x00000002
#define NCPREV_MESSAGEBOX       0x00000004
#define NCPREV_RTL              0x00000008

THEMEAPI DrawNCPreview(HDC hdc, DWORD dwFlags, LPRECT prc, LPCWSTR pszVSPath, 
    LPCWSTR pszVSColor, LPCWSTR pszVSSize, NONCLIENTMETRICS* pncm, 
    COLORREF* prgb);


//---------------------------------------------------------------------------
//  DumpLoadedThemeToTextFile()     
//                      - (for internal testing) dumps the contents of the
//                        loaded theme file to the specified text file
//
//      hThemeFile      - the handle of the loaded theme file
//
//      pszTextFile     - path of the text file to create & write to
//
//      fPacked         - TRUE to dump packed objects; FALSE for normal
//                        properties
//
//      fFullInfo       - includes sizes, offsets, paths, etc.  Use FALSE
//                        for info that will be DIFF-ed across builds/machines
//---------------------------------------------------------------------------
THEMEAPI DumpLoadedThemeToTextFile(HTHEMEFILE hThemeFile, 
    LPCWSTR pszTextFile, BOOL fPacked, BOOL fFullInfo);

#ifdef __cplusplus

class CDrawBase;          // forward
class CTextDraw;          // forward

//---------------------------------------------------------------------------
//  CreateThemeDataFromObjects() 
//                      - creates a theme handle from a CBorderFill, 
//                        CImageFile, and/or CTextDraw object.  At lease one
//                        non-NULL ptr must be passed (either or both).
//
//      pDrawObj       - (optional) ptr to an object derived from CDrawBase
//                       NOTE: if pDrawObj is a CImageFile ptr and its
//                       "_pImageData" contains any alpha channel bitmaps,
//                       the bits in those bitmaps will be "pre-multiplied"
//                       for alpha blending.
//
//      pTextObj       - (optional) ptr to a CTextDraw object
//
//      dwOtdFlags     - theme override flags (see OpenThemeDataEx())
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) CreateThemeDataFromObjects(OPTIONAL CDrawBase *pDrawObj, 
    OPTIONAL CTextDraw *pTextObj, DWORD dwOtdFlags);
#endif

//---------------------------------------------------------------------------
//  OpenThemeDataFromFile() 
//                      - Open the theme data for the specified loaded theme
//                        file and semi-colon separated list of class names.  
//                        OpenThemeDataFromFile() will try each class name, 
//                        one at a time, and use the first matching theme info
//                        found.  If none match, "NULL" is returned.  
//
//                        Note: normal controls should NOT use this API;
//                        they should use "OpenThemeData()" (which uses the
//                        current global or app theme).
//
//      hLoadedThemeFile - handle to the loaded theme file.
//
//      hwnd             - (optional) hwnd to base the HTHEME on
//
//      pszClassList     - (optional) class name (or list of names) to match 
//                         to theme data section; if NULL, will get match
//                         to [globals] section.
//
//      fClient          - TRUE if theming a client window with returned 
//                         HTHEME.
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataFromFile(HTHEMEFILE hLoadedThemeFile, 
    OPTIONAL HWND hwnd, OPTIONAL LPCWSTR pszClassList, BOOL fClient);

//---------------------------------------------------------------------------
//  OpenThemeFileFromData() 
//                      - Open the theme file corresponding to the HTHEME.
//
//      hTheme          - handle to the theme data from OpenThemeData().
//
//      phThemeFile     - ptr to return HTHEMEFILE to.
//---------------------------------------------------------------------------
THEMEAPI OpenThemeFileFromData(HTHEME hTheme, HTHEMEFILE *phThemeFile);

//---------------------------------------------------------------------------
//  GetThemeSysSize96() - Get the value of the specified System size metric. 
//                        (original value authored for 96 dpi)
//
//  hTheme              - the theme data handle (required).  Will return
//                        size from [SysMetrics] section of theme.
//
//  iSizeId             - only the following sizes are supported:
//
//                          SM_CXBORDER   (border width)
//                          SM_CXVSCROLL  (scrollbar width)
//                          SM_CYHSCROLL  (scrollbar height)
//                          SM_CXSIZE     (caption width)
//                          SM_CYSIZE     (caption height)
//                          SM_CXSMSIZE   (small caption width)
//                          SM_CYSMSIZE   (small caption height)
//                          SM_CXMENUSIZE (menubar width)
//                          SM_CYMENUSIZE (menubar height)
//---------------------------------------------------------------------------
THEMEAPI_(int) GetThemeSysSize96(HTHEME hTheme, int iSizeId);

//---------------------------------------------------------------------------
//  GetThemeSysFont96() - Get the LOGFONT for the specified System font. 
//                        (original value authored for 96 dpi)
//
//  hTheme              - the theme data handle (required).  Will return
//                        size from [SysMetrics] section of theme.
//
//  iFontId             - the TMT_XXX font number (first font
//                        is TMT_CAPTIONFONT)
//
//  plf                 - ptr to LOGFONT to receive the font value.
//---------------------------------------------------------------------------
THEMEAPI GetThemeSysFont96(HTHEME hTheme, int iFontId, OUT LOGFONT *plf);

//---------------------------------------------------------------------------
//  RefreshThemeForTS() 
//                      - turn themes on/off for current Terminal Server user
//---------------------------------------------------------------------------
THEMEAPI RefreshThemeForTS();

//---------------------------------------------------------------------------
//---- flag bits for OpenThemeDataEx() ----

#define OTD_FORCE_RECT_SIZING   0x0001      // make all parts size to rect
#define OTD_NONCLIENT           0x0002      // set if hTheme to be used for nonclient area
//---------------------------------------------------------------------------
//  OpenThemeDataEx     - Open the theme data for the specified HWND and 
//                        semi-colon separated list of class names. 
// 
//                        OpenThemeData() will try each class name, one at 
//                        a time, and use the first matching theme info
//                        found.  If a match is found, a theme handle
//                        to the data is returned.  If no match is found,
//                        a "NULL" handle is returned. 
//
//                        When the window is destroyed or a WM_THEMECHANGED
//                        msg is received, "CloseThemeData()" should be 
//                        called to close the theme handle.
//
//  hwnd                - window handle of the control/window to be themed
//
//  pszClassList        - class name (or list of names) to match to theme data
//                        section.  if the list contains more than one name, 
//                        the names are tested one at a time for a match.  
//                        If a match is found, OpenThemeData() returns a 
//                        theme handle associated with the matching class. 
//                        This param is a list (instead of just a single 
//                        class name) to provide the class an opportunity 
//                        to get the "best" match between the class and 
//                        the current theme.  For example, a button might
//                        pass L"OkButton, Button" if its ID=ID_OK.  If 
//                        the current theme has an entry for OkButton, 
//                        that will be used.  Otherwise, we fall back on 
//                        the normal Button entry.
//
//  dwFlags              - allows certain overrides of std features
//                         (see OTD_XXX defines above)
//---------------------------------------------------------------------------
THEMEAPI_(HTHEME) OpenThemeDataEx(HWND hwnd, LPCWSTR pszClassList, DWORD dwFlags);

THEMEAPI CheckThemeSignature (LPCWSTR pszName);

//---------------------------------------------------------------------------
//  ClassicGetSystemMetrics( int iMetric );
//  
//  ClassicSystemParametersInfoA( IN UINT uiAction, IN UINT uiParam, 
//                                IN OUT PVOID pvParam, IN UINT fWinIni);
//  ClassicSystemParametersInfoW( IN UINT uiAction, IN UINT uiParam, 
//                                IN OUT PVOID pvParam, IN UINT fWinIni);
//  ClassicAdjustWindowRectEx( IN LPRECT prcWnd, IN DWORD dwStyle, IN BOOL fMenu, IN DWORD dwExStyle );
//
//  These exports correspond to their Win32 API counterparts and ensure that
//  the classic visual style metrics are retrieved.   Theme hooks are shunted.
//---------------------------------------------------------------------------
THEMEAPI_(int)  ClassicGetSystemMetrics( int iMetric );
THEMEAPI_(BOOL) ClassicSystemParametersInfoA( UINT uiAction, UINT uiParam, IN OUT PVOID pvParam, UINT fWinIni);
THEMEAPI_(BOOL) ClassicSystemParametersInfoW( UINT uiAction, UINT uiParam, IN OUT PVOID pvParam, UINT fWinIni);
THEMEAPI_(BOOL) ClassicAdjustWindowRectEx( LPRECT prcWnd, DWORD dwStyle, BOOL fMenu, DWORD dwExStyle );

#ifdef UNICODE
#define ClassicSystemParametersInfo ClassicSystemParametersInfoW
#else  UNICODE
#define ClassicSystemParametersInfo ClassicSystemParametersInfoA
#endif UNICODE 

//---------------------------------------------------------------------------
#define PACKTHEM_VERSION 3      // latest change: localizable properties

//---------------------------------------------------------------------------
#endif // _UXTHEMEP_H_                               
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\imapi\burnsys.h ===
/****************************************************************************
**
** Copyright 1999 Adaptec, Inc.,  All Rights Reserved.
**
** This software contains the valuable trade secrets of Adaptec.  The
** software is protected under copyright laws as an unpublished work of
** Adaptec.  Notice is for informational purposes only and does not imply
** publication.  The user of this software may make copies of the software
** for use with parts manufactured by Adaptec or under license from Adaptec
** and for no other use.
**
****************************************************************************/

/****************************************************************************
**
**  Module Name:    burnsys.h
**
**  Description:    Definitions of all the IOCTLs and their structures that
**                  can be used with BURNENG.SYS.  Note that the structures
**                  are used for ring-3 to SYS submission only.
**
**  Programmers:    Daniel Evers (dle)
**                  Tom Halloran (tgh)
**                  Don Lilly (drl)
**                  Daniel Polfer (dap)
**
**  History:        
**
**  Notes:          This file created using 4 spaces per tab.
**
****************************************************************************/

#ifndef __BURNSYS_H_
#define __BURNSYS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include "ImageFile.h"
#include "ImapiPub.h"
#include "BurnV.h"


/*
** The version numbers allow us to lock the API to a specific version from up top.
*/

// v 20.20 had everything in this file pack(1)'d, which caused all sorts of
// alignment faults.  what was Roxio thinking?

#define IMAPIAPI_VERSION_HI                     48
#define IMAPIAPI_VERSION_LO                     48

/*
** Make sure we have the stuff we need to declare IOCTLs.  The device code
** is below, and then each of the IOCTLs is defined alone with its constants
** and structures below.
*/

#define FILE_DEVICE_BURNENG     0x90DC


/*
** ----------------------------------------------------------------------------
** IOCTL_BURNENG_INIT
** ----------------------------------------------------------------------------
*/

#define IOCTL_BURNENG_INIT ((ULONG)CTL_CODE (FILE_DEVICE_BURNENG, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS))

typedef struct  tag_BURNENG_INIT
{
    ULONG                   dwVersion;      // (OUT) Version number.  Use this to ensure compatible structures/IOCTLs.
    BURNENG_ERROR_STATUS    errorStatus;    // (OUT) Error status from the burneng driver
} BURNENG_INIT, *PBURNENG_INIT;


/*
** ----------------------------------------------------------------------------
** IOCTL_BURNENG_TERM
** ----------------------------------------------------------------------------
*/

#define IOCTL_BURNENG_TERM ((ULONG)CTL_CODE (FILE_DEVICE_BURNENG, 0x810, METHOD_BUFFERED, FILE_ANY_ACCESS))

typedef struct  tag_BURNENG_TERM
{
    BURNENG_ERROR_STATUS    errorStatus;    // (OUT) Error status from the burneng driver
} BURNENG_TERM, *PBURNENG_TERM;



/*
** ----------------------------------------------------------------------------
** IOCTL_BURNENG_BURN
** ----------------------------------------------------------------------------
*/

#define IOCTL_BURNENG_BURN ((ULONG)CTL_CODE (FILE_DEVICE_BURNENG, 0x820, METHOD_BUFFERED, FILE_ANY_ACCESS))

typedef struct  tag_BURNENG_BURN
{
    DWORD                 dwSimulate;                 // IN  - Whether the burn is simulated (non-zero) or real (0)
    BURNENG_ERROR_STATUS  errorStatus;                // OUT - Error status copied from ImapiW2k.sys
    PIMAGE_CONTENT_LIST   pContentList;               // IN  - The description of the content to be burned.
    DWORD                 dwRecorderBucket;           // IN  - Target's recorder class
    DWORD                 dwDeviceFlags;              // IN  - Target's device-specific flags
    DWORD                 dwCurrentSessionNumber;     // IN  - Session number.
    DWORD                 dwAudioGapSize;             // IN  - dead air between tracks.
    DWORD                 dwEnableBufferUnderrunFree; // IN  - enable buffer underrun free recording
} BURNENG_BURN, *PBURNENG_BURN;



/*
** ----------------------------------------------------------------------------
** IOCTL_BURNENG_PROGRESS
** ----------------------------------------------------------------------------
*/

#define IOCTL_BURNENG_PROGRESS ((ULONG)CTL_CODE (FILE_DEVICE_BURNENG, 0x830, METHOD_BUFFERED, FILE_ANY_ACCESS))

typedef struct  tag_BURNENG_PROGRESS
{
    DWORD                       dwCancelBurn;   // (IN)  if not zero, cancel the burn.
    DWORD                       dwSectionsDone; // (OUT) Number of sections completed.
    DWORD                       dwTotalSections;// (OUT) Total number of sections to burn.
    DWORD                       dwBlocksDone;   // (OUT) Number of blocks completed.
    DWORD                       dwTotalBlocks;  // (OUT) Total number of blocks to burn.
    BURNENGV_PROGRESS_STATUS    eStatus;        // (OUT) Status of the burn operation.
} BURNENG_PROGRESS, *PBURNENG_PROGRESS;



/*
** ----------------------------------------------------------------------------
*/

#ifdef __cplusplus
}
#endif

#endif //__BURNSYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\vrsscan.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for vrsscan.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __vrsscan_h__
#define __vrsscan_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVirusScanner_FWD_DEFINED__
#define __IVirusScanner_FWD_DEFINED__
typedef interface IVirusScanner IVirusScanner;
#endif 	/* __IVirusScanner_FWD_DEFINED__ */


#ifndef __IRegisterVirusScanEngine_FWD_DEFINED__
#define __IRegisterVirusScanEngine_FWD_DEFINED__
typedef interface IRegisterVirusScanEngine IRegisterVirusScanEngine;
#endif 	/* __IRegisterVirusScanEngine_FWD_DEFINED__ */


#ifndef __IVirusScanEngine_FWD_DEFINED__
#define __IVirusScanEngine_FWD_DEFINED__
typedef interface IVirusScanEngine IVirusScanEngine;
#endif 	/* __IVirusScanEngine_FWD_DEFINED__ */


#ifndef __VirusScan_FWD_DEFINED__
#define __VirusScan_FWD_DEFINED__

#ifdef __cplusplus
typedef class VirusScan VirusScan;
#else
typedef struct VirusScan VirusScan;
#endif /* __cplusplus */

#endif 	/* __VirusScan_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_vrsscan_0000 */
/* [local] */ 






extern RPC_IF_HANDLE __MIDL_itf_vrsscan_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_vrsscan_0000_v0_0_s_ifspec;


#ifndef __VIRUSSCAN_LIBRARY_DEFINED__
#define __VIRUSSCAN_LIBRARY_DEFINED__

/* library VIRUSSCAN */
/* [version][lcid][helpstring][uuid] */ 

//   Virus Scan Error codes
#define  VSCAN_E_NOPROVIDERS      _HRESULT_TYPEDEF_(0x800D1001)
#define  VSCAN_E_CHECKPARTIAL     _HRESULT_TYPEDEF_(0x800D1002)
#define  VSCAN_E_CHECKFAIL        _HRESULT_TYPEDEF_(0x800D1003)
#define  VSCAN_E_DELETEFAIL       _HRESULT_TYPEDEF_(0x800D1004)

// Virus Scanner Capabilities flags
#define  VSC_LIKESISTREAM      0x00000001
#define  VSC_LIKESFILE         0x00000002
#define  VSC_LIKESHGLOBAL      0x00000004
#define  VSC_HASMOREINFO       0x00000008

//   Virus Scan Engine Error codes
#define  VSE_E_UNSUPPORTEDINPUTTYPE      _HRESULT_TYPEDEF_(0x800D2001)
#define  VSE_E_CHECKFAIL                 _HRESULT_TYPEDEF_(0x800D2002)

#define	MAX_DESCRIPTION	( 128 )

#define	MAX_URL_LENGTH	( 2048 )

typedef struct _tagVIRUSINFO
    {
    DWORD cbSize;
    WCHAR wszVendorDescription[ 128 ];
    HICON hVendorIcon;
    WCHAR wszVendorContactInfo[ 2048 ];
    WCHAR wszVirusName[ 128 ];
    WCHAR wszVirusDescription[ 128 ];
    } 	VIRUSINFO;

typedef /* [unique] */ VIRUSINFO *LPVIRUSINFO;


#define    SFV_DONTDOUI             0x00000002                                
#define    SFV_DELETE               0x00000004                                
#define    SFV_WANTVENDORICON       0x00000008                                
#define    SFV_ENGINE_DOUI          0x00010000                                

#define REGISTERSCANNER_REREGISTER     1

EXTERN_C const IID LIBID_VIRUSSCAN;

#ifndef __IVirusScanner_INTERFACE_DEFINED__
#define __IVirusScanner_INTERFACE_DEFINED__

/* interface IVirusScanner */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IVirusScanner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4589BEE0-B4B1-11CF-AAFA-00AA00B6015C")
    IVirusScanner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScanForVirus( 
            /* [in] */ HWND hWnd,
            /* [in] */ STGMEDIUM *pstgMedium,
            /* [in] */ LPWSTR pwszItemDescription,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPVIRUSINFO pVirusInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVirusScannerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVirusScanner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVirusScanner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVirusScanner * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScanForVirus )( 
            IVirusScanner * This,
            /* [in] */ HWND hWnd,
            /* [in] */ STGMEDIUM *pstgMedium,
            /* [in] */ LPWSTR pwszItemDescription,
            /* [in] */ DWORD dwFlags,
            /* [out][in] */ LPVIRUSINFO pVirusInfo);
        
        END_INTERFACE
    } IVirusScannerVtbl;

    interface IVirusScanner
    {
        CONST_VTBL struct IVirusScannerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVirusScanner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVirusScanner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVirusScanner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVirusScanner_ScanForVirus(This,hWnd,pstgMedium,pwszItemDescription,dwFlags,pVirusInfo)	\
    (This)->lpVtbl -> ScanForVirus(This,hWnd,pstgMedium,pwszItemDescription,dwFlags,pVirusInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVirusScanner_ScanForVirus_Proxy( 
    IVirusScanner * This,
    /* [in] */ HWND hWnd,
    /* [in] */ STGMEDIUM *pstgMedium,
    /* [in] */ LPWSTR pwszItemDescription,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ LPVIRUSINFO pVirusInfo);


void __RPC_STUB IVirusScanner_ScanForVirus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVirusScanner_INTERFACE_DEFINED__ */


#ifndef __IRegisterVirusScanEngine_INTERFACE_DEFINED__
#define __IRegisterVirusScanEngine_INTERFACE_DEFINED__

/* interface IRegisterVirusScanEngine */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IRegisterVirusScanEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0825E060-B961-11CF-AAFA-00AA00B6015C")
    IRegisterVirusScanEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterScanEngine( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPWSTR pwszDescription,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out][in] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterScanEngine( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPWSTR pwszDescription,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegisterVirusScanEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegisterVirusScanEngine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegisterVirusScanEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegisterVirusScanEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterScanEngine )( 
            IRegisterVirusScanEngine * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPWSTR pwszDescription,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out][in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnRegisterScanEngine )( 
            IRegisterVirusScanEngine * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LPWSTR pwszDescription,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IRegisterVirusScanEngineVtbl;

    interface IRegisterVirusScanEngine
    {
        CONST_VTBL struct IRegisterVirusScanEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegisterVirusScanEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegisterVirusScanEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegisterVirusScanEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegisterVirusScanEngine_RegisterScanEngine(This,rclsid,pwszDescription,dwFlags,dwReserved,pdwCookie)	\
    (This)->lpVtbl -> RegisterScanEngine(This,rclsid,pwszDescription,dwFlags,dwReserved,pdwCookie)

#define IRegisterVirusScanEngine_UnRegisterScanEngine(This,rclsid,pwszDescription,dwFlags,dwReserved,dwCookie)	\
    (This)->lpVtbl -> UnRegisterScanEngine(This,rclsid,pwszDescription,dwFlags,dwReserved,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegisterVirusScanEngine_RegisterScanEngine_Proxy( 
    IRegisterVirusScanEngine * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LPWSTR pwszDescription,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwReserved,
    /* [out][in] */ DWORD *pdwCookie);


void __RPC_STUB IRegisterVirusScanEngine_RegisterScanEngine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegisterVirusScanEngine_UnRegisterScanEngine_Proxy( 
    IRegisterVirusScanEngine * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LPWSTR pwszDescription,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwReserved,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IRegisterVirusScanEngine_UnRegisterScanEngine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegisterVirusScanEngine_INTERFACE_DEFINED__ */


#ifndef __IVirusScanEngine_INTERFACE_DEFINED__
#define __IVirusScanEngine_INTERFACE_DEFINED__

/* interface IVirusScanEngine */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IVirusScanEngine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("083DB180-B4A8-11CF-AAFA-00AA00B6015C")
    IVirusScanEngine : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScanForVirus( 
            /* [in] */ HWND hWnd,
            /* [in] */ STGMEDIUM *pstgMedium,
            /* [in] */ LPWSTR pwszItemDescription,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out][in] */ LPVIRUSINFO pVirusInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayCustomInfo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVirusScanEngineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVirusScanEngine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVirusScanEngine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVirusScanEngine * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScanForVirus )( 
            IVirusScanEngine * This,
            /* [in] */ HWND hWnd,
            /* [in] */ STGMEDIUM *pstgMedium,
            /* [in] */ LPWSTR pwszItemDescription,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwReserved,
            /* [out][in] */ LPVIRUSINFO pVirusInfo);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayCustomInfo )( 
            IVirusScanEngine * This);
        
        END_INTERFACE
    } IVirusScanEngineVtbl;

    interface IVirusScanEngine
    {
        CONST_VTBL struct IVirusScanEngineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVirusScanEngine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVirusScanEngine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVirusScanEngine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVirusScanEngine_ScanForVirus(This,hWnd,pstgMedium,pwszItemDescription,dwFlags,dwReserved,pVirusInfo)	\
    (This)->lpVtbl -> ScanForVirus(This,hWnd,pstgMedium,pwszItemDescription,dwFlags,dwReserved,pVirusInfo)

#define IVirusScanEngine_DisplayCustomInfo(This)	\
    (This)->lpVtbl -> DisplayCustomInfo(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVirusScanEngine_ScanForVirus_Proxy( 
    IVirusScanEngine * This,
    /* [in] */ HWND hWnd,
    /* [in] */ STGMEDIUM *pstgMedium,
    /* [in] */ LPWSTR pwszItemDescription,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwReserved,
    /* [out][in] */ LPVIRUSINFO pVirusInfo);


void __RPC_STUB IVirusScanEngine_ScanForVirus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVirusScanEngine_DisplayCustomInfo_Proxy( 
    IVirusScanEngine * This);


void __RPC_STUB IVirusScanEngine_DisplayCustomInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVirusScanEngine_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_VirusScan;

#ifdef __cplusplus

class DECLSPEC_UUID("E88E5DE0-BD3E-11CF-AAFA-00AA00B6015C")
VirusScan;
#endif
#endif /* __VIRUSSCAN_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\w95wraps.h ===
/*****************************************************************************\
*                                                                             *
* w95wraps.h - Unicode wrappers for ANSI functions on Win95                   *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

//
//  This file is for internal use only.  Do not put it in the SDK.
//

#ifndef _INC_W95WRAPS
#define _INC_W95WRAPS

// no wrappers are needed for non x86, since win9x only runs on x86!
#ifdef _X86_

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_W95WRAPS_UNITHUNK  Unicode wrapper functions
//    NO_W95WRAPS_TPS       Thread Pool Services
//    NO_W95WRAPS_MLUI      MLUI wrapper functions
//
//  You are expected to have done a #include <shlwapi.h> before including
//  this file.
//
// BUGBUG: you can't include shlwapi.h before this, as ATL templates
// require things like TranlsateAccelerator which, due to munging, get
// turned into TranslateAcceleratorWrapW at compile time.  So w95wraps.h
// pretty much needs to be included FIRST so all the interface definitions
// get munged too.
//#ifndef _INC_SHLWAPI
//#error "You must include shlwapi.h *before* w95wraps.h
//#endif

//=============== Unicode Wrapper Routines ===================================

#ifndef NO_W95WRAPS_UNITHUNK

//
//  If you #include this file, then calls to many UNICODE functions
//  are re-routed through wrapper functions in SHLWAPI which will
//  either call the UNICODE version (on NT) or thunk the parameters
//  to ANSI and call the ANSI version (on 9x).
//
//  Note that these wrapper functions must be used with care, because
//
//  *   They do not account for subtle differences between UNICODE and
//      ANSI versions of the same API.  Examples:
//
//      -   RegisterClassW register a UNICODE window class, whereas
//          RegisterClassA registers an ANSI window class.  Consequently,
//          if you use RegisterClassWrapW, your WNDPROC will receive
//          *ANSI* WM_SETTEXT messages on Windows 9x.
//
//      -   SetWindowLongW(GWL_WNDPROC) and CallWindowProcW behave
//          very differently from their ANSI counterparts.
//
//      -   DialogBoxW will send your dialog procedure UNICODE window
//          messages, whereas DialogBoxA will send ANSI window messages.
//
//      -   Anything that manipulates window messages or MSG structures
//          will be subtly affected by character set discrepancies.
//
//  *   Not all features of the underlying API are always supported,
//      or are supported with restrictions.  Examples:
//
//      -   DialogBoxWrapW does not support named dialog resources.
//
//      -   AppendMenuWrapW does not support bitmap or owner-draw
//          menu items.
//
//      -   FormatMessageWrapW does not support insertions.
//
//      -   If you use RegQueryValueExWrapW with a NULL output buffer to
//          query the size of a buffer, you must also pass *lpcbData = 0.
//
//      -   SendMessageWrapW requires that the window message not conflict
//          with messages used by any of the Windows common controls.
//

#define IsCharAlphaW                IsCharAlphaWrapW
#define IsCharUpperW                IsCharUpperWrapW
#define IsCharLowerW                IsCharLowerWrapW
#define IsCharAlphaNumericW         IsCharAlphaNumericWrapW

#define AppendMenuW                 AppendMenuWrapW
#define CallMsgFilterW              CallMsgFilterWrapW
#define CallWindowProcW             CallWindowProcWrapW
#define CharLowerW                  CharLowerWrapW
#define CharLowerBuffW              CharLowerBuffWrapW
#define CharNextW                   CharNextWrapW
#define CharPrevW                   CharPrevWrapW
#define CharToOemW                  CharToOemWrapW
#define CharUpperW                  CharUpperWrapW
#define CharUpperBuffW              CharUpperBuffWrapW
#define CompareStringW              CompareStringWrapW
#define CopyAcceleratorTableW       CopyAcceleratorTableWrapW
#define CreateAcceleratorTableW     CreateAcceleratorTableWrapW
#define CreateDCW                   CreateDCWrapW
#define CreateDirectoryW            CreateDirectoryWrapW
#define CreateEventW                CreateEventWrapW
#define CreateFileW                 CreateFileWrapW
#define CreateFontW                 CreateFontWrapW
#define CreateFontIndirectW         CreateFontIndirectWrapW
#define CreateMetaFileW             CreateMetaFileWrapW
#define CreateMutexW                CreateMutexWrapW
#define CreateICW                   CreateICWrapW
#define CreateSemaphoreW            CreateSemaphoreWrapW
#define CreateWindowExW             CreateWindowExWrapW
#define GetFileVersionInfoSizeW     GetFileVersionInfoSizeWrapW
#define GetFileVersionInfoW         GetFileVersionInfoWrapW
#define lstrcmpiW                   StrCmpIW
#define lstrcmpW                    StrCmpW
#define lstrcpyW                    StrCpyW
#define lstrcpynW                   StrCpyNW
#define VerQueryValueW              VerQueryValueWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define DefWindowProcW              DefWindowProcWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define DeleteFileW                 DeleteFileWrapW
#define DispatchMessageW            DispatchMessageWrapW
#define DragQueryFileW              DragQueryFileWrapW
#define DrawTextExW                 DrawTextExWrapW
#define DrawTextW                   DrawTextWrapW
#define EnumFontFamiliesW           EnumFontFamiliesWrapW
#define EnumFontFamiliesExW         EnumFontFamiliesExWrapW
#define EnumResourceNamesW          EnumResourceNamesWrapW
#define ExpandEnvironmentStringsW   ExpandEnvironmentStringsWrapW
#define ExtractIconExW              ExtractIconExWrapW
#define ExtTextOutW                 ExtTextOutWrapW
#define FindFirstFileW              FindFirstFileWrapW
#define FindResourceW               FindResourceWrapW
#define FindNextFileW               FindNextFileWrapW
#define FindWindowW                 FindWindowWrapW
#define FindWindowExW               FindWindowExWrapW
#define FormatMessageW              FormatMessageWrapW
#ifndef NO_W95_GETCLASSINFO_WRAPS
// #define NO_W95_GETCLASSINFO_WRAPS if one of the objects uses IProvideClassInfo which has a GetClassInfo method.
#define GetClassInfoW               GetClassInfoWrapW
#define GetClassInfoExW             GetClassInfoExWrapW
#endif  // NO_W95_GETCLASSINFO_WRAPS
#define GetClassLongW               GetClassLongWrapW
#define GetClassNameW               GetClassNameWrapW
#define GetClipboardFormatNameW     GetClipboardFormatNameWrapW
#define GetCurrentDirectoryW        GetCurrentDirectoryWrapW
#define GetDlgItemTextW             GetDlgItemTextWrapW
#define GetFileAttributesW          GetFileAttributesWrapW
#define GetFullPathNameW            GetFullPathNameWrapW
#define GetLocaleInfoW              GetLocaleInfoWrapW
#define GetMenuItemInfoW            GetMenuItemInfoWrapW
#define GetMenuStringW              GetMenuStringWrapW
#define GetMessageW                 GetMessageWrapW
#define GetModuleFileNameW          GetModuleFileNameWrapW
#define GetNumberFormatW            GetNumberFormatWrapW
#define GetSystemDirectoryW         GetSystemDirectoryWrapW
#define GetModuleHandleW            GetModuleHandleWrapW
#define GetObjectW                  GetObjectWrapW
#define GetPrivateProfileIntW       GetPrivateProfileIntWrapW
#define GetPrivateProfileStringW    GetPrivateProfileStringWrapW
#define GetProfileStringW           GetProfileStringWrapW
#define GetPropW                    GetPropWrapW
#define GlobalAddAtomW              GlobalAddAtomWrapW
#define GlobalFindAtomW             GlobalFindAtomWrapW
#define GetShortPathNameW           GetShortPathNameWrapW
#define GetLongPathNameW            GetLongPathNameWrapW
#define GetLongPathNameA            GetLongPathNameWrapA
#define GetStringTypeExW            GetStringTypeExWrapW
#define GetTempFileNameW            GetTempFileNameWrapW
#define GetTempPathW                GetTempPathWrapW
#define GetTextExtentPoint32W       GetTextExtentPoint32WrapW
#define GetTextFaceW                GetTextFaceWrapW
#define GetTextMetricsW             GetTextMetricsWrapW
#define GetTimeFormatW              GetTimeFormatWrapW
#define GetDateFormatW              GetDateFormatWrapW
#define GetUserNameW                GetUserNameWrapW
#define GetWindowLongW              GetWindowLongWrapW
#define GetEnvironmentVariableW     GetEnvironmentVariableWrapW

#ifndef NO_W95_ATL_WRAPS_TBS
// #define NO_W95_ATL_WRAPS_TBS if you use ATL.
#define GetWindowTextW              GetWindowTextWrapW
#endif // NO_W95_ATL_WRAPS_TBS

#define GetWindowTextLengthW        GetWindowTextLengthWrapW
#define GetWindowsDirectoryW        GetWindowsDirectoryWrapW
#define InsertMenuW                 InsertMenuWrapW
#define InsertMenuItemW             InsertMenuItemWrapW
#define IsBadStringPtrW             IsBadStringPtrWrapW
#define IsDialogMessageW            IsDialogMessageWrapW
#define LoadAcceleratorsW           LoadAcceleratorsWrapW
#define LoadBitmapW                 LoadBitmapWrapW
#define LoadCursorW                 LoadCursorWrapW
#define LoadIconW                   LoadIconWrapW
#define LoadImageW                  LoadImageWrapW
#define LoadLibraryW                LoadLibraryWrapW
#define LoadLibraryExW              LoadLibraryExWrapW
#define LoadMenuW                   LoadMenuWrapW
#define LoadStringW                 LoadStringWrapW
#define MessageBoxIndirectW         MessageBoxIndirectWrapW
#define MessageBoxW                 MessageBoxWrapW
#define ModifyMenuW                 ModifyMenuWrapW
#define GetCharWidth32W             GetCharWidth32WrapW
#define GetCharacterPlacementW      GetCharacterPlacementWrapW
#define CopyFileW                   CopyFileWrapW
#define MoveFileW                   MoveFileWrapW
#define OemToCharW                  OemToCharWrapW
#define OpenEventW                  OpenEventWrapW
#define OutputDebugStringW          OutputDebugStringWrapW
#define PeekMessageW                PeekMessageWrapW
#define PostMessageW                PostMessageWrapW
#define PostThreadMessageW          PostThreadMessageWrapW
#define RegCreateKeyW               RegCreateKeyWrapW
#define RegCreateKeyExW             RegCreateKeyExWrapW
#define RegDeleteKeyW               RegDeleteKeyWrapW
#define RegDeleteValueW             RegDeleteValueWrapW
#define RegEnumKeyW                 RegEnumKeyWrapW
#define RegEnumKeyExW               RegEnumKeyExWrapW
#define RegOpenKeyW                 RegOpenKeyWrapW
#define RegOpenKeyExW               RegOpenKeyExWrapW
#define RegQueryInfoKeyW            RegQueryInfoKeyWrapW
#define RegQueryValueW              RegQueryValueWrapW
#define RegQueryValueExW            RegQueryValueExWrapW
#define RegSetValueW                RegSetValueWrapW
#define RegSetValueExW              RegSetValueExWrapW
#define RegisterClassW              RegisterClassWrapW
#define RegisterClassExW            RegisterClassExWrapW
#define RegisterClipboardFormatW    RegisterClipboardFormatWrapW
#define RegisterWindowMessageW      RegisterWindowMessageWrapW
#define RemoveDirectoryW            RemoveDirectoryWrapW
#define RemovePropW                 RemovePropWrapW
#define SearchPathW                 SearchPathWrapW
#define SendDlgItemMessageW         SendDlgItemMessageWrapW
#define SendMessageW                SendMessageWrapW
#define SendMessageTimeoutW         SendMessageTimeoutWrapW
#define SetCurrentDirectoryW        SetCurrentDirectoryWrapW
#define SetDlgItemTextW             SetDlgItemTextWrapW
#define SetMenuItemInfoW            SetMenuItemInfoWrapW
#define SetPropW                    SetPropWrapW
#define SetFileAttributesW          SetFileAttributesWrapW
#define SetWindowLongW              SetWindowLongWrapW

#ifndef NO_W95_SHELL32_WRAPS
#define ExtractIconW                ExtractIconWrapW
#define SHGetFileInfoW              SHGetFileInfoWrapW
#define SHBrowseForFolderW          SHBrowseForFolderWrapW
#define ShellExecuteExW             ShellExecuteExWrapW
#define SHFileOperationW            SHFileOperationWrapW
#define SHGetNewLinkInfoW           SHGetNewLinkInfoWrapW
#define SHDefExtractIconW           SHDefExtractIconWrapW
#define SHChangeNotify              SHChangeNotifyWrap
#define SHFlushSFCache              SHFlushSFCacheWrap
#define SHGetPathFromIDListW        SHGetPathFromIDListWrapW
#endif // NO_W95_SHELL32_WRAPS

#define GetUserNameW                GetUserNameWrapW
#define RegEnumValueW               RegEnumValueWrapW
#define WritePrivateProfileStructW  WritePrivateProfileStructWrapW
#define GetPrivateProfileStructW    GetPrivateProfileStructWrapW
#define CreateProcessW              CreateProcessWrapW
#define DdeInitializeW              DdeInitializeWrapW
#define DdeCreateStringHandleW      DdeCreateStringHandleWrapW
#define DdeQueryStringW             DdeQueryStringWrapW
#define GetSaveFileNameW            GetSaveFileNameWrapW
#define GetOpenFileNameW            GetOpenFileNameWrapW
#define PageSetupDlgW               PageSetupDlgWrapW
#define PrintDlgW                   PrintDlgWrapW
#define SetWindowsHookExW           SetWindowsHookExWrapW
#define SetWindowTextW              SetWindowTextWrapW
#define StartDocW                   StartDocWrapW
#define CreateColorSpaceW           CreateColorSpaceWrapW
#define SystemParametersInfoW       SystemParametersInfoWrapW

#ifndef NO_W95_TRANSACCEL_WRAPS_TBS
// #define NO_W95_TRANSACCEL_WRAPS_TBS if one of the objects uses IOleInPlaceActiveObject which has a TranslateAccelerator method.
#define TranslateAcceleratorW       TranslateAcceleratorWrapW
#endif // NO_W95_TRANSACCEL_WRAPS_TBS

#define UnregisterClassW            UnregisterClassWrapW
#define VkKeyScanW                  VkKeyScanWrapW
#define WinHelpW                    WinHelpWrapW
#define WritePrivateProfileStringW  WritePrivateProfileStringWrapW
#define wvsprintfW                  wvsprintfWrapW
#define WNetRestoreConnectionW      WNetRestoreConnectionWrapW
#define WNetGetLastErrorW           WNetGetLastErrorWrapW

#endif // NO_W95WRAPS_UNITHUNK

#if !defined(NO_W95WRAPS_UNITHUNK) && !defined(NO_W95WRAPS_MLUI)

#define CreateDialogIndirectParamW  CreateDialogIndirectParamWrapW
#define CreateDialogParamW          CreateDialogParamWrapW
#define DialogBoxIndirectParamW     DialogBoxIndirectParamWrapW                 // UNICODE, ML
//#ifdef DialogBoxIndirectW
//#undef DialogBoxIndirectW
//#endif
//#define DialogBoxIndirectW(i,h,w,f) DialogBoxIndirectParamWrapW(i,h,w,f,d,0)    // UNICODE, ML
#define DialogBoxParamW             DialogBoxParamWrapW                         // UNICODE, ML
//#ifdef DialogBoxW
//#undef DialogBoxW
//#endif
//#define DialogBoxW(i,t,w,f)         DialogBoxParamWrapW(i,t,w,f,0)              // UNICODE, ML
#define ShellMessageBoxW            ShellMessageBoxWrapW

#define TrackPopupMenu              TrackPopupMenuWrap
#define TrackPopupMenuEx            TrackPopupMenuExWrap

#define DeleteMenu                  DeleteMenuWrap
#define DestroyMenu                 DestroyMenuWrap

#endif // !defined(NO_W95WRAPS_UNITHUNK) || !defined(NO_W95WRAPS_MLUI)


#if !defined(NO_OLE32_WRAPS)
#define CLSIDFromString             CLSIDFromStringWrap
#define CLSIDFromProgID             CLSIDFromProgIDWrap
#endif

#endif // _X86_

#endif // _INC_W95WRAPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\winfoldr.h ===
#ifndef _WINFOLDR_H_
#define _WINFOLDR_H_

// Folder Display Name IDs

// should reserve 0x5500 to 0x5C00 for localization strings
// assumption: maximum folder #< 256, max lNK #< 512

#define IDS_LOCALGDN_FLD_START 0x5500


#define IDS_LOCALGDN_FLD_ACCESSIBILITY      IDS_LOCALGDN_FLD_START
#define IDS_LOCALGDN_FLD_ACCESSORIES        IDS_LOCALGDN_FLD_START+1
#define IDS_LOCALGDN_FLD_ADMIN_TOOLS        IDS_LOCALGDN_FLD_START+2
#define IDS_LOCALGDN_FLD_ADMINISTRATOR      IDS_LOCALGDN_FLD_START+3
#define IDS_LOCALGDN_FLD_APP_COMP_SCRIPTS   IDS_LOCALGDN_FLD_START+4
#define IDS_LOCALGDN_FLD_APP_DATA           IDS_LOCALGDN_FLD_START+5
#define IDS_LOCALGDN_FLD_COMMON_COVER       IDS_LOCALGDN_FLD_START+6
#define IDS_LOCALGDN_FLD_COMMON_FILES       IDS_LOCALGDN_FLD_START+7
#define IDS_LOCALGDN_FLD_COMMUNICATIONS     IDS_LOCALGDN_FLD_START+8
#define IDS_LOCALGDN_FLD_DESKTOP            IDS_LOCALGDN_FLD_START+9
#define IDS_LOCALGDN_FLD_DOCUMENTS          IDS_LOCALGDN_FLD_START+10
#define IDS_LOCALGDN_FLD_DOCSETTINGS        IDS_LOCALGDN_FLD_START+11
#define IDS_LOCALGDN_FLD_ENTERTAINMENT      IDS_LOCALGDN_FLD_START+12
#define IDS_LOCALGDN_FLD_GAMES              IDS_LOCALGDN_FLD_START+13
#define IDS_LOCALGDN_FLD_LOCALSETTINGS      IDS_LOCALGDN_FLD_START+14
#define IDS_LOCALGDN_FLD_MEDIA              IDS_LOCALGDN_FLD_START+15
#define IDS_LOCALGDN_FLD_MSSCRIPTDEBUG      IDS_LOCALGDN_FLD_START+16
#define IDS_LOCALGDN_FLD_MYBRIEFCASE        IDS_LOCALGDN_FLD_START+17
#define IDS_LOCALGDN_FLD_MYFAXES            IDS_LOCALGDN_FLD_START+18
#define IDS_LOCALGDN_FLD_MYPICTURES         IDS_LOCALGDN_FLD_START+19
#define IDS_LOCALGDN_FLD_ONLINE_SERVICES    IDS_LOCALGDN_FLD_START+20
#define IDS_LOCALGDN_FLD_PROGRAM_FILES      IDS_LOCALGDN_FLD_START+21
#define IDS_LOCALGDN_FLD_PROGRAMS           IDS_LOCALGDN_FLD_START+22
#define IDS_LOCALGDN_FLD_RECEIVED_FAXES     IDS_LOCALGDN_FLD_START+23
#define IDS_LOCALGDN_FLD_SENT_FAXES         IDS_LOCALGDN_FLD_START+24
#define IDS_LOCALGDN_FLD_SHARED_DOC         IDS_LOCALGDN_FLD_START+25
#define IDS_LOCALGDN_FLD_START_MENU         IDS_LOCALGDN_FLD_START+26
#define IDS_LOCALGDN_FLD_STARTUP            IDS_LOCALGDN_FLD_START+27
#define IDS_LOCALGDN_FLD_SYSTEM_TOOLS       IDS_LOCALGDN_FLD_START+28
#define IDS_LOCALGDN_FLD_WINDOWS_MEDIA      IDS_LOCALGDN_FLD_START+29
#define IDS_LOCALGDN_FLD_MYMUSIC            IDS_LOCALGDN_FLD_START+30
#define IDS_LOCALGDN_FLD_MYVIDEOS           IDS_LOCALGDN_FLD_START+31
#define IDS_LOCALGDN_FLD_THEIRDOCUMENTS     IDS_LOCALGDN_FLD_START+32
#define IDS_LOCALGDN_FLD_THEIRPICTURES      IDS_LOCALGDN_FLD_START+33
#define IDS_LOCALGDN_FLD_THEIRMUSIC         IDS_LOCALGDN_FLD_START+34
#define IDS_LOCALGDN_FLD_THEIRVIDEOS        IDS_LOCALGDN_FLD_START+35


// LNK file Display Name IDs
// assume maximum FOLDER is less than 0x100
#define IDS_LOCALGDN_LNK_START IDS_LOCALGDN_FLD_START+0x100

#define IDS_LOCALGDN_LNK_ACCESSIBILITY_WIZARD   IDS_LOCALGDN_LNK_START
#define IDS_LOCALGDN_LNK_ADDRESS_BOOK           IDS_LOCALGDN_LNK_START+1
#define IDS_LOCALGDN_LNK_BACKUP                 IDS_LOCALGDN_LNK_START+2
#define IDS_LOCALGDN_LNK_CALCULATOR             IDS_LOCALGDN_LNK_START+3
#define IDS_LOCALGDN_LNK_CDPLAYER               IDS_LOCALGDN_LNK_START+4
#define IDS_LOCALGDN_LNK_CHARACTER_MAP          IDS_LOCALGDN_LNK_START+5
#define IDS_LOCALGDN_LNK_COMMAND_PROMPT         IDS_LOCALGDN_LNK_START+6
#define IDS_LOCALGDN_LNK_COMP_MANAG             IDS_LOCALGDN_LNK_START+7
#define IDS_LOCALGDN_LNK_CONFIG_SERVER          IDS_LOCALGDN_LNK_START+8
#define IDS_LOCALGDN_LNK_DATA_ODBC              IDS_LOCALGDN_LNK_START+9
#define IDS_LOCALGDN_LNK_DISK_CLEANUP           IDS_LOCALGDN_LNK_START+10
#define IDS_LOCALGDN_LNK_DISK_DEFRAG            IDS_LOCALGDN_LNK_START+11
#define IDS_LOCALGDN_LNK_DFS                    IDS_LOCALGDN_LNK_START+12
#define IDS_LOCALGDN_LNK_EVENT_VIEWER           IDS_LOCALGDN_LNK_START+13
#define IDS_LOCALGDN_LNK_FREECELL               IDS_LOCALGDN_LNK_START+14
#define IDS_LOCALGDN_LNK_HYPERTERMINAL          IDS_LOCALGDN_LNK_START+15
#define IDS_LOCALGDN_LNK_IMAGING                IDS_LOCALGDN_LNK_START+16
#define IDS_LOCALGDN_LNK_ICW                    IDS_LOCALGDN_LNK_START+17
#define IDS_LOCALGDN_LNK_INTERNET_EXPLORER      IDS_LOCALGDN_LNK_START+18
#define IDS_LOCALGDN_LNK_INTERNET_SERVICES      IDS_LOCALGDN_LNK_START+19
#define IDS_LOCALGDN_LNK_ISDN_CONFIG            IDS_LOCALGDN_LNK_START+20
#define IDS_LOCALGDN_LNK_LAUNCH_IE              IDS_LOCALGDN_LNK_START+21
#define IDS_LOCALGDN_LNK_LAUNCH_OE              IDS_LOCALGDN_LNK_START+22
#define IDS_LOCALGDN_LNK_LICENSING              IDS_LOCALGDN_LNK_START+23
#define IDS_LOCALGDN_LNK_LOCAL_SECURITY         IDS_LOCALGDN_LNK_START+24
#define IDS_LOCALGDN_LNK_MAGNIFIER              IDS_LOCALGDN_LNK_START+25
#define IDS_LOCALGDN_LNK_MAINTENANCE_WIZARD     IDS_LOCALGDN_LNK_START+26
#define IDS_LOCALGDN_LNK_MSSCRIPT_DEB           IDS_LOCALGDN_LNK_START+27
#define IDS_LOCALGDN_LNK_MSSCRIPT_DEB_README    IDS_LOCALGDN_LNK_START+28
#define IDS_LOCALGDN_LNK_MINESWEEPER            IDS_LOCALGDN_LNK_START+29
#define IDS_LOCALGDN_LNK_MSN_MESSENGER          IDS_LOCALGDN_LNK_START+30
#define IDS_LOCALGDN_LNK_MYBRIEFCASE            IDS_LOCALGDN_LNK_START+31
#define IDS_LOCALGDN_LNK_NARRATOR               IDS_LOCALGDN_LNK_START+32
#define IDS_LOCALGDN_LNK_NETWORK_DIALUP         IDS_LOCALGDN_LNK_START+33
#define IDS_LOCALGDN_LNK_NETWORK_MON            IDS_LOCALGDN_LNK_START+34
#define IDS_LOCALGDN_LNK_NOTEPAD                IDS_LOCALGDN_LNK_START+35
#define IDS_LOCALGDN_LNK_ONSCREEN_KEY           IDS_LOCALGDN_LNK_START+36
#define IDS_LOCALGDN_LNK_OUTLOOK_EXPRESS        IDS_LOCALGDN_LNK_START+37
#define IDS_LOCALGDN_LNK_PAINT                  IDS_LOCALGDN_LNK_START+38
#define IDS_LOCALGDN_LNK_PERFORMANCE            IDS_LOCALGDN_LNK_START+39
#define IDS_LOCALGDN_LNK_PHONE_DIALER           IDS_LOCALGDN_LNK_START+40
#define IDS_LOCALGDN_LNK_PINBALL                IDS_LOCALGDN_LNK_START+41
#define IDS_LOCALGDN_LNK_SCHEDULED_TASKS        IDS_LOCALGDN_LNK_START+42
#define IDS_LOCALGDN_LNK_SERVICES               IDS_LOCALGDN_LNK_START+43
#define IDS_LOCALGDN_LNK_SOLITAIRE              IDS_LOCALGDN_LNK_START+44
#define IDS_LOCALGDN_LNK_SOUND_REC              IDS_LOCALGDN_LNK_START+45
#define IDS_LOCALGDN_LNK_SYNCHRONIZE            IDS_LOCALGDN_LNK_START+46
#define IDS_LOCALGDN_LNK_SYSTEM_INFO            IDS_LOCALGDN_LNK_START+47
#define IDS_LOCALGDN_LNK_TELNET_SERVER_ADMIN    IDS_LOCALGDN_LNK_START+48
#define IDS_LOCALGDN_LNK_UTILITY_MANAGER        IDS_LOCALGDN_LNK_START+49
#define IDS_LOCALGDN_LNK_VOLUME_CONTROL         IDS_LOCALGDN_LNK_START+50
#define IDS_LOCALGDN_LNK_WINDOWS_EXPLORER       IDS_LOCALGDN_LNK_START+51
#define IDS_LOCALGDN_LNK_WINDOWS_UPDATE         IDS_LOCALGDN_LNK_START+52
#define IDS_LOCALGDN_LNK_WORDPAD                IDS_LOCALGDN_LNK_START+53

#define IDS_LOCALGDN_LNK_EUDCEDIT               IDS_LOCALGDN_LNK_START+54
#define IDS_LOCALGDN_LNK_CHAT                   IDS_LOCALGDN_LNK_START+55
#define IDS_LOCALGDN_LNK_MEDIAPLAYER            IDS_LOCALGDN_LNK_START+56
#define IDS_LOCALGDN_LNK_GETSTART               IDS_LOCALGDN_LNK_START+57
#define IDS_LOCALGDN_LNK_CLIPBOOK               IDS_LOCALGDN_LNK_START+58
#define IDS_LOCALGDN_LNK_WINDOWS_CATALOG        IDS_LOCALGDN_LNK_START+59 // 22075


// IDs for Infotip Strings
// assume maximum LNK is less than 0x200
#define IDS_LOCALGDN_ITIP_START IDS_LOCALGDN_LNK_START+0x200

#define IDS_LOCALGDN_ITIP_ACCESSIBILITY_WIZARD  IDS_LOCALGDN_ITIP_START
#define IDS_LOCALGDN_ITIP_ADDRESS_BOOK          IDS_LOCALGDN_ITIP_START+1
#define IDS_LOCALGDN_ITIP_BACKUP                IDS_LOCALGDN_ITIP_START+2
#define IDS_LOCALGDN_ITIP_CALCULATOR            IDS_LOCALGDN_ITIP_START+3
#define IDS_LOCALGDN_ITIP_CDPLAYER              IDS_LOCALGDN_ITIP_START+4
#define IDS_LOCALGDN_ITIP_CHARACTER_MAP         IDS_LOCALGDN_ITIP_START+5
#define IDS_LOCALGDN_ITIP_COMMAND_PROMPT        IDS_LOCALGDN_ITIP_START+6
#define IDS_LOCALGDN_ITIP_COMP_MANAG            IDS_LOCALGDN_ITIP_START+7
#define IDS_LOCALGDN_ITIP_CONFIG_SERVER         IDS_LOCALGDN_ITIP_START+8
#define IDS_LOCALGDN_ITIP_DATA_ODBC             IDS_LOCALGDN_ITIP_START+9
#define IDS_LOCALGDN_ITIP_DISK_CLEANUP          IDS_LOCALGDN_ITIP_START+10
#define IDS_LOCALGDN_ITIP_DISK_DEFRAG           IDS_LOCALGDN_ITIP_START+11
#define IDS_LOCALGDN_ITIP_DFS                   IDS_LOCALGDN_ITIP_START+12
#define IDS_LOCALGDN_ITIP_EVEN_VIEWER           IDS_LOCALGDN_ITIP_START+13
#define IDS_LOCALGDN_ITIP_FREECELL              IDS_LOCALGDN_ITIP_START+14
#define IDS_LOCALGDN_ITIP_HYPERTERMINAL         IDS_LOCALGDN_ITIP_START+15
#define IDS_LOCALGDN_ITIP_IMAGING               IDS_LOCALGDN_ITIP_START+16
#define IDS_LOCALGDN_ITIP_ICW                   IDS_LOCALGDN_ITIP_START+17
#define IDS_LOCALGDN_ITIP_INTERNET_EXPLORER     IDS_LOCALGDN_ITIP_START+18
#define IDS_LOCALGDN_ITIP_INTERNET_SERVICES     IDS_LOCALGDN_ITIP_START+19
#define IDS_LOCALGDN_ITIP_ISDN_CONFIG           IDS_LOCALGDN_ITIP_START+20
#define IDS_LOCALGDN_ITIP_LAUNCH_IE             IDS_LOCALGDN_ITIP_START+21
#define IDS_LOCALGDN_ITIP_LAUNCH_OE             IDS_LOCALGDN_ITIP_START+22
#define IDS_LOCALGDN_ITIP_LICENSING             IDS_LOCALGDN_ITIP_START+23
#define IDS_LOCALGDN_ITIP_LOCAL_SECURITY        IDS_LOCALGDN_ITIP_START+24
#define IDS_LOCALGDN_ITIP_MAGNIFIER             IDS_LOCALGDN_ITIP_START+25
#define IDS_LOCALGDN_ITIP_MAINTENANCE_WIZARD    IDS_LOCALGDN_ITIP_START+26
#define IDS_LOCALGDN_ITIP_MSSCRIPT_DEB          IDS_LOCALGDN_ITIP_START+27
#define IDS_LOCALGDN_ITIP_MSSCRIPT_DEB_README   IDS_LOCALGDN_ITIP_START+28
#define IDS_LOCALGDN_ITIP_MINESWEEPER           IDS_LOCALGDN_ITIP_START+29
#define IDS_LOCALGDN_ITIP_MSN_MESSENGER_SERVICE IDS_LOCALGDN_ITIP_START+30
#define IDS_LOCALGDN_ITIP_MYBRIEFCASE           IDS_LOCALGDN_ITIP_START+31
#define IDS_LOCALGDN_ITIP_NARRATOR              IDS_LOCALGDN_ITIP_START+32
#define IDS_LOCALGDN_ITIP_NETWORK_DIALUP        IDS_LOCALGDN_ITIP_START+33
#define IDS_LOCALGDN_ITIP_NETWORK_MON           IDS_LOCALGDN_ITIP_START+34
#define IDS_LOCALGDN_ITIP_NOTEPAD               IDS_LOCALGDN_ITIP_START+35
#define IDS_LOCALGDN_ITIP_ONSCREEN_KEY          IDS_LOCALGDN_ITIP_START+36
#define IDS_LOCALGDN_ITIP_OUTLOOK_EXPRESS       IDS_LOCALGDN_ITIP_START+37
#define IDS_LOCALGDN_ITIP_PAINT                 IDS_LOCALGDN_ITIP_START+38
#define IDS_LOCALGDN_ITIP_PERFORMANCE           IDS_LOCALGDN_ITIP_START+39
#define IDS_LOCALGDN_ITIP_PHONE_DIALER          IDS_LOCALGDN_ITIP_START+40
#define IDS_LOCALGDN_ITIP_PINBALL               IDS_LOCALGDN_ITIP_START+41
#define IDS_LOCALGDN_ITIP_SCHEDULED_TASKS       IDS_LOCALGDN_ITIP_START+42
#define IDS_LOCALGDN_ITIP_SERVICES              IDS_LOCALGDN_ITIP_START+43
#define IDS_LOCALGDN_ITIP_SOLITAIRE             IDS_LOCALGDN_ITIP_START+44
#define IDS_LOCALGDN_ITIP_SOUND_REC             IDS_LOCALGDN_ITIP_START+45
#define IDS_LOCALGDN_ITIP_SYNCHRONIZE           IDS_LOCALGDN_ITIP_START+46
#define IDS_LOCALGDN_ITIP_SYSTEM_INFO           IDS_LOCALGDN_ITIP_START+47
#define IDS_LOCALGDN_ITIP_TELNET_SERVER_ADM     IDS_LOCALGDN_ITIP_START+48
#define IDS_LOCALGDN_ITIP_UTILITY_MANAGER       IDS_LOCALGDN_ITIP_START+49
#define IDS_LOCALGDN_ITIP_VOLUME_CONTROL        IDS_LOCALGDN_ITIP_START+50
#define IDS_LOCALGDN_ITIP_WINDOWS_EXPLORER      IDS_LOCALGDN_ITIP_START+51
#define IDS_LOCALGDN_ITIP_WINDOWS_UPDATE        IDS_LOCALGDN_ITIP_START+52
#define IDS_LOCALGDN_ITIP_WORDPAD               IDS_LOCALGDN_ITIP_START+53

#define IDS_LOCALGDN_ITIP_EUDCEDIT              IDS_LOCALGDN_ITIP_START+54
#define IDS_LOCALGDN_ITIP_CHAT                  IDS_LOCALGDN_ITIP_START+55
#define IDS_LOCALGDN_ITIP_MEDIAPLAYER           IDS_LOCALGDN_ITIP_START+56
#define IDS_LOCALGDN_ITIP_GETSTART              IDS_LOCALGDN_ITIP_START+57
#define IDS_LOCALGDN_ITIP_CLIPBOOK              IDS_LOCALGDN_ITIP_START+58
#define IDS_LOCALGDN_ITIP_WINDOWS_CATALOG       IDS_LOCALGDN_ITIP_START+59 // 22587


//added on 5/2/2000 for Shell Name Space InfoTip
//assume 0x180 Shortcut before this. If not enough, add new ones after NameSpace Infotip
#define IDS_LOCALGDN_ITIPNS_START IDS_LOCALGDN_ITIP_START+0x180

#define IDS_LOCALGDN_ITIPNS_MY_NETWORK_PLACES   IDS_LOCALGDN_ITIPNS_START
#define IDS_LOCALGDN_ITIPNS_MY_COMPUTER         IDS_LOCALGDN_ITIPNS_START+1
#define IDS_LOCALGDN_ITIPNS_MY_DOCUMENTS        IDS_LOCALGDN_ITIPNS_START+2
#define IDS_LOCALGDN_ITIPNS_RECYCLE_BIN         IDS_LOCALGDN_ITIPNS_START+3
// unused
#define IDS_LOCALGDN_ITIPNS_BRIEFCASE           IDS_LOCALGDN_ITIPNS_START+5
// unused
// unused
#define IDS_LOCALGDN_ITIPNS_FONTS               IDS_LOCALGDN_ITIPNS_START+8
#define IDS_LOCALGDN_ITIPNS_ADMIN_TOOLS         IDS_LOCALGDN_ITIPNS_START+9
// unused
#define IDS_LOCALGDN_ITIPNS_SCHEDULED_TASKS     IDS_LOCALGDN_ITIPNS_START+11
#define IDS_LOCALGDN_ITIPNS_FOLDEROPTIONS       IDS_LOCALGDN_ITIPNS_START+12

// added on 5/2/2000 for LocalizedString/DisplayName of Shell Name Space
#define IDS_LOCALGDN_NS_START IDS_LOCALGDN_ITIPNS_START+0x40

// unused
// unused
#define IDS_LOCALGDN_NS_BRIEFCASE               IDS_LOCALGDN_NS_START+2
// unused
// unused
#define IDS_LOCALGDN_NS_FONTS                   IDS_LOCALGDN_NS_START+5
#define IDS_LOCALGDN_NS_ADMIN_TOOLS             IDS_LOCALGDN_NS_START+6
// unused
// unused
#define IDS_LOCALGDN_NS_FOLDEROPTIONS           IDS_LOCALGDN_NS_START+9

// Shell search extensions
#define IDS_LOCALGDN_SRCHEXT_START IDS_LOCALGDN_NS_START+0x100

#define IDS_LOCALGDN_SRCHEXT_FILES_AND_FOLDERS  IDS_LOCALGDN_SRCHEXT_START
#define IDS_LOCALGDN_SRCHEXT_COMPUTERS          IDS_LOCALGDN_SRCHEXT_START+1
#define IDS_LOCALGDN_SRCHEXT_PRINTER            IDS_LOCALGDN_SRCHEXT_START+2

// Shell search extensions help
#define IDS_LOCALGDN_SRCHHLP_START IDS_LOCALGDN_SRCHEXT_START+0x40

#define IDS_LOCALGDN_SRCHHLP_FILES_AND_FOLDERS  IDS_LOCALGDN_SRCHHLP_START
#define IDS_LOCALGDN_SRCHHLP_COMPUTERS          IDS_LOCALGDN_SRCHHLP_START+1
#define IDS_LOCALGDN_SRCHHLP_PRINTER            IDS_LOCALGDN_SRCHHLP_START+2

// next available range is IDS_LOCALGDN_SRCHHLP_START+0x40

#endif // _WINFOLDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\imapi\imagefile.h ===
/******************************************************************************
**
** Copyright 1999 Adaptec, Inc.,  All Rights Reserved.
**
** This software contains the valuable trade secrets of Adaptec.  The
** software is protected under copyright laws as an unpublished work of
** Adaptec.  Notice is for informational purposes only and does not imply
** publication.  The user of this software may make copies of the software
** for use with parts manufactured by Adaptec or under license from Adaptec
** and for no other use.
**
******************************************************************************/

/******************************************************************************
**
**  Module Name:    ImageFile.h
**
**  Description:
**
**  Programmers:    Daniel Evers (dle)
**
**  History:        1999 98 03 (dle)  Initial creation for Millenium.
**
**  Notes:          This file created using 4 spaces per tab.
**
******************************************************************************/

#ifndef __IMAGE_H__
#define __IMAGE_H__


/*
** Make sure structures are byte aligned and fields are undecorated.
*/

#pragma pack(1)
#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

/*
 * Constant declarations section.
 */
#define IMAGE_SIGNATURE     'araK'

#define IMAGE_VERSION_EDIT  ((DWORD)( 0x0001 ))
#define IMAGE_VERSION_LO    ((DWORD)( 0x02 ))
#define IMAGE_VERSION_HI    ((DWORD)( 0x01 ))

#define IMAGE_VERSION       ((( IMAGE_VERSION_HI << 24 ) & 0xff000000 ) | \
                            (( IMAGE_VERSION_LO << 16 ) & 0x00ff0000 ) | \
                            ( IMAGE_VERSION_EDIT & 0x0000ffff ))


#define IMAGE_TYPE_REDBOOK_AUDIO_BLOCKSIZE  2352    // or 0x930
#define IMAGE_TYPE_DATA_MODE1_BLOCKSIZE     2048    // or 0x800


/*
 * Type definitions section.
 */

    // Following are the definitions used to describe the content of the
    // image file for various content types.
typedef enum {
    eImageRecorderModeTrackAtOnce = 1,
    eImageRecorderModeSessionAtOnce,
    eImageRecorderModeDiscAtOnce,
    eImageRecorderModeMAX
} IMAGE_RECORDER_MODE_ENUM;

typedef enum {
    eImageDiscFormatDataMode1 = 1,
    eImageDiscFormatAudioRedbook,
    eImageDiscFormatMAX
} IMAGE_DISC_FORMAT_ENUM;

typedef enum {
    eImageSectionDescConstantBlockStash = 1,
    eImageSectionDescMAX
} IMAGE_SECTION_DESCRIPTOR_TYPE_ENUM;

typedef enum {
    eImageSectionDataDataMode1 = 1,
    eImageSectionDataAudioRedbook,
    eImageSectionDataMAX
} IMAGE_SECTION_DATA_TYPE_ENUM;

typedef enum {
    eImageSourceTypeStashFile = 1,
    eImageSourceTypeMAX
} IMAGE_SOURCE_TYPE_ENUM;

    // The structure of the image file ready to be burned as a Redboook
    // audio disc is simply a series of tracks, already in the 2352-byte
    // block-size format:
    //
    // 
    //            |------------------------------------------------------------
    //            | Track 1 (N1 blocks of 2352 bytes)
    //            |------------------------------------------------------------
    //            | Track 2 (N2 blocks of 2352 bytes)
    //            |------------------------------------------------------------
    //            | ...
    //            |------------------------------------------------------------
    //            | Track T (NT blocks of 2352 bytes)
    //            |------------------------------------------------------------
    //

    // The structure of the image file ready to be burned as a Mode 1 Data disc:
    // This diagram is of a Joliet (a derivative of ISO 9660) data disc for example.
    // The on-disk structure is simply the complete set of 2048 blocks that are to
    // comprise the single data-track.  Coincidentally, this is the strcture of
    // an ISO9660 image file, so tools like CDWorkshop may be used to view the
    // image in the on-disk stash file.
    // 
    //            |------------------------------------------------------------
    //            | Block 0 (zeroes)  (2048 bytes)
    //            |------------------------------------------------------------
    //            | Block 1 (zeroes)  (2048 bytes)
    //            |------------------------------------------------------------
    //            | ...
    //            |------------------------------------------------------------
    //            | Block 15 (zeroes)  (2048 bytes)
    //            |------------------------------------------------------------
    //            | Block 16 (ISO 9660 PVD)  (2048 bytes)
    //            |------------------------------------------------------------
    //            | Block 17 (SVD)  (2048 bytes)
    //            |------------------------------------------------------------
    //            | Block 18 (file system or data)  (2048 bytes)
    //            |------------------------------------------------------------
    //            | Block 19 (file system or data)  (2048 bytes)
    //            |------------------------------------------------------------
    //            | ...
    //            |------------------------------------------------------------
    //            | Block T (file system or data)  (2048 bytes)
    //            |------------------------------------------------------------
    //


    // The in-memory structure (the Content List) used to describe the
    // stash-file is as follows (structure definitions follow):
    // 
    //            |------------------------------------------------------------
    //            | IMAGE_CONTENT_LIST
    //            |------------------------------------------------------------
    //            | IMAGE_DESCRIPTOR_HEADER
    //            |------------------------------------------------------------
    //            | IMAGE_SOURCE_DESCRIPTOR (including ndwSectionCount = N)
    //            |------------------------------------------------------------
    //            | IMAGE_SECTION_DESCRIPTOR 1
    //            |------------------------------------------------------------
    //            | IMAGE_SECTION_DESCRIPTOR 2
    //            |------------------------------------------------------------
    //            | ...
    //            |------------------------------------------------------------
    //            | IMAGE_SECTION_DESCRIPTOR N
    //            |------------------------------------------------------------


typedef struct {
                        // Block size in source.
    DWORD           dwBlockSize;
                        // Number of blocks in the track.
    DWORD           ndwBlockCount;
                        // 1-based Track Number.
    DWORD           idwTrackNumber;
                        // Must be zero.
    DWORD           dwaReserved[ 5 ];

                        // liOffsetStart and liOffsetEnd point to the starting and
                        // ending bytes within the image of the track.  Subtracting
                        // liOffsetStart from liOffsetEnd must equal (dwBlockSize * ndwBlockCount).
    LARGE_INTEGER   liOffsetStart;
    LARGE_INTEGER   liOffsetEnd;
} IMAGE_SECTION_CONSTANT_BLOCK_TRACK, *PIMAGE_SECTION_CONSTANT_BLOCK_TRACK;

typedef struct {
                        // IMAGE_SECTION_DESCRIPTOR_TYPE_ENUM
    DWORD           dwSectionDescType;
                        // IMAGE_SECTION_DATA_TYPE_ENUM
    DWORD           dwSectionDataType;
    DWORD           dwDescriptorSize;
                        // Flags:
                        //  None defined -- must be zero.
    DWORD           dwFlags;
                        // Must be IMAGE_SIGNATURE.
    DWORD           dwSignature;
    DWORD           dwaReserved[ 3 ];

    union {
        IMAGE_SECTION_CONSTANT_BLOCK_TRACK  dataConstantBlockTrack;
    } dcbt;
} IMAGE_SECTION_DESCRIPTOR, *PIMAGE_SECTION_DESCRIPTOR;


typedef struct {
    HANDLE          hStashFileHandle;
    void            *pIDiscStash;
    DWORD           dwaReserved[ 4 ];
} IMAGE_SOURCE_TYPE_STASH, *PIMAGE_SOURCE_TYPE_STASH;

typedef struct {
                        // sizeof( IMAGE_SOURCE_DESCRIPTOR )
    DWORD           dwHeaderSize;
                        //  None defined -- must be zero.
    DWORD           dwFlags;
                        // IMAGE_SIGNATURE
    DWORD           dwSignature;
                        // IMAGE_SOURCE_TYPE_ENUM
    DWORD           dwSourceType;
                        // Must be zero.
    DWORD           dwaReserved[ 4 ];

    union {
        IMAGE_SOURCE_TYPE_STASH     sourceStash;
    } ss;
} IMAGE_SOURCE_DESCRIPTOR, *PIMAGE_SOURCE_DESCRIPTOR;


typedef struct {
                        // sizeof( IMAGE_DESCRIPTOR_HEADER )
    DWORD           dwHeaderSize;
                        // IMAGE_DISC_FORMAT_ENUM
    DWORD           dwDiscFormat;
                        //  None defined -- must be zero.
    DWORD           dwFlags;
                        // IMAGE_RECORDER_MODE_ENUM
    DWORD           dwRecorderMode;
                        // Section count
    DWORD           ndwSectionCount;
                        // IMAGE_SIGNATURE
    DWORD           dwSignature;
                        // Must be IMAGE_VERSION.
    DWORD           dwVersion;
                        // Must be zero.
    DWORD           dwaReserved[ 5 ];
} IMAGE_DESCRIPTOR_HEADER, *PIMAGE_DESCRIPTOR_HEADER;


typedef struct {
                        // sizeof( IMAGE_CONTENT_LIST )
    DWORD           dwHeaderSize;
                        //  None defined -- must be zero.
    DWORD           dwFlags;
                        // IMAGE_SIGNATURE
    DWORD           dwSignature;
                        // Must be IMAGE_VERSION.
    DWORD           dwVersion;
                        // Sum of all size of all sections.
    DWORD           dwContentListSize;
                        // Must be zero.
    DWORD           dwaReserved[ 3 ];
} IMAGE_CONTENT_LIST, *PIMAGE_CONTENT_LIST;


/*
 * Macro definitions section.
 */
#define IMAGE_GETVERSION_EDIT( Version )    LOWORD( Version )

#define IMAGE_GETVERSION_LO( Version )      LOBYTE( HIWORD( Version ))

#define IMAGE_GETVERSION_HI( Version )      HIBYTE( HIWORD( Version ))


/*
** Restore compiler default packing and close off the C declarations.
*/

#pragma pack()
#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__IMAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\imapi\imapipub.h ===
/****************************************************************************
**
** Copyright 1999 Adaptec, Inc.,  All Rights Reserved.
**
** This software contains the valuable trade secrets of Adaptec.  The
** software is protected under copyright laws as an unpublished work of
** Adaptec.  Notice is for informational purposes only and does not imply
** publication.  The user of this software may make copies of the software
** for use with parts manufactured by Adaptec or under license from Adaptec
** and for no other use.
**
****************************************************************************/

/****************************************************************************
**
**  Module Name:    imapipub.h
**
**  Description:    Definitions of all the IOCTLs and their structures that
**                  can be used with IMAPIW2K.SYS.  Note that the structures
**                  are used for either KMD->KMD submission, or for ring-3
**                  to KMD submission.
**
**  Programmers:    Daniel Evers (dle)
**                  Tom Halloran (tgh)
**                  Don Lilly (drl)
**                  Daniel Polfer (dap)
**
**  History:        8/25/99 (dap)  Opened history and added header.
**
**  Notes:          This file created using 4 spaces per tab.
**
****************************************************************************/

#ifndef __IMAPIPUB_H_
#define __IMAPIPUB_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef DEVICE_TYPE
#define DEVICE_TYPE ULONG
#endif
#include <ntddstor.h> // sdk


#ifdef __cplusplus
extern "C" {
#endif


/*
** Globally unique identifer for the interface class of our device.
*/
// {1186654D-47B8-48b9-BEB9-7DF113AE3C67}
static const GUID IMAPIDeviceInterfaceGuid = 
{ 0x1186654d, 0x47b8, 0x48b9, { 0xbe, 0xb9, 0x7d, 0xf1, 0x13, 0xae, 0x3c, 0x67 } };


// v 20.20 had everything in this file pack(1)'d, which caused all sorts of
// alignment faults.  what was Roxio thinking?

#define IMAPIAPI_VERSION_HI                     48
#define IMAPIAPI_VERSION_LO                     48


#define FILE_DEVICE_IMAPI                       0x90DA

/*
** ----------------------------------------------------------------------------
** IOCTL_IMAPIDRV_INIT
** ----------------------------------------------------------------------------
*/

#define IOCTL_IMAPIDRV_INIT ((ULONG)CTL_CODE(FILE_DEVICE_IMAPI,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS))

typedef struct  tag_IMAPIDRV_INIT
{
    // (OUT) The version number for this API.  Use this version to make sure
    // the structures and IOCTLs are compatible.

    ULONG Version;

    // Not currently used.

    ULONG Reserved;
}
IMAPIDRV_INIT, *PIMAPIDRV_INIT;

/*
** ----------------------------------------------------------------------------
** IOCTL_IMAPIDRV_ENUMERATE - 
** This IOCTL returns information about a specific drive.  It gives global info 
** such as the driver's UniqueID for the device, and its Inquiry data, etc., 
** and it also gives an instantaneous snap-shot of the devices state information.
** This state information is accurate at the moment it is collected, but can 
** change immediately.  Therefore the state info is best used for making general
** decisions such as if the device is in use (bOpenedExclusive), wait a while 
** before seeing if it is available.
** ----------------------------------------------------------------------------
*/

#define IOCTL_IMAPIDRV_INFO ((ULONG)CTL_CODE(FILE_DEVICE_IMAPI,0x810,METHOD_BUFFERED,FILE_READ_ACCESS | FILE_WRITE_ACCESS))

#define UNIQUE_ID_LEN       256

typedef enum tag_IMAPIDRV_DEVSTATE
{
    eDevState_Started = 0x00,       //IRP_MN_START_DEVICE
    eDevState_RemovePending = 0x01, //IRP_MN_QUERY_REMOVE_DEVICE,
    eDevState_Removed = 0x02,       //IRP_MN_REMOVE_DEVICE,
    eDevState_Stopped = 0x04,       //IRP_MN_STOP_DEVICE,
    eDevState_StopPending = 0x05,   //IRP_MN_QUERY_STOP_DEVICE,
    eDevState_Unknown = 0xff
}
IMAPIDRV_DEVSTATE;

typedef struct tag_IMAPIDRV_DEVICE
{
    ULONG DeviceType;
    ULONG userDriveNumber;            // for use by user mode side of things
    PVOID pUserUse;                   // for use by user mode side of things
    STORAGE_BUS_TYPE BusType;
    USHORT BusMajorVersion;           // bus-specific data
    USHORT BusMinorVersion;           // bus-specific data
    ULONG AlignmentMask;
    ULONG MaximumTransferLength;
    ULONG MaximumPhysicalPages;
    ULONG BufferUnderrunFreeCapable;  // whether the drive support B.U.F. operation
    ULONG bInitialized;               // 0 - no initialized yet, non-zero - initialized
    ULONG bOpenedExclusive;           // 0 - not opened, non-zero - currently open by someone
    ULONG bBurning;                   // 0 - no burn process active, non-zero - the drive has started a burn process
    IMAPIDRV_DEVSTATE curDeviceState; // started, removed, etc., state of device
    DWORD idwRecorderType;            // CD-R == 0x01, CD-RW == 0x10
    ULONG maxWriteSpeed;              // 1, 2, 3, meaning 1X, 2X, etc. where X == 150KB/s (typical audio CD stream rate)
    BYTE  scsiInquiryData[36];        // first portion of data returned from Inquiry CDB // CPF - needs to be 36 long to include revision info
    UCHAR UniqueId[UNIQUE_ID_LEN];    // ID assigned when IMAPI driver registered an interface for this device
}
IMAPIDRV_DEVICE, *PIMAPIDRV_DEVICE;

typedef struct tag_IMAPIDRV_INFO
{
    ULONG Version;
    ULONG NumberOfDevices;
    IMAPIDRV_DEVICE DeviceData;
}
IMAPIDRV_INFO, *PIMAPIDRV_INFO;

// defines for idwRecorderType
#define RECORDER_TYPE_CDR     0x00000001
#define RECORDER_TYPE_CDRW    0x00000010

/*
** ----------------------------------------------------------------------------
** IOCTL_IMAPIDRV_OPENEXCLUSIVE
** ----------------------------------------------------------------------------
*/

#define IOCTL_IMAPIDRV_OPENEXCLUSIVE ((ULONG)CTL_CODE(FILE_DEVICE_IMAPI,0x820,METHOD_BUFFERED,FILE_ANY_ACCESS))

typedef struct tag_IMAPIDRV_OPENEXCLUSIVE
{
    HANDLE  Handle;
    CHAR    UniqueId[UNIQUE_ID_LEN];  // zero terminated string
}
IMAPIDRV_OPENEXCLUSIVE, *PIMAPIDRV_OPENEXCLUSIVE;

/*
** ----------------------------------------------------------------------------
** IOCTL_IMAPIDRV_SENDCOMMAND
** ----------------------------------------------------------------------------
*/

#define IOCTL_IMAPIDRV_SENDCOMMAND ((ULONG)CTL_CODE(FILE_DEVICE_IMAPI,0x830,METHOD_BUFFERED,FILE_READ_ACCESS | FILE_WRITE_ACCESS))

/*
** IMAPISRB - The SCSI REQUEST BLOCK for IMAPI.  It is simplified compared to
** the request block used in NT.  It is handle based, for one thing, and it
** doesn't have a lot of fluff.  See the NT docs, however, for information on
** individual fields.
*/
#define MAX_SENSE_BYTES             18              // max. number of bytes in sense data

typedef struct tag_IMAPIDRV_SRB
{
    USHORT Version;
    UCHAR Function;
    UCHAR SrbStatus;

    UCHAR ScsiStatus;
    UCHAR CdbLength;
    UCHAR Reserved;
    UCHAR Reserved1;
    
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG SrbFlags;
    PVOID DataBuffer;    
    UCHAR Cdb[16];

    UCHAR SenseInfoBuffer[MAX_SENSE_BYTES];
}
IMAPIDRV_SRB, *PIMAPIDRV_SRB;

/*
** IMAPISRB Functions - Subset of NT SCSI_REQUEST_BLOCK functions.
*/

#define IMAPISRB_FUNCTION_EXECUTE_SCSI          0x00
#define IMAPISRB_FUNCTION_FLUSH                 0x08
#define IMAPISRB_FUNCTION_ABORT_COMMAND         0x10
#define IMAPISRB_FUNCTION_RESET_BUS             0x12
#define IMAPISRB_FUNCTION_RESET_DEVICE          0x13

/*
** IMAPISRB Status Codes - Same as NT SCSI_REQUEST_BLOCK codes.
*/

#define IMAPISRB_STATUS_PENDING                 0x00
#define IMAPISRB_STATUS_SUCCESS                 0x01
#define IMAPISRB_STATUS_ABORTED                 0x02
#define IMAPISRB_STATUS_ABORT_FAILED            0x03
#define IMAPISRB_STATUS_ERROR                   0x04
#define IMAPISRB_STATUS_BUSY                    0x05
#define IMAPISRB_STATUS_INVALID_REQUEST         0x06
#define IMAPISRB_STATUS_INVALID_PATH_ID         0x07
#define IMAPISRB_STATUS_NO_DEVICE               0x08
#define IMAPISRB_STATUS_TIMEOUT                 0x09
#define IMAPISRB_STATUS_SELECTION_TIMEOUT       0x0A
#define IMAPISRB_STATUS_COMMAND_TIMEOUT         0x0B
#define IMAPISRB_STATUS_MESSAGE_REJECTED        0x0D
#define IMAPISRB_STATUS_BUS_RESET               0x0E
#define IMAPISRB_STATUS_PARITY_ERROR            0x0F
#define IMAPISRB_STATUS_REQUEST_SENSE_FAILED    0x10
#define IMAPISRB_STATUS_NO_HBA                  0x11
#define IMAPISRB_STATUS_DATA_OVERRUN            0x12
#define IMAPISRB_STATUS_UNEXPECTED_BUS_FREE     0x13
#define IMAPISRB_STATUS_PHASE_SEQUENCE_FAILURE  0x14
#define IMAPISRB_STATUS_BAD_SRB_BLOCK_LENGTH    0x15
#define IMAPISRB_STATUS_REQUEST_FLUSHED         0x16
#define IMAPISRB_STATUS_INVALID_LUN             0x20
#define IMAPISRB_STATUS_INVALID_TARGET_ID       0x21
#define IMAPISRB_STATUS_BAD_FUNCTION            0x22
#define IMAPISRB_STATUS_ERROR_RECOVERY          0x23
#define IMAPISRB_STATUS_NOT_POWERED             0x24

/*
** IMAPISRB Status Masks
*/

#define IMAPISRB_STATUS_QUEUE_FROZEN            0x40
#define IMAPISRB_STATUS_AUTOSENSE_VALID         0x80
#define IMAPISRB_STATUS(Status) (Status & ~(IMAPISRB_STATUS_AUTOSENSE_VALID | IMAPISRB_STATUS_QUEUE_FROZEN))


/*
** SCSI Status values 
*/

#define IMAPISRB_SCSISTATUS_GOOD                    0x00
#define IMAPISRB_SCSISTATUS_CHECK_CONDITION         0x02
#define IMAPISRB_SCSISTATUS_BUSY                    0x08
#define IMAPISRB_SCSISTATUS_INTERMEDIATE            0x10
#define IMAPISRB_SCSISTATUS_RESERVATION_CONFLICT    0x18 // used if another app already opened the device exclusive
#define IMAPISRB_SCSISTATUS_QUEUE_FULL              0x28

/*
** IMAPISRB Flag Bits - Subset of NT SCSI_REQUEST_BLOCK flag bits.
*/

#define SRB_FLAGS_DATA_IN                       0x00000040
#define SRB_FLAGS_DATA_OUT                      0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER              0x00000000

/*
** ----------------------------------------------------------------------------
** IOCTL_IMAPIDRV_CLOSE
** ----------------------------------------------------------------------------
*/

#define IOCTL_IMAPIDRV_CLOSE ((ULONG)CTL_CODE(FILE_DEVICE_IMAPI,0x840,METHOD_BUFFERED,FILE_ANY_ACCESS))

/*
** ----------------------------------------------------------------------------
** IOCTL_IMAPIDRV_PNPEVENT
** ----------------------------------------------------------------------------
*/

#define IOCTL_IMAPIDRV_PNPEVENT ((ULONG)CTL_CODE(FILE_DEVICE_IMAPI,0x860,METHOD_BUFFERED,FILE_ANY_ACCESS))


/*
** ----------------------------------------------------------------------------
** IOCTL_IMAPIDRV_CLEAR_PNPEVENT
** ----------------------------------------------------------------------------
*/

#define IOCTL_IMAPIDRV_CLEAR_PNPEVENT ((ULONG)CTL_CODE(FILE_DEVICE_IMAPI,0x870,METHOD_BUFFERED,FILE_ANY_ACCESS))

#ifdef __cplusplus
}
#endif

#endif //__IMAPIPUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\imapi\imapiregistry.h ===
/******************************************************************************
**
** Copyright 1998 Adaptec, Inc.,  All Rights Reserved.
**
** This software contains the valuable trade secrets of Adaptec.  The
** software is protected under copyright laws as an unpublished work of
** Adaptec.  Notice is for informational purposes only and does not imply
** publication.  The user of this software may make copies of the software
** for use with parts manufactured by Adaptec or under license from Adaptec
** and for no other use.
**
******************************************************************************/

/******************************************************************************
**
**  Module Name:    ImapiRegisty.h
**
******************************************************************************/

#ifndef _IMAPIREGISTRY_H_
#define _IMAPIREGISTRY_H_

#define IMAPI_PRODUCT_REGPATH       "Software\\Microsoft\\IMAPI"
#define IMAPI_REGKEY_STASHFILE      "\\StashInfo"

#define IMAPI_REGVAL_NEWPATH        "StashNewPath"
#define IMAPI_REGVAL_PATH           "StashPath"
#define IMAPI_REGVAL_STASHSIZE      "StashSize"
#define IMAPI_REGVAL_STASHAUTO      "Automatic"
#define IMAPI_REGVAL_DELETEONCLOSE  "DeleteOnClose"

#endif //_IMAPIREGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\imapi\burnv.h ===
/******************************************************************************
**
** Copyright 1999 Adaptec, Inc.,  All Rights Reserved.
**
** This software contains the valuable trade secrets of Adaptec.  The
** software is protected under copyright laws as an unpublished work of
** Adaptec.  Notice is for informational purposes only and does not imply
** publication.  The user of this software may make copies of the software
** for use with parts manufactured by Adaptec or under license from Adaptec
** and for no other use.
**
******************************************************************************/

/******************************************************************************
**
**  Module Name:    BurnV.h
**
******************************************************************************/

#ifndef _BURNV_H_
#define _BURNV_H_

/*
** Make sure structures are byte aligned and fields are undecorated.
*/

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


#include "ImapiPub.h"
#include "ScsiThings.h"


/*
 * Constant declarations.
 */
#define PHOENIX_WRITER_DECLSPEC

#define BURNENGV_CDB_BYTES                                  16
#define BURNENG_ERROR_INFO_DATABYTES                        32
#define BURNENG_ERROR_INFO_SENSEBYTES                       14
#define BURNENG_ERROR_INFO_PRIVATEBYTES                     32

/*
** Make sure we have the stuff we need to declare IOCTLs.  The device code
** is below, and then each of the IOCTLs is defined alone with its constants
** and structures below.
*/

#ifndef CTL_CODE

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

#define METHOD_BUFFERED         0
#define METHOD_IN_DIRECT        1
#define METHOD_OUT_DIRECT       2
#define METHOD_NEITHER          3

#define FILE_ANY_ACCESS         0
#define FILE_SPECIAL_ACCESS     (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS        ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS       ( 0x0002 )    // file & pipe

#endif

/*
 * Typedefs.
 */

typedef enum {
    eWriterErrorNone = 0,
    eWriterBurnStarted,
    eWriterBurnengError,
    eWriterDeviceUnsupported,
    eWriterImapiFailure,
    eWriterMediaNonerasable,
    eWriterMediaNotPresent,
    eWriterMediaNonwritable,
    eWriterTargetScsiError,
    eWriterTargetUnknownResponseTIB,
    eWin32Error,
    eWin32OverlappedError,
    eWriterAlloc,
    eWriterBufferSize,
    eWriterIntFnTab,
    eWriterIntImapi,
    eWriterIntList,
    eWriterInvalidData,
    eWriterBadHandle,
    eWriterInvalidParam,
    eWriterBurnError,
    eWriterGenFailure,
    eWriterRegistryError,
    eWriterStashFileOpen,
    eWriterBadSectionClose,
    eWriterPrematureTermination,
    eWriterWriteError,
    eWriterReadFileError,
    eWriterThreadCreationError,
    eWriterLossOfStreaming,
    eWriterClosingSession,
    eWriterWriteProtectedMedia,
    eWriterUnableToWriteToMedia,
    eWriterErrorMAX
} WRITER_ERROR_TYPE, *PWRITER_ERROR_TYPE;

typedef struct {
    WRITER_ERROR_TYPE   dwBurnEngineError;

    IMAPIDRV_SRB        srbErrored;

    UCHAR               ucaDataBuffer[ BURNENG_ERROR_INFO_DATABYTES ];
    ULONGLONG           Reserved1; // alignment
    UCHAR               ucaSenseInfoBuffer[ BURNENG_ERROR_INFO_SENSEBYTES ] ;
    ULONGLONG           Reserved2; // alignment
    UCHAR               ucaPrivateBuffer[ BURNENG_ERROR_INFO_PRIVATEBYTES ];
} BURNENG_ERROR_STATUS, *PBURNENG_ERROR_STATUS;

/*
typedef struct {
    DWORD   dwWriteSpeed;
    DWORD   dwAudioGapSize;
    DWORD   dwaReserved[ 3 ];
} WRITERV_SETTABLE_PROPERTIES, *PWRITERV_SETTABLE_PROPERTIES;
*/
typedef enum {
    eOrderMethodMotorola = 1,
    eOrderMethodMAX
} BURNENGV_AUDIO_BYTE_ORDERING_METHOD, *PBURNENGV_AUDIO_BYTE_ORDERING_METHOD;

typedef struct _tag_WriteParameters
{
    DWORD       dwByteReorderingMethod;
    DWORD       dwaReserved1[2];

    BYTE        bySectionCloseCDBLen;
    BYTE        bySectionCloseCDBAcceptErrorSenseKey;
    BYTE        bySectionCloseCDBAcceptErrorASC;
    BYTE        byWriteCDBLen;
    BYTE        byaReserved3[2];

    BYTE        byaSectionCloseCDB[BURNENGV_CDB_BYTES];
    BYTE        byaWriteCDB[BURNENGV_CDB_BYTES];
} BURNENGV_WRITE_PARAMETERS, *PBURNENGV_WRITE_PARAMETERS;

typedef struct _tag_ScsiInfo
{
    UCHAR                       SrbStatus;
    SCSI_SENSE_DATA             scsiSenseData;
} BURNENGV_IMAPI_SCSI_INFO, *PBURNENGV_IMAPI_SCSI_INFO;

typedef union _tag_ErrorExtraInfo
{
    DWORD                       dwWin32Error;
    BURNENGV_IMAPI_SCSI_INFO    imapiScsiError;
    BURNENG_ERROR_STATUS        engErrorStatus;
} BURNENGV_ERROR_EXTRA_INFO, *PBURNENGV_ERROR_EXTRA_INFO;

typedef struct _tag_ErrorInfo
{
    DWORD                       errorType;
    BURNENGV_ERROR_EXTRA_INFO   info;
} WRITER_ERROR_INFO, *PWRITER_ERROR_INFO;

typedef enum
{
    evBurnProgressNoError = 0,
    evBurnProgressNotStarted,
    evBurnProgressBurning,
    evBurnProgressComplete,
    evBurnProgressError,
    evBurnProgressLossOfStreamingError,
    evBurnProgressMediaWriteProtect,   // i.e. 8/10X RW media in a 4X RW drive
    evBurnProgressUnableToWriteToMedia,
    evBurnProgressBadHandle
} BURNENGV_PROGRESS_STATUS, *PBURNENGV_PROGRESS_STATUS;

/*
** Restore compiler default packing and close off the C declarations.
*/

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //_BURNV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\imapi\mmcthings.h ===
/****************************************************************************
**
** Copyright 1999 Adaptec, Inc.,  All Rights Reserved.
**
** This software contains the valuable trade secrets of Adaptec.  The
** software is protected under copyright laws as an unpublished work of
** Adaptec.  Notice is for informational purposes only and does not imply
** publication.  The user of this software may make copies of the software
** for use with parts manufactured by Adaptec or under license from Adaptec
** and for no other use.
**
****************************************************************************/

/****************************************************************************
**
**  Module Name:    MmcThings.h
**
**  Description:    MMC Structures and OpCodes
**
**  Programmers:    Daniel Evers (dle)
**                  Tom Halloran (tgh)
**                  Don Lilly (drl)
**                  Daniel Polfer (dap)
**
**  History:        8/18/99 (dap)  Opened history and added header.
**
**  Notes:          This file created using 4 spaces per tab.
**
****************************************************************************/

#ifndef __MMCTHINGS_H__
#define __MMCTHINGS_H__


#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#define MMC_CDR_1X_SPEED_KB             176

    // MMC SCSI Opcodes
#define MMC_CDBOPCODE_BLANK                 0xa1
#define MMC_CDBLENGTH_BLANK                 12
#define MMC_CDBOPCODE_CLOSE_TRACK_SESSION   0x5b
#define MMC_CDBLENGTH_CLOSE_TRACK_SESSION   10
#define MMC_CDBOPCODE_PREVENTALLOWREMOVAL   0x1e
#define MMC_CDBLENGTH_PREVENTALLOWREMOVAL   6       // drl - this is the length for the hp9200
#define MMC_CDBOPCODE_READ_DISC_INFO        0x51
#define MMC_CDBLENGTH_READ_DISC_INFO        10
#define MMC_CDBOPCODE_READ_TRACK_INFO       0x52
#define MMC_CDBLENGTH_READ_TRACK_INFO       10
#define MMC_CDBOPCODE_SETCDSPEED            0xbb
#define MMC_CDBLENGTH_SETCDSPEED            12      // drl - this is the length for the hp9200
#define MMC_CDBOPCODE_STARTSTOPUNIT         0x1b
#define MMC_CDBLENGTH_STARTSTOPUNIT         6       // drl - this is the length for the hp9200
#define MMC_CDBOPCODE_SYNCHRONIZE_CACHE     0x35
#define MMC_CDBLENGTH_SYNCHRONIZE_CACHE     10
#define MMC_CDBOPCODE_WRITE                 0x2a
#define MMC_CDBLENGTH_WRITE                 10
#define MMC_CDBOPCODE_READ                  0x28
#define MMC_CDBLENGTH_READ                  10

#define MMC_CDB_BLANK_BLANKINGTYPE_FULL     0x00
#define MMC_CDB_BLANK_BLANKINGTYPE_MINIMAL  0x01

    // MMC Structs
#define MMC_CLOSE_TRACK_SESSION_FLAG_SESSION    0x02
#define MMC_CLOSE_TRACK_SESSION_FLAG_TRACK      0x01
#define MMC_CLOSE_TRACK_SESSION_FLAG_IMMED      0x01

#define MMC_DISC_INFO_DISC_STATUS_EMPTY             0x00
#define MMC_DISC_INFO_DISC_STATUS_INCOMPLETE        0x01
#define MMC_DISC_INFO_DISC_STATUS_COMPLETE          0x02
#define MMC_DISC_INFO_DISC_STATUS_MASK              0x03
#define MMC_DISC_INFO_LAST_SESSION_STATE_EMPTY      0x00
#define MMC_DISC_INFO_LAST_SESSION_STATE_INCOMPLETE 0x04
#define MMC_DISC_INFO_LAST_SESSION_STATE_COMPLETE   0x0c
#define MMC_DISC_INFO_LAST_SESSION_STATE_MASK       0x0c
#define MMC_DISC_INFO_ERASEABLE_MASK                0x10
#define MMC_DISC_INFO_DISC_TYPE_CDDA_CDROM          0x00
#define MMC_DISC_INFO_DISC_TYPE_CD_I                0x10
#define MMC_DISC_INFO_DISC_TYPE_CDROM_XA            0x20
#define MMC_DISC_INFO_DISC_TYPE_UNDEFINED           0xff

#pragma pack(push,1)
typedef struct {
    BYTE    byDataLengthHi;
    BYTE    byDataLengthLo;
    BYTE    byDiscStatus;
    BYTE    byFirstTrackNumber;
    BYTE    bySessionCount;
    BYTE    byFirstTrackInLastSession;
    BYTE    byLastTrackInLastSession;
    BYTE    byDIDVDBCVURU;

    BYTE    byDiscType;
    BYTE    byaReserved0[ 3 ];
    BYTE    byaDiscId[ 4 ];

    BYTE    byaLastSessionLeadInStartTimeMSF[ 4 ];
    BYTE    byaLastPossStartTimeforLeadOutMSF[ 4 ];

    BYTE    byaDiscBarcode[ 8 ];

    BYTE    byReserved1;
    BYTE    byOpcTableEntriesCount;
    BYTE    byaOPCTableEntries[ 100 ];
} MMC_DISC_INFO_BLOCK, *PMMC_DISC_INFO_BLOCK;
#pragma pack(pop)


//#define MMC_EXPECTED_RT_BLANK_PACKET_FP_DATAMODE_AUDIO    0x4f
#define MMC_EXPECTED_RT_BLANK_PACKET_FP_DATAMODE_AUDIO  0x0f
#define MMC_EXPECTED_RT_BLANK_PACKET_FP_DATAMODE_MODE1  0x41
#define MMC_TIB_RT_BLANK_PACKET_FP_DATAMODE_RESERVEDTRACK   0x80
#define MMC_TIB_RT_BLANK_PACKET_FP_DATAMODE_BLANK           0x40
#define MMC_TIB_RT_BLANK_PACKET_FP_DATAMODE_PACKET          0x20
#define MMC_TIB_RT_BLANK_PACKET_FP_DATAMODE_FIXEDPACKET     0x10
#define MMC_TIB_RT_BLANK_PACKET_FP_DATAMODE_MODE1           0x01
#define MMC_TIB_RT_BLANK_PACKET_FP_DATAMODE_MODE2           0x02
#define MMC_TIB_RT_BLANK_PACKET_FP_DATAMODE_UNKNOWN         0x0f

#pragma pack(push,1)
typedef struct {
    BYTE    byaDataLength[ 2 ];
    BYTE    byTrackNumber;
    BYTE    bySessionNumber;
    BYTE    byReserved0;
    BYTE    byDamage_Copy_TrackMode;
    BYTE    byRT_Blank_Packet_FP_DataMode;
    BYTE    byNWA_V;

    BYTE    byaTrackStartAddress[ 4 ];
    BYTE    byaNextWritableAddress[ 4 ];

    BYTE    byaFreeBlocks[ 4 ];
    BYTE    byaFixedPacketSize[ 4 ];

    // tgh - the 9200 spec says that there is another field here: Track Length.
    BYTE    byaTrackLength[ 4 ];

} MMC_TRACK_INFO_BLOCK, *PMMC_TRACK_INFO_BLOCK;
#pragma pack(pop)


#define MMC_MODE_PAGE_CODE_WRITE_PARAMETERS 0x05
#define MMC_WP_TEST_WRITING_FLAG            0x10
#define MMC_WP_WRITE_TYPE_TRACK_AT_ONCE     0x01
#define MMC_WP_DATA_BLOCK_TYPE_RAW_DATA     0x00
#define MMC_WP_DATA_BLOCK_TYPE_MODE1        0x08
#define MMC_WP_DATA_BLOCK_TYPE_MODE2_FORM1  0x0A
#define MMC_WP_SESSION_FORMAT_CDDAorCDROM   0x00
#define MMC_WP_SESSION_FORMAT_CDROM_XA      0x20

#define MMC_SUBCHANNEL_Q_BIT_AUDIOPREEMPHASIS       0x01
#define MMC_SUBCHANNEL_Q_BIT_DIGITALCOPYPERMITTED   0x02
#define MMC_SUBCHANNEL_Q_BIT_AUDIOTRACK             0x00
#define MMC_SUBCHANNEL_Q_BIT_DATATRACK              0x04
#define MMC_SUBCHANNEL_Q_BIT_FOURCHANNELAUDIO       0x08

#pragma pack(push,1)
typedef struct {
    BYTE    byaModeDataLength[ 2 ];
    BYTE    byaMediumType;
    BYTE    byaReserved[ 3 ];
    BYTE    byaBlockDescriptorLength[ 2 ];
    BYTE    byaBlockDescriptor[ 8 ];
} MMC_MODE_PARAMETER_HEADER, *PMMC_MODE_PARAMETER_HEADER;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct {
    BYTE    byPageCode;         // 0x05
    BYTE    byPageLength;       // 0x32
//    BYTE    byTW_WriteType;
    BYTE    bfWriteType:4;
    BYTE    bfTestWrite:1;
    BYTE    bfLS_V:1;
    BYTE    bfBufferUnderrunFree:1;
    BYTE    bfreserved1:1;
//    BYTE    byMS_FP_Copy_TrackMode;
    BYTE    bfTrackMode:4;
    BYTE    bfCopyRight:1;
    BYTE    bfFixedPacket:1;
    BYTE    bfMultiSession:2;
//    BYTE    byDataBlockType;
    BYTE    bfDataBlockType:4;
    BYTE    bfreserved2:4;

    BYTE    byLinkSize;
    BYTE    byreserved3;
    BYTE    bfHostApplicationCode:6;
    BYTE    bfreserved4:2;
    BYTE    bySessionFormat;
    BYTE    byreserved5;
    BYTE    byaPacketSize[ 4 ];
    BYTE    byaAudioPauseLength[ 2 ];

    BYTE    byMCVAL;
    BYTE    byaN1thruN13[ 13 ];
    BYTE    byZero1;
    BYTE    byAframe1;

    BYTE    byTCVAL;
    BYTE    byI1CountryCode;
    BYTE    byI2A_Z;
    BYTE    byI3OwnerCode;
    BYTE    byI4;
    BYTE    byI5A_Z_0_9;
    BYTE    byI6YearOfRecording;
    BYTE    byI7;
    BYTE    byI8SerialNumber;
    BYTE    byI9;
    BYTE    byI10;
    BYTE    byI11;
    BYTE    byI12;
    BYTE    byZero2;
    BYTE    byAframe2;
    BYTE    byReserved2;

    BYTE    byaSubheader[ 4 ];

    //BYTE    byaAdditionalLength[ 80 ];
} MMC_MODE_PAGE_WRITE_PARAMETERS, *PMMC_MODE_PAGE_WRITE_PARAMETERS;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct {
    MMC_MODE_PARAMETER_HEADER       header;
    MMC_MODE_PAGE_WRITE_PARAMETERS  page;
} MMC_MODE_WRITE_PARAMETERS, *PMMC_MODE_WRITE_PARAMETERS;
#pragma pack(pop)


#define MMC_MODE_PAGE_CODE_CAPABILITIES_PARAMETERS 0x2A

#pragma pack(push,1)
typedef struct {
    BYTE    byPageCode;   // 0x2a       
    BYTE    byPageLength; // 0x18
    BYTE    byReadType;
    BYTE    byWriterType;
    BYTE    byMultiSession              : 7;
    BYTE    bfBufferUnderrunFreeCapable : 1;
    BYTE    byReadBarCode;
    BYTE    byEjectLock;
    BYTE    byLeadIn;
    BYTE    byMaxReadSpeed[2];
    BYTE    byVolumeLevels[2];
    BYTE    byBufferSizeSupported[2];
    BYTE    byCurrentReadSpeed[2];

    BYTE    byReserved[2];

    BYTE    byMaxWriteSpeed[2];
    BYTE    byCurrentWriteSpeed[2];
    BYTE    byManagement[2];

    BYTE    byReserved2[2];
} MMC_MODE_PAGE_CAPABILITY_PARAMETERS, *PMMC_MODE_PAGE_CAPABILITY_PARAMETERS;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct {
    MMC_MODE_PARAMETER_HEADER       header;
    MMC_MODE_PAGE_CAPABILITY_PARAMETERS page;
} MMC_MODE_CAPABILITY_PARAMETERS, *PMMC_MODE_CAPABILITY_PARAMETERS;
#pragma pack(pop)



#ifdef __cplusplus
}
#endif //__cplusplus



#endif //__MMCTHINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\imapi\scsithings.h ===
/******************************************************************************
**
**  Module Name:    ScsiThings.h
**
**  Notes:          This file created using 4 spaces per tab.
**
******************************************************************************/

#ifndef __SCSITHINGS_H__
#define __SCSITHINGS_H__

/*
** Make sure structures are packed and undecorated.
*/

#ifdef _MSC_VER
#pragma pack(push,1)
#endif //__MSC_VER

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus


    // SCSI CDB Opcodes.
#define SCSI_CMD_INQUIRY                            0x12
#define SCSI_CMD_INQUIRY_LENGTH                     6
#define SCSI_CMD_MODE_SELECT10                      0x55
#define SCSI_CMD_MODE_SELECT10_LENGTH               10
#define SCSI_CMD_MODE_SENSE10                       0x5a
#define SCSI_CMD_MODE_SENSE10_LENGTH                10
#define SCSI_CMD_PREVENT_ALLOW_MEDIUM_REM           0x1e
#define SCSI_CMD_PREVENT_ALLOW_MEDIUM_REM_LENGTH    6
#define SCSI_CMD_TUR                            0x00
#define SCSI_CMD_LENGTH_TUR                     6

// Ricoh CDB Opcodes.
#define SCSI_RICOH_CDBOPCODE_FLUSH_CACHE            0x35
#define SCSI_RICOH_CDBLENGTH_FLUSH_CACHE            10
#define SCSI_RICOH_CDBOPCODE_GETNEXTADDRESS         0xe2
#define SCSI_RICOH_CDBLENGTH_GETNEXTADDRESS         10
#define SCSI_RICOH_CDBOPCODE_READ_TRACK_INFO        0xe5
#define SCSI_RICOH_CDBLENGTH_READ_TRACK_INFO        10
#define SCSI_RICOH_CDBOPCODE_WRITE_TRACK            0xe6
#define SCSI_RICOH_CDBLENGTH_WRITE_TRACK            10
#define SCSI_RICOH_CDBOPCODE_FIXATION               0xe9
#define SCSI_RICOH_CDBLENGTH_FIXATION               10
// End Ricoh


    // SCSI Sense Keys
#define SCSI_SENSEKEY_NOTREADY          0x02
#define SCSI_SENSEKEY_MEDIUM_ERROR      0x03
#define SCSI_SENSEKEY_HARDWARE_ERROR    0x04
#define SCSI_SENSEKEY_ILLEGALREQUEST    0x05
#define SCSI_SENSEKEY_UNITATTENTION     0x06

    // SCSI Additional Sense Codes
#define SCSI_ASC_COMMUNICATIONFAILURE   0x08
#define SCSI_ASC_WRITEERROR             0x0c
#define SCSI_ASC_PARAMETERLISTLENGTH    0x1a
#define SCSI_ASC_INVALIDOPCODE          0x20
#define SCSI_ASC_LBAOUTOFRANGE          0x21
#define SCSI_ASC_INVALIDFIELDCDB        0x24
#define SCSI_ASC_INVALIDFIELDPARAMLIST  0x26
#define SCSI_ASC_PARAMETERSCHANGED      0x2a
#define SCSI_ASC_MEDIUMNOTPRESENT       0x3a
#define SCSI_ASC_DUMMYBLOCKSADDED       0xb5
#define SCSI_ASC_ILLEGALMODEFORTRACK    0x64

    // SCSI Data structs.
#define SCSI_INQUIRY_RMB            0x80
#define SCSI_DEVICE_TYPE_WORM       0x04
#define SCSI_DEVICE_TYPE_CDROM      0x05

    // Other things
#define SCSI_MODE_SENSE_PAGE_CODE_MASK  0x3f


// Ricoh things.
#define SCSI_RICOH_TRACK_INFO_TRACK_STATUS_MASK         0xf0
#define SCSI_RICOH_TRACK_INFO_TRACK_STATUS_UNKNOWN      0x40
#define SCSI_RICOH_TRACK_INFO_TRACK_MODE_MASK           0x0f
#define SCSI_RICOH_TRACK_INFO_TRACK_MODE_AUDIO_WITHOUT  0x00
#define SCSI_RICOH_TRACK_INFO_TRACK_MODE_AUDIO_WITH     0x01
#define SCSI_RICOH_TRACK_INFO_TRACK_MODE_DATA_UNINT     0x04
#define SCSI_RICOH_TRACK_INFO_TRACK_MODE_DATA_INT       0x05
#define SCSI_RICOH_TRACK_INFO_INCREMENTAL_MASK          0xf0
#define SCSI_RICOH_TRACK_INFO_INCREMENTAL_NOTNOTNONOT   0x00
#define SCSI_RICOH_TRACK_INFO_DATA_MODE_MASK            0x0f
#define SCSI_RICOH_TRACK_INFO_DATA_MODE_UNKNOWN         0x0f
#define SCSI_RICOH_TRACK_INFO_DATA_MODE_YELLOWBOOK      0x01
#define SCSI_RICOH_TRACK_INFO_DATA_MODE_YELLOWBOOK_F1F2 0x02

#define SCSI_RICOH_MODE_PAGE_CODE_WRITE                 0x21
#define SCSI_RICOH_MEDIUM_TYPE_PRESENT                  0x80
#define SCSI_RICOH_MEDIUM_TYPE_SIZE_120MM               0x20
#define SCSI_RICOH_MEDIUM_TYPE_WRITE_ENABLE             0x08
#define SCSI_RICOH_MEDIUM_TYPE_AUDIO_EXIST              0x04
#define SCSI_RICOH_MODE_PAGE_WRITE_COPY                 0x20
#define SCSI_RICOH_MODE_PAGE_WRITE_AUDIO                0x04
#define SCSI_RICOH_MODE_PAGE_WRITE_MODE_MODE1           0x01
#define SCSI_RICOH_MODE_PAGE_CODE_SPEED                 0x31
#define SCSI_RICOH_MODE_PAGE_SPEED_SPEEDMASK            0xf0
#define SCSI_RICOH_MODE_PAGE_SPEED_TEST_WRITING_FLAG    0x01

#define SCSI_RICOH_FIXATION_FLAG_IMMED                  0x01
#define SCSI_RICOH_FIXATION_TOCTYPE_CDROM               0x01
#define SCSI_RICOH_FIXATION_TOCTYPE_CDDA                0x00
// End Ricoh


typedef struct {
    BYTE    byPeripheralDeviceType;
    BYTE    byDeviceTypeModifier;       // 01
    BYTE    byVersionISOECMAANSI;       // 02
    BYTE    byResponseDataFormat;       // 03
    BYTE    byAdditionalLength;         // 04
    BYTE    byaReserved0[ 3 ];          // 05
    BYTE    byaVendorID[ 8 ];           // 08
    BYTE    byaProductID[ 16 ];         // 10
    BYTE    byaProductRevision[ 4 ];    // 20
    //BYTE  byaReserved1[ 210 ];        // 24
} SCSI_INQUIRY, *PSCSI_INQUIRY;

typedef struct {
    BYTE    byError;
    BYTE    bySegment;                  // 01
    BYTE    bySenseKey;                 // 02
    BYTE    byaInfo[ 4 ];               // 03
    BYTE    byAdditionalSenseLength;    // 07
    BYTE    byaCommandSpecific[ 4 ];    // 08
    BYTE    byASC;                      // 0c
    BYTE    byASCQ;                     // 0d
    //BYTE  byFieldReplacable;          // 0e
    //BYTE  byaSenseKeySpecific[ 3 ];
    //BYTE  byaAdditionalBytes[ 220 ];
} SCSI_SENSE_DATA, *PSCSI_SENSE_DATA;


// Begin Ricoh drive specific things.
typedef struct {
    BYTE    byBufferLength;
    BYTE    byNumberOfTracks;

    BYTE    byaStartAddress[ 4 ];
    BYTE    byaTrackLength[ 4 ];

    BYTE    byTrackStatusMode;
    BYTE    byIncrementalDataMode;

    BYTE    byaFreeBlocks[ 4 ];
    BYTE    byaFixedPacketSize[ 4 ];
} SCSI_RICOH_TRACK_INFO_BLOCK, *PSCSI_RICOH_TRACK_INFO_BLOCK;

typedef struct {
        // Header
    BYTE    byaModeDataLength[ 2 ];
    BYTE    byMediumType;
    BYTE    byaReserved[ 3 ];
    BYTE    byaBlockDescLen[ 2 ];

        // Block Descriptor
    BYTE    byDensityCode;
    BYTE    byaNumberOfBlocks[ 3 ];
    BYTE    byReserved2;
    BYTE    byaBlockSize[ 3 ];

        // Write Page
    BYTE    byPageCode;         // x21
    BYTE    byParameterLength;  // x0e
    BYTE    byReserved3;
    BYTE    byCopyAudioMode;
    BYTE    byTrackNumber;
    BYTE    byaISRC[ 9 ];
    BYTE    byaReserved4[ 2 ];
} SCSI_RICOH_MODE_PAGE_WRITE, *PSCSI_RICOH_MODE_PAGE_WRITE;

typedef struct {
        // Header
    BYTE    byaModeDataLength[ 2 ];
    BYTE    byMediumType;
    BYTE    byaReserved[ 3 ];
    BYTE    byaBlockDescLen[ 2 ];

        // Block Descriptor
    BYTE    byDensityCode;
    BYTE    byaNumberOfBlocks[ 3 ];
    BYTE    byReserved2;
    BYTE    byaBlockSize[ 3 ];

        // Speed page
    BYTE    byPageCode;         // x31
    BYTE    byParameterLength;  // x02
    BYTE    byReserved5;
    BYTE    bySpeedSelectEmulation;
} SCSI_RICOH_MODE_PAGE_SPEED, *PSCSI_RICOH_MODE_PAGE_SPEED;

typedef struct {
    BYTE    byDataBlockLength;
    BYTE    byaLogicalBlockAddress[ 4 ];
    BYTE    byReserved;
} SCSI_RICOH_NEXT_WRITABLE_ADDRESS, *PSCSI_RICOH_NEXT_WRITABLE_ADDRESS;
// End Ricoh


    // Macros
#define SCSI_TRIPLE( HA, ID, LUN )      (DWORD)( (( (DWORD)HA << 24 ) & 0xff000000 ) + \
                                                (( (DWORD)ID << 16 ) & 0x00ff0000 ) + \
                                                (( (DWORD)LUN << 8 ) & 0x0000ff00 ))
#define SCSI_TRIPLE_TO_HA( Triple )     (BYTE)(( (DWORD)Triple >> 24 ) & 0x000000ff )
#define SCSI_TRIPLE_TO_ID( Triple )     (BYTE)(( (DWORD)Triple >> 16 ) & 0x000000ff )
#define SCSI_TRIPLE_TO_LUN( Triple )    (BYTE)(( (DWORD)Triple >> 8 ) & 0x000000ff )


/*
** Restore compiler default packing and close off the C declarations.
*/

#ifdef __cplusplus
}
#endif //__cplusplus

#ifdef _MSC_VER
#pragma pack(pop)
#endif //_MSC_VER



#endif //__SCSITHINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\cdtapi.h ===
/*************************************************************************
*
* cdtapi.h
*
* Contains structures and declarations for the TAPI-based Connection Driver
*
* Copyright Microsoft Corporation, 1998
*
*  
***************************************************************************/

#ifndef sdkinc_cdtapi_h
#define sdkinc_cdtapi_h

/*
 *  TAPI Create Endpoint Structure
 */
typedef struct _ICA_STACK_TAPI_ENDPOINT {
    HANDLE hDevice;             // Comm port device handle
    HANDLE hDiscEvent;          // Disconnect event handle
    ULONG fCallback : 1;        // Set if the ENDPOINT created due to callback
} ICA_STACK_TAPI_ENDPOINT, *PICA_STACK_TAPI_ENDPOINT;

#endif // sdkinc_cdtapi_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\allproc.h ===
//NBD
#ifndef TS_ALLPROC_ALREADY_SET
#define TS_ALLPROC_ALREADY_SET

    //
    //  No longer available in the Windows 2000 include files (but I need it to be able to 
    //  access to Hydra 4 servers).
    //  This has no direct link with GetAllProcesses, but it is very convenient to put it here, 
    //  because apps calling GetAllProcesses will probably care about Hydra 4 compatibility.
    //
#define CITRIX_PROCESS_INFO_MAGIC  0x23495452

    typedef struct _CITRIX_PROCESS_INFORMATION {
        ULONG MagicNumber;
        ULONG LogonId;
        PVOID ProcessSid;
        ULONG Pad;
    } CITRIX_PROCESS_INFORMATION, * PCITRIX_PROCESS_INFORMATION;

    // sizes of TS4.0 structures (size has changed in Windows 2000)
#define SIZEOF_TS4_SYSTEM_THREAD_INFORMATION 64
#define SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION 136


#define GAP_LEVEL_BASIC 0

    typedef struct _TS_UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
#ifdef MIDL_PASS
		[size_is(MaximumLength),length_is(Length)]PWSTR  Buffer;
#else
        PWSTR  Buffer;
#endif
    } TS_UNICODE_STRING;


    // CAUTION:
    // TS_SYS_PROCESS_INFO is duplicated from ntexapi.h, and slightly modified.
    // (not nice, but necessary because the Midl compiler doesn't like PVOID !)

    typedef struct _TS_SYS_PROCESS_INFORMATION {
        ULONG NextEntryOffset;
        ULONG NumberOfThreads;
        LARGE_INTEGER SpareLi1;
        LARGE_INTEGER SpareLi2;
        LARGE_INTEGER SpareLi3;
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER KernelTime;
        TS_UNICODE_STRING ImageName;
        LONG BasePriority;                     // KPRIORITY in ntexapi.h
        DWORD UniqueProcessId;                 // HANDLE in ntexapi.h
        DWORD InheritedFromUniqueProcessId;    // HANDLE in ntexapi.h
        ULONG HandleCount;
        ULONG SessionId;
        ULONG SpareUl3;
        SIZE_T PeakVirtualSize;
        SIZE_T VirtualSize;
        ULONG PageFaultCount;
        ULONG PeakWorkingSetSize;
        ULONG WorkingSetSize;
        SIZE_T QuotaPeakPagedPoolUsage;
        SIZE_T QuotaPagedPoolUsage;
        SIZE_T QuotaPeakNonPagedPoolUsage;
        SIZE_T QuotaNonPagedPoolUsage;
        SIZE_T PagefileUsage;
        SIZE_T PeakPagefileUsage;
        SIZE_T PrivatePageCount;
    } 
    TS_SYS_PROCESS_INFORMATION, *PTS_SYS_PROCESS_INFORMATION;

typedef struct _TS_ALL_PROCESSES_INFO {
        PTS_SYS_PROCESS_INFORMATION     pTsProcessInfo;
        DWORD                           SizeOfSid;
#ifdef MIDL_PASS
        [size_is(SizeOfSid)] PBYTE      pSid;
#else
        PBYTE                           pSid;
#endif
    } 
    TS_ALL_PROCESSES_INFO, *PTS_ALL_PROCESSES_INFO;


	//=============================================================================================

	// The following structures are defined for taking care of interface change in the Whistler.

    typedef struct _NT6_TS_UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
#ifdef MIDL_PASS
	[size_is(MaximumLength / 2),length_is(Length / 2)]PWSTR  Buffer;
#else
        PWSTR  Buffer;
#endif
    } NT6_TS_UNICODE_STRING;


    typedef struct _TS_SYS_PROCESS_INFORMATION_NT6 {
        ULONG NextEntryOffset;
        ULONG NumberOfThreads;
        LARGE_INTEGER SpareLi1;
        LARGE_INTEGER SpareLi2;
        LARGE_INTEGER SpareLi3;
        LARGE_INTEGER CreateTime;
        LARGE_INTEGER UserTime;
        LARGE_INTEGER KernelTime;
        NT6_TS_UNICODE_STRING ImageName;
        LONG BasePriority;                     // KPRIORITY in ntexapi.h
        DWORD UniqueProcessId;                 // HANDLE in ntexapi.h
        DWORD InheritedFromUniqueProcessId;    // HANDLE in ntexapi.h
        ULONG HandleCount;
        ULONG SessionId;
        ULONG SpareUl3;
        SIZE_T PeakVirtualSize;
        SIZE_T VirtualSize;
        ULONG PageFaultCount;
        ULONG PeakWorkingSetSize;
        ULONG WorkingSetSize;
        SIZE_T QuotaPeakPagedPoolUsage;
        SIZE_T QuotaPagedPoolUsage;
        SIZE_T QuotaPeakNonPagedPoolUsage;
        SIZE_T QuotaNonPagedPoolUsage;
        SIZE_T PagefileUsage;
        SIZE_T PeakPagefileUsage;
        SIZE_T PrivatePageCount;
    } 
    TS_SYS_PROCESS_INFORMATION_NT6, *PTS_SYS_PROCESS_INFORMATION_NT6;

typedef struct _TS_ALL_PROCESSES_INFO_NT6 {
        PTS_SYS_PROCESS_INFORMATION_NT6 pTsProcessInfo;
        DWORD                           SizeOfSid;
#ifdef MIDL_PASS
        [size_is(SizeOfSid)] PBYTE      pSid;
#else
        PBYTE                           pSid;
#endif
    } 
    TS_ALL_PROCESSES_INFO_NT6, *PTS_ALL_PROCESSES_INFO_NT6;

    //=============================================================================================

//
// TermSrv Counter Header
// 
typedef struct _TS_COUNTER_HEADER {
    DWORD dwCounterID;     // identifies counter
    BOOLEAN bResult;       // result of operation performed on counter
} TS_COUNTER_HEADER, *PTS_COUNTER_HEADER;

typedef struct _TS_COUNTER {
    TS_COUNTER_HEADER counterHead; 
    DWORD             dwValue;      // returned value
    LARGE_INTEGER     startTime;    // start time for counter
} TS_COUNTER, *PTS_COUNTER;

#endif  //  TS_ALLPROC_ALREADY_SET

//NBD   end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\cchannel.h ===
/****************************************************************************/
/* Header:    cchannel.h                                                    */
/*                                                                          */
/* Purpose:   Virtual Channel Client API                                    */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#ifndef H_CCHANNEL
#define H_CCHANNEL

/****************************************************************************/
/* Include Virtual Channel Protocol header                                  */
/****************************************************************************/
#include <pchannel.h>

#ifdef _WIN32 
#define VCAPITYPE _stdcall
#define VCEXPORT
#else // _WIN32
#define VCAPITYPE CALLBACK
#define VCEXPORT  __export
#endif // _WIN32

/****************************************************************************/
/* Name: CHANNEL_INIT_EVENT_FN                                              */
/*                                                                          */
/* Purpose:                                                                 */
/*                                                                          */
/* This function is passed to MSTSC on VirtualChannelInit.  It is called by */
/* MSTSC to tell the application about interesting events.                  */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* none                                                                     */
/*                                                                          */
/* Params:                                                                  */
/*                                                                          */
/* - pInitHandle - a handle uniquely identifying this connection            */
/* - event - the event that has occurred - see CHANNEL_EVENT_XXX below      */
/* - pData - data associated with the event - see CHANNEL_EVENT_XXX below   */
/* - dataLength - length of the data.                                       */
/*                                                                          */
/****************************************************************************/
typedef VOID VCAPITYPE CHANNEL_INIT_EVENT_FN(LPVOID pInitHandle,
                                             UINT   event,
                                             LPVOID pData,
                                             UINT   dataLength);

typedef CHANNEL_INIT_EVENT_FN FAR * PCHANNEL_INIT_EVENT_FN;

typedef VOID VCAPITYPE CHANNEL_INIT_EVENT_EX_FN(LPVOID lpUserParam,
                                             LPVOID pInitHandle,
                                             UINT   event,
                                             LPVOID pData,
                                             UINT   dataLength);

typedef CHANNEL_INIT_EVENT_EX_FN FAR * PCHANNEL_INIT_EVENT_EX_FN;


/****************************************************************************/
/* Events passed to VirtualChannelInitEvent                                 */
/****************************************************************************/
/* Client initialized (no data)                                             */
#define CHANNEL_EVENT_INITIALIZED       0

/* Connection established (data = name of Server)                           */
#define CHANNEL_EVENT_CONNECTED         1

/* Connection established with old Server, so no channel support            */
#define CHANNEL_EVENT_V1_CONNECTED      2

/* Connection ended (no data)                                               */
#define CHANNEL_EVENT_DISCONNECTED      3

/* Client terminated (no data)                                              */
#define CHANNEL_EVENT_TERMINATED        4

/* Remote control is starting on this client                                */
#define CHANNEL_EVENT_REMOTE_CONTROL_START          5

/* Remote control is ending on this client                                  */
#define CHANNEL_EVENT_REMOTE_CONTROL_STOP           6

/****************************************************************************/
/* Name: CHANNEL_OPEN_EVENT_FN                                              */
/*                                                                          */
/* Purpose:                                                                 */
/*                                                                          */
/* This function is passed to MSTSC on VirtualChannelOpen.  It is called by */
/* MSTSC when data is available on the channel.                             */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* none                                                                     */
/*                                                                          */
/* Params:                                                                  */
/*                                                                          */
/* - openHandle - a handle uniquely identifying this channel                */
/* - event - event that has occurred - see CHANNEL_EVENT_XXX below          */
/* - pData - data received                                                  */
/* - dataLength - length of the data                                        */
/* - totalLength - total length of data written by the Server               */
/* - dataFlags - flags, zero, one or more of:                               */
/*   - 0x01 - beginning of data from a single write operation at the Server */
/*   - 0x02 - end of data from a single write operation at the Server.      */
/*                                                                          */
/****************************************************************************/
typedef VOID VCAPITYPE CHANNEL_OPEN_EVENT_FN(DWORD  openHandle,
                                             UINT   event,
                                             LPVOID pData,
                                             UINT32 dataLength,
                                             UINT32 totalLength,
                                             UINT32 dataFlags);

typedef CHANNEL_OPEN_EVENT_FN FAR * PCHANNEL_OPEN_EVENT_FN;

typedef VOID VCAPITYPE CHANNEL_OPEN_EVENT_EX_FN(LPVOID lpUserParam,
                                             DWORD  openHandle,
                                             UINT   event,
                                             LPVOID pData,
                                             UINT32 dataLength,
                                             UINT32 totalLength,
                                             UINT32 dataFlags);

typedef CHANNEL_OPEN_EVENT_EX_FN FAR * PCHANNEL_OPEN_EVENT_EX_FN;


/****************************************************************************/
/* Events passed to VirtualChannelOpenEvent                                 */
/****************************************************************************/
/* Data received from Server (data = incoming data)                         */
#define CHANNEL_EVENT_DATA_RECEIVED     10

/* VirtualChannelWrite completed (pData - pUserData passed on
   VirtualChannelWrite)                                                     */
#define CHANNEL_EVENT_WRITE_COMPLETE    11

/* VirtualChannelWrite cancelled (pData - pUserData passed on
   VirtualChannelWrite)                                                     */
#define CHANNEL_EVENT_WRITE_CANCELLED   12


/****************************************************************************/
/* Return codes from VirtualChannelXxx functions                            */
/****************************************************************************/
#define CHANNEL_RC_OK                             0
#define CHANNEL_RC_ALREADY_INITIALIZED            1
#define CHANNEL_RC_NOT_INITIALIZED                2
#define CHANNEL_RC_ALREADY_CONNECTED              3
#define CHANNEL_RC_NOT_CONNECTED                  4
#define CHANNEL_RC_TOO_MANY_CHANNELS              5
#define CHANNEL_RC_BAD_CHANNEL                    6
#define CHANNEL_RC_BAD_CHANNEL_HANDLE             7
#define CHANNEL_RC_NO_BUFFER                      8
#define CHANNEL_RC_BAD_INIT_HANDLE                9
#define CHANNEL_RC_NOT_OPEN                      10
#define CHANNEL_RC_BAD_PROC                      11
#define CHANNEL_RC_NO_MEMORY                     12
#define CHANNEL_RC_UNKNOWN_CHANNEL_NAME          13
#define CHANNEL_RC_ALREADY_OPEN                  14
#define CHANNEL_RC_NOT_IN_VIRTUALCHANNELENTRY    15
#define CHANNEL_RC_NULL_DATA                     16
#define CHANNEL_RC_ZERO_LENGTH                   17
#define CHANNEL_RC_INVALID_INSTANCE              18
#define CHANNEL_RC_UNSUPPORTED_VERSION           19

/****************************************************************************/
/* Levels of Virtual Channel Support                                        */
/****************************************************************************/
#define VIRTUAL_CHANNEL_VERSION_WIN2000         1

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
/****************************************************************************/
/* Name: VirtualChannelInit                                                 */
/*                                                                          */
/* Purpose:                                                                 */
/*                                                                          */
/* This function is called by the application to register the virtual       */
/* channels it wants to have access to.  Note that this does not open the   */
/* channels, merely reserves the names for use by this application.  This   */
/* function must be called before the Client connects to the Server, hence  */
/* it is recommended that it is called from the DLL's initialization        */
/* procedure.                                                               */
/*                                                                          */
/*                                                                          */
/* On_return, the channels requested have been registered.  However, other  */
/* MSTSC initialization may not yet have completed.  The application        */
/* receives a VirtualChannelInitEvent callback with the "Client             */
/* initialized" event when all MSTSC initialization is complete.            */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* CHANNEL_RC_OK                                                            */
/* CHANNEL_RC_ALREADY_INITIALIZED                                           */
/* CHANNEL_RC_ALREADY_CONNECTED                                             */
/* CHANNEL_RC_TOO_MANY_CHANNELS                                             */
/* CHANNEL_RC_NOT_IN_VIRTUALCHANNELENTRY                                    */
/*                                                                          */
/* Parameters                                                               */
/*                                                                          */
/* - ppInitHandle (returned) - handle to pass to subsequent                 */
/*                             VirtualChannelXxx calls                      */
/* - pChannel - list of names registered by this application                */
/* - channelCount - number of channels registered.                          */
/* - versionRequested - level of virtual channel support requested (one of  */
/*                      the VIRTUAL_CHANNEL_LEVEL_XXX parameters)           */
/* - pChannelInitEventProc - address of VirtualChannelInitEvent procedure   */
/*                                                                          */
/****************************************************************************/
typedef UINT VCAPITYPE VIRTUALCHANNELINIT(
                LPVOID FAR *           ppInitHandle,
                PCHANNEL_DEF           pChannel,
                INT                    channelCount,
                ULONG                  versionRequested,
                PCHANNEL_INIT_EVENT_FN pChannelInitEventProc);

typedef VIRTUALCHANNELINIT FAR * PVIRTUALCHANNELINIT;

/****************************************************************************/
/* Parameters for EX version                                                */
/*                                                                          */
/*  pUserParam              - user definded value that will be passed back  */
/*                            to addin in callbacks                         */
/*                                                                          */
/* - pInitHandle            - handle passed in in entry function            */
/* - pChannel - list of names registered by this application                */
/* - channelCount - number of channels registered.                          */
/* - versionRequested - level of virtual channel support requested (one of  */
/*                      the VIRTUAL_CHANNEL_LEVEL_XXX parameters)           */
/* - pChannelInitEventProc - address of VirtualChannelInitEvent procedure   */
/*                                                                          */
/****************************************************************************/

typedef UINT VCAPITYPE VIRTUALCHANNELINITEX(
                LPVOID                 lpUserParam,
                LPVOID                 pInitHandle,
                PCHANNEL_DEF           pChannel,
                INT                    channelCount,
                ULONG                  versionRequested,
                PCHANNEL_INIT_EVENT_EX_FN pChannelInitEventProcEx);

typedef VIRTUALCHANNELINITEX FAR * PVIRTUALCHANNELINITEX;



/****************************************************************************/
/* Name: VirtualChannelOpen                                                 */
/*                                                                          */
/* Purpose:                                                                 */
/*                                                                          */
/* This function is called by the application to open a channel.  It cannot */
/* be called until a connection is established with a Server.               */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* CHANNEL_RC_OK                                                            */
/* CHANNEL_RC_NOT_INITIALIZED                                               */
/* CHANNEL_RC_NOT_CONNECTED                                                 */
/* CHANNEL_RC_BAD_CHANNEL_NAME                                              */
/* CHANNEL_RC_BAD_INIT_HANDLE                                               */
/*                                                                          */
/* Params:                                                                  */
/*                                                                          */
/* - pInitHandle - handle from VirtualChannelInit                           */
/*                                                                          */
/* - pOpenHandle (returned) - handle to pass to subsequent                  */
/*                            VirtualChannelXxx calls                       */
/* - pChannelName - name of channel to open                                 */
/* - pChannelOpenEventProc - address of VirtualChannelOpenEvent procedure   */
/*                                                                          */
/****************************************************************************/
typedef UINT VCAPITYPE VIRTUALCHANNELOPEN(
                                LPVOID                 pInitHandle,
                                LPDWORD                pOpenHandle,
                                PCHAR                  pChannelName,
                                PCHANNEL_OPEN_EVENT_FN pChannelOpenEventProc);

typedef VIRTUALCHANNELOPEN FAR * PVIRTUALCHANNELOPEN;

typedef UINT VCAPITYPE VIRTUALCHANNELOPENEX(
                                LPVOID                 pInitHandle,
                                LPDWORD                pOpenHandle,
                                PCHAR                  pChannelName,
                                PCHANNEL_OPEN_EVENT_EX_FN pChannelOpenEventProcEx);

typedef VIRTUALCHANNELOPENEX FAR * PVIRTUALCHANNELOPENEX;


/****************************************************************************/
/* Name: VirtualChannelClose                                                */
/*                                                                          */
/* Purpose:                                                                 */
/*                                                                          */
/* This function is called to close a previously opened channel.            */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* CHANNEL_RC_OK                                                            */
/* CHANNEL_RC_BAD_CHANNEL_HANDLE                                            */
/*                                                                          */
/* Params:                                                                  */
/*                                                                          */
/* - (EX version) pInitHandle - handle identifying the client instance      */
/* - openHandle - handle returned on VirtualChannelOpen                     */
/*                                                                          */
/****************************************************************************/
typedef UINT VCAPITYPE VIRTUALCHANNELCLOSE(DWORD openHandle);

typedef VIRTUALCHANNELCLOSE FAR * PVIRTUALCHANNELCLOSE;

typedef UINT VCAPITYPE VIRTUALCHANNELCLOSEEX(LPVOID pInitHandle,
                                             DWORD openHandle);

typedef VIRTUALCHANNELCLOSEEX FAR * PVIRTUALCHANNELCLOSEEX;


/****************************************************************************/
/* Name: VirtualChannelWrite                                                */
/*                                                                          */
/* Purpose:                                                                 */
/*                                                                          */
/* This function is used to send data to the partner app on the Server.     */
/*                                                                          */
/* VirtualChannelWrite copies the data to one or more network buffers as    */
/* necessary.  VirtualChannelWrite ensures that data is sent to the Server  */
/* on the right context.  It sends all data on MS TC's Sender thread.       */
/*                                                                          */
/* VirtualChannelWrite is asynchronous - the VirtualChannelOpenEvent        */
/* procedure is called when the write completes.  Until that callback is    */
/* made, the caller must not free or reuse the buffer passed on             */
/* VirtualChannelWrite.  The caller passes a piece of data (pUserData) to   */
/* VirtualChannelWrite, which is returned on the VirtualChannelOpenEvent    */
/* callback.  The caller can use this data to identify the write which has  */
/* completed.                                                               */
/*                                                                          */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* CHANNEL_RC_OK                                                            */
/* CHANNEL_RC_NOT_INITIALIZED                                               */
/* CHANNEL_RC_NOT_CONNECTED                                                 */
/* CHANNEL_RC_BAD_CHANNEL_HANDLE                                            */
/*                                                                          */
/* Params:                                                                  */
/* - (EX version) pInitHandle - handle identifying the client instance      */
/* - openHandle - handle from VirtualChannelOpen                            */
/* - pData - data to write                                                  */
/* - datalength - length of data to write                                   */
/* - pUserData - user supplied data, returned on VirtualChannelOpenEvent    */
/*               when the write completes                                   */
/*                                                                          */
/****************************************************************************/
typedef UINT VCAPITYPE VIRTUALCHANNELWRITE(DWORD  openHandle,
                                           LPVOID pData,
                                           ULONG  dataLength,
                                           LPVOID pUserData);

typedef VIRTUALCHANNELWRITE FAR * PVIRTUALCHANNELWRITE;

typedef UINT VCAPITYPE VIRTUALCHANNELWRITEEX(LPVOID pInitHandle,
                                           DWORD  openHandle,
                                           LPVOID pData,
                                           ULONG  dataLength,
                                           LPVOID pUserData);

typedef VIRTUALCHANNELWRITEEX FAR * PVIRTUALCHANNELWRITEEX;


/****************************************************************************/
/* Structure: CHANNEL_ENTRY_POINTS                                          */
/*                                                                          */
/* Description: Virtual Channel entry points passed to VirtualChannelEntry  */
/****************************************************************************/
typedef struct tagCHANNEL_ENTRY_POINTS
{
    DWORD cbSize;
    DWORD protocolVersion;
    PVIRTUALCHANNELINIT  pVirtualChannelInit;
    PVIRTUALCHANNELOPEN  pVirtualChannelOpen;
    PVIRTUALCHANNELCLOSE pVirtualChannelClose;
    PVIRTUALCHANNELWRITE pVirtualChannelWrite;
} CHANNEL_ENTRY_POINTS, FAR * PCHANNEL_ENTRY_POINTS;

typedef struct tagCHANNEL_ENTRY_POINTS_EX
{
    DWORD cbSize;
    DWORD protocolVersion;
    PVIRTUALCHANNELINITEX  pVirtualChannelInitEx;
    PVIRTUALCHANNELOPENEX  pVirtualChannelOpenEx;
    PVIRTUALCHANNELCLOSEEX pVirtualChannelCloseEx;
    PVIRTUALCHANNELWRITEEX pVirtualChannelWriteEx;
} CHANNEL_ENTRY_POINTS_EX, FAR * PCHANNEL_ENTRY_POINTS_EX;



/****************************************************************************/
/* Name: VirtualChannelEntry                                                */
/*                                                                          */
/* Purpose:                                                                 */
/*                                                                          */
/* This function is provided by addin DLLS.  It is called by MSTSC at       */
/* initialization to tell the addin DLL the addresses of the                */
/* VirtualChannelXxx functions.                                             */
/*                                                                          */
/* Returns:                                                                 */
/*                                                                          */
/* TRUE - everything OK                                                     */
/* FALSE - error, unload the DLL                                            */
/*                                                                          */
/* Parameters:                                                              */
/*                                                                          */
/* - pVirtualChannelInit - pointers to VirtualChannelXxx functions          */
/* - pVirtualChannelOpen                                                    */
/* - pVirtualChannelClose                                                   */
/* - pVirtualChannelWrite                                                   */
/*                                                                          */
/* - (EX version) pInitHandle - value that identifies client instance       */
/*                              this must be passed back when calling into  */
/*                              the client.                                 */
/****************************************************************************/
typedef BOOL VCAPITYPE VIRTUALCHANNELENTRY(
                                          PCHANNEL_ENTRY_POINTS pEntryPoints);

typedef VIRTUALCHANNELENTRY FAR * PVIRTUALCHANNELENTRY;

typedef BOOL VCAPITYPE VIRTUALCHANNELENTRYEX(
                                          PCHANNEL_ENTRY_POINTS_EX pEntryPointsEx,
                                          PVOID                    pInitHandle);

typedef VIRTUALCHANNELENTRYEX FAR * PVIRTUALCHANNELENTRYEX;


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* H_CCHANNEL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\ctxdef.h ===
/*******************************************************************************
*
* CTXDEF.H
*
* TerminalServer  API support (typedefs).
*
* copyright notice: Microsoft Corporation 1998
*
*
*******************************************************************************/


/***********
 *  Defines
 ***********/
#define WINSTATIONNAME_LENGTH    32

/*
 *  Event flags for CtxWinStationWaitEvent
 */
#define WEVENT_NONE         0x00000000    
#define WEVENT_CREATE       0x00000001 // new WinStation created
#define WEVENT_DELETE       0x00000002 // existing WinStation deleted
#define WEVENT_RENAME       0x00000004 // existing WinStation renamed
#define WEVENT_CONNECT      0x00000008 // WinStation connect to client
#define WEVENT_DISCONNECT   0x00000010 // WinStation logged on without client
#define WEVENT_LOGON        0x00000020 // user logon to existing WinStation
#define WEVENT_LOGOFF       0x00000040 // user logoff from existing WinStation 
#define WEVENT_STATECHANGE  0x00000080 // WinStation state change
#define WEVENT_LICENSE      0x00000100 // License state change
#define WEVENT_ALL          0x7fffffff // wait for all event types
#define WEVENT_FLUSH        0x80000000 // unblock all waiters


/************
 *  Typedefs
 ************/
typedef WCHAR WINSTATIONNAMEW[ WINSTATIONNAME_LENGTH + 1 ];
typedef WCHAR * PWINSTATIONNAMEW;

typedef CHAR WINSTATIONNAMEA[ WINSTATIONNAME_LENGTH + 1 ];
typedef CHAR * PWINSTATIONNAMEA;

#ifdef UNICODE
#define WINSTATIONNAME WINSTATIONNAMEW
#define PWINSTATIONNAME PWINSTATIONNAMEW
#else
#define WINSTATIONNAME WINSTATIONNAMEA
#define PWINSTATIONNAME PWINSTATIONNAMEA
#endif /* UNICODE */

/*
 *  WinStation connect states
 */
typedef enum _WINSTATIONSTATECLASS {
    State_Active,                      // user logged on to WinStation
    State_Connected,                   // WinStation connected to client
    State_ConnectQuery,                // in the process of connecting to client
    State_Shadow,                      // shadowing another WinStation
    State_Disconnected,                // WinStation logged on without client
    State_Idle,                        // waiting for client to connect
    State_Listen,                      // WinStation is listening for connection     
    State_Reset,                       // WinStation is being reset
    State_Down,                        // WinStation is down due to error
    State_Init,                        // WinStation in initialization
} WINSTATIONSTATECLASS;

typedef struct _SESSIONIDW {
    union {
        ULONG SessionId;             
        ULONG LogonId;                 // internal use only
    };
    WINSTATIONNAMEW WinStationName;
    WINSTATIONSTATECLASS State;
} SESSIONIDW, * PSESSIONIDW;

typedef struct _SESSIONIDA {
    union {
        ULONG SessionId;
        ULONG LogonId;                 // internal use only 
    };
    WINSTATIONNAMEA WinStationName;
    WINSTATIONSTATECLASS State;
} SESSIONIDA, * PSESSIONIDA;

#ifdef UNICODE
#define SESSIONID SESSIONIDW
#define PSESSIONID PSESSIONIDW
#else
#define SESSIONID SESSIONIDA
#define PSESSIONID PSESSIONIDA
#endif /* UNICODE */

/*
 * NtUserCtxConnectState() values
 *    Used by routines that can't use WinStation API calls
 *    like DLL init routines.
 */
#define CTX_W32_CONNECT_STATE_CONSOLE             0
#define CTX_W32_CONNECT_STATE_IDLE                1
#define CTX_W32_CONNECT_STATE_EXIT_IN_PROGRESS    2
#define CTX_W32_CONNECT_STATE_CONNECTED           3
#define CTX_W32_CONNECT_STATE_DISCONNECTED        4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\ctxver.h ===
/***************************************************************************
*
*  CTXVER.H
*
*  This module defines the Terminal Server NT build version.
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#ifndef _INC_CTXVER
#define _INC_CTXVER

/*
 * NOTE:  The standard MS NT build values VER_PRODUCTBUILD,
 *        VER_PRODUCTBUILD_STR, and VER_PRODUCTBETA_STR in ntverp.h
 *        are left alone and the new CITRIX build values are set here.
 */

#define VER_CTXPRODUCTBUILD         309

#define VER_CTXPRODUCTBUILD_STR    "309"

#define VER_CTXPRODUCTBETA_STR      ""

/*--------------------------------------------------------------------------*/
/*                                                                          */
/* The standard NT file versioning sets up the .rc file in a similar way    */
/* to the following:                                                        */
/*                                                                          */
/*  #include <winver.h>  // or #include <windows.h>                         */
/*  #include <ntverp.h>                                                     */
/*                                                                          */
/*  [file-specific #defines, such as...]                                    */
/*                                                                          */
/*  #define VER_FILETYPE                VFT_APP                             */
/*  #define VER_FILESUBTYPE             VFT2_UNKNOWN                        */
/*  #define VER_FILEDESCRIPTION_STR     "WinStation Configuration"          */
/*  #define VER_INTERNALNAME_STR        "WinCfg"                            */
/*  #define VER_ORIGINALFILENAME_STR    "WINCFG.EXE"                        */
/*                                                                          */
/* If you are building a component with ONLY citrix content, use the        */
/* following line:                                                          */
/*                                                                          */
/*  #include <citrix\verall.h>                                              */
/*                                                                          */
/* If you are building a component with SOME Citrix content, use the        */
/* following line:                                                          */
/*                                                                          */
/*  #include <citrix\versome.h>                                             */
/*                                                                          */
/* (Obviously, neither of the two lines mentioned above will be included    */
/* if there is NO Citrix content)                                           */
/*                                                                          */
/*  #include <common.ver>                                                   */
/*                                                                          */
/* The above version resource layout will produce the following version     */
/* contents for the built files:                                            */
/*                                                                          */
/*                          All Ctx          Some Ctx         No Ctx        */
/*                          ------------     ------------     ------------  */
/* File Version Str:        ctx ver.bld      <original>       <original>    */
/* File Version #:          ctx ver.bld      <original>       <original>    */
/* Copyright:               ctx copyright    <original>       <original>    */
/* Company Name:            citrix           <original>       <original>    */
/* Product Name:            winframe         <original>       <original>    */
/* Product Version Str:     ctx ver          <original>       <original>    */
/* Product Version #:       ctx ver          <original>       <original>    */
/* Addl. Copyright:         ---              ctx copyright    ---           */
/* Addl. Product:           ---              winframe ver.bld ---           */
/*                                                                          */
/* The following two OEM defines are now defined in SHELL32.DLL's RC file   */
/* so that they don't get stuck in every versioned file that Citrix builds  */
/*                                                                          */
/*  #define VER_CTXOEMNAME_STR             "Citrix Systems, Inc."           */
/*  #define VER_CTXOEMID_STR               "CTX"                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/
/*                                                                          */
/* Define Citrix version stuff (build defines are auto-put above)           */
/*                                                                          */
#define VER_CTXCOPYRIGHT_STR            "Copyright \251 1990-1997 Citrix Systems, Inc."
#define VER_CTXCOMPANYNAME_STR          "Citrix Systems, Inc."
#define VER_CTXPRODUCTNAME_STR          "Citrix WinFrame"
#define VER_CTXPRODUCTVERSION_STR       "4.00"
#define VER_CTXPRODUCTVERSION           4,00,VER_CTXPRODUCTBUILD,1
#define VER_CTXFILEVERSION_STR          VER_CTXPRODUCTVERSION_STR "." VER_CTXPRODUCTBUILD_STR
#define VER_CTXFILEVERSION              VER_CTXPRODUCTVERSION
/*                                                                          */
/* License level to verify code and license are the same level.   This      */
/* is stored in a base or upgrade license serial number.  This needs to be  */
/* inc'd for each release/upgrade where we require a license diskette be    */
/* installed so it can't be freely distributed.                             */
#define VER_LICENSE_CODE                3
/*                                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*                                                                          */
/* Override standard MS VER_ defines depending on the Citrix content level: */
/*                                                                          */
#ifndef VER_CTXCONTENT
#define VER_CTXCONTENT      1   // Default to SOME Citrix content
#define VER_CTXSOMECONTENT  1
#endif

/*                                                                          */
/* ALL Citrix content: override standard MS defines.                        */
/*                                                                          */
#ifdef VER_CTXALLCONTENT

#ifdef VER_FILEVERSION_STR
#undef VER_FILEVERSION_STR
#endif
#define VER_FILEVERSION_STR VER_CTXFILEVERSION_STR

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif
#define VER_FILEVERSION VER_CTXFILEVERSION

#ifdef VER_LEGALCOPYRIGHT_STR
#undef VER_LEGALCOPYRIGHT_STR
#endif
#define VER_LEGALCOPYRIGHT_STR VER_CTXCOPYRIGHT_STR

#ifdef VER_COMPANYNAME_STR
#undef VER_COMPANYNAME_STR
#endif
#define VER_COMPANYNAME_STR VER_CTXCOMPANYNAME_STR

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif
#define VER_PRODUCTNAME_STR VER_CTXPRODUCTNAME_STR

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif
#define VER_PRODUCTVERSION_STR VER_CTXPRODUCTVERSION_STR

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif
#define VER_PRODUCTVERSION VER_CTXPRODUCTVERSION

#ifdef VER_PRODUCTBUILD_STR
#undef VER_PRODUCTBUILD_STR
#endif
#define VER_PRODUCTBUILD_STR VER_CTXPRODUCTBUILD_STR

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif
#define VER_PRODUCTBUILD VER_CTXPRODUCTBUILD

#endif // All Citrix Content

/*                                                                          */
/* SOME Citrix content.  No MS defines are overridden; common.ver will take */
/*                       care of adding the 'Additional ...' lines.         */
/*                                                                          */
#ifdef VER_CTXSOMECONTENT
#endif // Some Citrix Content

#endif  /* !_INC_CTXVER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\cxmsgsvc.h ===
/*************************************************************************
*
* cxmsgsvc.h
*
* This header file supports the Terminal Server WinStation extensions to the
* main network message service.
*
* This interface allows qualifying information to be sent to the extended
* message service to support directing messages to specific users.
*
* Copyright Microsoft Corporation, 1998
*
*
*
*************************************************************************/

//
// Define WinStation control port name
//
#define CTX_MSGSVC_PORT_NAME L"\\CtxMsgSvcQualifier"

#define CTX_MSGSVC_VERSION   1

#define MSGSVC_NAME_LENGTH   16  // NETBIOS_NAME_LENGTH

//
// This is the ConnectInfo structure passed at NtConnectPort() time
// so that the server can verify our access rights.
//
typedef struct _CTX_MSGSVC_CONNECT_INFO {
    ULONG    Version;
    NTSTATUS AcceptStatus;
} CTX_MSGSVC_CONNECT_INFO, *PCTX_MSGSVC_CONNECT_INFO;

typedef struct _PRINT_QUALIFY_MSG {
    WCHAR PrintServerName[MSGSVC_NAME_LENGTH];
    WCHAR UserName[MSGSVC_NAME_LENGTH];
    ULONG PrintJobId;
} PRINT_QUALIFY_MSG;

typedef struct _CTX_MSGSVC_APIMSG {
    PORT_MESSAGE h;
    ULONG MessageId;
    ULONG ApiNumber;
    NTSTATUS ReturnedStatus;
    union {
        PRINT_QUALIFY_MSG Print;
        // Add additional messages here in the future
    } u;
} CTX_MSGSVC_APIMSG, *PCTX_MSGSVC_APIMSG;

//
// Command message types
//

#define PRINT_QUALIFY 1
// Add additional here
#define CTX_MSGSVC_MAX_API_NUMBER PRINT_QUALIFY+1



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\ctxdd.h ===
/*************************************************************************
*
* ctxdd.h
*
* Prototypes for functions to perform kernel level I/O using file object.
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 * Read file using a FileObject instead of a handle.
 * If the caller does not specify a wait KEVENT, then this is
 * a synchronous read operation.  Otherwise, it is the caller's
 * responsibility to wait on the specified event if necessary.
 */
NTSTATUS
CtxReadFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    );


/*
 * Write file using a FileObject instead of a handle.
 * If the caller does not specify a wait KEVENT, then this is
 * a synchronous read operation.  Otherwise, it is the caller's
 * responsibility to wait on the specified event if necessary.
 */
NTSTATUS
CtxWriteFile(
    IN PFILE_OBJECT fileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    );


/*
 * DeviceIoControl using a FileObject instead of a handle.
 * If the caller does not specify a wait KEVENT, then this is
 * a synchronous read operation.  Otherwise, it is the caller's
 * responsibility to wait on the specified event if necessary.
 */
NTSTATUS
CtxDeviceIoControlFile(
    IN PFILE_OBJECT fileObject,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    );


/*
 * DeviceIoControl using a FileObject instead of a handle.
 * If the caller does not specify a wait KEVENT, then this is
 * a synchronous read operation.  Otherwise, it is the caller's
 * responsibility to wait on the specified event if necessary.
 */
NTSTATUS
CtxInternalDeviceIoControlFile(
    IN PFILE_OBJECT FileObject,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer OPTIONAL,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction,
    IN PKEVENT pEvent OPTIONAL,
    OUT PIO_STATUS_BLOCK pIosb OPTIONAL,
    OUT PIRP *ppIrp OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\execsrv.h ===
/*************************************************************************
*
* execsrv.h
*
* Common header file for remote WinStation exec service
*
* Copyright Microsoft Corporation, 1998
*
*
*
*************************************************************************/

// Server: WinLogon per WinStation
#define EXECSRV_SYSTEM_PIPE_NAME  L"\\\\.\\Pipe\\TerminalServer\\SystemExecSrvr\\%d" // winlogon

#define EXECSRV_BUFFER_SIZE  8192 

/*
 * Data structure passed for a remote exec request
 *
 * This basicily exports the WIN32 CreateProcessW() API.
 *
 * NOTE: pointers are self relative
 *
 */

typedef struct _EXECSRV_REQUEST {
    DWORD   Size;                // total size in request
    DWORD   RequestingProcessId; // To allow the handle DUP to the requestor
    BOOL    System;              // TRUE if create under system context

    // CreateProcessW() parameters
    HANDLE  hToken;
    PWCHAR  lpszImageName;
    PWCHAR  lpszCommandLine;
    SECURITY_ATTRIBUTES saProcess;
    SECURITY_ATTRIBUTES saThread;
    BOOL    fInheritHandles;
    DWORD   fdwCreate;
    LPVOID  lpvEnvironment;
    LPWSTR  lpszCurDir;
    STARTUPINFOW StartInfo;
    PROCESS_INFORMATION ProcInfo;
} EXECSRV_REQUEST, *PEXECSRV_REQUEST;

typedef struct _EXECSRV_REPLY {
    DWORD   Size;
    BOOLEAN Result;
    DWORD   LastError;
    //
    // NOTE: The handles for hProcess and hThread are converted from the
    //       remote exec server into the requestors process using the
    //       RequestingProcess handle in the request.
    //
    PROCESS_INFORMATION ProcInfo;
} EXECSRV_REPLY, *PEXECSRV_REPLY;


BOOL
WinStationCreateProcessW(
    ULONG  LogonId,
    BOOL   System,
    PWCHAR lpszImageName,
    PWCHAR lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvionment,
    LPWSTR lpszCurDir,
    LPSTARTUPINFOW pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    );

//
// For non-UNICODE clients
//
BOOL
WinStationCreateProcessA(
    ULONG  LogonId,
    BOOL   System,
    PCHAR  lpszImageName,
    PCHAR  lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvionment,
    LPCSTR lpszCurDir,
    LPSTARTUPINFOA pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\icaapi.h ===
/***************************************************************************
*
*  ICAAPI.H
*
*  This module contains defines, structures, and function prototypes
*  for the ICA DLL (ICAAPI.DLL) interface to the Terminal Server Termdd Device Driver.
*
*
*  Copyright Microsoft Corporation, 1998
*
*  
****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*
 *   Function prototypes
 */

NTSTATUS
IcaOpen( OUT HANDLE * phIca );

NTSTATUS
IcaClose( IN HANDLE hIca );

NTSTATUS
IcaStackUnlock( IN HANDLE pContext );

VOID cdecl
IcaSystemTrace( IN HANDLE hIca, ULONG, ULONG, char *, ... );

VOID cdecl
IcaTrace( IN HANDLE hIca, ULONG, ULONG, char *, ... );

NTSTATUS
IcaIoControl( IN HANDLE hIca,
              IN ULONG IoControlCode,
              IN PVOID pInBuffer,
              IN ULONG InBufferSize,
              OUT PVOID pOutBuffer,
              IN ULONG OutBufferSize,
              OUT PULONG pBytesReturned );

NTSTATUS
IcaStackOpen( IN  HANDLE hIca, 
              IN  STACKCLASS Class,     // primary, shadow, passthrough
              IN  PROC pStackIoControl, // pointer to StackIoControl procedure
              IN  PVOID Context,        // context value passed to above proc
              OUT HANDLE * phStack );

NTSTATUS
IcaStackClose( IN HANDLE hStack );

NTSTATUS
IcaStackTerminate( IN HANDLE hStack );

VOID cdecl
IcaStackTrace( IN HANDLE hStack, ULONG, ULONG, char *, ... );

NTSTATUS
IcaStackConnectionWait( IN  HANDLE hStack,
                        IN  PWINSTATIONNAME pWinStationName,
                        IN  PWINSTATIONCONFIG2 pWinStationConfig,
                        IN  PICA_STACK_ADDRESS pAddress,
                        OUT PVOID pEndpoint,
                        IN  ULONG BufferLength,
                        OUT PULONG pEndpointLength );

NTSTATUS
IcaStackConnectionRequest( IN  HANDLE hStack, 
                           IN  PWINSTATIONNAME pWinStationName,
                           IN  PWINSTATIONCONFIG2 pWinStationConfig,
                           IN  PICA_STACK_ADDRESS pAddress,
                           OUT PVOID pEndpoint,
                           IN  ULONG BufferLength,
                           OUT PULONG pEndpointLength );

NTSTATUS
IcaStackConnectionAccept( IN  HANDLE hIca,
                          IN  HANDLE hStack,
                          IN  PWINSTATIONNAME pWinStationName,
                          IN  PWINSTATIONCONFIG2 pWinStationConfig,
                          IN  PVOID pEndpoint,
                          IN  ULONG EndpointLength,
                          IN  PICA_STACK_STATE_HEADER pStackState,
                          IN  ULONG BufferLength,
                          IN  PICA_TRACE pTrace );

NTSTATUS
IcaStackQueryState( IN HANDLE hStack,
                    OUT PICA_STACK_STATE_HEADER pStackState,
                    IN ULONG BufferLength,
                    OUT PULONG pStateLength );
NTSTATUS
IcaStackCreateShadowEndpoint( HANDLE pContext,
                              PWINSTATIONNAME pWinStationName,
                              PWINSTATIONCONFIG2 pWinStationConfig,
                              PICA_STACK_ADDRESS pAddressIn,
                              PICA_STACK_ADDRESS pAddressOut );

NTSTATUS
IcaStackConnectionClose( IN  HANDLE hStack,
                         IN  PWINSTATIONCONFIG2 pWinStationConfig,
                         IN  PVOID pEndpoint,
                         IN  ULONG EndpointLength );

NTSTATUS
IcaStackCallback( IN  HANDLE hStack, 
                  IN  PWINSTATIONCONFIG2 pWinStationConfig,
                  IN  WCHAR * pPhoneNumber,
                  OUT PVOID pEndpoint,
                  IN  ULONG BufferLength,
                  OUT PULONG pEndpointLength );

NTSTATUS
IcaStackDisconnect( IN  HANDLE hStack, 
                    IN  HANDLE hIca,
                    IN  PVOID pCallbackContext );

NTSTATUS
IcaStackReconnect( IN  HANDLE hStack, 
                   IN  HANDLE hIca,
                   IN  PVOID  pCallbackContext,
                   IN  ULONG  sessionId);

NTSTATUS
IcaStackIoControl( IN HANDLE hStack,
                   IN ULONG IoControlCode,
                   IN PVOID pInBuffer,
                   IN ULONG InBufferSize,
                   OUT PVOID pOutBuffer,
                   IN ULONG OutBufferSize,
                   OUT PULONG pBytesReturned );

//
//  This version of IcaStackIoControl is not protected by the stack critical
//  section.
//

NTSTATUS
_IcaStackIoControl( IN HANDLE hStack,
                   IN ULONG IoControlCode,
                   IN PVOID pInBuffer,
                   IN ULONG InBufferSize,
                   OUT PVOID pOutBuffer,
                   IN ULONG OutBufferSize,
                   OUT PULONG pBytesReturned );

NTSTATUS
IcaCdIoControl( IN HANDLE hStack,
                IN ULONG IoControlCode,
                IN PVOID pInBuffer,
                IN ULONG InBufferSize,
                OUT PVOID pOutBuffer,
                IN ULONG OutBufferSize,
                OUT PULONG pBytesReturned );

NTSTATUS 
IcaCdWaitForSingleObject( HANDLE pContext, 
                          HANDLE hHandle,
                          LONG Timeout );

NTSTATUS 
IcaCdWaitForMultipleObjects( HANDLE pContext, 
                             ULONG Count,
                             HANDLE * phHandle,
                             BOOL bWaitAll,
                             LONG Timeout );

HANDLE
IcaCdCreateThread( HANDLE pContext, 
                   PVOID pProc, 
                   PVOID pParam, 
                   PULONG pThreadId );

NTSTATUS
IcaChannelOpen( IN  HANDLE hIca, 
                IN  CHANNELCLASS Channel, // cmd,con,video,mou,beep,kbd,virtual
                IN  PVIRTUALCHANNELNAME pVirtualName,
                OUT HANDLE * phChannel );

NTSTATUS
IcaChannelClose( IN HANDLE hChannel );

NTSTATUS
IcaChannelIoControl( IN HANDLE hChannel,
                     IN ULONG IoControlCode,
                     IN PVOID pInBuffer,
                     IN ULONG InBufferSize,
                     OUT PVOID pOutBuffer,
                     IN ULONG OutBufferSize,
                     OUT PULONG pBytesReturned );

VOID cdecl
IcaChannelTrace( IN HANDLE hChannel, ULONG, ULONG, char *, ... );

VOID
IcaBreakOnDebugger( );

NTSTATUS
IcaPushConsoleStack( IN HANDLE pContext,
                     IN PWINSTATIONNAME pWinStationName,
                     IN PWINSTATIONCONFIG2 pWinStationConfig,
                     IN PVOID pModuleData,
                     IN ULONG ModuleDataLength );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\icadd.h ===
/****************************************************************************/
// icadd.h
//
// TermSrv protocol stack defines.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef _ICADDH_
#define _ICADDH_


/*
 * ICA Stack types -- TEMP until moved to winsta.h
 */
typedef enum _STACKCLASS {
    Stack_Primary,
    Stack_Shadow,
    Stack_Passthru,
    Stack_Console
} STACKCLASS;

/*
 * ICA Channel types -- TEMP until moved to winsta.h
 *
 * NOTE: Channel_Virtual MUST be the last in the list.
 */
typedef enum _CHANNELCLASS {
    Channel_Keyboard,
    Channel_Mouse,
    Channel_Video,
    Channel_Beep,
    Channel_Command,
    Channel_Virtual     // WARNING: this must remain last in the list
} CHANNELCLASS;

#define CHANNEL_FIRST   Channel_Keyboard
#define CHANNEL_LAST    Channel_Virtual
#define CHANNEL_COUNT   Channel_Virtual+1


/*
 *  Client module information
 */
typedef struct _CLIENTMODULES {

    /*
     *  Initialization data from client    (client -> host)
     */
    PUCHAR pUiModule;                      // user interface module
    PUCHAR pUiExtModule[ MAX_UI_MODULES ]; // user interface extension modules
    PUCHAR pWdModule;                      // winstation driver module
    PUCHAR pVdModule[ VIRTUAL_MAXIMUM ];   // virtual driver modules
    PUCHAR pPdModule[ SdClass_Maximum ];   // protocol driver modules
    PUCHAR pTdModule;                      // transport driver module
    PUCHAR pPrModule;                      // protocol resolver module
    PUCHAR pScriptModule;                  // scripting module

    /*
     *  Pointers into the above client data
     */
    ULONG TextModeCount;         // number of supported text modes
    PFSTEXTMODE pTextModes;      // pointer to array of supported text modes

    /*
     *  Data accessed by winstation driver module
     */
    ULONG fTextOnly : 1;         // text only client connection
    ULONG fIcaDetected : 1;      // ICA data stream has been detected

    /*
     *  Initialization data from host       (host -> client)
     */
    PUCHAR pHostWdModule;                      // winstation driver module
    PUCHAR pHostPdModule[ SdClass_Maximum ];   // protocol driver modules
    PUCHAR pHostTdModule;                      // transport driver module

    /*
     *  Transport driver version information
     */
    BYTE TdVersionL;                  // lowest supported version
    BYTE TdVersionH;                  // highest supported version
    BYTE TdVersion;                   // connect version level

} CLIENTMODULES, * PCLIENTMODULES;


/*
 * TermDD Device Name
 */
#define ICA_DEVICE_NAME L"\\Device\\Termdd"
#define ICAOPENPACKET "TermddOpenPacketXX"
#define ICA_OPEN_PACKET_NAME_LENGTH (sizeof(ICAOPENPACKET) - 1)


/*
 * Structures used on NtCreateFile() for TermSrv.
 */
typedef enum _ICA_OPEN_TYPE {
    IcaOpen_Stack,
    IcaOpen_Channel
} ICA_OPEN_TYPE;

typedef union _ICA_TYPE_INFO {
    STACKCLASS StackClass;
    struct {
        CHANNELCLASS ChannelClass;
        VIRTUALCHANNELNAME  VirtualName;
    };
} ICA_TYPE_INFO, *PICA_TYPE_INFO;

typedef struct _ICA_OPEN_PACKET {
    HANDLE IcaHandle;
    ICA_OPEN_TYPE OpenType;
    ICA_TYPE_INFO TypeInfo;
} ICA_OPEN_PACKET;
typedef ICA_OPEN_PACKET UNALIGNED * PICA_OPEN_PACKET;


/*
 * ICA IOCTL code definitions
 */
#define IOCTL_ICA_BASE  FILE_DEVICE_TERMSRV
#define _ICA_CTL_CODE( request, method ) \
            CTL_CODE( IOCTL_ICA_BASE, request, method, FILE_ANY_ACCESS )



/*=============================================================================
==   ICA Driver IOCTLs
=============================================================================*/

/*
 *  IOCTL_ICA_SET_TRACE
 *
 *  Set WinStation trace options
 *
 *  input  - ICATRACE
 *  output - nothing
 */
#define IOCTL_ICA_SET_TRACE                 _ICA_CTL_CODE( 0, METHOD_NEITHER )

typedef struct _ICA_TRACE {
    WCHAR TraceFile[256];
    BOOLEAN fDebugger;
    BOOLEAN fTimestamp;
    ULONG TraceClass;
    ULONG TraceEnable;
    WCHAR TraceOption[64];
} ICA_TRACE, * PICA_TRACE;


/*
 *  IOCTL_ICA_TRACE
 *
 *  Write trace record to winstation trace file
 *
 *  input  - ICA_TRACE_BUFFER
 *  output - nothing
 */
#define IOCTL_ICA_TRACE                     _ICA_CTL_CODE( 1, METHOD_NEITHER )

typedef struct _ICA_TRACE_BUFFER {
    ULONG TraceClass;
    ULONG TraceEnable;
    ULONG DataLength;
    BYTE Data[256];   // must be last in structure
} ICA_TRACE_BUFFER, * PICA_TRACE_BUFFER;

typedef struct _ICA_KEEP_ALIVE {
    BOOLEAN    start;
    ULONG      interval ; 
}   ICA_KEEP_ALIVE, *PICA_KEEP_ALIVE;


/*
 *  IOCTL_ICA_SET_SYSTEM_TRACE
 *
 *  Set system wide API trace options
 *
 *  input  - ICATRACE
 *  output - nothing
 */
#define IOCTL_ICA_SET_SYSTEM_TRACE             _ICA_CTL_CODE( 2, METHOD_NEITHER )


/*
 *  IOCTL_ICA_SYSTEM_TRACE
 *
 *  Write trace record to system wide trace file
 *
 *  input  - ICA_TRACE_BUFFER
 *  output - nothing
 */
#define IOCTL_ICA_SYSTEM_TRACE                 _ICA_CTL_CODE( 3, METHOD_NEITHER )


/*
 *  IOCTL_ICA_UNBIND_VIRTUAL_CHANNEL
 *
 *  Unbind a virtual channel to prevent future uses of the channel.
 *
 *  input  - VIRTUAL_NAME
 *  output - nothing
 */
#define IOCTL_ICA_UNBIND_VIRTUAL_CHANNEL       _ICA_CTL_CODE( 4, METHOD_NEITHER )


/*
 *  IOCTL_ICA_SET_SYSTEM_PARAMETERS
 *
 *  Used to inform TermDD of non-trace system settings. Allows registry reads
 *  to occur mostly in TermSrv.
 *
 *  input  - TERMSRV_SYSTEM_PARAMS
 *  output - nothing
 */
#define IOCTL_ICA_SET_SYSTEM_PARAMETERS        _ICA_CTL_CODE( 5, METHOD_NEITHER )


/*
 *  IOCTL_ICA_SYSTEM_KEEPALIVE 
 *
 *
 *  input  - enable/disable keep alive
 *  output - nothing
 */
#define IOCTL_ICA_SYSTEM_KEEP_ALIVE                    _ICA_CTL_CODE( 6, METHOD_NEITHER )





#define DEFAULT_MOUSE_THROTTLE_SIZE (200 * sizeof(MOUSE_INPUT_DATA))
#define DEFAULT_KEYBOARD_THROTTLE_SIZE (200 * sizeof(KEYBOARD_INPUT_DATA))

typedef struct _TERMSRV_SYSTEM_PARAMS
{
    // Byte sizes used as upper limit to data stored in channel queues.
    // Nonzero sizes prevent an attacking client from allocating all the
    // system nonpaged pool for channel storage.
    ULONG MouseThrottleSize;
    ULONG KeyboardThrottleSize;
} TERMSRV_SYSTEM_PARAMS, *PTERMSRV_SYSTEM_PARAMS;



/*=============================================================================
==   ICA Stack IOCTLs
=============================================================================*/

/*
 *  Stack driver configuration
 */
typedef struct _ICA_STACK_CONFIG {
    DLLNAME SdDLL[ SdClass_Maximum ];
    SDCLASS SdClass[ SdClass_Maximum ];
    DLLNAME WdDLL;
} ICA_STACK_CONFIG, *PICA_STACK_CONFIG;

/*
 *  IOCTL_ICA_STACK_PUSH
 *
 *  Load a new stack driver to the top of the stack
 *
 *  input  - ICA_STACK_PUSH
 *  output - nothing
 */
#define IOCTL_ICA_STACK_PUSH                _ICA_CTL_CODE( 10, METHOD_NEITHER )

typedef enum _STACKMODULECLASS {
    Stack_Module_Pd,
    Stack_Module_Wd
} STACKMODULECLASS;

typedef struct _ICA_STACK_PUSH {
    STACKMODULECLASS StackModuleType;  // IN
    DLLNAME StackModuleName;           // IN
    char  OEMId[4];                    // IN - WinFrame Server OEM Id
    WDCONFIG WdConfig;                 // IN - WD configuration data
    PDCONFIG PdConfig;                 // IN - PD configuration data
    WINSTATIONNAME WinStationRegName;  // IN - WinStation registry name
} ICA_STACK_PUSH, *PICA_STACK_PUSH;


/*
 *  IOCTL_ICA_STACK_POP
 *
 *  Unload the top stack driver
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_POP                 _ICA_CTL_CODE( 11, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CREATE_ENDPOINT
 *
 *  Create a new stack endpoint
 *
 *  Issued on a "Listen Stack" based on the registry template
 *
 *  input  - ICA_STACK_ADDRESS (optional local address -- used by shadow)
 *  output - ICA_STACK_ADDRESS (optional)
 */
#define IOCTL_ICA_STACK_CREATE_ENDPOINT     _ICA_CTL_CODE( 12, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CD_CREATE_ENDPOINT
 *
 *  Create a new stack endpoint with the supplied handle.
 *
 *  Issued on a "Listen Stack" based on the registry template
 *
 *  input  - <endpoint data>
 *  output - <endpoint data>
 */
#define IOCTL_ICA_STACK_CD_CREATE_ENDPOINT  _ICA_CTL_CODE( 13, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_OPEN_ENDPOINT
 *
 *  Open an existing stack endpoint
 *
 *  input  - <endpoint data>
 *  output - nothing
 */
#define IOCTL_ICA_STACK_OPEN_ENDPOINT       _ICA_CTL_CODE( 14, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CLOSE_ENDPOINT
 *
 *  Close stack endpoint  (closing stack does not close the endpoint)
 *  - terminates client connection
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_CLOSE_ENDPOINT      _ICA_CTL_CODE( 15, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_ENABLE_DRIVER
 *
 *  Enables protocol driver functionality (e.g. compression, encryption, ...)
 *
 *  Issued on a "Listen Stack" based on the registry template
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_ENABLE_DRIVER       _ICA_CTL_CODE( 16, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CONNECTION_WAIT
 *
 *  Waits for a client connection (listens)
 *
 *  Issued on a "Listen Stack"
 *
 *  input  - nothing
 *  output - <endpoint data>
 */
#define IOCTL_ICA_STACK_CONNECTION_WAIT     _ICA_CTL_CODE( 17, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_WAIT_FOR_ICA
 *
 *  Wait for ICA detect string in WinStation driver
 *
 *  Issued on a "Listen Stack"
 *
 *  Also returns the "Query Stack" which is the host stack that the following
 *  queries will be done on.  If no stack is returned, just use the
 *  original "Listen Stack" from the registry template.
 *
 *  input  - nothing
 *  output - ICA_STACK_CONFIG  (optional)
 */
#define IOCTL_ICA_STACK_WAIT_FOR_ICA        _ICA_CTL_CODE( 18, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CONNECTION_QUERY
 *
 *  Issues the client query commands.  The client responds with client
 *  module data that contains the "Negotiated Stack"
 *
 *  Issued on a "Query Stack"
 *
 *  input  - nothing
 *  output - ICA_STACK_CONFIG
 */
#define IOCTL_ICA_STACK_CONNECTION_QUERY    _ICA_CTL_CODE( 19, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CONNECTION_SEND
 *
 *  Initialize and send host module data to the client
 *
 *  Issued on a "Negotiated Stack"
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_CONNECTION_SEND     _ICA_CTL_CODE( 20, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CONNECTION_REQUEST
 *
 *  Initiates a connection to a listening remote endpoint
 *
 *  input  - ICA_STACK_ADDRESS (remote address -- used by shadow)
 *  output - <endpoint data>
 */
#define IOCTL_ICA_STACK_CONNECTION_REQUEST  _ICA_CTL_CODE( 21, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_QUERY_PARAMS
 *
 *  Query protocol or transport driver parameters
 *  used by wincfg and winadmin
 *
 *  input  - PDCLASS
 *  output - PDPARAMS
 */
#define IOCTL_ICA_STACK_QUERY_PARAMS        _ICA_CTL_CODE( 22, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_SET_PARAMS
 *
 *  Set protocol or transport driver parameters
 *  used by wincfg and winadmin
 *
 *  input  - PDPARAMS
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SET_PARAMS          _ICA_CTL_CODE( 23, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_ENCRYPTION_OFF
 *
 *  Permanently turn stack encryption off
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_ENCRYPTION_OFF      _ICA_CTL_CODE( 24, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_ENCRYPTION_PERM
 *
 *  Permanently turn stack encryption on
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_ENCRYPTION_PERM     _ICA_CTL_CODE( 25, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CALLBACK_INITIATE
 *
 *  Initiate a modem callback
 *
 *  input  - ICA_STACK_CALLBACK
 *  output - nothing
 */
#define IOCTL_ICA_STACK_CALLBACK_INITIATE   _ICA_CTL_CODE( 26, METHOD_NEITHER )

typedef struct _ICA_STACK_CALLBACK {
    WCHAR PhoneNumber[ CALLBACK_LENGTH + 1 ];
} ICA_STACK_CALLBACK, *PICA_STACK_CALLBACK;


/*
 *  IOCTL_ICA_STACK_QUERY_LAST_ERROR
 *
 *  Query transport driver error code and message
 *
 *  input  - nothing
 *  output - ICA_STACK_LAST_ERROR
 */
#define IOCTL_ICA_STACK_QUERY_LAST_ERROR    _ICA_CTL_CODE( 27, METHOD_NEITHER )

#define MAX_ERRORMESSAGE 256
typedef struct _ICA_STACK_LAST_ERROR {
    ULONG Error;
    CHAR Message[ MAX_ERRORMESSAGE ];
} ICA_STACK_LAST_ERROR, *PICA_STACK_LAST_ERROR;


/*
 *  IOCTL_ICA_STACK_WAIT_FOR_STATUS
 *
 *  Wait for status change
 *  only valid with async transport driver
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_WAIT_FOR_STATUS     _ICA_CTL_CODE( 28, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_QUERY_STATUS
 *
 *  Query stack statistics
 *  - byte counts, signal status, error counts
 *
 *  input  - nothing
 *  output - PROTOCOLSTATUS
 */
#define IOCTL_ICA_STACK_QUERY_STATUS        _ICA_CTL_CODE( 29, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_REGISTER_HOTKEY
 *
 *  Register hotkey used to cancel shadow
 *  - a message will be sent on the "command" handle when the hotkey is detected
 *
 *  input  - ICA_STACK_HOTKEY
 *  output - nothing
 */
#define IOCTL_ICA_STACK_REGISTER_HOTKEY     _ICA_CTL_CODE( 30, METHOD_NEITHER )

typedef struct _ICA_STACK_HOTKEY {
    BYTE HotkeyVk;
    USHORT HotkeyModifiers;
} ICA_STACK_HOTKEY, *PICA_STACK_HOTKEY;


/*
 *  IOCTL_ICA_STACK_CANCEL_IO
 *
 *  Cancel all current and future I/O
 *  - no further i/o can be done on this stack
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_CANCEL_IO           _ICA_CTL_CODE( 31, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_QUERY_STATE
 *
 *  Query the stack driver state
 *  - use during reconnections
 *
 *  input  - nothing
 *  output - array of ICA_STACK_STATE_HEADER
 */
#define IOCTL_ICA_STACK_QUERY_STATE         _ICA_CTL_CODE( 32, METHOD_NEITHER )

/*
 *  Stack driver state header
 *
 *  ** this is a variable length data structure **
 */
typedef struct _ICA_STACK_STATE_HEADER {
    SDCLASS SdClass;   // type of stack driver
    ULONG DataLength;  // length of the following data
#ifdef COMPILERERROR
    BYTE Data[0];
#else
    BYTE * Data;
#endif
} ICA_STACK_STATE_HEADER, *PICA_STACK_STATE_HEADER;


/*
 *  IOCTL_ICA_STACK_SET_STATE
 *
 *  Set the stack driver state
 *  - use during reconnections
 *
 *  input  - array of ICA_STACK_STATE_HEADER
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SET_STATE           _ICA_CTL_CODE( 33, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME
 *
 *  Query last input time for inactivity timeout
 *
 *  input  - nothing
 *  output - ICA_STACK_LAST_INPUT_TIME
 */
#define IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME _ICA_CTL_CODE( 34, METHOD_NEITHER )

typedef struct _ICA_STACK_LAST_INPUT_TIME {
    LARGE_INTEGER LastInputTime;
} ICA_STACK_LAST_INPUT_TIME, *PICA_STACK_LAST_INPUT_TIME;


/*
 *  IOCTL_ICA_STACK_TRACE
 *
 *  Write trace record to winstation trace file
 *
 *  input  - ICA_TRACE_BUFFER
 *  output - nothing
 */
#define IOCTL_ICA_STACK_TRACE               _ICA_CTL_CODE( 35, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CALLBACK_COMPLETE
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_CALLBACK_COMPLETE   _ICA_CTL_CODE( 36, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_CD_CANCEL_IO
 *
 *  This is done before the connection driver is closed
 *  - releases tapi threads
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_CD_CANCEL_IO        _ICA_CTL_CODE( 37, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_QUERY_CLIENT
 *
 *  Query the client data
 *
 *  input  - nothing
 *  output - WINSTATIONCLIENTW
 */
#define IOCTL_ICA_STACK_QUERY_CLIENT        _ICA_CTL_CODE( 38, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_QUERY_MODULE_DATA
 *
 *  Query the client module data
 *
 *  input  - nothing
 *  output - (buffer containing all the C2H module data from the client)
 */
#define IOCTL_ICA_STACK_QUERY_MODULE_DATA   _ICA_CTL_CODE( 39, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_REGISTER_BROKEN
 *
 *  Register an event to be signaled when the stack connection is broken
 *
 *  input  - ICA_STACK_BROKEN
 *  output - nothing
 */
#define IOCTL_ICA_STACK_REGISTER_BROKEN     _ICA_CTL_CODE( 40, METHOD_NEITHER )

typedef struct _ICA_STACK_BROKEN {
    HANDLE BrokenEvent;
} ICA_STACK_BROKEN, *PICA_STACK_BROKEN;


/*
 *  IOCTL_ICA_STACK_ENABLE_IO
 *
 *  Enable I/O for a stack (used by shadow)
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_ENABLE_IO           _ICA_CTL_CODE( 41, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_DISABLE_IO
 *
 *  Disable I/O for a stack (used by shadow)
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_DISABLE_IO          _ICA_CTL_CODE( 42, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_SET_CONNECTED
 *
 *  Mark a stack as connected (used by shadow)
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SET_CONNECTED       _ICA_CTL_CODE( 43, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_SET_CLIENT_DATA
 *
 *  Send arbitrary data to the client
 *
 *  input  - ICA_STACK_CLIENT_DATA
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SET_CLIENT_DATA     _ICA_CTL_CODE( 44, METHOD_NEITHER )

typedef struct _ICA_STACK_CLIENT_DATA {
    CLIENTDATANAME DataName;
    BOOLEAN fUnicodeData;
    /* CHAR Data[]; Variable length data */
} ICA_STACK_CLIENT_DATA, *PICA_STACK_CLIENT_DATA;


/*
 *  IOCTL_ICA_STACK_QUERY_BUFFER
 *
 *  Get WD/TD buffer info
 *
 *  input  -
 *  output - ICA_STACK_QUERY_BUFFER
 */
#define IOCTL_ICA_STACK_QUERY_BUFFER        _ICA_CTL_CODE( 45, METHOD_NEITHER )

typedef struct _ICA_STACK_QUERY_BUFFER {
    ULONG   WdBufferCount;
    ULONG   TdBufferSize;
} ICA_STACK_QUERY_BUFFER, *PICA_STACK_QUERY_BUFFER;


/*
 *  IOCTL_ICA_STACK_DISCONNECT
 *
 *  Disconnect stack
 *
 *  input  - ICA_STACK_RECONNECT
 *  output - nothing
 */
#define IOCTL_ICA_STACK_DISCONNECT          _ICA_CTL_CODE( 46, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_RECONNECT
 *
 *  Reconnect stack to a new connection
 *
 *  input  - ICA_STACK_RECONNECT
 *  output - nothing
 */
#define IOCTL_ICA_STACK_RECONNECT           _ICA_CTL_CODE( 47, METHOD_NEITHER )

typedef struct _ICA_STACK_RECONNECT {
    HANDLE hIca;
    ULONG  sessionId;
} ICA_STACK_RECONNECT, *PICA_STACK_RECONNECT;

/*
 *  IOCTL_ICA_STACK_CONSOLE_CONNECT
 *
 *  Connect WinStation to Console session
 *
 *  Issued on a Console Stack
 *
 *  input  - nothing
 *  output - ICA_STACK_CONFIG  (optional)
 */
#define IOCTL_ICA_STACK_CONSOLE_CONNECT     _ICA_CTL_CODE( 48, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_SET_CONFIG
 *
 *  Set stack config information
 *
 *  input  - ICA_STACK_CONFIG_DATA
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SET_CONFIG          _ICA_CTL_CODE( 49, METHOD_NEITHER )

typedef struct _ICA_STACK_CONFIG_DATA {
    ULONG colorDepth : 3;
    ULONG fDisableEncryption : 1;
    ULONG encryptionLevel : 3;
    ULONG fDisableAutoReconnect : 1;
} ICA_STACK_CONFIG_DATA, *PICA_STACK_CONFIG_DATA;


/*=============================================================================
==   ICA Generic Channel IOCTLs
=============================================================================*/

/*
 *  IOCTL_ICA_CHANNEL_TRACE
 *
 *  Write trace record to winstation trace file
 *
 *  input  - ICA_TRACE_BUFFER
 *  output - nothing
 */
#define IOCTL_ICA_CHANNEL_TRACE             _ICA_CTL_CODE( 50, METHOD_NEITHER )


/*
 *  IOCTL_ICA_CHANNEL_ENABLE_SHADOW
 *
 *  Enable shadowing for this channel
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_CHANNEL_ENABLE_SHADOW     _ICA_CTL_CODE( 51, METHOD_NEITHER )

/*
 *  IOCTL_ICA_CHANNEL_END_SHADOW
 *
 *  End shadowing for this channel
 *
 *  input  - ICA_CHANNEL_END_SHADOW_DATA struct
 *  output - nothing
 */
#define IOCTL_ICA_CHANNEL_END_SHADOW        _ICA_CTL_CODE( 52, METHOD_NEITHER )

typedef struct _ICA_CHANNEL_END_SHADOW_DATA {
    NTSTATUS StatusCode;
    BOOLEAN  bLogError;
} ICA_CHANNEL_END_SHADOW_DATA, *PICA_CHANNEL_END_SHADOW_DATA;

/*
 *  IOCTL_ICA_CHANNEL_DISABLE_SHADOW
 *
 *  Disable shadowing for this channel
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_CHANNEL_DISABLE_SHADOW    _ICA_CTL_CODE( 53, METHOD_NEITHER )

/*
 *  IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO
 *
 *  Disable Keyboard and mouse IO from Help Session
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO        _ICA_CTL_CODE( 54, METHOD_NEITHER )

/*
 *  IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO
 *
 *  Enable Keyboard and mouse IO from Help Session
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO        _ICA_CTL_CODE( 55, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_SET_BROKENREASON
 *
 *  Sets the broken reason to the TD from user mode
 *  Used so that TD can report back the correct broken reason
 *
 *  input  - ICA_STACK_BROKENREASON
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SET_BROKENREASON           _ICA_CTL_CODE( 56, METHOD_NEITHER )

#define TD_USER_BROKENREASON_UNEXPECTED  0x0000
#define TD_USER_BROKENREASON_TERMINATING 0x0001

typedef struct _ICA_STACK_BROKENREASON {
    ULONG BrokenReason;
} ICA_STACK_BROKENREASON, *PICA_STACK_BROKENREASON;


/*=============================================================================
==   ICA Virtual IOCTLs
=============================================================================*/

#define IOCTL_ICA_VIRTUAL_LOAD_FILTER       _ICA_CTL_CODE( 60, METHOD_NEITHER )
#define IOCTL_ICA_VIRTUAL_UNLOAD_FILTER     _ICA_CTL_CODE( 61, METHOD_NEITHER )
#define IOCTL_ICA_VIRTUAL_ENABLE_FILTER     _ICA_CTL_CODE( 62, METHOD_NEITHER )
#define IOCTL_ICA_VIRTUAL_DISABLE_FILTER    _ICA_CTL_CODE( 63, METHOD_NEITHER )


/*
 *  IOCTL_ICA_VIRTUAL_BOUND
 *
 *  Check if there is a client bound to this virtual channel
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_VIRTUAL_BOUND             _ICA_CTL_CODE( 64, METHOD_NEITHER )


/*
 *  IOCTL_ICA_VIRTUAL_CANCEL_INPUT
 *
 *  Cancel input i/o on this virtual channel
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_VIRTUAL_CANCEL_INPUT      _ICA_CTL_CODE( 65, METHOD_NEITHER )


/*
 *  IOCTL_ICA_VIRTUAL_CANCEL_OUTPUT
 *
 *  Cancel output i/o on this virtual channel
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_VIRTUAL_CANCEL_OUTPUT     _ICA_CTL_CODE( 66, METHOD_NEITHER )


/*
 *  IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA
 *
 *  Query client module data for this virtual channel
 *
 *  input  - nothing
 *  output - module data (starts with common header VD_C2H)
 */
#define IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA _ICA_CTL_CODE( 67, METHOD_NEITHER )


/*
 *  IOCTL_ICA_VIRTUAL_QUERY_BINDINGS
 *
 *  Query virtual channel bindings for this winstaion
 *
 *  input  - nothing
 *  output - array of WD_VCBIND structures
 */
#define IOCTL_ICA_VIRTUAL_QUERY_BINDINGS    _ICA_CTL_CODE( 68, METHOD_NEITHER )


//-----------------------------------------------------------------------------
//
// Outcome of licensing protocol
//
// LICENSE_PROTOCOL_SUCCESS - Indicate that the licensing protocol has completed
// successfully.
//
//-----------------------------------------------------------------------------

#define LICENSE_PROTOCOL_SUCCESS        1


/*=============================================================================
==   ICA Licensing IOCTLs
=============================================================================*/
/*
 *  IOCTL_ICA_STACK_QUERY_LICENSE_CAPABILITIES
 *
 *  Query the client licensing capabilities
 *
 *  input  - nothing
 *  output - licensing capabilities structure
 */

#define IOCTL_ICA_STACK_QUERY_LICENSE_CAPABILITIES      _ICA_CTL_CODE( 69, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE
 *
 *  sending and receiving client licensing data
 *
 *  input  - licensing data to send
 *  output - licensing data received from client
 */

#define IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE          _ICA_CTL_CODE( 70, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_SEND_CLIENT_LICENSE
 *
 *  sending and licensing data
 *
 *  input  - licensing data to send
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SEND_CLIENT_LICENSE             _ICA_CTL_CODE( 71, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE
 *
 *  indicate whether the licensing protocol has completed successfully
 *
 *  input  - licensing protocol status
 *  output - nothing
 */
#define IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE       _ICA_CTL_CODE( 72, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_GET_LICENSE_DATA
 *
 *  retrieve the cached license data
 *
 *  input  - buffer to receive the licensing data
 *  output - number of bytes copied
 */
#define IOCTL_ICA_STACK_GET_LICENSE_DATA               _ICA_CTL_CODE( 73, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_SEND_KEEPALIVE_PDU
 *
 *  send a keepalive packet to the client to detect if a session is still alive
 *
 *  input - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_SEND_KEEPALIVE_PDU             _ICA_CTL_CODE( 74, METHOD_NEITHER)

// IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO
//
// Used for cluster-aware systems to query the protocol stack for client
// capabilities and information related to load balancing. Input to the
// IOCTL is null, output is TS_LOAD_BALANCE_INFO shown below.
#define IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO         _ICA_CTL_CODE(75, METHOD_NEITHER)

// This struct contains client-provided info pertaining to clustering.
// RequestedSessionID (and bRequestedSessionIDFieldValid) are used
// when the client has already been redirected by another server and
// has the session ID info for reconnection. Presence of this field
// implies we should not re-redirect the client. InitialProgram and
// ProtocolType are the same info as provided by the DoConnect parameter
// to WsxInitializeClientData(). and are used to filter sessions
// retieved from the cluster session directory.
typedef struct
{
    ULONG bClientSupportsRedirection : 1;
    ULONG bRequestedSessionIDFieldValid : 1;
    ULONG bClientRequireServerAddr : 1;
    ULONG RequestedSessionID;
    ULONG ClientRedirectionVersion;
    ULONG ProtocolType;  // PROTOCOL_ICA or PROTOCOL_RDP.
    WCHAR UserName[256];
    WCHAR Domain[128];
    WCHAR Password[128];
    WCHAR InitialProgram[256];
} TS_LOAD_BALANCE_INFO, *PTS_LOAD_BALANCE_INFO;


// IOCTL_TS_STACK_SEND_CLIENT_REDIRECTION
//
// Used for cluster-aware clients to force-reconnect the client to a different
// server. Input is TS_CLIENT_REDIRECTION_INFO below, output is null.
#define IOCTL_TS_STACK_SEND_CLIENT_REDIRECTION         _ICA_CTL_CODE(76, METHOD_NEITHER)

/*
 *  IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED
 *
 *  Query the client data for Long UserName, Password and Domain
 *
 *  input  - nothing
 *  output - ExtendedClientCredentials
 */
#define IOCTL_ICA_STACK_QUERY_CLIENT_EXTENDED        _ICA_CTL_CODE( 77, METHOD_NEITHER )

/*
 *  IOCTL_TS_STACK_QUERY_REMOTEADDRESS
 *
 *  Query for the client IP address
 *
 *  input  - <endpoint data>
 *  output - sockaddr structure
 */
#define IOCTL_TS_STACK_QUERY_REMOTEADDRESS          _ICA_CTL_CODE( 78, METHOD_NEITHER )

/*
 *  IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL
 *
 *  Used to close the Command channel when we terminate a WinStation. 
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL        _ICA_CTL_CODE( 79, METHOD_NEITHER )

/*
 *  IOCTL_ICA_STACK_QUERY_AUTORECONNECT
 *
 *  Queries for Client->Server or Server->Client autoreconnect info
 *
 *  input  - BOOL set TRUE to get S->C info. False to get C->S
 *  output - AutoReconnect info
 */
#define IOCTL_ICA_STACK_QUERY_AUTORECONNECT             _ICA_CTL_CODE( 81, METHOD_NEITHER )



typedef struct
{
    ULONG SessionID;
    ULONG Flags;
#define TARGET_NET_ADDRESS      0x1
#define LOAD_BALANCE_INFO       0x2
#define LB_USERNAME             0x4
#define LB_DOMAIN               0x8
#define LB_PASSWORD             0x10
    // For each variable length field, the format is like:
    // ULONG Length
    // BYTE  Data[]
} TS_CLIENT_REDIRECTION_INFO;


/*=============================================================================
== Keyboard IOCTLs
=============================================================================*/

/*
 *  IOCTL_KEYBOARD_ICA_INPUT
 *
 *  Simulate keyboard input
 *
 *  input  - array of KEYBOARD_INPUT_DATA structures
 *  output - nothing
 */
#define IOCTL_KEYBOARD_ICA_INPUT            _ICA_CTL_CODE( 0x200, METHOD_NEITHER )


/*
 *  IOCTL_KEYBOARD_ICA_LAYOUT
 *
 *  Send keyboard layout from Win32K to WD
 *
 *  input  - buffer containing keyboard layout
 *  output - nothing
 */
#define IOCTL_KEYBOARD_ICA_LAYOUT           _ICA_CTL_CODE( 0x201, METHOD_NEITHER )


/*
 *  IOCTL_KEYBOARD_ICA_SCANMAP
 *
 *  Send keyboard scan map from Win32K to WD
 *
 *  input  - buffer containing keyboard scan map
 *  output - nothing
 */
#define IOCTL_KEYBOARD_ICA_SCANMAP          _ICA_CTL_CODE( 0x202, METHOD_NEITHER )


/*
 *  IOCTL_KEYBOARD_ICA_TYPE
 *
 *  Send keyboard type from Win32K to WD
 *
 *  input  - buffer containing keyboard type
 *  output - nothing
 */
#define IOCTL_KEYBOARD_ICA_TYPE             _ICA_CTL_CODE( 0x203, METHOD_NEITHER )



/*=============================================================================
==   ICA Mouse IOCTLs
=============================================================================*/

/*
 *  IOCTL_MOUSE_ICA_INPUT
 *
 *  Simulate mouse input
 *
 *  input  - array of MOUSE_INPUT_DATA structures
 *  output - nothing
 */
#define IOCTL_MOUSE_ICA_INPUT               _ICA_CTL_CODE( 0x300, METHOD_NEITHER )



/*=============================================================================
==   ICA Video IOCTLs
=============================================================================*/

#define IOCTL_VIDEO_ICA_QUERY_FONT_PAIRS      _ICA_CTL_CODE( 0x400, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_ENABLE_GRAPHICS       _ICA_CTL_CODE( 0x401, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_DISABLE_GRAPHICS      _ICA_CTL_CODE( 0x402, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_SET_CP                _ICA_CTL_CODE( 0x403, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_STOP_OK               _ICA_CTL_CODE( 0x404, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_REVERSE_MOUSE_POINTER _ICA_CTL_CODE( 0x405, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_COPY_FRAME_BUFFER     _ICA_CTL_CODE( 0x406, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_WRITE_TO_FRAME_BUFFER _ICA_CTL_CODE( 0x407, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_INVALIDATE_MODES      _ICA_CTL_CODE( 0x408, METHOD_BUFFERED )
#define IOCTL_VIDEO_ICA_SCROLL                _ICA_CTL_CODE( 0x409, METHOD_BUFFERED )


/*
 *  IOCTL_ICA_STACK_SECURE_DESKTOP_ENTER
 *
 *  Turn encryption on if enabled. SAS desktop is going up.
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_ENCRYPTION_ENTER      _ICA_CTL_CODE( 0x410, METHOD_NEITHER )


/*
 *  IOCTL_ICA_STACK_SECURE_DESKTOP_EXIT
 *
 *  Turn encryption off if enabled. SAS desktop is going away.
 *
 *  input  - nothing
 *  output - nothing
 */
#define IOCTL_ICA_STACK_ENCRYPTION_EXIT     _ICA_CTL_CODE( 0x411, METHOD_NEITHER )


/*
 *  IOCTL_VIDEO_CREATE_THREAD
 *
 *  Called by video driver to create a worker thread
 *
 *  input  - PVIDEO_ICA_CREATE_THREAD
 *  output - nothing
 */
#define IOCTL_VIDEO_CREATE_THREAD       _ICA_CTL_CODE( 0x412, METHOD_BUFFERED )


/*
 *  IOCTL_ICA_MVGA_
 *
 *  Used by Direct ICA
 *
 */
#define IOCTL_ICA_MVGA_GET_INFO                  _ICA_CTL_CODE( 0x420, METHOD_BUFFERED )
#define IOCTL_ICA_MVGA_VIDEO_SET_CURRENT_MODE    _ICA_CTL_CODE( 0x421, METHOD_BUFFERED )
#define IOCTL_ICA_MVGA_VIDEO_MAP_VIDEO_MEMORY    _ICA_CTL_CODE( 0x422, METHOD_BUFFERED )
#define IOCTL_ICA_MVGA_VIDEO_UNMAP_VIDEO_MEMORY  _ICA_CTL_CODE( 0x423, METHOD_BUFFERED )

/*
 * IOCTL_SD_MODULE_INIT
 *
 * Initialize a newly loaded WD/PD/TD module. This returns the
 * modules private interface pointers for direct calling between
 * the drivers. These pointers are valid until NtUnloadDriver()
 * is called on the module.
 *
 * This is only available from kernel mode IRP_MJ_INTERNAL_DEVICE_CONTROL.
 */

#define IOCTL_SD_MODULE_INIT  _ICA_CTL_CODE( 3000, METHOD_NEITHER )

typedef struct _SD_MODULE_INIT {
    PVOID SdLoadProc;
} SD_MODULE_INIT, *PSD_MODULE_INIT;

#ifndef _WINCON_

typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

#ifdef _DEFCHARINFO_
typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    USHORT Attributes;
} CHAR_INFO, *PCHAR_INFO;

typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;
#endif

#endif // _WINCON_

typedef struct _ICA_FONT_PAIR {
    ULONG Index;
    ULONG Rows;
    ULONG Columns;
    ULONG ResolutionX;
    ULONG ResolutionY;
    ULONG FontSizeX;
    ULONG FontSizeY;
} ICA_FONT_PAIR, *PICA_FONT_PAIR;

typedef struct _VIDEO_ICA_MODE_FONT_PAIR {
    ULONG Count;
#ifdef COMPILERERROR
    ICA_FONT_PAIR FontPair[0];
#else
    ICA_FONT_PAIR* FontPair;
#endif
} VIDEO_ICA_MODE_FONT_PAIR, *PVIDEO_ICA_MODE_FONT_PAIR;

typedef struct _VIDEO_ICA_SET_CP {
    ULONG CodePage;
    ULONG TextModeIndex;
} VIDEO_ICA_SET_CP, *PVIDEO_ICA_SET_CP;

typedef struct _VIDEO_ICA_COPY_FRAME_BUFFER {
    ULONG DestFrameBufOffset;
    ULONG SourceFrameBufOffset;
    ULONG ByteCount;
} VIDEO_ICA_COPY_FRAME_BUFFER, *PVIDEO_ICA_COPY_FRAME_BUFFER;

typedef struct _VIDEO_ICA_WRITE_TO_FRAME_BUFFER {
    PCHAR_INFO pBuffer;
    ULONG ByteCount;
    ULONG FrameBufOffset;
} VIDEO_ICA_WRITE_TO_FRAME_BUFFER, *PVIDEO_ICA_WRITE_TO_FRAME_BUFFER;

typedef enum _ICASCROLLCLASS {
    IcaScrollScreenUp,
    IcaScrollRect,
    IcaScrollNothing,
} ICASCROLLCLASS;

typedef struct _VIDEO_ICA_SCROLL {
    SMALL_RECT ScrollRect;
    SMALL_RECT MergeRect1;
    SMALL_RECT MergeRect2;
    COORD TargetPoint;
    CHAR_INFO Fill;
    ICASCROLLCLASS Type;
} VIDEO_ICA_SCROLL, * PVIDEO_ICA_SCROLL;

typedef struct _VIDEO_ICA_CREATE_THREAD {
    PVOID ThreadAddress;
    ULONG ThreadPriority;
    PVOID ThreadContext;
} VIDEO_ICA_CREATE_THREAD, * PVIDEO_ICA_CREATE_THREAD;


/*=============================================================================
== Command Channel
=============================================================================*/

/*
 * Command Channel functions
 */
#define ICA_COMMAND_BROKEN_CONNECTION       1
#define ICA_COMMAND_REDRAW_RECTANGLE        2   // SetFocus
#define ICA_COMMAND_REDRAW_SCREEN           3   // SetFocus
#define ICA_COMMAND_STOP_SCREEN_UPDATES     4   // KillFocus
#define ICA_COMMAND_SOFT_KEYBOARD           5
#define ICA_COMMAND_SHADOW_HOTKEY           6
#define ICA_COMMAND_DISPLAY_IOCTL           7

/*
 *  Common header for all command channel functions
 */
typedef struct _ICA_COMMAND_HEADER {
    UCHAR Command;
} ICA_COMMAND_HEADER, *PICA_COMMAND_HEADER;


/*
 *  Broken connection requests
 */
typedef enum _BROKENCLASS {
    Broken_Unexpected = 1,
    Broken_Disconnect,
    Broken_Terminate,
} BROKENCLASS;

typedef enum _BROKENSOURCECLASS {
    BrokenSource_User = 1,
    BrokenSource_Server,
} BROKENSOURCECLASS;

/*
 *  ICA_COMMAND_BROKEN_CONNECTION
 */
typedef struct _ICA_BROKEN_CONNECTION {
    BROKENCLASS Reason;
    BROKENSOURCECLASS Source;
} ICA_BROKEN_CONNECTION, *PICA_BROKEN_CONNECTION;

/*
 *  ICA_COMMAND_REDRAW_RECTANGLE
 */
typedef struct _ICA_REDRAW_RECTANGLE {
    SMALL_RECT Rect;
} ICA_REDRAW_RECTANGLE, *PICA_REDRAW_RECTANGLE;

/*
 *  ICA_COMMAND_SOFT_KEYBOARD
 */
typedef struct _ICA_SOFT_KEYBOARD {
    ULONG SoftKeyCmd;
} ICA_SOFT_KEYBOARD, *PICA_SOFT_KEYBOARD;

/*
 *  ICA_COMMAND_DISPLAY_IOCTL
 */
#define MAX_DISPLAY_IOCTL_DATA     2041
#define DISPLAY_IOCTL_FLAG_REDRAW   0x1

typedef struct _ICA_DISPLAY_IOCTL {
    ULONG DisplayIOCtlFlags;
    ULONG cbDisplayIOCtlData;
    UCHAR DisplayIOCtlData[ MAX_DISPLAY_IOCTL_DATA ];
} ICA_DISPLAY_IOCTL, *PICA_DISPLAY_IOCTL;

/*
 *  ICA Channel Commands
 */
typedef struct _ICA_CHANNEL_COMMAND {
    ICA_COMMAND_HEADER Header;
    union {
        ICA_BROKEN_CONNECTION BrokenConnection;
        ICA_REDRAW_RECTANGLE RedrawRectangle;
        ICA_SOFT_KEYBOARD SoftKeyboard;
        ICA_DISPLAY_IOCTL DisplayIOCtl;
    };
} ICA_CHANNEL_COMMAND, *PICA_CHANNEL_COMMAND;

/*
 *  ICA_DEVICE_BITMAP_INFO
 *
 */
typedef struct _ICA_DEVICE_BITMAP_INFO {
    LONG cx;
    LONG cy;
} ICA_DEVICE_BITMAP_INFO, *PICA_DEVICE_BITMAP_INFO;

/*=============================================================================
==   Tracing
=============================================================================*/

/*
 *  IcaTrace - Trace Class
 */
#define TC_ICASRV       0x00000001          // ica service
#define TC_ICAAPI       0x00000002          // icadd interface dll
#define TC_ICADD        0x00000004          // ica device driver
#define TC_WD           0x00000008          // winstation driver
#define TC_CD           0x00000010          // connection driver
#define TC_PD           0x00000020          // protocol driver
#define TC_TD           0x00000040          // transport driver
#define TC_RELIABLE     0x00000100          // reliable protocol driver
#define TC_FRAME        0x00000200          // frame protocol driver
#define TC_COMP         0x00000400          // compression
#define TC_CRYPT        0x00000800          // encryption
#define TC_TW           0x10000000          // thinwire
#define TC_DISPLAY      0x10000000          // display driver
#define TC_WFSHELL      0x20000000
#define TC_WX           0x40000000          // winstation extension
#define TC_LOAD         0x80000000          // load balancing 
#define TC_ALL          0xffffffff          // everything

/*
 *  IcaTrace - Trace Type
 */
#define TT_API1         0x00000001          // api level 1
#define TT_API2         0x00000002          // api level 2
#define TT_API3         0x00000004          // api level 3
#define TT_API4         0x00000008          // api level 4
#define TT_OUT1         0x00000010          // output level 1
#define TT_OUT2         0x00000020          // output level 2
#define TT_OUT3         0x00000040          // output level 3
#define TT_OUT4         0x00000080          // output level 4
#define TT_IN1          0x00000100          // input level 1
#define TT_IN2          0x00000200          // input level 2
#define TT_IN3          0x00000400          // input level 3
#define TT_IN4          0x00000800          // input level 4
#define TT_ORAW         0x00001000          // raw output data
#define TT_IRAW         0x00002000          // raw input data
#define TT_OCOOK        0x00004000          // cooked output data
#define TT_ICOOK        0x00008000          // cooked input data
#define TT_SEM          0x00010000          // semaphores
#define TT_NONE         0x10000000          // only view errors
#define TT_ERROR        0xffffffff          // error condition


/*
 * RDP Display Driver: DrvEscape escape numbers
 */
#define ESC_TIMEROBJ_SIGNALED        0x01
#define ESC_SET_WD_TIMEROBJ          0x02
#define ESC_GET_DEVICEBITMAP_SUPPORT 0x05

/*=============================================================================
==
 Optional Channel Write IRP Flags.  These are passed by reference to a ULONG value, 
 in the first field of the IRP.Tail.Overlay.DriverContext array for channel IRP_MJ_WRITE 
 IRP's.  See IcaWriteChannel for details.
============================================================================*/
#define CHANNEL_WRITE_LOWPRIO  0x00000001  // Write can block behind
                                           //  default priority writes.

#endif //ICADDH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\icaipx.h ===
/***************************************************************************
*
*   ICAIPX.H
*
*   This file contains definitions for the ICA 3.0/IPX Protocol (tdipx)
*
**  
****************************************************************************/

#ifndef __ICAIPX_H__
#define __ICAIPX_H__

/*=============================================================================
==   Defines 
=============================================================================*/

/*
 * Initial connection defines
 *
 * The buffer is 128 bytes big.  The first characters are the following
 * strings.  The version number is returned in byte 64.
 */

#define ICA_2_IPX_VERSION         0x01  //  ICA 2.0 IPX Connection
#define ICA_3_IPX_VERSION         0x02  //  ICA 3.0 IPX Connection
#define CALL_BUFFER_SIZE           128
#define CALL_CLIENT_IPX_VERSION     64
#define CALL_HOST_IPX_VERSION       65
#define CALL_CLIENT_SEQUENCE_ENABLE 66
#define CALL_HOST_SEQUENCE_ENABLE   67
#define CONNECTION_STRING          "Citrix IPX Connection Packet"
#define CONNECTION_STRING_REPLY    "Reply to Citrix IPX Connection Packet"


/*
 *  IPX Packet Types
 */

#define IPX_TYPE_CONTROL                0x00
#define IPX_TYPE_DATA                   0x04


/*
 * IPX Control Packet Types.
 */

#define IPX_CTRL_PACKET_HANGUP          0xff
#define IPX_CTRL_PACKET_CANCEL          0x01
#define IPX_CTRL_PACKET_PING            0x02
#define IPX_CTRL_PACKET_PING_RESP       0x03

/*
 *  SAP ID - Citrix Application Server for NT
 */

#define CITRIX_APPLICATION_SERVER       0x083d
#define CITRIX_APPLICATION_SERVER_SWAP  0x3d08  // byte swapped

#endif //__ICAIPX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\oemtdapi.h ===
/*******************************************************************************
*
* OEMTDAPI.H
*
*   WinFrame OEM Transport Driver API support - 
*       function prototypes that must be supported by a WinFrame OEM
*       Transport Driver
*
*   Copyright Microsoft Corporation, 1998
*
*
*******************************************************************************/

/*******************************************************************************
 *
 *  OemTdEnumerateDevicesW
 *
 *      Enumerate all devices supported by this OEM Transport Driver
 *
 * ENTRY:
 *      ppBuffer (output)
 *          points to a variable to reference the API-allocated buffer which
 *          will contain a MULTI-SZ formatted list of devices supported by 
 *          this OEM Transport Driver.  Set to NULL on error.
 *
 * EXIT:
 *      ERROR_SUCCESS - enumeration was sucessful
 *      error code - enumeration failed
 *
 * NOTE:  The buffer allocated by this API will contain all devices that are
 *        supported by this OEM Transport Driver, in MULTI-SZ format (each
 *        device name is nul terminated with an extra nul character following
 *        the last name).  The caller must call OemTdConfigFreeBufferW() to 
 *        free the memory allocated for this buffer when it is done using it.
 *
 ******************************************************************************/

LONG
WINAPI
OemTdEnumerateDevicesW( LPWSTR *ppBuffer );

typedef LONG (WINAPI * PFNOEMTDENUMERATEDEVICESW)( LPWSTR * );
#define OEMTDENUMERATEDEVICESW  "OemTdEnumerateDevicesW"


/*******************************************************************************
 *
 *  OemTdFreeBufferW
 *
 *     Frees memory allocated from above OemTd APIs. 
 *
 * ENTRY:
 *    pBuffer
 *       pointer to memory to be freed                                
 *
 * EXIT: none
 *
 ******************************************************************************/

VOID
WINAPI
OemTdFreeBufferW( LPWSTR pBuffer );

typedef VOID (WINAPI * PFNOEMTDFREEBUFFERW)( LPWSTR );
#define OEMTDFREEBUFFERW  "OemTdFreeBufferW"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\hydrix.h ===
/******************************************************************************
*
*   HYDRIX.H
*
*   This file contains definitions for the TerminalServer base.
*
*   Copyright Microsoft Corporation 1998
*
*******************************************************************************/

#ifndef __HYDRIX_H__
#define __HYDRIX_H__

#pragma pack(1)


/*=============================================================================
==   Client Modules
=============================================================================*/

/*
 *  Maximum lengths
 */
#define MAX_BR_NAME              65  // maximum length of browser name (including null)
#define DOMAIN_LENGTH            17
#define USERNAME_LENGTH          20
#define PASSWORD_LENGTH          14
#define CLIENTNAME_LENGTH        20
#define CLIENTADDRESS_LENGTH     30
#define CLIENTLICENSE_LENGTH     32
#define DIRECTORY_LENGTH         256
#define INITIALPROGRAM_LENGTH    256
#define CLIENTLICENSE_LENGTH     32
#define CLIENTMODEM_LENGTH       40
#define IMEFILENAME_LENGTH       32


/*=============================================================================
==   Protocol Drivers - Common data structures
=============================================================================*/

/*
 *  stack driver classes
 *
 *  NOTE: don't change the order of this structure it will break
 *  NOTE: the Client.  Also, any additions to this structure must
 *  NOTE: be reflected into the PDCLASS in ICA.H or else we're SOL.
 */
typedef enum _SDCLASS {
    SdNone,            // 0
    SdConsole,         // 1  no dll
    SdNetwork,         // 2  tdnetb.dll, tdspx.dll, tdftp.dll tdipx.dll
    SdAsync,           // 3  tdasync.dll
    SdOemTransport,    // 4  user transport driver
    SdISDN,            // 5  not implemented
    SdX25,             // 6  not implemented
    SdModem,           // 7  pdmodem.dll
    SdOemConnect,      // 8  user protocol driver
    SdFrame,           // 9  pdframe.dll
    SdReliable,        // 10 pdreli.dll
    SdEncrypt,         // 11 pdcrypt1.dll
    SdCompress,        // 12 pdcomp.dll
    SdTelnet,          // 13 not implemented
    SdOemFilter,       // 14 user protocol driver
    SdNasi,            // 15 tdnasi.dll
    SdTapi,            // 16 pdtapi.dll
    SdReserved1,       // 17
    SdReserved2,       // 18
    SdReserved3,       // 19
    SdClass_Maximum,   // 20 must be last
} SDCLASS;


/*=============================================================================
==   Client Data - Common data structures
=============================================================================*/

/*
 *  Client Data Name
 */
#define CLIENTDATANAME_LENGTH  7

typedef CHAR CLIENTDATANAME[ CLIENTDATANAME_LENGTH + 1 ];  // includes null
typedef CHAR * PCLIENTDATANAME;

/*
 *  Client data names  (CLIENTDATANAME)
 *
 *  name syntax:  xxxyyyy<null>
 *
 *    xxx    - oem id (CTX - Citrix Systems)
 *    yyyy   - client data name
 *    <null> - trailing null
 */

#define CLIENTDATA_SERVER      "CTXSRVR"   // WF Server Name
#define CLIENTDATA_USERNAME    "CTXUSRN"   // WF User Name
#define CLIENTDATA_DOMAIN      "CTXDOMN"   // WF User Domain Name


/*=============================================================================
==   Transport Driver - Common data structures
=============================================================================*/

#define VERSION_HOSTL_TDASYNC   1
#define VERSION_HOSTH_TDASYNC   1

#define VERSION_HOSTL_TDNETB    1
#define VERSION_HOSTH_TDNETB    1

#define VERSION_HOSTL_TDSPX     1
#define VERSION_HOSTH_TDSPX     1

#define VERSION_HOSTL_TDIPX     1
#define VERSION_HOSTH_TDIPX     1

#define VERSION_HOSTL_TDTCP     1
#define VERSION_HOSTH_TDTCP     1


/*=============================================================================
==   Winstation Drivers - Common data structures
=============================================================================*/

/*
 *  Valid full screen row/column combinations
 */
typedef struct _FSTEXTMODE {
    BYTE Index;            // this value is sent by PACKET_SET_VIDEOMODE
    BYTE Flags;            // Used by the client
    USHORT Columns;
    USHORT Rows;
    USHORT ResolutionX;
    USHORT ResolutionY;
    BYTE FontSizeX;
    BYTE FontSizeY;
} FSTEXTMODE, * PFSTEXTMODE;


/*=============================================================================
==   Virtual Drivers - Common data structures
=============================================================================*/

/*
 *  Virtual Channel Name
 */
#define VIRTUALCHANNELNAME_LENGTH  7

typedef CHAR VIRTUALCHANNELNAME[ VIRTUALCHANNELNAME_LENGTH + 1 ];  // includes null
typedef CHAR * PVIRTUALCHANNELNAME;

typedef LONG VIRTUALCHANNELCLASS;
typedef LONG * PVIRTUALCHANNELCLASS;

#define VIRTUAL_THINWIRE  "CTXTW  "   // remote windows data
#define VIRTUAL_MAXIMUM   32    // number of virtual channels

/*
 *  Structure used to bind virtual channel name to number
 */
typedef struct _SD_VCBIND {
    VIRTUALCHANNELNAME VirtualName;
    USHORT VirtualClass;
	ULONG  Flags;
} SD_VCBIND, * PSD_VCBIND;

/*
 *  Flags passed along with binding info
 */
#define SD_CHANNEL_FLAG_SHADOW_PERSISTENT	0x00000001

#pragma pack()

#endif //__HYDRIX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\pchannel.h ===
/****************************************************************************/
/* Header:    pchannel.h                                                    */
/*                                                                          */
/* Purpose:   Virtual Channel protocol header - VC stuff common to Client & */
/*            Server                                                        */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1999                                  */
/*                                                                          */
/****************************************************************************/

#ifndef _H_PCHANNEL
#define _H_PCHANNEL

/****************************************************************************/
/* Maximum amount of data that is sent in one operation.  Data larger than  */
/* this is segmented into chunks of this size and sent as multiple          */
/* operations.                                                              */
/****************************************************************************/
#define CHANNEL_CHUNK_LENGTH    1600

#define CHANNEL_PDU_LENGTH (CHANNEL_CHUNK_LENGTH + sizeof(CHANNEL_PDU_HEADER))

/****************************************************************************/
/* Header flags (also passed to VirtualChannelOpenEventFn)                  */
/****************************************************************************/
#define CHANNEL_FLAG_FIRST      0x01
#define CHANNEL_FLAG_LAST       0x02
#define CHANNEL_FLAG_ONLY       (CHANNEL_FLAG_FIRST | CHANNEL_FLAG_LAST)
#define CHANNEL_FLAG_MIDDLE     0

#define CHANNEL_FLAG_FAIL       0x100

/****************************************************************************/
/* Header flags (internal protocol use only)                                */
/****************************************************************************/
#define CHANNEL_FLAG_SHOW_PROTOCOL 0x10
#define CHANNEL_FLAG_SUSPEND       0x20
#define CHANNEL_FLAG_RESUME        0x40
#define CHANNEL_FLAG_SHADOW_PERSISTENT 0x80

/****************************************************************************/
/* Virtual Channel options, passed by Client on VirtualChannelOpen          */
/****************************************************************************/

/****************************************************************************/
/* Application is initialized.  If this flag is not set, a virtual channel  */
/* is not established for this application                                  */
/****************************************************************************/
#define CHANNEL_OPTION_INITIALIZED  0x80000000

/****************************************************************************/
/* Encrypt according to RDP data encryption (ie if RDP data is encrypted,   */
/* do so for this virtual channel too)                                      */
/****************************************************************************/
#define CHANNEL_OPTION_ENCRYPT_RDP  0x40000000

/****************************************************************************/
/* Encrypt Server to Client data (ignored if CHANNEL_OPTION_ENCRYPT_RDP is  */
/* set)                                                                     */
/****************************************************************************/
#define CHANNEL_OPTION_ENCRYPT_SC   0x20000000

/****************************************************************************/
/* Encrypt Client to Server data (ignored if CHANNEL_OPTION_ENCRYPT_RDP is  */
/* set)                                                                     */
/****************************************************************************/
#define CHANNEL_OPTION_ENCRYPT_CS   0x10000000

/****************************************************************************/
/* Send data at high priority (not recommended, as this may impact RDP      */
/* performance)                                                             */
/****************************************************************************/
#define CHANNEL_OPTION_PRI_HIGH     0x08000000

/****************************************************************************/
/* Send data at medium priority                                             */
/****************************************************************************/
#define CHANNEL_OPTION_PRI_MED      0x04000000

/****************************************************************************/
/* Send data at low priority                                                */
/****************************************************************************/
#define CHANNEL_OPTION_PRI_LOW      0x02000000

/****************************************************************************/
/* Compress data in this virtual channel if RDP data compression is         */
/* configured for this connection                                           */
/****************************************************************************/
#define CHANNEL_OPTION_COMPRESS_RDP 0x00800000

/****************************************************************************/
/* Compress data in this virtual channel, irrespective of RDP data          */
/* compression (ignored if CHANNEL_OPTION_COMPRESS_RDP is set)              */
/****************************************************************************/
#define CHANNEL_OPTION_COMPRESS     0x00400000

/****************************************************************************/
/* Show Server addins the full Virtual Channel protocol.  This option       */
/* affects how data passed to VirtualChannelWrite is presented to Server    */
/* addins.                                                                  */
/*                                                                          */
/* - If this option is set, Server addins see the full Virtual Channel      */
/* protocol, including CHANNEL_PDU_HEADER (below).                          */
/*                                                                          */
/* -If this option is not set, Server addins see just the data passed to    */
/* VirtualChannelWrite                                                      */
/****************************************************************************/
#define CHANNEL_OPTION_SHOW_PROTOCOL 0x00200000

/****************************************************************************/
/* Specify that this channel is persistent accross remote control           */
/* transitions.                                                             */
/****************************************************************************/
#define CHANNEL_OPTION_REMOTE_CONTROL_PERSISTENT 0x00100000

/****************************************************************************/
/* Maximum number and size of channel names                                 */
/****************************************************************************/
#define CHANNEL_MAX_COUNT           30
#define CHANNEL_NAME_LEN             7

/****************************************************************************/
/* Structure: CHANNEL_DEF                                                   */
/*                                                                          */
/* Description: Client to Server virtual channel information                */
/* - name       channel name                                                */
/* - options    channel options (a combination of the CHANNEL_OPTION        */
/*              constants above)                                            */
/****************************************************************************/
typedef struct tagCHANNEL_DEF
{
    char            name[CHANNEL_NAME_LEN + 1];
    ULONG           options;
} CHANNEL_DEF;
typedef CHANNEL_DEF UNALIGNED FAR *PCHANNEL_DEF;
typedef PCHANNEL_DEF UNALIGNED FAR *PPCHANNEL_DEF;

/****************************************************************************/
/* Header of Virtual Channel PDUs                                           */
/****************************************************************************/
/****************************************************************************/
/* Structure: CHANNEL_PDU_HEADER                                            */
/*                                                                          */
/* Description: Header sent on Virtual Channel PDUs                         */
/****************************************************************************/
typedef struct tagCHANNEL_PDU_HEADER
{
    UINT32    length;                 /* Length of data including header    */
    UINT32    flags;                  /* CHANNEL_FLAG_xxx flags             */
} CHANNEL_PDU_HEADER, FAR * PCHANNEL_PDU_HEADER;
/****************************************************************************/

#endif /* _H_PCHANNEL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdchost.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdchost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rdchost_h__
#define __rdchost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDataChannelIO_FWD_DEFINED__
#define __IDataChannelIO_FWD_DEFINED__
typedef interface IDataChannelIO IDataChannelIO;
#endif 	/* __IDataChannelIO_FWD_DEFINED__ */


#ifndef __ISAFRemoteDesktopClient_FWD_DEFINED__
#define __ISAFRemoteDesktopClient_FWD_DEFINED__
typedef interface ISAFRemoteDesktopClient ISAFRemoteDesktopClient;
#endif 	/* __ISAFRemoteDesktopClient_FWD_DEFINED__ */


#ifndef __ISAFRemoteDesktopClientHost_FWD_DEFINED__
#define __ISAFRemoteDesktopClientHost_FWD_DEFINED__
typedef interface ISAFRemoteDesktopClientHost ISAFRemoteDesktopClientHost;
#endif 	/* __ISAFRemoteDesktopClientHost_FWD_DEFINED__ */


#ifndef __ISAFRemoteDesktopTestExtension_FWD_DEFINED__
#define __ISAFRemoteDesktopTestExtension_FWD_DEFINED__
typedef interface ISAFRemoteDesktopTestExtension ISAFRemoteDesktopTestExtension;
#endif 	/* __ISAFRemoteDesktopTestExtension_FWD_DEFINED__ */


#ifndef ___ISAFRemoteDesktopDataChannelEvents_FWD_DEFINED__
#define ___ISAFRemoteDesktopDataChannelEvents_FWD_DEFINED__
typedef interface _ISAFRemoteDesktopDataChannelEvents _ISAFRemoteDesktopDataChannelEvents;
#endif 	/* ___ISAFRemoteDesktopDataChannelEvents_FWD_DEFINED__ */


#ifndef __SAFRemoteDesktopClientHost_FWD_DEFINED__
#define __SAFRemoteDesktopClientHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAFRemoteDesktopClientHost SAFRemoteDesktopClientHost;
#else
typedef struct SAFRemoteDesktopClientHost SAFRemoteDesktopClientHost;
#endif /* __cplusplus */

#endif 	/* __SAFRemoteDesktopClientHost_FWD_DEFINED__ */


#ifndef __ClientDataChannel_FWD_DEFINED__
#define __ClientDataChannel_FWD_DEFINED__

#ifdef __cplusplus
typedef class ClientDataChannel ClientDataChannel;
#else
typedef struct ClientDataChannel ClientDataChannel;
#endif /* __cplusplus */

#endif 	/* __ClientDataChannel_FWD_DEFINED__ */


#ifndef __ClientRemoteDesktopChannelMgr_FWD_DEFINED__
#define __ClientRemoteDesktopChannelMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class ClientRemoteDesktopChannelMgr ClientRemoteDesktopChannelMgr;
#else
typedef struct ClientRemoteDesktopChannelMgr ClientRemoteDesktopChannelMgr;
#endif /* __cplusplus */

#endif 	/* __ClientRemoteDesktopChannelMgr_FWD_DEFINED__ */


#ifndef ___ISAFRemoteDesktopClientEvents_FWD_DEFINED__
#define ___ISAFRemoteDesktopClientEvents_FWD_DEFINED__
typedef interface _ISAFRemoteDesktopClientEvents _ISAFRemoteDesktopClientEvents;
#endif 	/* ___ISAFRemoteDesktopClientEvents_FWD_DEFINED__ */


#ifndef ___IDataChannelIOEvents_FWD_DEFINED__
#define ___IDataChannelIOEvents_FWD_DEFINED__
typedef interface _IDataChannelIOEvents _IDataChannelIOEvents;
#endif 	/* ___IDataChannelIOEvents_FWD_DEFINED__ */


#ifndef __SAFRemoteDesktopClient_FWD_DEFINED__
#define __SAFRemoteDesktopClient_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAFRemoteDesktopClient SAFRemoteDesktopClient;
#else
typedef struct SAFRemoteDesktopClient SAFRemoteDesktopClient;
#endif /* __cplusplus */

#endif 	/* __SAFRemoteDesktopClient_FWD_DEFINED__ */


#ifndef __TSRDPRemoteDesktopClient_FWD_DEFINED__
#define __TSRDPRemoteDesktopClient_FWD_DEFINED__

#ifdef __cplusplus
typedef class TSRDPRemoteDesktopClient TSRDPRemoteDesktopClient;
#else
typedef struct TSRDPRemoteDesktopClient TSRDPRemoteDesktopClient;
#endif /* __cplusplus */

#endif 	/* __TSRDPRemoteDesktopClient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "rdschan.h"
#include "rderror.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IDataChannelIO_INTERFACE_DEFINED__
#define __IDataChannelIO_INTERFACE_DEFINED__

/* interface IDataChannelIO */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDataChannelIO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43A09182-0472-436E-9883-2D95C347C5F1")
    IDataChannelIO : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendData( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_ChannelMgr( 
            /* [in] */ ISAFRemoteDesktopChannelMgr *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDataChannelIOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDataChannelIO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDataChannelIO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDataChannelIO * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendData )( 
            IDataChannelIO * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ChannelMgr )( 
            IDataChannelIO * This,
            /* [in] */ ISAFRemoteDesktopChannelMgr *newVal);
        
        END_INTERFACE
    } IDataChannelIOVtbl;

    interface IDataChannelIO
    {
        CONST_VTBL struct IDataChannelIOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDataChannelIO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDataChannelIO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDataChannelIO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDataChannelIO_SendData(This,data)	\
    (This)->lpVtbl -> SendData(This,data)

#define IDataChannelIO_put_ChannelMgr(This,newVal)	\
    (This)->lpVtbl -> put_ChannelMgr(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDataChannelIO_SendData_Proxy( 
    IDataChannelIO * This,
    /* [in] */ BSTR data);


void __RPC_STUB IDataChannelIO_SendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IDataChannelIO_put_ChannelMgr_Proxy( 
    IDataChannelIO * This,
    /* [in] */ ISAFRemoteDesktopChannelMgr *newVal);


void __RPC_STUB IDataChannelIO_put_ChannelMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDataChannelIO_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rdchost_0259 */
/* [local] */ 


#define DISPID_RDSCLIENT_CHANNELMANAGER                      1
#define DISPID_RDSCLIENT_CONNECTPARMS                        2
#define DISPID_RDSCLIENT_CONNECTTOSERVER                     3
#define DISPID_RDSCLIENT_CONNECTREMOTEDESKTOP                4
#define DISPID_RDSCLIENT_DISCONNECTREMOTEDESKTOP             5
#define DISPID_RDSCLIENT_ISREMOTEDESKTOPCONNECTED            6
#define DISPID_RDSCLIENT_ISSERVERCONNECTED                   7
#define DISPID_RDSCLIENT_DISCONNECTFROMSERVER                8
#define DISPID_RDSCLIENT_ONCONNECTED                         9
#define DISPID_RDSCLIENT_ONDISCONNECTED                      10
#define DISPID_RDSCLIENT_ONCONNECTREMOTEDESKTOPCOMPLETE      11
#define DISPID_RDSCLIENT_EXTENDEDERRORINFO                   12
#define DISPID_RDSCLIENT_ENABLESMARTSIZING                   13
#define DISPID_RDSCLIENT_CONNECTEDSERVER						14
#define DISPID_RDSCLIENT_CONNECTEDPORT						15
#define DISPID_RDSCLIENT_CREATELISTENENDPOINT                16
#define DISPID_RDSCLIENT_STARTLISTEN                         17
#define DISPID_RDSCLIENT_ACCEPTCONNECTION                    18
#define DISPID_RDSCLIENT_STOPLISTEN                          19
#define DISPID_RDSCLIENT_ONLISTENCONNECT                     20
#define DISPID_RDSCLIENT_COLORDEPTH                          21
#define DISPID_RDSCLIENT_ONBEGINCONNECT                      22



extern RPC_IF_HANDLE __MIDL_itf_rdchost_0259_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdchost_0259_v0_0_s_ifspec;

#ifndef __ISAFRemoteDesktopClient_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopClient_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopClient */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8AA5F108-2918-435C-88AA-DE0AFEE51440")
    ISAFRemoteDesktopClient : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ChannelManager( 
            /* [retval][out] */ ISAFRemoteDesktopChannelMgr **mgr) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectParms( 
            /* [in] */ BSTR parms) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectParms( 
            /* [retval][out] */ BSTR *parms) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectToServer( 
            /* [in] */ BSTR expertBlob) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectRemoteDesktop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisconnectRemoteDesktop( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsRemoteDesktopConnected( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsServerConnected( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisconnectFromServer( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnConnected( 
            /* [in] */ IDispatch *iDisp) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnDisconnected( 
            /* [in] */ IDispatch *iDisp) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnConnectRemoteDesktopComplete( 
            /* [in] */ IDispatch *iDisp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtendedErrorInfo( 
            /* [retval][out] */ LONG *error) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EnableSmartSizing( 
            /* [in] */ BOOL val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnableSmartSizing( 
            /* [retval][out] */ BOOL *val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedServer( 
            /* [retval][out] */ BSTR *val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectedPort( 
            /* [retval][out] */ LONG *val) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateListenEndpoint( 
            /* [in] */ LONG port,
            /* [retval][out] */ BSTR *pConnectParm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartListen( 
            /* [in] */ LONG timeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcceptListenConnection( 
            /* [in] */ BSTR expertBlob) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopListen( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnListenConnect( 
            /* [in] */ IDispatch *iDisp) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorDepth( 
            /* [in] */ LONG val) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorDepth( 
            /* [retval][out] */ LONG *val) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnBeginConnect( 
            /* [in] */ IDispatch *iDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAFRemoteDesktopClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAFRemoteDesktopClient * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISAFRemoteDesktopClient * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelManager )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ ISAFRemoteDesktopChannelMgr **mgr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ConnectParms )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ BSTR parms);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectParms )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ BSTR *parms);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectToServer )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ BSTR expertBlob);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectRemoteDesktop )( 
            ISAFRemoteDesktopClient * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisconnectRemoteDesktop )( 
            ISAFRemoteDesktopClient * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsRemoteDesktopConnected )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsServerConnected )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisconnectFromServer )( 
            ISAFRemoteDesktopClient * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnConnected )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ IDispatch *iDisp);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnDisconnected )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ IDispatch *iDisp);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnConnectRemoteDesktopComplete )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ IDispatch *iDisp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedErrorInfo )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ LONG *error);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EnableSmartSizing )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ BOOL val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnableSmartSizing )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ BOOL *val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedServer )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ BSTR *val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectedPort )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ LONG *val);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateListenEndpoint )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ LONG port,
            /* [retval][out] */ BSTR *pConnectParm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartListen )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ LONG timeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcceptListenConnection )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ BSTR expertBlob);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopListen )( 
            ISAFRemoteDesktopClient * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnListenConnect )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ IDispatch *iDisp);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ColorDepth )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ LONG val);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ColorDepth )( 
            ISAFRemoteDesktopClient * This,
            /* [retval][out] */ LONG *val);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnBeginConnect )( 
            ISAFRemoteDesktopClient * This,
            /* [in] */ IDispatch *iDisp);
        
        END_INTERFACE
    } ISAFRemoteDesktopClientVtbl;

    interface ISAFRemoteDesktopClient
    {
        CONST_VTBL struct ISAFRemoteDesktopClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopClient_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopClient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopClient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopClient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopClient_get_ChannelManager(This,mgr)	\
    (This)->lpVtbl -> get_ChannelManager(This,mgr)

#define ISAFRemoteDesktopClient_put_ConnectParms(This,parms)	\
    (This)->lpVtbl -> put_ConnectParms(This,parms)

#define ISAFRemoteDesktopClient_get_ConnectParms(This,parms)	\
    (This)->lpVtbl -> get_ConnectParms(This,parms)

#define ISAFRemoteDesktopClient_ConnectToServer(This,expertBlob)	\
    (This)->lpVtbl -> ConnectToServer(This,expertBlob)

#define ISAFRemoteDesktopClient_ConnectRemoteDesktop(This)	\
    (This)->lpVtbl -> ConnectRemoteDesktop(This)

#define ISAFRemoteDesktopClient_DisconnectRemoteDesktop(This)	\
    (This)->lpVtbl -> DisconnectRemoteDesktop(This)

#define ISAFRemoteDesktopClient_get_IsRemoteDesktopConnected(This,pVal)	\
    (This)->lpVtbl -> get_IsRemoteDesktopConnected(This,pVal)

#define ISAFRemoteDesktopClient_get_IsServerConnected(This,pVal)	\
    (This)->lpVtbl -> get_IsServerConnected(This,pVal)

#define ISAFRemoteDesktopClient_DisconnectFromServer(This)	\
    (This)->lpVtbl -> DisconnectFromServer(This)

#define ISAFRemoteDesktopClient_put_OnConnected(This,iDisp)	\
    (This)->lpVtbl -> put_OnConnected(This,iDisp)

#define ISAFRemoteDesktopClient_put_OnDisconnected(This,iDisp)	\
    (This)->lpVtbl -> put_OnDisconnected(This,iDisp)

#define ISAFRemoteDesktopClient_put_OnConnectRemoteDesktopComplete(This,iDisp)	\
    (This)->lpVtbl -> put_OnConnectRemoteDesktopComplete(This,iDisp)

#define ISAFRemoteDesktopClient_get_ExtendedErrorInfo(This,error)	\
    (This)->lpVtbl -> get_ExtendedErrorInfo(This,error)

#define ISAFRemoteDesktopClient_put_EnableSmartSizing(This,val)	\
    (This)->lpVtbl -> put_EnableSmartSizing(This,val)

#define ISAFRemoteDesktopClient_get_EnableSmartSizing(This,val)	\
    (This)->lpVtbl -> get_EnableSmartSizing(This,val)

#define ISAFRemoteDesktopClient_get_ConnectedServer(This,val)	\
    (This)->lpVtbl -> get_ConnectedServer(This,val)

#define ISAFRemoteDesktopClient_get_ConnectedPort(This,val)	\
    (This)->lpVtbl -> get_ConnectedPort(This,val)

#define ISAFRemoteDesktopClient_CreateListenEndpoint(This,port,pConnectParm)	\
    (This)->lpVtbl -> CreateListenEndpoint(This,port,pConnectParm)

#define ISAFRemoteDesktopClient_StartListen(This,timeout)	\
    (This)->lpVtbl -> StartListen(This,timeout)

#define ISAFRemoteDesktopClient_AcceptListenConnection(This,expertBlob)	\
    (This)->lpVtbl -> AcceptListenConnection(This,expertBlob)

#define ISAFRemoteDesktopClient_StopListen(This)	\
    (This)->lpVtbl -> StopListen(This)

#define ISAFRemoteDesktopClient_put_OnListenConnect(This,iDisp)	\
    (This)->lpVtbl -> put_OnListenConnect(This,iDisp)

#define ISAFRemoteDesktopClient_put_ColorDepth(This,val)	\
    (This)->lpVtbl -> put_ColorDepth(This,val)

#define ISAFRemoteDesktopClient_get_ColorDepth(This,val)	\
    (This)->lpVtbl -> get_ColorDepth(This,val)

#define ISAFRemoteDesktopClient_put_OnBeginConnect(This,iDisp)	\
    (This)->lpVtbl -> put_OnBeginConnect(This,iDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_ChannelManager_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ ISAFRemoteDesktopChannelMgr **mgr);


void __RPC_STUB ISAFRemoteDesktopClient_get_ChannelManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_ConnectParms_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ BSTR parms);


void __RPC_STUB ISAFRemoteDesktopClient_put_ConnectParms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_ConnectParms_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ BSTR *parms);


void __RPC_STUB ISAFRemoteDesktopClient_get_ConnectParms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_ConnectToServer_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ BSTR expertBlob);


void __RPC_STUB ISAFRemoteDesktopClient_ConnectToServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_ConnectRemoteDesktop_Proxy( 
    ISAFRemoteDesktopClient * This);


void __RPC_STUB ISAFRemoteDesktopClient_ConnectRemoteDesktop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_DisconnectRemoteDesktop_Proxy( 
    ISAFRemoteDesktopClient * This);


void __RPC_STUB ISAFRemoteDesktopClient_DisconnectRemoteDesktop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_IsRemoteDesktopConnected_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB ISAFRemoteDesktopClient_get_IsRemoteDesktopConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_IsServerConnected_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB ISAFRemoteDesktopClient_get_IsServerConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_DisconnectFromServer_Proxy( 
    ISAFRemoteDesktopClient * This);


void __RPC_STUB ISAFRemoteDesktopClient_DisconnectFromServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_OnConnected_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopClient_put_OnConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_OnDisconnected_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopClient_put_OnDisconnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_OnConnectRemoteDesktopComplete_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopClient_put_OnConnectRemoteDesktopComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_ExtendedErrorInfo_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ LONG *error);


void __RPC_STUB ISAFRemoteDesktopClient_get_ExtendedErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_EnableSmartSizing_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ BOOL val);


void __RPC_STUB ISAFRemoteDesktopClient_put_EnableSmartSizing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_EnableSmartSizing_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ BOOL *val);


void __RPC_STUB ISAFRemoteDesktopClient_get_EnableSmartSizing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_ConnectedServer_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ BSTR *val);


void __RPC_STUB ISAFRemoteDesktopClient_get_ConnectedServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_ConnectedPort_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ LONG *val);


void __RPC_STUB ISAFRemoteDesktopClient_get_ConnectedPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_CreateListenEndpoint_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ LONG port,
    /* [retval][out] */ BSTR *pConnectParm);


void __RPC_STUB ISAFRemoteDesktopClient_CreateListenEndpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_StartListen_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ LONG timeout);


void __RPC_STUB ISAFRemoteDesktopClient_StartListen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_AcceptListenConnection_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ BSTR expertBlob);


void __RPC_STUB ISAFRemoteDesktopClient_AcceptListenConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_StopListen_Proxy( 
    ISAFRemoteDesktopClient * This);


void __RPC_STUB ISAFRemoteDesktopClient_StopListen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_OnListenConnect_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopClient_put_OnListenConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_ColorDepth_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ LONG val);


void __RPC_STUB ISAFRemoteDesktopClient_put_ColorDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_get_ColorDepth_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [retval][out] */ LONG *val);


void __RPC_STUB ISAFRemoteDesktopClient_get_ColorDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClient_put_OnBeginConnect_Proxy( 
    ISAFRemoteDesktopClient * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopClient_put_OnBeginConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopClient_INTERFACE_DEFINED__ */


#ifndef __ISAFRemoteDesktopClientHost_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopClientHost_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopClientHost */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopClientHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69DE5BF3-5EB9-4158-81DA-6FD662BBDDDD")
    ISAFRemoteDesktopClientHost : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRemoteDesktopClient( 
            /* [retval][out] */ ISAFRemoteDesktopClient **client) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopClientHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAFRemoteDesktopClientHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAFRemoteDesktopClientHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAFRemoteDesktopClientHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISAFRemoteDesktopClientHost * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISAFRemoteDesktopClientHost * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISAFRemoteDesktopClientHost * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISAFRemoteDesktopClientHost * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRemoteDesktopClient )( 
            ISAFRemoteDesktopClientHost * This,
            /* [retval][out] */ ISAFRemoteDesktopClient **client);
        
        END_INTERFACE
    } ISAFRemoteDesktopClientHostVtbl;

    interface ISAFRemoteDesktopClientHost
    {
        CONST_VTBL struct ISAFRemoteDesktopClientHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopClientHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopClientHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopClientHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopClientHost_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopClientHost_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopClientHost_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopClientHost_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopClientHost_GetRemoteDesktopClient(This,client)	\
    (This)->lpVtbl -> GetRemoteDesktopClient(This,client)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopClientHost_GetRemoteDesktopClient_Proxy( 
    ISAFRemoteDesktopClientHost * This,
    /* [retval][out] */ ISAFRemoteDesktopClient **client);


void __RPC_STUB ISAFRemoteDesktopClientHost_GetRemoteDesktopClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopClientHost_INTERFACE_DEFINED__ */


#ifndef __ISAFRemoteDesktopTestExtension_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopTestExtension_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopTestExtension */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopTestExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C7A32EF-1C77-4F35-8FBA-729DD2DE7222")
    ISAFRemoteDesktopTestExtension : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TestExtDllName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_TestExtParams( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopTestExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAFRemoteDesktopTestExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAFRemoteDesktopTestExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAFRemoteDesktopTestExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISAFRemoteDesktopTestExtension * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISAFRemoteDesktopTestExtension * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISAFRemoteDesktopTestExtension * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISAFRemoteDesktopTestExtension * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TestExtDllName )( 
            ISAFRemoteDesktopTestExtension * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_TestExtParams )( 
            ISAFRemoteDesktopTestExtension * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ISAFRemoteDesktopTestExtensionVtbl;

    interface ISAFRemoteDesktopTestExtension
    {
        CONST_VTBL struct ISAFRemoteDesktopTestExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopTestExtension_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopTestExtension_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopTestExtension_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopTestExtension_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopTestExtension_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopTestExtension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopTestExtension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopTestExtension_put_TestExtDllName(This,newVal)	\
    (This)->lpVtbl -> put_TestExtDllName(This,newVal)

#define ISAFRemoteDesktopTestExtension_put_TestExtParams(This,newVal)	\
    (This)->lpVtbl -> put_TestExtParams(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopTestExtension_put_TestExtDllName_Proxy( 
    ISAFRemoteDesktopTestExtension * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISAFRemoteDesktopTestExtension_put_TestExtDllName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopTestExtension_put_TestExtParams_Proxy( 
    ISAFRemoteDesktopTestExtension * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ISAFRemoteDesktopTestExtension_put_TestExtParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopTestExtension_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rdchost_0262 */
/* [local] */ 


#define DISPID_RDSCLIENTEVENTS_CONNECTED						2
#define DISPID_RDSCLIENTEVENTS_DISCONNECTED					3
#define DISPID_RDSCLIENTEVENTS_REMOTECONTROLREQUESTCOMPLETE	4
#define DISPID_DATACHANNELEVEVENTS_DATAREADY					1
#define DISPID_RDSCLIENTEVENTS_LISTENCONNECT                 5
#define DISPID_RDSCLIENTEVENTS_BEGINCONNECT                  6


#define DISPID_RDSCHANNELEVENTS_CHANNELDATAREADY     1



extern RPC_IF_HANDLE __MIDL_itf_rdchost_0262_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdchost_0262_v0_0_s_ifspec;


#ifndef __RDCCLIENTHOSTLib_LIBRARY_DEFINED__
#define __RDCCLIENTHOSTLib_LIBRARY_DEFINED__

/* library RDCCLIENTHOSTLib */
/* [helpstring][version][uuid] */ 


#define DISPID_RDSCHANNELEVENTS_CHANNELDATAREADY     1


EXTERN_C const IID LIBID_RDCCLIENTHOSTLib;

#ifndef ___ISAFRemoteDesktopDataChannelEvents_DISPINTERFACE_DEFINED__
#define ___ISAFRemoteDesktopDataChannelEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ISAFRemoteDesktopDataChannelEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ISAFRemoteDesktopDataChannelEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("59AE79BC-9721-42df-9396-9D98E7F7A396")
    _ISAFRemoteDesktopDataChannelEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ISAFRemoteDesktopDataChannelEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _ISAFRemoteDesktopDataChannelEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _ISAFRemoteDesktopDataChannelEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ISAFRemoteDesktopDataChannelEventsVtbl;

    interface _ISAFRemoteDesktopDataChannelEvents
    {
        CONST_VTBL struct _ISAFRemoteDesktopDataChannelEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ISAFRemoteDesktopDataChannelEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _ISAFRemoteDesktopDataChannelEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _ISAFRemoteDesktopDataChannelEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _ISAFRemoteDesktopDataChannelEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _ISAFRemoteDesktopDataChannelEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _ISAFRemoteDesktopDataChannelEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _ISAFRemoteDesktopDataChannelEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ISAFRemoteDesktopDataChannelEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SAFRemoteDesktopClientHost;

#ifdef __cplusplus

class DECLSPEC_UUID("299BE050-E83E-4DB7-A7DA-D86FDEBFE6D0")
SAFRemoteDesktopClientHost;
#endif

EXTERN_C const CLSID CLSID_ClientDataChannel;

#ifdef __cplusplus

class DECLSPEC_UUID("C91C2A81-8B14-4a96-A5DB-4640F551F3EE")
ClientDataChannel;
#endif

EXTERN_C const CLSID CLSID_ClientRemoteDesktopChannelMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("078BB428-FA9B-43f1-B002-1ABF3A8C95CF")
ClientRemoteDesktopChannelMgr;
#endif

#ifndef ___ISAFRemoteDesktopClientEvents_DISPINTERFACE_DEFINED__
#define ___ISAFRemoteDesktopClientEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ISAFRemoteDesktopClientEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ISAFRemoteDesktopClientEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("327A98F6-B337-43B0-A3DE-408B46E6C4CE")
    _ISAFRemoteDesktopClientEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ISAFRemoteDesktopClientEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _ISAFRemoteDesktopClientEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _ISAFRemoteDesktopClientEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _ISAFRemoteDesktopClientEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _ISAFRemoteDesktopClientEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _ISAFRemoteDesktopClientEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _ISAFRemoteDesktopClientEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ISAFRemoteDesktopClientEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ISAFRemoteDesktopClientEventsVtbl;

    interface _ISAFRemoteDesktopClientEvents
    {
        CONST_VTBL struct _ISAFRemoteDesktopClientEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ISAFRemoteDesktopClientEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _ISAFRemoteDesktopClientEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _ISAFRemoteDesktopClientEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _ISAFRemoteDesktopClientEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _ISAFRemoteDesktopClientEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _ISAFRemoteDesktopClientEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _ISAFRemoteDesktopClientEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ISAFRemoteDesktopClientEvents_DISPINTERFACE_DEFINED__ */


#ifndef ___IDataChannelIOEvents_DISPINTERFACE_DEFINED__
#define ___IDataChannelIOEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IDataChannelIOEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IDataChannelIOEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("85C037E5-743F-4938-936B-A8DB95430391")
    _IDataChannelIOEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IDataChannelIOEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _IDataChannelIOEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _IDataChannelIOEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _IDataChannelIOEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _IDataChannelIOEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _IDataChannelIOEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _IDataChannelIOEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _IDataChannelIOEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _IDataChannelIOEventsVtbl;

    interface _IDataChannelIOEvents
    {
        CONST_VTBL struct _IDataChannelIOEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IDataChannelIOEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IDataChannelIOEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IDataChannelIOEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IDataChannelIOEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IDataChannelIOEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IDataChannelIOEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IDataChannelIOEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IDataChannelIOEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SAFRemoteDesktopClient;

#ifdef __cplusplus

class DECLSPEC_UUID("B90D0115-3AEA-45D3-801E-93913008D49E")
SAFRemoteDesktopClient;
#endif

EXTERN_C const CLSID CLSID_TSRDPRemoteDesktopClient;

#ifdef __cplusplus

class DECLSPEC_UUID("F137E241-0092-4575-976A-D3E33980BB26")
TSRDPRemoteDesktopClient;
#endif
#endif /* __RDCCLIENTHOSTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rassistance_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rassistance.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRASettingProperty,0x08C8B592,0xFDD0,0x423C,0x9F,0xD2,0x7D,0x8C,0x05,0x5E,0xC5,0xB3);


MIDL_DEFINE_GUID(IID, IID_IRARegSetting,0x2464AA8D,0x7099,0x4C22,0x92,0x5C,0x81,0xA4,0xEB,0x1F,0xCF,0xFE);


MIDL_DEFINE_GUID(IID, LIBID_RASSISTANCELib,0x5190C4AF,0xAB0F,0x4235,0xB1,0x2F,0xD5,0xA8,0xFA,0x3F,0x85,0x4B);


MIDL_DEFINE_GUID(CLSID, CLSID_RASettingProperty,0x4D317113,0xC6EC,0x406A,0x9C,0x61,0x20,0xE8,0x91,0xBC,0x37,0xF7);


MIDL_DEFINE_GUID(CLSID, CLSID_RARegSetting,0x70FF37C0,0xF39A,0x4B26,0xAE,0x5E,0x63,0x8E,0xF2,0x96,0xD4,0x90);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rassistance.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRASettingProperty,0x08C8B592,0xFDD0,0x423C,0x9F,0xD2,0x7D,0x8C,0x05,0x5E,0xC5,0xB3);


MIDL_DEFINE_GUID(IID, IID_IRARegSetting,0x2464AA8D,0x7099,0x4C22,0x92,0x5C,0x81,0xA4,0xEB,0x1F,0xCF,0xFE);


MIDL_DEFINE_GUID(IID, LIBID_RASSISTANCELib,0x5190C4AF,0xAB0F,0x4235,0xB1,0x2F,0xD5,0xA8,0xFA,0x3F,0x85,0x4B);


MIDL_DEFINE_GUID(CLSID, CLSID_RASettingProperty,0x4D317113,0xC6EC,0x406A,0x9C,0x61,0x20,0xE8,0x91,0xBC,0x37,0xF7);


MIDL_DEFINE_GUID(CLSID, CLSID_RARegSetting,0x70FF37C0,0xF39A,0x4B26,0xAE,0x5E,0x63,0x8E,0xF2,0x96,0xD4,0x90);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rassistance.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rassistance.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rassistance_h__
#define __rassistance_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRASettingProperty_FWD_DEFINED__
#define __IRASettingProperty_FWD_DEFINED__
typedef interface IRASettingProperty IRASettingProperty;
#endif 	/* __IRASettingProperty_FWD_DEFINED__ */


#ifndef __IRARegSetting_FWD_DEFINED__
#define __IRARegSetting_FWD_DEFINED__
typedef interface IRARegSetting IRARegSetting;
#endif 	/* __IRARegSetting_FWD_DEFINED__ */


#ifndef __RASettingProperty_FWD_DEFINED__
#define __RASettingProperty_FWD_DEFINED__

#ifdef __cplusplus
typedef class RASettingProperty RASettingProperty;
#else
typedef struct RASettingProperty RASettingProperty;
#endif /* __cplusplus */

#endif 	/* __RASettingProperty_FWD_DEFINED__ */


#ifndef __RARegSetting_FWD_DEFINED__
#define __RARegSetting_FWD_DEFINED__

#ifdef __cplusplus
typedef class RARegSetting RARegSetting;
#else
typedef struct RARegSetting RARegSetting;
#endif /* __cplusplus */

#endif 	/* __RARegSetting_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IRASettingProperty_INTERFACE_DEFINED__
#define __IRASettingProperty_INTERFACE_DEFINED__

/* interface IRASettingProperty */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRASettingProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C8B592-FDD0-423C-9FD2-7D8C055EC5B3")
    IRASettingProperty : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsCancelled( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsCancelled( 
            BOOL bVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsChanged( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Init( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRegSetting( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowDialogBox( 
            HWND hWndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRASettingPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRASettingProperty * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRASettingProperty * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRASettingProperty * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRASettingProperty * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRASettingProperty * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRASettingProperty * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRASettingProperty * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsCancelled )( 
            IRASettingProperty * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsCancelled )( 
            IRASettingProperty * This,
            BOOL bVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsChanged )( 
            IRASettingProperty * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IRASettingProperty * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetRegSetting )( 
            IRASettingProperty * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ShowDialogBox )( 
            IRASettingProperty * This,
            HWND hWndParent);
        
        END_INTERFACE
    } IRASettingPropertyVtbl;

    interface IRASettingProperty
    {
        CONST_VTBL struct IRASettingPropertyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRASettingProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRASettingProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRASettingProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRASettingProperty_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRASettingProperty_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRASettingProperty_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRASettingProperty_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRASettingProperty_get_IsCancelled(This,pVal)	\
    (This)->lpVtbl -> get_IsCancelled(This,pVal)

#define IRASettingProperty_put_IsCancelled(This,bVal)	\
    (This)->lpVtbl -> put_IsCancelled(This,bVal)

#define IRASettingProperty_get_IsChanged(This,pVal)	\
    (This)->lpVtbl -> get_IsChanged(This,pVal)

#define IRASettingProperty_Init(This)	\
    (This)->lpVtbl -> Init(This)

#define IRASettingProperty_SetRegSetting(This)	\
    (This)->lpVtbl -> SetRegSetting(This)

#define IRASettingProperty_ShowDialogBox(This,hWndParent)	\
    (This)->lpVtbl -> ShowDialogBox(This,hWndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRASettingProperty_get_IsCancelled_Proxy( 
    IRASettingProperty * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRASettingProperty_get_IsCancelled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRASettingProperty_put_IsCancelled_Proxy( 
    IRASettingProperty * This,
    BOOL bVal);


void __RPC_STUB IRASettingProperty_put_IsCancelled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRASettingProperty_get_IsChanged_Proxy( 
    IRASettingProperty * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRASettingProperty_get_IsChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRASettingProperty_Init_Proxy( 
    IRASettingProperty * This);


void __RPC_STUB IRASettingProperty_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRASettingProperty_SetRegSetting_Proxy( 
    IRASettingProperty * This);


void __RPC_STUB IRASettingProperty_SetRegSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRASettingProperty_ShowDialogBox_Proxy( 
    IRASettingProperty * This,
    HWND hWndParent);


void __RPC_STUB IRASettingProperty_ShowDialogBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRASettingProperty_INTERFACE_DEFINED__ */


#ifndef __IRARegSetting_INTERFACE_DEFINED__
#define __IRARegSetting_INTERFACE_DEFINED__

/* interface IRARegSetting */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRARegSetting;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2464AA8D-7099-4C22-925C-81A4EB1FCFFE")
    IRARegSetting : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowGetHelp( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowGetHelp( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowUnSolicited( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowUnSolicited( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowFullControl( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowFullControl( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxTicketExpiry( 
            /* [retval][out] */ LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxTicketExpiry( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowRemoteAssistance( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllowRemoteAssistance( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowUnSolicitedFullControl( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowBuddyHelp( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AllowGetHelpCPL( 
            /* [retval][out] */ BOOL *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRARegSettingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRARegSetting * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRARegSetting * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRARegSetting * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRARegSetting * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRARegSetting * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRARegSetting * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRARegSetting * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowGetHelp )( 
            IRARegSetting * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowGetHelp )( 
            IRARegSetting * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowUnSolicited )( 
            IRARegSetting * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowUnSolicited )( 
            IRARegSetting * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowFullControl )( 
            IRARegSetting * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowFullControl )( 
            IRARegSetting * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxTicketExpiry )( 
            IRARegSetting * This,
            /* [retval][out] */ LONG *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MaxTicketExpiry )( 
            IRARegSetting * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowRemoteAssistance )( 
            IRARegSetting * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AllowRemoteAssistance )( 
            IRARegSetting * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowUnSolicitedFullControl )( 
            IRARegSetting * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowBuddyHelp )( 
            IRARegSetting * This,
            /* [retval][out] */ BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AllowGetHelpCPL )( 
            IRARegSetting * This,
            /* [retval][out] */ BOOL *pVal);
        
        END_INTERFACE
    } IRARegSettingVtbl;

    interface IRARegSetting
    {
        CONST_VTBL struct IRARegSettingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRARegSetting_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRARegSetting_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRARegSetting_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRARegSetting_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRARegSetting_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRARegSetting_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRARegSetting_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRARegSetting_get_AllowGetHelp(This,pVal)	\
    (This)->lpVtbl -> get_AllowGetHelp(This,pVal)

#define IRARegSetting_put_AllowGetHelp(This,newVal)	\
    (This)->lpVtbl -> put_AllowGetHelp(This,newVal)

#define IRARegSetting_get_AllowUnSolicited(This,pVal)	\
    (This)->lpVtbl -> get_AllowUnSolicited(This,pVal)

#define IRARegSetting_put_AllowUnSolicited(This,newVal)	\
    (This)->lpVtbl -> put_AllowUnSolicited(This,newVal)

#define IRARegSetting_get_AllowFullControl(This,pVal)	\
    (This)->lpVtbl -> get_AllowFullControl(This,pVal)

#define IRARegSetting_put_AllowFullControl(This,newVal)	\
    (This)->lpVtbl -> put_AllowFullControl(This,newVal)

#define IRARegSetting_get_MaxTicketExpiry(This,pVal)	\
    (This)->lpVtbl -> get_MaxTicketExpiry(This,pVal)

#define IRARegSetting_put_MaxTicketExpiry(This,newVal)	\
    (This)->lpVtbl -> put_MaxTicketExpiry(This,newVal)

#define IRARegSetting_get_AllowRemoteAssistance(This,pVal)	\
    (This)->lpVtbl -> get_AllowRemoteAssistance(This,pVal)

#define IRARegSetting_put_AllowRemoteAssistance(This,newVal)	\
    (This)->lpVtbl -> put_AllowRemoteAssistance(This,newVal)

#define IRARegSetting_get_AllowUnSolicitedFullControl(This,pVal)	\
    (This)->lpVtbl -> get_AllowUnSolicitedFullControl(This,pVal)

#define IRARegSetting_get_AllowBuddyHelp(This,pVal)	\
    (This)->lpVtbl -> get_AllowBuddyHelp(This,pVal)

#define IRARegSetting_get_AllowGetHelpCPL(This,pVal)	\
    (This)->lpVtbl -> get_AllowGetHelpCPL(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_AllowGetHelp_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRARegSetting_get_AllowGetHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRARegSetting_put_AllowGetHelp_Proxy( 
    IRARegSetting * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IRARegSetting_put_AllowGetHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_AllowUnSolicited_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRARegSetting_get_AllowUnSolicited_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRARegSetting_put_AllowUnSolicited_Proxy( 
    IRARegSetting * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IRARegSetting_put_AllowUnSolicited_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_AllowFullControl_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRARegSetting_get_AllowFullControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRARegSetting_put_AllowFullControl_Proxy( 
    IRARegSetting * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IRARegSetting_put_AllowFullControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_MaxTicketExpiry_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ LONG *pVal);


void __RPC_STUB IRARegSetting_get_MaxTicketExpiry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRARegSetting_put_MaxTicketExpiry_Proxy( 
    IRARegSetting * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IRARegSetting_put_MaxTicketExpiry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_AllowRemoteAssistance_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRARegSetting_get_AllowRemoteAssistance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRARegSetting_put_AllowRemoteAssistance_Proxy( 
    IRARegSetting * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IRARegSetting_put_AllowRemoteAssistance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_AllowUnSolicitedFullControl_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRARegSetting_get_AllowUnSolicitedFullControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_AllowBuddyHelp_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRARegSetting_get_AllowBuddyHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRARegSetting_get_AllowGetHelpCPL_Proxy( 
    IRARegSetting * This,
    /* [retval][out] */ BOOL *pVal);


void __RPC_STUB IRARegSetting_get_AllowGetHelpCPL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRARegSetting_INTERFACE_DEFINED__ */



#ifndef __RASSISTANCELib_LIBRARY_DEFINED__
#define __RASSISTANCELib_LIBRARY_DEFINED__

/* library RASSISTANCELib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_RASSISTANCELib;

EXTERN_C const CLSID CLSID_RASettingProperty;

#ifdef __cplusplus

class DECLSPEC_UUID("4D317113-C6EC-406A-9C61-20E891BC37F7")
RASettingProperty;
#endif

EXTERN_C const CLSID CLSID_RARegSetting;

#ifdef __cplusplus

class DECLSPEC_UUID("70FF37C0-F39A-4B26-AE5E-638EF296D490")
RARegSetting;
#endif
#endif /* __RASSISTANCELib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rderror.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rderror.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __rderror_h__
#define __rderror_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_rderror_0000 */
/* [local] */ 


#define  SAFERROR_NOERROR					0
#define  SAFERROR_NOINFO						1
#define  SAFERROR_LOCALNOTERROR              3
#define  SAFERROR_REMOTEBYUSER               4
#define  SAFERROR_BYSERVER					5
#define  SAFERROR_DNSLOOKUPFAILED            6
#define  SAFERROR_OUTOFMEMORY                7
#define  SAFERROR_CONNECTIONTIMEDOUT         8
#define  SAFERROR_SOCKETCONNECTFAILED        9
#define  SAFERROR_HOSTNOTFOUND               11
#define  SAFERROR_WINSOCKSENDFAILED          12
#define  SAFERROR_INVALIDIPADDR              14
#define  SAFERROR_SOCKETRECVFAILED           15
#define  SAFERROR_INVALIDENCRYPTION          18
#define  SAFERROR_GETHOSTBYNAMEFAILED        20
#define  SAFERROR_LICENSINGFAILED            21
#define  SAFERROR_ENCRYPTIONERROR            22
#define  SAFERROR_DECRYPTIONERROR            23
#define  SAFERROR_INVALIDPARAMETERSTRING     24
#define  SAFERROR_HELPSESSIONNOTFOUND        25
#define  SAFERROR_INVALIDPASSWORD            26
#define  SAFERROR_HELPSESSIONEXPIRED         27
#define  SAFERROR_CANTOPENRESOLVER           28
#define  SAFERROR_UNKNOWNSESSMGRERROR        29
#define  SAFERROR_CANTFORMLINKTOUSERSESSION  30
#define  SAFERROR_RCPROTOCOLERROR			32
#define  SAFERROR_RCUNKNOWNERROR			    33
#define  SAFERROR_INTERNALERROR			    34
#define  SAFERROR_HELPEERESPONSEPENDING      35
#define  SAFERROR_HELPEESAIDYES			    36
#define  SAFERROR_HELPEEALREADYBEINGHELPED   37
#define  SAFERROR_HELPEECONSIDERINGHELP      38
#define  SAFERROR_HELPEENOTFOUND			    39
#define  SAFERROR_HELPEENEVERRESPONDED	    40
#define  SAFERROR_HELPEESAIDNO               41
#define  SAFERROR_HELPSESSIONACCESSDENIED    42
#define  SAFERROR_USERNOTFOUND               43
#define  SAFERROR_SESSMGRERRORNOTINIT        44
#define  SAFERROR_SELFHELPNOTSUPPORTED       45
#define  SAFERROR_INCOMPATIBLEVERSION        47
#define  SAFERROR_SESSIONNOTCONNECTED        48
#define  SAFERROR_SYSTEMSHUTDOWN             50
#define  SAFERROR_STOPLISTENBYUSER           51
#define  SAFERROR_WINSOCK_FAILED             52
#define  SAFERROR_MISMATCHPARMS              53
#define  SAFERROR_SHADOWEND_BASE             300
#define  SAFERROR_SHADOWEND_CONFIGCHANGE     SAFERROR_SHADOWEND_BASE+1
#define  SAFERROR_SHADOWEND_UNKNOWN          SAFERROR_SHADOWEND_BASE+2



extern RPC_IF_HANDLE __MIDL_itf_rderror_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rderror_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdpdr.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    rdrdr.h

Abstract:

    Type definitions for the Rdp redirector protocol

Revision History:
--*/

#ifndef _RDPDR_
#define _RDPDR_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Turn off compiler padding of structures
// Save previous packing style if 32-bit build.
//
#ifdef OS_WIN16
#pragma pack (1)
#else
#pragma pack (push, drpack, 1)
#endif

//
// version info.
//

#define RDPDR_MAJOR_VERSION     1
#define RDPDR_MINOR_VERSION     5

//
// version comparison macro
//
#define COMPARE_VERSION(Minor1, Major1, Minor2, Major2) \
    (((LONG)MAKELONG(Minor1, Major1)) - ((LONG)MAKELONG(Minor2, Major2)))

#define RDPDR_MAJOR_VERSION_PORTS   1
#define RDPDR_MINOR_VERSION_PORTS   5

#define RDPDR_MAJOR_VERSION_DRIVE   1
#define RDPDR_MINOR_VERSION_DRIVE   5

//
//  NULL Client Device ID.
//

#define RDPDR_INVALIDDEVICEID      (ULONG)-1

//
//  This string precedes the session id number in the file name path when
//  a user-mode component opens us for device management.
//
#define RDPDYN_SESSIONIDSTRING      L"\\session"

//
//  Device Names for RDPDR Device Manager Control Device
//
// NT Names
#define RDPDRDVMGR_DEVICE_PATH_A "\\Device\\RdpDrDvMgr"
#define RDPDRDVMGR_DEVICE_PATH_U L"\\Device\\RdpDrDvMgr"
#define RDPDRDVMGR_DEVICE_PATH_A_LENGTH sizeof(RDPDRDVMGR_DEVICE_PATH_A)
#define RDPDRDVMGR_DEVICE_PATH_U_LENGTH sizeof(RDPDRDVMGR_DEVICE_PATH_U)

// Win32 Names
#define RDPDRDVMGR_W32DEVICE_NAME_A "RdpDrDvMgr"
#define RDPDRDVMGR_W32DEVICE_NAME_U L"RdpDrDvMgr"
#define RDPDRDVMGR_W32DEVICE_PATH_A "\\DosDevices\\RdpDrDvMgr"
#define RDPDRDVMGR_W32DEVICE_PATH_U L"\\DosDevices\\RdpDrDvMgr"
#define RDPDRDVMGR_W32DEVICE_PATH_A_LENGTH sizeof(RDPDRDVMGR_W32DEVICE_PATH_A)
#define RDPDRDVMGR_W32DEVICE_PATH_U_LENGTH sizeof(RDPDRDVMGR_W32DEVICE_PATH_U)

//  Maximum number of characters in a ULONG -> STRING conversion.
#define RDPDRMAXULONGSTRING    16  // Big enough for a 32-bit int.
#define RDPDRMAXDOSNAMELEN     16

//
//  Maximum number of characters (not bytes!) in a reference string.
//
#define RDPDRMAXREFSTRINGLEN   \
    (RDPDRMAXDOSNAMELEN + RDPDRMAXULONGSTRING + RDPDR_MAX_COMPUTER_NAME_LENGTH + 5 + RDPDRMAXDOSNAMELEN + 1)
//  DosDeviceName   +  Session ID       +   computer name           + delimiters + preferred dos name  + terminator

//
//  Maximum number of characters in a NT device name string
//
#define RDPDRMAXNTDEVICENAMEGLEN   \
    ((sizeof(RDPDR_PORT_DEVICE_NAME_U) / sizeof(WCHAR)) +  RDPDRMAXREFSTRINGLEN + 1)    
//  NT Device name + Reference string + terminator null

// 
//  Dr Network Provider Dll Name
//
#define RDPDR_PROVIDER_NAME_U L"Microsoft Terminal Services"
#define RDPDR_PROVIDER_NAME_A "Microsoft Terminal Services"

// The following constant defines the length of the above name.

#define RDPDR_PROVIDER_NAME_U_LENGTH (sizeof(RDPDR_PROVIDER_NAME_U))
#define RDPDR_PROVIDER_NAME_A_LENGTH (sizeof(RDPDR_PROVIDER_NAME_A))


//
//  RDPDR Device Manager Event Codes for IOCTL Responses from Server
//
//  Message Code                Corresponding Message       Meaning
//  ---------------------------------------------------------------------------
//  RDPDREVT_PRINTERANNOUNCE    RDPDR_PRINTERDEVICE_SUB     New printer device.
//  RDPDREVT_BUFFERTOOSMALL     RDPDR_BUFFERTOOSMALL        IOCTL output buffer
//                                                          is too small.
//  RDPDREVT_PORTANNOUNCE       RDPDR_PORTDEVICE_SUB        New redirect port
//                                                          device.
//  RDPDREVT_REMOVEDEVICE       RDPDR_REMOVEDEVICE          A client-side device
//                                                          has been removed.
//  RDPDREVT_SESSIONDISCONNECT  NONE                        Client has disconnected
//                                                          from the session.
//  RDPDREVT_DRIVEANNOUNCE      RDPDR_DRIVEDEVICE_SUB       New redirected drive
//                                                          device
//

//  Message Codes
#define RDPDREVT_BASE                   0
#define RDPDREVT_PRINTERANNOUNCE        RDPDREVT_BASE + 1
#define RDPDREVT_BUFFERTOOSMALL         RDPDREVT_BASE + 2
#define RDPDREVT_REMOVEDEVICE           RDPDREVT_BASE + 3
#define RDPDREVT_PORTANNOUNCE           RDPDREVT_BASE + 4
#define RDPDREVT_SESSIONDISCONNECT      RDPDREVT_BASE + 5
#define RDPDREVT_DRIVEANNOUNCE          RDPDREVT_BASE + 6

//
//  Device Manager IOCTL's
//
//  IOCTL                           Input Buffer  Output Message Code
//                                              (Above-Defined Buffer Follows
//                                               Header in Driver-Response)
//  ----------------------------------------------------------------------------
//  IOCTL_RDPDR_GETNEXTDEVMGMTEVENT NONE          RDPDREVT_PRINTERANNOUNCE
//                                                RDPDREVT_BUFFERTOOSMALL
//  IOCTL_RDPDR_DBGADDNEWPRINTER    NONE          NONE
//  IOCTL_RDPDR_CLIENTMSG           opaque data     NONE
//                                  intended for
//                                  session's
//                                  corresponding
//                                  client.
//
#define IOCTL_RDPDR_GETNEXTDEVMGMTEVENT \
        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#ifdef DBG
#define IOCTL_RDPDR_DBGADDNEWPRINTER \
        CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#define IOCTL_RDPDR_CLIENTMSG \
    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  TS Printer Port Defines
//
#define RDPDRPRT_BASEPORTNAME       L"TS"   // TS Port Base Name
#define RDPDR_PORTNAMEDIGITS        6       // This value must match JobyL's value for USB
                                            //  max port number.
#define RDPDR_PORTNAMEDIGITSTOPAD   3       // We pad the first 3 to make things line 
                                            //  up nicely in UI up to port 999
#define RDPDR_MAXPORTNAMELEN        \
    (((sizeof(RDPDRPRT_BASEPORTNAME)-sizeof(WCHAR))/sizeof(WCHAR)) \
        + RDPDR_PORTNAMEDIGITS + 1)         //  In characters, including the terminator.

//
//  Driver name and ioctls
//
#define RDPDR_DEVICE_NAME_A "\\Device\\RdpDr"
#define RDPDR_DEVICE_NAME_U L"\\Device\\RdpDr"
#define RDPDR_DEVICE_NAME_A_LENGTH sizeof(RDPDR_DEVICE_NAME_A)
#define RDPDR_DEVICE_NAME_U_LENGTH sizeof(RDPDR_DEVICE_NAME_U)

#define RDPDR_PORT_DEVICE_NAME_A "\\Device\\RdpDrPort"
#define RDPDR_PORT_DEVICE_NAME_U L"\\Device\\RdpDrPort"
#define RDPDR_PORT_DEVICE_NAME_A_LENGTH sizeof(RDPDR_PORT_DEVICE_NAME_A)
#define RDPDR_PORT_DEVICE_NAME_U_LENGTH sizeof(RDPDR_PORT_DEVICE_NAME_U)


#define FSCTL_DR_START CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, \
        100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DR_STOP CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, \
        101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DR_DELETE_CONNECTION      CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, \
        102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DR_GET_CONNECTION_INFO    CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, \
        103, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_DR_ENUMERATE_CONNECTIONS  CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, \
        104, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_DR_ENUMERATE_SHARES       CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, \
        105, METHOD_NEITHER, FILE_ANY_ACCESS) 
#define FSCTL_DR_ENUMERATE_SERVERS      CTL_CODE(FILE_DEVICE_NETWORK_FILE_SYSTEM, \
        106, METHOD_NEITHER, FILE_ANY_ACCESS) 

//
//  Channel Name
//
#define DR_CHANNEL_NAME "RDPDR"

//
// Smartcard Name
//
#define DR_SMARTCARD_SUBSYSTEM "SCARD"

//
// Smartcard Name
//
#define DR_SMARTCARD_FILEID 1

//
//  Component Ids
//
#define RDPDR_CTYP_CORE         0x4472  /* 'Dr' */
#define RDPDR_CTYP_PRN          0x5052  /* 'PR' */

//
//  Core Packet Ids
//
#define DR_CORE_SERVER_ANNOUNCE         0x496E  /* 'In' */
#define DR_CORE_CLIENTID_CONFIRM        0x4343  /* 'CC' */
#define DR_CORE_CLIENT_NAME             0x434E  /* 'CN' */
#define DR_CORE_DEVICE_ANNOUNCE         0x6461  /* 'da' */
#define DR_CORE_DEVICELIST_ANNOUNCE     0x4441  /* 'DA' */
#define DR_CORE_DEVICELIST_REPLY        0x4452  /* 'DR' */
#define DR_CORE_DEVICE_REPLY            0x6472  /* 'dr' */
#define DR_CORE_DEVICE_IOREQUEST        0x4952  /* 'IR' */
#define DR_CORE_DEVICE_IOCOMPLETION     0x4943  /* 'IC' */
#define DR_CORE_SERVER_CAPABILITY       0x5350  /* 'SP' */
#define DR_CORE_CLIENT_CAPABILITY       0x4350  /* 'CP' */
#define DR_CORE_DEVICE_REMOVE           0x646D  /* 'dm' */
#define DR_CORE_DEVICELIST_REMOVE       0x444D  /* 'DM' */
#define DR_CORE_CLIENT_DISPLAY_NAME     0x444E  /* 'DN' */
#define DR_PRN_CACHE_DATA               0x5043  /* 'PC' */

//
//  Protocol header
//
typedef struct tagRDPDR_HEADER {
    SHORT   Component;
    SHORT   PacketId;
} RDPDR_HEADER, *PRDPDR_HEADER;

#ifdef __cplusplus
inline
BOOL
IsValidHeader(
    PVOID pData
    )
{
    PRDPDR_HEADER pRdpdrHeader;

    pRdpdrHeader = (PRDPDR_HEADER)pData;

    if( (pRdpdrHeader != NULL) &&
        ((pRdpdrHeader->Component == RDPDR_CTYP_CORE) ||
         (pRdpdrHeader->Component == RDPDR_CTYP_PRN)) ) {

        SHORT sPacketId;

        sPacketId = pRdpdrHeader->PacketId;

        if( (sPacketId == DR_CORE_SERVER_ANNOUNCE    ) ||
            (sPacketId == DR_CORE_CLIENTID_CONFIRM   ) ||
            (sPacketId == DR_CORE_CLIENT_NAME        ) ||
            (sPacketId == DR_CORE_DEVICE_ANNOUNCE    ) ||
            (sPacketId == DR_CORE_DEVICELIST_ANNOUNCE) ||
            (sPacketId == DR_CORE_DEVICELIST_REPLY   ) ||
            (sPacketId == DR_CORE_DEVICE_REPLY       ) ||
            (sPacketId == DR_CORE_DEVICE_IOREQUEST   ) ||
            (sPacketId == DR_CORE_DEVICE_IOCOMPLETION) ||
            (sPacketId == DR_PRN_CACHE_DATA          ) ||
            (sPacketId == DR_CORE_SERVER_CAPABILITY  ) ||
            (sPacketId == DR_CORE_CLIENT_CAPABILITY  ) ||
            (sPacketId == DR_CORE_DEVICE_REMOVE     ) ||
            (sPacketId == DR_CORE_DEVICELIST_REMOVE  ) ||
            (sPacketId == DR_CORE_CLIENT_DISPLAY_NAME)) {

            return( TRUE );
        }
    }

    return( FALSE );
}
#endif // __cplusplus


//
// RDPDR capability PDUs
//
// This is used during the client/server connection time to determine what
// the client and server are capable of doing
//
typedef struct tagRDPDR_CAPABILITY_SET_HEADER 
{
    RDPDR_HEADER Header;
    UINT16 numberCapabilities;
    UINT16 pad1;    
} RDPDR_CAPABILITY_SET_HEADER, *PRDPDR_CAPABILITY_SET_HEADER;

typedef struct tagRDPDR_CAPABILITY_HEADER
{
    UINT16 capabilityType;
    UINT16 capabilityLength;
    UINT32 version;
} RDPDR_CAPABILITY_HEADER, *PRDPDR_CAPABILITY_HEADER;

#define RDPDR_GENERAL_CAPABILITY_TYPE   0x1
#define RDPDR_PRINT_CAPABILITY_TYPE     0x2
#define RDPDR_PORT_CAPABILITY_TYPE      0x3
#define RDPDR_FS_CAPABILITY_TYPE        0x4
#define RDPDR_SMARTCARD_CAPABILITY_TYPE 0x5

//
// RDPDR general capability
//
typedef struct tagRDPDR_GENERAL_CAPABILITY
{
    UINT16 capabilityType;
    UINT16 capabilityLength;
    UINT32 version;
#define RDPDR_GENERAL_CAPABILITY_VERSION_01    0x1

    UINT32 osType;
#define RDPDR_OS_TYPE_UNKNOWN           0x0
#define RDPDR_OS_TYPE_WIN9X             0x1
#define RDPDR_OS_TYPE_WINNT             0x2

    UINT32 osVersion;
// For windows platforms, the high word is the major version
// The low word is the minor version

    UINT16 protocolMajorVersion;
    UINT16 protocolMinorVersion;

    UINT32 ioCode1;                             
#define RDPDR_IRP_MJ_CREATE                     0x0001
#define RDPDR_IRP_MJ_CLEANUP                    0x0002
#define RDPDR_IRP_MJ_CLOSE                      0x0004
#define RDPDR_IRP_MJ_READ                       0x0008
#define RDPDR_IRP_MJ_WRITE                      0x0010
#define RDPDR_IRP_MJ_FLUSH_BUFFERS              0x0020
#define RDPDR_IRP_MJ_SHUTDOWN                   0x0040
#define RDPDR_IRP_MJ_DEVICE_CONTROL             0x0080
#define RDPDR_IRP_MJ_QUERY_VOLUME_INFORMATION   0x0100
#define RDPDR_IRP_MJ_SET_VOLUME_INFORMATION     0x0200
#define RDPDR_IRP_MJ_QUERY_INFORMATION          0x0400
#define RDPDR_IRP_MJ_SET_INFORMATION            0x0800
#define RDPDR_IRP_MJ_DIRECTORY_CONTROL          0x1000
#define RDPDR_IRP_MJ_LOCK_CONTROL               0x2000
#define RDPDR_IRP_MJ_QUERY_SECURITY             0x4000
#define RDPDR_IRP_MJ_SET_SECURITY               0x8000

    UINT32 ioCode2;

    UINT32 extendedPDU;
#define RDPDR_DEVICE_REMOVE_PDUS        0x0001
#define RDPDR_CLIENT_DISPLAY_NAME_PDU   0x0002

    UINT32 extraFlags1;
    UINT32 extraFlags2;    
} RDPDR_GENERAL_CAPABILITY, *PRDPDR_GENERAL_CAPABILITY;

//
// RDPDR printing capability
//
typedef struct tagRDPDR_PRINT_CAPABILITY
{
    UINT16 capabilityType;
    UINT16 capabilityLength;
    UINT32 version;
#define RDPDR_PRINT_CAPABILITY_VERSION_01      0x1
} RDPDR_PRINT_CAPABILITY, *PRDPDR_PRINT_CAPABILITY;

//
// RDPDR port capability
//
typedef struct tagRDPDR_PORT_CAPABILITY
{
    UINT16 capabilityType;
    UINT16 capabilityLength;
    UINT32 version;
#define RDPDR_PORT_CAPABILITY_VERSION_01      0x1
} RDPDR_PORT_CAPABILITY, *PRDPDR_PORT_CAPABILITY;

//
// RDPDR file system capability
//
typedef struct tagRDPDR_FS_CAPABILITY
{
    UINT16 capabilityType;
    UINT16 capabilityLength;
    UINT32 version;
#define RDPDR_FS_CAPABILITY_VERSION_01      0x1
} RDPDR_FS_CAPABILITY, *PRDPDR_FS_CAPABILITY;

//
// RDPDR smart card subsystem capability
//
typedef struct tagRDPDR_SMARTCARD_CAPABILITY
{
    UINT16 capabilityType;
    UINT16 capabilityLength;
    UINT32 version;
#define RDPDR_SMARTCARD_CAPABILITY_VERSION_01      0x1
} RDPDR_SMARTCARD_CAPABILITY, *PRDPDR_SMARTCARD_CAPABILITY;


typedef struct tagRDPDR_VERSION {
    SHORT Major;
    SHORT Minor;
} RDPDR_VERSION, *PRDPDR_VERSION;

//
//  Device types
//
#define RDPDR_DTYP_SERIAL       0x00000001
#define RDPDR_DTYP_PARALLEL     0x00000002
#define RDPDR_DRYP_PRINTPORT    0x00000010
#define RDPDR_DTYP_PRINT        0x00000004
#define RDPDR_DTYP_FILESYSTEM   0x00000008
#define RDPDR_DTYP_SMARTCARD    0x00000020

//
//  RDPDR_SERVER_ANNOUNCE
//
//  Sent by the Server to establish communications and provide a client Id
//
typedef struct tagRDPDR_SERVER_ANNOUNCE
{
    ULONG   ClientId;       // Unique client identifier.
} RDPDR_SERVER_ANNOUNCE, *PRDPDR_SERVER_ANNOUNCE;

typedef struct tagRDPDR_SERVER_ANNOUNCE_PACKET
{
    RDPDR_HEADER            Header;
    RDPDR_VERSION           VersionInfo;    // Server version Info.
    RDPDR_SERVER_ANNOUNCE   ServerAnnounce;
} RDPDR_SERVER_ANNOUNCE_PACKET, *PRDPDR_SERVER_ANNOUNCE_PACKET;

//
//  RDPDR_CLIENTID_CONFIRM
//
//  Sent by the client to confirm the client id or propose reusing a
//  pre-existing client Id. If the client sends acceptance the ID from the
//  RDPDR_SERVER_ANNOUNCE, that's the end of it.
//  If the client proposes a different id, the server will send a
//  RPPDR_CLIENTID_CONFIRM back to either insist on the original clientId or
//  accept the client provided one.
//

typedef struct tagRDPDR_CLIENTID_CONFIRM
{
    ULONG   ClientId;       // Unique client identifier.
} RDPDR_CLIENTID_CONFIRM, *PRDPDR_CLIENTID_CONFIRM;

typedef struct tagRDPDR_CLIENT_CONFIRM_PACKET
{
    RDPDR_HEADER            Header;
    RDPDR_VERSION           VersionInfo;    // Client version Info.
    RDPDR_CLIENTID_CONFIRM  ClientConfirm;
} RDPDR_CLIENT_CONFIRM_PACKET, *PRDPDR_CLIENT_CONFIRM_PACKET;

#ifndef MAX_COMPUTERNAME_LENGTH
#define MAX_COMPUTERNAME_LENGTH 15 // From winbase.h
#endif // MAX_COMPUTERNAME_LENGTH

#define RDPDR_MAX_COMPUTER_NAME_LENGTH (MAX_COMPUTERNAME_LENGTH + 1)
#define RDPDR_MAX_DOSNAMELEN     16

typedef struct tagRDPDR_CLIENT_NAME
{
    ULONG   Unicode:1;      // flag to indicate the computer name is unicode or
                            // ansi.
    ULONG   CodePage;       // code page of the ansi string.

    ULONG   ComputerNameLen;// length of the computer name in bytes that
                            // follows this structures.
    //
    // computer name follows.
    //

} RDPDR_CLIENT_NAME, *PRDPDR_CLIENT_NAME;

typedef struct tagRDPDR_CLIENT_NAME_PACKET
{
    RDPDR_HEADER            Header;
    RDPDR_CLIENT_NAME       Name;
} RDPDR_CLIENT_NAME_PACKET, *PRDPDR_CLIENT_NAME_PACKET;

#define RDPDR_MAX_CLIENT_DISPLAY_NAME 64

typedef struct tagRDPDR_CLIENT_DISPLAY_NAME
{
    BYTE ComputerDisplayNameLen;

    //
    // computer display name follows
    //

} RDPDR_CLIENT_DISPLAY_NAME, *PRDPDR_CLIENT_DISPLAY_NAME;

typedef struct tagRDPDR_CLIENT_DISPLAY_NAME_PACKET
{
    RDPDR_HEADER                    Header;
    RDPDR_CLIENT_DISPLAY_NAME       Name;
} RDPDR_CLIENT_DISPLAY_NAME_PACKET, *PRDPDR_CLIENT_DISPLAY_NAME_PACKET;

//
//  RDPDR_DEVICE_ANNOUNCE
//
//  Sent by the client to indicate a device is available
//

#define PREFERRED_DOS_NAME_SIZE 8
typedef struct tagRDPDR_DEVICE_ANNOUNCE
{
    ULONG   DeviceType;             // Type of device, as listed above
    ULONG   DeviceId;               // An id to refer the device later
    UCHAR   PreferredDosName[PREFERRED_DOS_NAME_SIZE];    // Preferred device name COM99:\null
                                    // Long enough?
    ULONG   DeviceDataLength;       // Length of Type specific data (follows)
} RDPDR_DEVICE_ANNOUNCE, *PRDPDR_DEVICE_ANNOUNCE;

typedef struct tagRDPDR_DEVICE_ANNOUNCE_PACKET
{
    RDPDR_HEADER            Header;
    RDPDR_DEVICE_ANNOUNCE   DeviceAnnounce;
} RDPDR_DEVICE_ANNOUNCE_PACKET, *PRDPDR_DEVICE_ANNOUNCE_PACKET;

//
//  RDPDR_DEVICELIST_ANNOUNCE
//
//  Sent by the client to indicate a number of devices are available
//
typedef struct tagRDPDR_DEVICELIST_ANNOUNCE
{
    ULONG   DeviceCount;                // Number of devices
    // DeviceCount RDPDR_DEVICE_ANNOUNCE structures follows
} RDPDR_DEVICELIST_ANNOUNCE, *PRDPDR_DEVICELIST_ANNOUNCE;

typedef struct tagRDPDR_DEVICELIST_ANNOUNCE_PACKET
{
    RDPDR_HEADER                Header;
    RDPDR_DEVICELIST_ANNOUNCE   DeviceListAnnounce;
    RDPDR_DEVICE_ANNOUNCE       DeviceAnnounce;
} RDPDR_DEVICELIST_ANNOUNCE_PACKET, *PRDPDR_DEVICELIST_ANNOUNCE_PACKET;

#define DR_FIRSTDEVICEANNOUNCE(DeviceListPacket) \
    (&((PRDPDR_DEVICELIST_ANNOUNCE_PACKET)(DeviceListPacket))->DeviceAnnounce)
#define DR_NEXTDEVICEANNOUNCE(DeviceAnnounce) \
    (PRDPDR_DEVICE_ANNOUNCE) \
    ((((PUCHAR)(DeviceAnnounce)) + sizeof(RDPDR_DEVICE_ANNOUNCE) + \
    ((DeviceAnnounce)->DeviceDataLength)))

#define DR_CHECK_DEVICEDATALEN(DeviceAnnounce, DeviceSub) \
    (DeviceAnnounce->DeviceDataLength <= (sizeof(DeviceSub) - sizeof(*DeviceAnnounce)))


//
//  RDPDR_DEVICE_REMOVE
//
//  Sent by the client to indicate a device to be removed
//
typedef struct tagRDPDR_DEVICE_REMOVE
{
    ULONG   DeviceId;               // An id to refer the device later
} RDPDR_DEVICE_REMOVE, *PRDPDR_DEVICE_REMOVE;

typedef struct tagRDPDR_DEVICE_REMOVE_PACKET
{
    RDPDR_HEADER            Header;
    RDPDR_DEVICE_REMOVE     DeviceRemove;
} RDPDR_DEVICE_REMOVE_PACKET, *PRDPDR_DEVICE_REMOVE_PACKET;

//
//  RDPDR_DEVICELIST_REMOVE
//
//  Sent by the client to indicate a number of devices are to be removed
//
typedef struct tagRDPDR_DEVICELIST_REMOVE
{
    ULONG   DeviceCount;                // Number of devices
    // DeviceCount RDPDR_DEVICE_REMOVE structures follows
} RDPDR_DEVICELIST_REMOVE, *PRDPDR_DEVICELIST_REMOVE;

typedef struct tagRDPDR_DEVICELIST_REMOVE_PACKET
{
    RDPDR_HEADER                Header;
    RDPDR_DEVICELIST_REMOVE     DeviceListRemove;
    RDPDR_DEVICE_REMOVE         DeviceRemove;
} RDPDR_DEVICELIST_REMOVE_PACKET, *PRDPDR_DEVICELIST_REMOVE_PACKET;

#define DR_FIRSTDEVICEREMOVE(DeviceListPacket) \
    (&((PRDPDR_DEVICELIST_REMOVE_PACKET)(DeviceListPacket))->DeviceRemove)
#define DR_NEXTDEVICEREMOVE(DeviceRemove) \
    (PRDPDR_DEVICE_REMOVE) \
    ((((PUCHAR)(DeviceRemove)) + sizeof(RDPDR_DEVICE_REMOVE)))


#define RDPDR_DEVICE_REPLY_SUCCESS      0x00000000  // Accepted device
#define RDPDR_DEVICE_REPLY_REJECTED     0x00000001  // Generic will not use

//
//  RDPDR_DEVICE_REPLY
//
//  Sent by the server to indicate whether a device will be used
//
typedef struct tagRDPDR_DEVICE_REPLY
{
    ULONG   DeviceId;               // Id supplied in RDPDR_DEVICE_ANNOUNCE
    ULONG   ResultCode;             // Success or reason code
} RDPDR_DEVICE_REPLY, *PRDPDR_DEVICE_REPLY;

typedef struct tagRDPDR_DEVICE_REPLY_PACKET
{
    RDPDR_HEADER                Header;
    RDPDR_DEVICE_REPLY          DeviceReply;
} RDPDR_DEVICE_REPLY_PACKET, *PRDPDR_DEVICE_REPLY_PACKET;

//
//  RDPDR_DEVICELIST_REPLY
//
//  Sent by the server to indicate which devices will be used
//
typedef struct tagRDPDR_DEVICELIST_REPLY
{
    ULONG   DeviceCount;                    // Number of devices
    // DeviceReplies follow
} RDPDR_DEVICELIST_REPLY, *PRDPDR_DEVICELIST_REPLY;

typedef struct tagRDPDR_DEVICELIST_REPLY_PACKET
{
    RDPDR_HEADER                Header;
    RDPDR_DEVICELIST_REPLY      DeviceListReply;
    RDPDR_DEVICE_REPLY          DeviceReply;
} RDPDR_DEVICELIST_REPLY_PACKET_PACKET,
        *PRDPDR_DEVICELIST_REPLY_PACKET_PACKET;

//
//  RDPDR_UPDATE_DEVICEINFO
//
//  Sent by the server to update information about the device, for example
//  if the user does configuration on it.
//
typedef struct tagRDPDR_UPDATE_DEVICEINFO
{
    ULONG   DeviceId;               // Relevant device
    ULONG   DeviceDataLength;       // Length of type specific data (follows)
} RDPDR_UPDATE_DEVICEINFO, *PRDPDR_UPDATE_DEVICEINFO;

typedef struct tagRDPDR_UPDATE_DEVICEINFO_PACKET
{
    RDPDR_HEADER                Header;
    RDPDR_UPDATE_DEVICEINFO     DeviceUpdate;
    UCHAR                       Data;
} RDPDR_UPDATE_DEVICEINFO_PACKET, *PRDPDR_UPDATE_DEVICEINFO_PACKET;

//
// Define the file create disposition values
// These are defined in ntioapi.h
//
#define FILE_SUPERSEDE                  0x00000000
#define FILE_OPEN                       0x00000001
#define FILE_CREATE                     0x00000002
#define FILE_OPEN_IF                    0x00000003
#define FILE_OVERWRITE                  0x00000004
#define FILE_OVERWRITE_IF               0x00000005
#define FILE_MAXIMUM_DISPOSITION        0x00000005

//
// Define the I/O status information return values for NtCreateFile/NtOpenFile
// These are defined in ntioapi.h
//

#define FILE_SUPERSEDED                 0x00000000
#define FILE_OPENED                     0x00000001
#define FILE_CREATED                    0x00000002
#define FILE_OVERWRITTEN                0x00000003
#define FILE_EXISTS                     0x00000004
#define FILE_DOES_NOT_EXIST             0x00000005


//
// Define the file create/open option flags
// Also defined in ntioapi.h
//
#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000

#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff

//
// Define the file system information class
// Server can query the client file system with 
// each of these information class.
// These are defined in ntioapi.h
//
typedef enum _RDPFSINFOCLASS {
    RdpFsVolumeInformation       = 1,
    RdpFsLabelInformation,      // 2
    RdpFsSizeInformation,       // 3
    RdpFsDeviceInformation,     // 4
    RdpFsAttributeInformation,  // 5
    RdpFsControlInformation,    // 6
    RdpFsFullSizeInformation,   // 7
    RdpFsObjectIdInformation,   // 8
    RdpFsMaximumInformation
} RDP_FS_INFORMATION_CLASS, *PRDP_FS_INFORMATION_CLASS;

//
//  This is the maximum length for the file system volume
//  information structures
//  (not including variable file length)
//  Need to update this value if there is update to the file
//  system volume information structures
//
#define RDP_FILE_VOLUME_INFO_MAXLENGTH      32

//
// Define file system information classes
//
typedef struct _RDP_FILE_FS_LABEL_INFORMATION {
    ULONG VolumeLabelLength;
    WCHAR VolumeLabel[1];
} RDP_FILE_FS_LABEL_INFORMATION;
typedef UNALIGNED RDP_FILE_FS_LABEL_INFORMATION * PRDP_FILE_FS_LABEL_INFORMATION;

typedef struct _RDP_FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG VolumeSerialNumber;
    ULONG VolumeLabelLength;
    BYTE  SupportsObjects;
    WCHAR VolumeLabel[1];    
} RDP_FILE_FS_VOLUME_INFORMATION;
typedef UNALIGNED RDP_FILE_FS_VOLUME_INFORMATION * PRDP_FILE_FS_VOLUME_INFORMATION;
                
typedef struct _RDP_FILE_FS_SIZE_INFORMATION {
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER AvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} RDP_FILE_FS_SIZE_INFORMATION;
typedef UNALIGNED RDP_FILE_FS_SIZE_INFORMATION * PRDP_FILE_FS_SIZE_INFORMATION;

typedef struct _RDP_FILE_FS_FULL_SIZE_INFORMATION {
    LARGE_INTEGER TotalAllocationUnits;
    LARGE_INTEGER CallerAvailableAllocationUnits;
    LARGE_INTEGER ActualAvailableAllocationUnits;
    ULONG SectorsPerAllocationUnit;
    ULONG BytesPerSector;
} RDP_FILE_FS_FULL_SIZE_INFORMATION;
typedef UNALIGNED RDP_FILE_FS_FULL_SIZE_INFORMATION * PRDP_FILE_FS_FULL_SIZE_INFORMATION;

typedef struct _RDP_FILE_FS_ATTRIBUTE_INFORMATION {
    ULONG FileSystemAttributes;
    LONG MaximumComponentNameLength;
    ULONG FileSystemNameLength;
    WCHAR FileSystemName[1];    
} RDP_FILE_FS_ATTRIBUTE_INFORMATION;
typedef UNALIGNED RDP_FILE_FS_ATTRIBUTE_INFORMATION * PRDP_FILE_FS_ATTRIBUTE_INFORMATION;


//
// Define the file information class
// Server can query the client file with 
// each of these information class.
// These are defined in ntioapi.h
//
typedef enum _RDP_FILE_INFORMATION_CLASS {
    RdpFileDirectoryInformation       = 1,
    RdpFileFullDirectoryInformation, // 2
    RdpFileBothDirectoryInformation, // 3
    RdpFileBasicInformation,         // 4  
    RdpFileStandardInformation,      // 5  
    RdpFileInternalInformation,      // 6
    RdpFileEaInformation,            // 7
    RdpFileAccessInformation,        // 8
    RdpFileNameInformation,          // 9
    RdpFileRenameInformation,        // 10
    RdpFileLinkInformation,          // 11
    RdpFileNamesInformation,         // 12
    RdpFileDispositionInformation,   // 13
    RdpFilePositionInformation,      // 14 
    RdpFileFullEaInformation,        // 15
    RdpFileModeInformation,          // 16
    RdpFileAlignmentInformation,     // 17
    RdpFileAllInformation,           // 18
    RdpFileAllocationInformation,    // 19
    RdpFileEndOfFileInformation,     // 20 
    RdpFileAlternateNameInformation, // 21
    RdpFileStreamInformation,        // 22
    RdpFilePipeInformation,          // 23
    RdpFilePipeLocalInformation,     // 24
    RdpFilePipeRemoteInformation,    // 25
    RdpFileMailslotQueryInformation, // 26
    RdpFileMailslotSetInformation,   // 27
    RdpFileCompressionInformation,   // 28
    RdpFileObjectIdInformation,      // 29
    RdpFileCompletionInformation,    // 30
    RdpFileMoveClusterInformation,   // 31
    RdpFileQuotaInformation,         // 32
    RdpFileReparsePointInformation,  // 33
    RdpFileNetworkOpenInformation,   // 34
    RdpFileAttributeTagInformation,  // 35
    RdpFileTrackingInformation,      // 36
    RdpFileMaximumInformation
} RDP_FILE_INFORMATION_CLASS, *PRDP_FILE_INFORMATION_CLASS;

//
//  This is the maximum length for the file information structures
//  (not including variable file length)
//  Need to update this value if there is update to the file
//  information structures
//
#define RDP_FILE_INFORMATION_MAXLENGTH  36

//
// Define file information classes
//
typedef struct _RDP_FILE_BASIC_INFORMATION {                 
    LARGE_INTEGER CreationTime;                             
    LARGE_INTEGER LastAccessTime;                           
    LARGE_INTEGER LastWriteTime;                            
    LARGE_INTEGER ChangeTime;                               
    ULONG FileAttributes;                                   
} RDP_FILE_BASIC_INFORMATION;
typedef UNALIGNED RDP_FILE_BASIC_INFORMATION * PRDP_FILE_BASIC_INFORMATION;

typedef struct _RDP_FILE_STANDARD_INFORMATION {            
    LARGE_INTEGER AllocationSize;                          
    LARGE_INTEGER EndOfFile;                               
    ULONG NumberOfLinks;                                   
    BOOLEAN DeletePending;                                 
    BOOLEAN Directory;                                     
} RDP_FILE_STANDARD_INFORMATION;
typedef UNALIGNED RDP_FILE_STANDARD_INFORMATION * PRDP_FILE_STANDARD_INFORMATION;

typedef struct _RDP_FILE_ATTRIBUTE_TAG_INFORMATION {       
    ULONG FileAttributes;                                  
    ULONG ReparseTag;                                      
} RDP_FILE_ATTRIBUTE_TAG_INFORMATION;
typedef UNALIGNED RDP_FILE_ATTRIBUTE_TAG_INFORMATION * PRDP_FILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _RDP_FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} RDP_FILE_INTERNAL_INFORMATION;
typedef UNALIGNED RDP_FILE_INTERNAL_INFORMATION * PRDP_FILE_INTERNAL_INFORMATION;

typedef struct _RDP_FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    BOOLEAN RootDirectory;     // Specify if the FileName contains the root directory
    ULONG FileNameLength;
    WCHAR FileName[1];
} RDP_FILE_RENAME_INFORMATION;
typedef RDP_FILE_RENAME_INFORMATION * PRDP_FILE_RENAME_INFORMATION;

// 
//  This is the maximum length for any directory information structure
//  (not including variable file length)
//  Need to update this macro if there is update to the directory
//  information structure
//
#define RDP_FILE_DIRECTORY_INFO_MAXLENGTH   96 

typedef struct _RDP_FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];    
} RDP_FILE_DIRECTORY_INFORMATION;
typedef UNALIGNED RDP_FILE_DIRECTORY_INFORMATION * PRDP_FILE_DIRECTORY_INFORMATION;

typedef struct _RDP_FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];    
} RDP_FILE_FULL_DIR_INFORMATION;
typedef UNALIGNED RDP_FILE_FULL_DIR_INFORMATION *PRDP_FILE_FULL_DIR_INFORMATION;

typedef struct _RDP_FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CHAR  ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} RDP_FILE_BOTH_DIR_INFORMATION;
typedef UNALIGNED RDP_FILE_BOTH_DIR_INFORMATION *PRDP_FILE_BOTH_DIR_INFORMATION;

typedef struct _RDP_FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];    
} RDP_FILE_NAMES_INFORMATION;
typedef UNALIGNED RDP_FILE_NAMES_INFORMATION * PRDP_FILE_NAMES_INFORMATION;

typedef struct _RDP_FILE_END_OF_FILE_INFORMATION {                  
    LARGE_INTEGER EndOfFile;                                    
} RDP_FILE_END_OF_FILE_INFORMATION;
typedef UNALIGNED RDP_FILE_END_OF_FILE_INFORMATION * PRDP_FILE_END_OF_FILE_INFORMATION;

//
//  File I/O Operation
//  This is defined in mrx.h
//
typedef enum _RDP_LOWIO_OPS {
  RDP_LOWIO_OP_READ=0,
  RDP_LOWIO_OP_WRITE,
  RDP_LOWIO_OP_SHAREDLOCK,
  RDP_LOWIO_OP_EXCLUSIVELOCK,
  RDP_LOWIO_OP_UNLOCK,
  RDP_LOWIO_OP_UNLOCK_MULTIPLE,
  //LOWIO_OP_UNLOCKALLBYKEY,
  RDP_LOWIO_OP_FSCTL,
  RDP_LOWIO_OP_IOCTL,
  RDP_LOWIO_OP_NOTIFY_CHANGE_DIRECTORY,
  RDP_LOWIO_OP_CLEAROUT,
  RDP_LOWIO_OP_MAXIMUM
} RDP_LOWIO_OPS;

//
// File locking information
//
typedef struct _RDP_LOCK_INFO {
  LONG  LengthLow;       // Number of bytes to lock
  LONG  LengthHigh;
  LONG  OffsetLow;
  LONG  OffsetHigh;      // Byte offset where lock starts
} RDP_LOCK_INFO;
typedef UNALIGNED RDP_LOCK_INFO *PRDP_LOCK_INFO;

//
// Lock flags
//

#define SL_FAIL_IMMEDIATELY             0x01
#define SL_EXCLUSIVE_LOCK               0x02


typedef ULONG SECURITY_INFORMATION, *PSECURITY_INFORMATION;

//
//  RDPDR_DEVICE_IOREQUEST
//
//  Sent by the server to get an IO Request processed on a device
//
//  IRP_MJ_CREATE
//  IRP_MJ_CLEANUP
//  IRP_MJ_CLOSE
//  IRP_MJ_READ
//  IRP_MJ_WRITE
//  IRP_MJ_FLUSH_BUFFERS
//  IRP_MJ_SHUTDOWN
//  IRP_MJ_DEVICE_CONTROL
//  IRP_MJ_INTERNAL_DEVICE_CONTROL
//
//  The specific IOCTLs for serial DEVICE_CONTROL calls are:
//
//  <split these in to sent and handled locally?>
//  IOCTL_SERIAL_SET_BAUD_RATE
//  IOCTL_SERIAL_GET_BAUD_RATE
//  IOCTL_SERIAL_SET_LINE_CONTROL
//  IOCTL_SERIAL_GET_LINE_CONTROL
//  IOCTL_SERIAL_SET_TIMEOUTS
//  IOCTL_SERIAL_GET_TIMEOUTS
//  IOCTL_SERIAL_SET_CHARS
//  IOCTL_SERIAL_GET_CHARS
//  IOCTL_SERIAL_SET_DTR
//  IOCTL_SERIAL_CLR_DTR
//  IOCTL_SERIAL_RESET_DEVICE
//  IOCTL_SERIAL_SET_RTS
//  IOCTL_SERIAL_CLR_RTS
//  IOCTL_SERIAL_SET_XOFF
//  IOCTL_SERIAL_SET_XON
//  IOCTL_SERIAL_SET_BREAK_ON
//  IOCTL_SERIAL_SET_BREAK_OFF
//  IOCTL_SERIAL_SET_QUEUE_SIZE
//  IOCTL_SERIAL_GET_WAIT_MASK
//  IOCTL_SERIAL_SET_WAIT_MASK
//  IOCTL_SERIAL_WAIT_ON_MASK
//  IOCTL_SERIAL_IMMEDIATE_CHAR
//  IOCTL_SERIAL_PURGE
//  IOCTL_SERIAL_GET_HANDFLOW
//  IOCTL_SERIAL_SET_HANDFLOW
//  IOCTL_SERIAL_GET_MODEMSTATUS
//  IOCTL_SERIAL_GET_DTRRTS
//  IOCTL_SERIAL_GET_COMMSTATUS
//  IOCTL_SERIAL_GET_PROPERTIES
//  IOCTL_SERIAL_XOFF_COUNTER
//  IOCTL_SERIAL_LSRMST_INSERT
//  IOCTL_SERIAL_CONFIG_SIZE
//  IOCTL_SERIAL_GET_STATS
//  IOCTL_SERIAL_CLEAR_STATS
//
//  The specific IOCTLs for parallel DEVICE_CONTROL calls are:
//
//  For IRP_MJ_DEVICE_CONTROL:
//      IOCTL_PAR_QUERY_INFORMATION
//      IOCTL_PAR_SET_INFORMATION
//      IOCTL_PAR_QUERY_DEVICE_ID
//      IOCTL_PAR_QUERY_DEVICE_ID_SIZE
//      IOCTL_SERIAL_GET_TIMEOUTS
//      IOCTL_SERIAL_SET_TIMEOUTS
//
//  For IRP_MJ_INTERNAL_DEVICE_CONTROL:
//      IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO
//      IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE
//      IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT
//      IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT
//
//
typedef struct tagRDPDR_DEVICE_IOREQUEST
{
    ULONG   DeviceId;           // Id used in DeviceAnnounce
    ULONG   FileId;             // Id for file on the device
    ULONG   CompletionId;       // Id to return completion status
    ULONG   MajorFunction;      // The IRP_MJ_XXX request
    ULONG   MinorFunction;      // The subfunction of above, usually for SCSI
    //
    // The following Parameters depend on the IRP_MJ_XXX that is set
    // in MajorFunction.
    //

    union {
        // IRP_MJ_CREATE
        struct {
            ACCESS_MASK         DesiredAccess;
            LARGE_INTEGER       AllocationSize;
            ULONG               FileAttributes;
            ULONG               ShareAccess;
            ULONG               Disposition;
            ULONG               CreateOptions;
            ULONG               PathLength;
            // PathLength Bytes follow
        } Create;

        // IRP_MJ_CLEANUP
        // Sent, no structure

        // IRP_MJ_CLOSE
        // Sent, no structure

        // IRP_MJ_READ
        struct {
            ULONG Length;       // Number of UCHARs to read
            LONG  OffsetLow;    // Byte offset where read starts
            LONG  OffsetHigh;   // offset is defined from the beginning of the file
            // Length Bytes follow
        } Read;
        
        // IRP_MJ_WRITE
        struct {
            ULONG Length;       // Number of UCHARs to write
            LONG  OffsetLow;    // Byte offset where write starts
            LONG  OffsetHigh;   // offset is defined from the beginning of the file
            // Length Bytes follow
        } Write;
        
        // IRP_MJ_FLUSH_BUFFERS
        // Sent, no structure
        
        // IRP_MJ_SHUTDOWN
        // Not sent, no structure
        
        // IRP_MJ_DEVICE_CONTROL, IRP_MJ_INTERNAL_DEVICE_CONTROL
        // IRP_MJ_FILE_SYSTEM_CONTROL is collapsed into device control
        // on the client side
        struct {
            ULONG OutputBufferLength;
            ULONG InputBufferLength;
            ULONG IoControlCode;        // IOCTL_XXX
            // InputBufferLength Bytes follow
        } DeviceIoControl;
        
        // IRP_MJ_QUERY_VOLUME_INFORMATION
        struct {
            RDP_FS_INFORMATION_CLASS FsInformationClass;
            ULONG Length;    // length of query buffer
        } QueryVolume;

        // IRP_MJ_SET_VOLUME_INFORMATION
        struct {
            RDP_FS_INFORMATION_CLASS FsInformationClass;
            ULONG Length;
            //Length Bytes follow
        } SetVolume;

        // IRP_MJ_QUERY_INFORMATION
        struct {
            RDP_FILE_INFORMATION_CLASS FileInformationClass;
            ULONG Length;    // length of query buffer
        } QueryFile;

        // IRP_MJ_SET_INFORMATION
        struct {
            RDP_FILE_INFORMATION_CLASS FileInformationClass;
            ULONG Length;
            //Length Bytes follow
        } SetFile;

        // IRP_MJ_QUERY_SECURITY
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;    // length of query buffer
        } QuerySd;

        // IRP_MJ_SET_SECURITY
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } SetSd;

        // IRP_MJ_DIRECTORY_CONTROL
        struct {
            RDP_FILE_INFORMATION_CLASS FileInformationClass;
            BOOLEAN InitialQuery;
            ULONG PathLength;
            ULONG Length;    // length of query buffer
            // PathLength Bytes follow
        } QueryDir;

        // IRP_MJ_DIRECTORY_CONTROL
        struct {            
            BOOLEAN WatchTree;
            ULONG CompletionFilter;
            ULONG Length;            
        } NotifyChangeDir;
         
        // IRP_MJ_LOCK_CONTROL
        struct {
            ULONG Operation;
            ULONG Flags;
            ULONG NumLocks;
            // LockInfo List follow
        } Locks;

    } Parameters;
} RDPDR_DEVICE_IOREQUEST, *PRDPDR_DEVICE_IOREQUEST;

typedef struct tagRDPDR_IOREQUEST_PACKET
{
    RDPDR_HEADER            Header;
    RDPDR_DEVICE_IOREQUEST  IoRequest;
} RDPDR_IOREQUEST_PACKET, *PRDPDR_IOREQUEST_PACKET;


//
//  RDPDR_DEVICE_IOCOMPLETION
//
//  Sent by the client to indicate an I/O operation has completed
//
typedef struct tagRDPDR_DEVICE_IOCOMPLETION
{
    ULONG   DeviceId;           // Given a CompletionId, is this necessary?
    ULONG   CompletionId;       // Completion Id supplied by the request
    ULONG   IoStatus;           // Status code

    //
    // The following Parameters depend on the IRP_MJ_XXX that was set
    // in the MajorFunction element of the original request.
    //

    union {
        // IRP_MJ_CREATE
        struct {
            ULONG FileId;       // File to refer to in future IO operations
            UCHAR Information;  // Create/Open return information
        } Create;
        // Sent, no structure

        // IRP_MJ_CLEANUP
        // Sent, no structure

        // IRP_MJ_CLOSE
        // Sent, no structure

        // IRP_MJ_READ
        struct {
            ULONG Length;       // Number of UCHARs that were read
            UCHAR Buffer[1];    // UCHARs that were read
        } Read;

        // IRP_MJ_WRITE
        struct {
            ULONG Length;       // Number of UCHARs that were written
        } Write;

        // IRP_MJ_FLUSH_BUFFERS
        // Sent, no structure
        
        // IRP_MJ_SHUTDOWN
        // Not sent, no structure
        
        // IRP_MJ_DEVICE_CONTROL, IRP_MJ_INTERNAL_DEVICE_CONTROL
        // IRP_MJ_FILE_SYSTEM_CONTROL is collapsed into device control
        // on the client side
        struct {
            ULONG OutputBufferLength;
            UCHAR OutputBuffer[1];       // Depends on IOCTL_XXX
        } DeviceIoControl;

        // IRP_MJ_QUERY_VOLUME_INFORMATION
        struct {
            ULONG Length;
            UCHAR Buffer[1];
        } QueryVolume;

        // IRP_MJ_SET_VOLUME_INFORMATION
        struct {
            ULONG Length;            
        } SetVolume;

        // IRP_MJ_QUERY_INFORMATION
        struct {
            ULONG Length;
            UCHAR Buffer[1];
        } QueryFile;

        // IRP_MJ_SET_INFORMATION
        struct {
            ULONG Length;
        } SetFile;

        // IRP_MJ_DIRECTORY_CONTROL
        struct {
            ULONG Length;
            UCHAR Buffer[1];
        } QueryDir;

        // IRP_MJ_QUERY_SECURITY
        struct {
            ULONG Length;
            UCHAR Buffer[1];
        } QuerySd;

        // IRP_MJ_SET_SECURITY
        struct {
            ULONG Length;
        } SetSd;

        // IRP_MJ_LOCK_CONTROL
        // Sent, no structure

    } Parameters;

} RDPDR_DEVICE_IOCOMPLETION, *PRDPDR_DEVICE_IOCOMPLETION;

typedef struct tagRDPDR_IOCOMPLETION_PACKET
{
    RDPDR_HEADER                Header;
    RDPDR_DEVICE_IOCOMPLETION   IoCompletion;
} RDPDR_IOCOMPLETION_PACKET, *PRDPDR_IOCOMPLETION_PACKET;

//
//  RDPDRDVMGR Event Header
//
//  This header prefixes all device management events.
//
typedef struct tagRDPDRDVMGR_EVENTHEADER
{
    ULONG   EventType;            // Event-Type Field
    ULONG   EventLength;          // Event-Length Field
} RDPDRDVMGR_EVENTHEADER, *PRDPDRDVMGR_EVENTHEADER;

//
//  Buffer Too-Small Event
//
typedef struct tagRDPDR_BUFFERTOOSMALL
{
    ULONG   RequiredSize;           // Required Size for Request to Succeed.
} RDPDR_BUFFERTOOSMALL, *PRDPDR_BUFFERTOOSMALL;

//
//  This information is sent to the server from the client.
//
//  It contains information about a client-attached printing device and
//  is included with the RDPDR_DEVICE_ANNOUNCE struct ... following the
//  rest of the RDPDR_DEVICE_ANNOUNCE struct fields.
//
typedef struct tagRDPDR_PRINTERDEVICE_ANNOUNCE
{
    ULONG   Flags;                  // Contain the flag bits defined below
                                    // 
    ULONG   CodePage;               // Ansi code page to use to convert the
                                    // ansi string to unicode.
    ULONG   PnPNameLen;             // Length (in bytes) of PnP wide-character name
                                    //  that was discovered by the client.
    ULONG   DriverLen;              // Length (in bytes) of driver wide-character
                                    //  name that was discovered by the client.
    ULONG   PrinterNameLen;         // Length (in bytes) of printer wide-character
                                    //  name that was discovered by the client.
    ULONG   CachedFieldsLen;        // This is simply printer-associated binary
                                    //  data that is stashed away on the client
                                    //  machine for the server.  Note that this
                                    //  data is specific to the server that
                                    //  cached the data.
    // The actual fields corresponding to the above field lengths follow this
    // struct in the order that the field lengths appear in this typedef.
} RDPDR_PRINTERDEVICE_ANNOUNCE, *PRDPDR_PRINTERDEVICE_ANNOUNCE;

//  RDPDR_PRINTERDEVICE_ANNOUNCE structure contains ansi strings
#define RDPDR_PRINTER_ANNOUNCE_FLAG_ANSI                    0x1 

//  The printer being announced is the default printer on the client.
#define RDPDR_PRINTER_ANNOUNCE_FLAG_DEFAULTPRINTER          0x2

//  The printer being announced is a network printer
#define RDPDR_PRINTER_ANNOUNCE_FLAG_NETWORKPRINTER          0x4

//  The printer being announced is a TS redirected printer
// It means that the printer name has been rebuilt by the client
// and the name is based on the original server/client/printer names
// (the printer is going to be nested or is nested at the nth level).
#define RDPDR_PRINTER_ANNOUNCE_FLAG_TSPRINTER               0x8

#define DEVICERDR_PRINT_SERVER_NAME     TEXT("PrintServerName")
#define DEVICERDR_CLIENT_NAME           TEXT("ClientName")
#define DEVICERDR_PRINTER_NAME          TEXT("PrinterName")

//
// cache data printer events.
//

#define RDPDR_ADD_PRINTER_EVENT     0x1
#define RDPDR_UPDATE_PRINTER_EVENT  0x2
#define RDPDR_DELETE_PRINTER_EVENT  0x3
#define RDPDR_RENAME_PRINTER_EVENT  0x4

typedef struct tagRDPDR_PRINTER_CACHEDATA_PACKET
{
    RDPDR_HEADER                    Header;
    ULONG                           EventId;

    //
    // data structure that corresponds to the EventID will follow.
    // Ex: for AddPrinter Event RDPDR_PRINTER_ADD_CACHEDATA will follow.
    //

} RDPDR_PRINTER_CACHEDATA_PACKET, *PRDPDR_PRINTER_CACHEDATA_PACKET;

//
//  RDPDR_PRINTER_ADD_CACHEDATA
//
//  This structure is sent to the client from the server, when a new printer
//  queue is manually added to the user session.
//
//
typedef struct tagRDPDR_PRINTER_ADD_CACHEDATA
{
    UCHAR   PortDosName[PREFERRED_DOS_NAME_SIZE];
                                    // port name in ANSI format.
    ULONG   PnPNameLen;             // Length (in bytes) of PnP wide-character name
                                    //  that was discovered by the client.
    ULONG   DriverLen;              // Length (in bytes) of driver wide-character
                                    //  name that was discovered by the client.
    ULONG   PrinterNameLen;         // Length (in bytes) of printer wide-character
                                    //  name that was discovered by the client.
    ULONG   CachedFieldsLen;        // This is simply printer-associated binary
                                    //  data that is stashed away on the client
                                    //  machine for the server.  Note that this
                                    //  data is specific to the server that
                                    //  cached the data.
    // variable length data will follow.
} RDPDR_PRINTER_ADD_CACHEDATA, *PRDPDR_PRINTER_ADD_CACHEDATA;

//
//  RDPDR_PRINTER_DELETE_CACHEDATA
//
//  This structure is sent to the client from the server, when a printer
//  queue is manually deleted from the user session.
//
//
typedef struct tagRDPDR_PRINTER_DELETE_CACHEDATA
{
    ULONG   PrinterNameLen;         // Length (in bytes) of printer wide-character
                                    //  name.
    // string data will follow.
} RDPDR_PRINTER_DELETE_CACHEDATA, *PRDPDR_PRINTER_DELETE_CACHEDATA;

//
//  RDPDR_PRINTER_RENAME_CACHEDATA
//
//  This structure is sent to the client from the server, when a printer
//  queue is manually renamed from the user session.
//
//
typedef struct tagRDPDR_PRINTER_RENAME_CACHEDATA
{
    ULONG   OldPrinterNameLen;      // Length (in bytes) of printer
                                    //  wide-character name.

    ULONG   NewPrinterNameLen;      // Length (in bytes) of printer
                                    //  wide-character name.
    // string data will follow.
} RDPDR_PRINTER_RENAME_CACHEDATA, *PRDPDR_PRINTER_RENAME_CACHEDATA;

//
//  RDPDR_PRINTER_UPDATE_CACHEDATA
//
//  This structure is sent to the client from the server, when the printer
//  configuration is modified.
//
//
typedef struct tagRDPDR_PRINTER_UPDATE_CACHEDATA
{
    ULONG   PrinterNameLen;         // Length (in bytes) of printer wide-character
                                    //  name.
    ULONG   ConfigDataLen;          // Length of the cache data that will
                                    //  follow the printer name.

    // string data will follow.
} RDPDR_PRINTER_UPDATE_CACHEDATA, *PRDPDR_PRINTER_UPDATE_CACHEDATA;

//
//  Printer device "subclass" of RDPDR_DEVICE_ANNOUNCE.
//  This message is sent from the kernel-mode "dr" to the user-mode
//  "dr" so the user-mode "dr" can install a printer.
//
typedef struct tagRDPDR_PRINTERDEVICE_SUB
{
    WCHAR                           portName[RDPDR_MAXPORTNAMELEN];
    WCHAR                           clientName[RDPDR_MAX_COMPUTER_NAME_LENGTH];
    RDPDR_DEVICE_ANNOUNCE           deviceFields;
    RDPDR_PRINTERDEVICE_ANNOUNCE    clientPrinterFields;
} RDPDR_PRINTERDEVICE_SUB, *PRDPDR_PRINTERDEVICE_SUB;

//
//  Drive device "subclass" of RDPDR_DEVICE_ANNOUNCE.
//  This message is sent from the kernel-mode "dr" to the user-mode
//  "dr" so the user-mode "dr" can create a UNC connection.
//
typedef struct tagRDPDR_DRIVEDEVICE_SUB
{
    WCHAR                           driveName[RDPDR_MAXPORTNAMELEN];
    WCHAR                           clientName[RDPDR_MAX_COMPUTER_NAME_LENGTH];
    RDPDR_DEVICE_ANNOUNCE           deviceFields;
    WCHAR                           clientDisplayName[RDPDR_MAX_CLIENT_DISPLAY_NAME];
} RDPDR_DRIVEDEVICE_SUB, *PRDPDR_DRIVEDEVICE_SUB;

//
//  Indicate to the user-mode component that a device has been removed.
//
typedef struct tagRDPDR_REMOVEDEVICE
{
    ULONG       deviceID;
} RDPDR_REMOVEDEVICE, *PRDPDR_REMOVEDEVICE;

//
//  Port device "subclass" of RDPDR_DEVICE_ANNOUNCE.  This message is
//  sent from the kernel-mode "dr" to the user-mode "dr" so the user-mode
//  "dr" can install a port.
//
typedef struct tagRDPDR_PORTDEVICE_SUB
{
    WCHAR                           portName[RDPDR_MAXPORTNAMELEN];
    WCHAR                           devicePath[RDPDRMAXNTDEVICENAMEGLEN];
    RDPDR_DEVICE_ANNOUNCE           deviceFields;
} RDPDR_PORTDEVICE_SUB, *PRDPDR_PORTDEVICE_SUB;

//
// Restore packing style (previous for 32-bit, default for 16-bit).
//
#ifdef OS_WIN16
#pragma pack ()
#else
#pragma pack (pop, drpack)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // RDPDR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdchost_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdchost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDataChannelIO,0x43A09182,0x0472,0x436E,0x98,0x83,0x2D,0x95,0xC3,0x47,0xC5,0xF1);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopClient,0x8AA5F108,0x2918,0x435C,0x88,0xAA,0xDE,0x0A,0xFE,0xE5,0x14,0x40);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopClientHost,0x69DE5BF3,0x5EB9,0x4158,0x81,0xDA,0x6F,0xD6,0x62,0xBB,0xDD,0xDD);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopTestExtension,0x5C7A32EF,0x1C77,0x4F35,0x8F,0xBA,0x72,0x9D,0xD2,0xDE,0x72,0x22);


MIDL_DEFINE_GUID(IID, LIBID_RDCCLIENTHOSTLib,0x97917068,0xBB0B,0x4DDA,0x80,0x67,0xB1,0xA0,0x0C,0x89,0x0F,0x44);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopDataChannelEvents,0x59AE79BC,0x9721,0x42df,0x93,0x96,0x9D,0x98,0xE7,0xF7,0xA3,0x96);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopClientHost,0x299BE050,0xE83E,0x4DB7,0xA7,0xDA,0xD8,0x6F,0xDE,0xBF,0xE6,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_ClientDataChannel,0xC91C2A81,0x8B14,0x4a96,0xA5,0xDB,0x46,0x40,0xF5,0x51,0xF3,0xEE);


MIDL_DEFINE_GUID(CLSID, CLSID_ClientRemoteDesktopChannelMgr,0x078BB428,0xFA9B,0x43f1,0xB0,0x02,0x1A,0xBF,0x3A,0x8C,0x95,0xCF);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopClientEvents,0x327A98F6,0xB337,0x43B0,0xA3,0xDE,0x40,0x8B,0x46,0xE6,0xC4,0xCE);


MIDL_DEFINE_GUID(IID, DIID__IDataChannelIOEvents,0x85C037E5,0x743F,0x4938,0x93,0x6B,0xA8,0xDB,0x95,0x43,0x03,0x91);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopClient,0xB90D0115,0x3AEA,0x45D3,0x80,0x1E,0x93,0x91,0x30,0x08,0xD4,0x9E);


MIDL_DEFINE_GUID(CLSID, CLSID_TSRDPRemoteDesktopClient,0xF137E241,0x0092,0x4575,0x97,0x6A,0xD3,0xE3,0x39,0x80,0xBB,0x26);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdchost.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDataChannelIO,0x43A09182,0x0472,0x436E,0x98,0x83,0x2D,0x95,0xC3,0x47,0xC5,0xF1);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopClient,0x8AA5F108,0x2918,0x435C,0x88,0xAA,0xDE,0x0A,0xFE,0xE5,0x14,0x40);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopClientHost,0x69DE5BF3,0x5EB9,0x4158,0x81,0xDA,0x6F,0xD6,0x62,0xBB,0xDD,0xDD);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopTestExtension,0x5C7A32EF,0x1C77,0x4F35,0x8F,0xBA,0x72,0x9D,0xD2,0xDE,0x72,0x22);


MIDL_DEFINE_GUID(IID, LIBID_RDCCLIENTHOSTLib,0x97917068,0xBB0B,0x4DDA,0x80,0x67,0xB1,0xA0,0x0C,0x89,0x0F,0x44);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopDataChannelEvents,0x59AE79BC,0x9721,0x42df,0x93,0x96,0x9D,0x98,0xE7,0xF7,0xA3,0x96);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopClientHost,0x299BE050,0xE83E,0x4DB7,0xA7,0xDA,0xD8,0x6F,0xDE,0xBF,0xE6,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_ClientDataChannel,0xC91C2A81,0x8B14,0x4a96,0xA5,0xDB,0x46,0x40,0xF5,0x51,0xF3,0xEE);


MIDL_DEFINE_GUID(CLSID, CLSID_ClientRemoteDesktopChannelMgr,0x078BB428,0xFA9B,0x43f1,0xB0,0x02,0x1A,0xBF,0x3A,0x8C,0x95,0xCF);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopClientEvents,0x327A98F6,0xB337,0x43B0,0xA3,0xDE,0x40,0x8B,0x46,0xE6,0xC4,0xCE);


MIDL_DEFINE_GUID(IID, DIID__IDataChannelIOEvents,0x85C037E5,0x743F,0x4938,0x93,0x6B,0xA8,0xDB,0x95,0x43,0x03,0x91);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopClient,0xB90D0115,0x3AEA,0x45D3,0x80,0x1E,0x93,0x91,0x30,0x08,0xD4,0x9E);


MIDL_DEFINE_GUID(CLSID, CLSID_TSRDPRemoteDesktopClient,0xF137E241,0x0092,0x4575,0x97,0x6A,0xD3,0xE3,0x39,0x80,0xBB,0x26);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdfilter.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    RDFilter

Abstract:

    API's for filtering desktop visual elements for remote connections of
    varying connection speeds for performance reasons.

Author:

    Tad Brockway 02/00

Revision History:

--*/

#ifndef __RDFILTER_H__
#define __RDFILTER_H__

#include <tsperf.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Flags Values
//
#define RDFILTER_SKIPTHEMESREFRESH  0x1
#define RDFILTER_SKIPUSERREFRESH    0x2
#define RDFILTER_SKIPSHELLREFRESH   0x4

//
//  Applies specified filter for the active TS session by adjusting visual 
//  desktop settings.  Also notifies shell, etc. that a remote filter is in place.  
//  Any previous filter settings will be destroyed and overwritten.
//
//  The context for this call should be that of the logged on user and the call
//  should be made within the session for which the filter is intended to be 
//  applied.
//
DWORD RDFilter_ApplyRemoteFilter(HANDLE hLoggedOnUserToken, DWORD filter, 
                                 BOOL userLoggingOn, DWORD flags);

//
//  Removes existing remote filter settings and notifies shell, etc. that
//  a remote filter is no longer in place for the active TS session.  
//
//  The context for this call should be that of the logged on user and the call
//  should be made within the session for which the filter is intended to be 
//  applied.
//
VOID RDFilter_ClearRemoteFilter(HANDLE hLoggedOnUserToken,
                                 BOOL userLoggingOn, DWORD flags);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdschan.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdschan.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rdschan_h__
#define __rdschan_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISAFRemoteDesktopDataChannel_FWD_DEFINED__
#define __ISAFRemoteDesktopDataChannel_FWD_DEFINED__
typedef interface ISAFRemoteDesktopDataChannel ISAFRemoteDesktopDataChannel;
#endif 	/* __ISAFRemoteDesktopDataChannel_FWD_DEFINED__ */


#ifndef __ISAFRemoteDesktopChannelMgr_FWD_DEFINED__
#define __ISAFRemoteDesktopChannelMgr_FWD_DEFINED__
typedef interface ISAFRemoteDesktopChannelMgr ISAFRemoteDesktopChannelMgr;
#endif 	/* __ISAFRemoteDesktopChannelMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_rdschan_0000 */
/* [local] */ 


#define DISPID_RDSDATACHANNEL_CHANNELNAME			1
#define DISPID_RDSDATACHANNEL_ONCHANNELDATAREADY		2
#define DISPID_RDSDATACHANNEL_SENDCHANNELDATA		3
#define DISPID_RDSDATACHANNEL_RECEIVECHANNELDATA		4



extern RPC_IF_HANDLE __MIDL_itf_rdschan_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdschan_0000_v0_0_s_ifspec;

#ifndef __ISAFRemoteDesktopDataChannel_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopDataChannel_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopDataChannel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopDataChannel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64976FAE-B108-4095-8E59-5874E00E562A")
    ISAFRemoteDesktopDataChannel : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ChannelName( 
            /* [retval][out] */ BSTR *name) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnChannelDataReady( 
            /* [in] */ IDispatch *iDisp) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SendChannelData( 
            /* [in] */ BSTR data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReceiveChannelData( 
            /* [retval][out] */ BSTR *data) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopDataChannelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAFRemoteDesktopDataChannel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAFRemoteDesktopDataChannel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelName )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [retval][out] */ BSTR *name);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnChannelDataReady )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [in] */ IDispatch *iDisp);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SendChannelData )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [in] */ BSTR data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReceiveChannelData )( 
            ISAFRemoteDesktopDataChannel * This,
            /* [retval][out] */ BSTR *data);
        
        END_INTERFACE
    } ISAFRemoteDesktopDataChannelVtbl;

    interface ISAFRemoteDesktopDataChannel
    {
        CONST_VTBL struct ISAFRemoteDesktopDataChannelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopDataChannel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopDataChannel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopDataChannel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopDataChannel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopDataChannel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopDataChannel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopDataChannel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopDataChannel_get_ChannelName(This,name)	\
    (This)->lpVtbl -> get_ChannelName(This,name)

#define ISAFRemoteDesktopDataChannel_put_OnChannelDataReady(This,iDisp)	\
    (This)->lpVtbl -> put_OnChannelDataReady(This,iDisp)

#define ISAFRemoteDesktopDataChannel_SendChannelData(This,data)	\
    (This)->lpVtbl -> SendChannelData(This,data)

#define ISAFRemoteDesktopDataChannel_ReceiveChannelData(This,data)	\
    (This)->lpVtbl -> ReceiveChannelData(This,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopDataChannel_get_ChannelName_Proxy( 
    ISAFRemoteDesktopDataChannel * This,
    /* [retval][out] */ BSTR *name);


void __RPC_STUB ISAFRemoteDesktopDataChannel_get_ChannelName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopDataChannel_put_OnChannelDataReady_Proxy( 
    ISAFRemoteDesktopDataChannel * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopDataChannel_put_OnChannelDataReady_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopDataChannel_SendChannelData_Proxy( 
    ISAFRemoteDesktopDataChannel * This,
    /* [in] */ BSTR data);


void __RPC_STUB ISAFRemoteDesktopDataChannel_SendChannelData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopDataChannel_ReceiveChannelData_Proxy( 
    ISAFRemoteDesktopDataChannel * This,
    /* [retval][out] */ BSTR *data);


void __RPC_STUB ISAFRemoteDesktopDataChannel_ReceiveChannelData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopDataChannel_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rdschan_0253 */
/* [local] */ 


#define DISPID_RDSCHANNELMANAGER_OPENDATACHANNEL		1



extern RPC_IF_HANDLE __MIDL_itf_rdschan_0253_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdschan_0253_v0_0_s_ifspec;

#ifndef __ISAFRemoteDesktopChannelMgr_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopChannelMgr_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopChannelMgr */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopChannelMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E6E0954-33CE-4945-ACF7-6728D23B2067")
    ISAFRemoteDesktopChannelMgr : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenDataChannel( 
            /* [in] */ BSTR name,
            /* [retval][out] */ ISAFRemoteDesktopDataChannel **channel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopChannelMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAFRemoteDesktopChannelMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAFRemoteDesktopChannelMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAFRemoteDesktopChannelMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISAFRemoteDesktopChannelMgr * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISAFRemoteDesktopChannelMgr * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISAFRemoteDesktopChannelMgr * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISAFRemoteDesktopChannelMgr * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OpenDataChannel )( 
            ISAFRemoteDesktopChannelMgr * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ ISAFRemoteDesktopDataChannel **channel);
        
        END_INTERFACE
    } ISAFRemoteDesktopChannelMgrVtbl;

    interface ISAFRemoteDesktopChannelMgr
    {
        CONST_VTBL struct ISAFRemoteDesktopChannelMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopChannelMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopChannelMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopChannelMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopChannelMgr_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopChannelMgr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopChannelMgr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopChannelMgr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopChannelMgr_OpenDataChannel(This,name,channel)	\
    (This)->lpVtbl -> OpenDataChannel(This,name,channel)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopChannelMgr_OpenDataChannel_Proxy( 
    ISAFRemoteDesktopChannelMgr * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ ISAFRemoteDesktopDataChannel **channel);


void __RPC_STUB ISAFRemoteDesktopChannelMgr_OpenDataChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopChannelMgr_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdschan_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdschan.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopDataChannel,0x64976FAE,0xB108,0x4095,0x8E,0x59,0x58,0x74,0xE0,0x0E,0x56,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopChannelMgr,0x8E6E0954,0x33CE,0x4945,0xAC,0xF7,0x67,0x28,0xD2,0x3B,0x20,0x67);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdschan.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopDataChannel,0x64976FAE,0xB108,0x4095,0x8E,0x59,0x58,0x74,0xE0,0x0E,0x56,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopChannelMgr,0x8E6E0954,0x33CE,0x4945,0xAC,0xF7,0x67,0x28,0xD2,0x3B,0x20,0x67);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdshost.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdshost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __rdshost_h__
#define __rdshost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISAFRemoteDesktopSession_FWD_DEFINED__
#define __ISAFRemoteDesktopSession_FWD_DEFINED__
typedef interface ISAFRemoteDesktopSession ISAFRemoteDesktopSession;
#endif 	/* __ISAFRemoteDesktopSession_FWD_DEFINED__ */


#ifndef __IRDSThreadBridge_FWD_DEFINED__
#define __IRDSThreadBridge_FWD_DEFINED__
typedef interface IRDSThreadBridge IRDSThreadBridge;
#endif 	/* __IRDSThreadBridge_FWD_DEFINED__ */


#ifndef __ISAFRemoteDesktopServerHost_FWD_DEFINED__
#define __ISAFRemoteDesktopServerHost_FWD_DEFINED__
typedef interface ISAFRemoteDesktopServerHost ISAFRemoteDesktopServerHost;
#endif 	/* __ISAFRemoteDesktopServerHost_FWD_DEFINED__ */


#ifndef ___ISAFRemoteDesktopDataChannelEvents_FWD_DEFINED__
#define ___ISAFRemoteDesktopDataChannelEvents_FWD_DEFINED__
typedef interface _ISAFRemoteDesktopDataChannelEvents _ISAFRemoteDesktopDataChannelEvents;
#endif 	/* ___ISAFRemoteDesktopDataChannelEvents_FWD_DEFINED__ */


#ifndef __TSRDPServerDataChannel_FWD_DEFINED__
#define __TSRDPServerDataChannel_FWD_DEFINED__

#ifdef __cplusplus
typedef class TSRDPServerDataChannel TSRDPServerDataChannel;
#else
typedef struct TSRDPServerDataChannel TSRDPServerDataChannel;
#endif /* __cplusplus */

#endif 	/* __TSRDPServerDataChannel_FWD_DEFINED__ */


#ifndef __TSRDPServerDataChannelMgr_FWD_DEFINED__
#define __TSRDPServerDataChannelMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class TSRDPServerDataChannelMgr TSRDPServerDataChannelMgr;
#else
typedef struct TSRDPServerDataChannelMgr TSRDPServerDataChannelMgr;
#endif /* __cplusplus */

#endif 	/* __TSRDPServerDataChannelMgr_FWD_DEFINED__ */


#ifndef __SAFRemoteDesktopServerHost_FWD_DEFINED__
#define __SAFRemoteDesktopServerHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAFRemoteDesktopServerHost SAFRemoteDesktopServerHost;
#else
typedef struct SAFRemoteDesktopServerHost SAFRemoteDesktopServerHost;
#endif /* __cplusplus */

#endif 	/* __SAFRemoteDesktopServerHost_FWD_DEFINED__ */


#ifndef ___ISAFRemoteDesktopSessionEvents_FWD_DEFINED__
#define ___ISAFRemoteDesktopSessionEvents_FWD_DEFINED__
typedef interface _ISAFRemoteDesktopSessionEvents _ISAFRemoteDesktopSessionEvents;
#endif 	/* ___ISAFRemoteDesktopSessionEvents_FWD_DEFINED__ */


#ifndef __SAFRemoteDesktopSession_FWD_DEFINED__
#define __SAFRemoteDesktopSession_FWD_DEFINED__

#ifdef __cplusplus
typedef class SAFRemoteDesktopSession SAFRemoteDesktopSession;
#else
typedef struct SAFRemoteDesktopSession SAFRemoteDesktopSession;
#endif /* __cplusplus */

#endif 	/* __SAFRemoteDesktopSession_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "rdschan.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_rdshost_0000 */
/* [local] */ 

typedef /* [public][public][public][public][public][helpstring][uuid] */  DECLSPEC_UUID("34b3166d-870a-4f39-9e2a-09fd8d31ad83") 
enum __MIDL___MIDL_itf_rdshost_0000_0001
    {	DESKTOPSHARING_DEFAULT	= 0,
	NO_DESKTOP_SHARING	= 0x1,
	VIEWDESKTOP_PERMISSION_REQUIRE	= 0x2,
	VIEWDESKTOP_PERMISSION_NOT_REQUIRE	= 0x4,
	CONTROLDESKTOP_PERMISSION_REQUIRE	= 0x8,
	CONTROLDESKTOP_PERMISSION_NOT_REQUIRE	= 0x10
    } 	REMOTE_DESKTOP_SHARING_CLASS;


#define DISPID_RDSSESSION_CHANNELMANAGER			1
#define DISPID_RDSSESSION_CONNECTPARMS			2
#define DISPID_RDSSESSION_SHARINGCLASS			3
#define DISPID_RDSSESSION_ONCONNECTED            4
#define DISPID_RDSSESSION_ONDISCONNECTED			5
#define	DISPID_RDSSESSION_CLOSERDSSESSION		6
#define  DISPID_RDSSESSION_DISCONNECT            7



extern RPC_IF_HANDLE __MIDL_itf_rdshost_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdshost_0000_v0_0_s_ifspec;

#ifndef __ISAFRemoteDesktopSession_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopSession_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopSession */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9D8C82C9-A89F-42C5-8A52-FE2A77B00E82")
    ISAFRemoteDesktopSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ChannelManager( 
            /* [retval][out] */ ISAFRemoteDesktopChannelMgr **mgr) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectParms( 
            /* [retval][out] */ BSTR *parms) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SharingClass( 
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SharingClass( 
            /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *sharingClass) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseRemoteDesktopSession( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnConnected( 
            /* [in] */ IDispatch *iDisp) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OnDisconnected( 
            /* [in] */ IDispatch *iDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAFRemoteDesktopSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAFRemoteDesktopSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAFRemoteDesktopSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISAFRemoteDesktopSession * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISAFRemoteDesktopSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISAFRemoteDesktopSession * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISAFRemoteDesktopSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelManager )( 
            ISAFRemoteDesktopSession * This,
            /* [retval][out] */ ISAFRemoteDesktopChannelMgr **mgr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectParms )( 
            ISAFRemoteDesktopSession * This,
            /* [retval][out] */ BSTR *parms);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SharingClass )( 
            ISAFRemoteDesktopSession * This,
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SharingClass )( 
            ISAFRemoteDesktopSession * This,
            /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *sharingClass);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CloseRemoteDesktopSession )( 
            ISAFRemoteDesktopSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            ISAFRemoteDesktopSession * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnConnected )( 
            ISAFRemoteDesktopSession * This,
            /* [in] */ IDispatch *iDisp);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnDisconnected )( 
            ISAFRemoteDesktopSession * This,
            /* [in] */ IDispatch *iDisp);
        
        END_INTERFACE
    } ISAFRemoteDesktopSessionVtbl;

    interface ISAFRemoteDesktopSession
    {
        CONST_VTBL struct ISAFRemoteDesktopSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopSession_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopSession_get_ChannelManager(This,mgr)	\
    (This)->lpVtbl -> get_ChannelManager(This,mgr)

#define ISAFRemoteDesktopSession_get_ConnectParms(This,parms)	\
    (This)->lpVtbl -> get_ConnectParms(This,parms)

#define ISAFRemoteDesktopSession_put_SharingClass(This,sharingClass)	\
    (This)->lpVtbl -> put_SharingClass(This,sharingClass)

#define ISAFRemoteDesktopSession_get_SharingClass(This,sharingClass)	\
    (This)->lpVtbl -> get_SharingClass(This,sharingClass)

#define ISAFRemoteDesktopSession_CloseRemoteDesktopSession(This)	\
    (This)->lpVtbl -> CloseRemoteDesktopSession(This)

#define ISAFRemoteDesktopSession_Disconnect(This)	\
    (This)->lpVtbl -> Disconnect(This)

#define ISAFRemoteDesktopSession_put_OnConnected(This,iDisp)	\
    (This)->lpVtbl -> put_OnConnected(This,iDisp)

#define ISAFRemoteDesktopSession_put_OnDisconnected(This,iDisp)	\
    (This)->lpVtbl -> put_OnDisconnected(This,iDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_get_ChannelManager_Proxy( 
    ISAFRemoteDesktopSession * This,
    /* [retval][out] */ ISAFRemoteDesktopChannelMgr **mgr);


void __RPC_STUB ISAFRemoteDesktopSession_get_ChannelManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_get_ConnectParms_Proxy( 
    ISAFRemoteDesktopSession * This,
    /* [retval][out] */ BSTR *parms);


void __RPC_STUB ISAFRemoteDesktopSession_get_ConnectParms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_put_SharingClass_Proxy( 
    ISAFRemoteDesktopSession * This,
    /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass);


void __RPC_STUB ISAFRemoteDesktopSession_put_SharingClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_get_SharingClass_Proxy( 
    ISAFRemoteDesktopSession * This,
    /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *sharingClass);


void __RPC_STUB ISAFRemoteDesktopSession_get_SharingClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_CloseRemoteDesktopSession_Proxy( 
    ISAFRemoteDesktopSession * This);


void __RPC_STUB ISAFRemoteDesktopSession_CloseRemoteDesktopSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_Disconnect_Proxy( 
    ISAFRemoteDesktopSession * This);


void __RPC_STUB ISAFRemoteDesktopSession_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_put_OnConnected_Proxy( 
    ISAFRemoteDesktopSession * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopSession_put_OnConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopSession_put_OnDisconnected_Proxy( 
    ISAFRemoteDesktopSession * This,
    /* [in] */ IDispatch *iDisp);


void __RPC_STUB ISAFRemoteDesktopSession_put_OnDisconnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopSession_INTERFACE_DEFINED__ */


#ifndef __IRDSThreadBridge_INTERFACE_DEFINED__
#define __IRDSThreadBridge_INTERFACE_DEFINED__

/* interface IRDSThreadBridge */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRDSThreadBridge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35B9A4B1-7CA6-4aec-8762-1B590056C05D")
    IRDSThreadBridge : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClientConnectedNotify( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClientDisconnectedNotify( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DataReadyNotify( 
            /* [in] */ BSTR msg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRDSThreadBridgeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRDSThreadBridge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRDSThreadBridge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRDSThreadBridge * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ClientConnectedNotify )( 
            IRDSThreadBridge * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ClientDisconnectedNotify )( 
            IRDSThreadBridge * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DataReadyNotify )( 
            IRDSThreadBridge * This,
            /* [in] */ BSTR msg);
        
        END_INTERFACE
    } IRDSThreadBridgeVtbl;

    interface IRDSThreadBridge
    {
        CONST_VTBL struct IRDSThreadBridgeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRDSThreadBridge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRDSThreadBridge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRDSThreadBridge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRDSThreadBridge_ClientConnectedNotify(This)	\
    (This)->lpVtbl -> ClientConnectedNotify(This)

#define IRDSThreadBridge_ClientDisconnectedNotify(This)	\
    (This)->lpVtbl -> ClientDisconnectedNotify(This)

#define IRDSThreadBridge_DataReadyNotify(This,msg)	\
    (This)->lpVtbl -> DataReadyNotify(This,msg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRDSThreadBridge_ClientConnectedNotify_Proxy( 
    IRDSThreadBridge * This);


void __RPC_STUB IRDSThreadBridge_ClientConnectedNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRDSThreadBridge_ClientDisconnectedNotify_Proxy( 
    IRDSThreadBridge * This);


void __RPC_STUB IRDSThreadBridge_ClientDisconnectedNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRDSThreadBridge_DataReadyNotify_Proxy( 
    IRDSThreadBridge * This,
    /* [in] */ BSTR msg);


void __RPC_STUB IRDSThreadBridge_DataReadyNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRDSThreadBridge_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rdshost_0259 */
/* [local] */ 


#define DISPID_RDSSERVERHOST_CREATERDSSESSION		1
#define DISPID_RDSSERVERHOST_OPENRDSSESSION			2
#define DISPID_RDSSERVERHOST_CLOSERDSSESSION			3
#define DISPID_RDSSERVERHOST_DISCONNECTRDSSESSION	4
#define DISPID_RDSSERVERHOST_CREATERDSSESSIONEX	    5
#define DISPID_RDSSERVERHOST_CONNECTEXPERT           6



extern RPC_IF_HANDLE __MIDL_itf_rdshost_0259_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdshost_0259_v0_0_s_ifspec;

#ifndef __ISAFRemoteDesktopServerHost_INTERFACE_DEFINED__
#define __ISAFRemoteDesktopServerHost_INTERFACE_DEFINED__

/* interface ISAFRemoteDesktopServerHost */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISAFRemoteDesktopServerHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C9CCDEB3-A3DD-4673-B495-C1C89494D90E")
    ISAFRemoteDesktopServerHost : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateRemoteDesktopSession( 
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ BOOL fEnableCallback,
            /* [in] */ LONG timeOut,
            /* [in] */ BSTR userHelpBlob,
            /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0011) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateRemoteDesktopSessionEx( 
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ BOOL fEnableCallback,
            /* [in] */ LONG timeOut,
            /* [in] */ BSTR userHelpBlob,
            /* [in] */ LONG tsSessionID,
            /* [in] */ BSTR userSID,
            /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0012) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenRemoteDesktopSession( 
            /* [in] */ BSTR parms,
            /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0013) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseRemoteDesktopSession( 
            /* [in] */ ISAFRemoteDesktopSession *__MIDL_0014) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConnectToExpert( 
            /* [in] */ BSTR expertConnectParm,
            /* [in] */ LONG timeout,
            /* [retval][out] */ LONG *SafErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAFRemoteDesktopServerHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISAFRemoteDesktopServerHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISAFRemoteDesktopServerHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISAFRemoteDesktopServerHost * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateRemoteDesktopSession )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ BOOL fEnableCallback,
            /* [in] */ LONG timeOut,
            /* [in] */ BSTR userHelpBlob,
            /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0011);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateRemoteDesktopSessionEx )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ BOOL fEnableCallback,
            /* [in] */ LONG timeOut,
            /* [in] */ BSTR userHelpBlob,
            /* [in] */ LONG tsSessionID,
            /* [in] */ BSTR userSID,
            /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0012);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OpenRemoteDesktopSession )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ BSTR parms,
            /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0013);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CloseRemoteDesktopSession )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ ISAFRemoteDesktopSession *__MIDL_0014);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConnectToExpert )( 
            ISAFRemoteDesktopServerHost * This,
            /* [in] */ BSTR expertConnectParm,
            /* [in] */ LONG timeout,
            /* [retval][out] */ LONG *SafErrorCode);
        
        END_INTERFACE
    } ISAFRemoteDesktopServerHostVtbl;

    interface ISAFRemoteDesktopServerHost
    {
        CONST_VTBL struct ISAFRemoteDesktopServerHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAFRemoteDesktopServerHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAFRemoteDesktopServerHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAFRemoteDesktopServerHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAFRemoteDesktopServerHost_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISAFRemoteDesktopServerHost_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISAFRemoteDesktopServerHost_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISAFRemoteDesktopServerHost_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISAFRemoteDesktopServerHost_CreateRemoteDesktopSession(This,sharingClass,fEnableCallback,timeOut,userHelpBlob,__MIDL_0011)	\
    (This)->lpVtbl -> CreateRemoteDesktopSession(This,sharingClass,fEnableCallback,timeOut,userHelpBlob,__MIDL_0011)

#define ISAFRemoteDesktopServerHost_CreateRemoteDesktopSessionEx(This,sharingClass,fEnableCallback,timeOut,userHelpBlob,tsSessionID,userSID,__MIDL_0012)	\
    (This)->lpVtbl -> CreateRemoteDesktopSessionEx(This,sharingClass,fEnableCallback,timeOut,userHelpBlob,tsSessionID,userSID,__MIDL_0012)

#define ISAFRemoteDesktopServerHost_OpenRemoteDesktopSession(This,parms,__MIDL_0013)	\
    (This)->lpVtbl -> OpenRemoteDesktopSession(This,parms,__MIDL_0013)

#define ISAFRemoteDesktopServerHost_CloseRemoteDesktopSession(This,__MIDL_0014)	\
    (This)->lpVtbl -> CloseRemoteDesktopSession(This,__MIDL_0014)

#define ISAFRemoteDesktopServerHost_ConnectToExpert(This,expertConnectParm,timeout,SafErrorCode)	\
    (This)->lpVtbl -> ConnectToExpert(This,expertConnectParm,timeout,SafErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopServerHost_CreateRemoteDesktopSession_Proxy( 
    ISAFRemoteDesktopServerHost * This,
    /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    /* [in] */ BOOL fEnableCallback,
    /* [in] */ LONG timeOut,
    /* [in] */ BSTR userHelpBlob,
    /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0011);


void __RPC_STUB ISAFRemoteDesktopServerHost_CreateRemoteDesktopSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopServerHost_CreateRemoteDesktopSessionEx_Proxy( 
    ISAFRemoteDesktopServerHost * This,
    /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    /* [in] */ BOOL fEnableCallback,
    /* [in] */ LONG timeOut,
    /* [in] */ BSTR userHelpBlob,
    /* [in] */ LONG tsSessionID,
    /* [in] */ BSTR userSID,
    /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0012);


void __RPC_STUB ISAFRemoteDesktopServerHost_CreateRemoteDesktopSessionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopServerHost_OpenRemoteDesktopSession_Proxy( 
    ISAFRemoteDesktopServerHost * This,
    /* [in] */ BSTR parms,
    /* [retval][out] */ ISAFRemoteDesktopSession **__MIDL_0013);


void __RPC_STUB ISAFRemoteDesktopServerHost_OpenRemoteDesktopSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopServerHost_CloseRemoteDesktopSession_Proxy( 
    ISAFRemoteDesktopServerHost * This,
    /* [in] */ ISAFRemoteDesktopSession *__MIDL_0014);


void __RPC_STUB ISAFRemoteDesktopServerHost_CloseRemoteDesktopSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISAFRemoteDesktopServerHost_ConnectToExpert_Proxy( 
    ISAFRemoteDesktopServerHost * This,
    /* [in] */ BSTR expertConnectParm,
    /* [in] */ LONG timeout,
    /* [retval][out] */ LONG *SafErrorCode);


void __RPC_STUB ISAFRemoteDesktopServerHost_ConnectToExpert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAFRemoteDesktopServerHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_rdshost_0260 */
/* [local] */ 


#define DISPID_RDSSESSIONSEVENTS_CLIENTCONNECTED		1
#define DISPID_RDSSESSIONSEVENTS_CLIENTDISCONNECTED	2


#define DISPID_RDSCHANNELEVENTS_CHANNELDATAREADY     1



extern RPC_IF_HANDLE __MIDL_itf_rdshost_0260_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_rdshost_0260_v0_0_s_ifspec;


#ifndef __RDSSERVERHOSTLib_LIBRARY_DEFINED__
#define __RDSSERVERHOSTLib_LIBRARY_DEFINED__

/* library RDSSERVERHOSTLib */
/* [helpstring][version][uuid] */ 


#define DISPID_RDSCHANNELEVENTS_CHANNELDATAREADY     1


EXTERN_C const IID LIBID_RDSSERVERHOSTLib;

#ifndef ___ISAFRemoteDesktopDataChannelEvents_DISPINTERFACE_DEFINED__
#define ___ISAFRemoteDesktopDataChannelEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ISAFRemoteDesktopDataChannelEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ISAFRemoteDesktopDataChannelEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("59AE79BC-9721-42df-9396-9D98E7F7A396")
    _ISAFRemoteDesktopDataChannelEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ISAFRemoteDesktopDataChannelEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _ISAFRemoteDesktopDataChannelEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _ISAFRemoteDesktopDataChannelEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ISAFRemoteDesktopDataChannelEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ISAFRemoteDesktopDataChannelEventsVtbl;

    interface _ISAFRemoteDesktopDataChannelEvents
    {
        CONST_VTBL struct _ISAFRemoteDesktopDataChannelEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ISAFRemoteDesktopDataChannelEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _ISAFRemoteDesktopDataChannelEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _ISAFRemoteDesktopDataChannelEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _ISAFRemoteDesktopDataChannelEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _ISAFRemoteDesktopDataChannelEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _ISAFRemoteDesktopDataChannelEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _ISAFRemoteDesktopDataChannelEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ISAFRemoteDesktopDataChannelEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_TSRDPServerDataChannel;

#ifdef __cplusplus

class DECLSPEC_UUID("8C71C09E-3176-4be6-B294-EA3C41CABB99")
TSRDPServerDataChannel;
#endif

EXTERN_C const CLSID CLSID_TSRDPServerDataChannelMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("92550D33-3272-43b6-B536-2DB08C1D569C")
TSRDPServerDataChannelMgr;
#endif

EXTERN_C const CLSID CLSID_SAFRemoteDesktopServerHost;

#ifdef __cplusplus

class DECLSPEC_UUID("5EA6F67B-7713-45F3-B535-0E03DD637345")
SAFRemoteDesktopServerHost;
#endif

#ifndef ___ISAFRemoteDesktopSessionEvents_DISPINTERFACE_DEFINED__
#define ___ISAFRemoteDesktopSessionEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ISAFRemoteDesktopSessionEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ISAFRemoteDesktopSessionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("434AD1CF-4054-44A8-933F-C69889CA22D7")
    _ISAFRemoteDesktopSessionEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ISAFRemoteDesktopSessionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            _ISAFRemoteDesktopSessionEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            _ISAFRemoteDesktopSessionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            _ISAFRemoteDesktopSessionEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            _ISAFRemoteDesktopSessionEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            _ISAFRemoteDesktopSessionEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            _ISAFRemoteDesktopSessionEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ISAFRemoteDesktopSessionEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ISAFRemoteDesktopSessionEventsVtbl;

    interface _ISAFRemoteDesktopSessionEvents
    {
        CONST_VTBL struct _ISAFRemoteDesktopSessionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ISAFRemoteDesktopSessionEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _ISAFRemoteDesktopSessionEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _ISAFRemoteDesktopSessionEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _ISAFRemoteDesktopSessionEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _ISAFRemoteDesktopSessionEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _ISAFRemoteDesktopSessionEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _ISAFRemoteDesktopSessionEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ISAFRemoteDesktopSessionEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SAFRemoteDesktopSession;

#ifdef __cplusplus

class DECLSPEC_UUID("3D5D6889-14CC-4E28-8464-6B02A26F506D")
SAFRemoteDesktopSession;
#endif
#endif /* __RDSSERVERHOSTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\rdshost_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdshost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopSession,0x9D8C82C9,0xA89F,0x42C5,0x8A,0x52,0xFE,0x2A,0x77,0xB0,0x0E,0x82);


MIDL_DEFINE_GUID(IID, IID_IRDSThreadBridge,0x35B9A4B1,0x7CA6,0x4aec,0x87,0x62,0x1B,0x59,0x00,0x56,0xC0,0x5D);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopServerHost,0xC9CCDEB3,0xA3DD,0x4673,0xB4,0x95,0xC1,0xC8,0x94,0x94,0xD9,0x0E);


MIDL_DEFINE_GUID(IID, LIBID_RDSSERVERHOSTLib,0x1B16CE61,0x2406,0x412F,0x96,0x9E,0x21,0xBC,0x08,0x2F,0x76,0xE8);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopDataChannelEvents,0x59AE79BC,0x9721,0x42df,0x93,0x96,0x9D,0x98,0xE7,0xF7,0xA3,0x96);


MIDL_DEFINE_GUID(CLSID, CLSID_TSRDPServerDataChannel,0x8C71C09E,0x3176,0x4be6,0xB2,0x94,0xEA,0x3C,0x41,0xCA,0xBB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_TSRDPServerDataChannelMgr,0x92550D33,0x3272,0x43b6,0xB5,0x36,0x2D,0xB0,0x8C,0x1D,0x56,0x9C);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopServerHost,0x5EA6F67B,0x7713,0x45F3,0xB5,0x35,0x0E,0x03,0xDD,0x63,0x73,0x45);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopSessionEvents,0x434AD1CF,0x4054,0x44A8,0x93,0x3F,0xC6,0x98,0x89,0xCA,0x22,0xD7);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopSession,0x3D5D6889,0x14CC,0x4E28,0x84,0x64,0x6B,0x02,0xA2,0x6F,0x50,0x6D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for rdshost.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopSession,0x9D8C82C9,0xA89F,0x42C5,0x8A,0x52,0xFE,0x2A,0x77,0xB0,0x0E,0x82);


MIDL_DEFINE_GUID(IID, IID_IRDSThreadBridge,0x35B9A4B1,0x7CA6,0x4aec,0x87,0x62,0x1B,0x59,0x00,0x56,0xC0,0x5D);


MIDL_DEFINE_GUID(IID, IID_ISAFRemoteDesktopServerHost,0xC9CCDEB3,0xA3DD,0x4673,0xB4,0x95,0xC1,0xC8,0x94,0x94,0xD9,0x0E);


MIDL_DEFINE_GUID(IID, LIBID_RDSSERVERHOSTLib,0x1B16CE61,0x2406,0x412F,0x96,0x9E,0x21,0xBC,0x08,0x2F,0x76,0xE8);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopDataChannelEvents,0x59AE79BC,0x9721,0x42df,0x93,0x96,0x9D,0x98,0xE7,0xF7,0xA3,0x96);


MIDL_DEFINE_GUID(CLSID, CLSID_TSRDPServerDataChannel,0x8C71C09E,0x3176,0x4be6,0xB2,0x94,0xEA,0x3C,0x41,0xCA,0xBB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_TSRDPServerDataChannelMgr,0x92550D33,0x3272,0x43b6,0xB5,0x36,0x2D,0xB0,0x8C,0x1D,0x56,0x9C);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopServerHost,0x5EA6F67B,0x7713,0x45F3,0xB5,0x35,0x0E,0x03,0xDD,0x63,0x73,0x45);


MIDL_DEFINE_GUID(IID, DIID__ISAFRemoteDesktopSessionEvents,0x434AD1CF,0x4054,0x44A8,0x93,0x3F,0xC6,0x98,0x89,0xCA,0x22,0xD7);


MIDL_DEFINE_GUID(CLSID, CLSID_SAFRemoteDesktopSession,0x3D5D6889,0x14CC,0x4E28,0x84,0x64,0x6B,0x02,0xA2,0x6F,0x50,0x6D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\regapi.h ===
/****************************************************************************/
// regapi.h
//
// Terminal Server registry access definitions, including prototypes for
// regapi.dll.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/
#ifndef __REGAPI_H__
#define __REGAPI_H__


/*
 *  Maximum length of keyword
 */
#define MAX_REGKEYWORD  50


/*
 * Path to the TS policy tree managed by Group Policy
 */ 
#define TS_POLICY_SUB_TREE L"Software\\Policies\\Microsoft\\Windows NT\\Terminal Services"


/*
 * partial key strings used to build larger key strings and used by
 * various multiuser components within Rtl registry APIs.
 *
 * NOTE1: Don't put value names here - put them in separate sections
 *        documented with some explaination (see below for examples)
 *
 * NOTE2: For completeness, each UNICODE string define should have an ANSI
 *        define also (with _A suffix on name).  Some Hydra/WinFrame components
 *        want to use ANSI APIs, so defines should be provided for both.  The
 *        NTAPI defines do not need to have ANSI defines since the NT RTL 
 *        registry APIs work with UNICODE strings only.
 */
#define  REG_CONTROL                        L"System\\CurrentControlSet\\Control"
#define  REG_CONTROL_A                       "System\\CurrentControlSet\\Control"
#define  REG_NTAPI_CONTROL                  L"\\Registry\\Machine\\" REG_CONTROL
#define  REG_TSERVER                        L"Terminal Server"
#define  REG_TSERVER_A                       "Terminal Server"
#define  REG_WINSTATIONS                    L"WinStations"
#define  REG_WINSTATIONS_A                   "WinStations"
#define  REG_TSERVER_WINSTATIONS            REG_TSERVER   L"\\" REG_WINSTATIONS
#define  REG_TSERVER_WINSTATIONS_A          REG_TSERVER_A  "\\" REG_WINSTATIONS_A
#define  REG_DEFAULTSECURITY                L"DefaultSecurity"
#define  REG_DEFAULTSECURITY_A               "DefaultSecurity"
#define  REG_CONSOLESECURITY                L"ConsoleSecurity"
#define  REG_CONSOLESECURITY_A               "ConsoleSecurity"
#define  REG_WINSTATIONS_DEFAULTSECURITY    REG_WINSTATIONS   L"\\" REG_DEFAULTSECURITY
#define  REG_WINSTATIONS_DEFAULTSECURITY_A  REG_WINSTATIONS_A  "\\" REG_DEFAULTSECURITY_A
#define  REG_SECURITY                       L"Security"
#define  REG_SECURITY_A                      "Security"
#define  REG_INSTALL                        L"Install"
#define  REG_INSTALL_A                       "Install"
#define  REG_CHANGEUSER_OPTION              L"Change User Option"
#define  REG_CHANGEUSER_OPTION_A             "Change User Option"
#define  REG_COMPATIBILITY                  L"Compatibility"
#define  REG_COMPATIBILITY_A                 "Compatibility"
#define  REG_USERCONFIG                     L"UserConfig"
#define  REG_USERCONFIG_A                    "UserConfig"
#define  REG_DEFAULTUSERCONFIG              L"DefaultUserConfiguration"
#define  REG_DEFAULTUSERCONFIG_A             "DefaultUserConfiguration"
#define  REG_DOS                            L"Dos"
#define  REG_DOS_A                           "Dos"
#define  REG_AUTHORIZEDAPPLICATIONS         L"AuthorizedApplications"
#define  REG_AUTHORIZEDAPPLICATIONS_A        "AuthorizedApplications"
#define  REG_VIDEO                          L"Video"
#define  REG_VIDEO_A                         "Video"
#define  REG_APPLICATIONS                   L"Applications"
#define  REG_APPLICATIONS_A                  "Applications"
#define  REG_DLLS                           L"Dlls"
#define  REG_DLLS_A                          "Dlls"
#define  REG_INIFILES                       L"IniFiles"
#define  REG_INIFILES_A                      "IniFiles"
#define  REG_REGISTRYENTRIES                L"Registry Entries"
#define  REG_REGISTRYENTRIES_A               "Registry Entries"
#define  REG_INIFILETIMES                   L"IniFile Times"
#define  REG_INIFILETIMES_A                  "IniFile Times"
#define  REG_OBJRULES                       L"ObjectRules"
#define  REG_OBJRULES_A                      "ObjectRules"
#define  REG_DLLRULES                       L"DllRules"
#define  REG_DLLRULES_A                      "DllRules"
#define  REG_WINDOWS                        L"Windows"
#define  REG_WINDOWS_A                       "Windows"
#define  REG_ADVERTISEOLDAPPSERVERBIT       L"AdvertiseOldAppServerBit"
#define  REG_ADVERTISEOLDAPPSERVERBIT_A      "AdvertiseOldAppServerBit"


/*
 *  CONTROL key defines
 */
#define  REG_CONTROL_TSERVER            REG_CONTROL   L"\\" REG_TSERVER
#define  REG_CONTROL_TSERVER_A          REG_CONTROL_A  "\\" REG_TSERVER_A
#define  REG_NTAPI_CONTROL_TSERVER          REG_NTAPI_CONTROL L"\\" REG_TSERVER
#define  WINSTATION_REG_NAME            REG_CONTROL_TSERVER   L"\\" REG_WINSTATIONS
#define  WINSTATION_REG_NAME_A          REG_CONTROL_TSERVER_A  "\\" REG_WINSTATIONS_A
#define  WD_REG_NAME                    REG_CONTROL_TSERVER   L"\\Wds"
#define  WD_REG_NAME_A                  REG_CONTROL_TSERVER_A  "\\Wds"
#define  PD_REG_NAME                        L"\\Pds"
#define  PD_REG_NAME_A                       "\\Pds"
#define  TD_REG_NAME                        L"\\Tds"
#define  TD_REG_NAME_A                   "\\Tds"
#define  CD_REG_NAME                    L"\\Cds"
#define  CD_REG_NAME_A                   "\\Cds"
#define  DOS_REG_NAME                   REG_CONTROL_TSERVER   L"\\" REG_DOS
#define  DOS_REG_NAME_A                 REG_CONTROL_TSERVER_A  "\\" REG_DOS_A
#define  USERCONFIG_REG_NAME            REG_CONTROL_TSERVER   L"\\" REG_USERCONFIG   L"\\"
#define  USERCONFIG_REG_NAME_A          REG_CONTROL_TSERVER_A  "\\" REG_USERCONFIG_A  "\\"
#define  DEFCONFIG_REG_NAME             REG_CONTROL_TSERVER   L"\\" REG_DEFAULTUSERCONFIG
#define  DEFCONFIG_REG_NAME_A           REG_CONTROL_TSERVER_A  "\\" REG_DEFAULTUSERCONFIG_A
#define  UTILITY_REG_NAME_CHANGE        REG_CONTROL_TSERVER   L"\\Utilities\\change"
#define  UTILITY_REG_NAME_CHANGE_A      REG_CONTROL_TSERVER_A  "\\Utilities\\change"
#define  UTILITY_REG_NAME_QUERY         REG_CONTROL_TSERVER   L"\\Utilities\\query"
#define  UTILITY_REG_NAME_QUERY_A       REG_CONTROL_TSERVER_A  "\\Utilities\\query"
#define  UTILITY_REG_NAME_RESET         REG_CONTROL_TSERVER   L"\\Utilities\\reset"
#define  UTILITY_REG_NAME_RESET_A       REG_CONTROL_TSERVER_A  "\\Utilities\\reset"
#define  AUTHORIZEDAPPS_REG_NAME        REG_CONTROL_TSERVER   L"\\" REG_AUTHORIZEDAPPLICATIONS
#define  AUTHORIZEDAPPS_REG_NAME_A      REG_CONTROL_TSERVER_A  "\\" REG_AUTHORIZEDAPPLICATIONS_A
#define  NTAPI_AUTHORIZEDAPPS_REG_NAME  REG_NTAPI_CONTROL_TSERVER L"\\" REG_AUTHORIZEDAPPLICATIONS
#define  VIDEO_REG_NAME                 REG_CONTROL_TSERVER   L"\\" REG_VIDEO
#define  VIDEO_REG_NAME_A               REG_CONTROL_TSERVER_A  "\\" REG_VIDEO_A
#define  NTAPI_VIDEO_REG_NAME           REG_NTAPI_CONTROL_TSERVER L"\\" REG_VIDEO
#define  REG_TS_SESSDIRACTIVE           L"SessionDirectoryActive"
#define  REG_TS_SESSDIRACTIVE_A         "SessionDirectoryActive"
#define  REG_TS_SESSDIR_EXPOSE_SERVER_ADDR L"SessionDirectoryExposeServerIP"
#define  REG_TS_SESSDIR_EXPOSE_SERVER_ADDR_A "SessionDirectoryExposeServerIP"
#define  REG_TS_SESSDIRCLSID            L"SessionDirectoryCLSID"
#define  REG_TS_SESSDIRCLSID_A          "SessionDirectoryCLSID"
#define  REG_TS_SESSDIR_EX_CLSID        L"SessionDirectoryExCLSID"
#define  REG_TS_SESSDIR_EX_CLSID_A      "SessionDirectoryExCLSID"
#define  REG_TS_CLUSTERSETTINGS         REG_CONTROL_TSERVER L"\\ClusterSettings"
#define  REG_TS_CLUSTERSETTINGS_A       REG_CONTROL_TSERVER_A "\\ClusterSettings"
#define  REG_TS_CLUSTER_STORESERVERNAME L"SessionDirectoryLocation"
#define  REG_TS_CLUSTER_STORESERVERNAME_A "SessionDirectoryLocation"
#define  REG_TS_CLUSTER_CLUSTERNAME     L"SessionDirectoryClusterName"
#define  REG_TS_CLUSTER_CLUSTERNAME_A   "SessionDirectoryClusterName"
#define  REG_TS_CLUSTER_OPAQUESETTINGS  L"SessionDirectoryAdditionalParams"
#define  REG_TS_CLUSTER_OPAQUESETTINGS_A "SessionDirectoryAdditionalParams"


/*
 * SOFTWARE key defines
 */
#define  BUILD_NUMBER_KEY               L"Software\\Microsoft\\Windows NT\\CurrentVersion"
#define  BUILD_NUMBER_KEY_A              "Software\\Microsoft\\Windows NT\\CurrentVersion"
#define  REG_SOFTWARE_TSERVER           L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"
#define  REG_SOFTWARE_TSERVER_A          "Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"
#define  REG_NTAPI_SOFTWARE_TSERVER         L"\\Registry\\Machine\\" REG_SOFTWARE_TSERVER
#if defined (_IA64_)
#define  REG_SOFTWARE_WOW6432_TSERVER   L"Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"
#define  REG_NTAPI_SOFTWARE_WOW6432_TSERVER   L"\\Registry\\Machine\\" REG_SOFTWARE_WOW6432_TSERVER
#endif //_IA64_
#define  COMPAT_REG_NAME                REG_SOFTWARE_TSERVER   L"\\" REG_COMPATIBILITY
#define  COMPAT_REG_NAME_A              REG_SOFTWARE_TSERVER_A  "\\" REG_COMPATIBILITY_A
#define  NTAPI_COMPAT_REG_NAME          REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_COMPATIBILITY
#define  COMPAT_APPS_REG_NAME           REG_SOFTWARE_TSERVER   L"\\" REG_COMPATIBILITY   L"\\" REG_APPLICATIONS
#define  COMPAT_APPS_REG_NAME_A         REG_SOFTWARE_TSERVER_A  "\\" REG_COMPATIBILITY_A  "\\" REG_APPLICATIONS_A
#define  NTAPI_COMPAT_APPS_REG_NAME     REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_COMPATIBILITY L"\\" REG_APPLICATIONS
#define  NTAPI_COMPAT_APPS_REG_PREFIX   REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_COMPATIBILITY L"\\" REG_APPLICATIONS L"\\"
#define  COMPAT_DLLS_REG_NAME           REG_SOFTWARE_TSERVER   L"\\" REG_COMPATIBILITY   L"\\" REG_DLLS
#define  COMPAT_DLLS_REG_NAME_A         REG_SOFTWARE_TSERVER_A  "\\" REG_COMPATIBILITY_A  "\\" REG_DLLS_A
#define  COMPAT_APPS_REG_NAME           REG_SOFTWARE_TSERVER   L"\\" REG_COMPATIBILITY   L"\\" REG_APPLICATIONS
#define  COMPAT_APPS_REG_NAME_A         REG_SOFTWARE_TSERVER_A  "\\" REG_COMPATIBILITY_A  "\\" REG_APPLICATIONS_A
#define  NTAPI_COMPAT_DLLS_REG_NAME     REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_COMPATIBILITY L"\\" REG_DLLS
#define  NTAPI_COMPAT_DLLS_REG_PREFIX   REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_COMPATIBILITY L"\\" REG_DLLS L"\\"
#define  COMPAT_INI_REG_NAME            REG_SOFTWARE_TSERVER   L"\\" REG_COMPATIBILITY   L"\\" REG_INIFILES
#define  COMPAT_INI_REG_NAME_A          REG_SOFTWARE_TSERVER_A  "\\" REG_COMPATIBILITY_A  "\\" REG_INIFILES_A
#define  NTAPI_COMPAT_INI_REG_NAME      REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_COMPATIBILITY L"\\" REG_INIFILES
#define  COMPAT_REGENTRY_REG_NAME       REG_SOFTWARE_TSERVER   L"\\" REG_COMPATIBILITY   L"\\" REG_REGISTRYENTRIES
#define  COMPAT_REGENTRY_REG_NAME_A     REG_SOFTWARE_TSERVER_A  "\\" REG_COMPATIBILITY_A  "\\" REG_REGISTRYENTRIES_A
#define  NTAPI_COMPAT_REGENTRY_REG_NAME REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_COMPATIBILITY L"\\" REG_REGISTRYENTRIES
#define  INSTALL_REG_NAME               REG_SOFTWARE_TSERVER   L"\\" REG_INSTALL
#define  INSTALL_REG_NAME_A             REG_SOFTWARE_TSERVER_A  "\\" REG_INSTALL_A
#define  NTAPI_INSTALL_REG_NAME         REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_INSTALL
#define  INIFILE_TIMES_REG_NAME         REG_SOFTWARE_TSERVER   L"\\" REG_INSTALL   L"\\" REG_INIFILETIMES
#define  INIFILE_TIMES_REG_NAME_A       REG_SOFTWARE_TSERVER_A  "\\" REG_INSTALL_A  "\\" REG_INIFILETIMES_A
#define  NTAPI_INIFILE_TIMES_REG_NAME   REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_INSTALL L"\\" REG_INIFILETIMES
#define  CHANGEUSER_OPTION_REG_NAME     REG_SOFTWARE_TSERVER   L"\\" REG_INSTALL   L"\\" REG_CHANGEUSER_OPTION
#define  CHANGEUSER_OPTION_REG_NAME_A   REG_SOFTWARE_TSERVER_A  "\\" REG_INSTALL_A  "\\" REG_CHANGEUSER_OPTION_A
#define  SECURITY_REG_NAME              REG_SOFTWARE_TSERVER   L"\\" REG_SECURITY
#define  SECURITY_REG_NAME_A            REG_SOFTWARE_TSERVER_A  "\\" REG_SECURITY_A
#define  WINDOWS_REG_NAME               REG_SOFTWARE_TSERVER   L"\\" REG_WINDOWS
#define  WINDOWS_REG_NAME_A             REG_SOFTWARE_TSERVER_A  "\\" REG_WINDOWS_A
#define  NTAPI_WINDOWS_REG_NAME         REG_NTAPI_SOFTWARE_TSERVER L"\\" REG_WINDOWS
#define  DEVICERDR_REG_NAME             REG_CONTROL_TSERVER  L"\\AddIns\\Terminal Server Redirector" 
#define  DEVICERDR_REG_NAME_A           REG_CONTROL_TSERVER_A "\\AddIns\\Terminal Server Redirector" 

/*
 * SERVICES key defines
 */
#define  EVENTLOG_REG_NAME          L"System\\CurrentControlSet\\Services\\EventLog\\System"
#define  EVENTLOG_REG_NAME_A    "System\\CurrentControlSet\\Services\\EventLog\\System"

/*
 * REG_CONTROL_TSERVER values (REG_CONTROL_CITRIX in WinFrame)
 */
#define REG_CITRIX_OEMID                        L"OemId"
#define REG_CITRIX_OEMID_A                      "OemId"
#define REG_CITRIX_OEMNAME                      L"OemName"
#define REG_CITRIX_OEMNAME_A                    "OemName"
#define REG_CITRIX_PRODUCTNAME                  L"ProductName"
#define REG_CITRIX_PRODUCTNAME_A                "ProductName"
#define REG_CITRIX_PRODUCTVERSION               L"ProductVersion"
#define REG_CITRIX_PRODUCTVERSION_A             "ProductVersion"
#define REG_CITRIX_PRODUCTVERSIONNUM            L"ProductVersionNum"
#define REG_CITRIX_PRODUCTVERSIONNUM_A          "ProductVersionNum"
#define REG_CITRIX_VERSION                      L"Version"
#define REG_CITRIX_VERSION_A                    "Version"
#define REG_CITRIX_PRODUCTBUILD                 L"ProductBuild"
#define REG_CITRIX_PRODUCTBUILD_A               "ProductBuild"
#define REG_CITRIX_NWLOGON                      L"NWLogon"
#define REG_CITRIX_NWLOGON_A                    "NWLogon"
#define REG_CITRIX_IDLEWINSTATIONPOOLCOUNT      L"IdleWinStationPoolCount"
#define REG_CITRIX_IDLEWINSTATIONPOOLCOUNT_A    "IdleWinStationPoolCount"
#define REG_CITRIX_FLATTEMPDIR                  L"FlatTempDir"
#define REG_CITRIX_FLATTEMPDIR_A                "FlatTempDir"
#define REG_TERMSRV_PERSESSIONTEMPDIR           L"PerSessionTempDir"
#define REG_TERMSRV_PERSESSIONTEMPDIR_A         "PerSessionTempDir"
#define REG_CITRIX_MODEMSWITHBADDSR             L"Modems With Bad DSR"
#define REG_CITRIX_MODEMSWITHBADDSR_A           "Modems With Bad DSR"
#define REG_CITRIX_NWNDSPREFERREDSERVER         L"NWNDSPreferredServer"
#define REG_CITRIX_NWNDSPREFERREDSERVER_A       "NWNDSPreferredServer"
#define REG_CITRIX_INITIALNETWAREDRIVE          L"InitialNetWareDrive"
#define REG_CITRIX_INITIALNETWAREDRIVE_A        "InitialNetWareDrive"
#define REG_CITRIX_CROSSWINSTATIONDEBUG         L"CrossWinStationDebug"
#define REG_CITRIX_CROSSWINSTATIONDEBUG_A       "CrossWinStationDebug"
#define REG_CITRIX_DELETETEMPDIRSONEXIT         L"DeleteTempDirsOnExit"
#define REG_CITRIX_DELETETEMPDIRSONEXIT_A       "DeleteTempDirsOnExit"
#define REG_TERMSRV_APPCOMPAT                   L"TSAppCompat"
#define REG_TERMSRV_APPCOMPAT_A                 "TSAppCompat"
#define REG_TERMSRV_ENABLED                     L"TSEnabled"
#define REG_TERMSRV_ENABLED_A                   "TSEnabled"
#define REG_TERMSRV_ADVERTISE                   L"TSAdvertise"
#define REG_TERMSRV_ADVERTISE_A                 "TSAdvertise"
#define REG_TERMSRV_CONQUEUE_MAX                L"ConnectionQueue"
#define REG_TERMSRV_CONQUEUE_MAX_A              "ConnectionQueue"


/*
 *  WinStation Profile values
 */
#define WIN_BAUDRATE                            L"BaudRate"
#define WIN_BAUDRATE_A                           "BaudRate"
#define WIN_BYTESIZE                            L"ByteSize"
#define WIN_BYTESIZE_A                           "ByteSize"
#define WIN_COMMENT                     L"Comment"
#define WIN_COMMENT_A                    "Comment"
#define WIN_CONNECTTYPE                         L"ConnectType"
#define WIN_CONNECTTYPE_A                        "ConnectType"
#define WIN_DEFAULTWDNAME                   L"DefaultWdName"
#define WIN_DEFAULTWDNAME_A                  "DefaultWdName"
#define WIN_DEVICENAME                          L"DeviceName"
#define WIN_DEVICENAME_A                         "DeviceName"
#define WIN_MODEMNAME                   L"ModemName"
#define WIN_MODEMNAME_A                  "ModemName"
#define WIN_ENABLEBREAKDISCONNECT           L"fEnableBreakDisconnect"
#define WIN_ENABLEBREAKDISCONNECT_A          "fEnableBreakDisconnect"
#define WIN_ENABLEDSRSENSITIVITY            L"fEnableDsrSensitivity"
#define WIN_ENABLEDSRSENSITIVITY_A           "fEnableDsrSensitivity"
#define WIN_CONNECTIONDRIVER                L"fConnectionDriver"
#define WIN_CONNECTIONDRIVER_A               "fConnectionDriver"
#define WIN_ENABLEDTR                           L"fEnableDTR"
#define WIN_ENABLEDTR_A                          "fEnableDTR"
#define WIN_ENABLERTS                           L"fEnableRTS"
#define WIN_ENABLERTS_A                          "fEnableRTS"
#define WIN_ENABLEWINSTATION                L"fEnableWinStation"
#define WIN_ENABLEWINSTATION_A               "fEnableWinStation"
#define WIN_MAXINSTANCECOUNT            L"MaxInstanceCount"
#define WIN_MAXINSTANCECOUNT_A           "MaxInstanceCount"
#define WIN_FLOWTYPE                    L"FlowType"
#define WIN_FLOWTYPE_A                   "FlowType"
#define WIN_FLOWSOFTWARERX              L"fFlowSoftwareRx"
#define WIN_FLOWSOFTWARERX_A             "fFlowSoftwareRx"
#define WIN_FLOWSOFTWARETX              L"fFlowSoftwareTx"
#define WIN_FLOWSOFTWARETX_A             "fFlowSoftwareTx"
#define WIN_FLOWHARDWARERX                      L"FlowHardwareRx"
#define WIN_FLOWHARDWARERX_A             "FlowHardwareRx"
#define WIN_FLOWHARDWARETX                      L"FlowHardwareTx"
#define WIN_FLOWHARDWARETX_A                 "FlowHardwareTx"
#define WIN_INPUTBUFFERLENGTH               L"InputBufferLength"
#define WIN_INPUTBUFFERLENGTH_A          "InputBufferLength"
#define WIN_INTERACTIVEDELAY                L"InteractiveDelay"
#define WIN_INTERACTIVEDELAY_A           "InteractiveDelay"
#define WIN_KEEPALIVETIMEOUT            L"KeepAliveTimeout"
#define WIN_KEEPALIVETIMEOUT_A           "KeepAliveTimeout"
#define WIN_LANADAPTER                  L"LanAdapter"
#define WIN_LANADAPTER_A                 "LanAdapter"
#define WIN_CDCLASS                             L"CdClass"
#define WIN_CDCLASS_A                            "CdClass"
#define WIN_CDDLL                                   L"CdDLL"
#define WIN_CDDLL_A                                  "CdDLL"
#define WIN_CDNAME                          L"CdName"
#define WIN_CDNAME_A                         "CdName"
#define WIN_CDFLAG                              L"CdFlag"
#define WIN_CDFLAG_A                     "CdFlag"
#define WIN_CFGDLL                      L"CfgDLL"
#define WIN_CFGDLL_A                     "CfgDLL"
#define WIN_CONFIGDLL                   L"ConfigDLL"
#define WIN_CONFIGDLL_A                  "ConfigDLL"
#define WIN_WDNAME                          L"WdName"
#define WIN_WDNAME_A                         "WdName"
#define WIN_WDPREFIX                    L"WdPrefix"
#define WIN_WDPREFIX_A                   "WdPrefix"
#define WIN_WDDLL                                   L"WdDLL"
#define WIN_WDDLL_A                                  "WdDLL"
#define WIN_WSXDLL                                  L"WsxDLL"
#define WIN_WSXDLL_A                     "WsxDLL"
#define WIN_OUTBUFLENGTH                        L"OutBufLength"
#define WIN_OUTBUFLENGTH_A               "OutBufLength"
#define WIN_OUTBUFCOUNT                         L"OutBufCount"
#define WIN_OUTBUFCOUNT_A                        "OutBufCount"
#define WIN_OUTBUFDELAY                     L"OutBufDelay"
#define WIN_OUTBUFDELAY_A                "OutBufDelay"
#define WIN_PARITY                                  L"Parity"
#define WIN_PARITY_A                     "Parity"
#define WIN_PDCLASS                                 L"PdClass"
#define WIN_PDCLASS_A                    "PdClass"
#define WIN_PDDLL                                   L"PdDLL"
#define WIN_PDDLL_A                                  "PdDLL"
#define WIN_PDFLAG                              L"PdFlag"
#define WIN_PDFLAG_A                     "PdFlag"
#define WIN_PDNAME                                  L"PdName"
#define WIN_PDNAME_A                     "PdName"
#define WIN_PDOPTIONS                           L"PdOptions"
#define WIN_PDOPTIONS_A                  "PdOptions"
#define WIN_REQUIREDPDS                         L"RequiredPds"
#define WIN_REQUIREDPDS_A                "RequiredPds"
#define WIN_SERVICENAME                 L"ServiceName"
#define WIN_SERVICENAME_A                "ServiceName"
#define WIN_STOPBITS                            L"StopBits"
#define WIN_STOPBITS_A                   "StopBits"
#define WIN_TCDNAME                                 L"TcdName"
#define WIN_TCDNAME_A                    "TcdName"
#define WIN_TRACEENABLE                         L"TraceEnable"
#define WIN_TRACEENABLE_A                "TraceEnable"
#define WIN_TRACECLASS                          L"TraceClass"
#define WIN_TRACECLASS_A                 "TraceClass"
#define WIN_TRACEDEBUGGER                       L"TraceDebugger"
#define WIN_TRACEDEBUGGER_A              "TraceDebugger"
#define WIN_TRACEOPTION                         L"TraceOption"
#define WIN_TRACEOPTION_A                "TraceOption"
#define WIN_WDFLAG                      L"WdFlag"
#define WIN_WDFLAG_A                     "WdFlag"
#define WIN_WDOPTIONS                           L"WdOptions"
#define WIN_WDOPTIONS_A                  "WdOptions"
#define WIN_XOFFCHAR                            L"XoffChar"
#define WIN_XOFFCHAR_A                           "XoffChar"
#define WIN_XONCHAR                                 L"XonChar"
#define WIN_XONCHAR_A                    "XonChar"
#define WIN_USEROVERRIDE                        L"UserOverride"
#define WIN_USEROVERRIDE_A               "UserOverride"
#define WIN_NASISPECIFICNAME            L"NasiSpecificName"
#define WIN_NASISPECIFICNAME_A           "NasiSpecificName"
#define WIN_NASIUSERNAME                L"NasiUserName"
#define WIN_NASIUSERNAME_A               "NasiUserName"
#define WIN_NASIPASSWORD                L"NasiPassWord"
#define WIN_NASIPASSWORD_A               "NasiPassWord"
#define WIN_NASISESSIONNAME             L"NasiSessionName"
#define WIN_NASISESSIONNAME_A            "NasiSessionName"
#define WIN_NASIFILESERVER              L"NasiFileServer"
#define WIN_NASIFILESERVER_A             "NasiFileServer"
#define WIN_NASIGLOBALSESSION           L"NasiGlobalSession"
#define WIN_NASIGLOBALSESSION_A          "NasiGlobalSession"
#define WIN_PORTNUMBER                  L"PortNumber"
#define WIN_PORTNUMBER_A                 "PortNumber"
#define WIN_OEMTDADAPTER                L"OemTdAdapter"
#define WIN_OEMTDADAPTER_A               "OemTdAdapter"
#define WIN_OEMTDDEVICENAME             L"OemTdDeviceName"
#define WIN_OEMTDDEVICENAME_A            "OemTdDeviceName"
#define WIN_OEMTDFLAGS                  L"OemTdFlags"
#define WIN_OEMTDFLAGS_A                 "OemTdFlags"
#define WIN_DONTDISPLAYLASTUSERNAME     L"DontDisplayLastUserName"
#define WIN_DONTDISPLAYLASTUSERNAME_A    "DontDisplayLastUserName"


/*
 *  User Profile / WinStation Profile values
 */
#define WIN_INHERITAUTOLOGON                L"fInheritAutoLogon"
#define WIN_INHERITAUTOLOGON_A               "fInheritAutoLogon"
#define WIN_INHERITRESETBROKEN              L"fInheritResetBroken"
#define WIN_INHERITRESETBROKEN_A             "fInheritResetBroken"
#define WIN_INHERITRECONNECTSAME            L"fInheritReconnectSame"
#define WIN_INHERITRECONNECTSAME_A           "fInheritReconnectSame"
#define WIN_INHERITINITIALPROGRAM           L"fInheritInitialProgram"
#define WIN_INHERITINITIALPROGRAM_A          "fInheritInitialProgram"
#define WIN_INHERITCALLBACK                 L"fInheritCallback"
#define WIN_INHERITCALLBACK_A                "fInheritCallback"
#define WIN_INHERITCALLBACKNUMBER           L"fInheritCallbackNumber"
#define WIN_INHERITCALLBACKNUMBER_A          "fInheritCallbackNumber"
#define WIN_INHERITSHADOW                   L"fInheritShadow"
#define WIN_INHERITSHADOW_A                  "fInheritShadow"
#define WIN_INHERITMAXSESSIONTIME           L"fInheritMaxSessionTime"
#define WIN_INHERITMAXSESSIONTIME_A          "fInheritMaxSessionTime"
#define WIN_INHERITMAXDISCONNECTIONTIME     L"fInheritMaxDisconnectionTime"
#define WIN_INHERITMAXDISCONNECTIONTIME_A    "fInheritMaxDisconnectionTime"
#define WIN_INHERITMAXIDLETIME              L"fInheritMaxIdleTime"
#define WIN_INHERITMAXIDLETIME_A             "fInheritMaxIdleTime"
#define WIN_INHERITAUTOCLIENT               L"fInheritAutoClient"
#define WIN_INHERITAUTOCLIENT_A              "fInheritAutoClient"
#define WIN_INHERITSECURITY                 L"fInheritSecurity"
#define WIN_INHERITSECURITY_A                "fInheritSecurity"

//NA 2/23/01
#define WIN_INHERITCOLORDEPTH               L"fInheritColorDepth"

#define WIN_PROMPTFORPASSWORD           L"fPromptForPassword"
#define WIN_PROMPTFORPASSWORD_A          "fPromptForPassword"
#define WIN_RESETBROKEN                 L"fResetBroken"
#define WIN_RESETBROKEN_A                "fResetBroken"
#define WIN_RECONNECTSAME               L"fReconnectSame"
#define WIN_RECONNECTSAME_A              "fReconnectSame"
#define WIN_LOGONDISABLED               L"fLogonDisabled"
#define WIN_LOGONDISABLED_A              "fLogonDisabled"
#define WIN_AUTOCLIENTDRIVES            L"fAutoClientDrives"
#define WIN_AUTOCLIENTDRIVES_A           "fAutoClientDrives"
#define WIN_AUTOCLIENTLPTS              L"fAutoClientLpts"
#define WIN_AUTOCLIENTLPTS_A             "fAutoClientLpts"
#define WIN_FORCECLIENTLPTDEF           L"fForceClientLptDef"
#define WIN_FORCECLIENTLPTDEF_A          "fForceClientLptDef"
#define WIN_DISABLEENCRYPTION           L"fDisableEncryption"
#define WIN_DISABLEENCRYPTION_A          "fDisableEncryption"
#define WIN_HOMEDIRECTORYMAPROOT        L"fHomeDirectoryMapRoot"
#define WIN_HOMEDIRECTORYMAPROOT_A       "fHomeDirectoryMapRoot"
#define WIN_USEDEFAULTGINA              L"fUseDefaultGina"
#define WIN_USEDEFAULTGINA_A             "fUseDefaultGina"
#define WIN_DISABLEAUTORECONNECT        L"fDisableAutoReconnect"
#define WIN_DISABLEAUTORECONNECT_A       "fDisableAutoReconnect"


#define WIN_SESSIONDIRECTORYACTIVE              L"SessionDirectoryActive"
#define WIN_SESSIONDIRECTORYLOCATION            L"SessionDirectoryLocation"
#define WIN_SESSIONDIRECTORYCLUSTERNAME         L"SessionDirectoryClusterName"
#define WIN_SESSIONDIRECTORYADDITIONALPARAMS    L"SessionDirectoryAdditionalParams"

#define WIN_DISABLECPM                  L"fDisableCpm"
#define WIN_DISABLECPM_A                 "fDisableCpm"
#define WIN_DISABLECDM                  L"fDisableCdm"
#define WIN_DISABLECDM_A                 "fDisableCdm"
#define WIN_DISABLECCM                  L"fDisableCcm"
#define WIN_DISABLECCM_A                 "fDisableCcm"
#define WIN_DISABLELPT                  L"fDisableLPT"
#define WIN_DISABLELPT_A                 "fDisableLPT"
#define WIN_DISABLECLIP                 L"fDisableClip"
#define WIN_DISABLECLIP_A                "fDisableClip"
#define WIN_DISABLEEXE                  L"fDisableExe"
#define WIN_DISABLEEXE_A                 "fDisableExe"
#define WIN_DISABLECAM                  L"fDisableCam"
#define WIN_DISABLECAM_A                 "fDisableCam"

#define WIN_USERNAME                        L"Username"
#define WIN_USERNAME_A                       "Username"
#define WIN_DOMAIN                      L"Domain"
#define WIN_DOMAIN_A                     "Domain"
#define WIN_PASSWORD                    L"Password"
#define WIN_PASSWORD_A                   "Password"
#define WIN_WORKDIRECTORY               L"WorkDirectory"
#define WIN_WORKDIRECTORY_A              "WorkDirectory"
#define WIN_INITIALPROGRAM              L"InitialProgram"
#define WIN_INITIALPROGRAM_A             "InitialProgram"
#define WIN_CALLBACKNUMBER              L"CallbackNumber"
#define WIN_CALLBACKNUMBER_A             "CallbackNumber"
#define WIN_CALLBACKTIMEOUT             L"CallbackTimeout"
#define WIN_CALLBACKTIMEOUT_A            "CallbackTimeout"
#define WIN_CALLBACK                    L"Callback"
#define WIN_CALLBACK_A                   "Callback"
#define WIN_SHADOW                      L"Shadow"
#define WIN_SHADOW_A                     "Shadow"
#define WIN_MAXCONNECTIONTIME           L"MaxConnectionTime"
#define WIN_MAXCONNECTIONTIME_A          "MaxConnectionTime"
#define WIN_MAXDISCONNECTIONTIME        L"MaxDisconnectionTime"
#define WIN_MAXDISCONNECTIONTIME_A       "MaxDisconnectionTime"
#define WIN_MAXIDLETIME                 L"MaxIdleTime"
#define WIN_MAXIDLETIME_A                "MaxIdleTime"
#define WIN_KEYBOARDLAYOUT              L"KeyboardLayout"
#define WIN_KEYBOARDLAYOUT_A             "KeyboardLayout"
#define WIN_MINENCRYPTIONLEVEL          L"MinEncryptionLevel"
#define WIN_MINENCRYPTIONLEVEL_A         "MinEncryptionLevel"
#define WIN_NWLOGONSERVER               L"NWLogonServer"
#define WIN_NWLOGONSERVER_A              "NWLogonServer"
#define WIN_WFPROFILEPATH               L"WFProfilePath"
#define WIN_WFPROFILEPATH_A              "WFProfilePath"
#define WIN_WFHOMEDIR                   L"WFHomeDir"
#define WIN_WFHOMEDIR_A                  "WFHomeDir"
#define WIN_WFHOMEDIRDRIVE              L"WFHomeDirDrive"
#define WIN_WFHOMEDIRDRIVE_A             "WFHomeDirDrive"

// New entries due to new Group Policy items. 
#define POLICY_DENY_TS_CONNECTIONS       L"fDenyTSConnections"
#define POLICY_TS_COLOR_DEPTH            L"ColorDepth"
#define POLICY_TS_REMDSK_ALLOWTOGETHELP  L"fAllowToGetHelp"
#define POLICY_TS_TSCC_PERM_TAB_WRITABLE L"fWritableTSCCPermTab"
#define POLICY_TS_SINGLE_SESSION_PER_USER L"fSingleSessionPerUser"
#define POLICY_TS_NO_REMOTE_DESKTOP_WALLPAPER   L"fNoRemoteDesktopWallpaper"

#define REG_MACHINE_IN_HELP_MODE         L"fInHelpMode"

#define REG_POLICY_PREVENT_LICENSE_UPGRADE    L"fPreventLicenseUpgrade"

/*
 *  Dos values
 */
#define CTXDOS_KBDIDLEDETECTPROBATIONCOUNT      L"KbdIdleDetectProbationCount"
#define CTXDOS_KBDIDLEDETECTPROBATIONCOUNT_A    "KbdIdleDetectProbationCount"
#define CTXDOS_KBDIDLEINPROBATIONCOUNT          L"KbdIdleInProbationCount"
#define CTXDOS_KBDIDLEINPROBATIONCOUNT_A        "KbdIdleInProbationCount"
#define CTXDOS_KBDIDLEDETECTABSOLUTE            L"KbdIdleDetectAbsolute"
#define CTXDOS_KBDIDLEDETECTABSOLUTE_A          "KbdIdleDetectAbsolute"
#define CTXDOS_KBDIDLEBUSYMSALLOWED             L"KbdIdleBusymsAllowed"
#define CTXDOS_KBDIDLEBUSYMSALLOWED_A           "KbdIdleBusymsAllowed"
#define CTXDOS_KBDIDLEMSALLOWED                 L"KbdIdlemsAllowed"
#define CTXDOS_KBDIDLEMSALLOWED_A               "KbdIdlemsAllowed"
#define CTXDOS_KBDIDLEMSGOODPROBATIONEND        L"KbdIdlemsGoodProbationEnd"
#define CTXDOS_KBDIDLEMSGOODPROBATIONEND_A      "KbdIdlemsGoodProbationEnd"
#define CTXDOS_KBDIDLEMSPROBATIONTRAIL          L"KbdIdlemsProbationTrial"
#define CTXDOS_KBDIDLEMSPROBATIONTRAIL_A        "KbdIdlemsProbationTrial"
#define CTXDOS_KBDIDLEMSSLEEP                   L"KbdIdlemsSleep"
#define CTXDOS_KBDIDLEMSSLEEP_A                 "KbdIdlemsSleep"
#define CTXDOS_KBDIDLEDETECTIONINTERVAL         L"KbdIdleDetectionInterval"
#define CTXDOS_KBDIDLEDETECTIONINTERVAL_A       "KbdIdleDetectionInterval"

/*
 * AuthorizedApplications values
 */
#define CTXAPPS_APPLICATIONLIST         L"ApplicationList"
#define CTXAPPS_APPLICATIONLIST_A        "ApplicationList"
#define CTXAPPS_ENABLED                 L"fEnabled"
#define CTXAPPS_ENABLED_A                "fEnabled"

/*
 * Compatibility\Applications\<appname> values (some also appear as defaults
 * under REG_CONTROL_TSERVER)
 */
#define COMPAT_MSGQBADAPPSLEEPTIMEINMILLISEC    L"MsgQBadAppSleepTimeInMillisec"
#define COMPAT_MSGQBADAPPSLEEPTIMEINMILLISEC_A   "MsgQBadAppSleepTimeInMillisec"
#define COMPAT_FIRSTCOUNTMSGQPEEKSSLEEPBADAPP   L"FirstCountMsgQPeeksSleepBadApp"
#define COMPAT_FIRSTCOUNTMSGQPEEKSSLEEPBADAPP_A  "FirstCountMsgQPeeksSleepBadApp"
#define COMPAT_NTHCOUNTMSGQPEEKSSLEEPBADAPP     L"NthCountMsgQPeeksSleepBadApp"
#define COMPAT_NTHCOUNTMSGQPEEKSSLEEPBADAPP_A    "NthCountMsgQPeeksSleepBadApp"
#define COMPAT_FLAGS                            L"Flags"
#define COMPAT_FLAGS_A                           "Flags"
#define COMPAT_CLIPBOARDFLAGS                   L"ClipboardFlags"
#define COMPAT_CLIPBOARDFLAGS_A                  "ClipboardFlags"
#define COMPAT_OPENCLIPBOARDRETRIES             L"OpenClipboardRetries"
#define COMPAT_OPENCLIPBOARDRETRIES_A            "OpenClipboardRetries"
#define COMPAT_OPENCLIPBOARDDELAYINMILLISECS    L"OpenClipboardDelayInMilliSecs"
#define COMPAT_OPENCLIPBOARDDELAYINMILLISECS_A   "OpenClipboardDelayInMilliSecs"
#define COMPAT_PHYSICALMEMORYLIMIT              L"PhysicalMemoryLimit"
#define COMPAT_PHYSICALMEMORYLIMIT_A             "PhysicalMemoryLimit"

/*
 * Compatibility\Applications\<appname>\ObjectRules and *\DllRules values
 */
#define COMPAT_RULES_USER_GLOBAL_SEMAPHORES     L"UserGlobalSemaphores"
#define COMPAT_RULES_USER_GLOBAL_SEMAPHORES_A    "UserGlobalSemaphores"
#define COMPAT_RULES_USER_GLOBAL_EVENTS         L"UserGlobalEvents"
#define COMPAT_RULES_USER_GLOBAL_EVENTS_A        "UserGlobalEvents"
#define COMPAT_RULES_USER_GLOBAL_MUTEXES        L"UserGlobalMutexes"
#define COMPAT_RULES_USER_GLOBAL_MUTEXES_A       "UserGlobalMutexes"
#define COMPAT_RULES_USER_GLOBAL_SECTIONS       L"UserGlobalSections"
#define COMPAT_RULES_USER_GLOBAL_SECTIONS_A      "UserGlobalSections"
#define COMPAT_RULES_SYSTEM_GLOBAL_SEMAPHORES   L"SystemGlobalSemaphores"
#define COMPAT_RULES_SYSTEM_GLOBAL_SEMAPHORES_A  "SystemGlobalSemaphores"
#define COMPAT_RULES_SYSTEM_GLOBAL_EVENTS       L"SystemGlobalEvents"
#define COMPAT_RULES_SYSTEM_GLOBAL_EVENTS_A      "SystemGlobalEvents"
#define COMPAT_RULES_SYSTEM_GLOBAL_MUTEXES      L"SystemGlobalMutexes"
#define COMPAT_RULES_SYSTEM_GLOBAL_MUTEXES_A     "SystemGlobalMutexes"
#define COMPAT_RULES_SYSTEM_GLOBAL_SECTIONS     L"SystemGlobalSections"
#define COMPAT_RULES_SYSTEM_GLOBAL_SECTIONS_A    "SystemGlobalSections"

/*
 * Compatibility\Registry Entries system values
 */
#define COMPAT_REGENTRIES_CLASSES               L"Classes"
#define COMPAT_REGENTRIES_CLASSES_A              "Classes"

/*
 * INIFILE_TIMES_REG_NAME system values
 */
#define INIFILE_TIMES_LATESTREGISTRYKEY         L"LatestRegistryKey"
#define INIFILE_TIMES_LATESTREGISTRYKEY_A        "LatestRegistryKey"

/*
 * SECURITY_REG_NAME system values
 */
#define CTXSECURITY_SECURITYLEVEL               L"SecurityLevel"
#define CTXSECURITY_SECURITYLEVEL_A              "SecurityLevel"

/*
 * WINDOWS_REG_NAME system values
 */
#define CTXWINDOWS_USERDIRECTORYNAME            L"UserDirectoryName"
#define CTXWINDOWS_USERDIRECTORYNAME_A           "UserDirectoryName"

/*
 * CURRENT_USER\(REG_SOFTWARE_TSERVER) values
 */
#define COMPAT_USER_LASTUSERINISYNCTIME         L"LastUserIniSyncTime"
#define COMPAT_USER_LASTUSERINISYNCTIME_A        "LastUserIniSyncTime"

/*
 * Windows NT build number information value (under BUILD_NUMBER_KEY)
 */
#define BUILD_NUMBER_VALUE              L"CurrentBuildNumber"
#define BUILD_NUMBER_VALUE_A             "CurrentBuildNumber"

/*
 * KeepAlive Values
 */
#define KEEP_ALIVE_ENABLE_KEY           L"KeepAliveEnable"
#define KEEP_ALIVE_ENABLE_KEY_A          "KeepAliveEnable"

#define KEEP_ALIVE_INTERVAL_KEY         L"KeepAliveInterval"
#define KEEP_ALIVE_INTERVAL_KEY_A        "KeepAliveInterval"

/*
 * MaxOutStandingConnect value
 */
#define MAX_OUTSTD_CONNECT              L"MaxOutStandingConnect"
#define MAX_OUTSTD_CONNECT_A             "MaxOutStandingConnect"


/*
 * MaxSingleOutStandingConnect value
 */
#define MAX_SINGLE_OUTSTD_CONNECT              L"MaxSingleOutStandingConnect"
#define MAX_SINGLE_OUTSTD_CONNECT_A             "MaxSingleOutStandingConnect"


/*
 * LogoffTimeout value
 */
 
#define LOGOFF_TIMEOUT                  L"LogoffTimeout"
#define LOGOFF_TIMEOUT_A                  "LogoffTimeout"

/*
 * Channel throttling values.
 */
#define REG_MOUSE_THROTTLE_SIZE   L"MouseThrottleSize"
#define REG_MOUSE_THROTTLE_SIZE_A  "MouseThrottleSize"
#define REG_KEYBOARD_THROTTLE_SIZE   L"KeyboardThrottleSize"
#define REG_KEYBOARD_THROTTLE_SIZE_A  "KeyboardThrottleSize"


/*
 * Device Redirection Values
 */
#define DEVICERDR_SESSIONID             L"TSSessionID"
#define DEVICERDR_SESSIONID_A            "TSSessionID"
#define DEVICERDR_WAITFORSPOOLTIMEOUT   L"WaitForSpoolerTimeOut"
#define DEVICERDR_WAITFORSPOOLTIMEOUT_A  "WaitForSpoolerTimeOut"

/*
 * Various other defines that probably should live elsewhere
 */
// Dll Oem and Product information DLL (this should be elsewhere)
#define OEM_AND_PRODUCT_INFO_DLL        L"SHELL32.DLL"

// defines for Citrix error and status extensions (this should be elsewhere)
#define  WIN_EVENTLOGPATH       L"%SystemRoot%\\System32\\cxstatus.dll;%SystemRoot%\\System32\\cxerror.dll"



/*
 * Salem specific registry key
 */
#define REG_CONTROL_SALEM L"Software\\Microsoft\\Remote Desktop"

/*
* Registry key to control Salem 'GetHelp'
*/
#define REG_CONTROL_GETHELP REG_CONTROL_TSERVER

#endif //__REGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\sessmgr.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for sessmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sessmgr_h__
#define __sessmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRemoteDesktopHelpSession_FWD_DEFINED__
#define __IRemoteDesktopHelpSession_FWD_DEFINED__
typedef interface IRemoteDesktopHelpSession IRemoteDesktopHelpSession;
#endif 	/* __IRemoteDesktopHelpSession_FWD_DEFINED__ */


#ifndef __IRemoteDesktopHelpSessionMgr_FWD_DEFINED__
#define __IRemoteDesktopHelpSessionMgr_FWD_DEFINED__
typedef interface IRemoteDesktopHelpSessionMgr IRemoteDesktopHelpSessionMgr;
#endif 	/* __IRemoteDesktopHelpSessionMgr_FWD_DEFINED__ */


#ifndef __RemoteDesktopHelpSessionMgr_FWD_DEFINED__
#define __RemoteDesktopHelpSessionMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class RemoteDesktopHelpSessionMgr RemoteDesktopHelpSessionMgr;
#else
typedef struct RemoteDesktopHelpSessionMgr RemoteDesktopHelpSessionMgr;
#endif /* __cplusplus */

#endif 	/* __RemoteDesktopHelpSessionMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "rdshost.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IRemoteDesktopHelpSession_INTERFACE_DEFINED__
#define __IRemoteDesktopHelpSession_INTERFACE_DEFINED__

/* interface IRemoteDesktopHelpSession */
/* [unique][helpstring][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IRemoteDesktopHelpSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("19E62A24-95D2-483A-AEB6-6FA92914DF96")
    IRemoteDesktopHelpSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HelpSessionId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserLogonId( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AssistantAccountName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UserHelpSessionRemoteDesktopSharingSetting( 
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS level) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserHelpSessionRemoteDesktopSharingSetting( 
            /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *pLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectParms( 
            /* [retval][out] */ BSTR *pConnectParm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteHelp( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResolveUserSession( 
            /* [in] */ BSTR bstrResolverBlob,
            /* [in] */ BSTR bstrExpertBlob,
            /* [in] */ LONG CallerProcessId,
            /* [out] */ ULONG_PTR *hHelpCtr,
            /* [out] */ LONG *pResolverErrorCode,
            /* [retval][out] */ long *plUserSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableUserSessionRdsSetting( 
            /* [in] */ BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDesktopHelpSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDesktopHelpSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDesktopHelpSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDesktopHelpSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRemoteDesktopHelpSession * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRemoteDesktopHelpSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRemoteDesktopHelpSession * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRemoteDesktopHelpSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HelpSessionId )( 
            IRemoteDesktopHelpSession * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserLogonId )( 
            IRemoteDesktopHelpSession * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AssistantAccountName )( 
            IRemoteDesktopHelpSession * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UserHelpSessionRemoteDesktopSharingSetting )( 
            IRemoteDesktopHelpSession * This,
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS level);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserHelpSessionRemoteDesktopSharingSetting )( 
            IRemoteDesktopHelpSession * This,
            /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *pLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectParms )( 
            IRemoteDesktopHelpSession * This,
            /* [retval][out] */ BSTR *pConnectParm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteHelp )( 
            IRemoteDesktopHelpSession * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResolveUserSession )( 
            IRemoteDesktopHelpSession * This,
            /* [in] */ BSTR bstrResolverBlob,
            /* [in] */ BSTR bstrExpertBlob,
            /* [in] */ LONG CallerProcessId,
            /* [out] */ ULONG_PTR *hHelpCtr,
            /* [out] */ LONG *pResolverErrorCode,
            /* [retval][out] */ long *plUserSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableUserSessionRdsSetting )( 
            IRemoteDesktopHelpSession * This,
            /* [in] */ BOOL bEnable);
        
        END_INTERFACE
    } IRemoteDesktopHelpSessionVtbl;

    interface IRemoteDesktopHelpSession
    {
        CONST_VTBL struct IRemoteDesktopHelpSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDesktopHelpSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDesktopHelpSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDesktopHelpSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDesktopHelpSession_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteDesktopHelpSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteDesktopHelpSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteDesktopHelpSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteDesktopHelpSession_get_HelpSessionId(This,pVal)	\
    (This)->lpVtbl -> get_HelpSessionId(This,pVal)

#define IRemoteDesktopHelpSession_get_UserLogonId(This,pVal)	\
    (This)->lpVtbl -> get_UserLogonId(This,pVal)

#define IRemoteDesktopHelpSession_get_AssistantAccountName(This,pVal)	\
    (This)->lpVtbl -> get_AssistantAccountName(This,pVal)

#define IRemoteDesktopHelpSession_put_UserHelpSessionRemoteDesktopSharingSetting(This,level)	\
    (This)->lpVtbl -> put_UserHelpSessionRemoteDesktopSharingSetting(This,level)

#define IRemoteDesktopHelpSession_get_UserHelpSessionRemoteDesktopSharingSetting(This,pLevel)	\
    (This)->lpVtbl -> get_UserHelpSessionRemoteDesktopSharingSetting(This,pLevel)

#define IRemoteDesktopHelpSession_get_ConnectParms(This,pConnectParm)	\
    (This)->lpVtbl -> get_ConnectParms(This,pConnectParm)

#define IRemoteDesktopHelpSession_DeleteHelp(This)	\
    (This)->lpVtbl -> DeleteHelp(This)

#define IRemoteDesktopHelpSession_ResolveUserSession(This,bstrResolverBlob,bstrExpertBlob,CallerProcessId,hHelpCtr,pResolverErrorCode,plUserSession)	\
    (This)->lpVtbl -> ResolveUserSession(This,bstrResolverBlob,bstrExpertBlob,CallerProcessId,hHelpCtr,pResolverErrorCode,plUserSession)

#define IRemoteDesktopHelpSession_EnableUserSessionRdsSetting(This,bEnable)	\
    (This)->lpVtbl -> EnableUserSessionRdsSetting(This,bEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_get_HelpSessionId_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IRemoteDesktopHelpSession_get_HelpSessionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_get_UserLogonId_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IRemoteDesktopHelpSession_get_UserLogonId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_get_AssistantAccountName_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IRemoteDesktopHelpSession_get_AssistantAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_put_UserHelpSessionRemoteDesktopSharingSetting_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [in] */ REMOTE_DESKTOP_SHARING_CLASS level);


void __RPC_STUB IRemoteDesktopHelpSession_put_UserHelpSessionRemoteDesktopSharingSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_get_UserHelpSessionRemoteDesktopSharingSetting_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *pLevel);


void __RPC_STUB IRemoteDesktopHelpSession_get_UserHelpSessionRemoteDesktopSharingSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_get_ConnectParms_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [retval][out] */ BSTR *pConnectParm);


void __RPC_STUB IRemoteDesktopHelpSession_get_ConnectParms_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_DeleteHelp_Proxy( 
    IRemoteDesktopHelpSession * This);


void __RPC_STUB IRemoteDesktopHelpSession_DeleteHelp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_ResolveUserSession_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [in] */ BSTR bstrResolverBlob,
    /* [in] */ BSTR bstrExpertBlob,
    /* [in] */ LONG CallerProcessId,
    /* [out] */ ULONG_PTR *hHelpCtr,
    /* [out] */ LONG *pResolverErrorCode,
    /* [retval][out] */ long *plUserSession);


void __RPC_STUB IRemoteDesktopHelpSession_ResolveUserSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSession_EnableUserSessionRdsSetting_Proxy( 
    IRemoteDesktopHelpSession * This,
    /* [in] */ BOOL bEnable);


void __RPC_STUB IRemoteDesktopHelpSession_EnableUserSessionRdsSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDesktopHelpSession_INTERFACE_DEFINED__ */


#ifndef __IRemoteDesktopHelpSessionMgr_INTERFACE_DEFINED__
#define __IRemoteDesktopHelpSessionMgr_INTERFACE_DEFINED__

/* interface IRemoteDesktopHelpSessionMgr */
/* [unique][helpstring][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IRemoteDesktopHelpSessionMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8556D72C-2854-447D-A098-39CDBFCDB832")
    IRemoteDesktopHelpSessionMgr : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ResetHelpAssistantAccount( 
            /* [in] */ BOOL bForce) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateHelpSession( 
            /* [in] */ BSTR bstrSessName,
            /* [in] */ BSTR bstrSessPwd,
            /* [in] */ BSTR bstrSessDesc,
            /* [in] */ BSTR bstrHelpCreateBlob,
            /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteHelpSession( 
            /* [in] */ BSTR HelpSessionID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetrieveHelpSession( 
            /* [in] */ BSTR HelpSessionID,
            /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE VerifyUserHelpSession( 
            /* [in] */ BSTR HelpSessionId,
            /* [in] */ BSTR bstrSessPwd,
            /* [in] */ BSTR bstrResolverBlob,
            /* [in] */ BSTR bstrExpertBlob,
            /* [in] */ LONG CallerProcessId,
            /* [out] */ ULONG_PTR *phHelpCtr,
            /* [out] */ LONG *pResolverErrCode,
            /* [retval][out] */ long *pdwUserLogonSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsValidHelpSession( 
            /* [in] */ BSTR HelpSessionId,
            /* [in] */ BSTR bstrSessPwd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetUserSessionRdsSetting( 
            /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *sessionRdsLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoteCreateHelpSession( 
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ LONG timeOut,
            /* [in] */ LONG userSessionId,
            /* [in] */ BSTR userSid,
            /* [in] */ BSTR bstrHelpCreateBlob,
            /* [retval][out] */ BSTR *parms) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateHelpSessionEx( 
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ BOOL fEnableCallback,
            /* [in] */ LONG timeOut,
            /* [in] */ LONG userSessionId,
            /* [in] */ BSTR userSid,
            /* [in] */ BSTR bstrHelpCreateBlob,
            /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogSalemEvent( 
            /* [in] */ LONG ulEventType,
            /* [in] */ LONG ulEventCode,
            /* [in] */ VARIANT *EventString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRemoteDesktopHelpSessionMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRemoteDesktopHelpSessionMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRemoteDesktopHelpSessionMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ResetHelpAssistantAccount )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ BOOL bForce);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateHelpSession )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ BSTR bstrSessName,
            /* [in] */ BSTR bstrSessPwd,
            /* [in] */ BSTR bstrSessDesc,
            /* [in] */ BSTR bstrHelpCreateBlob,
            /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteHelpSession )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ BSTR HelpSessionID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RetrieveHelpSession )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ BSTR HelpSessionID,
            /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *VerifyUserHelpSession )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ BSTR HelpSessionId,
            /* [in] */ BSTR bstrSessPwd,
            /* [in] */ BSTR bstrResolverBlob,
            /* [in] */ BSTR bstrExpertBlob,
            /* [in] */ LONG CallerProcessId,
            /* [out] */ ULONG_PTR *phHelpCtr,
            /* [out] */ LONG *pResolverErrCode,
            /* [retval][out] */ long *pdwUserLogonSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsValidHelpSession )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ BSTR HelpSessionId,
            /* [in] */ BSTR bstrSessPwd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetUserSessionRdsSetting )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *sessionRdsLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoteCreateHelpSession )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ LONG timeOut,
            /* [in] */ LONG userSessionId,
            /* [in] */ BSTR userSid,
            /* [in] */ BSTR bstrHelpCreateBlob,
            /* [retval][out] */ BSTR *parms);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateHelpSessionEx )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
            /* [in] */ BOOL fEnableCallback,
            /* [in] */ LONG timeOut,
            /* [in] */ LONG userSessionId,
            /* [in] */ BSTR userSid,
            /* [in] */ BSTR bstrHelpCreateBlob,
            /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogSalemEvent )( 
            IRemoteDesktopHelpSessionMgr * This,
            /* [in] */ LONG ulEventType,
            /* [in] */ LONG ulEventCode,
            /* [in] */ VARIANT *EventString);
        
        END_INTERFACE
    } IRemoteDesktopHelpSessionMgrVtbl;

    interface IRemoteDesktopHelpSessionMgr
    {
        CONST_VTBL struct IRemoteDesktopHelpSessionMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRemoteDesktopHelpSessionMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRemoteDesktopHelpSessionMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRemoteDesktopHelpSessionMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRemoteDesktopHelpSessionMgr_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRemoteDesktopHelpSessionMgr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRemoteDesktopHelpSessionMgr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRemoteDesktopHelpSessionMgr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRemoteDesktopHelpSessionMgr_ResetHelpAssistantAccount(This,bForce)	\
    (This)->lpVtbl -> ResetHelpAssistantAccount(This,bForce)

#define IRemoteDesktopHelpSessionMgr_CreateHelpSession(This,bstrSessName,bstrSessPwd,bstrSessDesc,bstrHelpCreateBlob,ppIRDHelpSession)	\
    (This)->lpVtbl -> CreateHelpSession(This,bstrSessName,bstrSessPwd,bstrSessDesc,bstrHelpCreateBlob,ppIRDHelpSession)

#define IRemoteDesktopHelpSessionMgr_DeleteHelpSession(This,HelpSessionID)	\
    (This)->lpVtbl -> DeleteHelpSession(This,HelpSessionID)

#define IRemoteDesktopHelpSessionMgr_RetrieveHelpSession(This,HelpSessionID,ppIRDHelpSession)	\
    (This)->lpVtbl -> RetrieveHelpSession(This,HelpSessionID,ppIRDHelpSession)

#define IRemoteDesktopHelpSessionMgr_VerifyUserHelpSession(This,HelpSessionId,bstrSessPwd,bstrResolverBlob,bstrExpertBlob,CallerProcessId,phHelpCtr,pResolverErrCode,pdwUserLogonSession)	\
    (This)->lpVtbl -> VerifyUserHelpSession(This,HelpSessionId,bstrSessPwd,bstrResolverBlob,bstrExpertBlob,CallerProcessId,phHelpCtr,pResolverErrCode,pdwUserLogonSession)

#define IRemoteDesktopHelpSessionMgr_IsValidHelpSession(This,HelpSessionId,bstrSessPwd)	\
    (This)->lpVtbl -> IsValidHelpSession(This,HelpSessionId,bstrSessPwd)

#define IRemoteDesktopHelpSessionMgr_GetUserSessionRdsSetting(This,sessionRdsLevel)	\
    (This)->lpVtbl -> GetUserSessionRdsSetting(This,sessionRdsLevel)

#define IRemoteDesktopHelpSessionMgr_RemoteCreateHelpSession(This,sharingClass,timeOut,userSessionId,userSid,bstrHelpCreateBlob,parms)	\
    (This)->lpVtbl -> RemoteCreateHelpSession(This,sharingClass,timeOut,userSessionId,userSid,bstrHelpCreateBlob,parms)

#define IRemoteDesktopHelpSessionMgr_CreateHelpSessionEx(This,sharingClass,fEnableCallback,timeOut,userSessionId,userSid,bstrHelpCreateBlob,ppIRDHelpSession)	\
    (This)->lpVtbl -> CreateHelpSessionEx(This,sharingClass,fEnableCallback,timeOut,userSessionId,userSid,bstrHelpCreateBlob,ppIRDHelpSession)

#define IRemoteDesktopHelpSessionMgr_LogSalemEvent(This,ulEventType,ulEventCode,EventString)	\
    (This)->lpVtbl -> LogSalemEvent(This,ulEventType,ulEventCode,EventString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_ResetHelpAssistantAccount_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ BOOL bForce);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_ResetHelpAssistantAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_CreateHelpSession_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ BSTR bstrSessName,
    /* [in] */ BSTR bstrSessPwd,
    /* [in] */ BSTR bstrSessDesc,
    /* [in] */ BSTR bstrHelpCreateBlob,
    /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_CreateHelpSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_DeleteHelpSession_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ BSTR HelpSessionID);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_DeleteHelpSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_RetrieveHelpSession_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ BSTR HelpSessionID,
    /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_RetrieveHelpSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_VerifyUserHelpSession_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ BSTR HelpSessionId,
    /* [in] */ BSTR bstrSessPwd,
    /* [in] */ BSTR bstrResolverBlob,
    /* [in] */ BSTR bstrExpertBlob,
    /* [in] */ LONG CallerProcessId,
    /* [out] */ ULONG_PTR *phHelpCtr,
    /* [out] */ LONG *pResolverErrCode,
    /* [retval][out] */ long *pdwUserLogonSession);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_VerifyUserHelpSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_IsValidHelpSession_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ BSTR HelpSessionId,
    /* [in] */ BSTR bstrSessPwd);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_IsValidHelpSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_GetUserSessionRdsSetting_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [retval][out] */ REMOTE_DESKTOP_SHARING_CLASS *sessionRdsLevel);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_GetUserSessionRdsSetting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_RemoteCreateHelpSession_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    /* [in] */ LONG timeOut,
    /* [in] */ LONG userSessionId,
    /* [in] */ BSTR userSid,
    /* [in] */ BSTR bstrHelpCreateBlob,
    /* [retval][out] */ BSTR *parms);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_RemoteCreateHelpSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_CreateHelpSessionEx_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ REMOTE_DESKTOP_SHARING_CLASS sharingClass,
    /* [in] */ BOOL fEnableCallback,
    /* [in] */ LONG timeOut,
    /* [in] */ LONG userSessionId,
    /* [in] */ BSTR userSid,
    /* [in] */ BSTR bstrHelpCreateBlob,
    /* [retval][out] */ IRemoteDesktopHelpSession **ppIRDHelpSession);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_CreateHelpSessionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRemoteDesktopHelpSessionMgr_LogSalemEvent_Proxy( 
    IRemoteDesktopHelpSessionMgr * This,
    /* [in] */ LONG ulEventType,
    /* [in] */ LONG ulEventCode,
    /* [in] */ VARIANT *EventString);


void __RPC_STUB IRemoteDesktopHelpSessionMgr_LogSalemEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRemoteDesktopHelpSessionMgr_INTERFACE_DEFINED__ */



#ifndef __RDSESSMGRLib_LIBRARY_DEFINED__
#define __RDSESSMGRLib_LIBRARY_DEFINED__

/* library RDSESSMGRLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_RDSESSMGRLib;

EXTERN_C const CLSID CLSID_RemoteDesktopHelpSessionMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("A6A6F92B-26B5-463B-AE0D-5F361B09C171")
RemoteDesktopHelpSessionMgr;
#endif
#endif /* __RDSESSMGRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\regsam.h ===
/*************************************************************************
*
* regsam.h
*
* Includes for SAM-based APIs within regapi.dll 
*
* NOTE: This header files requires SAM definitions found in ntsam.h.
*
* Copyright Microsoft Corporation, 1998
*
*  
*
*************************************************************************/

#ifndef __REGSAM_H__
#define __REGSAM_H__

DWORD 
RegSAMUserConfig(
    BOOLEAN fGetConfig,
    PWCHAR pUserName,
    PWCHAR pServerName,
    PUSERCONFIGW pUser
    );

NTSTATUS
RegGetUserConfigFromUserParameters(
    PUSER_PARAMETERS_INFORMATION pUserParmInfo,
    PUSERCONFIGW pUser
    );

NTSTATUS
RegMergeUserConfigWithUserParameters(
    PUSER_PARAMETERS_INFORMATION pUserParmInfo,
    PUSERCONFIGW pUser,
    PUSER_PARAMETERS_INFORMATION pNewUserParmInfo
    );

#endif //__REGSAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\sessmgr_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for sessmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRemoteDesktopHelpSession,0x19E62A24,0x95D2,0x483A,0xAE,0xB6,0x6F,0xA9,0x29,0x14,0xDF,0x96);


MIDL_DEFINE_GUID(IID, IID_IRemoteDesktopHelpSessionMgr,0x8556D72C,0x2854,0x447D,0xA0,0x98,0x39,0xCD,0xBF,0xCD,0xB8,0x32);


MIDL_DEFINE_GUID(IID, LIBID_RDSESSMGRLib,0x71F1098A,0x2D69,0x45D7,0xB1,0x9E,0xD3,0xB9,0x02,0x32,0x3F,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_RemoteDesktopHelpSessionMgr,0xA6A6F92B,0x26B5,0x463B,0xAE,0x0D,0x5F,0x36,0x1B,0x09,0xC1,0x71);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for sessmgr.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRemoteDesktopHelpSession,0x19E62A24,0x95D2,0x483A,0xAE,0xB6,0x6F,0xA9,0x29,0x14,0xDF,0x96);


MIDL_DEFINE_GUID(IID, IID_IRemoteDesktopHelpSessionMgr,0x8556D72C,0x2854,0x447D,0xA0,0x98,0x39,0xCD,0xBF,0xCD,0xB8,0x32);


MIDL_DEFINE_GUID(IID, LIBID_RDSESSMGRLib,0x71F1098A,0x2D69,0x45D7,0xB1,0x9E,0xD3,0xB9,0x02,0x32,0x3F,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_RemoteDesktopHelpSessionMgr,0xA6A6F92B,0x26B5,0x463B,0xAE,0x0D,0x5F,0x36,0x1B,0x09,0xC1,0x71);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\syslib.h ===
/*************************************************************************
*
* syslib.h
*
* Header file for Terminal Server System Library routines.
*
Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/
#ifndef _INC_CTXSYSLIB
#define _INC_CTXSYSLIB


//
// Routines for dealing with WinStations
//

//
// This function enumerates all WinStations in the system
// calling the supplied function with the supplied argument.
//

typedef BOOLEAN (CALLBACK* WINSTATIONENUMPROC)(ULONG, PLOGONIDW, ULONG_PTR);

BOOLEAN
WinStationEnumeratorW(
    ULONG StartIndex,
    WINSTATIONENUMPROC pProc,
    ULONG_PTR lParam
    );


//
// Routines for dealing with users and WinStations
//

//
// Get the WinStations User name
//
BOOL
WinStationGetUserName(
    ULONG  LogonId,
    PWCHAR pBuf,
    ULONG  BufSize
    );

//
// Get the WinStations ICA name
//
#ifdef UNICODE
#define WinStationGetICAName WinStationGetICANameW
#else
#define WinStationGetICAName WinStationGetICANameA
#endif

PWCHAR
WinStationGetICANameW(
    ULONG LogonId
    );

PCHAR
WinStationGetICANameA(
    ULONG LogonId
    );

//
// Get the LogonId of the client currently being impersonated.
// Returns 0 if error to default to console.
//
ULONG
GetClientLogonId();


//
// Find which WinStation a given user name is logged into.
//
// NOTE: If a user is logged on multiple times, the FIRST
//       occurance is returned.
//
BOOL
FindUsersWinStation(
    PWCHAR   pName,
    PULONG   pLogonId
    );

//
// Return whether the WinStation is hardwired
//
BOOLEAN
WinStationIsHardWire(
    ULONG LogonId
    );

//
// Return the user token for the user logged on the WinStation
//
BOOL
GetWinStationUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    );

//
// Routines to deal with NT Security
//

//
// Return whether the calling thread has admin rights.
//

#if 0
BOOL
TestUserForAdmin( VOID );
#endif

//
// Return whether the calling thread is a member of requested group.
//

BOOL
TestUserForGroup( PWCHAR );

//
// Debugging routines for dumping security descriptors
//

#if DBG
void
DumpSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD
    );
#endif


//
// Application compatibility flags
//
#define CITRIX_COMPAT_DOS       0x00000001
#define CITRIX_COMPAT_OS2       0x00000002
#define CITRIX_COMPAT_WIN16     0x00000004
#define CITRIX_COMPAT_WIN32     0x00000008
#define CITRIX_COMPAT_ALL       0x0000000F
#define CITRIX_COMPAT_USERNAME  0x00000010  // return username for computername
#define CITRIX_COMPAT_CTXBLDNUM 0x00000020  // return Citrix build number
#define CITRIX_COMPAT_INISYNC   0x00000040  // sync user ini file to system
#define CITRIX_COMPAT_ININOSUB  0x00000080  // Don't subst. user dir for sys dir
#define CITRIX_COMPAT_NOREGMAP  0x00000100  // Disable registry mapping for app
#define CITRIX_COMPAT_PEROBJMAP 0x00000200  // Per object user/system global mapping
#define CITRIX_COMPAT_SYSWINDIR 0x00000400  // return system windows directory
#define CITRIX_COMPAT_PHYSMEMLIM \
                                0x00000800  // Limit the reported physical memory info
#define CITRIX_COMPAT_LOGOBJCREATE \
                                0x00001000  // Log object creation to file
#define CITRIX_COMPAT_KBDPOLL_NOSLEEP \
                                0x20000000  // Don't put app to sleep on unsuccessful
                                            // keyboard polling (WIN16 only)

//
//  Clipboard compatibility flags
//
#define CITRIX_COMPAT_CLIPBRD_METAFILE  0x00000008

BOOL SetCtxAppCompatFlags(ULONG ulAppFlags);

//
// Create and set the user's temp directory
//
typedef struct {
    HANDLE                 UserToken;
    PSECURITY_DESCRIPTOR   NewThreadTokenSD;
} CTX_USER_DATA;
typedef CTX_USER_DATA  *PCTX_USER_DATA;

BOOL
CtxCreateTempDir(
    PWSTR pwcEnvVar,
    PWSTR pwcLogonID,
    PVOID *pEnv,
    PWSTR *ppTempName,
    PCTX_USER_DATA pUserData
    );

//
// Remove the directory and all files and subdirectories it contains
//
BOOL RemoveDir( PWCHAR dirname );

// 
// User Impersonation
//
HANDLE
CtxImpersonateUser(
    PCTX_USER_DATA UserData,
    HANDLE ThreadHandle
    );
BOOL 
CtxStopImpersonating(
    HANDLE ThreadHandle
    );

#endif  /* !_INC_CTXSYSLIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\tscfgex.h ===
/*++

Copyright (C) 1989-1998 Microsoft Corporation, All rights reserved

Module:
    tscfgex.h

Abstract:
    Terminal Server Connection Configuration DLL extension data structures
    and function prototypes.

Author:
    Brad Graziadio (BradG) 4-Feb-98

--*/

#ifndef _TSCFGEX_
#define _TSCFGEX_

#include <winsta.h>

//
// This data structure is used to represent the list of encryption
// levels that a protocol supports.
//
typedef struct _EncLevel {
    WORD    StringID;           // Resource ID to lookup in DLLs resource table
    DWORD   RegistryValue;      // DWORD value to set in registry
    WORD    Flags;              // Flags (see ELF_* values below)
} EncryptionLevel, *PEncryptionLevel;

// Flags for EncryptionLevel.Flags
#define ELF_DEFAULT     0x0001

typedef LONG (WINAPI *LPFNEXTENCRYPTIONLEVELSPROC) (WDNAME *pWdName, EncryptionLevel **);

//
// Flags for ExtGetCapabilities
//
const ULONG WDC_CLIENT_DRIVE_MAPPING            = 0x00000001;
const ULONG WDC_WIN_CLIENT_PRINTER_MAPPING      = 0x00000002;
const ULONG WDC_CLIENT_LPT_PORT_MAPPING         = 0x00000004;
const ULONG WDC_CLIENT_COM_PORT_MAPPING         = 0x00000008;
const ULONG WDC_CLIENT_CLIPBOARD_MAPPING        = 0x00000010;
const ULONG WDC_CLIENT_AUDIO_MAPPING            = 0x00000020;
const ULONG WDC_SHADOWING                       = 0x00000040;
const ULONG WDC_PUBLISHED_APPLICATIONS          = 0x00000080;
const ULONG WDC_RECONNECT_PREVCLIENT			= 0X00000100;

#define WDC_CLIENT_DIALOG_MASK (WDC_CLIENT_DRIVE_MAPPING | \
                                WDC_WIN_CLIENT_PRINTER_MAPPING | \
                                WDC_CLIENT_LPT_PORT_MAPPING | \
                                WDC_CLIENT_COM_PORT_MAPPING | \
                                WDC_CLIENT_CLIPBOARD_MAPPING | \
                                WDC_CLIENT_AUDIO_MAPPING)


#define WDC_CLIENT_CONNECT_MASK = (WDC_CLIENT_DRIVE_MAPPING | \
                                  WDC_WIN_CLIENT_PRINTER_MAPPING | \
                                  WDC_CLIENT_LPT_PORT_MAPPING)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\tschannl.h ===
/**INC+**********************************************************************/
/* Header:    tschannl.h                                                    */
/*                                                                          */
/* Purpose:   Server Channel API file                                       */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log$
**/
/**INC-**********************************************************************/

/****************************************************************************/
/* Include common channel protocol definitions                              */
/****************************************************************************/
#include <pchannel.h>

/****************************************************************************/
/* Structure: CHANNEL_CONNECT_DEF                                           */
/*                                                                          */
/* Description: Definition of a channel for CHANNEL_CONNECT_IN              */
/****************************************************************************/
typedef struct tagCHANNEL_CONNECT_DEF
{
    char            name[CHANNEL_NAME_LEN + 1];
    ULONG           ID;
} CHANNEL_CONNECT_DEF, * PCHANNEL_CONNECT_DEF;

/****************************************************************************/
/* Structure: CHANNEL_IOCTL_IN                                              */
/*                                                                          */
/* Description: Common channel inbound IOCTL header                         */
/****************************************************************************/
typedef struct tagCHANNEL_IOCTL_IN
{
    UINT     sessionID;
    HANDLE   IcaHandle;
    UINT_PTR contextData;
} CHANNEL_IOCTL_IN, * PCHANNEL_IOCTL_IN;

/****************************************************************************/
/* Structure: CHANNEL_IOCTL_OUT                                             */
/*                                                                          */
/* Description: Common channel outbound IOCTL header                        */
/****************************************************************************/
typedef struct tagCHANNEL_IOCTL_OUT
{
    UINT_PTR contextData;
} CHANNEL_IOCTL_OUT, * PCHANNEL_IOCTL_OUT;


/****************************************************************************/
/* IOCTL_CHANNEL_CONNECT                                                    */
/*                                                                          */
/* - data in: CHANNEL_CONNECT_IN                                            */
/*                                                                          */
/* - data out: CHANNEL_CONNECT_OUT                                          */
/****************************************************************************/
#define IOCTL_CHANNEL_CONNECT \
         CTL_CODE(FILE_DEVICE_TERMSRV, 0xA00, METHOD_NEITHER, FILE_WRITE_ACCESS)

/****************************************************************************/
/* Structure: CHANNEL_CONNECT_IN                                            */
/*                                                                          */
/* Description: Data sent to driver on IOCTL_CHANNEL_CONNECT                */
/****************************************************************************/
typedef struct tagCHANNEL_CONNECT_IN
{
    CHANNEL_IOCTL_IN hdr;
    UINT             channelCount;
    ULONG fAutoClientDrives : 1;
    ULONG fAutoClientLpts : 1;
    ULONG fForceClientLptDef : 1;
    ULONG fDisableCpm : 1;
    ULONG fDisableCdm : 1;
    ULONG fDisableCcm : 1;
    ULONG fDisableLPT : 1;
    ULONG fDisableClip : 1;
    ULONG fDisableExe : 1;
    ULONG fDisableCam : 1;
    ULONG fDisableSCard : 1;
    /* <channelCount> repetitions of CHANNEL_CONNECT_DEF follow             */
} CHANNEL_CONNECT_IN, * PCHANNEL_CONNECT_IN;

/****************************************************************************/
/* Structure: CHANNEL_CONNECT_OUT                                           */
/*                                                                          */
/* Description: Data returned by driver on IOCTL_CHANNEL_CONNECT            */
/****************************************************************************/
typedef struct tagCHANNEL_CONNECT_OUT
{
    CHANNEL_IOCTL_OUT hdr;
} CHANNEL_CONNECT_OUT, *PCHANNEL_CONNECT_OUT;

/****************************************************************************/
/* IOCTL_CHANNEL_DISCONNECT                                                 */
/*                                                                          */
/* - data in: CHANNEL_DISCONNECT_IN                                         */
/*                                                                          */
/* - data out: CHANNEL_DISCONNECT_OUT                                       */
/****************************************************************************/
#define IOCTL_CHANNEL_DISCONNECT \
         CTL_CODE(FILE_DEVICE_TERMSRV, 0xA01, METHOD_NEITHER, FILE_WRITE_ACCESS)

/****************************************************************************/
/* Structure: CHANNEL_DISCONNECT_IN                                         */
/*                                                                          */
/* Description: Data sent to driver on IOCTL_CHANNEL_DISCONNECT             */
/****************************************************************************/
typedef struct tagCHANNEL_DISCONNECT_IN
{
    CHANNEL_IOCTL_IN hdr;
} CHANNEL_DISCONNECT_IN, * PCHANNEL_DISCONNECT_IN;

/****************************************************************************/
/* Structure: CHANNEL_DISCONNECT_OUT                                        */
/*                                                                          */
/* Description: Data returned by driver on IOCTL_CHANNEL_DISCONNECT         */
/****************************************************************************/
typedef struct tagCHANNEL_DISCONNECT_OUT
{
    CHANNEL_IOCTL_OUT hdr;
} CHANNEL_DISCONNECT_OUT, *PCHANNEL_DISCONNECT_OUT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\tserrs.h ===
/***************************************************************************
*
*  TSERRS.H
*
*  This module defines error codes passed from the server to the client
*  via TS_SET_ERROR_INFO_PDU (for RDP)
*
*  Copyright Microsoft Corporation, 2000
*
*
****************************************************************************/

#ifndef _INC_TSERRSH
#define _INC_TSERRSH

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************/
/* Error info values passed through the IOCTL_TSHARE_SET_ERROR_INFO IOCTL   */
/* down to the protocol drivers and then onto the client (for disconnect    */
/* reason reporting                                                         */
/****************************************************************************/

//
// Protocol independent codes
//
#define TS_ERRINFO_NOERROR                                  0x00000000
#define TS_ERRINFO_RPC_INITIATED_DISCONNECT                 0x00000001
#define TS_ERRINFO_RPC_INITIATED_LOGOFF                     0x00000002
#define TS_ERRINFO_IDLE_TIMEOUT                             0x00000003
#define TS_ERRINFO_LOGON_TIMEOUT                            0x00000004
#define TS_ERRINFO_DISCONNECTED_BY_OTHERCONNECTION          0x00000005
#define TS_ERRINFO_OUT_OF_MEMORY                            0x00000006
//
// Error happens when we get disconnected early in the connection sequence
// normal causes are (in priority)
//      1) TS not enabled / policy limiting new connections
//      2) Network error occured at early stage in connection
//
#define TS_ERRINFO_SERVER_DENIED_CONNECTION                 0x00000007

//
// Protocol independent licensing codes
//
#define TS_ERRINFO_LICENSE_INTERNAL                         0x0000100
#define TS_ERRINFO_LICENSE_NO_LICENSE_SERVER                0x0000101
#define TS_ERRINFO_LICENSE_NO_LICENSE                       0x0000102
#define TS_ERRINFO_LICENSE_BAD_CLIENT_MSG                   0x0000103
#define TS_ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE        0x0000104
#define TS_ERRINFO_LICENSE_BAD_CLIENT_LICENSE               0x0000105
#define TS_ERRINFO_LICENSE_CANT_FINISH_PROTOCOL             0x0000106
#define TS_ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL            0x0000107
#define TS_ERRINFO_LICENSE_BAD_CLIENT_ENCRYPTION            0x0000108
#define TS_ERRINFO_LICENSE_CANT_UPGRADE_LICENSE             0x0000109
#define TS_ERRINFO_LICENSE_NO_REMOTE_CONNECTIONS            0x000010A

//
// Salem specific error code
//
#define TS_ERRINFO_SALEM_INVALIDHELPSESSION                 0x0000200

//
// Protocol specific codes must be passed in the
// range TS_ERRINFO_PROTOCOL_BASE to TS_ERRINFO_PROTOCOL_END
//
#define TS_ERRINFO_PROTOCOL_BASE                            0x0001000
#define TS_ERRINFO_PROTOCOL_END                             0x0007FFF


#ifdef __cplusplus
}
#endif


#endif  /* !_INC_TSERRSH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\tsappcmp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    tsappcmp.h

Abstract:

    Terminal server application compatibility support

Author:


Revision History:

--*/

#ifndef _INC_TSAPPCMP
#define _INC_TSAPPCMP

// @@BEGIN_DDKSPLIT

#define TERMSRV_VALUE \
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Compatibility\\Registry Values"

#define TERMSRV_INSTALL \
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install"

#define TERMSRV_USERREGISTRY \
    L"\\Registry\\User"

#define TERMSRV_MACHINEREGISTRY \
    L"\\Registry\\Machine"

#define TERMSRV_CLASSES \
    L"\\Registry\\Machine\\Software\\Classes"

#define TERMSRV_INSTALLCLASSES \
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software\\Classes"

#define TERMSRV_CLASSES_SIZE sizeof(WCHAR)*(sizeof(TERMSRV_INSTALLCLASSES)+1)

#define TERMSRV_SOFTWARECLASSES \
    L"\\Software\\Classes"

#define TERMSRV_COPYONCEFLAG \
    L"TermSrvCopyKeyOnce"

//
// Compat flags for the register command, used for import table patching at run time.
// 
#define TERMSRV_COMPAT_DONT_PATCH_IN_LOAD_LIBS  0x00000001  // turn off the new Whistler defaul behavior which patches all 
                                                            // load libs to go thru our redirected load lib first.
                                                            //
                                                            // The images marked as GLOBAL would still patch in the loadlibs
                                                            // regardless of this flag
                                                            
#define TERMSRV_COMPAT_IAT_FLAGS           L"IAT"  // flags used by the register module which patches 
                                                   // the import-address-table
                                                   // So far, the following flags are defines/used:
                                                   //      TERMSRV_COMPAT_DONT_PATCH_IN_LOAD_LIBS
                                                   //

//
// Application compatibility flags
//
#define TERMSRV_COMPAT_DOS       0x00000001
#define TERMSRV_COMPAT_OS2       0x00000002
#define TERMSRV_COMPAT_WIN16     0x00000004
#define TERMSRV_COMPAT_WIN32     0x00000008
#define TERMSRV_COMPAT_ALL       0x0000000F
#define TERMSRV_COMPAT_USERNAME  0x00000010  // return username for computername
#define TERMSRV_COMPAT_CTXBLDNUM 0x00000020  // return Terminal Server build number
#define TERMSRV_COMPAT_INISYNC   0x00000040  // sync user ini file to system
#define TERMSRV_COMPAT_ININOSUB  0x00000080  // Don't subst. user dir for sys dir
#define TERMSRV_COMPAT_NOREGMAP  0x00000100  // Disable registry mapping for app
#define TERMSRV_COMPAT_PEROBJMAP 0x00000200  // Per object user/system global mapping
#define TERMSRV_COMPAT_SYSWINDIR 0x00000400  // return system windows directory
#define TERMSRV_COMPAT_PHYSMEMLIM \
                                0x00000800  // Limit the reported physical memory info
#define TERMSRV_COMPAT_LOGOBJCREATE \
                                0x00001000  // Log object creation to file
#define TERMSRV_COMPAT_SYSREGMAP 0x00002000  // Let system processes take advantage of
                                            // registry mapping.
#define TERMSRV_COMPAT_PERUSERWINDIR \
                                0x00004000  // Log object creation to file

#define TERMSRV_COMPAT_WAIT_USING_JOB_OBJECTS \
                                0x00008000  // Use kernelJobObject for tracking 
                                            // execution completion, since some apps,
                                            // such as VS60WIX.EXE self spawn and 
                                            // parent dies immediately.

#define TERMSRV_COMPAT_NO_ENABLE_ACCESS_FLAG_MODIFICATION   0x00010000
#define TERMSRV_COMPAT_NO_PER_USER_CLASSES_REDIRECTION      0x00020000

#define TERMSRV_COMPAT_KBDPOLL_NOSLEEP \
                                0x20000000  // Don't put app to sleep on unsuccessful
                                            // keyboard polling (WIN16 only)


#define TERMSRV_COMPAT_APP               NTAPI_COMPAT_APPS_REG_PREFIX

//Registry extension flags
#define TERMSRV_SOFTWARE \
    L"\\Registry\\Machine\\Software"
#define TERMSRV_BASE \
    L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"
#define TERMSRV_ENABLE_ACCESS_FLAG_MODIFICATION     0x00000001
#define TERMSRV_ENABLE_PER_USER_CLASSES_REDIRECTION 0x00000002
void GetRegistryExtensionFlags();
extern DWORD gdwRegistryExtensionFlags;

//
//  Clipboard compatibility flags
//
#define TERMSRV_COMPAT_CLIPBRD_METAFILE  0x00000008

typedef enum _TERMSRV_COMPATIBILITY_CLASS {
    CompatibilityApp = 1,
    CompatibilityIniFile,
    CompatibilityRegEntry
} TERMSRV_COMPATIBILITY_CLASS, *PTERMSRV_COMPATIBILITY_CLASS;



#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))

void InitializeTermsrvFpns(void);

//Kernel32 API's
typedef PWCHAR  (*PTERMSRVFORMATOBJECTNAME) (
                     IN LPCWSTR SrcObjectName
                    );
extern PTERMSRVFORMATOBJECTNAME gpTermsrvFormatObjectName;

typedef DWORD  (*PTERMSRVGETCOMPUTERNAME) (
                     OUT LPWSTR lpBuffer,
                     OUT LPDWORD nSize
                    );
extern PTERMSRVGETCOMPUTERNAME gpTermsrvGetComputerName;

typedef void   (*PTERMSRVADJUSTPHYMEMLIMITS) (
                     IN OUT PULONG_PTR TotalPhys,
                     IN OUT PULONG_PTR AvailPhys,
                     IN DWORD SysPageSize
                    );
extern PTERMSRVADJUSTPHYMEMLIMITS gpTermsrvAdjustPhyMemLimits;

typedef UINT (*PTERMSRVGETWINDOWSDIRECTORYA) (
                    OUT LPSTR lpBuffer,
                    OUT UINT uSize
                    );
extern PTERMSRVGETWINDOWSDIRECTORYA gpTermsrvGetWindowsDirectoryA;

typedef UINT (*PTERMSRVGETWINDOWSDIRECTORYW) (
                    OUT LPWSTR lpBuffer,
                    OUT UINT uSize
                    );

extern PTERMSRVGETWINDOWSDIRECTORYW gpTermsrvGetWindowsDirectoryW;

typedef NTSTATUS (* PTERMSRVCONVERTSYSROOTTOUSERDIR)(
                    OUT PUNICODE_STRING pFQPath,
                    IN PUNICODE_STRING BaseWindowsDirectory
                    );
extern PTERMSRVCONVERTSYSROOTTOUSERDIR gpTermsrvConvertSysRootToUserDir;


typedef NTSTATUS (*PTERMSRVBUILDINIFILENAME)(
    OUT PUNICODE_STRING pFQName,
    IN PUNICODE_STRING pBaseFileName
    );

extern PTERMSRVBUILDINIFILENAME gpTermsrvBuildIniFileName;

typedef VOID (*PTERMSRVCORINIFILE)(
    PUNICODE_STRING pUserFullPath
    );

extern PTERMSRVCORINIFILE gpTermsrvCORIniFile;

typedef BOOL (* PTERMSRVCREATEREGENTRY)(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjAttr,
                       IN ULONG TitleIndex,
                       IN PUNICODE_STRING pUniClass OPTIONAL,
                       IN ULONG ulCreateOpt);

extern PTERMSRVCREATEREGENTRY gpfnTermsrvCreateRegEntry;

typedef BOOL (*PTERMSRVOPENREGENTRY)(OUT PHANDLE pUserhKey,
                     IN ACCESS_MASK DesiredAccess,
                     IN POBJECT_ATTRIBUTES pUserObjectAttr);

extern PTERMSRVOPENREGENTRY gpfnTermsrvOpenRegEntry;

typedef BOOL (*PTERMSRVSETVALUEKEY)(HANDLE hKey,
                    PUNICODE_STRING ValueName,
                    ULONG TitleIndex,
                    ULONG Type,
                    PVOID Data,
                    ULONG DataSize);
extern PTERMSRVSETVALUEKEY gpfnTermsrvSetValueKey;

typedef BOOL (* PTERMSRVDELETEKEY)(HANDLE hKey);

extern PTERMSRVDELETEKEY gpfnTermsrvDeleteKey;

typedef BOOL (*PTERMSRVDELETEVALUE)(HANDLE hKey,
                    PUNICODE_STRING pUniValue);
extern PTERMSRVDELETEVALUE gpfnTermsrvDeleteValue;

typedef BOOL (* PTERMSRVRESTOREKEY)(IN HANDLE hKey,
                   IN HANDLE hFile,
                   IN ULONG Flags);
extern PTERMSRVRESTOREKEY gpfnTermsrvRestoreKey;

typedef BOOL (* PTERMSRVSETKEYSECURITY)(IN HANDLE hKey,  
                       IN SECURITY_INFORMATION SecInfo,
                       IN PSECURITY_DESCRIPTOR pSecDesc);

extern PTERMSRVSETKEYSECURITY gpfnTermsrvSetKeySecurity;

typedef BOOL (* PTERMSRVOPENUSERCLASSES)(IN ACCESS_MASK DesiredAccess, 
                                         OUT PHANDLE pUserhKey);
extern PTERMSRVOPENUSERCLASSES gpfnTermsrvOpenUserClasses;

typedef NTSTATUS ( * PTERMSRVGETPRESETVALUE)(  IN HANDLE hKey,
                                               IN PUNICODE_STRING pValueName,
                                               IN ULONG  Type,
                                               OUT PVOID *Data
                                            );
extern PTERMSRVGETPRESETVALUE gpfnTermsrvGetPreSetValue;

typedef int (*PTERMSRVUPDATEALLUSERMENU)(int RunMode);
extern PTERMSRVUPDATEALLUSERMENU gpTermsrvUpdateAllUserMenu;


typedef ULONG ( *PGETTERMSRCOMPATFLAGS)(LPWSTR, LPDWORD, TERMSRV_COMPATIBILITY_CLASS);
extern PGETTERMSRCOMPATFLAGS gpGetTermsrCompatFlags;

typedef BOOL (*PTERMSRVBUILDSYSINIPATH) (
    PUNICODE_STRING pIniPath,
    PUNICODE_STRING pSysPath,
    PUNICODE_STRING pUserPath
    );

extern PTERMSRVBUILDSYSINIPATH gpTermsrvBuildSysIniPath;

typedef BOOL (* PTERMSRVCOPYINIFILE)(
    PUNICODE_STRING pSysFullPath,
    PUNICODE_STRING pUserBasePath,
    PUNICODE_STRING pUserFullPath
    );
extern PTERMSRVCOPYINIFILE gpTermsrvCopyIniFile;


typedef NTSTATUS (* PTERMSRVGETSTRING)(
                    HANDLE SrcHandle,
                    PCHAR  *ppStringPtr,
                    PULONG pStringSize,
                    PCHAR  pIOBuf,
                    ULONG  IOBufSize,
                    PULONG pIOBufIndex,
                    PULONG pIOBufFillSize
                    );

extern PTERMSRVGETSTRING gpTermsrvGetString;

typedef BOOL (*PTERMSRVLOGINSTALLINIFILE)(PUNICODE_STRING NtFileName);

extern PTERMSRVLOGINSTALLINIFILE gpTermsrvLogInstallIniFile;

// @@END_DDKSPLIT

#ifdef __cplusplus
extern "C" {
#endif
WINBASEAPI
BOOL
WINAPI
TermsrvAppInstallMode( VOID );

WINBASEAPI
BOOL
WINAPI
SetTermsrvAppInstallMode( BOOL bState );
#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\utildll.h ===
/*******************************************************************************
*
* utildll.h
*
* UTILDLL WinStation utility support functions header file (export stuff)
*
*
*******************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

/*
 * UTILDLL defines and typedefs
 */
typedef struct _ELAPSEDTIME {
    USHORT days;
    USHORT hours;
    USHORT minutes;
    USHORT seconds;
} ELAPSEDTIME, * PELAPSEDTIME;

#define MAX_PROCESSNAME                 18
#define UTILDLL_NAME                    TEXT("UTILDLL.DLL")
#define SYSTEM_MESSAGE_MAX              528
#define MAX_ELAPSED_TIME_LENGTH         13
#define MAX_DATE_TIME_LENGTH            56
#define NO_ERROR_TEXT_LENGTH		100
#define STANDARD_ERROR_TEXT_LENGTH	100

/*
 * UTILDLL function prototypes
 */
void WINAPIV StandardErrorMessage( LPCTSTR pszAppName,
                           HWND hwndApp,
                           HINSTANCE hinstApp,
                           ULONG LogonId,
                           UINT nId,
                           int nErrorMessageLength,
                           int nArgumentListLength,
                           int nErrorResourceID, ...);
LPWSTR WINAPI GetSystemMessageW( ULONG LogonId, UINT nId /*, LPWSTR chBuffer, int chBuffSize*/ );
LPSTR WINAPI GetSystemMessageA( ULONG LogonId, UINT nId /*, LPSTR chBuffer, int chBuffSize*/ );
#ifdef UNICODE
#define GetSystemMessage GetSystemMessageW
#else
#define GetSystemMessage GetSystemMessageA
#endif

PPDPARAMS WINAPI WinEnumerateDevices( HWND hWnd,
                                      PPDCONFIG3 pPdConfig,
                                      PULONG pEntries,
                                      BOOL bInSetup );
BOOL WINAPI NetworkDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
BOOL WINAPI QueryCurrentWinStation( PWINSTATIONNAME pWSName, LPTSTR pUserName,
                                    PULONG pLogonId, PULONG pWSFlags );
LONG WINAPI RegGetNetworkDeviceName( HANDLE hServer, PPDCONFIG3 pPdConfig,
                                     PPDPARAMS pPdParams, LPTSTR szDeviceName,
                                     int nDeviceName );
LONG WINAPI RegGetNetworkServiceName( HANDLE hServer,
                                      LPTSTR szServiceKey,
                                      LPTSTR szServiceName,
                                      int nServiceName );
BOOL WINAPI AsyncDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                  PULONG, BOOL );
BOOL WINAPI NetBIOSDeviceEnumerate( PPDCONFIG3, PULONG, PPDPARAMS,
                                    PULONG, BOOL );
void WINAPI FormDecoratedAsyncDeviceName( LPTSTR pDeviceName,
                                          PASYNCCONFIG pAsyncConfig );
void WINAPI ParseDecoratedAsyncDeviceName( LPCTSTR pDeviceName,
                                           PASYNCCONFIG pAsyncConfig );
void WINAPI SetupAsyncCdConfig( PASYNCCONFIG pAsyncConfig,
                                PCDCONFIG pCdConfig );
BOOL WINAPI InstallModem( HWND hwndOwner );
BOOL WINAPI ConfigureModem( LPCTSTR pModemName, HWND hwndOwner );
BOOL GetAssociatedPortName(char  *szKeyName, WCHAR *wszPortName);
void WINAPI InitializeAnonymousUserCompareList( const WCHAR *pszServer );
BOOL WINAPI HaveAnonymousUsersChanged();
void WINAPI GetUserFromSid( PSID pSid, LPTSTR pUserName, DWORD cbUserName );
void WINAPI CachedGetUserFromSid( PSID pSid, PWCHAR pUserName, PULONG cbUserName );
BOOL WINAPI TestUserForAdmin( BOOL dom );
BOOL WINAPI IsPartOfDomain( VOID );
LPCTSTR WINAPI StrSdClass( SDCLASS SdClass );
LPCTSTR WINAPI StrConnectState( WINSTATIONSTATECLASS ConnectState,
                                BOOL bShortString );
LPCTSTR WINAPI StrProcessState( ULONG State );
LPCTSTR WINAPI StrSystemWaitReason( ULONG WaitReason );
LPCTSTR WINAPI GetUnknownString();
void WINAPI CalculateElapsedTime( LARGE_INTEGER *pTime,
                                  ELAPSEDTIME *pElapsedTime );
int WINAPI CompareElapsedTime( ELAPSEDTIME *pElapsedTime1,
                               ELAPSEDTIME *pElapsedTime2,
                               BOOL bCompareSeconds );
void WINAPI ElapsedTimeString( ELAPSEDTIME *pElapsedTime,
                               BOOL bIncludeSeconds,
                               LPTSTR pString );
void WINAPI DateTimeString( LARGE_INTEGER *pTime, LPTSTR pString );
void WINAPI CurrentDateTimeString( LPTSTR pString );
LARGE_INTEGER WINAPI CalculateDiffTime( LARGE_INTEGER, LARGE_INTEGER );
LPWSTR WINAPI EnumerateMultiUserServers( LPWSTR pDomain );

BOOL CtxGetAnyDCName( PWCHAR pServer, PWCHAR pDomain, PWCHAR pBuffer );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\verall.h ===
/***************************************************************************
*
*  VERALL.H
*
*  Include this header file for proper resource version where the component
*  consists of all TerminalServer code.  See ctxver.h for details.
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#define VER_CTXCONTENT      1
//#define VER_CTXALLCONTENT   1
#define VER_CTXSOMECONTENT  1

#include <ctxver.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\tsperf.h ===
/***************************************************************************
*
* TSPERF.H
*
* Defines performance flags sent up from the client that are used to control
* which server features (typically shell) are disabled to enhance performance
* for slow links
*
* Copyright Microsoft Corporation, 2000
*
****************************************************************************/

#ifndef _INC_TSPERFH
#define _INC_TSPERFH

#ifdef __cplusplus
extern "C" {
#endif

//
// Protocol independent codes must fit in a DWORD for the termsrv
// RPC interface
//

//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// NOTE (only applies to RDP): If you make a change here update mstsax.idl's
//                             enum values to reflect these.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

//
// Define the disable feature codes
//
#define TS_PERF_DISABLE_NOTHING                              0x00000000
#define TS_PERF_DISABLE_WALLPAPER                            0x00000001
#define TS_PERF_DISABLE_FULLWINDOWDRAG                       0x00000002
#define TS_PERF_DISABLE_MENUANIMATIONS                       0x00000004
#define TS_PERF_DISABLE_THEMING                              0x00000008
#define TS_PERF_ENABLE_ENHANCED_GRAPHICS                     0x00000010
#define TS_PERF_DISABLE_CURSOR_SHADOW                        0x00000020
#define TS_PERF_DISABLE_CURSORSETTINGS			     0x00000040
//
// The high order bit is reserved (the client uses it internally)
//
#define TS_PERF_RESERVED1                                    0x80000000

#define TS_GDIPLUS_NOTIFYMSG_STR                             TEXT("TS_GDIPLUS_NOTIFYMSG")
#ifdef __cplusplus
}
#endif


#endif  /* !_INC_TSPERFH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\versome.h ===
/***************************************************************************
*
*  VERSOME.H
*
*  Include this header file for proper resource version where some Citrix
*  code has been added to an existing NT component.  See ctxver.h for details.
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#define VER_CTXCONTENT      1
#define VER_CTXSOMECONTENT  1

#include <ctxver.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\winstaw.h ===
/***************************************************************************
*
*  WINSTAW.H   (UNICODE version)
*
*  This module contains external window station defines and structures
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#ifndef UNICODE
#define _WINSTAW
#define UNICODE
#endif

#include <winsta.h>

#ifdef _WINSTAW
#undef UNICODE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\winddits.h ===
/*++

Copyright (c) 1985-1995, Microsoft Corporation

Module Name:

    winddits.h

Abstract:

    Private entry points, defines and types for Windows NT GDI device
    driver interfaces for terminal server.

--*/

#ifndef _WINDDITS_
#define _WINDDITS_

/*
 *  Mouse position
 *
 *  Normal == Primary stack i.e moves sent up from the client
 *  Procedural == Programmatic moves that originate at the server side
 *  Shadow == Moves that orginate at the shadow client
 */

#define MP_NORMAL                               0x00
#define MP_PROCEDURAL                           0x01 
#define MP_TERMSRV_SHADOW                       0x02


#define INDEX_DrvConnect                        INDEX_DrvReserved1
#define INDEX_DrvDisconnect                     INDEX_DrvReserved2
#define INDEX_DrvReconnect                      INDEX_DrvReserved3
#define INDEX_DrvShadowConnect                  INDEX_DrvReserved4
#define INDEX_DrvShadowDisconnect               INDEX_DrvReserved5
#define INDEX_DrvInvalidateRect                 INDEX_DrvReserved6
#define INDEX_DrvSetPointerPos                  INDEX_DrvReserved7
#define INDEX_DrvDisplayIOCtl                   INDEX_DrvReserved8

#define INDEX_DrvMovePointerEx                  INDEX_DrvReserved11

#ifdef __cplusplus
extern "C" {
#endif

BOOL APIENTRY DrvConnect(HANDLE, PVOID, PVOID, PVOID);

BOOL APIENTRY DrvDisconnect(HANDLE, PVOID);

BOOL APIENTRY DrvReconnect(HANDLE, PVOID);

BOOL APIENTRY DrvShadowConnect(PVOID pClientThinwireData, 
                               ULONG ThinwireDataLength);

BOOL APIENTRY DrvShadowDisconnect(PVOID pClientThinwireData, 
                                  ULONG ThinwireDataLength);
                                  
BOOL APIENTRY DrvMovePointerEx(SURFOBJ*, LONG, LONG, ULONG);

DWORD APIENTRY EngGetTickCount();

VOID APIENTRY EngFileWrite(
    HANDLE hFileObject,
    PVOID Buffer,
    ULONG Length,
    PULONG pActualLength
    );

DWORD APIENTRY EngFileIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned
    );

PVOID APIENTRY EngAllocSectionMem(
    PVOID   *pSectionObject,
    ULONG   fl,
    ULONG   cj,
    ULONG   tag
    );
    
VOID APIENTRY EngFreeSectionMem(
    PVOID SectionObject,
    PVOID pv    
    );     
    
BOOL APIENTRY EngMapSection(
    PVOID SectionObject,
    BOOL bMap,
    HANDLE ProcessHandle,
    PVOID *pMapBase
    );         


#ifdef __cplusplus
}
#endif

#endif //  _WINDDITS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\wfregupg.h ===
/*************************************************************************
*
* wfregupg.h
*
* Includes for Terminal Server registry keys - used by Hydra to upgrade
* existing WinFrame installations to Hydra
*
* copyright notice: Copyright 1998, Microsoft
*
*
*************************************************************************/

#ifndef __WFREGUPG__
#define __WFREGUPG_H__

// @@BEGIN_DDKSPLIT

#include <regapi.h>

/*
 * partial key strings used to build larger key strings
 */
#define  REG_CITRIX                         L"Citrix"
#define  REG_CITRIX_A                       "Citrix"

/*
 *  CONTROL defines
 */
#define  REG_CONTROL_CITRIX                     REG_CONTROL L"\\" REG_CITRIX
#define  REG_CONTROL_CITRIX_A               REG_CONTROL_A "\\" REG_CITRIX_A
#define  USERCONFIG_REG_NAME_CITRIX         REG_CONTROL_CITRIX L"\\" REG_USERCONFIG L"\\"
#define  DEFCONFIG_REG_NAME_CITRIX          REG_CONTROL_CITRIX L"\\" REG_DEFAULTUSERCONFIG
#define  AUTHORIZEDAPPS_REG_NAME_CITRIX     REG_CONTROL_CITRIX L"\\" REG_AUTHORIZEDAPPLICATIONS
#define  DOS_REG_NAME_CITRIX                REG_CONTROL_CITRIX L"\\" REG_DOS

/*
 * SOFTWARE defines
 */

// @@END_DDKSPLIT
#define  REG_SOFTWARE_CITRIX                L"Software\\Citrix"
// @@BEGIN_DDKSPLIT

#define  REG_SOFTWARE_CITRIX_A              "Software\\Citrix"
#define  CHANGEUSER_OPTION_REG_NAME_CITRIX  REG_SOFTWARE_CITRIX L"\\" REG_INSTALL L"\\" REG_CHANGEUSER_OPTION
#define  COMPAT_REG_NAME_CITRIX             REG_SOFTWARE_CITRIX L"\\" REG_COMPATIBILITY
#define  INSTALL_REG_NAME_CITRIX            REG_SOFTWARE_CITRIX L"\\" REG_INSTALL
#define  SECURITY_REG_NAME_CITRIX           REG_SOFTWARE_CITRIX L"\\" REG_SECURITY
#define  WINDOWS_REG_NAME_CITRIX            REG_SOFTWARE_CITRIX L"\\" REG_WINDOWS

/*
 * REG_CONTROL_CITRIX values
 */
#define REG_CITRIX_HYDRAUPGRADEDWINFRAME    L"HydraUpgradedWinFrame"

// @@END_DDKSPLIT

#endif //__WFREGUPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\aclapip.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993-1999, Microsoft Corporation

Module Name:

    aclapip.h

Abstract:

    Private
    Structure/constant definitions and typedefines for the Win32 Access
    Control APIs

--*/
#ifndef __ACCESS_CONTROL_API_P__
#define __ACCESS_CONTROL_API_P__

#ifdef __cplusplus
extern "C" {
#endif
#if(_WIN32_WINNT >= 0x0500)

WINADVAPI
DWORD
WINAPI
GetNamedSecurityInfoExA(
    IN   LPCSTR                lpObject,
    IN   SE_OBJECT_TYPE          ObjectType,
    IN   SECURITY_INFORMATION    SecurityInfo,
    IN   LPCSTR                lpProvider,
    IN   LPCSTR                lpProperty,
    OUT  PACTRL_ACCESSA         *ppAccessList,
    OUT  PACTRL_AUDITA          *ppAuditList,
    OUT  LPSTR                *lppOwner,
    OUT  LPSTR                *lppGroup
    );
WINADVAPI
DWORD
WINAPI
GetNamedSecurityInfoExW(
    IN   LPCWSTR                lpObject,
    IN   SE_OBJECT_TYPE          ObjectType,
    IN   SECURITY_INFORMATION    SecurityInfo,
    IN   LPCWSTR                lpProvider,
    IN   LPCWSTR                lpProperty,
    OUT  PACTRL_ACCESSW         *ppAccessList,
    OUT  PACTRL_AUDITW          *ppAuditList,
    OUT  LPWSTR                *lppOwner,
    OUT  LPWSTR                *lppGroup
    );
#ifdef UNICODE
#define GetNamedSecurityInfoEx  GetNamedSecurityInfoExW
#else
#define GetNamedSecurityInfoEx  GetNamedSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
SetNamedSecurityInfoExA(
    IN    LPCSTR               lpObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCSTR               lpProvider,
    IN    PACTRL_ACCESSA         pAccessList,
    IN    PACTRL_AUDITA          pAuditList,
    IN    LPSTR                lpOwner,
    IN    LPSTR                lpGroup,
    IN    PACTRL_OVERLAPPED      pOverlapped
    );
WINADVAPI
DWORD
WINAPI
SetNamedSecurityInfoExW(
    IN    LPCWSTR               lpObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCWSTR               lpProvider,
    IN    PACTRL_ACCESSW         pAccessList,
    IN    PACTRL_AUDITW          pAuditList,
    IN    LPWSTR                lpOwner,
    IN    LPWSTR                lpGroup,
    IN    PACTRL_OVERLAPPED      pOverlapped
    );
#ifdef UNICODE
#define SetNamedSecurityInfoEx  SetNamedSecurityInfoExW
#else
#define SetNamedSecurityInfoEx  SetNamedSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
GetSecurityInfoExA(
    IN    HANDLE                  hObject,
    IN    SE_OBJECT_TYPE          ObjectType,
    IN    SECURITY_INFORMATION    SecurityInfo,
    IN    LPCSTR                lpProvider,
    IN    LPCSTR                lpProperty,
    OUT   PACTRL_ACCESSA         *ppAccessList,
    OUT   PACTRL_AUDITA          *ppAuditList,
    OUT   LPSTR                *lppOwner,
    OUT   LPSTR                *lppGroup
    );
WINADVAPI
DWORD
WINAPI
GetSecurityInfoExW(
    IN    HANDLE                  hObject,
    IN    SE_OBJECT_TYPE          ObjectType,
    IN    SECURITY_INFORMATION    SecurityInfo,
    IN    LPCWSTR                lpProvider,
    IN    LPCWSTR                lpProperty,
    OUT   PACTRL_ACCESSW         *ppAccessList,
    OUT   PACTRL_AUDITW          *ppAuditList,
    OUT   LPWSTR                *lppOwner,
    OUT   LPWSTR                *lppGroup
    );
#ifdef UNICODE
#define GetSecurityInfoEx  GetSecurityInfoExW
#else
#define GetSecurityInfoEx  GetSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
SetSecurityInfoExA(
    IN    HANDLE                 hObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCSTR               lpProvider,
    IN    PACTRL_ACCESSA         pAccessList,
    IN    PACTRL_AUDITA          pAuditList,
    IN    LPSTR                lpOwner,
    IN    LPSTR                lpGroup,
    OUT   PACTRL_OVERLAPPED      pOverlapped
    );
WINADVAPI
DWORD
WINAPI
SetSecurityInfoExW(
    IN    HANDLE                 hObject,
    IN    SE_OBJECT_TYPE         ObjectType,
    IN    SECURITY_INFORMATION   SecurityInfo,
    IN    LPCWSTR               lpProvider,
    IN    PACTRL_ACCESSW         pAccessList,
    IN    PACTRL_AUDITW          pAuditList,
    IN    LPWSTR                lpOwner,
    IN    LPWSTR                lpGroup,
    OUT   PACTRL_OVERLAPPED      pOverlapped
    );
#ifdef UNICODE
#define SetSecurityInfoEx  SetSecurityInfoExW
#else
#define SetSecurityInfoEx  SetSecurityInfoExA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
ConvertAccessToSecurityDescriptorA(
    IN  PACTRL_ACCESSA        pAccessList,
    IN  PACTRL_AUDITA         pAuditList,
    IN  LPCSTR              lpOwner,
    IN  LPCSTR              lpGroup,
    OUT PSECURITY_DESCRIPTOR *ppSecDescriptor
    );
WINADVAPI
DWORD
WINAPI
ConvertAccessToSecurityDescriptorW(
    IN  PACTRL_ACCESSW        pAccessList,
    IN  PACTRL_AUDITW         pAuditList,
    IN  LPCWSTR              lpOwner,
    IN  LPCWSTR              lpGroup,
    OUT PSECURITY_DESCRIPTOR *ppSecDescriptor
    );
#ifdef UNICODE
#define ConvertAccessToSecurityDescriptor  ConvertAccessToSecurityDescriptorW
#else
#define ConvertAccessToSecurityDescriptor  ConvertAccessToSecurityDescriptorA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessA(
    IN  HANDLE               hObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSA      *ppAccessList,
    OUT PACTRL_AUDITA       *ppAuditList,
    OUT LPSTR             *lppOwner,
    OUT LPSTR             *lppGroup
    );
WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessW(
    IN  HANDLE               hObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSW      *ppAccessList,
    OUT PACTRL_AUDITW       *ppAuditList,
    OUT LPWSTR             *lppOwner,
    OUT LPWSTR             *lppGroup
    );
#ifdef UNICODE
#define ConvertSecurityDescriptorToAccess  ConvertSecurityDescriptorToAccessW
#else
#define ConvertSecurityDescriptorToAccess  ConvertSecurityDescriptorToAccessA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedA(
    IN  LPCSTR             lpObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSA      *ppAccessList,
    OUT PACTRL_AUDITA       *ppAuditList,
    OUT LPSTR             *lppOwner,
    OUT LPSTR             *lppGroup
    );
WINADVAPI
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedW(
    IN  LPCWSTR             lpObject,
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  PSECURITY_DESCRIPTOR pSecDescriptor,
    OUT PACTRL_ACCESSW      *ppAccessList,
    OUT PACTRL_AUDITW       *ppAuditList,
    OUT LPWSTR             *lppOwner,
    OUT LPWSTR             *lppGroup
    );
#ifdef UNICODE
#define ConvertSecurityDescriptorToAccessNamed  ConvertSecurityDescriptorToAccessNamedW
#else
#define ConvertSecurityDescriptorToAccessNamed  ConvertSecurityDescriptorToAccessNamedA
#endif // !UNICODE


WINADVAPI
DWORD
WINAPI
SetEntriesInAccessListA(
    IN  ULONG                cEntries,
    IN  PACTRL_ACCESS_ENTRYA pAccessEntryList,
    IN  ACCESS_MODE          AccessMode,
    IN  LPCSTR             lpProperty,
    IN  PACTRL_ACCESSA       pOldList,
    OUT PACTRL_ACCESSA      *ppNewList
    );
WINADVAPI
DWORD
WINAPI
SetEntriesInAccessListW(
    IN  ULONG                cEntries,
    IN  PACTRL_ACCESS_ENTRYW pAccessEntryList,
    IN  ACCESS_MODE          AccessMode,
    IN  LPCWSTR             lpProperty,
    IN  PACTRL_ACCESSW       pOldList,
    OUT PACTRL_ACCESSW      *ppNewList
    );
#ifdef UNICODE
#define SetEntriesInAccessList  SetEntriesInAccessListW
#else
#define SetEntriesInAccessList  SetEntriesInAccessListA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
SetEntriesInAuditListA(
    IN  ULONG                 cEntries,
    IN  PACTRL_ACCESS_ENTRYA  pAccessEntryList,
    IN  ACCESS_MODE           AccessMode,
    IN  LPCSTR              lpProperty,
    IN  PACTRL_AUDITA         pOldList,
    OUT PACTRL_AUDITA        *ppNewList
    );
WINADVAPI
DWORD
WINAPI
SetEntriesInAuditListW(
    IN  ULONG                 cEntries,
    IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
    IN  ACCESS_MODE           AccessMode,
    IN  LPCWSTR              lpProperty,
    IN  PACTRL_AUDITW         pOldList,
    OUT PACTRL_AUDITW        *ppNewList
    );
#ifdef UNICODE
#define SetEntriesInAuditList  SetEntriesInAuditListW
#else
#define SetEntriesInAuditList  SetEntriesInAuditListA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
TrusteeAccessToObjectA(
    IN        LPCSTR           lpObject,
    IN        SE_OBJECT_TYPE     ObjectType,
    IN        LPCSTR           lpProvider,
    IN        PTRUSTEE_A         pTrustee,
    IN        ULONG              cEntries,
    IN OUT    PTRUSTEE_ACCESSA   pTrusteeAccess
    );
WINADVAPI
DWORD
WINAPI
TrusteeAccessToObjectW(
    IN        LPCWSTR           lpObject,
    IN        SE_OBJECT_TYPE     ObjectType,
    IN        LPCWSTR           lpProvider,
    IN        PTRUSTEE_W         pTrustee,
    IN        ULONG              cEntries,
    IN OUT    PTRUSTEE_ACCESSW   pTrusteeAccess
    );
#ifdef UNICODE
#define TrusteeAccessToObject  TrusteeAccessToObjectW
#else
#define TrusteeAccessToObject  TrusteeAccessToObjectA
#endif // !UNICODE

WINADVAPI
DWORD
WINAPI
GetOverlappedAccessResults(
    IN  PACTRL_OVERLAPPED   pOverlapped,
    IN  BOOL                fWaitForCompletion,
    OUT PDWORD              pResult,
    OUT PULONG              pcItemsProcessed OPTIONAL
    );

WINADVAPI
DWORD
WINAPI
CancelOverlappedAccess(
    IN  PACTRL_OVERLAPPED   pOverlapped
    );

WINADVAPI
DWORD
WINAPI
GetAccessPermissionsForObjectA(
    IN   LPCSTR             lpObject,
    IN   SE_OBJECT_TYPE       ObjectType,
    IN   LPCSTR             lpObjType,
    IN   LPCSTR             lpProvider,
    OUT  PULONG               pcEntries,
    OUT  PACTRL_ACCESS_INFOA *ppAccessInfoList,
    OUT  PULONG               pcRights,
    OUT  PACTRL_CONTROL_INFOA *ppRightsList,
    OUT  PULONG               pfAccessFlags
    );
WINADVAPI
DWORD
WINAPI
GetAccessPermissionsForObjectW(
    IN   LPCWSTR             lpObject,
    IN   SE_OBJECT_TYPE       ObjectType,
    IN   LPCWSTR             lpObjType,
    IN   LPCWSTR             lpProvider,
    OUT  PULONG               pcEntries,
    OUT  PACTRL_ACCESS_INFOW *ppAccessInfoList,
    OUT  PULONG               pcRights,
    OUT  PACTRL_CONTROL_INFOW *ppRightsList,
    OUT  PULONG               pfAccessFlags
    );
#ifdef UNICODE
#define GetAccessPermissionsForObject  GetAccessPermissionsForObjectW
#else
#define GetAccessPermissionsForObject  GetAccessPermissionsForObjectA
#endif // !UNICODE

#endif /* _WIN32_WINNT >=  0x0500 */

#ifdef __cplusplus
}
#endif
#endif  // endif __ACCESS_CONTROL_API_P__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\winsta.h ===
/***************************************************************************
*
*  WINSTA.H
*
*  This module contains external window station defines and structures
*
*  Copyright Microsoft Corporation, 1998
*
*
****************************************************************************/

#ifndef _INC_WINSTAH
#define _INC_WINSTAH

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WINAPI
#define WINAPI      __stdcall
#endif

#ifndef BYTE
#define BYTE unsigned char
#endif


#include <hydrix.h>
#include <ctxdef.h>


/***********
 *  Defines
 ***********/

#define PROTOCOL_DISCONNECT      0xffff // disconnected session.
#define PROTOCOL_CONSOLE         0    // local console 
#define PROTOCOL_ICA             1    // ICA Protocol
#define PROTOCOL_TSHARE          2    // RDP Protocol (old name T.Share)
#define PROTOCOL_RDP             2    // RDP protocol

#define PDNAME_LENGTH            32
#define WDNAME_LENGTH            32
#define CDNAME_LENGTH            32
#define DEVICENAME_LENGTH        128
#define MODEMNAME_LENGTH         DEVICENAME_LENGTH
#define CALLBACK_LENGTH          50
#define LICENSE_PASSWORD_LENGTH  16
#define DLLNAME_LENGTH           32
#define PRINTERNAME_LENGTH       32
#define WINSTATIONCOMMENT_LENGTH 60
#define APPSERVERNAME_LENGTH     17
#define WDPREFIX_LENGTH          12
#define CLIENT_PRODUCT_ID_LENGTH 32

#define NASISPECIFICNAME_LENGTH    14
#define NASIUSERNAME_LENGTH        47
#define NASIPASSWORD_LENGTH        24
#define NASISESSIONNAME_LENGTH     16
#define NASIFILESERVER_LENGTH      47

#define LOGONID_CURRENT     ((ULONG)-1)
#define LOGONID_NONE        ((ULONG)-2)
#define SERVERNAME_CURRENT  ((HANDLE)NULL)

#define MAX_PDCONFIG             10  // maximum number of PDs per WinStation
#define MAX_UI_MODULES           5   // maximum client user interface modules
#define PSZ_ANONYMOUS           TEXT("Anonymous")

#define WINFRAME_SOFTKEY_CLASS L"WinFrameSoftkey"
#define WINFRAME_SOFTKEY_APPLICATION L"wfskey.exe"

#define OEM_ID_LENGTH                        3

// TermSrv Counters
#define TERMSRV_TOTAL_SESSIONS     1     // total number of sessions ever connected
#define TERMSRV_DISC_SESSIONS      2     // total number of disconnected sessions
#define TERMSRV_RECON_SESSIONS     3     // total number of reconnected sessions
#define TERMSRV_CURRENT_ACTIVE_SESSIONS 4   // total of currently active sessions
#define TERMSRV_CURRENT_DISC_SESSIONS   5   // total of currently disconnected sessions
   
// Color depth setting
#define TS_CLIENT_COMPAT_BPP_SUPPORT    0x3e7   // decimal 999
#define TS_24BPP_SUPPORT    0x04
#define TS_16BPP_SUPPORT    0x03
#define TS_15BPP_SUPPORT    0x02
#define TS_8BPP_SUPPORT     0x01


    

/*********************************
 *   WinStationOpen access values
 *********************************/
#define WINSTATION_QUERY        0x00000001  // WinStationQueryInformation()
#define WINSTATION_SET          0x00000002  // WinStationSetInformation()
#define WINSTATION_RESET        0x00000004  // WinStationReset()
#define WINSTATION_VIRTUAL      0x00000008  // read/write direct data
#define WINSTATION_SHADOW       0x00000010  // WinStationShadow()
#define WINSTATION_LOGON        0x00000020  // logon to WinStation
#define WINSTATION_LOGOFF       0x00000040  // WinStationLogoff()
#define WINSTATION_MSG          0x00000080  // WinStationMsg()
#define WINSTATION_CONNECT      0x00000100  // WinStationConnect()
#define WINSTATION_DISCONNECT   0x00000200  // WinStationDisconnect()

#define WINSTATION_GUEST_ACCESS (WINSTATION_LOGON)

#define WINSTATION_CURRENT_GUEST_ACCESS (WINSTATION_VIRTUAL | WINSTATION_LOGOFF)

#define WINSTATION_USER_ACCESS (WINSTATION_GUEST_ACCESS |                      \
                                WINSTATION_QUERY | WINSTATION_MSG |            \
                                WINSTATION_CONNECT )

#define WINSTATION_CURRENT_USER_ACCESS (WINSTATION_SET | WINSTATION_RESET      \
                                        WINSTATION_VIRTUAL | WINSTATION_LOGOFF \
                                        WINSTATION_DISCONNECT)

#define WINSTATION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | WINSTATION_QUERY |   \
                                WINSTATION_SET | WINSTATION_RESET |            \
                                WINSTATION_VIRTUAL |    WINSTATION_SHADOW |    \
                                WINSTATION_LOGON |                             \
                                WINSTATION_MSG |                               \
                                WINSTATION_CONNECT | WINSTATION_DISCONNECT)


/************
 *  Typedefs
 ************/

#define LOGONIDW SESSIONIDW      //externalized LogonID as SessionID in ctxapi.h
#define PLOGONIDW PSESSIONIDW
#define LOGONIDA SESSIONIDA
#define PLOGONIDA PSESSIONIDA
#ifdef UNICODE
#define LOGONID LOGONIDW
#define PLOGONID PLOGONIDW
#else
#define LOGONID LOGONIDA
#define PLOGONID PLOGONIDA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR PDNAMEW[ PDNAME_LENGTH + 1 ];
typedef WCHAR * PPDNAMEW;

typedef CHAR PDNAMEA[ PDNAME_LENGTH + 1 ];
typedef CHAR * PPDNAMEA;

#ifdef UNICODE
#define PDNAME PDNAMEW
#define PPDNAME PPDNAMEW
#else
#define PDNAME PDNAMEA
#define PPDNAME PPDNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR WDNAMEW[ WDNAME_LENGTH + 1 ];
typedef WCHAR * PWDNAMEW;

typedef CHAR WDNAMEA[ WDNAME_LENGTH + 1 ];
typedef CHAR * PWDNAMEA;

#ifdef UNICODE
#define WDNAME WDNAMEW
#define PWDNAME PWDNAMEW
#else
#define WDNAME WDNAMEA
#define PWDNAME PWDNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR CDNAMEW[ CDNAME_LENGTH + 1 ];
typedef WCHAR * PCDNAMEW;

typedef CHAR CDNAMEA[ CDNAME_LENGTH + 1 ];
typedef CHAR * PCDNAMEA;

#ifdef UNICODE
#define CDNAME CDNAMEW
#define PCDNAME PCDNAMEW
#else
#define CDNAME CDNAMEA
#define PCDNAME PCDNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR DEVICENAMEW[ DEVICENAME_LENGTH + 1 ];
typedef WCHAR * PDEVICENAMEW;

typedef CHAR DEVICENAMEA[ DEVICENAME_LENGTH + 1 ];
typedef CHAR * PDEVICENAMEA;

#ifdef UNICODE
#define DEVICENAME DEVICENAMEW
#define PDEVICENAME PDEVICENAMEW
#else
#define DEVICENAME DEVICENAMEA
#define PDEVICENAME PDEVICENAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR MODEMNAMEW[ MODEMNAME_LENGTH + 1 ];
typedef WCHAR * PMODEMNAMEW;

typedef CHAR MODEMNAMEA[ MODEMNAME_LENGTH + 1 ];
typedef CHAR * PMODEMNAMEA;

#ifdef UNICODE
#define MODEMNAME MODEMNAMEW
#define PMODEMNAME PMODEMNAMEW
#else
#define MODEMNAME MODEMNAMEA
#define PMODEMNAME PMODEMNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR DLLNAMEW[ DLLNAME_LENGTH + 1 ];
typedef WCHAR * PDLLNAMEW;

typedef CHAR DLLNAMEA[ DLLNAME_LENGTH + 1 ];
typedef CHAR * PDLLNAMEA;

#ifdef UNICODE
#define DLLNAME DLLNAMEW
#define PDLLNAME PDLLNAMEW
#else
#define DLLNAME DLLNAMEA
#define PDLLNAME PDLLNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR PRINTERNAMEW[ PRINTERNAME_LENGTH + 1 ];
typedef WCHAR * PPRINTERNAMEW;

typedef CHAR PRINTERNAMEA[ PRINTERNAME_LENGTH + 1 ];
typedef CHAR * PPRINTERNAMEA;

#ifdef UNICODE
#define PRINTERNAME PRINTERNAMEW
#define PPRINTERNAME PPRINTERNAMEW
#else
#define PRINTERNAME PRINTERNAMEA
#define PPRINTERNAME PPRINTERNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef WCHAR WDPREFIXW[ WDPREFIX_LENGTH + 1 ];
typedef WCHAR * PWDPREFIXW;

typedef CHAR WDPREFIXA[ WDPREFIX_LENGTH + 1 ];
typedef CHAR * PWDPREFIXA;

#ifdef UNICODE
#define WDPREFIX WDPREFIXW
#define PWDPREFIX PWDPREFIXW
#else
#define WDPREFIX WDPREFIXA
#define PWDPREFIX PWDPREFIXA
#endif /* UNICODE */

/*------------------------------------------------*/

#ifdef UNICODE
#define NASISPECIFICNAME NASISPECIFICNAMEW
#define PNASISPECIFICNAME PNASISPECIFICNAMEW
#define NASIUSERNAME NASIUSERNAMEW
#define PNASIUSERNAME PNASIUSERNAMEW
#define NASIPASSWORD NASIPASSWORDW
#define PNASIPASSWORD PNASIPASSWORDW
#define NASISESSIONNAME NASISESSIONNAMEW
#define PNASISESSIONNAME PNASISESSIONNAMEW
#define NASIFILESERVER NASIFILESERVERW
#define PNASIFILESERVER PNASIFILESERVERW
#else
#define NASISPECIFICNAME NASISPECIFICNAMEA
#define PNASISPECIFICNAME PNASISPECIFICNAMEA
#define NASIUSERNAME NASIUSERNAMEA
#define PNASIUSERNAME PNASIUSERNAMEA
#define NASIPASSWORD NASIPASSWORDA
#define PNASIPASSWORD PNASIPASSWORDA
#define NASISESSIONNAME NASISESSIONNAMEA
#define PNASISESSIONNAME PNASISESSIONNAMEA
#define NASIFILESERVER NASIFILESERVERA
#define PNASIFILESERVER PNASIFILESERVERA
#endif /* UNICODE */

typedef WCHAR   NASISPECIFICNAMEW[ NASISPECIFICNAME_LENGTH + 1 ];
typedef WCHAR   NASIUSERNAMEW[ NASIUSERNAME_LENGTH + 1 ];
typedef WCHAR   NASIPASSWORDW[ NASIPASSWORD_LENGTH + 1 ];
typedef WCHAR   NASISESIONNAMEW[ NASISESSIONNAME_LENGTH + 1 ];
typedef WCHAR   NASIFILESERVERW[ NASIFILESERVER_LENGTH + 1 ];

typedef CHAR    NASISPECIFICNAMEA[ NASISPECIFICNAME_LENGTH + 1 ];
typedef CHAR    NASIUSERNAMEA[ NASIUSERNAME_LENGTH + 1 ];
typedef CHAR    NASIPASSWORDA[ NASIPASSWORD_LENGTH + 1 ];
typedef CHAR    NASISESIONNAMEA[ NASISESSIONNAME_LENGTH + 1 ];
typedef CHAR    NASIFILESERVERA[ NASIFILESERVER_LENGTH + 1 ];

/*------------------------------------------------*/

#define STACK_ADDRESS_LENGTH 128

/*
 *  Stack address structure
 */
typedef struct _ICA_STACK_ADDRESS {
    BYTE Address[ STACK_ADDRESS_LENGTH ];   // bytes 0,1 family, 2-n address
} ICA_STACK_ADDRESS, *PICA_STACK_ADDRESS;

// Support for long Username, Password and Domain during autologon
#define EXTENDED_USERNAME_LEN 255
#define EXTENDED_PASSWORD_LEN 255
#define EXTENDED_DOMAIN_LEN 255

/*
 * Structure to hold the longer UserName and Password
 */
typedef struct _ExtendedClientCredentials { 
    WCHAR UserName[EXTENDED_USERNAME_LEN + 1];
    WCHAR Password[EXTENDED_PASSWORD_LEN + 1];
    WCHAR Domain[EXTENDED_DOMAIN_LEN + 1] ; 
}ExtendedClientCredentials, *pExtendedClientCredentials; 

// Type of info queried from TermSrv to RdpWsx via WlxEscape
// add more to this INFO_TYPE as need arises later on
typedef enum
{
   GET_LONG_USERNAME,
   GET_CLIENT_RANDOM,
   GET_CS_AUTORECONNECT_INFO,  //arc verifier
   GET_SC_AUTORECONNECT_INFO,  //arc random
} INFO_TYPE ; 

/*********************************
 *  User Configuration structures
 *********************************/

/*------------------------------------------------*/

typedef WCHAR APPLICATIONNAMEW[ MAX_BR_NAME ];
typedef WCHAR *PAPPLICATIONNAMEW;

typedef CHAR APPLICATIONNAMEA[ MAX_BR_NAME ];
typedef CHAR *PAPPLICATIONNAMEA;

#ifdef UNICODE
#define APPLICATIONNAME APPLICATIONNAMEW
#define PAPPLICATIONNAME PAPPLICATIONNAMEW
#else
#define APPLICATIONNAME APPLICATIONNAMEA
#define PAPPLICATIONNAME PAPPLICATIONNAMEA
#endif /* UNICODE */

/*------------------------------------------------*/

/*
 *  Shadow options
 */
typedef enum _SHADOWCLASS {
    Shadow_Disable,
    Shadow_EnableInputNotify,
    Shadow_EnableInputNoNotify,
    Shadow_EnableNoInputNotify,
    Shadow_EnableNoInputNoNotify,
} SHADOWCLASS;

/*------------------------------------------------*/

/*
 *  Callback options
 */
typedef enum _CALLBACKCLASS {
    Callback_Disable,
    Callback_Roving,
    Callback_Fixed,
} CALLBACKCLASS;

/*------------------------------------------------*/

//
// These are flags that if set, then data from the policy tree is avalible.
// If flag is not set, then there was no corresponding data item from the policy tree.
//
// At this time, the actual data is stored in a copy of userconfigw used as a scrath pad
// for the values found under group policy. The debate of what belongs to group policy has not
// been fully settled, and once that is resolved, I will probably move the data into this struct too.
// AraBern, March 29, 2000 (2 days away from code complete !)
//
//
typedef struct _POLICY_TS_USER {

    // ------------------------------------------------------------------------------
    // Some notes, March 11, 2000
    //
    //
    // fInheritAutoLogon 
    // fPromptForPassword 
    // UserName 
    // Domain
    // Password
    //      Used in WsxInitializeClientData()
    //      of \\index1\src\newnt\termsrv\rdpwsx\rdpex\tsrvwsx.c
    //      This is NOT exposed thru Group Policy
    
    // fInheritAutoClient
    //      There are 3 items which are individually being set thru Group Policy
    
    // fDisableEncryption 
    // MinEncryptionLevel;
    //      The policy for these is set thru fPolicyInheritSecurity, but no UI for these...
    
    // fWorkDirectory
    // fInitialProgram
    //       fPolicyInheritInitialProgram 
    //       will take care of these:
   
    // These seem to be used without being overriden by machine wide data
    // KeyboardLayout
   
    // fMaximize
    // fHideTitleBar 
    //      used in
    //      \\index1\src\newnt\termsrv\rdpwsx\rdpex\tsrvwsx.c 
    
   
    // These seem to be used by RDP, but are not overriden by any
    // Potentially stale WTS API stuff:
    // PublishedName
    //      used by WTSQuerySessionInformationW(), in response to
    //      request of WTSApplicationName. It's not used elsewhere!
    
     
    // These are set and retrieved, but play no meaningful roles.
    // fUseDefaultGina
    // fRequireEncryption
    
    // These are probably meaningless
    // fHomeDirectoryMapRoot
    // NWLogonServer
    //    \\index1\src\newnt\termsrv\tsuserex\tsusrsht.cpp
    //    and NETWARE ifdef'd in \\index1\src\newnt\termsrv\wtsapi\config.c
    
    
    // These are not used AT ALL, are only present in .w or .h files
    // fPublishedApp
    
      
    //
    //     ULONG   fPolicyDisableCpm : 1;                      // Printer, exposed thru TSCC
    //                                                         // Equivalent to ClientLptDef
    //
    //     ULONG   fPolicyDisableCdm : 1;                      // Drive, exposed thru TSCC
    //                                                         // Equivalent to ClientDrives.
    //
    //     ULONG   fPolicyDisableLPT : 1;                      // LPTPort, exposed thru TSCC
    //                                                         // Equivalent to ClientLPT
    //
    //     Protocol wide in NT2195 for Ccm, Clip, and Cam
    //     Make these machine policy
    //     ULONG   fPolicyDisableCcm : 1;                      // ComPort, exposed thru TSCC
    //
    //     ULONG   fPolicyDisableClip: 1;                      // Clipboad, exposed thru TSCC
    //
    //     ULONG   fPolicyDisableCam : 1;                      // Audio, exposed thru TSCC
    //
    //     OLD.....................................
    //     ULONG   fPolicyDisableExe : 1;                      //         not exposed thru TSCC, OLD tsCFG had it
    //     ........................................
    
    ULONG fPolicyResetBroken : 1 ;               
    ULONG fPolicyReconnectSame : 1 ;            
    ULONG fPolicyInitialProgram : 1 ;           
    
   
    ULONG fPolicyCallback : 1 ;                 
    ULONG fPolicyCallbackNumber : 1 ;            
    
    ULONG fPolicyShadow : 1 ;                    
    ULONG fPolicyMaxSessionTime : 1 ;            
    ULONG fPolicyMaxDisconnectionTime:1;         
    ULONG fPolicyMaxIdleTime : 1 ;               

    ULONG fPolicyAutoClientDrives : 1 ;          
    ULONG fPolicyAutoClientLpts : 1 ;           
    ULONG fPolicyForceClientLptDef : 1 ;       
    

} POLICY_TS_USER, * PPOLICY_TS_USER;

//
// 
// The USERCONFIGW struct contained both machine and user config data. We have split the
// data into two kinds of policies, a user policy and a machine policy.
//
// The below struct is the machine policy, which includes both a flag to indicate the policy is 
// present, and a value for that policy. 
// 
// 
// And finally, why am I not using arays? Well I should have, but, originally, the design was
// to user winstation->Config->User->User as the central repository for all data, which meant that all
// I needed here were policy-present bits, not the policy data. However, the Product "feature" has 
// gone thru 3 mutations, and when it finally got to this point, I had very little time to make
// any changes.
//
// I will consider to create a class that encapsulates all policy related bits.
// AraBern, March 29, 2000 (2 days away from code complete !
//
typedef struct _POLICY_TS_MACHINE
{
   
    ULONG   fPolicyDisableClip : 1 ;           
    ULONG   fPolicyDisableCam : 1 ;                          
    ULONG   fPolicyDisableCcm : 1 ;
    ULONG   fPolicyDisableLPT : 1;
    ULONG   fPolicyDisableCpm : 1;
    ULONG   fPolicyPromptForPassword : 1 ;
    ULONG   fPolicyMaxInstanceCount : 1;
    ULONG   fPolicyMinEncryptionLevel : 1 ;
    ULONG   fPolicyDisableAutoReconnect : 1;
    
     
    // These are new and used as machine-wide, so in a sense they are machine config data 
    //       especially that USERCONFIGW has entries for these     
    ULONG   fPolicyWFProfilePath: 1 ;
    ULONG   fPolicyWFHomeDir: 1 ;
    ULONG   fPolicyWFHomeDirDrive: 1 ;
    
    // this is new, and is present in here for the sake of consistancey. However, there is a special
    // func that is used by th's main connection loop to just look for this single item, in order
    // to save time.
    ULONG   fPolicyDenyTSConnections      : 1;              // if set, TS is basically OFF in the sense that nobody can connect.
    
    // these are not part of TS machine config data struct, but winlogn does use these and treats
    // them as per machine type of a policy
    ULONG   fPolicyTempFoldersPerSession  : 1;        // Use tmp folder per each session, instead of one common tmp folder
    ULONG   fPolicyDeleteTempFoldersOnExit: 1;       // on exit, do a cleanup of tmp folders
    
    ULONG   fPolicyColorDepth  : 1;

    ULONG   fPolicySessionDirectoryActive  : 1;
    ULONG   fPolicySessionDirectoryLocation  : 1;
    ULONG   fPolicySessionDirectoryClusterName  : 1;
    ULONG   fPolicySessionDirectoryAdditionalParams  : 1;
    ULONG   fPolicySessionDirectoryExposeServerIP  : 1;

    ULONG   fPolicyPreventLicenseUpgrade  : 1;
    
    ULONG   fPolicyWritableTSCCPermissionsTAB : 1;
    
    ULONG   fPolicyDisableCdm : 1;
    ULONG   fPolicyForceClientLptDef : 1;
    ULONG   fPolicyShadow : 1 ;                    
    ULONG   fPolicyResetBroken : 1 ;               
    ULONG   fPolicyReconnectSame : 1 ;            
    ULONG   fPolicyMaxSessionTime : 1 ;            
    ULONG   fPolicyMaxDisconnectionTime:1;         
    ULONG   fPolicyMaxIdleTime : 1 ;               
    ULONG   fPolicyInitialProgram : 1 ;           
    ULONG   fPolicySingleSessionPerUser : 1;
    ULONG   fPolicyDisableWallpaper : 1;
    ULONG   fPolicyKeepAlive   : 1;

    
    //
    // And now the data if policy is set. Not all items get data, some are just flags.
    //
    // Bit-fields first.
    //
    //
    
    ULONG   fDisableClip : 1 ;           
    ULONG   fDisableCam : 1 ;                          
    ULONG   fDisableCcm : 1 ;
    ULONG   fDisableLPT : 1;
    ULONG   fDisableCpm : 1;
    ULONG   fPromptForPassword : 1 ;
    
    ULONG   ColorDepth : 3;
    
    ULONG   fDenyTSConnections      : 1;              // if set, TS is basically OFF in the sense that nobody can connect.
    
    // these are not part of TS machine config data struct, but winlogn does use these and treats
    // them as per machine type of a policy
    ULONG   fTempFoldersPerSession  : 1;        // Use tmp folder per each session, instead of one common tmp folder
    ULONG   fDeleteTempFoldersOnExit: 1;       // on exit, do a cleanup of tmp folders
    
    ULONG   fWritableTSCCPermissionsTAB : 1;      // if set, then admins can change the per connection security descriptor.
   
    ULONG   fDisableCdm  : 1;
    ULONG   fForceClientLptDef : 1; 
    ULONG   fResetBroken : 1 ;               
    ULONG   fReconnectSame : 1 ;            
    ULONG   fSingleSessionPerUser:1;
    ULONG   fDisableWallpaper : 1;
    ULONG   fKeepAliveEnable : 1;
    ULONG   fPreventLicenseUpgrade:1;
    ULONG   fDisableAutoReconnect : 1;
    
    
    
    //
    // Non bit-fields next
    // 
    
    ULONG   MaxInstanceCount;
    
    BYTE    MinEncryptionLevel;
    
    WCHAR   WFProfilePath[ DIRECTORY_LENGTH + 1 ];

    WCHAR   WFHomeDir[ DIRECTORY_LENGTH + 1 ];

    WCHAR   WFHomeDirDrive[ 4 ];
    
    ULONG   SessionDirectoryActive;
    WCHAR   SessionDirectoryLocation[DIRECTORY_LENGTH+1];
    WCHAR   SessionDirectoryClusterName[DIRECTORY_LENGTH+1];
    WCHAR   SessionDirectoryAdditionalParams[DIRECTORY_LENGTH+1];
    ULONG   SessionDirectoryExposeServerIP;
    ULONG   KeepAliveInterval;
    
    SHADOWCLASS     Shadow;
    ULONG           MaxConnectionTime;            
    ULONG           MaxDisconnectionTime;         
    ULONG           MaxIdleTime;               
  
    // Start program Policy
    WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];

  
    
    // these have nothing to do with the USERCONFIGW data structure , not sure if I will keep them here.
    //    ULONG   fHideUserTabInTaskMan   : 1;        // When set, the new Users TAB in task man is hidden.
    //    ULONG   fDenyTSCCUsage          : 1;        // When set, you can't use TSCC
    //    ULONG   fHideTSCCPermissionsTAB : 1;        // allow TSCC to surface the permissions dialog, so that each connection
                                                    // gets it's own permissions list
                                                    
    // No UI for setting these in NT2195. Do we want to make these policies?
        //     ULONG fPolicyInheritSecurity : 1 ;
        //     ULONG fDisableEncryption    : 1;
        //
} POLICY_TS_MACHINE, *PPOLICY_TS_MACHINE;

/*
 *  User Configuration data
 */
typedef struct _USERCONFIGW {

    /* if flag is set inherit parameter from user or client configuration */
    ULONG fInheritAutoLogon : 1;
    ULONG fInheritResetBroken : 1;
    ULONG fInheritReconnectSame : 1;
    ULONG fInheritInitialProgram : 1;
    ULONG fInheritCallback : 1;
    ULONG fInheritCallbackNumber : 1;
    ULONG fInheritShadow : 1;
    ULONG fInheritMaxSessionTime : 1;
    ULONG fInheritMaxDisconnectionTime : 1;
    ULONG fInheritMaxIdleTime : 1;
    ULONG fInheritAutoClient : 1;
    ULONG fInheritSecurity : 1;

    ULONG fPromptForPassword : 1;      // fInheritAutoLogon
    ULONG fResetBroken : 1;
    ULONG fReconnectSame : 1;
    ULONG fLogonDisabled : 1;
    ULONG fWallPaperDisabled : 1;
    ULONG fAutoClientDrives : 1;
    ULONG fAutoClientLpts : 1;
    ULONG fForceClientLptDef : 1;
    ULONG fRequireEncryption : 1;
    ULONG fDisableEncryption : 1;
    ULONG fUnused1 : 1;                 // old fDisableIniFileMapping
    ULONG fHomeDirectoryMapRoot : 1;
    ULONG fUseDefaultGina : 1;

    ULONG fPublishedApp : 1;
    ULONG fHideTitleBar : 1;
    ULONG fMaximize : 1;

    ULONG fDisableCpm : 1;
    ULONG fDisableCdm : 1;
    ULONG fDisableCcm : 1;
    ULONG fDisableLPT : 1;
    ULONG fDisableClip : 1;
    ULONG fDisableExe : 1;
    ULONG fDisableCam : 1;
    ULONG fDisableAutoReconnect : 1;
    

    /* fInheritColorDepth */
    ULONG ColorDepth : 3;

    //NA 2/19/01
    ULONG fInheritColorDepth: 1;

    /* fInheritAutoLogon */
    WCHAR UserName[ USERNAME_LENGTH + 1 ];
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
    WCHAR Password[ PASSWORD_LENGTH + 1 ];

    /* fInheritInitialProgram */
    WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];

    /* fInheritCallback */
    WCHAR CallbackNumber[ CALLBACK_LENGTH + 1 ];
    CALLBACKCLASS Callback;

    /* fInheritShadow */
    SHADOWCLASS Shadow;

    ULONG MaxConnectionTime;
    ULONG MaxDisconnectionTime;
    ULONG MaxIdleTime;

    ULONG KeyboardLayout;               // 0 = inherit

    /* fInheritSecurity */
    BYTE MinEncryptionLevel;

    WCHAR NWLogonServer[ NASIFILESERVER_LENGTH + 1 ];

    APPLICATIONNAMEW PublishedName;

    /* WinFrame Profile Path - Overrides standard profile path */
    WCHAR WFProfilePath[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory - Overrides standard Home Directory */
    WCHAR WFHomeDir[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory Drive - Overrides standard Home Directory Drive*/
    WCHAR WFHomeDirDrive[ 4 ];

} USERCONFIGW, * PUSERCONFIGW;

typedef struct _USERCONFIGA {

    /* if flag is set inherit parameter from user or client configuration */
    ULONG fInheritAutoLogon : 1;
    ULONG fInheritResetBroken : 1;
    ULONG fInheritReconnectSame : 1;
    ULONG fInheritInitialProgram : 1;
    ULONG fInheritCallback : 1;
    ULONG fInheritCallbackNumber : 1;
    ULONG fInheritShadow : 1;
    ULONG fInheritMaxSessionTime : 1;
    ULONG fInheritMaxDisconnectionTime : 1;
    ULONG fInheritMaxIdleTime : 1;
    ULONG fInheritAutoClient : 1;
    ULONG fInheritSecurity : 1;

    ULONG fPromptForPassword : 1;      // fInheritAutoLogon
    ULONG fResetBroken : 1;
    ULONG fReconnectSame : 1;
    ULONG fLogonDisabled : 1;
    ULONG fWallPaperDisabled : 1;
    ULONG fAutoClientDrives : 1;
    ULONG fAutoClientLpts : 1;
    ULONG fForceClientLptDef : 1;
    ULONG fRequireEncryption : 1;
    ULONG fDisableEncryption : 1;
    ULONG fUnused1 : 1;                 // old fDisableIniFileMapping
    ULONG fHomeDirectoryMapRoot : 1;
    ULONG fUseDefaultGina : 1;

    ULONG fPublishedApp : 1;
    ULONG fHideTitleBar : 1;
    ULONG fMaximize : 1;

    ULONG fDisableCpm : 1;
    ULONG fDisableCdm : 1;
    ULONG fDisableCcm : 1;
    ULONG fDisableLPT : 1;
    ULONG fDisableClip : 1;
    ULONG fDisableExe : 1;
    ULONG fDisableCam : 1;
    ULONG fDisableAutoReconnect : 1;
    

    /* fInheritAutoLogon */
    CHAR UserName[ USERNAME_LENGTH + 1 ];
    CHAR Domain[ DOMAIN_LENGTH + 1 ];
    CHAR Password[ PASSWORD_LENGTH + 1 ];

    /* fInheritInitialProgram */
    CHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    CHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];

    /* fInheritCallback */
    CHAR CallbackNumber[ CALLBACK_LENGTH + 1 ];
    CALLBACKCLASS Callback;

    /* fInheritShadow */
    SHADOWCLASS Shadow;

    ULONG MaxConnectionTime;
    ULONG MaxDisconnectionTime;
    ULONG MaxIdleTime;

    ULONG KeyboardLayout;               // 0 = inherit

    /* fInheritSecurity */
    BYTE MinEncryptionLevel;

    CHAR NWLogonServer[ NASIFILESERVER_LENGTH + 1 ];

    APPLICATIONNAMEA PublishedName;

    /* WinFrame Profile Path - Overrides standard profile path */
    CHAR WFProfilePath[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory - Overrides standard Home Directory */
    CHAR WFHomeDir[ DIRECTORY_LENGTH + 1 ];

    /* WinFrame Home Directory Drive - Overrides standard Home Directory Drive*/
    CHAR WFHomeDirDrive[ 4 ];

} USERCONFIGA, * PUSERCONFIGA;

#ifdef UNICODE
#define USERCONFIG USERCONFIGW
#define PUSERCONFIG PUSERCONFIGW
#else
#define USERCONFIG USERCONFIGA
#define PUSERCONFIG PUSERCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

/******************
 *  PD structures
 ******************/

typedef struct _PDCONFIG2W{
    PDNAMEW PdName;                     // descriptive name of PD
    SDCLASS SdClass;                    // type of PD
    DLLNAMEW PdDLL;                     // name of PD dll
    ULONG    PdFlag;                    // PD flags
    ULONG OutBufLength;                 // optimal output buffer length
    ULONG OutBufCount;                  // optimal number of output buffers
    ULONG OutBufDelay;                  // write delay in msecs
    ULONG InteractiveDelay;             // write delay during active input
    ULONG PortNumber;                   // network listen port number
    ULONG KeepAliveTimeout;             // network watchdog frequence
} PDCONFIG2W, * PPDCONFIG2W;

typedef struct _PDCONFIG2A {
    PDNAMEA PdName;
    SDCLASS SdClass;
    DLLNAMEA PdDLL;
    ULONG    PdFlag;
    ULONG OutBufLength;
    ULONG OutBufCount;
    ULONG OutBufDelay;
    ULONG InteractiveDelay;
    ULONG PortNumber;
    ULONG KeepAliveTimeout;
} PDCONFIG2A, * PPDCONFIG2A;

/*
 *  PdFlag defines
 */
#define PD_UNUSED      0x00000001       // <unused>
#define PD_RELIABLE    0x00000002       // error free protocol already
#define PD_FRAME       0x00000004       // frame orientated protocol
#define PD_CONNECTION  0x00000008       // connection orientated protocol
#define PD_CONSOLE     0x00000010       // directly connected console
#define PD_LANA        0x00000020       // Network class uses LANAs (ie NetBIOS)
#define PD_TRANSPORT   0x00000040       // transport driver (lowest level)
#define PD_SINGLE_INST 0x00000080       // single instance only (async)
#define PD_NOLOW_WATERMARK 0x00000100	//low water mark to resume transmission

#ifdef UNICODE
#define PDCONFIG2 PDCONFIG2W
#define PPDCONFIG2 PPDCONFIG2W
#else
#define PDCONFIG2 PDCONFIG2A
#define PPDCONFIG2 PPDCONFIG2A
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _PDCONFIG3W {
    PDCONFIG2W Data;
    PDNAMEW ServiceName;               // Needed for non-LANA PdNetwork enum
    DLLNAMEW ConfigDLL;                // helper dll for WinStation configuration
    ULONG RequiredPdCount;
    PDNAMEW RequiredPds[ MAX_PDCONFIG ];
} PDCONFIG3W, * PPDCONFIG3W;

typedef struct _PDCONFIG3A {
    PDCONFIG2A Data;
    PDNAMEA ServiceName;               // Needed for non-LANA PdNetwork enum
    DLLNAMEA ConfigDLL;                // helper dll for WinStation configuration
    ULONG RequiredPdCount;
    PDNAMEA RequiredPds[ MAX_PDCONFIG ];
} PDCONFIG3A, * PPDCONFIG3A;

#ifdef UNICODE
#define PDCONFIG3 PDCONFIG3W
#define PPDCONFIG3 PPDCONFIG3W
#else
#define PDCONFIG3 PDCONFIG3A
#define PPDCONFIG3 PPDCONFIG3A
#endif /* UNICODE */

/*------------------------------------------------*/

typedef enum _FLOWCONTROLCLASS {
    FlowControl_None,
    FlowControl_Hardware,
    FlowControl_Software,
} FLOWCONTROLCLASS;

typedef enum _RECEIVEFLOWCONTROLCLASS {
    ReceiveFlowControl_None,
    ReceiveFlowControl_RTS,
    ReceiveFlowControl_DTR,
} RECEIVEFLOWCONTROLCLASS;

typedef enum _TRANSMITFLOWCONTROLCLASS {
    TransmitFlowControl_None,
    TransmitFlowControl_CTS,
    TransmitFlowControl_DSR,
} TRANSMITFLOWCONTROLCLASS;

typedef struct _FLOWCONTROLCONFIG {
    ULONG fEnableSoftwareTx: 1;
    ULONG fEnableSoftwareRx: 1;
    ULONG fEnableDTR: 1;
    ULONG fEnableRTS: 1;
    CHAR XonChar;
    CHAR XoffChar;
    FLOWCONTROLCLASS Type;
    RECEIVEFLOWCONTROLCLASS HardwareReceive;
    TRANSMITFLOWCONTROLCLASS HardwareTransmit;
} FLOWCONTROLCONFIG, * PFLOWCONTROLCONFIG;

typedef enum _ASYNCCONNECTCLASS {
    Connect_CTS,
    Connect_DSR,
    Connect_RI,
    Connect_DCD,
    Connect_FirstChar,
    Connect_Perm,
} ASYNCCONNECTCLASS;

typedef struct _CONNECTCONFIG {
    ASYNCCONNECTCLASS Type;
    ULONG fEnableBreakDisconnect: 1;
} CONNECTCONFIG, * PCONNECTCONFIG;

/*------------------------------------------------*/

typedef struct _ASYNCCONFIGW {
    DEVICENAMEW DeviceName;
    MODEMNAMEW ModemName;
    ULONG BaudRate;
    ULONG Parity;
    ULONG StopBits;
    ULONG ByteSize;
    ULONG fEnableDsrSensitivity: 1;
    ULONG fConnectionDriver: 1;
    FLOWCONTROLCONFIG FlowControl;
    CONNECTCONFIG Connect;
} ASYNCCONFIGW, * PASYNCCONFIGW;

typedef struct _ASYNCCONFIGA {
    DEVICENAMEA DeviceName;
    MODEMNAMEA ModemName;
    ULONG BaudRate;
    ULONG Parity;
    ULONG StopBits;
    ULONG ByteSize;
    ULONG fEnableDsrSensitivity: 1;
    ULONG fConnectionDriver: 1;
    FLOWCONTROLCONFIG FlowControl;
    CONNECTCONFIG Connect;
} ASYNCCONFIGA, * PASYNCCONFIGA;

#ifdef UNICODE
#define ASYNCCONFIG ASYNCCONFIGW
#define PASYNCCONFIG PASYNCCONFIGW
#else
#define ASYNCCONFIG ASYNCCONFIGA
#define PASYNCCONFIG PASYNCCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _NETWORKCONFIGW {
    LONG LanAdapter;
    DEVICENAMEW NetworkName;
    ULONG Flags;
} NETWORKCONFIGW, * PNETWORKCONFIGW;

typedef struct _NETWORKCONFIGA {
    LONG LanAdapter;
    DEVICENAMEA NetworkName;
    ULONG Flags;
} NETWORKCONFIGA, * PNETWORKCONFIGA;

#define NETWORK_CLIENT  0x00000001

#ifdef UNICODE
#define NETWORKCONFIG NETWORKCONFIGW
#define PNETWORKCONFIG PNETWORKCONFIGW
#else
#define NETWORKCONFIG NETWORKCONFIGA
#define PNETWORKCONFIG PNETWORKCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

#ifdef UNICODE
#define NASICONFIG NASICONFIGW
#define PNASICONFIG PNASICONFIGW
#else
#define NASICONFIG NASICONFIGA
#define PNASICONFIG PNASICONFIGA
#endif /* UNICODE */
typedef struct _NASICONFIGW {
    NASISPECIFICNAMEW    SpecificName;
    NASIUSERNAMEW        UserName;
    NASIPASSWORDW        PassWord;
    NASISESIONNAMEW      SessionName;
    NASIFILESERVERW      FileServer;
    BOOLEAN              GlobalSession;
} NASICONFIGW, * PNASICONFIGW;

typedef struct _NASICONFIGA {
    NASISPECIFICNAMEA    SpecificName;
    NASIUSERNAMEA        UserName;
    NASIPASSWORDA        PassWord;
    NASISESIONNAMEA      SessionName;
    NASIFILESERVERA      FileServer;
    BOOLEAN              GlobalSession;
} NASICONFIGA, * PNASICONFIGA;

/*------------------------------------------------*/

typedef struct _OEMTDCONFIGW {
    LONG Adapter;
    DEVICENAMEW DeviceName;
    ULONG Flags;
} OEMTDCONFIGW, * POEMTDCONFIGW;

typedef struct _OEMTDCONFIGA {
    LONG Adapter;
    DEVICENAMEA DeviceName;
    ULONG Flags;
} OEMTDCONFIGA, * POEMTDCONFIGA;

#ifdef UNICODE
#define OEMTDCONFIG OEMTDCONFIGW
#define POEMTDCONFIG POEMTDCONFIGW
#else
#define OEMTDCONFIG OEMTDCONFIGA
#define POEMTDCONFIG POEMTDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _PDPARAMSW {
    SDCLASS SdClass;
    union {
        NETWORKCONFIGW Network;
        ASYNCCONFIGW Async;
        NASICONFIGW Nasi;
        OEMTDCONFIGW OemTd;
    };
} PDPARAMSW, * PPDPARAMSW;

typedef struct _PDPARAMSA {
    SDCLASS SdClass;
    union {
        NETWORKCONFIGA Network;
        ASYNCCONFIGA Async;
        NASICONFIGA Nasi;
        OEMTDCONFIGA OemTd;
    };
} PDPARAMSA, * PPDPARAMSA;

#ifdef UNICODE
#define PDPARAMS PDPARAMSW
#define PPDPARAMS PPDPARAMSW
#else
#define PDPARAMS PDPARAMSA
#define PPDPARAMS PPDPARAMSA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _PDCONFIGW {
    PDCONFIG2W Create;
    PDPARAMSW Params;
} PDCONFIGW, * PPDCONFIGW;

typedef struct _PDCONFIGA {
    PDCONFIG2A Create;
    PDPARAMSA Params;
} PDCONFIGA, * PPDCONFIGA;

#ifdef UNICODE
#define PDCONFIG PDCONFIGW
#define PPDCONFIG PPDCONFIGW
#else
#define PDCONFIG PDCONFIGA
#define PPDCONFIG PPDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/


 /***********************
  *  Wd structures
  ***********************/


typedef struct _WDCONFIGW {
    WDNAMEW WdName;
    DLLNAMEW WdDLL;
    DLLNAMEW WsxDLL;
    ULONG WdFlag;
    ULONG WdInputBufferLength;
    DLLNAMEW CfgDLL;
    WDPREFIXW WdPrefix;
} WDCONFIGW, * PWDCONFIGW;

typedef struct _WDCONFIGA {
    WDNAMEA WdName;
    DLLNAMEA WdDLL;
    DLLNAMEA WsxDLL;
    ULONG WdFlag;
    ULONG WdInputBufferLength;
    DLLNAMEA CfgDLL;
    WDPREFIXA WdPrefix;
} WDCONFIGA, * PWDCONFIGA;

/*
 *  WdFlag defines
 */
#define WDF_UNUSED            0x00000001   // <unused>
#define WDF_SHADOW_SOURCE     0x00000002   // valid shadow source
#define WDF_SHADOW_TARGET     0x00000004   // valid shadow target
#define WDF_ICA               0x00000008   // WD is Citrix ICA class
#define WDF_TSHARE            0x00000010   // WD is Microsoft TSHARE class
#define WDF_DYNAMIC_RECONNECT 0x00000020   // Session can resize Display at reconnect

#ifdef UNICODE
#define WDCONFIG WDCONFIGW
#define PWDCONFIG PWDCONFIGW
#else
#define WDCONFIG WDCONFIGA
#define PWDCONFIG PWDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _WDCONFIG2W {
    WDCONFIGW Wd;
    ASYNCCONFIGW Async;
    USERCONFIGW User;
} WDCONFIG2W, * PWDCONFIG2W;

typedef struct _WDCONFIG2A {
    WDCONFIGA Wd;
    ASYNCCONFIGA Async;
    USERCONFIGA User;
} WDCONFIG2A, * PWDCONFIG2A;

#ifdef UNICODE
#define WDCONFIG2 WDCONFIG2W
#define PWDCONFIG2 PWDCONFIG2W
#else
#define WDCONFIG2 WDCONFIG2A
#define PWDCONFIG2 PWDCONFIG2A
#endif /* UNICODE */

/*------------------------------------------------*/

 /**************************************
  *  Connection Driver structures (CD)
  **************************************/

/*
 *  connection driver classes
 */
typedef enum _CDCLASS {
    CdNone,            // 0
    CdModem,           // 1  cdmodem.dll
    CdClass_Maximum,   // 2  -- must be last
} CDCLASS;

/*------------------------------------------------*/


typedef struct _CDCONFIGW {
    CDCLASS CdClass;
    CDNAMEW CdName;
    DLLNAMEW CdDLL;
    ULONG CdFlag;
} CDCONFIGW, * PCDCONFIGW;

typedef struct _CDCONFIGA {
    CDCLASS CdClass;
    CDNAMEA CdName;
    DLLNAMEA CdDLL;
    ULONG CdFlag;
} CDCONFIGA, * PCDCONFIGA;

#ifdef UNICODE
#define CDCONFIG CDCONFIGW
#define PCDCONFIG PCDCONFIGW
#else
#define CDCONFIG CDCONFIGA
#define PCDCONFIG PCDCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/


/*****************************
 *  Window Station structures
 *****************************/

typedef struct _WINSTATIONCREATEW {
    ULONG fEnableWinStation : 1;
    ULONG MaxInstanceCount;
} WINSTATIONCREATEW, * PWINSTATIONCREATEW;

typedef struct _WINSTATIONCREATEA {
    ULONG fEnableWinStation : 1;
    ULONG MaxInstanceCount;
} WINSTATIONCREATEA, * PWINSTATIONCREATEA;

#ifdef UNICODE
#define WINSTATIONCREATE WINSTATIONCREATEW
#define PWINSTATIONCREATE PWINSTATIONCREATEW
#else
#define WINSTATIONCREATE WINSTATIONCREATEA
#define PWINSTATIONCREATE PWINSTATIONCREATEA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _WINSTATIONCONFIGW {
    WCHAR Comment[ WINSTATIONCOMMENT_LENGTH + 1 ];
    USERCONFIGW User;
    char OEMId[4];                // WinFrame Server OEM Id
} WINSTATIONCONFIGW, * PWINSTATIONCONFIGW;

typedef struct _WINSTATIONCONFIGA {
    CHAR Comment[ WINSTATIONCOMMENT_LENGTH + 1 ];
    USERCONFIGA User;
    char OEMId[4];                // WinFrame Server OEM Id
} WINSTATIONCONFIGA, * PWINSTATIONCONFIGA;

#ifdef UNICODE
#define WINSTATIONCONFIG WINSTATIONCONFIGW
#define PWINSTATIONCONFIG PWINSTATIONCONFIGW
#else
#define WINSTATIONCONFIG WINSTATIONCONFIGA
#define PWINSTATIONCONFIG PWINSTATIONCONFIGA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef enum _WINSTATIONINFOCLASS {
    WinStationCreateData,         // query WinStation create data
    WinStationConfiguration,      // query/set WinStation parameters
    WinStationPdParams,           // query/set PD parameters
    WinStationWd,                 // query WD config (only one can be loaded)
    WinStationPd,                 // query PD config (many can be loaded)
    WinStationPrinter,            // query/set LPT mapping to printer queues
    WinStationClient,             // query information about client
    WinStationModules,            // query information about all client modules
    WinStationInformation,        // query information about WinStation
    WinStationTrace,              // enable/disable winstation tracing
    WinStationBeep,               // beep the WinStation
    WinStationEncryptionOff,      // turn off encryption
    WinStationEncryptionPerm,     // encryption is permanent on
    WinStationNtSecurity,         // select winlogon security desktop
    WinStationUserToken,          // User token
    WinStationUnused1,            // *** AVAILABLE *** (old IniMapping)
    WinStationVideoData,          // query hres, vres, color depth
    WinStationInitialProgram,     // Identify Initial Program
    WinStationCd,                 // query CD config (only one can be loaded)
    WinStationSystemTrace,        // enable/disable system tracing
    WinStationVirtualData,        // query client virtual data
    WinStationClientData,         // send data to client
    WinStationSecureDesktopEnter, // turn encryption on, if enabled
    WinStationSecureDesktopExit,  // turn encryption off, if enabled
    WinStationLoadBalanceSessionTarget,  // Load balance info from redirected client.
    WinStationLoadIndicator,      // query load capacity information
    WinStationShadowInfo,     // query/set Shadow state & parameters
    WinStationDigProductId,   // get the outermost digital product id, the client's product id, and the current product id
    WinStationLockedState,        // winlogon sets this for notifing apps/services.
    WinStationRemoteAddress,     // Query client IP address
    WinStationLastReconnectType,   // If last reconnect for this winstation was manual or auto reconnect.      
    WinStationDisallowAutoReconnect,     // Allow/Disallow AutoReconnect for this WinStation
    WinStationMprNotifyInfo       // Mprnotify info from Winlogon for notifying 3rd party network providers
} WINSTATIONINFOCLASS;

/*------------------------------------------------*/

typedef struct _WINSTATIONCLIENTDATA {
    CLIENTDATANAME DataName;
    BOOLEAN fUnicodeData;
    /* BYTE   Data[1]; Variable length data follows */
} WINSTATIONCLIENTDATA, * PWINSTATIONCLIENTDATA;

/*------------------------------------------------*/

typedef struct _WINSTATIONUSERTOKEN {
    HANDLE ProcessId;
    HANDLE ThreadId;
    HANDLE UserToken;
} WINSTATIONUSERTOKEN, * PWINSTATIONUSERTOKEN;

/*------------------------------------------------*/

typedef struct _WINSTATIONVIDEODATA {
    USHORT  HResolution;
    USHORT  VResolution;
    USHORT  fColorDepth;
} WINSTATIONVIDEODATA, *PWINSTATIONVIDEODATA;

/*----------------------------------------------*/

typedef struct _WINSTATIONCONFIG2W {
    WINSTATIONCREATEW Create;
    PDCONFIGW Pd[ MAX_PDCONFIG ];
    WDCONFIGW Wd;
    CDCONFIGW Cd;
    WINSTATIONCONFIGW   Config;
} WINSTATIONCONFIG2W, * PWINSTATIONCONFIG2W;

typedef struct _WINSTATIONCONFIG2A {
    WINSTATIONCREATEA Create;
    PDCONFIGA Pd[ MAX_PDCONFIG ];
    WDCONFIGA Wd;
    CDCONFIGA Cd;
    WINSTATIONCONFIGA Config;
} WINSTATIONCONFIG2A, * PWINSTATIONCONFIG2A;

#ifdef UNICODE
#define WINSTATIONCONFIG2 WINSTATIONCONFIG2W
#define PWINSTATIONCONFIG2 PWINSTATIONCONFIG2W
#else
#define WINSTATIONCONFIG2 WINSTATIONCONFIG2A
#define PWINSTATIONCONFIG2 PWINSTATIONCONFIG2A
#endif /* UNICODE */

/*------------------------------------------------*/

typedef struct _WINSTATIONPRINTERW {
    PRINTERNAMEW Lpt1;
    PRINTERNAMEW Lpt2;
    PRINTERNAMEW Lpt3;
    PRINTERNAMEW Lpt4;
} WINSTATIONPRINTERW, * PWINSTATIONPRINTERW;

typedef struct _WINSTATIONPRINTERA {
    PRINTERNAMEA Lpt1;
    PRINTERNAMEA Lpt2;
    PRINTERNAMEA Lpt3;
    PRINTERNAMEA Lpt4;
} WINSTATIONPRINTERA, * PWINSTATIONPRINTERA;

#ifdef UNICODE
#define WINSTATIONPRINTER WINSTATIONPRINTERW
#define PWINSTATIONPRINTER PWINSTATIONPRINTERW
#else
#define WINSTATIONPRINTER WINSTATIONPRINTERA
#define PWINSTATIONPRINTER PWINSTATIONPRINTERA
#endif /* UNICODE */

#ifndef _TS_TIME_ZONE_INFORMATION_
#define _TS_TIME_ZONE_INFORMATION_
typedef struct _TS_SYSTEMTIME {
    USHORT wYear;
    USHORT wMonth;
    USHORT wDayOfWeek;
    USHORT wDay;
    USHORT wHour;
    USHORT wMinute;
    USHORT wSecond;
    USHORT wMilliseconds;
} TS_SYSTEMTIME;

typedef struct _TS_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    TS_SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    TS_SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TS_TIME_ZONE_INFORMATION;
#endif //_TS_TIME_ZONE_INFORMATION_

/*------------------------------------------------*/

/*
 *  WinStation client data structure
 */
typedef struct _WINSTATIONCLIENTW {
    ULONG fTextOnly: 1;
    ULONG fDisableCtrlAltDel: 1;
    ULONG fMouse: 1;
    ULONG fDoubleClickDetect: 1;
    ULONG fINetClient: 1;
    ULONG fPromptForPassword : 1;
    ULONG fMaximizeShell: 1;
    ULONG fEnableWindowsKey: 1;
    ULONG fRemoteConsoleAudio: 1;
    WCHAR ClientName[ CLIENTNAME_LENGTH + 1 ];
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
    WCHAR UserName[ USERNAME_LENGTH + 1 ];
    WCHAR Password[ PASSWORD_LENGTH + 1 ];
    WCHAR WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];
    ULONG SerialNumber;         // client computer unique serial number
    BYTE EncryptionLevel;       // security level of encryption pd
    ULONG ClientAddressFamily;
    WCHAR ClientAddress[ CLIENTADDRESS_LENGTH + 1 ];
    USHORT HRes;
    USHORT VRes;
    USHORT ColorDepth;
    USHORT ProtocolType;   // PROTOCOL_ICA or PROTOCOL_RDP
    ULONG KeyboardLayout;
    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
    WCHAR imeFileName[ IMEFILENAME_LENGTH + 1 ];
    WCHAR ClientDirectory[ DIRECTORY_LENGTH + 1 ];
    WCHAR ClientLicense[ CLIENTLICENSE_LENGTH + 1 ];
    WCHAR ClientModem[ CLIENTMODEM_LENGTH + 1 ];
    ULONG ClientBuildNumber;
    ULONG ClientHardwareId;    // client software serial number
    USHORT ClientProductId;     // client software product id
    USHORT OutBufCountHost;     // number of outbufs on host
    USHORT OutBufCountClient;   // number of outbufs on client
    USHORT OutBufLength;        // length of outbufs in bytes
    WCHAR AudioDriverName[9];
    //client time zone information
    TS_TIME_ZONE_INFORMATION ClientTimeZone;
    ULONG ClientSessionId;
    WCHAR clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    ULONG PerformanceFlags;  // List of features to disable for perf
} WINSTATIONCLIENTW, * PWINSTATIONCLIENTW;

/*
 *  WinStation client data structure
 */
typedef struct _WINSTATIONCLIENTA {
    ULONG fTextOnly: 1;
    ULONG fDisableCtrlAltDel: 1;
    ULONG fMouse: 1;
    ULONG fDoubleClickDetect: 1;
    ULONG fINetClient: 1;
    ULONG fPromptForPassword : 1;
    ULONG fMaximizeShell: 1;
    ULONG fEnableWindowsKey: 1;
    char ClientName[ CLIENTNAME_LENGTH + 1 ];
    char Domain[ DOMAIN_LENGTH + 1 ];
    char UserName[ USERNAME_LENGTH + 1 ];
    char Password[ PASSWORD_LENGTH + 1 ];
    char WorkDirectory[ DIRECTORY_LENGTH + 1 ];
    char InitialProgram[ INITIALPROGRAM_LENGTH + 1 ];
    ULONG SerialNumber;         // client computer unique serial number
    BYTE EncryptionLevel;       // security level of encryption pd
    ULONG ClientAddressFamily;
    char ClientAddress[ CLIENTADDRESS_LENGTH + 1 ];
    USHORT HRes;
    USHORT VRes;
    USHORT ColorDepth;
    USHORT ProtocolType;   // PROTOCOL_ICA or PROTOCOL_RDP
    ULONG KeyboardLayout;
    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
    char imeFileName[ IMEFILENAME_LENGTH + 1 ];
    char ClientDirectory[ DIRECTORY_LENGTH + 1 ];
    char ClientLicense[ CLIENTLICENSE_LENGTH + 1 ];
    char ClientModem[ CLIENTMODEM_LENGTH + 1 ];
    ULONG ClientBuildNumber;
    ULONG ClientHardwareId;    // client software serial number
    USHORT ClientProductId;     // client software product id
    USHORT OutBufCountHost;     // number of outbufs on host
    USHORT OutBufCountClient;   // number of outbufs on client
    USHORT OutBufLength;        // length of outbufs in bytes
    char AudioDriverName[9];
    //client time zone information
    TS_TIME_ZONE_INFORMATION ClientTimeZone;
    ULONG ClientSessionId;
    char clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    ULONG PerformanceFlags;  // List of features to disable for perf
} WINSTATIONCLIENTA, * PWINSTATIONCLIENTA;

#ifdef UNICODE
#define WINSTATIONCLIENT WINSTATIONCLIENTW
#define PWINSTATIONCLIENT PWINSTATIONCLIENTW
#else
#define WINSTATIONCLIENT WINSTATIONCLIENTA
#define PWINSTATIONCLIENT PWINSTATIONCLIENTA
#endif /* UNICODE */

/*
 *  Autoreconnect information passed up from the stack
 */
#define MAX_TS_AUTORECONNECTINFO_LEN    128 
typedef struct _TS_AUTORECONNECTINFO {
    USHORT cbAutoReconnectInfo;
    BYTE AutoReconnectInfo[MAX_TS_AUTORECONNECTINFO_LEN];
} TS_AUTORECONNECTINFO, *PTS_AUTORECONNECTINFO;


/*------------------------------------------------*/

/*
 *  ICA specific protocol performance counters
 */
typedef struct _ICA_COUNTERS {
    ULONG Reserved;
} ICA_COUNTERS, * PICA_COUNTERS;

/*
 *  T.Share specific protocol performance counters
 */
typedef struct _TSHARE_COUNTERS {
    ULONG Reserved;
} TSHARE_COUNTERS, * PTSHARE_COUNTERS;

/*
 *  WinStation protocol performance counters
 */
typedef struct _PROTOCOLCOUNTERS {
    ULONG WdBytes;              // wd common
    ULONG WdFrames;             // wd common
    ULONG WaitForOutBuf;        // wd common
    ULONG Frames;               // td common
    ULONG Bytes;                // td common
    ULONG CompressedBytes;      // pdcomp
    ULONG CompressFlushes;      // pdcomp
    ULONG Errors;               // pdreli
    ULONG Timeouts;             // pdreli
    ULONG AsyncFramingError;    // pdasync
    ULONG AsyncOverrunError;    // pdasync
    ULONG AsyncOverflowError;   // pdasync
    ULONG AsyncParityError;     // pdasync
    ULONG TdErrors;             // td common
    USHORT ProtocolType;        // PROTOCOL_ICA or PROTOCOL_RDP
    USHORT Length;              // length of data in protocol-specific space
    union {
        ICA_COUNTERS    IcaCounters;
        TSHARE_COUNTERS TShareCounters;
        ULONG           Reserved[100];
    } Specific;
} PROTOCOLCOUNTERS, * PPROTOCOLCOUNTERS;

/*
 * ThinWire cache statistics
 */
typedef struct _THINWIRECACHE {
    ULONG CacheReads;
    ULONG CacheHits;
} THINWIRECACHE, * PTHINWIRECACHE;

#define MAX_THINWIRECACHE   4

/*
 *  ICA specific cache statistics
 */
typedef struct _ICA_CACHE {
    THINWIRECACHE ThinWireCache[ MAX_THINWIRECACHE ];
} ICA_CACHE, * PICA_CACHE;

/*
 *  T.Share specific cache statistics
 */
typedef struct _TSHARE_CACHE {
    ULONG Reserved;
} TSHARE_CACHE, * PTSHARE_CACHE;

/*
 *  WinStation cache statistics
 */
typedef struct CACHE_STATISTICS {
    USHORT ProtocolType;        // PROTOCOL_ICA or PROTOCOL_RDP
    USHORT Length;              // length of data in protocol-specific space
    union {
        ICA_CACHE    IcaCacheStats;
        TSHARE_CACHE TShareCacheStats;
        ULONG        Reserved[20];
    } Specific;
} CACHE_STATISTICS, * PCACHE_STATISTICS;

/*
 *  WinStation protocol status
 */
typedef struct _PROTOCOLSTATUS {
    PROTOCOLCOUNTERS Output;
    PROTOCOLCOUNTERS Input;
    CACHE_STATISTICS Cache;
    ULONG AsyncSignal;                  // MS_CTS_ON, MS_DSR_ON, etc...
    ULONG AsyncSignalMask;              // EV_CTS, EV_DSR, etc...
} PROTOCOLSTATUS, * PPROTOCOLSTATUS;

/*
 *  Protocol extension info struct
 */
typedef struct _WSX_INFO {
    ULONG Version;
    HANDLE hIca;
    HANDLE hStack;
    ULONG SessionId;
    PWCHAR pUserName;
    PWCHAR pDomain;
#define WSX_INFO_VERSION_1 0x1
} WSX_INFO, * PWSX_INFO;

/*
 *  AsyncSignal defines
 */
// #define MS_CTS_ON            0x0010
// #define MS_DSR_ON            0x0020
// #define MS_RING_ON           0x0040
// #define MS_RLSD_ON           0x0080
#define MS_DTR_ON           0x00010000
#define MS_RTS_ON           0x00020000

/*
 *  AsyncSignalMask defines
 */
// #define EV_CTS              0x0008  // CTS changed state
// #define EV_DSR              0x0010  // DSR changed state
// #define EV_RLSD             0x0020  // RLSD changed state
// #define EV_RING             0x0100  // Ring signal detected
#define EV_DTR             0x00010000  // DTR changed state
#define EV_RTS             0x00020000  // DTR changed state

/*------------------------------------------------*/

/*
 *  WinStation query information
 */
typedef struct _WINSTATIONINFORMATIONW {
    WINSTATIONSTATECLASS ConnectState;
    WINSTATIONNAMEW WinStationName;
    ULONG LogonId;
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER LogonTime;
    PROTOCOLSTATUS Status;
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
    WCHAR UserName[USERNAME_LENGTH + 1];
    LARGE_INTEGER CurrentTime;
} WINSTATIONINFORMATIONW, * PWINSTATIONINFORMATIONW;

typedef struct _WINSTATIONINFORMATIONA {
    WINSTATIONSTATECLASS ConnectState;
    WINSTATIONNAMEA WinStationName;
    ULONG LogonId;
    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LastInputTime;
    LARGE_INTEGER LogonTime;
    PROTOCOLSTATUS Status;
    CHAR Domain[ DOMAIN_LENGTH + 1 ];
    CHAR UserName[USERNAME_LENGTH + 1];
    LARGE_INTEGER CurrentTime;
} WINSTATIONINFORMATIONA, * PWINSTATIONINFORMATIONA;

#ifdef UNICODE
#define WINSTATIONINFORMATION WINSTATIONINFORMATIONW
#define PWINSTATIONINFORMATION PWINSTATIONINFORMATIONW
#else
#define WINSTATIONINFORMATION WINSTATIONINFORMATIONA
#define PWINSTATIONINFORMATION PWINSTATIONINFORMATIONA
#endif /* UNICODE */

/*
 * Load balancing data types
 */
typedef enum _LOADFACTORTYPE {
    ErrorConstraint,
    PagedPoolConstraint,
    NonPagedPoolConstraint,
    AvailablePagesConstraint,
    SystemPtesConstraint,
    CPUConstraint 
} LOADFACTORTYPE;

typedef struct _WINSTATIONLOADINDICATORDATA {
    ULONG RemainingSessionCapacity;
    LOADFACTORTYPE LoadFactor;
    ULONG TotalSessions;
    ULONG DisconnectedSessions;
    LARGE_INTEGER IdleCPU;
    LARGE_INTEGER TotalCPU;
    ULONG RawSessionCapacity;
    ULONG reserved[9];    
} WINSTATIONLOADINDICATORDATA, * PWINSTATIONLOADINDICATORDATA;

/*------------------------------------------------*/

/*
 *  WinStation shadow states
 */
typedef enum _SHADOWSTATECLASS {
    State_NoShadow,                    // No shadow operations on this session
    State_Shadowing,                   // The session is a Shadow client (viewer)
    State_Shadowed,                    // The session is a Shadow target 
} SHADOWSTATECLASS;


/*
 *  Shadow query/set information
 */
typedef struct _WINSTATIONSHADOW {
    SHADOWSTATECLASS    ShadowState;
    SHADOWCLASS         ShadowClass;
    ULONG               SessionId;
    ULONG               ProtocolType;   // ignored in a set operation
} WINSTATIONSHADOW, * PWINSTATIONSHADOW;

//get the outermost product id, client product id, and current product id
//and corresponding session ids for use in checking shadow loop
typedef struct _WINSTATIONPRODIDW {
  WCHAR DigProductId[CLIENT_PRODUCT_ID_LENGTH];
  WCHAR ClientDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  WCHAR OuterMostDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  ULONG curentSessionId;
  ULONG ClientSessionId;
  ULONG OuterMostSessionId;
}WINSTATIONPRODIDW, *PWINSTATIONPRODIDW;

typedef struct _WINSTATIONPRODIDA {
  CHAR DigProductId[CLIENT_PRODUCT_ID_LENGTH];
  CHAR ClientDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  CHAR OuterMostDigProductId[CLIENT_PRODUCT_ID_LENGTH ];
  ULONG curentSessionId;
  ULONG ClientSessionId;
  ULONG OuterMostSessionId;
}WINSTATIONPRODIDA, *PWINSTATIONPRODIDA;

#ifdef UNICODE
#define WINSTATIONPRODID WINSTATIONPRODIDW
#define PWINSTATIONPRODID PWINSTATIONPRODIDW
#else
#define WINSTATIONPRODID WINSTATIONPRODIDA
#define PWINSTATIONPRODID PWINSTATIONPRODIDA
#endif /* UNICODE */


typedef struct {
	unsigned short sin_family;		// Socket address family.
									// AF_INET or AF_INET6

	union {
		// structure identical to TDI_ADDRESS_IP
		struct {
			USHORT sin_port;
			ULONG  in_addr;
			UCHAR  sin_zero[8];
		} ipv4;

		// structure identical to TDI_ADDRESS_IP6
		struct {
			USHORT sin6_port;
			ULONG  sin6_flowinfo;
			USHORT sin6_addr[8];
			ULONG  sin6_scope_id;
		} ipv6;
	};
} WINSTATIONREMOTEADDRESS, *PWINSTATIONREMOTEADDRESS;
    
/*------------------------------------------------*/

/*
 *  Licensing Policy information struct
 */

#define LCPOLICYINFOTYPE_V1 (1)

#define LCPOLICYINFOTYPE_CURRENT LCPOLICYINFOTYPE_V1

typedef struct {
    ULONG ulVersion;
    LPWSTR lpPolicyName;
    LPWSTR lpPolicyDescription;
} LCPOLICYINFO_V1W, *LPLCPOLICYINFO_V1W;

typedef struct {
    ULONG ulVersion;
    LPSTR lpPolicyName;
    LPSTR lpPolicyDescription;
} LCPOLICYINFO_V1A, *LPLCPOLICYINFO_V1A;

#ifdef UNICODE
#define LCPOLICYINFO_V1 LCPOLICYINFO_V1W
#define LPLCPOLICYINFO_V1 LPLCPOLICYINFO_V1W
#else
#define LCPOLICYINFO_V1 LCPOLICYINFO_V1A
#define LPLCPOLICYINFO_V1 LPLCPOLICYINFO_V1A
#endif

//
//  The generic type is for the API. This will help callers realize that while
//  this API can correctly handle several types of input, they are all based
//  on the LCPOLICYINFO series.
//

typedef struct {
    ULONG ulVersion;
} LCPOLICYINFOGENERIC, *LPLCPOLICYINFOGENERIC;

/*------------------------------------------------*/

/*
 * Types of settings that termsrv can update.  Callers to 
 * _WinStationUpdateSettings choose one, therefore we need not update
 * everything because one type of setting has changed.
 *
 * What used to be contained in ReadRegistry is now covered by
 * WINSTACFG_LEGACY.
 */

typedef enum _WINSTATIONUPDATECFGCLASS {
    WINSTACFG_LEGACY,
    WINSTACFG_SESSDIR
} WINSTATIONUPDATECFGCLASS;

/*------------------------------------------------*/

typedef struct _BEEPINPUT {
    ULONG uType;
} BEEPINPUT, * PBEEPINPUT;

/*------------------------------------------------*/


/**********************
 *  NWLogon Structure
 **********************/


typedef struct _NWLOGONADMIN {
    WCHAR Username[ USERNAME_LENGTH + 1 ];
    WCHAR Password[ PASSWORD_LENGTH + 1 ];
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];
} NWLOGONADMIN, * PNWLOGONADMIN;


/*------------------------------------------------*/
/**********************************************
 *  Registry APIs for Connection Drivers (Cds)
 **********************************************/


LONG WINAPI
RegCdEnumerateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PULONG  pIndex,
    PULONG  pEntries,
    PCDNAMEW pCdName,
    PULONG  pByteCount
    );

LONG WINAPI
RegCdEnumerateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PULONG  pIndex,
    PULONG  pEntries,
    PCDNAMEA pCdName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegCdEnumerate RegCdEnumerateW
#else
#define RegCdEnumerate RegCdEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegCdCreateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PCDNAMEW pCdName,
    BOOLEAN bCreate,
    PCDCONFIGW pCdConfig,
    ULONG CdConfigLength
    );

LONG WINAPI
RegCdCreateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PCDNAMEA pCdName,
    BOOLEAN bCreate,
    PCDCONFIGA pCdConfig,
    ULONG CdConfigLength
    );

#ifdef UNICODE
#define RegCdCreate RegCdCreateW
#else
#define RegCdCreate RegCdCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegCdQueryW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PCDNAMEW pCdName,
    PCDCONFIGW pCdConfig,
    ULONG CdConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegCdQueryA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PCDNAMEA pCdName,
    PCDCONFIGA pCdConfig,
    ULONG CdConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegCdQuery RegCdQueryW
#else
#define RegCdQuery RegCdQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegCdDeleteW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PCDNAMEW pCdName
    );

LONG WINAPI
RegCdDeleteA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PCDNAMEA pCdName
    );

#ifdef UNICODE
#define RegCdDelete RegCdDeleteW
#else
#define RegCdDelete RegCdDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/


/**********************************************
 *  Registry APIs for WinStation Drivers (Wds)
 **********************************************/


LONG WINAPI
RegWdEnumerateW(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWDNAMEW pWdName,
    PULONG  pByteCount
    );

LONG WINAPI
RegWdEnumerateA(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWDNAMEA pWdName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegWdEnumerate RegWdEnumerateW
#else
#define RegWdEnumerate RegWdEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWdCreateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bCreate,
    PWDCONFIG2W pWdConfig,
    ULONG WdConfigLength
    );

LONG WINAPI
RegWdCreateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bCreate,
    PWDCONFIG2A pWdConfig,
    ULONG WdConfigLength
    );

#ifdef UNICODE
#define RegWdCreate RegWdCreateW
#else
#define RegWdCreate RegWdCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWdQueryW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    PWDCONFIG2W pWdConfig,
    ULONG WdConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegWdQueryA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    PWDCONFIG2A pWdConfig,
    ULONG WdConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegWdQuery RegWdQueryW
#else
#define RegWdQuery RegWdQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWdDeleteW(
    HANDLE hServer,
    PWDNAMEW pWdName
    );

LONG WINAPI
RegWdDeleteA(
    HANDLE hServer,
    PWDNAMEA pWdName
    );

#ifdef UNICODE
#define RegWdDelete RegWdDeleteW
#else
#define RegWdDelete RegWdDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/


/******************************************************************
 *  Registry APIs for Transport and Protocol Drivers (Tds and Pds)
 ******************************************************************/


HANDLE WINAPI
RegOpenServerW(
    LPWSTR hServerName
    );

HANDLE WINAPI
RegOpenServerA(
    LPSTR hServerName
    );

#ifdef UNICODE
#define RegOpenServer RegOpenServerW
#else
#define RegOpenServer RegOpenServerA
#endif /* UNICODE */

/*------------------------------------------------*/
LONG WINAPI
RegCloseServer(
        HANDLE hServer
        );

/*------------------------------------------------*/
LONG WINAPI
RegPdEnumerateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PULONG  pIndex,
    PULONG  pEntries,
    PPDNAMEW  pPdName,
    PULONG  pByteCount
    );

LONG WINAPI
RegPdEnumerateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PULONG  pIndex,
    PULONG  pEntries,
    PPDNAMEA  pPdName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegPdEnumerate RegPdEnumerateW
#else
#define RegPdEnumerate RegPdEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegPdCreateW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PPDNAMEW pPdName,
    BOOLEAN bCreate,
    PPDCONFIG3W pPdConfig,
    ULONG PdConfigLength
    );

LONG WINAPI
RegPdCreateA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PPDNAMEA pPdName,
    BOOLEAN bCreate,
    PPDCONFIG3A pPdConfig,
    ULONG PdConfigLength
    );

#ifdef UNICODE
#define RegPdCreate RegPdCreateW
#else
#define RegPdCreate RegPdCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegPdQueryW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PPDNAMEW pPdName,
    PPDCONFIG3W pPdConfig,
    ULONG PdConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegPdQueryA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PPDNAMEA pPdName,
    PPDCONFIG3A pPdConfig,
    ULONG PdConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegPdQuery RegPdQueryW
#else
#define RegPdQuery RegPdQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegPdDeleteW(
    HANDLE hServer,
    PWDNAMEW pWdName,
    BOOLEAN bTd,
    PPDNAMEW pPdName
    );

LONG WINAPI
RegPdDeleteA(
    HANDLE hServer,
    PWDNAMEA pWdName,
    BOOLEAN bTd,
    PPDNAMEA pPdName
    );

#ifdef UNICODE
#define RegPdDelete RegPdDeleteW
#else
#define RegPdDelete RegPdDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/


/*************************************
 *  Registry APIs for Window Stations
 *************************************/


LONG WINAPI
RegWinStationAccessCheck(
    HANDLE hServer,
    ACCESS_MASK samDesired
    );

/*------------------------------------------------*/

LONG WINAPI
RegWinStationEnumerateW(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWINSTATIONNAMEW pWinStationName,
    PULONG  pByteCount
    );

/*------------------------------------------------*/

LONG WINAPI
RegWinStationEnumerateA(
    HANDLE hServer,
    PULONG  pIndex,
    PULONG  pEntries,
    PWINSTATIONNAMEA pWinStationName,
    PULONG  pByteCount
    );

#ifdef UNICODE
#define RegWinStationEnumerate RegWinStationEnumerateW
#else
#define RegWinStationEnumerate RegWinStationEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationCreateW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    BOOLEAN bCreate,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength
    );

LONG WINAPI
RegWinStationCreateA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    BOOLEAN bCreate,
    PWINSTATIONCONFIG2A pWinStationConfig,
    ULONG WinStationConfigLength
    );

#ifdef UNICODE
#define RegWinStationCreate RegWinStationCreateW
#else
#define RegWinStationCreate RegWinStationCreateA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegWinStationQueryEx(
    HANDLE hServer,
    PPOLICY_TS_MACHINE   pMachinePolicy,
    PWINSTATIONNAMEW pWinStationName,
    PWINSTATIONCONFIG2W pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength,
    BOOLEAN bPerformMerger
    );



LONG WINAPI
RegWinStationQueryA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PWINSTATIONCONFIG2A pWinStationConfig,
    ULONG WinStationConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegWinStationQuery RegWinStationQueryW
#else
#define RegWinStationQuery RegWinStationQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegConsoleShadowQueryA( HANDLE hServer,
                     PWINSTATIONNAMEA pWinStationName,
                     PWDPREFIXA pWdPrefixName,
                     PWINSTATIONCONFIG2A pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );

LONG WINAPI
RegConsoleShadowQueryW( HANDLE hServer,
                     PWINSTATIONNAMEW pWinStationName,
                     PWDPREFIXW pWdPrefixName,
                     PWINSTATIONCONFIG2W pWinStationConfig,
                     ULONG WinStationConfigLength,
                     PULONG pReturnLength );

#ifdef UNICODE
#define RegConsoleShadowQuery RegConsoleShadowQueryW
#else
#define RegConsoleShadowQuery RegConsoleShadowQueryA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationDeleteW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName
    );

LONG WINAPI
RegWinStationDeleteA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName
    );

#ifdef UNICODE
#define RegWinStationDelete RegWinStationDeleteW
#else
#define RegWinStationDelete RegWinStationDeleteA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationSetSecurityW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength
    );

LONG WINAPI
RegWinStationSetSecurityA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength
    );

#ifdef UNICODE
#define RegWinStationSetSecurity RegWinStationSetSecurityW
#else
#define RegWinStationSetSecurity RegWinStationSetSecurityA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQuerySecurityW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    PULONG SecurityDescriptorLengthRequired
    );

LONG WINAPI
RegWinStationQuerySecurityA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    PULONG SecurityDescriptorLengthRequired
    );

#ifdef UNICODE
#define RegWinStationQuerySecurity RegWinStationQuerySecurityW
#else
#define RegWinStationQuerySecurity RegWinStationQuerySecurityA
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryDefaultSecurity(
    HANDLE hServer,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    ULONG SecurityDescriptorLength,
    PULONG SecurityDescriptorLengthRequired
    );

/*------------------------------------------------*/

LONG WINAPI
RegWinStationSetNumValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    ULONG ValueData
    );

#ifdef UNICODE
#define RegWinStationSetNumValue RegWinStationSetNumValueW
#else
#define RegWinStationSetNumValue
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryNumValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PULONG pValueData );

#ifdef UNICODE
#define RegWinStationQueryNumValue RegWinStationQueryNumValueW
#else
#define RegWinStationQueryNumValue
#endif /* UNICODE */

/*------------------------------------------------*/

LONG WINAPI
RegWinStationQueryValueW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    LPWSTR pValueName,
    PVOID pValueData,
    ULONG ValueSize,
    PULONG pValueSize );

#ifdef UNICODE
#define RegWinStationQueryValue RegWinStationQueryValueW
#else
#define RegWinStationQueryValue
#endif /* UNICODE */

/*------------------------------------------------*/


/*********************************************
 *  Registry APIs for User Configuration Data
 *********************************************/

/*------------------------------------------------*/

BOOLEAN     RegGetUserPolicy( LPWSTR userSID, PPOLICY_TS_USER pPolicy , PUSERCONFIGW pData );
void        RegGetMachinePolicy( PPOLICY_TS_MACHINE pPolicy );

void        RegMergeMachinePolicy( PPOLICY_TS_MACHINE pPolicy, USERCONFIGW *pMachineConfigData ,
                PWINSTATIONCREATE   pCreate  );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigSet(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength
    );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigQuery(
    WCHAR * pServerName,
    WCHAR * pUserName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigDelete(
    WCHAR * pServerName,
    WCHAR * pUserName
    );

/*------------------------------------------------*/

LONG WINAPI
RegUserConfigRename(
    WCHAR * pServerName,
    WCHAR * pUserOldName,
    WCHAR * pUserNewName
    );

/*------------------------------------------------*/

LONG WINAPI
RegDefaultUserConfigQueryW(
    WCHAR * pServerName,
    PUSERCONFIGW pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    );

LONG WINAPI
RegDefaultUserConfigQueryA(
    CHAR * pServerName,
    PUSERCONFIGA pUserConfig,
    ULONG UserConfigLength,
    PULONG pReturnLength
    );

#ifdef UNICODE
#define RegDefaultUserConfigQuery RegDefaultUserConfigQueryW
#else
#define RegDefaultUserConfigQuery RegDefaultUserConfigQueryA
#endif /* UNICODE */

/*------------------------------------------------*/


/*********************************************
 *  Additional Support Registry APIs
 *********************************************/

BOOLEAN WINAPI
RegIsTServer(
    WCHAR * pServerName
    );

BOOLEAN WINAPI
RegBuildNumberQuery(
    PULONG pBuildNum
    );

BOOLEAN WINAPI
RegGetTServerVersion(
    WCHAR * pServerName,
    PULONG  pVersionNumber
    );


BOOLEAN WINAPI
RegQueryOEMId(
    BYTE *,
    ULONG
    );

typedef struct _PROGRAMCALL {
    struct _PROGRAMCALL *pFirst;        /* Points to first item in sorted list */
    struct _PROGRAMCALL *pNext;         /* Points to next item in sorted list */
    BOOLEAN  fAlias;                    /* TRUE if commmand is an alias (hidden) */
    LPWSTR   pRegistryMultiString;      /* Command info from registry */
    USHORT   CommandLen;                /* min chars needed for command */
    PWCHAR   Command;                   /* command string */
    PWCHAR   Program;                   /* name of program to execute */
    PWCHAR   Args;                      /* extra args to put on command line */
} PROGRAMCALL, /*FAR*/ *PPROGRAMCALL;

LONG WINAPI
RegQueryUtilityCommandList(
    LPWSTR pUtilityKey,
    PPROGRAMCALL * ppProgramCall
    );

LONG WINAPI
RegFreeUtilityCommandList(
    PPROGRAMCALL pProgramCall
    );

BOOLEAN WINAPI
RegIsMachinePolicyAllowHelp();

/*------------------------------------------------*/


/***********************************
 *  APIs for Window Station Objects
 ***********************************/

/*------------------------------------------------*/

HANDLE WINAPI
WinStationOpenServerW(
    LPWSTR  pServerName
    );

HANDLE WINAPI
WinStationOpenServerA(
    LPSTR  pServerName
    );

#ifdef UNICODE
#define WinStationOpenServer WinStationOpenServerW
#else
#define WinStationOpenServer WinStationOpenServerA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationCloseServer(
    HANDLE  hServer
    );

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationServerPing(
    HANDLE  hServer
    );

/*------------------------------------------------*/

typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATEW)(HANDLE,PLOGONIDW *,PULONG);
typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATEA)(HANDLE,PLOGONIDA *,PULONG);

BOOLEAN WINAPI
WinStationEnumerateW(
    HANDLE  hServer,
    PLOGONIDW *ppLogonId,
    PULONG  pEntries
    );

BOOLEAN WINAPI
WinStationEnumerateA(
    HANDLE  hServer,
    PLOGONIDA *ppLogonId,
    PULONG  pEntries
    );

#ifdef UNICODE
#define WinStationEnumerate WinStationEnumerateW
#else
#define WinStationEnumerate WinStationEnumerateA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATE_INDEXEDW)(HANDLE,PULONG,PLOGONIDW,PULONG,PULONG);
typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATE_INDEXEDA)(HANDLE,PULONG,PLOGONIDA,PULONG,PULONG);

BOOLEAN WINAPI
WinStationEnumerate_IndexedW(
    HANDLE  hServer,
    PULONG  pEntries,
    PLOGONIDW pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    );

BOOLEAN WINAPI
WinStationEnumerate_IndexedA(
    HANDLE  hServer,
    PULONG  pEntries,
    PLOGONIDA pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    );

#ifdef UNICODE
#define WinStationEnumerate_Indexed WinStationEnumerate_IndexedW
#else
#define WinStationEnumerate_Indexed WinStationEnumerate_IndexedA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationEnumerateProcesses(
    HANDLE  hServer,
    PVOID *ppProcessBuffer
    );

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationGetAllProcesses(
                          HANDLE    hServer,
                          ULONG     Level,
                          ULONG    *pNumberOfProcesses,
                          PVOID    *ppProcessArray
                          );

/*------------------------------------------------*/

#ifdef _WINBASE_
BOOLEAN WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        DWORD    ProcessId,
        FILETIME ProcessStartTime,
        PBYTE    pProcessUserSid,
        DWORD    *pdwSidSize
        );
#else
BOOLEAN WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        ULONG    ProcessId,
        LARGE_INTEGER   ProcessStartTime,
        PUCHAR    pProcessUserSid,
        ULONG    *pdwSidSize
        );
#endif

BOOLEAN WINAPI
WinStationRenameW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationNameOld,
    PWINSTATIONNAMEW pWinStationNameNew
    );

BOOLEAN WINAPI
WinStationRenameA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationNameOld,
    PWINSTATIONNAMEA pWinStationNameNew
    );

#ifdef UNICODE
#define WinStationRename WinStationRenameW
#else
#define WinStationRename WinStationRenameA
#endif /* UNICODE */

/*------------------------------------------------*/

typedef BOOLEAN (WINAPI * PWINSTATIONQUERYINFORMATIONW)(HANDLE,ULONG,WINSTATIONINFOCLASS,PVOID,ULONG,PULONG);
typedef BOOLEAN (WINAPI * PWINSTATIONQUERYINFORMATIONA)(HANDLE,ULONG,WINSTATIONINFOCLASS,PVOID,ULONG,PULONG);

BOOLEAN WINAPI
WinStationQueryInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

BOOLEAN WINAPI
WinStationQueryInformationA(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

#ifdef UNICODE
#define WinStationQueryInformation WinStationQueryInformationW
#else
#define WinStationQueryInformation WinStationQueryInformationA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationSetInformationW(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID pWinStationInformation,
    ULONG WinStationInformationLength
    );

BOOLEAN WINAPI
WinStationSetInformationA(
    HANDLE hServer,
    ULONG LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID pWinStationInformation,
    ULONG WinStationInformationLength
    );

#ifdef UNICODE
#define WinStationSetInformation WinStationSetInformationW
#else
#define WinStationSetInformation WinStationSetInformationA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationGetLanAdapterNameW(
    HANDLE hServer,
    ULONG LanAdapter,
    ULONG pdNameLength,
    PWCHAR pPdName,
    ULONG *pLength,
    PWCHAR *ppLanAdapter
    );

BOOLEAN WINAPI
WinStationGetLanAdapterNameA(
    HANDLE hServer,
    ULONG LanAdapter,
    ULONG pdNameLength,
    PCHAR pPdName,
    ULONG *pLength,
    PCHAR *ppLanAdapter
    );

#ifdef UNICODE
#define WinStationGetLanAdapterName WinStationGetLanAdapterNameW
#else
#define WinStationGetLanAdapterName WinStationGetLanAdapterNameA
#endif /* UNICODE */


/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationSendMessageW(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR  pTitle,
    ULONG TitleLength,
    LPWSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    );

BOOLEAN WINAPI
WinStationSendMessageA(
    HANDLE hServer,
    ULONG LogonId,
    LPSTR  pTitle,
    ULONG TitleLength,
    LPSTR  pMessage,
    ULONG MessageLength,
    ULONG Style,
    ULONG Timeout,
    PULONG pResponse,
    BOOLEAN DoNotWait
    );

#ifdef UNICODE
#define WinStationSendMessage WinStationSendMessageW
#else
#define WinStationSendMessage WinStationSendMessageA
#endif /* UNICODE */


/*
 *  These are new pResponse values
 */
#define IDTIMEOUT        32000  // The MsgBox timed out before a user response
#define IDASYNC          32001  // The request was for an Async message box, no return
#define IDERROR          32002  // an error occured that resulted in not displaying
#define IDCOUNTEXCEEDED  32003  // to many in queue for winstation already
#define IDDESKTOPERROR   32004  // current desktop is not default


/*------------------------------------------------*/

BOOLEAN WINAPI
LogonIdFromWinStationNameW(
    HANDLE hServer,
    PWINSTATIONNAMEW pWinStationName,
    PULONG pLogonId
    );

BOOLEAN WINAPI
LogonIdFromWinStationNameA(
    HANDLE hServer,
    PWINSTATIONNAMEA pWinStationName,
    PULONG pLogonId
    );

#ifdef UNICODE
#define LogonIdFromWinStationName LogonIdFromWinStationNameW
#else
#define LogonIdFromWinStationName LogonIdFromWinStationNameA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationNameFromLogonIdW(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONNAMEW pWinStationName
    );

BOOLEAN WINAPI
WinStationNameFromLogonIdA(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONNAMEA pWinStationName
    );

#ifdef UNICODE
#define WinStationNameFromLogonId WinStationNameFromLogonIdW
#else
#define WinStationNameFromLogonId WinStationNameFromLogonIdA
#endif /* UNICODE */

/*------------------------------------------------*/

BOOLEAN WINAPI
WinStationConnectW(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PWCHAR pPassword,
    BOOLEAN bWait
    );

BOOLEAN WINAPI
WinStationConnectA(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PCHAR pPassword,
    BOOLEAN bWait
    );

#ifdef UNICODE
#define WinStationConnect WinStationConnectW
#else
#define WinStationConnect WinStationConnectA
#endif /* UNICODE */

/*------------------------------------------------*/


HANDLE WINAPI
WinStationVirtualOpen(
    HANDLE hServer,
    ULONG LogonId,
    PVIRTUALCHANNELNAME pVirtualChannelName    /* ascii name */
    );

typedef HANDLE (WINAPI * PWINSTATIONBEEPOPEN)(ULONG);
HANDLE WINAPI
_WinStationBeepOpen(
    ULONG LogonId
    );

BOOLEAN WINAPI
WinStationDisconnect(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    );


BOOLEAN WINAPI
WinStationReset(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    );

BOOLEAN WINAPI
WinStationShadowStop(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    );

BOOLEAN WINAPI
WinStationShutdownSystem(
    HANDLE hServer,
    ULONG ShutdownFlags
    );

#define WSD_LOGOFF      0x00000001  // force WinStations to logoff
#define WSD_SHUTDOWN    0x00000002  // shutdown system
#define WSD_REBOOT      0x00000004  // reboot after shutdown
#define WSD_POWEROFF    0x00000008  // reboot after shutdown
#define WSD_FASTREBOOT  0x00000010  // CTRL-SHIFT-ALT-DEL fast reboot


typedef BOOLEAN (WINAPI * PWINSTATIONWAITSYSTEMEVENT)(HANDLE,ULONG,PULONG);

BOOLEAN WINAPI
WinStationWaitSystemEvent(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    );


BOOLEAN WINAPI
WinStationShadow(
    HANDLE hServer,
    PWSTR pTargetServerName,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    );


typedef BOOLEAN (WINAPI * PWINSTATIONFREEMEMORY)( PVOID );

BOOLEAN WINAPI
WinStationFreeMemory(
    PVOID  pBuffer
    );

BOOLEAN WINAPI
WinStationFreeGAPMemory(
    ULONG   Level,
    PVOID   ProcessArray,
    ULONG   NbProcesses
    );

BOOLEAN WINAPI
WinStationTerminateProcess(
    HANDLE hServer,
    ULONG ProcessId,
    ULONG ExitCode
    );

BOOLEAN WINAPI
WinStationNtsdDebug(
    ULONG LogonId,
    LONG  ProcessId,
    ULONG DbgProcessId,
    ULONG DbgThreadId,
    PVOID AttachCompletionRoutine
    );

BOOLEAN WINAPI
_WinStationCallback(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR pPhoneNumber
    );

BOOLEAN WINAPI
_WinStationBreakPoint(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN KernelFlag
    );

BOOLEAN WINAPI
_WinStationReadRegistry(
    HANDLE  hServer
    );

BOOLEAN WINAPI
_WinStationUpdateSettings(
    HANDLE hServer,
    WINSTATIONUPDATECFGCLASS SettingsClass,
    ULONG SettingsParameters
    );

BOOLEAN WINAPI
_WinStationWaitForConnect(
    VOID
    );


BOOLEAN WINAPI
_WinStationNotifyLogon(
    BOOLEAN fUserIsAdmin,
    HANDLE UserToken,
    PWCHAR pDomain,
    PWCHAR pUserName,
    PWCHAR pPassword,
    UCHAR Seed,
    PUSERCONFIGW pUserConfig
    );


BOOLEAN WINAPI
_WinStationNotifyLogoff(
    VOID
    );

BOOLEAN WINAPI
_WinStationNotifyNewSession(
    HANDLE hServer,
    ULONG  LogonId
    );

BOOLEAN WINAPI
_WinStationGetApplicationInfo(
    HANDLE hServer,
    ULONG  LogonId,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    );

BOOLEAN WINAPI
_WinStationCheckForApplicationName(
    HANDLE hServer,
    ULONG  LogonId,
    PWCHAR pUserName,
    ULONG  UserNameSize,
    PWCHAR pDomain,
    ULONG  DomainSize,
    PWCHAR pPassword,
    ULONG  *pPasswordSize,
    ULONG  MaxPasswordSize,
    PCHAR  pSeed,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    );

BOOLEAN WINAPI
_WinStationReInitializeSecurity(
    HANDLE  hServer
    );

BOOLEAN WINAPI
_WinStationUpdateClientCachedCredentials(
    PWCHAR pDomain,
    PWCHAR pUserName
    );
    
BOOLEAN WINAPI
_WinStationFUSCanRemoteUserDisconnect(
    ULONG  LogonId,
    PWCHAR pDomain,
    PWCHAR pUserName
    );
    
BOOLEAN WINAPI
WinStationCheckLoopBack(
    HANDLE hServer,
    ULONG ClientSessionId,
    ULONG TargetLogonId,
    LPWSTR pTargetServerName
    );

BOOLEAN WINAPI
_WinStationNotifyDisconnectPipe(
    VOID
    );
        

/*******************************************************************
 *  WinStation APIs for Generic Licensing
 *  (The WinStation extension DLL determines actual implementation)
 *******************************************************************/

BOOLEAN WINAPI
WinStationGenerateLicense(
    HANDLE hServer,
    PWCHAR pSerialNumberString,
    PVOID pLicense,
    ULONG LicenseSize
    );

BOOLEAN WINAPI
WinStationInstallLicense(
    HANDLE hServer,
    PVOID pLicense,
    ULONG LicenseSize
    );

typedef BOOLEAN (WINAPI * PWINSTATIONENUMERATELICENSES)( HANDLE, PCHAR *, ULONG * );

BOOLEAN WINAPI
WinStationEnumerateLicenses(
    HANDLE hServer,
    PVOID *ppLicense,
    ULONG  *pEntries
    );

BOOLEAN WINAPI
WinStationActivateLicense(
    HANDLE hServer,
    PVOID pLicense,
    ULONG  LicenseSize,
    PWCHAR pActivationCode
    );

BOOLEAN WINAPI
WinStationRemoveLicense(
    HANDLE hServer,
    PVOID pLicense,
    ULONG  LicenseSize
    );

BOOLEAN WINAPI
WinStationSetPoolCount(
    HANDLE hServer,
    PVOID pLicense,
    ULONG  LicenseSize
    );


BOOLEAN WINAPI
WinStationQueryLicense(
    HANDLE hServer,
    PVOID pLicenseCounts,
    ULONG ByteCount
    );

BOOLEAN WINAPI
WinStationQueryUpdateRequired(
    HANDLE hServer,
    PULONG pUpdateFlag
    );

BOOLEAN WINAPI
_WinStationAnnoyancePopup(
    HANDLE hServer,
    ULONG LogonId
    );

BOOLEAN WINAPI
WinStationGetTermSrvCountersValue(
    HANDLE hServer,
    ULONG  dwEntries,
    PVOID  pCounter
    );

#ifdef _WINBASE_
LONG WINAPI
WinStationBroadcastSystemMessage( 
        HANDLE  hServer,
        BOOL    sendToAllWinstations,
        ULONG   sessionID,     
        ULONG   timeOut,
        DWORD   dwFlags,            
        DWORD   *lpdwRecipients,   
        ULONG   uiMessage,           
        WPARAM  wParam,            
        LPARAM  lParam, 
        LONG    *pResponse        
    );

LONG WINAPI
WinStationSendWindowMessage(
        HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,        
        ULONG   Msg,         
        WPARAM  wParam,      
        LPARAM  lParam,      
        LONG    *pResponse
  );
  
  
BOOLEAN    WinStationGetMachinePolicy (
        HANDLE              hServer,
        POLICY_TS_MACHINE   *pPolicy
    );
#endif

//
//  This API consolidates the previous two APIs used by Winlogon to retrieve
//  auto-logon credentials. It is hardcoded to use the local server only, for
//  the caller's session only. Is is UNICODE only, as well. The parameter is
//  actually a PWLX_CLIENT_CREDENTIALS_INFO of at least version 2.
//

#ifdef _WINBASE_

#include <winwlx.h>

BOOLEAN WINAPI
WinStationQueryLogonCredentialsW(
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    );


/* __CONSOLE_NOTIFY__ */
BOOL WINAPI
WinStationRegisterConsoleNotification (
                HANDLE  hServer,
                HWND    hWnd,
                DWORD   dwFlags
 );

BOOL WINAPI
WinStationUnRegisterConsoleNotification (
                HANDLE  hServer,
                HWND    hWnd
 );
/* __CONSOLE_NOTIFY__ */
#endif // _WINBASE_        // handle rdpwd including this

//-----------------------------------------------------------------------------
//
// The following APIs are only for supporting a 5.1 client to 5.0 server
// connection. On a 5.1 server, ERROR_INVALID_FUNCTION will be returned.
//
//-----------------------------------------------------------------------------

BOOLEAN WINAPI
ServerGetInternetConnectorStatus(
    HANDLE   hServer,
    ULONG *pResult,
    PBOOLEAN pfEnabled
    );


BOOLEAN WINAPI
ServerSetInternetConnectorStatus(
    HANDLE   hServer,
    ULONG *pResult,
    BOOLEAN  fEnabled
    );

/*-ServerQueryInetConnectorInformation-------------*/

BOOLEAN WINAPI
ServerQueryInetConnectorInformationW(
    HANDLE hServer,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

BOOLEAN WINAPI
ServerQueryInetConnectorInformationA(
    HANDLE hServer,
    PVOID  pWinStationInformation,
    ULONG WinStationInformationLength,
    PULONG  pReturnLength
    );

#ifdef UNICODE
#define ServerQueryInetConnectorInformation ServerQueryInetConnectorInformationW
#else
#define ServerQueryInetConnectorInformation ServerQueryInetConnectorInformationA
#endif /* UNICODE */

/*-------------------------------------------------*/

//
//  Surround these APIs with a check for winbase.h. Termdd is including this
//  file, but doesn't understand winbase types (DWORD).
//

#ifdef _WINBASE_

HANDLE WINAPI
ServerLicensingOpenW(
    LPWSTR pszServerName
    );

HANDLE WINAPI
ServerLicensingOpenA(
    LPSTR pszServerName
    );

#ifdef UNICODE
#define ServerLicensingOpen ServerLicensingOpenW
#else
#define ServerLicensingOpen ServerLicensingOpenA
#endif

VOID WINAPI
ServerLicensingClose(
    HANDLE hServer
    );

BOOLEAN WINAPI
ServerLicensingLoadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    );

BOOLEAN WINAPI
ServerLicensingUnloadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    );

DWORD WINAPI
ServerLicensingSetPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    LPDWORD lpNewPolicyStatus
    );

BOOLEAN WINAPI
ServerLicensingGetAvailablePolicyIds(
    HANDLE hServer,
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    );

BOOLEAN WINAPI
ServerLicensingGetPolicy(
    HANDLE hServer,
    PULONG pulPolicyId
    );

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationW(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationA(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

VOID
ServerLicensingFreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

BOOLEAN
WinStationConnectCallback(
    HANDLE hServer,
    DWORD  Timeout,
    ULONG  AddressType,
    PBYTE  pAddress,
    ULONG  AddressSize
    );

#ifdef UNICODE
#define ServerLicensingGetPolicyInformation ServerLicensingGetPolicyInformationW
#else
#define ServerLicensingGetPolicyInformation ServerLicensingGetPolicyInformationA
#endif

BOOLEAN WINAPI
ServerLicensingDeactivateCurrentPolicy(
    HANDLE hServer
    );

#endif  // _WINBASE_

BOOLEAN WINAPI
WinStationIsHelpAssistantSession(
    HANDLE hServer,
    ULONG SessionId
);

BOOLEAN WINAPI
RemoteAssistancePrepareSystemRestore(
    HANDLE hServer
);

ULONG WINAPI
WinStationAutoReconnect(
    ULONG flags
    );

#ifdef __cplusplus
}
#endif

#endif  /* !_INC_WINSTAH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\aimm12.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for aimm12.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __aimm12_h__
#define __aimm12_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimm12_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimm12.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM 1.2 Interfaces.

EXTERN_C const CLSID CLSID_CActiveIMM12;
EXTERN_C const CLSID CLSID_CActiveIMM12_Trident;
#define AIMM12_PROCESS_ATOM     TEXT("_AIMM12_PROCESS_ATOM_")
#if 0
typedef WORD LANGID;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    } 	REGISTERWORDA;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    } 	REGISTERWORDW;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	CANDIDATEFORM;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	COMPOSITIONFORM;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    } 	CANDIDATELIST;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    } 	STYLEBUFA;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    } 	STYLEBUFW;

typedef WORD ATOM;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOA;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm12_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOW;

#endif
#if !defined(_DDKIMM_H_) && !defined(_IMM_DDK_DEFINED_)
typedef /* [public] */ struct __MIDL___MIDL_itf_aimm12_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        } 	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    } 	INPUTCONTEXT;

typedef /* [public] */ struct __MIDL___MIDL_itf_aimm12_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    } 	IMEINFO;

#endif


extern RPC_IF_HANDLE __MIDL_itf_aimm12_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimm12_0000_v0_0_s_ifspec;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordA * This,
            /* [out] */ IEnumRegisterWordA **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA * This,
    /* [out] */ IEnumRegisterWordA **ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordW * This,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW * This,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInputContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInputContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumInputContext * This,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputContext_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched)

#define IEnumInputContext_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputContext_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInputContext_Clone_Proxy( 
    IEnumInputContext * This,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IEnumInputContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Next_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ HIMC *rgInputContext,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumInputContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Reset_Proxy( 
    IEnumInputContext * This);


void __RPC_STUB IEnumInputContext_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Skip_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumInputContext_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ const MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMMessagePumpOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ const MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveIMMMessagePumpOwner * This,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    (This)->lpVtbl -> Pause(This,pdwCookie)

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    (This)->lpVtbl -> Resume(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ const MSG *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Pause_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Resume_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMApp * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMApp * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMApp * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMApp_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContextEx_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMApp_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DisableIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMApp_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumInputContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMApp_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\termsrv\inc\wstmsg.h ===
/*************************************************************************
*
* wstmsg.h
*
* Session Manager Window Station API Messages
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*************************************************************************/

#ifndef WINAPI
#define WINAPI      __stdcall
#endif

#define CITRIX_WINSTATIONAPI_VERSION  1

#define WINSTATIONAPI_PORT_MEMORY_SIZE 0x2000 // 8K will hold everything

/*
 * Define WinStation control port name
 */
#define WINSTATION_CTRL_PORT_NAME L"\\WinStationCtrlPort"


#define DR_RECONNECT_DEVICE_NAMEW L"\\Device\\Video0"
#define DR_RECONNECT_DEVICE_NAMEA "\\Device\\Video0"

//
// This is the ConnectInfo structure passed at NtConnectPort() time
// so that the server can verify our access rights.
//
typedef struct _WINSTATIONAPI_CONNECT_INFO {
    ULONG    Version;
    ULONG    RequestedAccess;
    NTSTATUS AcceptStatus;
} WINSTATIONAPI_CONNECT_INFO, *PWINSTATIONAPI_CONNECT_INFO;


/*
 * WinStation APIs
 * The following APIs are processed by ICASRV or WIN32
 * depending on the API.  If you make any changes to this
 * table, be sure to update the corresponding API dispatch table
 * in both ICASRV and in Win32.
 */
typedef enum _WINSTATION_APINUMBER {
    SMWinStationCreate,
    SMWinStationReset,
    SMWinStationDisconnect,
    SMWinStationWCharLog,
    SMWinStationGetSMCommand,
    SMWinStationBrokenConnection,
    SMWinStationIcaReplyMessage,
    SMWinStationIcaShadowHotkey,
    SMWinStationDoConnect,
    SMWinStationDoDisconnect,
    SMWinStationDoReconnect,
    SMWinStationExitWindows,
    SMWinStationTerminate,
    SMWinStationNtSecurity,
    SMWinStationDoMessage,
    SMWinStationDoBreakPoint,
    SMWinStationThinwireStats,
    SMWinStationShadowSetup,
    SMWinStationShadowStart,
    SMWinStationShadowStop,
    SMWinStationShadowCleanup,
    SMWinStationPassthruEnable,
    SMWinStationPassthruDisable,
    SMWinStationSetTimeZone,
    SMWinStationInitialProgram,
    SMWinStationNtsdDebug,
    SMWinStationBroadcastSystemMessage,             // API for using Window's BroadcastSystemMessage()
    SMWinStationSendWindowMessage,                  // API for using WIndows's SendMessage()
    SMWinStationNotify,
    SMWinStationWindowInvalid,
    SMWinStationMaxApiNumber
} WINSTATION_APINUMBER;

/*
 * API function specific messages for WinStations
 */
typedef struct _WINSTATIONCREATEMSG {
    WINSTATIONNAME WinStationName;
    ULONG LogonId;
} WINSTATIONCREATEMSG;

typedef struct _WINSTATIONRESETMSG {
    ULONG LogonId;
} WINSTATIONRESETMSG;

typedef struct _WINSTATIONDISCONNECTMSG {
    ULONG LogonId;
} WINSTATIONDISCONNECTMSG;

typedef struct _WINSTATIONDODISCONNECTMSG {
    BOOLEAN ConsoleShadowFlag;
    ULONG NotUsed;
} WINSTATIONDODISCONNECTMSG;

typedef struct _WINSTATIONDOCONNECTMSG {
    BOOLEAN ConsoleShadowFlag;
    BOOLEAN fMouse;
    BOOLEAN fINetClient;
    BOOLEAN fInitialProgram;
    BOOLEAN fHideTitleBar;
    BOOLEAN fMaximize;
    HANDLE  hIcaVideoChannel;
    HANDLE  hIcaMouseChannel;
    HANDLE  hIcaKeyboardChannel;
    HANDLE  hIcaBeepChannel;
    HANDLE  hIcaCommandChannel;
    HANDLE  hIcaThinwireChannel;
    HANDLE  hDisplayChangeEvent;
    WINSTATIONNAME WinStationName;

    WCHAR   DisplayDriverName[9];
    WCHAR   ProtocolName[9];
    WCHAR   AudioDriverName[9];

    USHORT HRes;                   // are for dynamically changing
    USHORT VRes;                   // display resolution at reconnection.
    USHORT ColorDepth;
    USHORT ProtocolType;   // PROTOCOL_ICA or PROTOCOL_RDP
    BOOLEAN fClientDoubleClickSupport;
    BOOLEAN fEnableWindowsKey;

    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
} WINSTATIONDOCONNECTMSG;

typedef struct _WINSTATIONDORECONNECTMSG {
    BOOLEAN fMouse;
    BOOLEAN fINetClient;
    BOOLEAN fClientDoubleClickSupport;
    BOOLEAN fEnableWindowsKey;
    BOOLEAN fDynamicReconnect;      // Session can resize Display at reconnect
    WINSTATIONNAME WinStationName;
    WCHAR AudioDriverName[9];
    WCHAR   DisplayDriverName[9];
    WCHAR   ProtocolName[9];
    USHORT HRes;                    // are for dynamically changing
    USHORT VRes;                    // display resolution at reconnection.
    USHORT ColorDepth;
    USHORT ProtocolType;            // PROTOCOL_ICA or PROTOCOL_RDP

    ULONG KeyboardType;
    ULONG KeyboardSubType;
    ULONG KeyboardFunctionKey;
} WINSTATIONDORECONNECTMSG;


typedef enum _WINSTATIONNOTIFYEVENT {
    WinStation_Notify_Disconnect,
    WinStation_Notify_Reconnect,
    WinStation_Notify_PreReconnect,
    WinStation_Notify_SyncDisconnect,
    WinStation_Notify_DisableScrnSaver,
    WinStation_Notify_EnableScrnSaver,
    WinStation_Notify_PreReconnectDesktopSwitch,
    WinStation_Notify_HelpAssistantShadowStart,
    WinStation_Notify_HelpAssistantShadowFinish,
    WinStation_Notify_DisconnectPipe
} WINSTATIONNOTIFYEVENT;

typedef struct _WINSTATIONWINDOWINVALIDMSG {
    ULONG hWnd;
    ULONG SessionId;
} WINSTATIONWINDOWINVALIDMSG;

typedef struct _WINSTATIONDONOTIFYMSG {
    WINSTATIONNOTIFYEVENT NotifyEvent;
} WINSTATIONDONOTIFYMSG;

typedef struct _WINSTATIONTHINWIRESTATSMSG {
    CACHE_STATISTICS Stats;
} WINSTATIONTHINWIRESTATSMSG;

typedef struct _WINSTATIONEXITWINDOWSMSG {
    ULONG Flags;
} WINSTATIONEXITWINDOWSMSG;

typedef struct _WINSTATIONSENDMESSAGEMSG {
    LPWSTR pTitle;
    ULONG  TitleLength;
    LPWSTR pMessage;
    ULONG  MessageLength;
    ULONG  Style;
    ULONG  Timeout;
    ULONG  Response;
    PULONG pResponse;
    BOOLEAN DoNotWait;
    HANDLE hEvent;
} WINSTATIONSENDMESSAGEMSG;

typedef struct _WINSTATIONREPLYMESSAGEMSG {
    ULONG  Response;
    PULONG pResponse;
    HANDLE hEvent;
} WINSTATIONREPLYMESSAGEMSG;

typedef struct _WINSTATIONTERMINATEMSG {
    ULONG NotUsed;
} WINSTATIONTERMINATEMSG;

typedef struct _WINSTATIONNTSDDEBUGMSG {
    ULONG LogonId;
    LONG ProcessId;
    CLIENT_ID ClientId;
    PVOID AttachCompletionRoutine;
} WINSTATIONNTSDDEBUGMSG, *PWINSTATIONNTSDDEBUGMSG;

typedef struct _WINSTATIONBREAKPOINTMSG {
    BOOLEAN KernelFlag;
} WINSTATIONBREAKPOINTMSG;

typedef struct _WINSTATIONSHADOWSETUPMSG {
    ULONG NotUsed;
} WINSTATIONSHADOWSETUPMSG;

typedef struct _WINSTATIONSHADOWSTARTMSG {
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
} WINSTATIONSHADOWSTARTMSG;

typedef struct _WINSTATIONSHADOWSTOPMSG {
    ULONG NotUsed;
} WINSTATIONSHADOWSTOPMSG;

typedef struct _WINSTATIONSHADOWCLEANUPMSG {
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
} WINSTATIONSHADOWCLEANUPMSG;

typedef struct _WINSTATIONBROKENCONNECTIONMSG {
    ULONG Reason;  // reason for broken connection (BROKENCLASS)
    ULONG Source;  // source for broken connection (BROKENSOURCECLASS)
} WINSTATIONBROKENCONNECTIONMSG;

typedef struct _WINSTATIONWCHARLOG {
    WCHAR Buffer[100];
} WINSTATIONWCHARLOG;

// This data structure included all params used by window's BroadcastSystemMessage
// Use this APIto send a message to all windows of a winstation.
typedef struct _WINSTATIONBROADCASTSYSTEMMSG {
  DWORD     dwFlags;
  DWORD     dwRecipients;   
  UINT      uiMessage;           
  WPARAM    wParam;            
  LPARAM    lParam;            
  PVOID     dataBuffer;
  ULONG     bufferSize;
  HANDLE    hEvent;
  ULONG     Response;
} WINSTATIONBROADCASTSYSTEMMSG;

// This data structure has all the params used by window's standard SendMessage()API.
// Use this API to send a message to a specific hwnd of a winstation ( you need to know that the appropriate hwnd was)
typedef struct _WINSTATIONSENDWINDOWMSG {
  HWND      hWnd;           // handle of destination window
  UINT      Msg;            // message to send
  WPARAM    wParam;         // first message parameter
  LPARAM    lParam;         // second message parameter
  PCHAR     dataBuffer;
  ULONG     bufferSize;
  HANDLE    hEvent;
  ULONG     Response;
} WINSTATIONSENDWINDOWMSG;

typedef struct _WINSTATIONSETTIMEZONE {
    TS_TIME_ZONE_INFORMATION TimeZone;
} WINSTATIONSETTIMEZONE;

typedef struct _WINSTATION_APIMSG {
    PORT_MESSAGE h;
    ULONG MessageId;
    WINSTATION_APINUMBER ApiNumber;
    BOOLEAN WaitForReply;
    NTSTATUS ReturnedStatus;
    union {
        WINSTATIONCREATEMSG Create;
        WINSTATIONRESETMSG Reset;
        WINSTATIONDISCONNECTMSG Disconnect;
        WINSTATIONWCHARLOG WCharLog;
        WINSTATIONREPLYMESSAGEMSG ReplyMessage;
        WINSTATIONDODISCONNECTMSG DoDisconnect;
        WINSTATIONDOCONNECTMSG DoConnect;
        WINSTATIONEXITWINDOWSMSG ExitWindows;
        WINSTATIONTERMINATEMSG Terminate;
        WINSTATIONSENDMESSAGEMSG SendMessage;
        WINSTATIONBREAKPOINTMSG BreakPoint;
        WINSTATIONDORECONNECTMSG DoReconnect;
        WINSTATIONTHINWIRESTATSMSG ThinwireStats;
        WINSTATIONSHADOWSETUPMSG ShadowSetup;
        WINSTATIONSHADOWSTARTMSG ShadowStart;
        WINSTATIONSHADOWSTOPMSG ShadowStop;
        WINSTATIONSHADOWCLEANUPMSG ShadowCleanup;
        WINSTATIONBROKENCONNECTIONMSG Broken;
        WINSTATIONNTSDDEBUGMSG NtsdDebug;
        WINSTATIONBROADCASTSYSTEMMSG        bMsg; // API for Window's BroadcastSystemMessage()
        WINSTATIONSENDWINDOWMSG             sMsg; // API  for WIndows's SendMessage()
        WINSTATIONSETTIMEZONE SetTimeZone;
        WINSTATIONDONOTIFYMSG DoNotify;
        WINSTATIONWINDOWINVALIDMSG WindowInvalid;
    } u;
} WINSTATION_APIMSG, *PWINSTATION_APIMSG;


/*
 * WinStation Kernel object interface routines. These provide a common
 * interface to the Nt* API's for the object that can be used by the
 * Session manager, the WinStation client DLL, and the CSRSS subsystem.
 */

/*
 * WinStation kernel object root directory name
 */

#define CITRIX_WINSTATION_OBJECT_DIRECTORY L"\\WinStations"

/*
 * OpenWinStationObject
 *
 *   Open the WinStation Kernel Object of the given Name.
 *
 *  ENTRY:
 *    Id
 *      Id of the WinStation Kernel Object to open. It will be under the path
 *      of "\WinStations\xxx" in the kernel object name space when
 *      created.
 *
 *    pHandle (output)
 *      Pointer to variable to place the handle if the object was created.
 *
 *  EXIT:
 *    Returns the NTSTATUS code from the operation.
 */
NTSTATUS
OpenWinStationObject( ULONG,
                      PHANDLE,
                      ULONG );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\cicsthkl.h ===
//
// cicsthkl.h
//
// Cicero Library to retreive the substitute keyboard layout of the 
// current active keyboard TIP.
//

//
// CicSubstGetKeyboardLayout
//
// If the current focus is on Cicero aware (including AIMM1.2
// or CUAS), This function returns the substitute HKL of
// the current active keyboard TIP. And the keyboard layout
// name of the hKL that is returned in pszKLID.
// If the current focus is not on Cicero aware, it just returns
// the current keyboard layout and keyboard layout name in 
// pszKLID.
// pszKLID can be NULL.
//
extern "C" HKL WINAPI CicSubstGetKeyboardLayout(char *pszKLID);

//
// CicSubstGetDefaultKeyboardLayout
//
// This function returns the substitute hKL of the default item
// of the given langage.
//
extern "C" HKL WINAPI CicSubstGetDefaultKeyboardLayout(LANGID langid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\avrfutil.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        avrfutil.h

    Abstract:

        Common headers for app verifier utility functions - used by the exe as well as the shims

    Revision History:

    08/26/2001  dmunsil     Created.


--*/

#pragma once

#ifndef _AVRFUTIL_H_
#define _AVRFUTIL_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>

#include <windows.h>
#include <prsht.h>
#include "shimdb.h"

namespace ShimLib
{
#define AV_BREAKIN  L"BreakOnLog"

BOOL SaveShimSettingDWORD(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    DWORD       dwSetting
    );

DWORD GetShimSettingDWORD(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    DWORD       dwDefault
    );

BOOL SaveShimSettingString(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    LPCWSTR     szValue
    );

BOOL GetShimSettingString(
    LPCWSTR     szShim,
    LPCWSTR     szExe,
    LPCWSTR     szSetting,
    LPWSTR      szResult,
    DWORD       dwBufferLen     // in WCHARs
    );

//
// Handy macro-like name extraction utility for property sheets
// NOTE: only works during WM_INITDIALOG!!!
//
inline LPCWSTR ExeNameFromLParam(LPARAM lParam)
{
    if (lParam) {
        LPCWSTR szRet = (LPCWSTR)(((LPPROPSHEETPAGE)lParam)->lParam);
        if (szRet) {
            return szRet;
        }
    }

    return AVRF_DEFAULT_SETTINGS_NAME_W;
}

//
// useful utility function for getting the current exe name during shim
// startup (so it extracts the correct settings)
//
inline LPWSTR GetCurrentExeName(LPWSTR szName, DWORD dwChars)
{
    HMODULE hMod = GetModuleHandle(NULL);
    if (!hMod) {
        return NULL;
    }

    WCHAR  szModule[MAX_PATH];
     
    DWORD dwC = GetModuleFileNameW(hMod, szModule, MAX_PATH);

    if (!dwC) {
        return NULL;
    }

    int nLen = (int)wcslen(szModule);
    for (int i = nLen - 1; i != -1; --i) {
        if (szModule[i] == L'\\') {
            break;
        }
    }
    ++i;
    wcsncpy(szName, &szModule[i], dwChars);
    szName[dwChars - 1] = 0;

    return szName;
}

}; // end of namespace ShimLib

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\aimmex.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for aimmex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __aimmex_h__
#define __aimmex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveIMMAppEx_FWD_DEFINED__
#define __IActiveIMMAppEx_FWD_DEFINED__
typedef interface IActiveIMMAppEx IActiveIMMAppEx;
#endif 	/* __IActiveIMMAppEx_FWD_DEFINED__ */


#ifndef __IAImmFnDocFeed_FWD_DEFINED__
#define __IAImmFnDocFeed_FWD_DEFINED__
typedef interface IAImmFnDocFeed IAImmFnDocFeed;
#endif 	/* __IAImmFnDocFeed_FWD_DEFINED__ */


#ifndef __IAImmThreadCompartment_FWD_DEFINED__
#define __IAImmThreadCompartment_FWD_DEFINED__
typedef interface IAImmThreadCompartment IAImmThreadCompartment;
#endif 	/* __IAImmThreadCompartment_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "aimm12.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimmex_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimmex.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMMEx Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_s_ifspec;

#ifndef __IActiveIMMAppEx_INTERFACE_DEFINED__
#define __IActiveIMMAppEx_INTERFACE_DEFINED__

/* interface IActiveIMMAppEx */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IActiveIMMAppEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7A6F58A-D478-44ab-86C9-591C23A26534")
    IActiveIMMAppEx : public IActiveIMMApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsGUIDMap( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidAtom( 
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnfilterClientWindowsEx( 
            /* [in] */ HWND hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMAppEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMAppEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMAppEx * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMAppEx * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsGUIDMap )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidAtom )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom);
        
        HRESULT ( STDMETHODCALLTYPE *UnfilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd);
        
        END_INTERFACE
    } IActiveIMMAppExVtbl;

    interface IActiveIMMAppEx
    {
        CONST_VTBL struct IActiveIMMAppExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMAppEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMAppEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMAppEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMAppEx_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMAppEx_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMAppEx_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMAppEx_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMAppEx_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMAppEx_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMAppEx_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMAppEx_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMAppEx_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMAppEx_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMAppEx_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMAppEx_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMAppEx_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMAppEx_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMAppEx_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMAppEx_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMAppEx_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMAppEx_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMAppEx_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMAppEx_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMAppEx_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMAppEx_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMAppEx_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMAppEx_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMAppEx_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMAppEx_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)


#define IActiveIMMAppEx_FilterClientWindowsEx(This,hWnd,fGuidMap)	\
    (This)->lpVtbl -> FilterClientWindowsEx(This,hWnd,fGuidMap)

#define IActiveIMMAppEx_FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)	\
    (This)->lpVtbl -> FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)

#define IActiveIMMAppEx_GetGuidAtom(This,hImc,bAttr,pGuidAtom)	\
    (This)->lpVtbl -> GetGuidAtom(This,hImc,bAttr,pGuidAtom)

#define IActiveIMMAppEx_UnfilterClientWindowsEx(This,hWnd)	\
    (This)->lpVtbl -> UnfilterClientWindowsEx(This,hWnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd,
    /* [in] */ BOOL fGuidMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsGUIDMap_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize,
    /* [in] */ BOOL *aaGildMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsGUIDMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_GetGuidAtom_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HIMC hImc,
    /* [in] */ BYTE bAttr,
    /* [out] */ TfGuidAtom *pGuidAtom);


void __RPC_STUB IActiveIMMAppEx_GetGuidAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_UnfilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB IActiveIMMAppEx_UnfilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMAppEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_aimmex_0224 */
/* [local] */ 

EXTERN_C const CLSID CLSID_CAImmLayer;


extern RPC_IF_HANDLE __MIDL_itf_aimmex_0224_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0224_v0_0_s_ifspec;

#ifndef __IAImmFnDocFeed_INTERFACE_DEFINED__
#define __IAImmFnDocFeed_INTERFACE_DEFINED__

/* interface IAImmFnDocFeed */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAImmFnDocFeed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e098993-9577-499a-a830-52344f3e200d")
    IAImmFnDocFeed : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DocFeed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearDocFeedBuffer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartReconvert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartUndoCompositionString( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAImmFnDocFeedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAImmFnDocFeed * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAImmFnDocFeed * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *DocFeed )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *ClearDocFeedBuffer )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconvert )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartUndoCompositionString )( 
            IAImmFnDocFeed * This);
        
        END_INTERFACE
    } IAImmFnDocFeedVtbl;

    interface IAImmFnDocFeed
    {
        CONST_VTBL struct IAImmFnDocFeedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAImmFnDocFeed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAImmFnDocFeed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAImmFnDocFeed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAImmFnDocFeed_DocFeed(This)	\
    (This)->lpVtbl -> DocFeed(This)

#define IAImmFnDocFeed_ClearDocFeedBuffer(This)	\
    (This)->lpVtbl -> ClearDocFeedBuffer(This)

#define IAImmFnDocFeed_StartReconvert(This)	\
    (This)->lpVtbl -> StartReconvert(This)

#define IAImmFnDocFeed_StartUndoCompositionString(This)	\
    (This)->lpVtbl -> StartUndoCompositionString(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_DocFeed_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_DocFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_ClearDocFeedBuffer_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_ClearDocFeedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartReconvert_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartReconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartUndoCompositionString_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartUndoCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAImmFnDocFeed_INTERFACE_DEFINED__ */


#ifndef __IAImmThreadCompartment_INTERFACE_DEFINED__
#define __IAImmThreadCompartment_INTERFACE_DEFINED__

/* interface IAImmThreadCompartment */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAImmThreadCompartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d251a968-2b44-4da5-a549-c1249ef01711")
    IAImmThreadCompartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetThreadCompartmentValue( 
            /* [in] */ REFGUID rguid,
            /* [in] */ VARIANT *pvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadCompartmentValue( 
            /* [in] */ REFGUID rguid,
            /* [out] */ VARIANT *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAImmThreadCompartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAImmThreadCompartment * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAImmThreadCompartment * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAImmThreadCompartment * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadCompartmentValue )( 
            IAImmThreadCompartment * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ VARIANT *pvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadCompartmentValue )( 
            IAImmThreadCompartment * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ VARIANT *pvar);
        
        END_INTERFACE
    } IAImmThreadCompartmentVtbl;

    interface IAImmThreadCompartment
    {
        CONST_VTBL struct IAImmThreadCompartmentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAImmThreadCompartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAImmThreadCompartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAImmThreadCompartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAImmThreadCompartment_SetThreadCompartmentValue(This,rguid,pvar)	\
    (This)->lpVtbl -> SetThreadCompartmentValue(This,rguid,pvar)

#define IAImmThreadCompartment_GetThreadCompartmentValue(This,rguid,pvar)	\
    (This)->lpVtbl -> GetThreadCompartmentValue(This,rguid,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAImmThreadCompartment_SetThreadCompartmentValue_Proxy( 
    IAImmThreadCompartment * This,
    /* [in] */ REFGUID rguid,
    /* [in] */ VARIANT *pvar);


void __RPC_STUB IAImmThreadCompartment_SetThreadCompartmentValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmThreadCompartment_GetThreadCompartmentValue_Proxy( 
    IAImmThreadCompartment * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ VARIANT *pvar);


void __RPC_STUB IAImmThreadCompartment_GetThreadCompartmentValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAImmThreadCompartment_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\conapi.h ===
#ifndef NOGDI

typedef struct _CONSOLE_GRAPHICS_BUFFER_INFO {
    DWORD dwBitMapInfoLength;
    LPBITMAPINFO lpBitMapInfo;
    DWORD dwUsage;
    HANDLE hMutex;
    PVOID lpBitMap;
} CONSOLE_GRAPHICS_BUFFER_INFO, *PCONSOLE_GRAPHICS_BUFFER_INFO;

#endif // NOGDI

#define CONSOLE_GRAPHICS_BUFFER  2

BOOL
WINAPI
InvalidateConsoleDIBits(
    IN HANDLE hConsoleOutput,
    IN PSMALL_RECT lpRect
    );

#define SYSTEM_ROOT_CONSOLE_EVENT 3

VOID
WINAPI
SetLastConsoleEventActive( VOID );

#define VDM_HIDE_WINDOW         1
#define VDM_IS_ICONIC           2
#define VDM_CLIENT_RECT         3
#define VDM_CLIENT_TO_SCREEN    4
#define VDM_SCREEN_TO_CLIENT    5
#define VDM_IS_HIDDEN           6
#define VDM_FULLSCREEN_NOPAINT  7
#if defined(FE_SB)
#define VDM_SET_VIDEO_MODE      8
#if defined(i386)
#define VDM_SAVE_RESTORE_HW_STATE 9
#define VDM_VIDEO_IOCTL         10

typedef struct _VDM_IOCTL_PARAM {
    DWORD  dwIoControlCode;
    LPVOID lpvInBuffer;
    DWORD  cbInBuffer;
    LPVOID lpvOutBuffer;
    DWORD  cbOutBuffer;
} VDM_IOCTL_PARAM, *LPVDM_IOCTL_PARAM;
#endif /* i386 */
#endif /* FE_SB */

BOOL
WINAPI
VDMConsoleOperation(
    IN DWORD iFunction,
    IN OUT LPVOID lpData
    );


BOOL
WINAPI
SetConsoleIcon(
    IN HICON hIcon
    );

//
// These console font APIs don't appear to be used anywhere. Maybe they
// should be removed.
//

BOOL
WINAPI
SetConsoleFont(
    IN HANDLE hConsoleOutput,
    IN DWORD nFont
    );

DWORD
WINAPI
GetConsoleFontInfo(
    IN HANDLE hConsoleOutput,
    IN BOOL bMaximumWindow,
    IN DWORD nLength,
    OUT PCONSOLE_FONT_INFO lpConsoleFontInfo
    );

DWORD
WINAPI
GetNumberOfConsoleFonts(
    VOID
    );

BOOL
WINAPI
SetConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN HCURSOR hCursor
    );

int
WINAPI
ShowConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN BOOL bShow
    );

HMENU
APIENTRY
ConsoleMenuControl(
    IN HANDLE hConsoleOutput,
    IN UINT dwCommandIdLow,
    IN UINT dwCommandIdHigh
    );

BOOL
SetConsolePalette(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    );

#define CONSOLE_FULLSCREEN_MODE 1
#define CONSOLE_WINDOWED_MODE 2

BOOL
APIENTRY
SetConsoleDisplayMode(
    IN HANDLE hConsoleOutput,
    IN DWORD dwFlags,
    OUT PCOORD lpNewScreenBufferDimensions
    );

#define CONSOLE_UNREGISTER_VDM 0
#define CONSOLE_REGISTER_VDM   1
#define CONSOLE_REGISTER_WOW   2

BOOL
APIENTRY
RegisterConsoleVDM(
    IN DWORD dwRegisterFlags,
    IN HANDLE hStartHardwareEvent,
    IN HANDLE hEndHardwareEvent,
    IN HANDLE hErrorhardwareEvent,
    IN DWORD Reserved,
    OUT LPDWORD lpStateLength,
    OUT PVOID *lpState,
    IN LPWSTR lpVDMBufferSectionName,
    IN DWORD dwVDMBufferSectionNameLength,
    IN COORD VDMBufferSize OPTIONAL,
    OUT PVOID *lpVDMBuffer
    );

BOOL
APIENTRY
GetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    OUT PCOORD lpResolution,
    OUT PCOORD lpFontSize
    );

BOOL
APIENTRY
SetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    IN COORD dwResolution,
    IN COORD dwFontSize
    );



//
// aliasing apis
//

BOOL
AddConsoleAliasA(
    IN LPSTR Source,
    IN LPSTR Target,
    IN LPSTR ExeName
    );
BOOL
AddConsoleAliasW(
    IN LPWSTR Source,
    IN LPWSTR Target,
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define AddConsoleAlias  AddConsoleAliasW
#else
#define AddConsoleAlias  AddConsoleAliasA
#endif // !UNICODE

DWORD
GetConsoleAliasA(
    IN LPSTR Source,
    OUT LPSTR TargetBuffer,
    IN DWORD TargetBufferLength,
    IN LPSTR ExeName
    );
DWORD
GetConsoleAliasW(
    IN LPWSTR Source,
    OUT LPWSTR TargetBuffer,
    IN DWORD TargetBufferLength,
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define GetConsoleAlias  GetConsoleAliasW
#else
#define GetConsoleAlias  GetConsoleAliasA
#endif // !UNICODE

DWORD
GetConsoleAliasesLengthA(
    IN LPSTR ExeName
    );
DWORD
GetConsoleAliasesLengthW(
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define GetConsoleAliasesLength  GetConsoleAliasesLengthW
#else
#define GetConsoleAliasesLength  GetConsoleAliasesLengthA
#endif // !UNICODE

DWORD
GetConsoleAliasExesLengthA( VOID );
DWORD
GetConsoleAliasExesLengthW( VOID );
#ifdef UNICODE
#define GetConsoleAliasExesLength  GetConsoleAliasExesLengthW
#else
#define GetConsoleAliasExesLength  GetConsoleAliasExesLengthA
#endif // !UNICODE

DWORD
GetConsoleAliasesA(
    OUT LPSTR AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPSTR ExeName
    );
DWORD
GetConsoleAliasesW(
    OUT LPWSTR AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define GetConsoleAliases  GetConsoleAliasesW
#else
#define GetConsoleAliases  GetConsoleAliasesA
#endif // !UNICODE

DWORD
GetConsoleAliasExesA(
    OUT LPSTR ExeNameBuffer,
    IN DWORD ExeNameBufferLength
    );
DWORD
GetConsoleAliasExesW(
    OUT LPWSTR ExeNameBuffer,
    IN DWORD ExeNameBufferLength
    );
#ifdef UNICODE
#define GetConsoleAliasExes  GetConsoleAliasExesW
#else
#define GetConsoleAliasExes  GetConsoleAliasExesA
#endif // !UNICODE

VOID
ExpungeConsoleCommandHistoryA(
    IN LPSTR ExeName
    );
VOID
ExpungeConsoleCommandHistoryW(
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define ExpungeConsoleCommandHistory  ExpungeConsoleCommandHistoryW
#else
#define ExpungeConsoleCommandHistory  ExpungeConsoleCommandHistoryA
#endif // !UNICODE

BOOL
SetConsoleNumberOfCommandsA(
    IN DWORD Number,
    IN LPSTR ExeName
    );
BOOL
SetConsoleNumberOfCommandsW(
    IN DWORD Number,
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define SetConsoleNumberOfCommands  SetConsoleNumberOfCommandsW
#else
#define SetConsoleNumberOfCommands  SetConsoleNumberOfCommandsA
#endif // !UNICODE

DWORD
GetConsoleCommandHistoryLengthA(
    IN LPSTR ExeName
    );
DWORD
GetConsoleCommandHistoryLengthW(
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define GetConsoleCommandHistoryLength  GetConsoleCommandHistoryLengthW
#else
#define GetConsoleCommandHistoryLength  GetConsoleCommandHistoryLengthA
#endif // !UNICODE

DWORD
GetConsoleCommandHistoryA(
    OUT LPSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPSTR ExeName
    );
DWORD
GetConsoleCommandHistoryW(
    OUT LPWSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPWSTR ExeName
    );
#ifdef UNICODE
#define GetConsoleCommandHistory  GetConsoleCommandHistoryW
#else
#define GetConsoleCommandHistory  GetConsoleCommandHistoryA
#endif // !UNICODE

#define CONSOLE_OVERSTRIKE 1

BOOL
APIENTRY
SetConsoleCommandHistoryMode(
    IN DWORD Flags
    );

#define CONSOLE_NOSHORTCUTKEY   0               /* no shortcut key  */
#define CONSOLE_ALTTAB          1               /* Alt + Tab        */
#define CONSOLE_ALTESC          (1 << 1)        /* Alt + Escape     */
#define CONSOLE_ALTSPACE        (1 << 2)        /* Alt + Space      */
#define CONSOLE_ALTENTER        (1 << 3)        /* Alt + Enter      */
#define CONSOLE_ALTPRTSC        (1 << 4)        /* Alt Print screen */
#define CONSOLE_PRTSC           (1 << 5)        /* Print screen     */
#define CONSOLE_CTRLESC         (1 << 6)        /* Ctrl + Escape    */

typedef struct _APPKEY {
    WORD Modifier;
    WORD ScanCode;
} APPKEY, *LPAPPKEY;

#define CONSOLE_MODIFIER_SHIFT      0x0003   // Left shift key
#define CONSOLE_MODIFIER_CONTROL    0x0004   // Either Control shift key
#define CONSOLE_MODIFIER_ALT        0x0008   // Either Alt shift key

BOOL
APIENTRY
SetConsoleKeyShortcuts(
    IN BOOL bSet,
    IN BYTE bReserveKeys,
    IN LPAPPKEY lpAppKeys,
    IN DWORD dwNumAppKeys
    );

BOOL
APIENTRY
SetConsoleMenuClose(
    IN BOOL bEnable
    );

DWORD
GetConsoleInputExeNameA(
    IN DWORD nBufferLength,
    OUT LPSTR lpBuffer
    );
DWORD
GetConsoleInputExeNameW(
    IN DWORD nBufferLength,
    OUT LPWSTR lpBuffer
    );
#ifdef UNICODE
#define GetConsoleInputExeName  GetConsoleInputExeNameW
#else
#define GetConsoleInputExeName  GetConsoleInputExeNameA
#endif // !UNICODE

BOOL
SetConsoleInputExeNameA(
    IN LPSTR lpExeName
    );
BOOL
SetConsoleInputExeNameW(
    IN LPWSTR lpExeName
    );
#ifdef UNICODE
#define SetConsoleInputExeName  SetConsoleInputExeNameW
#else
#define SetConsoleInputExeName  SetConsoleInputExeNameA
#endif // !UNICODE

typedef struct _CONSOLE_READCONSOLE_CONTROL {
    IN ULONG nLength;           // sizeof( CONSOLE_READCONSOLE_CONTROL )
    IN ULONG nInitialChars;
    IN ULONG dwCtrlWakeupMask;
    OUT ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;


#define CONSOLE_ADD_SUBST 1
#define CONSOLE_REMOVE_SUBST 2
#define CONSOLE_QUERY_SUBST 3

BOOL
ConsoleSubst(
    IN DWORD dwDriveNumber,
    IN DWORD dwFlag,
    IN OUT LPWSTR lpPhysicalDriveBuffer,
    IN DWORD dwPhysicalDriveBufferLength
    );

#define CONSOLE_READ_NOREMOVE   0x0001
#define CONSOLE_READ_NOWAIT     0x0002

#define CONSOLE_READ_VALID      (CONSOLE_READ_NOREMOVE | CONSOLE_READ_NOWAIT)

BOOL
WINAPI
ReadConsoleInputExA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    );
BOOL
WINAPI
ReadConsoleInputExW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    );
#ifdef UNICODE
#define ReadConsoleInputEx  ReadConsoleInputExW
#else
#define ReadConsoleInputEx  ReadConsoleInputExA
#endif // !UNICODE

BOOL
WINAPI
WriteConsoleInputVDMA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
BOOL
WINAPI
WriteConsoleInputVDMW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    );
#ifdef UNICODE
#define WriteConsoleInputVDM  WriteConsoleInputVDMW
#else
#define WriteConsoleInputVDM  WriteConsoleInputVDMA
#endif // !UNICODE


#if defined(FE_SB)
BOOL
APIENTRY
GetConsoleNlsMode(
    IN HANDLE hConsole,
    OUT PDWORD lpdwNlsMode
    );

BOOL
APIENTRY
SetConsoleNlsMode(
    IN HANDLE hConsole,
    IN DWORD fdwNlsMode
    );

BOOL
APIENTRY
GetConsoleCharType(
    IN HANDLE hConsole,
    IN COORD coordCheck,
    OUT PDWORD pdwType
    );

#define CHAR_TYPE_SBCS     0   // Displayed SBCS character
#define CHAR_TYPE_LEADING  2   // Displayed leading byte of DBCS
#define CHAR_TYPE_TRAILING 3   // Displayed trailing byte of DBCS

BOOL
APIENTRY
SetConsoleLocalEUDC(
    IN HANDLE hConsoleHandle,
    IN WORD   wCodePoint,
    IN COORD  cFontSize,
    IN PCHAR  lpSB
    );

BOOL
APIENTRY
SetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    IN BOOL   Blink,
    IN BOOL   DBEnable
    );

BOOL
APIENTRY
GetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    OUT PBOOL  pbBlink,
    OUT PBOOL  pbDBEnable
    );

BOOL
APIENTRY
RegisterConsoleOS2(
    IN BOOL fOs2Register
    );

BOOL
APIENTRY
SetConsoleOS2OemFormat(
    IN BOOL fOs2OemFormat
    );

BOOL
IsConsoleFullWidth(
    IN HDC hDC,
    IN DWORD CodePage,
    IN WCHAR wch
    );

#if defined(FE_IME)
BOOL
APIENTRY
RegisterConsoleIME(
    IN HWND  hWndConsoleIME,
    OUT DWORD *dwConsoleThreadId
    );

BOOL
APIENTRY
UnregisterConsoleIME(
    );
#endif // FE_IME
#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\conroute.h ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    conroute.h

Abstract:

    This include file contains all the type and constant definitions that are
    shared by the BASE and CONSOLE components of the Windows Subsystem.

Author:

    Therese Stowell (thereses) 3-Jan-1991

Revision History:

--*/

//
// These bits are always on for console handles and are used for routing
// by windows.
//

#define CONSOLE_HANDLE_SIGNATURE 0x00000003
#define CONSOLE_HANDLE_NEVERSET  0x10000000
#define CONSOLE_HANDLE_MASK      (CONSOLE_HANDLE_SIGNATURE | CONSOLE_HANDLE_NEVERSET)

#define CONSOLE_HANDLE(HANDLE) (((ULONG_PTR)(HANDLE) & CONSOLE_HANDLE_MASK) == CONSOLE_HANDLE_SIGNATURE)


#define CONSOLE_DETACHED_PROCESS -1
#define CONSOLE_NEW_CONSOLE -2
#define CONSOLE_CREATE_NO_WINDOW -3

//
// These strings are used to open console input or output.
//

#define CONSOLE_INPUT_STRING  ((PWCHAR)"C\0O\0N\0I\0N\0$\0\0")
#define CONSOLE_OUTPUT_STRING ((PWCHAR)"C\0O\0N\0O\0U\0T\0$\0\0")
#define CONSOLE_GENERIC       ((PWCHAR)"C\0O\0N\0\0")

//
// this string is used to call RegisterWindowMessage to get
// progman's handle.
//

#define CONSOLE_PROGMAN_HANDLE_MESSAGE "ConsoleProgmanHandle"


//
// stream API definitions.  these API are only supposed to be used by
// subsystems (i.e. OpenFile routes to OpenConsoleW).
//

HANDLE
APIENTRY
OpenConsoleW(
    IN LPWSTR lpConsoleDevice,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwShareMode
    );

HANDLE
APIENTRY
DuplicateConsoleHandle(
    IN HANDLE hSourceHandle,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwOptions
    );

BOOL
APIENTRY
GetConsoleHandleInformation(
    IN HANDLE hObject,
    OUT LPDWORD lpdwFlags
    );

BOOL
APIENTRY
SetConsoleHandleInformation(
    IN HANDLE hObject,
    IN DWORD dwMask,
    IN DWORD dwFlags
    );

BOOL
APIENTRY
CloseConsoleHandle(
    IN HANDLE hConsole
    );

BOOL
APIENTRY
VerifyConsoleIoHandle(
    IN HANDLE hIoHandle
    );

HANDLE
APIENTRY
GetConsoleInputWaitHandle( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\ddemlp.h ===
/*++ BUILD Version: 0001 // Increment this if a change has global effects --*/
/****************************** Module Header ******************************\
* Module Name: ddemlp.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This header file contains stuff used by all parts of USER DDEML code.
*
* History:
* 10-28-91 Sanfords     Created
* 4-21-92  Sanfords     Merged into ddeml.w
\***************************************************************************/
#ifndef _INC_DDEMLPH
#define _INC_DDEMLPH
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define     ST_TERMINATE_RECEIVED   0x0200
#define     ST_FREE_CONV_RES_NOW    0x0800  // See FreeConversationResources()
#define     ST_INTRA_PROCESS        0x8000
#define     ST_UNICODE_EXECUTE      0x4000
#define     ST_BLOCKALLNEXT         0x2000
#define     ST_PROCESSING           0x1000   // See CheckForQueuedMessages()
#define     CBF_MASK                     0x003ff000L
#define     CBF_MONMASK                  0x0027f000L
#define     APPCMD_UNINIT_ASAP           0x00000800L
#define     APPCLASS_UNICODE             0x00000001L
BOOL WINAPI DdeGetQualityOfService(HWND hwndClient, HWND hwndServer,
        PSECURITY_QUALITY_OF_SERVICE pqos);
#define EC_ENABLEONEOFALL       0x2000
#define EC_CHECKQUEUEONCE       0x1000
#define EC_CHECKQUEUE           0x0800
#define UM_REGISTER         (WM_USER + 200)
#define UM_UNREGISTER       (WM_USER + 201)
#define     HDATA_READONLY          0x8000
#define     HDATA_NOAPPFREE         0x4000
#define     HDATA_EXECUTE           0x0100
#define     HDATA_INITIALIZED       0x0200

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* _INC_DDEMLPH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\gdispool.h ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation


Module Name:

    gdispool.h


Abstract:

    This module contains private gdi spool definition to the Drvxxxx calls


Author:

    04-Jun-1996 Tue 10:50:56 updated -by-  Daniel Chou (danielc)


[Environment:]

    spooler


[Notes:]


Revision History:

    Move most stuff to the winddiui.h in the public\oak\inc directory, this
    file only used by the gdi printer device drivers


--*/

#ifndef _GDISPOOL_
#define _GDISPOOL_

#include <winddiui.h>


#if DBG
#ifdef DEF_DRV_DOCUMENT_EVENT_DBG_STR
TCHAR *szDrvDocumentEventDbgStrings[] =
{
    L"UNKNOWN ESCAPE",
    L"CREATEDCPRE",
    L"CREATEDCPOST",
    L"RESETDCPRE",
    L"RESETDCPOST",
    L"STARTDOC",
    L"STARTPAGE",
    L"ENDPAGE",
    L"ENDDOC",
    L"ABORTDOC",
    L"DELETEDC",
    L"ESCAPE",
    L"ENDDOCPOST",
    L"STARTDOCPOST"
};
#endif
#endif // #define(DEBUG)


typedef int (WINAPI * PFNDOCUMENTEVENT)(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,
    PVOID   pbIn,
    ULONG   cbOut,
    PVOID   pbOut
);


#endif  // _GDISPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\icmpriv.h ===
/****************************Module*Header******************************\
* Module Name: ICMPRIV.H
*
* Module Descripton: Internal data structures and constants for ICM
*
* Warnings:
*
* Issues:
*
* Created:  8 January 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) Microsoft Corporation. All rights reserved.
\***********************************************************************/

#ifndef _ICMPRIV_H_
#define _ICMPRIV_H_

#include "icm.h"          // include external stuff first

#ifdef __cplusplus
extern "C" {
#endif

//
// External (but OS internal) functional declarations
//

BOOL    InternalGetPS2ColorSpaceArray (PBYTE, DWORD, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2ColorRenderingIntent(PBYTE, DWORD, PBYTE, PDWORD);
BOOL    InternalGetPS2ColorRenderingDictionary(PBYTE, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2PreviewCRD(PBYTE, PBYTE, DWORD, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetPS2CSAFromLCS(LPLOGCOLORSPACE, PBYTE, PDWORD, PBOOL);
BOOL    InternalGetDeviceConfig(LPCTSTR,DWORD,DWORD,PVOID,PDWORD);
BOOL    InternalSetDeviceConfig(LPCTSTR,DWORD,DWORD,PVOID,DWORD);

//
// Function ID for InternalGet/SetDeviceConfig
//

#define MSCMS_PROFILE_ENUM_MODE     1

#if !defined(_GDI32_)  // not include from here if gdi32.

//
// Useful macros
//

#define ABS(x)                      ((x) > 0 ? (x) : -(x))
#define DWORD_ALIGN(x)              (((x) + 3) & ~3)

#ifdef LITTLE_ENDIAN
#define FIX_ENDIAN(x)               (((x) & 0xff000000) >> 24 | \
                                     ((x) & 0xff0000)   >> 8  | \
                                     ((x) & 0xff00)     << 8  | \
                                     ((x) & 0xff)       << 24 )

#define FIX_ENDIAN16(x)             (((x) & 0xff00) >> 8 | ((x) & 0xff) << 8)
#else
#define FIX_ENDIAN(x)               (x)
#define FIX_ENDIAN16(x)             (x)
#endif

#if !defined(FROM_PS) // not include from here if postscript driver.

//
// MSCMS Internal definition
//

typedef struct tagTAGDATA {
    TAGTYPE tagType;
    DWORD   dwOffset;
    DWORD   cbSize;
} TAGDATA;
typedef TAGDATA *PTAGDATA;

//
// ICM supports the following  objects:
// 1. Profile object: This is created when an application requsts a handle
//      to a profile.
// 2. Color transform object: This is created when an application creates
//      a color transform.
// 3. CMM object: This is created when ICM loads a CMM into memory to
//      perform color matching.
//

typedef enum {
    OBJ_PROFILE             = 'PRFL',
    OBJ_TRANSFORM           = 'XFRM',
    OBJ_CMM                 = ' CMM',
} OBJECTTYPE;

typedef struct tagOBJHEAD {
    OBJECTTYPE  objType;
    DWORD       dwUseCount;
} OBJHEAD;
typedef OBJHEAD *POBJHEAD;

//
// Profile object:
// Memory for profile objects is allocated from ICM's per process heap.
// These objects use handles from ICM's per process handle table.
//

typedef struct tagPROFOBJ {
    OBJHEAD   objHdr;           // common object header info
    DWORD     dwType;           // type (from profile structure)
    PVOID     pProfileData;     // data (from profile structure)
    DWORD     cbDataSize;       // size of data (from profile structure)
    DWORD     dwFlags;          // miscellaneous flags
    HANDLE    hFile;            // handle to open profile
    HANDLE    hMap;             // handle to profile mapping
    DWORD     dwMapSize;        // size of the file mapping object
    PBYTE     pView;            // pointer to mapped view of profile
} PROFOBJ;
typedef PROFOBJ *PPROFOBJ;

//
// Flags for ((PPROFOBJ)0)->dwFlags
//

#define MEMORY_MAPPED       1   // memory mapped profile
#define PROFILE_TEMP        2   // temporary profile has been created
#define READWRITE_ACCESS    4   // if this bit is set, app has read & write
                                // access to profile, else it has only read
                                // read access.

//
// Transform returned by CMM
//

typedef HANDLE  HCMTRANSFORM;

//
// For internal use, compiler doesn't accept PBYTE* below
//

typedef PBYTE*  PPBYTE;

//
// CMM function calltable
//

typedef struct tagCMMFNS {

    //
    // Required functions
    //

    DWORD          (WINAPI *pCMGetInfo)(DWORD);
    HCMTRANSFORM   (WINAPI *pCMCreateTransform)(LPLOGCOLORSPACE, PVOID, PVOID);
    HCMTRANSFORM   (WINAPI *pCMCreateTransformExt)(LPLOGCOLORSPACE, PVOID, PVOID, DWORD);
    BOOL           (WINAPI *pCMDeleteTransform)(HCMTRANSFORM);
    BOOL           (WINAPI *pCMTranslateRGBs)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD);
    BOOL           (WINAPI *pCMTranslateRGBsExt)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PVOID, BMFORMAT, DWORD, PBMCALLBACKFN, LPARAM);
    BOOL           (WINAPI *pCMCheckRGBs)(HCMTRANSFORM, PVOID, BMFORMAT,
                       DWORD, DWORD, DWORD, PBYTE, PBMCALLBACKFN, LPARAM);
    HCMTRANSFORM   (WINAPI *pCMCreateMultiProfileTransform)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD);
    BOOL           (WINAPI *pCMTranslateColors)(HCMTRANSFORM, PCOLOR, DWORD,
                       COLORTYPE, PCOLOR, COLORTYPE);
    BOOL           (WINAPI *pCMCheckColors)(HCMTRANSFORM, PCOLOR, DWORD,
                       COLORTYPE, PBYTE);
    //
    // Optional functions
    //

    BOOL           (WINAPI *pCMCreateProfile)(LPLOGCOLORSPACE, PPBYTE);
    BOOL           (WINAPI *pCMGetNamedProfileInfo)(HPROFILE, PNAMED_PROFILE_INFO);
    BOOL           (WINAPI *pCMConvertColorNameToIndex)(HPROFILE, LPCOLOR_NAME, LPDWORD, DWORD);
    BOOL           (WINAPI *pCMConvertIndexToColorName)(HPROFILE, LPDWORD, LPCOLOR_NAME, DWORD);
    BOOL           (WINAPI *pCMCreateDeviceLinkProfile)(PHPROFILE, DWORD, PDWORD, DWORD, DWORD, PPBYTE);
    BOOL           (WINAPI *pCMIsProfileValid)(HPROFILE, PBOOL);
    BOOL           (WINAPI *pCMGetPS2ColorSpaceArray)(HPROFILE, DWORD, DWORD, PBYTE, PDWORD, PBOOL);
    BOOL           (WINAPI *pCMGetPS2ColorRenderingIntent)(HPROFILE, DWORD, PBYTE, PDWORD);
    BOOL           (WINAPI *pCMGetPS2ColorRenderingDictionary)(HPROFILE, DWORD,
                       PBYTE, PDWORD, PBOOL);
} CMMFNS;
typedef CMMFNS *PCMMFNS;

//
// CMM object:
// Memory for CMM objects is allocated from ICM's per process heap.
// They are maintained in a linked list.
//

typedef struct tagCMMOBJ {
    OBJHEAD           objHdr;
    DWORD             dwFlags;  // miscellaneous flags
    DWORD             dwCMMID;  // ICC identifier
    DWORD             dwTaskID; // process ID of current task
    HINSTANCE         hCMM;     // handle to instance of CMM dll
    CMMFNS            fns;      // function calltable
    struct tagCMMOBJ* pNext;    // pointer to next object
} CMMOBJ;
typedef CMMOBJ *PCMMOBJ;

//
//  dwFlags for CMMOBJ
//

#define CMM_DONT_USE_PS2_FNS        0x00001

//
// Color transform object
//

typedef struct tagTRANSFORMOBJ {
    OBJHEAD      objHdr;
    PCMMOBJ      pCMMObj;       // pointer to CMM object
    HCMTRANSFORM hcmxform;      // transform returned by CMM
} TRANSFORMOBJ;
typedef TRANSFORMOBJ *PTRANSFORMOBJ;

//
// Parameter to InternalHandleColorProfile
//

typedef enum {
    ADDPROFILES,
    REMOVEPROFILES,
    ENUMPROFILES,
} PROFILEOP;

//
// CMM returned transform should be larger than this value
//

#define TRANSFORM_ERROR    (HTRANSFORM)255

#define PROFILE_SIGNATURE          'psca'

#define HEADER(pProfObj)           ((PPROFILEHEADER)pProfObj->pView)
#define VIEW(pProfObj)             (pProfObj->pView)
#define PROFILE_SIZE(pProfObj)     (FIX_ENDIAN(HEADER(pProfObj)->phSize))
#define TAG_COUNT(pProfObj)        (*((DWORD *)(VIEW(pProfObj) + \
                                   sizeof(PROFILEHEADER))))
#define TAG_DATA(pProfObj)         ((PTAGDATA)(VIEW(pProfObj) + \
                                   sizeof(PROFILEHEADER) + sizeof(DWORD)))

#define MAGIC                      'ICM '
#define PTRTOHDL(x)                ((HANDLE)((ULONG_PTR)(x) ^ MAGIC))
#define HDLTOPTR(x)                ((ULONG_PTR)(x) ^ MAGIC)

PVOID   MemAlloc(DWORD);
PVOID   MemReAlloc(PVOID, DWORD);
VOID    MemFree(PVOID);
VOID    MyCopyMemory(PBYTE, PBYTE, DWORD);
PVOID   AllocateHeapObject(OBJECTTYPE);
VOID    FreeHeapObject(HANDLE);
BOOL    ValidHandle(HANDLE, OBJECTTYPE);
PCMMOBJ GetColorMatchingModule(DWORD);
BOOL    ValidColorMatchingModule(DWORD,PTSTR);
PCMMOBJ GetPreferredCMM();
VOID    ReleaseColorMatchingModule(PCMMOBJ);
BOOL    ValidProfile(PPROFOBJ);
BOOL    ConvertToAnsi(PCWSTR, PSTR*, BOOL);
BOOL    ConvertToUnicode(PCSTR, PWSTR*, BOOL);
PTSTR   GetFilenameFromPath(PTSTR);

//
// For use with the new Device Settings tag
//

typedef struct _SETTINGS {
    DWORD         dwSettingType;     // 'rsln', 'mdia' etc.
    DWORD         dwSizePerValue;    // number of bytes per value
    DWORD         nValues;           // number of values
    DWORD         Value[1];          // array of value entries
} SETTINGS, *PSETTINGS;

typedef struct _SETTINGCOMBOS {
    DWORD         dwSize;           // size of this structure, including sub structures
    DWORD         nSettings;        // number of setting structures
    SETTINGS      Settings[1];      // array of setting entries
} SETTINGCOMBOS, *PSETTINGCOMBOS;

typedef struct _PERPLATFORMENTRY {
    DWORD         PlatformID;        // platform signature ('msft', 'appl' etc.)
    DWORD         dwSize;            // size of this structure, including sub structures
    DWORD         nSettingCombos;    // number of setting combo structures
    SETTINGCOMBOS SettingCombos[1];  // array of setting combos entries
} PLATFORMENTRY, *PPLATFORMENTRY;

typedef struct _DEVICESETTINGS {
    DWORD         dwTagID;           // 'devs'
    DWORD         dwReserved;        // must be 0
    DWORD         nPlatforms;        // number of platform structures
    PLATFORMENTRY PlatformEntry[1];  // array of platform entries
} DEVICESETTINGS, *PDEVICESETTINGS;

#endif  // ifndef FROM_PS

#endif  // ifndef _GDI32_

#ifdef __cplusplus
}
#endif

#endif  // ifndef _ICMPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\ddetrack.h ===
/****************************** Module Header ******************************\
* Module Name: ddetrack.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Stuff for dde tracking
*
* History:
* 9-3-91    sanfords    Created
\***************************************************************************/

typedef struct tagDDEPACK {
    UINT_PTR uiLo;
    UINT_PTR uiHi;
} DDEPACK, *PDDEPACK;


#if defined(BUILD_WOW6432)
//
// This structure has the same layout as the DDEDATA when allocated by 32-bit 
// clients running on Win64. It's used only by USER to apply correct structure-size
// validation.
//
typedef struct _DDEDATA_WOW6432
{
    WORD wStatus;
    WORD wFmt;
    ULONG_PTR Data; 
} DDEDATA_WOW6432, *PDDEDATA_WOW6432;
#endif

// Packing set to 1 on 64 bits to prevent compiler from generating extra
// packing for DDE_DATA that will later corrupt data when we attempt to cast
// a pointer to a DDEDATA structure as a DDE_DATA pointer.  DDEDATA is not 
// packed and uses __unaligned directive to assign pointer values to Value 
// field.  To make sure those pointer values are extracted properly, DDE_DATA 
// must be packed to 1.

#if defined(_WIN64) || defined(BUILD_WOW6432)
#pragma pack(1)                 
#endif
typedef struct tagDDE_DATA {    // useful for sanely manipulating DDE data
    WORD wStatus;
    WORD wFmt;
    KERNEL_PVOID Data;          // often cast to a HANDLE so has to scale 32 and 64 bits.
} DDE_DATA, *PDDE_DATA;
#if defined(_WIN64) || defined(BUILD_WOW6432)
#pragma pack()
#endif

//
// This structure heads the single server side object used to hold DDE Data.
// Its complexity derives from the fact that we may need to copy huge and
// complex DDE data across the CSR barrier. (TYPE_DDEDATA object)
//
typedef struct tagINTDDEINFO {
    DDEPACK     DdePack;            // original dde pack struct
    DWORD       flags;              // XS_ flags describing the data
    HANDLE      hDirect;            // handle to direct DDE data
    PBYTE       pDirect;            // pointer to source buffer for direct data
    int         cbDirect;           // size of direct data total
    HANDLE      hIndirect;          // handle referenced by direct data
    PBYTE       pIndirect;          // pointer to source of indirect data - if being copied
    int         cbIndirect;         // amount of indirect data total
                                    // Directly following this struct is the
                                    // raw DDE data being copied between processes
} INTDDEINFO, *PINTDDEINFO;

// values for flags fields

#define XS_PACKED         0x0001  // this transaction has a packed lParam
#define XS_DATA           0x0002  // this transaction has data w/status-format info.
#define XS_METAFILEPICT   0x0004  // the data in this transaction has a METAFILEPICT
#define XS_BITMAP         0x0008  // the data in this transaction has a HBITMAP
#define XS_DIB            0x0010  // the data in this transaction has a DIB
#define XS_ENHMETAFILE    0x0020  // the data in this transaction has a HMF
#define XS_PALETTE        0x0040  // the data in this transaction has a HPALETTE
#define XS_LOHANDLE       0x0080  // the uiLo part has the data handle
#define XS_HIHANDLE       0x0100  // the uiHi part has the data handle
#define XS_FREEPXS        0x0200  // DDETrackGetMessageHook() should free pxs.
#define XS_FRELEASE       0x0400  // DDE_FRELEASE bit was set in the data msg.
#define XS_EXECUTE        0x0800  // execute data handle
#define XS_FREESRC        0x1000  // free source after copy.
#define XS_PUBLICOBJ      0x2000  // object being shared is public - cleanup if needed.
#define XS_GIVEBACKONNACK 0x4000  // object was given and may need to be returned.
#define XS_DUMPMSG        0x8000  // used for backing out PostMessages.
#define XS_UNICODE       0x10000  // execute string is expected to be UNICODE

#define FAIL_POST       0       // return values from DDETrackPostHook()
#define FAKE_POST       1
#define DO_POST         2
#define FAILNOFREE_POST 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\ddrawgdi.h ===
/******************************Module*Header*******************************\
* Module Name: ddrawgdi.h
*
* Structures and defines for the private entry points in GDI to support
* DirectDraw.
*
* Copyright (c) Microsoft Corporation. All rights reserved.
\**************************************************************************/

// We rename the actual entry points for added protection against anyone
// trying to call our private entry points directly:

#define DdCreateDirectDrawObject            GdiEntry1
#define DdQueryDirectDrawObject             GdiEntry2
#define DdDeleteDirectDrawObject            GdiEntry3
#define DdCreateSurfaceObject               GdiEntry4
#define DdDeleteSurfaceObject               GdiEntry5
#define DdResetVisrgn                       GdiEntry6
#define DdGetDC                             GdiEntry7
#define DdReleaseDC                         GdiEntry8
#define DdCreateDIBSection                  GdiEntry9
#define DdReenableDirectDrawObject          GdiEntry10
#define DdAttachSurface                     GdiEntry11
#define DdUnattachSurface                   GdiEntry12
#define DdQueryDisplaySettingsUniqueness    GdiEntry13
#define DdGetDxHandle                       GdiEntry14
#define DdSetGammaRamp                      GdiEntry15
#define DdSwapTextureHandles                GdiEntry16

BOOL
APIENTRY
DdCreateDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    HDC                     hdc
    );

typedef struct _D3DHAL_CALLBACKS FAR *LPD3DHAL_CALLBACKS;
typedef struct _D3DHAL_GLOBALDRIVERDATA FAR *LPD3DHAL_GLOBALDRIVERDATA;

BOOL
APIENTRY
DdQueryDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL     pDirectDrawGlobal,
    LPDDHALINFO                 pHalInfo,
    LPDDHAL_DDCALLBACKS         pDDCallbacks,
    LPDDHAL_DDSURFACECALLBACKS  pDDSurfaceCallbacks,
    LPDDHAL_DDPALETTECALLBACKS  pDDPaletteCallbacks,
    LPD3DHAL_CALLBACKS          pD3dCallbacks,
    LPD3DHAL_GLOBALDRIVERDATA   pD3dDriverData,
    LPDDHAL_DDEXEBUFCALLBACKS   pD3dBufferCallbacks,
    LPDDSURFACEDESC             pD3dTextureFormats,
    LPDWORD                     pdwFourCC,         // Can be NULL
    LPVIDMEM                    pvmList            // Can be NULL
    );

BOOL
APIENTRY
DdDeleteDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL   pDirectDrawGlobal
    );

BOOL
APIENTRY
DdCreateSurfaceObject(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    BOOL                      bPrimarySurface
    );

BOOL
APIENTRY
DdDeleteSurfaceObject(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal
    );

BOOL
APIENTRY
DdResetVisrgn(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    HWND                      hWnd
    );

HDC
APIENTRY
DdGetDC(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal,
    LPPALETTEENTRY            pColorTable
    );

BOOL
APIENTRY
DdReleaseDC(
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal
    );

HBITMAP
APIENTRY
DdCreateDIBSection(
    HDC               hdc,
    CONST BITMAPINFO* pbmi,
    UINT              iUsage,
    VOID**            ppvBits,
    HANDLE            hSectionApp,
    DWORD             dwOffset
    );

BOOL
APIENTRY
DdReenableDirectDrawObject(
    LPDDRAWI_DIRECTDRAW_GBL pDirectDrawGlobal,
    BOOL*                   pbNewMode
    );

BOOL
APIENTRY
DdAttachSurface(
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceFrom,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceTo
    );

VOID
APIENTRY
DdUnattachSurface(
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceAttached
    );

ULONG
APIENTRY
DdQueryDisplaySettingsUniqueness(
    VOID
    );

HANDLE
APIENTRY
DdGetDxHandle(
    LPDDRAWI_DIRECTDRAW_LCL	pDDraw,
    LPDDRAWI_DDRAWSURFACE_LCL   pSurface,
    BOOL			bRelease
    );

BOOL
APIENTRY
DdSetGammaRamp(
    LPDDRAWI_DIRECTDRAW_LCL	pDDraw,
    HDC                         hdc,
    LPVOID                      lpGammaRamp
    );



DWORD 
APIENTRY
DdSwapTextureHandles(
    LPDDRAWI_DIRECTDRAW_LCL	pDDraw,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl1,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\ddmc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\immp.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * Module Name:
 *
 *    immp.h
 *
 * Abstract:
 *
 *    Private
 *    Procedure declarations, constant definitions and macros for IMM.
 *
 */
#ifndef _IMMP_
#define _IMMP_

#ifdef __cplusplus
extern "C" {
#endif


#ifndef _IMM_SDK_DEFINED_
#define _IMM_SDK_DEFINED_

#if (WINVER >= 0x040A)
DECLARE_HANDLE(HIMC);
DECLARE_HANDLE(HIMCC);
#else
typedef DWORD   HIMC;
typedef DWORD   HIMCC;
#endif /* WINVER >= 0x040A */

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if (WINVER >= 0x040A)

typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;

#endif /* WINVER >= 0x040A */

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE


#if (WINVER >= 0x040A)

#define IMEMENUITEM_STRING_SIZE 80

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

typedef BOOL    (CALLBACK* IMCENUMPROC)(HIMC, LPARAM);

#endif /* WINVER >= 0x040A */



// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(IN LPCSTR lpszIMEFileName, IN LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(IN LPCWSTR lpszIMEFileName, IN LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);

UINT WINAPI ImmGetDescriptionA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(IN HKL, OUT LPSTR, IN UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(IN HKL, OUT LPWSTR, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

BOOL WINAPI ImmIsIME(IN HKL);

BOOL WINAPI ImmSimulateHotKey(IN HWND, IN DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(IN HIMC);
HIMC WINAPI ImmGetContext(IN HWND);
BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
#if (WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
#endif /* WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, OUT LPVOID, IN DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, OUT LPDWORD lpdwListCount);
DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, OUT LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD deIndex, OUT LPCANDIDATELIST, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(IN HIMC, IN DWORD dwIndex, OUT LPSTR, IN DWORD dwBufLen);
DWORD WINAPI ImmGetGuideLineW(IN HIMC, IN DWORD dwIndex, OUT LPWSTR, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(IN HIMC, OUT LPDWORD, OUT LPDWORD);
BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);
BOOL WINAPI ImmGetOpenStatus(IN HIMC);
BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

#if defined(_WINGDI_) && !defined(NOGDI)
BOOL WINAPI ImmGetCompositionFontA(IN HIMC, OUT LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(IN HIMC, OUT LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(IN HIMC, IN LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(IN HIMC, IN LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE
#endif  // defined(_WINGDI_) && !defined(NOGDI)

BOOL    WINAPI ImmConfigureIMEA(IN HKL, IN HWND, IN DWORD, IN LPVOID);
BOOL    WINAPI ImmConfigureIMEW(IN HKL, IN HWND, IN DWORD, IN LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListA(IN HKL, IN HIMC, IN LPCSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
DWORD   WINAPI ImmGetConversionListW(IN HKL, IN HIMC, IN LPCWSTR, OUT LPCANDIDATELIST, IN DWORD dwBufLen, IN UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, OUT LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, IN LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(IN HIMC, OUT LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(IN HIMC, IN LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, OUT LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(IN HIMC, IN LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
BOOL WINAPI ImmIsUIMessageW(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE


UINT WINAPI ImmGetVirtualKey(IN HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister);
BOOL WINAPI ImmRegisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(IN HKL, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszUnregister);
BOOL WINAPI ImmUnregisterWordW(IN HKL, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(IN HKL, IN UINT nItem, OUT LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(IN HKL, IN UINT nItem, OUT LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(IN HKL, IN REGISTERWORDENUMPROCA, IN LPCSTR lpszReading, IN DWORD, IN LPCSTR lpszRegister, IN LPVOID);
UINT WINAPI ImmEnumRegisterWordW(IN HKL, IN REGISTERWORDENUMPROCW, IN LPCWSTR lpszReading, IN DWORD, IN LPCWSTR lpszRegister, IN LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if (WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(IN DWORD);
BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOA, OUT LPIMEMENUITEMINFOA, IN DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, OUT LPIMEMENUITEMINFOW, OUT LPIMEMENUITEMINFOW, IN DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE

BOOL WINAPI ImmDisableTextFrameService(DWORD idThread);
#endif /* WINVER >= 0x040A */

// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022


// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F


// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F


// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000


// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000


// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000


// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004


// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002


// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004


// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004


// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF


// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_HANGUL                IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800
#define IME_CMODE_RESERVED          0xF0000000

// bit field for sentence mode
#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010
#define IME_SMODE_RESERVED          0x0000F000


// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E

#if (WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW           0x0001
#define IMR_CANDIDATEWINDOW             0x0002
#define IMR_COMPOSITIONFONT             0x0003
#define IMR_RECONVERTSTRING             0x0004
#define IMR_CONFIRMRECONVERTSTRING      0x0005
#define IMR_QUERYCHARPOSITION           0x0006
#define IMR_DOCUMENTFEED                0x0007
#endif /* WINVER >= 0x040A */

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)


// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3


// flags for ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF

#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b
// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF


#if (WINVER >= 0x040A)

// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x0001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x0001
#define IGIMII_SMODE                    0x0002
#define IGIMII_CONFIGURE                0x0004
#define IGIMII_TOOLS                    0x0008
#define IGIMII_HELP                     0x0010
#define IGIMII_OTHER                    0x0020
#define IGIMII_INPUTTOOLS               0x0040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT

#endif /* WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002


#endif  // _IMM_SDK_DEFINED_

#ifndef _IMM_DDK_DEFINED_
#define _IMM_DDK_DEFINED_

typedef struct tagCOMPOSITIONSTRING {
    DWORD dwSize;
    DWORD dwCompReadAttrLen;
    DWORD dwCompReadAttrOffset;
    DWORD dwCompReadClauseLen;
    DWORD dwCompReadClauseOffset;
    DWORD dwCompReadStrLen;
    DWORD dwCompReadStrOffset;
    DWORD dwCompAttrLen;
    DWORD dwCompAttrOffset;
    DWORD dwCompClauseLen;
    DWORD dwCompClauseOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwCursorPos;
    DWORD dwDeltaStart;
    DWORD dwResultReadClauseLen;
    DWORD dwResultReadClauseOffset;
    DWORD dwResultReadStrLen;
    DWORD dwResultReadStrOffset;
    DWORD dwResultClauseLen;
    DWORD dwResultClauseOffset;
    DWORD dwResultStrLen;
    DWORD dwResultStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} COMPOSITIONSTRING, *PCOMPOSITIONSTRING, NEAR *NPCOMPOSITIONSTRING, FAR  *LPCOMPOSITIONSTRING;

typedef struct tagGUIDELINE {
    DWORD dwSize;
    DWORD dwLevel;
    DWORD dwIndex;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwPrivateSize;
    DWORD dwPrivateOffset;
} GUIDELINE, *PGUIDELINE, NEAR *NPGUIDELINE, FAR *LPGUIDELINE;

#if (WINVER >= 0x040A)

typedef struct tagTRANSMSG {
    UINT   message;
    WPARAM wParam;
    LPARAM lParam;
} TRANSMSG, *PTRANSMSG, NEAR *NPTRANSMSG, FAR *LPTRANSMSG;

typedef struct tagTRANSMSGLIST {
    UINT     uMsgCount;
    TRANSMSG TransMsg[1];
} TRANSMSGLIST, *PTRANSMSGLIST, NEAR *NPTRANSMSGLIST, FAR *LPTRANSMSGLIST;

#endif /* WINVER >= 0x040A */

typedef struct tagCANDIDATEINFO {
    DWORD               dwSize;
    DWORD               dwCount;
    DWORD               dwOffset[32];
    DWORD               dwPrivateSize;
    DWORD               dwPrivateOffset;
} CANDIDATEINFO, *PCANDIDATEINFO, NEAR *NPCANDIDATEINFO, FAR *LPCANDIDATEINFO;



typedef struct tagIMEINFO {
    DWORD       dwPrivateDataSize;
    DWORD       fdwProperty;
    DWORD       fdwConversionCaps;
    DWORD       fdwSentenceCaps;
    DWORD       fdwUICaps;
    DWORD       fdwSCSCaps;
    DWORD       fdwSelectCaps;
} IMEINFO, *PIMEINFO, NEAR *NPIMEINFO, FAR *LPIMEINFO;

typedef struct tagSOFTKBDDATA {
    UINT        uCount;
    WORD        wCode[1][256];
} SOFTKBDDATA, *PSOFTKBDDATA, NEAR *NPSOFTKBDDATA, FAR * LPSOFTKBDDATA;


BOOL WINAPI ImmGetHotKey(IN DWORD, OUT LPUINT lpuModifiers, OUT LPUINT lpuVKey, OUT LPHKL);
BOOL WINAPI ImmSetHotKey(IN DWORD, IN UINT, IN UINT, IN HKL);
BOOL WINAPI ImmGenerateMessage(IN HIMC);
#if (WINVER >= 0x040A)
LRESULT WINAPI ImmRequestMessageA(IN HIMC, IN WPARAM, IN LPARAM);
LRESULT WINAPI ImmRequestMessageW(IN HIMC, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
#endif /* WINVER >= 0x040A */

//
// Prototype of soft keyboard APIs
//

HWND WINAPI ImmCreateSoftKeyboard(IN UINT, IN HWND, IN int, IN int);
BOOL WINAPI ImmDestroySoftKeyboard(IN HWND);
BOOL WINAPI ImmShowSoftKeyboard(IN HWND, IN int);

BOOL  WINAPI ImmUnlockIMC(IN HIMC);
DWORD WINAPI ImmGetIMCLockCount(IN HIMC);

HIMCC  WINAPI ImmCreateIMCC(IN DWORD);
HIMCC  WINAPI ImmDestroyIMCC(IN HIMCC);
LPVOID WINAPI ImmLockIMCC(IN HIMCC);
BOOL   WINAPI ImmUnlockIMCC(IN HIMCC);
DWORD  WINAPI ImmGetIMCCLockCount(IN HIMCC);
HIMCC  WINAPI ImmReSizeIMCC(IN HIMCC, IN DWORD);
DWORD  WINAPI ImmGetIMCCSize(IN HIMCC);

// the window extra offset
#define IMMGWL_IMC                      0
#define IMMGWL_PRIVATE                  (sizeof(LONG))

#ifdef _WIN64
#undef IMMGWL_IMC
#undef IMMGWL_PRIVATE
#endif /* _WIN64 */

#define IMMGWLP_IMC                     0
#define IMMGWLP_PRIVATE                 (sizeof(LONG_PTR))


// for NI_CONTEXTUPDATED
#define IMC_SETCONVERSIONMODE           0x0002
#define IMC_SETSENTENCEMODE             0x0004
#define IMC_SETOPENSTATUS               0x0006

// wParam for WM_IME_CONTROL to the soft keyboard
#define IMC_GETSOFTKBDFONT              0x0011
#define IMC_SETSOFTKBDFONT              0x0012
#define IMC_GETSOFTKBDPOS               0x0013
#define IMC_SETSOFTKBDPOS               0x0014
#define IMC_GETSOFTKBDSUBTYPE           0x0015
#define IMC_SETSOFTKBDSUBTYPE           0x0016
#define IMC_SETSOFTKBDDATA              0x0018


// dwAction for ImmNotifyIME
#define NI_CONTEXTUPDATED               0x0003
// dwSystemInfoFlags bits
#define IME_SYSINFO_WINLOGON            0x0001
#define IME_SYSINFO_WOW16               0x0002

#define GCS_COMP                        (GCS_COMPSTR|GCS_COMPATTR|GCS_COMPCLAUSE)
#define GCS_COMPREAD                    (GCS_COMPREADSTR|GCS_COMPREADATTR |GCS_COMPREADCLAUSE)
#define GCS_RESULT                      (GCS_RESULTSTR|GCS_RESULTCLAUSE)
#define GCS_RESULTREAD                  (GCS_RESULTREADSTR|GCS_RESULTREADCLAUSE)


// bits of fdwInit of INPUTCONTEXT
#define INIT_STATUSWNDPOS               0x00000001
#define INIT_CONVERSION                 0x00000002
#define INIT_SENTENCE                   0x00000004
#define INIT_LOGFONT                    0x00000008
#define INIT_COMPFORM                   0x00000010
#define INIT_SOFTKBDPOS                 0x00000020


// IME property bits
#define IME_PROP_END_UNLOAD             0x00000001
#define IME_PROP_KBD_CHAR_FIRST         0x00000002
#define IME_PROP_IGNORE_UPKEYS          0x00000004
#define IME_PROP_NEED_ALTKEY            0x00000008
#define IME_PROP_NO_KEYS_ON_CLOSE       0x00000010
#define IME_PROP_ACCEPT_WIDE_VKEY       0x00000020

// IME UICapability bits
#define UI_CAP_SOFTKBD                  0x00010000

#define IMN_SOFTKBDDESTROYED            0x0011


// flags for ImmEscape
#define IME_ESC_PENAUXDATA              0x100c


// prototype of IME APIs
BOOL    WINAPI ImeInquire(IN LPIMEINFO, OUT LPTSTR lpszUIClass, IN DWORD dwSystemInfoFlags);
BOOL    WINAPI ImeConfigure(IN HKL, IN HWND, IN DWORD, IN LPVOID);
DWORD   WINAPI ImeConversionList(HIMC, LPCTSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);
BOOL    WINAPI ImeDestroy(UINT);
LRESULT WINAPI ImeEscape(HIMC, UINT, LPVOID);
BOOL    WINAPI ImeProcessKey(IN HIMC, IN UINT, IN LPARAM, IN CONST LPBYTE);
BOOL    WINAPI ImeSelect(IN HIMC, IN BOOL);
BOOL    WINAPI ImeSetActiveContext(IN HIMC, IN BOOL);
#if (WINVER >= 0x040A)
UINT    WINAPI ImeToAsciiEx(IN UINT uVirtKey, IN UINT uScaCode, IN CONST LPBYTE lpbKeyState, OUT LPTRANSMSGLIST lpTransBuf, IN UINT fuState, IN HIMC);
#else
UINT    WINAPI ImeToAsciiEx(IN UINT uVirtKey, IN UINT uScaCode, IN CONST LPBYTE lpbKeyState, OUT LPDWORD lpdwTransBuf, IN UINT fuState, IN HIMC);
#endif /* WINVER >= 0x040A */
BOOL    WINAPI NotifyIME(IN HIMC, IN DWORD, IN DWORD, IN DWORD);
BOOL    WINAPI ImeRegisterWord(IN LPCTSTR, IN DWORD, IN LPCTSTR);
BOOL    WINAPI ImeUnregisterWord(IN LPCTSTR, IN DWORD, IN LPCTSTR);
UINT    WINAPI ImeGetRegisterWordStyle(IN UINT nItem, OUT LPSTYLEBUF);
UINT    WINAPI ImeEnumRegisterWord(IN REGISTERWORDENUMPROC, IN LPCTSTR, IN DWORD, IN LPCTSTR, IN LPVOID);
BOOL    WINAPI ImeSetCompositionString(IN HIMC, IN DWORD dwIndex, IN LPVOID lpComp, IN DWORD, IN LPVOID lpRead, IN DWORD);

//
// Pen Input support
//
typedef struct tagIMEPENDATA {
    DWORD dwVersion;
    DWORD dwFlags;
    DWORD dwCount;
    LPVOID lpExtraInfo;
    ULONG_PTR ulReserve;
    union {
        struct {
            LPDWORD lpSymbol;
            LPWORD lpSkip;
            LPWORD lpScore;
        } wd;
    };
} IMEPENDATA, *PIMEPENDATA, NEAR* NPIMEPENDATA, FAR* LPIMEPENDATA;

#define IME_PEN_SYMBOL                  0x00000010
#define IME_PEN_SKIP                    0x00000020
#define IME_PEN_SCORE                   0x00000040

#endif  // _IMM_DDK_DEFINED_


#if defined(_WINGDI_) && !defined(NOGDI)
typedef struct tagINPUTCONTEXT {
    HWND                hWnd;
    BOOL                fOpen;
    POINT               ptStatusWndPos;
    POINT               ptSoftKbdPos;
    DWORD               fdwConversion;
    DWORD               fdwSentence;
    union   {
        LOGFONTA        A;
        LOGFONTW        W;
    } lfFont;
    COMPOSITIONFORM     cfCompForm;
    CANDIDATEFORM       cfCandForm[4];
    HIMCC               hCompStr;
    HIMCC               hCandInfo;
    HIMCC               hGuideLine;
    HIMCC               hPrivate;
    DWORD               dwNumMsgBuf;
    HIMCC               hMsgBuf;
    DWORD               fdwInit;
    DWORD               dwReserve[3];
    UINT                uSavedVKey;
    BOOL                fChgMsg;
    DWORD               fdwFlags;
    DWORD               fdw31Compat;
    DWORD               dwRefCount;
    PVOID               pImeModeSaver;
    DWORD               fdwDirty;
#ifdef CUAS_ENABLE
    HIMCC               hCtfImeContext;
#endif // CUAS_ENABLE
} INPUTCONTEXT, *PINPUTCONTEXT, NEAR *NPINPUTCONTEXT, FAR *LPINPUTCONTEXT;
#endif
#ifdef CUAS_ENABLE
/////////////////////////////////////////////////////////////////////////////
// GUID attribute (IME share)
//     COMPOSITIONSTRING->dwPrivateSize = sizeof(GUIDMAPATTRIBUTE) + actual data array.
//     GUIDMAPATTRIBUTE* = GetOffset(COMPOSITIONSTRING->dwPrivateOffset)

typedef struct tagGUIDMAPATTRIBUTE {
    //
    // IME share of GUID map attribute.
    //
    DWORD               dwTfGuidAtomLen;
    DWORD               dwTfGuidAtomOffset;        // Offset based on GUIDMAPATTRIBUTE struct.
    //
    DWORD               dwGuidMapAttrLen;
    DWORD               dwGuidMapAttrOffset;       // Offset based on GUIDMAPATTRIBUTE struct.
} GUIDMAPATTRIBUTE, *PGUIDMAPATTRIBUTE;
#endif // CUAS_ENABLE



#if defined(_WINGDI_) && !defined(NOGDI)
LPINPUTCONTEXT WINAPI ImmLockIMC(IN HIMC);
#endif
#if (WINVER >= 0x040A)
#ifdef CUAS_ENABLE
//
// Prototype of Cicero Unaware
//
HRESULT WINAPI CtfImmGetGuidAtom(IN HIMC, IN BYTE, OUT DWORD*);
BOOL    WINAPI CtfImmIsGuidMapEnable(IN HIMC);

BOOL    WINAPI CtfImmIsCiceroEnabled();
BOOL    WINAPI CtfImmIsTextFrameServiceDisabled();

BOOL    WINAPI CtfImmIsCiceroStartedInThread();
HRESULT WINAPI CtfImmSetCiceroStartInThread(BOOL fSet);

UINT    WINAPI GetKeyboardLayoutCP(HKL hKL);

DWORD   WINAPI ImmGetAppCompatFlags(HIMC hIMC);
VOID    WINAPI CtfImmSetAppCompatFlags(DWORD dwFlag);

HRESULT WINAPI CtfAImmActivate(HMODULE* phMod);
HRESULT WINAPI CtfAImmDeactivate(HMODULE hMod);

BOOL    WINAPI CtfImmGenerateMessage(IN HIMC, BOOL fSendMsg);
#endif // CUAS_ENABLE
#endif /* WINVER >= 0x040A */



// wParam for WM_IME_CONTROL
#define IMC_FIRST                       0x0000

// 0x11 - 0x20 is reserved for soft keyboard

#define IMC_LAST                        0x0022

// wParam for WM_IME_SYSTEM
#define IMS_DESTROYWINDOW               0x0001
#define IMS_IME31COMPATIBLE             0x0002
#define IMS_SETOPENSTATUS               0x0003
#define IMS_SETACTIVECONTEXT            0x0004
#define IMS_CHANGE_SHOWSTAT             0x0005
#define IMS_WINDOWPOS                   0x0006


#define IMS_SENDIMEMSG                  0x0007
#define IMS_SENDIMEMSGEX                0x0008
#define IMS_SETCANDIDATEPOS             0x0009
#define IMS_SETCOMPOSITIONFONT          0x000A
#define IMS_SETCOMPOSITIONWINDOW        0x000B
#define IMS_CHECKENABLE                 0x000C
#define IMS_CONFIGUREIME                0x000D
#define IMS_CONTROLIMEMSG               0x000E
#define IMS_SETOPENCLOSE                0x000F
#define IMS_ISACTIVATED                 0x0010
#define IMS_UNLOADTHREADLAYOUT          0x0011
#define IMS_LCHGREQUEST                 0x0012
#define IMS_SETSOFTKBDONOFF             0x0013
#define IMS_GETCONVERSIONMODE           0x0014
#define IMS_IMEHELP                     0x0015

#define IMS_IMENT35SENDAPPMSG           0x0016
#define IMS_ACTIVATECONTEXT             0x0017
#define IMS_DEACTIVATECONTEXT           0x0018
#define IMS_ACTIVATETHREADLAYOUT        0x0019
#define IMS_CLOSEPROPERTYWINDOW         0x001a
#define IMS_OPENPROPERTYWINDOW          0x001b

#define IMS_GETIMEMENU                  0x001c
#define IMS_ENDIMEMENU                  0x001d

#define IMS_GETCONTEXT                  0x001e

#define IMS_SENDNOTIFICATION            0x001f
// IMS_SENDNOTIFICATION dirty bits for INPUTCONTEXT
 #define IMSS_UPDATE_OPEN               0x0001
 #define IMSS_UPDATE_CONVERSION         0x0002
 #define IMSS_UPDATE_SENTENCE           0x0004
 #define IMSS_INIT_OPEN                 0x0100

#define IMS_FINALIZE_COMPSTR            0x0020
#ifdef CUAS_ENABLE
#define IMS_LOADTHREADLAYOUT            0x0021
#define IMS_SETLANGBAND                 0x0023
#define IMS_RESETLANGBAND               0x0024
#endif // CUAS_ENABLE

// for NI_CONTEXTUPDATED
#define IMC_GETCONVERSIONMODE           0x0001
#define IMC_GETSENTENCEMODE             0x0003
#define IMC_GETOPENSTATUS               0x0005
// the return bits of ImmProcessHotKey
#define IPHK_HOTKEY                     0x0001
#define IPHK_PROCESSBYIME               0x0002
#define IPHK_CHECKCTRL                  0x0004
// NT only
#define IPHK_SKIPTHISKEY                0x0010

// the modifiers of hot key
#define MOD_WIN                         0x0008

// IME Hotkeys internal definitions
#define IME_CHOTKEY_FIRST                       0x10
#define IME_CHOTKEY_LAST                        0x2f
#define IME_JHOTKEY_FIRST                       0x30
#define IME_JHOTKEY_LAST                        0x4f
#define IME_KHOTKEY_FIRST                       0x50
#define IME_KHOTKEY_LAST                        0x6f
#define IME_THOTKEY_FIRST                       0x70
#define IME_THOTKEY_LAST                        0x8f
#define IME_INVALID_HOTKEY                      0xffffffff
#ifdef CUAS_ENABLE
#define GCS_COMPGUIDATTR                0x8000
#endif // CUAS_ENABLE
#ifdef CUAS_ENABLE
// bits of fdwInit of INPUTCONTEXT
#define INIT_GUID_ATOM                  0x00000040
#endif // CUAS_ENABLE

// fdw31Compat of INPUTCONTEXT
#define F31COMPAT_NOKEYTOIME     0x00000001
#define F31COMPAT_MCWHIDDEN      0x00000002
#define F31COMPAT_MCWVERTICAL    0x00000004
#define F31COMPAT_CALLFROMWINNLS 0x00000008
#define F31COMPAT_SAVECTRL       0x00010000
#define F31COMPAT_PROCESSEVENT   0x00020000
#define F31COMPAT_ECSETCFS       0x00040000

// the return value of ImmGetAppIMECompatFlags
#define IMECOMPAT_UNSYNC31IMEMSG 0x00000001
// the meaning of this bit depend on the same bit in
// IMELinkHdr.ctCountry.fdFlags
#define IMECOMPAT_DUMMYTASK      0x00000002
// For Japanese and Hangeul versions, this bit on
// indicates no dummy task is needed
#define IMECOMPAT_NODUMMYTASK    IMECOMPAT_DUMMYTASK
// For Chinese and PRC versions, this bit on indicates
// a dummy tasked is needed
#define IMECOMPAT_NEEDDUMMYTASK  IMECOMPAT_DUMMYTASK
#define IMECOMPAT_POSTDUMMY      0x00000004
#define IMECOMPAT_ECNOFLUSH      0x00000008
#define IMECOMPAT_NOINPUTLANGCHGTODLG   0x00000010
#define IMECOMPAT_ECREDRAWPARENT        0x00000020
#define IMECOMPAT_SENDOLDSBM            0x00000040
#define IMECOMPAT_UNSYNC31IMEMSG2       0x00000080
#define IMECOMPAT_NOIMEMSGINTERTASK     0x00000100
#define IMECOMPAT_USEXWANSUNG           0x00000200
#define IMECOMPAT_JXWFORATOK            0x00000400
#define IMECOMPAT_NOIME                 0x00000800
#define IMECOMPAT_NOKBDHOOK             0x00001000
#define IMECOMPAT_APPWNDREMOVEIMEMSGS   0x00002000
#define IMECOMPAT_LSTRCMP31COMPATIBLE   0x00004000
#define IMECOMPAT_USEALTSTKFORSHLEXEC   0x00008000
#define IMECOMPAT_NOVKPROCESSKEY        0x00010000
#define IMECOMPAT_NOYIELDWMCHAR         0x00020000
#define IMECOMPAT_SENDSC_RESTORE        0x00040000
#define IMECOMPAT_NOSENDLANGCHG         0x00080000
#define IMECOMPAT_FORCEUNSYNC31IMEMSG   0x00100000
#define IMECOMPAT_CONSOLEIMEPROCESS     0x00200000

//
// KOR only: do not finalize the composition
// string on mouse click
//
#define IMECOMPAT_NOFINALIZECOMPSTR     0x00400000

//
// Terminal Server Client (MSTSC.EXE) only:
//  If client machine connected Fujitsu Oasys keyboard, disable NlsKbdSendIMENotification call
//
#define IMECOMPAT_HYDRACLIENT           0x00800000

#ifdef CUAS_ENABLE
//
// Cicero Unaware Support
//    per process information
//
#define IMECOMPAT_AIMM_LEGACY_CLSID     0x01000000
#define IMECOMPAT_AIMM_TRIDENT55        0x02000000
#define IMECOMPAT_AIMM12_TRIDENT        0x04000000
#define IMECOMPAT_AIMM12                0x08000000
#endif // CUAS_ENABLE




#define IMGTF_CANT_SWITCH_LAYOUT        0x00000001
#define IMGTF_CANT_UNLOAD_IME           0x00000002

// all IME property bits, anyone add a new bit must update this !!!
#define IME_PROP_ALL                    0x001F003F
// all IME UICapability bits, anyone add a new bit must update this !!!
#define UI_CAP_ALL                      0x00010007
// ImmSetCompositionString Capability bits
// all ImmSetCompositionString Capability bits !!!
#define SCS_CAP_ALL                     0x00000007
// all IME WM_IME_SELECT inheritance Capability bits !!!
#define SELECT_CAP_ALL                  0x00000003
// ID for dwIndex of ImmGetProperty
// The value is the offset of IMEINFO structure
// last property index, anyone add a new property index must update this !!!
#define IGP_LAST                        IGP_SELECT
// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_SCREEN                      0x0004
#define CFS_VERTICAL                    0x0008
#define CFS_HIDDEN                      0x0010
// all conversion mode bits, anyone add a new bit must update this !!!
#define IME_CMODE_ALL                   0x0FFF
//
// This is extended NLS mode for console and console IME
//
#define IME_CMODE_OPEN              0x20000000
#define IME_CMODE_DISABLE           0x40000000

#ifdef CUAS_ENABLE
// bit field for extended conversion mode
#define IME_CMODE_GUID_NULL         0x80000000
#endif // CUAS_ENABLE
// all sentence mode bits, anyone add a new bit must update this !!!
#define IME_SMODE_ALL                   0x001F
#ifdef CUAS_ENABLE
// bit field for extended conversion mode
#define IME_SMODE_GUID_NULL         0x00008000
#endif // CUAS_ENABLE
#if (WINVER >= 0x040A)
#ifdef CUAS_ENABLE
// prototype of IME APIs for Cicero Bridge
HRESULT WINAPI CtfImeInquireEx(IN LPIMEINFO, OUT LPTSTR lpszUIClass, IN DWORD dwSystemInfoFlags, HKL hKL);
HRESULT WINAPI CtfImeCreateThreadMgr();
HRESULT WINAPI CtfImeDestroyThreadMgr();
HRESULT WINAPI CtfImeCreateInputContext(HIMC hImc);
HRESULT WINAPI CtfImeDestroyInputContext(HIMC hImc);
HRESULT WINAPI CtfImeSelectEx(HIMC hIMC, BOOL fSelect, HKL hKL);
HRESULT WINAPI CtfImeSetActiveContextAlways(HIMC hIMC, BOOL fOn, HWND hWnd, HKL hkl);
LRESULT WINAPI CtfImeEscapeEx(HIMC hIMC, UINT uSubFunc, LPVOID lpData, HKL hKL);
HRESULT WINAPI CtfImeGetGuidAtom(HIMC hIMC, BYTE bAttr, DWORD* pAtom);
BOOL    WINAPI CtfImeIsGuidMapEnable(HIMC hIMC);
BOOL    WINAPI CtfImeProcessCicHotkey(HIMC hIMC, UINT uVKey, LPARAM lParam);
#endif // CUAS_ENABLE
#endif /* WINVER >= 0x040A */

//
// nCode for MsctfCicNotify
//

#define CICN_LANGCHANGEHOTKEY 0x0001



//
// Pen Input support
//

#ifndef __cplusplus
//
// WM_COPYDATA format with Pen Input service
//
typedef struct tagPenInputData {
    DWORD dwVersion;
    DWORD flags;
    DWORD cnt;
    DWORD dwOffsetSymbols;
    DWORD dwOffsetSkip;
    DWORD dwOffsetScore;
    BYTE ab[0];
} PENINPUTDATA;
#endif // __cplusplus

#define LM_IMM_MAGIC            0x672c5c71

//#define LMDATA_SYMBOL_BYTE      0x00000001
//#define LMDATA_SYMBOL_WORD      0x00000002
#define LMDATA_SYMBOL_DWORD     0x00000004
//#define LMDATA_SYMBOL_QWORD     0x00000008
//#define LMDATA_SKIP_BYTE        0x00000010
#define LMDATA_SKIP_WORD        0x00000020
//#define LMDATA_SCORE_BYTE       0x00000040
#define LMDATA_SCORE_WORD       0x00000080
//#define LMDATA_SCORE_DWORD      0x00000100
//#define LMDATA_SCORE_QWORD      0x00000200
//#define LMDATA_SCORE_FLOAT      0x00000400
//#define LMDATA_SCORE_DOUBLE     0x00000800

//
// IMM private API for Pen Input
//
LRESULT WINAPI ImmSendMessageToActiveDefImeWndW(UINT msg, WPARAM wParam, LPARAM lParam);


#ifdef __cplusplus
}
#endif

#endif  // _IMMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\indicmlp.h ===
#ifdef __cplusplus
extern "C" {
#endif
//------------------------------------------------------------------//
//                                                                  //
// Internal ID for WM_COMMAND  of Indicator Window.                 //
//                                                                  //
//------------------------------------------------------------------//
#define CMDINDIC_REFRESHINDIC           249                         //
//                                                                  //
// defined in internat\exe\resource.h                               //
// #define IDM_RMENU_WHATSTHIS		250                         //
// #define IDM_RMENU_HELPFINDER		251                         //
// #define IDM_RMENU_PROPERTIES		252                         //
// #define IDM_EXIT			253                         //
// #define IDM_RMENU_IMEHELP		254                         //
//                                                                  //
#define CMDINDIC_EXIT                   259                         //
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\imep.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    imep.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the IME
    component.

--*/
#ifndef _IMEP_
#define _IMEP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

// IMESTRUCT structure for SendIMEMessage(Ex)
#if !defined(VK_DBE_IME_WORDREGISTER)
#define VK_DBE_IME_WORDREGISTER          VK_DBE_ENTERWORDREGISTERMODE
#define VK_DBE_IME_DIALOG                VK_DBE_ENTERIMECONFIGMODE
#define VK_DBE_FLUSH                     VK_DBE_FLUSHSTRING
#endif

#define VK_OEM_SEMICLN          0x0ba  //   ;  ** :
#define VK_OEM_EQUAL            0x0bb  //   =  ** +
#define VK_OEM_SLASH            0x0bf  //   /  ** ?
#define VK_OEM_LBRACKET         0x0db  //   [  ** {
#define VK_OEM_BSLASH           0x0dc  //   \  ** |
#define VK_OEM_RBRACKET         0x0dd  //   ]  ** |
#define VK_OEM_QUOTE            0x0de  //   '  ** "
//     switch for wParam of IME_MOVECONVERTWINDOW
#define MCW_CMD                 0x16        // command mask
#define MCW_CONSOLE_IME         0x8000
//    switch for wParam of IME_SET_MODE(IME_SETCONVERSIONMODE)
//       and IME_GET_MODE(IME_GETCONVERSIONMODE)
#define KOREA_IME_MODE_SBCSCHAR 0x0002
#define JAPAN_IME_MODE_SBCSCHAR 0x0008
// ;internal is added by JAPAN, CWIN user should ignore it
// 0x1, 0x2, 0x4, 0x20, 0x40, 0x80, 0x100 is not for CWIN
// 0x8, 0x10, and below IME_MODE_??? will be use by CWIN
#define IME_MODE_LHS                0x00200
#define IME_MODE_NOLHS              0x00400
#define IME_MODE_SK                 0x00800
#define IME_MODE_NOSK               0x01000
#define IME_MODE_XSPACE             0x02000
#define IME_MODE_NOXSPACE           0x04000
//     Subfunctions for WM_CONVERTREQUEST or WM_CONVERTREQUESTEX
#define IME_QUERY                 IME_GETIMECAPS
#define IME_ENABLEDOSIME          0x06
#define IME_ENABLE                IME_ENABLEDOSIME
#define IME_MOVECONVERTWINDOW     IME_SETCONVERSIONWINDOW
#define IME_GET_MODE              IME_GETCONVERSIONMODE
#define IME_SETCONVERSIONFONT     0x12
#define IME_SETFONT               IME_SETCONVERSIONFONT
#define IME_SENDKEY               IME_SENDVKEY
#define IME_DESTROYIME            0x14
#define IME_DESTROY               IME_DESTROYIME
#define IME_PRIVATE               0x15
#define IME_WINDOWUPDATE          0x16
#define IME_SELECT                0x17
#define IME_WORDREGISTER          IME_ENTERWORDREGISTERMODE
#define IME_DBCSNAME              0x1A
#define IME_MAXKEY                0x1B
#define IME_WINNLS_SK             0x1C
#define IME_CODECONVERT           0x20
#define IME_SETUSRFONT            0x20
#define IME_CONVERTLIST           0x21
#define IME_QUERYUSRFONT          0x21
#define IME_INPUTKEYTOSEQUENCE    0x22
#define IME_SEQUENCETOINTERNAL    0x23
#define IME_QUERYIMEINFO          0x24
#define IME_DIALOG                0x25
#define IME_AUTOMATA              0x30
#define IME_HANJAMODE             0x31
#define IME_GETLEVEL              0x40
#define IME_SETLEVEL              0x41
#define IME_GETMNTABLE            0x42  // reserved for HWIN

//#ifdef PEN
#define IME_SETUNDETERMINESTRING  0x50
#define IME_SETCAPTURE            0x51
//#endif
#define IME_CONSOLE_GET_PROCESSID     0x80                  // Win32
#define IME_CONSOLE_CREATE            0x81                  // Win32
#define IME_CONSOLE_DESTROY           0x82                  // Win32
#define IME_CONSOLE_SETFOCUS          0x83                  // Win32
#define IME_CONSOLE_KILLFOCUS         0x84                  // Win32
#define IME_CONSOLE_BUFFER_SIZE       0x85                  // Win32
#define IME_CONSOLE_WINDOW_SIZE       0x86                  // Win32
#define IME_CONSOLE_SET_IME_ON_WINDOW 0x87                  // Win32
#define IME_CONSOLE_MODEINFO          0x88
#define IME_PRIVATEFIRST          0x0100
#define IME_PRIVATELAST           0x04FF
#define IME_RS_CAPTURED         0x10    // IME is captured
#define IR_MOREROOM             0x110
#define IR_IMERELEASED          0x150
#define IMEVER_31               0x0a03
#ifdef __cplusplus
}
#endif  /* __cplusplus */
#endif  /* !_IMEP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\intlshar.h ===
/**********************************************************************/
/*      INTLSHAR.H - SHARED HEADER FOR INTERNAT.EXE                   */
/*                                                                    */
/*      Copyright (c) Microsoft Corporation. All rights reserved.     */
/**********************************************************************/

#ifndef _INTLSHAR_
#define _INTLSHAR_

/*
 * Ordinal exports in indicdll.dll
 */
#define ORD_REGISTERHOOK          1
#define ORD_STARTSHELL            2
#define ORD_STOPSHELL             3
#define ORD_GETLASTACTIVE         4
#define ORD_GETLASTFOCUS          5
#define ORD_SETNOTIFYWND          6
#define ORD_GETLAYOUT             7
#define ORD_GETIMESTAT            8
#define ORD_GETIMEMENU            9
#define ORD_BUILDIMEMENU          10
#define ORD_GETIMEMENUITEMID      11
#define ORD_GETIMEMENUITEMDATA    12
#define ORD_DESTROYIMEMENU        13
#define ORD_SETIMEMENUITEMDATA    14
#define ORD_GETCONSOLEIMEWND      15
#define ORD_GETDEFAULTIMEMENUITEM 16

#if !defined(NEED_ORDINAL_ONLY)

struct NotifyWindows {
    DWORD cbSize;
    HWND hwndNotify;
    HWND hwndTaskBar;
};

typedef int        (CALLBACK* REGHOOKPROC)(LPVOID, LPARAM);
typedef int        (CALLBACK* FPGETIMESTAT)(void);
typedef BOOL       (CALLBACK* FPGETIMEMENU)(HWND, BOOL);
typedef HKL        (CALLBACK* FPGETLAYOUT)(void);
typedef BOOL       (CALLBACK* FPBUILDIMEMENU)(HMENU, BOOL);
typedef UINT       (CALLBACK* FPGETIMEMENUITEMID)(int);
typedef int        (CALLBACK* FPDESTROYIMEMENU)(void);
typedef void       (CALLBACK* FPSETNOTIFYWND)(const struct NotifyWindows*);
typedef HWND       (CALLBACK* FPGETLASTACTIVE)(void);
typedef HWND       (CALLBACK* FPGETLASTFOCUS)(void);
typedef void       (CALLBACK* FPSETIMEMENUITEMDATA)(DWORD);
typedef BOOL       (CALLBACK* FPGETIMEMENUITEMDATA)(PUINT, PDWORD);
typedef HWND       (CALLBACK* FPGETCONSOLEIMEWND)(void);
typedef int        (CALLBACK* FPGETDEFAULTIMEMENUITEM)(void);

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\nddeagnt.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Private interface definition for having the NetDDE agent application
start the NetDDE services on the fly.

Created 11/5/93     SanfordS

--*/


#include <dde.h>
#define SZ_NDDEAGNT_SERVICE    TEXT("NDDEAgnt")
#define SZ_NDDEAGNT_TOPIC      TEXT("Start NetDDE Services")
#define SZ_NDDEAGNT_TITLE      TEXT("NetDDE Agent")
#define SZ_NDDEAGNT_CLASS      TEXT("NDDEAgnt")

#define START_NETDDE_SERVICES(hwnd)    {                                \
        ATOM aService, aTopic;                                          \
                                                                        \
        aService = GlobalAddAtom(SZ_NDDEAGNT_SERVICE);                  \
        aTopic = GlobalAddAtom(SZ_NDDEAGNT_TOPIC);                      \
        SendMessage(FindWindow(SZ_NDDEAGNT_CLASS, SZ_NDDEAGNT_TITLE),   \
                WM_DDE_INITIATE,                                        \
                (WPARAM)hwnd, MAKELPARAM(aService, aTopic));            \
        GlobalDeleteAtom(aService);                                     \
        GlobalDeleteAtom(aTopic);                                       \
    }

#define NETDDE_PIPE     L"\\\\.\\pipe\\NetDDE"

typedef struct {
    DWORD dwOffsetDesktop;
    WCHAR awchNames[64];
} NETDDE_PIPE_MESSAGE, *PNETDDE_PIPE_MESSAGE;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\mcdesc.h ===
/******************************Module*Header*******************************\
*
* Module Name: mcdesc.h
*
* Defines the enhanced ExtEscape functionality used for MCD support.
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
\**************************************************************************/

#ifndef __MCDESC_H__
#define __MCDESC_H__

// Escape through which all MCD functionality is accessed.

#ifndef MCDFUNCS
#define MCDFUNCS 3076
#endif

// Video memory surface description, for DDraw surface rendering.

typedef struct _MCDESC_SURFACE
{
    HANDLE hSurf;
    LONG lOffset;
    LONG lStride;
    RECTL rclPos;
} MCDESC_SURFACE;

// Data header for every escape.

typedef struct _MCDESC_HEADER
{
    ULONG flags;
    HANDLE hRC;
    HANDLE hSharedMem;
    VOID *pSharedMem;
    ULONG sharedMemSize;
    ULONG_PTR dwWindow;
    MCDESC_SURFACE msrfColor;
    MCDESC_SURFACE msrfDepth;
    ULONG cLockSurfaces;
    ULONG cExtraWndobj;
} MCDESC_HEADER;

// Data header used only on NT.

typedef struct _MCDESC_HEADER_NTPRIVATE
{
    struct _WNDOBJ *pwo;
    VOID *pBuffer;
    ULONG bufferSize;
    HANDLE *pLockSurfaces;
    HDC *pExtraWndobj;
} MCDESC_HEADER_NTPRIVATE;

// MCDESC_HEADER flags.

#define MCDESC_FL_CREATE_CONTEXT        0x00000001
#define MCDESC_FL_SURFACES              0x00000002
#define MCDESC_FL_LOCK_SURFACES         0x00000004
#define MCDESC_FL_EXTRA_WNDOBJ          0x00000008
#define MCDESC_FL_DISPLAY_LOCK          0x00000010
#define MCDESC_FL_BATCH                 0x00000020
// Used only for Win95.
#define MCDESC_FL_SWAPBUFFER            0x00000040

#define MCDESC_MAX_LOCK_SURFACES        12
#define MCDESC_MAX_EXTRA_WNDOBJ         16

// MCDSURFACE_HWND alias, used when creating contexts.
#define MCDESC_SURFACE_HWND             0x00000001

// Context creation information.
typedef struct _MCDESC_CREATE_CONTEXT
{
    ULONG flags;
    HWND hwnd;
} MCDESC_CREATE_CONTEXT;

#endif // __MCDESC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\msctfp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for msctfp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msctfp_h__
#define __msctfp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfThreadMgr_P_old_FWD_DEFINED__
#define __ITfThreadMgr_P_old_FWD_DEFINED__
typedef interface ITfThreadMgr_P_old ITfThreadMgr_P_old;
#endif 	/* __ITfThreadMgr_P_old_FWD_DEFINED__ */


#ifndef __ITfThreadMgr_P_FWD_DEFINED__
#define __ITfThreadMgr_P_FWD_DEFINED__
typedef interface ITfThreadMgr_P ITfThreadMgr_P;
#endif 	/* __ITfThreadMgr_P_FWD_DEFINED__ */


#ifndef __ITfKeystrokeMgr_P_FWD_DEFINED__
#define __ITfKeystrokeMgr_P_FWD_DEFINED__
typedef interface ITfKeystrokeMgr_P ITfKeystrokeMgr_P;
#endif 	/* __ITfKeystrokeMgr_P_FWD_DEFINED__ */


#ifndef __ITfSysHookSink_FWD_DEFINED__
#define __ITfSysHookSink_FWD_DEFINED__
typedef interface ITfSysHookSink ITfSysHookSink;
#endif 	/* __ITfSysHookSink_FWD_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_FWD_DEFINED__
#define __ITfStartReconversionNotifySink_FWD_DEFINED__
typedef interface ITfStartReconversionNotifySink ITfStartReconversionNotifySink;
#endif 	/* __ITfStartReconversionNotifySink_FWD_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_FWD_DEFINED__
#define __ITfLangBarEventSink_P_FWD_DEFINED__
typedef interface ITfLangBarEventSink_P ITfLangBarEventSink_P;
#endif 	/* __ITfLangBarEventSink_P_FWD_DEFINED__ */


#ifndef __ITfLangBarMgr_P_FWD_DEFINED__
#define __ITfLangBarMgr_P_FWD_DEFINED__
typedef interface ITfLangBarMgr_P ITfLangBarMgr_P;
#endif 	/* __ITfLangBarMgr_P_FWD_DEFINED__ */


#ifndef __ITfContext_P_FWD_DEFINED__
#define __ITfContext_P_FWD_DEFINED__
typedef interface ITfContext_P ITfContext_P;
#endif 	/* __ITfContext_P_FWD_DEFINED__ */


#ifndef __ITfRangeChangeSink_FWD_DEFINED__
#define __ITfRangeChangeSink_FWD_DEFINED__
typedef interface ITfRangeChangeSink ITfRangeChangeSink;
#endif 	/* __ITfRangeChangeSink_FWD_DEFINED__ */


#ifndef __ITfFnAbort_FWD_DEFINED__
#define __ITfFnAbort_FWD_DEFINED__
typedef interface ITfFnAbort ITfFnAbort;
#endif 	/* __ITfFnAbort_FWD_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_FWD_DEFINED__
#define __ITfMouseTrackerAnchor_FWD_DEFINED__
typedef interface ITfMouseTrackerAnchor ITfMouseTrackerAnchor;
#endif 	/* __ITfMouseTrackerAnchor_FWD_DEFINED__ */


#ifndef __ITfRangeAnchor_FWD_DEFINED__
#define __ITfRangeAnchor_FWD_DEFINED__
typedef interface ITfRangeAnchor ITfRangeAnchor;
#endif 	/* __ITfRangeAnchor_FWD_DEFINED__ */


#ifndef __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__
typedef interface ITfPersistentPropertyLoaderAnchor ITfPersistentPropertyLoaderAnchor;
#endif 	/* __ITfPersistentPropertyLoaderAnchor_FWD_DEFINED__ */


#ifndef __ITextStoreAnchorServices_FWD_DEFINED__
#define __ITextStoreAnchorServices_FWD_DEFINED__
typedef interface ITextStoreAnchorServices ITextStoreAnchorServices;
#endif 	/* __ITextStoreAnchorServices_FWD_DEFINED__ */


#ifndef __ITfProperty2_FWD_DEFINED__
#define __ITfProperty2_FWD_DEFINED__
typedef interface ITfProperty2 ITfProperty2;
#endif 	/* __ITfProperty2_FWD_DEFINED__ */


#ifndef __IEnumTfCollection_FWD_DEFINED__
#define __IEnumTfCollection_FWD_DEFINED__
typedef interface IEnumTfCollection IEnumTfCollection;
#endif 	/* __IEnumTfCollection_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionMgr ITfDisplayAttributeCollectionMgr;
#endif 	/* __ITfDisplayAttributeCollectionMgr_FWD_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__
typedef interface ITfDisplayAttributeCollectionProvider ITfDisplayAttributeCollectionProvider;
#endif 	/* __ITfDisplayAttributeCollectionProvider_FWD_DEFINED__ */


#ifndef __IEnumTfRenderingMarkup_FWD_DEFINED__
#define __IEnumTfRenderingMarkup_FWD_DEFINED__
typedef interface IEnumTfRenderingMarkup IEnumTfRenderingMarkup;
#endif 	/* __IEnumTfRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_FWD_DEFINED__
#define __ITfContextRenderingMarkup_FWD_DEFINED__
typedef interface ITfContextRenderingMarkup ITfContextRenderingMarkup;
#endif 	/* __ITfContextRenderingMarkup_FWD_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_FWD_DEFINED__
#define __ITfBackgroundThreadMgr_FWD_DEFINED__
typedef interface ITfBackgroundThreadMgr ITfBackgroundThreadMgr;
#endif 	/* __ITfBackgroundThreadMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msctfp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// msctfp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// MSCTF Private Interfaces.

#ifndef MSCTFP_DEFINED
#define MSCTFP_DEFINED

#include <windows.h>

EXTERN_C const GUID GUID_TFCAT_TIP_REFERENCE;
EXTERN_C const GUID GUID_TFCAT_TIP_PROOFING;
EXTERN_C const GUID GUID_TFCAT_TIP_SMARTTAG;
EXTERN_C const GUID GUID_TFCAT_PROPSTYLE_CUSTOM_COMPACT;
EXTERN_C const GUID GUID_SERVICE_TEXTSTORE;
EXTERN_C const GUID GUID_SERVICE_TF;
EXTERN_C const GUID GUID_COMPARTMENT_MSCANDIDATEUI_WINDOW;

#define TF_LBU_CAPSKANAKEY               1
#define TF_LBU_NTCONSOLELANGCHANGE       2
EXTERN_C const GUID GUID_MODEBIAS_DEFAULT;
#define TF_LBUF_CAPS        0x0001
#define TF_LBUF_KANA        0x0002
#define	TF_ES_READ_PROPERTY_WRITE	( 0x12 )

#define TF_PKEX_SYSHOTKEY    0x0001
#define TF_PKEX_NONEEDDIM    0x0002
#define TF_TMAE_NOACTIVATETIP   0x0001
#define TF_KEY_MSCTFIME      0x0001
#define TF_KEY_TEST          0x0002
#define TF_KEY_INTERNAL      0x0004


extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0000_v0_0_s_ifspec;

#ifndef __ITfThreadMgr_P_old_INTERFACE_DEFINED__
#define __ITfThreadMgr_P_old_INTERFACE_DEFINED__

/* interface ITfThreadMgr_P_old */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgr_P_old;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f65567a7-34a1-46f4-b5dd-8804aeb06ff7")
    ITfThreadMgr_P_old : public ITfThreadMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssociated( 
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSysHookSink( 
            /* [in] */ ITfSysHookSink *pSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestPostponedLock( 
            /* [in] */ ITfContext *pic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsKeystrokeFeedEnabled( 
            /* [out] */ BOOL *pfEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgr_P_oldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr_P_old * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr_P_old * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr_P_old * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssociated )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *SetSysHookSink )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ ITfSysHookSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RequestPostponedLock )( 
            ITfThreadMgr_P_old * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeystrokeFeedEnabled )( 
            ITfThreadMgr_P_old * This,
            /* [out] */ BOOL *pfEnabled);
        
        END_INTERFACE
    } ITfThreadMgr_P_oldVtbl;

    interface ITfThreadMgr_P_old
    {
        CONST_VTBL struct ITfThreadMgr_P_oldVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_P_old_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_P_old_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_P_old_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_P_old_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_P_old_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_P_old_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_P_old_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_P_old_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_P_old_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_P_old_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_P_old_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_P_old_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_P_old_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_P_old_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)


#define ITfThreadMgr_P_old_GetAssociated(This,hWnd,ppdim)	\
    (This)->lpVtbl -> GetAssociated(This,hWnd,ppdim)

#define ITfThreadMgr_P_old_SetSysHookSink(This,pSink)	\
    (This)->lpVtbl -> SetSysHookSink(This,pSink)

#define ITfThreadMgr_P_old_RequestPostponedLock(This,pic)	\
    (This)->lpVtbl -> RequestPostponedLock(This,pic)

#define ITfThreadMgr_P_old_IsKeystrokeFeedEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsKeystrokeFeedEnabled(This,pfEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_GetAssociated_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [in] */ HWND hWnd,
    /* [out] */ ITfDocumentMgr **ppdim);


void __RPC_STUB ITfThreadMgr_P_old_GetAssociated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_SetSysHookSink_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [in] */ ITfSysHookSink *pSink);


void __RPC_STUB ITfThreadMgr_P_old_SetSysHookSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_RequestPostponedLock_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfThreadMgr_P_old_RequestPostponedLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_old_IsKeystrokeFeedEnabled_Proxy( 
    ITfThreadMgr_P_old * This,
    /* [out] */ BOOL *pfEnabled);


void __RPC_STUB ITfThreadMgr_P_old_IsKeystrokeFeedEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_P_old_INTERFACE_DEFINED__ */


#ifndef __ITfThreadMgr_P_INTERFACE_DEFINED__
#define __ITfThreadMgr_P_INTERFACE_DEFINED__

/* interface ITfThreadMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfThreadMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c6247a1-2884-4b7c-af24-f198047aa728")
    ITfThreadMgr_P : public ITfThreadMgr_P_old
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallImm32HotkeyHanlder( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pbHandled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateEx( 
            /* [out] */ TfClientId *ptid,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfThreadMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfThreadMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ITfThreadMgr_P * This,
            /* [out] */ TfClientId *ptid);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ITfThreadMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDocumentMgr )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDocumentMgrs )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfDocumentMgrs **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfDocumentMgr **ppdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfDocumentMgr *pdimFocus);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateFocus )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hwnd,
            /* [unique][in] */ ITfDocumentMgr *pdimNew,
            /* [out] */ ITfDocumentMgr **ppdimPrev);
        
        HRESULT ( STDMETHODCALLTYPE *IsThreadFocus )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfThreadFocus);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionProvider )( 
            ITfThreadMgr_P * This,
            /* [in] */ REFCLSID clsid,
            /* [out] */ ITfFunctionProvider **ppFuncProv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumFunctionProviders )( 
            ITfThreadMgr_P * This,
            /* [out] */ IEnumTfFunctionProviders **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalCompartment )( 
            ITfThreadMgr_P * This,
            /* [out] */ ITfCompartmentMgr **ppCompMgr);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssociated )( 
            ITfThreadMgr_P * This,
            /* [in] */ HWND hWnd,
            /* [out] */ ITfDocumentMgr **ppdim);
        
        HRESULT ( STDMETHODCALLTYPE *SetSysHookSink )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfSysHookSink *pSink);
        
        HRESULT ( STDMETHODCALLTYPE *RequestPostponedLock )( 
            ITfThreadMgr_P * This,
            /* [in] */ ITfContext *pic);
        
        HRESULT ( STDMETHODCALLTYPE *IsKeystrokeFeedEnabled )( 
            ITfThreadMgr_P * This,
            /* [out] */ BOOL *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *CallImm32HotkeyHanlder )( 
            ITfThreadMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pbHandled);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateEx )( 
            ITfThreadMgr_P * This,
            /* [out] */ TfClientId *ptid,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } ITfThreadMgr_PVtbl;

    interface ITfThreadMgr_P
    {
        CONST_VTBL struct ITfThreadMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfThreadMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfThreadMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfThreadMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfThreadMgr_P_Activate(This,ptid)	\
    (This)->lpVtbl -> Activate(This,ptid)

#define ITfThreadMgr_P_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ITfThreadMgr_P_CreateDocumentMgr(This,ppdim)	\
    (This)->lpVtbl -> CreateDocumentMgr(This,ppdim)

#define ITfThreadMgr_P_EnumDocumentMgrs(This,ppEnum)	\
    (This)->lpVtbl -> EnumDocumentMgrs(This,ppEnum)

#define ITfThreadMgr_P_GetFocus(This,ppdimFocus)	\
    (This)->lpVtbl -> GetFocus(This,ppdimFocus)

#define ITfThreadMgr_P_SetFocus(This,pdimFocus)	\
    (This)->lpVtbl -> SetFocus(This,pdimFocus)

#define ITfThreadMgr_P_AssociateFocus(This,hwnd,pdimNew,ppdimPrev)	\
    (This)->lpVtbl -> AssociateFocus(This,hwnd,pdimNew,ppdimPrev)

#define ITfThreadMgr_P_IsThreadFocus(This,pfThreadFocus)	\
    (This)->lpVtbl -> IsThreadFocus(This,pfThreadFocus)

#define ITfThreadMgr_P_GetFunctionProvider(This,clsid,ppFuncProv)	\
    (This)->lpVtbl -> GetFunctionProvider(This,clsid,ppFuncProv)

#define ITfThreadMgr_P_EnumFunctionProviders(This,ppEnum)	\
    (This)->lpVtbl -> EnumFunctionProviders(This,ppEnum)

#define ITfThreadMgr_P_GetGlobalCompartment(This,ppCompMgr)	\
    (This)->lpVtbl -> GetGlobalCompartment(This,ppCompMgr)


#define ITfThreadMgr_P_GetAssociated(This,hWnd,ppdim)	\
    (This)->lpVtbl -> GetAssociated(This,hWnd,ppdim)

#define ITfThreadMgr_P_SetSysHookSink(This,pSink)	\
    (This)->lpVtbl -> SetSysHookSink(This,pSink)

#define ITfThreadMgr_P_RequestPostponedLock(This,pic)	\
    (This)->lpVtbl -> RequestPostponedLock(This,pic)

#define ITfThreadMgr_P_IsKeystrokeFeedEnabled(This,pfEnabled)	\
    (This)->lpVtbl -> IsKeystrokeFeedEnabled(This,pfEnabled)


#define ITfThreadMgr_P_CallImm32HotkeyHanlder(This,wParam,lParam,pbHandled)	\
    (This)->lpVtbl -> CallImm32HotkeyHanlder(This,wParam,lParam,pbHandled)

#define ITfThreadMgr_P_ActivateEx(This,ptid,dwFlags)	\
    (This)->lpVtbl -> ActivateEx(This,ptid,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_CallImm32HotkeyHanlder_Proxy( 
    ITfThreadMgr_P * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ BOOL *pbHandled);


void __RPC_STUB ITfThreadMgr_P_CallImm32HotkeyHanlder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfThreadMgr_P_ActivateEx_Proxy( 
    ITfThreadMgr_P * This,
    /* [out] */ TfClientId *ptid,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfThreadMgr_P_ActivateEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfThreadMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfKeystrokeMgr_P_INTERFACE_DEFINED__
#define __ITfKeystrokeMgr_P_INTERFACE_DEFINED__

/* interface ITfKeystrokeMgr_P */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfKeystrokeMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53fa1bec-5be1-458e-ae70-a9f1dc843e81")
    ITfKeystrokeMgr_P : public ITfKeystrokeMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreserveKeyEx( 
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeyDownUpEx( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfEaten) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfKeystrokeMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfKeystrokeMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfKeystrokeMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseKeyEventSink )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfKeyEventSink *pSink,
            /* [in] */ BOOL fForeground);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseKeyEventSink )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid);
        
        HRESULT ( STDMETHODCALLTYPE *GetForeground )( 
            ITfKeystrokeMgr_P * This,
            /* [out] */ CLSID *pclsid);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyDown )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *TestKeyUp )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDown )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *KeyUp )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *IsPreservedKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey,
            /* [out] */ BOOL *pfRegistered);
        
        HRESULT ( STDMETHODCALLTYPE *PreserveKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnpreserveKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *pprekey);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreservedKeyDescription )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreservedKeyDescription )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ BSTR *pbstrDesc);
        
        HRESULT ( STDMETHODCALLTYPE *SimulatePreservedKey )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID rguid,
            /* [out] */ BOOL *pfEaten);
        
        HRESULT ( STDMETHODCALLTYPE *PreserveKeyEx )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ REFGUID rguid,
            /* [in] */ const TF_PRESERVEDKEY *prekey,
            /* [size_is][in] */ const WCHAR *pchDesc,
            /* [in] */ ULONG cchDesc,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *KeyDownUpEx )( 
            ITfKeystrokeMgr_P * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfEaten);
        
        END_INTERFACE
    } ITfKeystrokeMgr_PVtbl;

    interface ITfKeystrokeMgr_P
    {
        CONST_VTBL struct ITfKeystrokeMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfKeystrokeMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfKeystrokeMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfKeystrokeMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfKeystrokeMgr_P_AdviseKeyEventSink(This,tid,pSink,fForeground)	\
    (This)->lpVtbl -> AdviseKeyEventSink(This,tid,pSink,fForeground)

#define ITfKeystrokeMgr_P_UnadviseKeyEventSink(This,tid)	\
    (This)->lpVtbl -> UnadviseKeyEventSink(This,tid)

#define ITfKeystrokeMgr_P_GetForeground(This,pclsid)	\
    (This)->lpVtbl -> GetForeground(This,pclsid)

#define ITfKeystrokeMgr_P_TestKeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_TestKeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> TestKeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_KeyDown(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyDown(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_KeyUp(This,wParam,lParam,pfEaten)	\
    (This)->lpVtbl -> KeyUp(This,wParam,lParam,pfEaten)

#define ITfKeystrokeMgr_P_GetPreservedKey(This,pic,pprekey,pguid)	\
    (This)->lpVtbl -> GetPreservedKey(This,pic,pprekey,pguid)

#define ITfKeystrokeMgr_P_IsPreservedKey(This,rguid,pprekey,pfRegistered)	\
    (This)->lpVtbl -> IsPreservedKey(This,rguid,pprekey,pfRegistered)

#define ITfKeystrokeMgr_P_PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)	\
    (This)->lpVtbl -> PreserveKey(This,tid,rguid,prekey,pchDesc,cchDesc)

#define ITfKeystrokeMgr_P_UnpreserveKey(This,rguid,pprekey)	\
    (This)->lpVtbl -> UnpreserveKey(This,rguid,pprekey)

#define ITfKeystrokeMgr_P_SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)	\
    (This)->lpVtbl -> SetPreservedKeyDescription(This,rguid,pchDesc,cchDesc)

#define ITfKeystrokeMgr_P_GetPreservedKeyDescription(This,rguid,pbstrDesc)	\
    (This)->lpVtbl -> GetPreservedKeyDescription(This,rguid,pbstrDesc)

#define ITfKeystrokeMgr_P_SimulatePreservedKey(This,pic,rguid,pfEaten)	\
    (This)->lpVtbl -> SimulatePreservedKey(This,pic,rguid,pfEaten)


#define ITfKeystrokeMgr_P_PreserveKeyEx(This,tid,rguid,prekey,pchDesc,cchDesc,dwFlags)	\
    (This)->lpVtbl -> PreserveKeyEx(This,tid,rguid,prekey,pchDesc,cchDesc,dwFlags)

#define ITfKeystrokeMgr_P_KeyDownUpEx(This,wParam,lParam,dwFlags,pfEaten)	\
    (This)->lpVtbl -> KeyDownUpEx(This,wParam,lParam,dwFlags,pfEaten)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_P_PreserveKeyEx_Proxy( 
    ITfKeystrokeMgr_P * This,
    /* [in] */ TfClientId tid,
    /* [in] */ REFGUID rguid,
    /* [in] */ const TF_PRESERVEDKEY *prekey,
    /* [size_is][in] */ const WCHAR *pchDesc,
    /* [in] */ ULONG cchDesc,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfKeystrokeMgr_P_PreserveKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfKeystrokeMgr_P_KeyDownUpEx_Proxy( 
    ITfKeystrokeMgr_P * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BOOL *pfEaten);


void __RPC_STUB ITfKeystrokeMgr_P_KeyDownUpEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfKeystrokeMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfSysHookSink_INTERFACE_DEFINED__
#define __ITfSysHookSink_INTERFACE_DEFINED__

/* interface ITfSysHookSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSysHookSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("495388DA-21A5-4852-8BB1-ED2F29DA8D60")
    ITfSysHookSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnPreFocusDIM( 
            /* [in] */ HWND hWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysKeyboardProc( 
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSysShellProc( 
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSysHookSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSysHookSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSysHookSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSysHookSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnPreFocusDIM )( 
            ITfSysHookSink * This,
            /* [in] */ HWND hWnd);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysKeyboardProc )( 
            ITfSysHookSink * This,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *OnSysShellProc )( 
            ITfSysHookSink * This,
            /* [in] */ int nCode,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfSysHookSinkVtbl;

    interface ITfSysHookSink
    {
        CONST_VTBL struct ITfSysHookSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSysHookSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSysHookSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSysHookSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSysHookSink_OnPreFocusDIM(This,hWnd)	\
    (This)->lpVtbl -> OnPreFocusDIM(This,hWnd)

#define ITfSysHookSink_OnSysKeyboardProc(This,wParam,lParam)	\
    (This)->lpVtbl -> OnSysKeyboardProc(This,wParam,lParam)

#define ITfSysHookSink_OnSysShellProc(This,nCode,wParam,lParam)	\
    (This)->lpVtbl -> OnSysShellProc(This,nCode,wParam,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnPreFocusDIM_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB ITfSysHookSink_OnPreFocusDIM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysKeyboardProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysKeyboardProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSysHookSink_OnSysShellProc_Proxy( 
    ITfSysHookSink * This,
    /* [in] */ int nCode,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfSysHookSink_OnSysShellProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSysHookSink_INTERFACE_DEFINED__ */


#ifndef __ITfStartReconversionNotifySink_INTERFACE_DEFINED__
#define __ITfStartReconversionNotifySink_INTERFACE_DEFINED__

/* interface ITfStartReconversionNotifySink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfStartReconversionNotifySink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b9cd19cb-2919-4935-8768-ef30bae9a0cc")
    ITfStartReconversionNotifySink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartReconversion( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndReconversion( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfStartReconversionNotifySinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfStartReconversionNotifySink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfStartReconversionNotifySink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndReconversion )( 
            ITfStartReconversionNotifySink * This);
        
        END_INTERFACE
    } ITfStartReconversionNotifySinkVtbl;

    interface ITfStartReconversionNotifySink
    {
        CONST_VTBL struct ITfStartReconversionNotifySinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfStartReconversionNotifySink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfStartReconversionNotifySink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfStartReconversionNotifySink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfStartReconversionNotifySink_StartReconversion(This)	\
    (This)->lpVtbl -> StartReconversion(This)

#define ITfStartReconversionNotifySink_EndReconversion(This)	\
    (This)->lpVtbl -> EndReconversion(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_StartReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_StartReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfStartReconversionNotifySink_EndReconversion_Proxy( 
    ITfStartReconversionNotifySink * This);


void __RPC_STUB ITfStartReconversionNotifySink_EndReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfStartReconversionNotifySink_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarEventSink_P_INTERFACE_DEFINED__
#define __ITfLangBarEventSink_P_INTERFACE_DEFINED__

/* interface ITfLangBarEventSink_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarEventSink_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a460360-da21-4b09-a8a0-8a69e728d893")
    ITfLangBarEventSink_P : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnLangBarUpdate( 
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarEventSink_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarEventSink_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarEventSink_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnLangBarUpdate )( 
            ITfLangBarEventSink_P * This,
            /* [in] */ UINT uPdate,
            /* [in] */ LPARAM lParam);
        
        END_INTERFACE
    } ITfLangBarEventSink_PVtbl;

    interface ITfLangBarEventSink_P
    {
        CONST_VTBL struct ITfLangBarEventSink_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarEventSink_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarEventSink_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarEventSink_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarEventSink_P_OnLangBarUpdate(This,uPdate,lParam)	\
    (This)->lpVtbl -> OnLangBarUpdate(This,uPdate,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_P_OnLangBarUpdate_Proxy( 
    ITfLangBarEventSink_P * This,
    /* [in] */ UINT uPdate,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfLangBarEventSink_P_OnLangBarUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarEventSink_P_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarMgr_P_INTERFACE_DEFINED__
#define __ITfLangBarMgr_P_INTERFACE_DEFINED__

/* interface ITfLangBarMgr_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarMgr_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d72c0fa9-add5-4af0-8706-4fa9ae3e2eff")
    ITfLangBarMgr_P : public ITfLangBarMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPrevShowFloatingStatus( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarMgr_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarMgr_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarMgr_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseEventSink )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadMarshalInterface )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadLangBarItemMgr )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProcessorProfiles )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLastFocus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwThreadId,
            /* [in] */ BOOL fPrev);
        
        HRESULT ( STDMETHODCALLTYPE *SetModalInput )( 
            ITfLangBarMgr_P * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarMgr_P * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevShowFloatingStatus )( 
            ITfLangBarMgr_P * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfLangBarMgr_PVtbl;

    interface ITfLangBarMgr_P
    {
        CONST_VTBL struct ITfLangBarMgr_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarMgr_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarMgr_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarMgr_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarMgr_P_AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)	\
    (This)->lpVtbl -> AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)

#define ITfLangBarMgr_P_UnadviseEventSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseEventSink(This,dwCookie)

#define ITfLangBarMgr_P_GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)	\
    (This)->lpVtbl -> GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)

#define ITfLangBarMgr_P_GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)	\
    (This)->lpVtbl -> GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)

#define ITfLangBarMgr_P_GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)	\
    (This)->lpVtbl -> GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)

#define ITfLangBarMgr_P_RestoreLastFocus(This,pdwThreadId,fPrev)	\
    (This)->lpVtbl -> RestoreLastFocus(This,pdwThreadId,fPrev)

#define ITfLangBarMgr_P_SetModalInput(This,pSink,dwThreadId,dwFlags)	\
    (This)->lpVtbl -> SetModalInput(This,pSink,dwThreadId,dwFlags)

#define ITfLangBarMgr_P_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarMgr_P_GetShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetShowFloatingStatus(This,pdwFlags)


#define ITfLangBarMgr_P_GetPrevShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetPrevShowFloatingStatus(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarMgr_P_GetPrevShowFloatingStatus_Proxy( 
    ITfLangBarMgr_P * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ITfLangBarMgr_P_GetPrevShowFloatingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarMgr_P_INTERFACE_DEFINED__ */


#ifndef __ITfContext_P_INTERFACE_DEFINED__
#define __ITfContext_P_INTERFACE_DEFINED__

/* interface ITfContext_P */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfContext_P;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dee47c8-704d-42a0-9983-ffeed659b64d")
    ITfContext_P : public ITfContext
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapAppProperty( 
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLockRequestPosting( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContext_PVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContext_P * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContext_P * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContext_P * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestEditSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [in] */ ITfEditSession *pes,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HRESULT *phrSession);
        
        HRESULT ( STDMETHODCALLTYPE *InWriteSession )( 
            ITfContext_P * This,
            /* [in] */ TfClientId tid,
            /* [out] */ BOOL *pfWriteSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulIndex,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_SELECTION *pSelection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelection )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const TF_SELECTION *pSelection);
        
        HRESULT ( STDMETHODCALLTYPE *GetStart )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnd )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ ITfRange **ppEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveView )( 
            ITfContext_P * This,
            /* [out] */ ITfContextView **ppView);
        
        HRESULT ( STDMETHODCALLTYPE *EnumViews )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfContextViews **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfContext_P * This,
            /* [out] */ TF_STATUS *pdcs);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidProp,
            /* [out] */ ITfReadOnlyProperty **ppProp);
        
        HRESULT ( STDMETHODCALLTYPE *TrackProperties )( 
            ITfContext_P * This,
            /* [size_is][in] */ const GUID **prgProp,
            /* [in] */ ULONG cProp,
            /* [size_is][in] */ const GUID **prgAppProp,
            /* [in] */ ULONG cAppProp,
            /* [out] */ ITfReadOnlyProperty **ppProperty);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            ITfContext_P * This,
            /* [out] */ IEnumTfProperties **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentMgr )( 
            ITfContext_P * This,
            /* [out] */ ITfDocumentMgr **ppDm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRangeBackup )( 
            ITfContext_P * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRangeBackup **ppBackup);
        
        HRESULT ( STDMETHODCALLTYPE *MapAppProperty )( 
            ITfContext_P * This,
            /* [in] */ REFGUID guidAppProp,
            /* [in] */ REFGUID guidProp);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLockRequestPosting )( 
            ITfContext_P * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } ITfContext_PVtbl;

    interface ITfContext_P
    {
        CONST_VTBL struct ITfContext_PVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContext_P_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContext_P_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContext_P_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContext_P_RequestEditSession(This,tid,pes,dwFlags,phrSession)	\
    (This)->lpVtbl -> RequestEditSession(This,tid,pes,dwFlags,phrSession)

#define ITfContext_P_InWriteSession(This,tid,pfWriteSession)	\
    (This)->lpVtbl -> InWriteSession(This,tid,pfWriteSession)

#define ITfContext_P_GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)	\
    (This)->lpVtbl -> GetSelection(This,ec,ulIndex,ulCount,pSelection,pcFetched)

#define ITfContext_P_SetSelection(This,ec,ulCount,pSelection)	\
    (This)->lpVtbl -> SetSelection(This,ec,ulCount,pSelection)

#define ITfContext_P_GetStart(This,ec,ppStart)	\
    (This)->lpVtbl -> GetStart(This,ec,ppStart)

#define ITfContext_P_GetEnd(This,ec,ppEnd)	\
    (This)->lpVtbl -> GetEnd(This,ec,ppEnd)

#define ITfContext_P_GetActiveView(This,ppView)	\
    (This)->lpVtbl -> GetActiveView(This,ppView)

#define ITfContext_P_EnumViews(This,ppEnum)	\
    (This)->lpVtbl -> EnumViews(This,ppEnum)

#define ITfContext_P_GetStatus(This,pdcs)	\
    (This)->lpVtbl -> GetStatus(This,pdcs)

#define ITfContext_P_GetProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetProperty(This,guidProp,ppProp)

#define ITfContext_P_GetAppProperty(This,guidProp,ppProp)	\
    (This)->lpVtbl -> GetAppProperty(This,guidProp,ppProp)

#define ITfContext_P_TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)	\
    (This)->lpVtbl -> TrackProperties(This,prgProp,cProp,prgAppProp,cAppProp,ppProperty)

#define ITfContext_P_EnumProperties(This,ppEnum)	\
    (This)->lpVtbl -> EnumProperties(This,ppEnum)

#define ITfContext_P_GetDocumentMgr(This,ppDm)	\
    (This)->lpVtbl -> GetDocumentMgr(This,ppDm)

#define ITfContext_P_CreateRangeBackup(This,ec,pRange,ppBackup)	\
    (This)->lpVtbl -> CreateRangeBackup(This,ec,pRange,ppBackup)


#define ITfContext_P_MapAppProperty(This,guidAppProp,guidProp)	\
    (This)->lpVtbl -> MapAppProperty(This,guidAppProp,guidProp)

#define ITfContext_P_EnableLockRequestPosting(This,fEnable)	\
    (This)->lpVtbl -> EnableLockRequestPosting(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContext_P_MapAppProperty_Proxy( 
    ITfContext_P * This,
    /* [in] */ REFGUID guidAppProp,
    /* [in] */ REFGUID guidProp);


void __RPC_STUB ITfContext_P_MapAppProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContext_P_EnableLockRequestPosting_Proxy( 
    ITfContext_P * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB ITfContext_P_EnableLockRequestPosting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContext_P_INTERFACE_DEFINED__ */


#ifndef __ITfRangeChangeSink_INTERFACE_DEFINED__
#define __ITfRangeChangeSink_INTERFACE_DEFINED__

/* interface ITfRangeChangeSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeChangeSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1a0e6af-0d60-4800-9796-1fe8e85c0cca")
    ITfRangeChangeSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnChange( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeChangeSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeChangeSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeChangeSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeChangeSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnChange )( 
            ITfRangeChangeSink * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfRangeChangeSinkVtbl;

    interface ITfRangeChangeSink
    {
        CONST_VTBL struct ITfRangeChangeSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeChangeSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeChangeSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeChangeSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeChangeSink_OnChange(This,pRange)	\
    (This)->lpVtbl -> OnChange(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeChangeSink_OnChange_Proxy( 
    ITfRangeChangeSink * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfRangeChangeSink_OnChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeChangeSink_INTERFACE_DEFINED__ */


#ifndef __ITfFnAbort_INTERFACE_DEFINED__
#define __ITfFnAbort_INTERFACE_DEFINED__

/* interface ITfFnAbort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17f2317f-addb-49df-870e-66227bc51d1a")
    ITfFnAbort : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAbort * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITfFnAbort * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfFnAbortVtbl;

    interface ITfFnAbort
    {
        CONST_VTBL struct ITfFnAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAbort_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAbort_Abort(This,pic)	\
    (This)->lpVtbl -> Abort(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAbort_Abort_Proxy( 
    ITfFnAbort * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfFnAbort_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAbort_INTERFACE_DEFINED__ */


#ifndef __ITfMouseTrackerAnchor_INTERFACE_DEFINED__
#define __ITfMouseTrackerAnchor_INTERFACE_DEFINED__

/* interface ITfMouseTrackerAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfMouseTrackerAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f9f4e0f2-d600-4a4c-b144-77e201ebd1b0")
    ITfMouseTrackerAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseMouseSink( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseMouseSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMouseTrackerAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMouseTrackerAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMouseTrackerAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [in] */ ITfMouseSink *pSink,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseMouseSink )( 
            ITfMouseTrackerAnchor * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } ITfMouseTrackerAnchorVtbl;

    interface ITfMouseTrackerAnchor
    {
        CONST_VTBL struct ITfMouseTrackerAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMouseTrackerAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMouseTrackerAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMouseTrackerAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMouseTrackerAnchor_AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)	\
    (This)->lpVtbl -> AdviseMouseSink(This,paStart,paEnd,pSink,pdwCookie)

#define ITfMouseTrackerAnchor_UnadviseMouseSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseMouseSink(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_AdviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [in] */ ITfMouseSink *pSink,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_AdviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfMouseTrackerAnchor_UnadviseMouseSink_Proxy( 
    ITfMouseTrackerAnchor * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfMouseTrackerAnchor_UnadviseMouseSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMouseTrackerAnchor_INTERFACE_DEFINED__ */


#ifndef __ITfRangeAnchor_INTERFACE_DEFINED__
#define __ITfRangeAnchor_INTERFACE_DEFINED__

/* interface ITfRangeAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfRangeAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8b99712b-5815-4bcc-b9a9-53db1c8d6755")
    ITfRangeAnchor : public ITfRange
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtent( 
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtent( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfRangeAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfRangeAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfRangeAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfRangeAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [length_is][size_is][out] */ WCHAR *pchText,
            /* [in] */ ULONG cchMax,
            /* [out] */ ULONG *pcch);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [unique][size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormattedText )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IDataObject **ppDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ REFGUID rguidService,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *InsertEmbedded )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDataObject *pDataObject);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ LONG cchReq,
            /* [out] */ LONG *pcch,
            /* [unique][in] */ const TF_HALTCOND *pHalt);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndToRange )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftStartRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *ShiftEndRegion )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfShiftDir dir,
            /* [out] */ BOOL *pfNoRegion);
        
        HRESULT ( STDMETHODCALLTYPE *IsEmpty )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ BOOL *pfEmpty);
        
        HRESULT ( STDMETHODCALLTYPE *Collapse )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqualEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *CompareStart )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *CompareEnd )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pWith,
            /* [in] */ TfAnchor aPos,
            /* [out] */ LONG *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustForInsert )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ULONG cchInsert,
            /* [out] */ BOOL *pfInsertOk);
        
        HRESULT ( STDMETHODCALLTYPE *GetGravity )( 
            ITfRangeAnchor * This,
            /* [out] */ TfGravity *pgStart,
            /* [out] */ TfGravity *pgEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGravity )( 
            ITfRangeAnchor * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ TfGravity gStart,
            /* [in] */ TfGravity gEnd);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfRange **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfRangeAnchor * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetExtent )( 
            ITfRangeAnchor * This,
            /* [out] */ IAnchor **ppaStart,
            /* [out] */ IAnchor **ppaEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtent )( 
            ITfRangeAnchor * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd);
        
        END_INTERFACE
    } ITfRangeAnchorVtbl;

    interface ITfRangeAnchor
    {
        CONST_VTBL struct ITfRangeAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfRangeAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfRangeAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfRangeAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfRangeAnchor_GetText(This,ec,dwFlags,pchText,cchMax,pcch)	\
    (This)->lpVtbl -> GetText(This,ec,dwFlags,pchText,cchMax,pcch)

#define ITfRangeAnchor_SetText(This,ec,dwFlags,pchText,cch)	\
    (This)->lpVtbl -> SetText(This,ec,dwFlags,pchText,cch)

#define ITfRangeAnchor_GetFormattedText(This,ec,ppDataObject)	\
    (This)->lpVtbl -> GetFormattedText(This,ec,ppDataObject)

#define ITfRangeAnchor_GetEmbedded(This,ec,rguidService,riid,ppunk)	\
    (This)->lpVtbl -> GetEmbedded(This,ec,rguidService,riid,ppunk)

#define ITfRangeAnchor_InsertEmbedded(This,ec,dwFlags,pDataObject)	\
    (This)->lpVtbl -> InsertEmbedded(This,ec,dwFlags,pDataObject)

#define ITfRangeAnchor_ShiftStart(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftStart(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftEnd(This,ec,cchReq,pcch,pHalt)	\
    (This)->lpVtbl -> ShiftEnd(This,ec,cchReq,pcch,pHalt)

#define ITfRangeAnchor_ShiftStartToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftStartToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftEndToRange(This,ec,pRange,aPos)	\
    (This)->lpVtbl -> ShiftEndToRange(This,ec,pRange,aPos)

#define ITfRangeAnchor_ShiftStartRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftStartRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_ShiftEndRegion(This,ec,dir,pfNoRegion)	\
    (This)->lpVtbl -> ShiftEndRegion(This,ec,dir,pfNoRegion)

#define ITfRangeAnchor_IsEmpty(This,ec,pfEmpty)	\
    (This)->lpVtbl -> IsEmpty(This,ec,pfEmpty)

#define ITfRangeAnchor_Collapse(This,ec,aPos)	\
    (This)->lpVtbl -> Collapse(This,ec,aPos)

#define ITfRangeAnchor_IsEqualStart(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualStart(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_IsEqualEnd(This,ec,pWith,aPos,pfEqual)	\
    (This)->lpVtbl -> IsEqualEnd(This,ec,pWith,aPos,pfEqual)

#define ITfRangeAnchor_CompareStart(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareStart(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_CompareEnd(This,ec,pWith,aPos,plResult)	\
    (This)->lpVtbl -> CompareEnd(This,ec,pWith,aPos,plResult)

#define ITfRangeAnchor_AdjustForInsert(This,ec,cchInsert,pfInsertOk)	\
    (This)->lpVtbl -> AdjustForInsert(This,ec,cchInsert,pfInsertOk)

#define ITfRangeAnchor_GetGravity(This,pgStart,pgEnd)	\
    (This)->lpVtbl -> GetGravity(This,pgStart,pgEnd)

#define ITfRangeAnchor_SetGravity(This,ec,gStart,gEnd)	\
    (This)->lpVtbl -> SetGravity(This,ec,gStart,gEnd)

#define ITfRangeAnchor_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define ITfRangeAnchor_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfRangeAnchor_GetExtent(This,ppaStart,ppaEnd)	\
    (This)->lpVtbl -> GetExtent(This,ppaStart,ppaEnd)

#define ITfRangeAnchor_SetExtent(This,paStart,paEnd)	\
    (This)->lpVtbl -> SetExtent(This,paStart,paEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfRangeAnchor_GetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [out] */ IAnchor **ppaStart,
    /* [out] */ IAnchor **ppaEnd);


void __RPC_STUB ITfRangeAnchor_GetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfRangeAnchor_SetExtent_Proxy( 
    ITfRangeAnchor * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd);


void __RPC_STUB ITfRangeAnchor_SetExtent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfRangeAnchor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0226 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("af9f076f-4937-4285-8600-81dca5c31eb6") struct TF_PERSISTENT_PROPERTY_HEADER_ANCHOR
    {
    GUID guidType;
    IAnchor *paStart;
    IAnchor *paEnd;
    ULONG cb;
    DWORD dwPrivate;
    CLSID clsidTIP;
    } 	TF_PERSISTENT_PROPERTY_HEADER_ANCHOR;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0226_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0226_v0_0_s_ifspec;

#ifndef __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__
#define __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__

/* interface ITfPersistentPropertyLoaderAnchor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfPersistentPropertyLoaderAnchor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2133f790-34c2-11d3-a745-0050040ab407")
    ITfPersistentPropertyLoaderAnchor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadProperty( 
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfPersistentPropertyLoaderAnchorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfPersistentPropertyLoaderAnchor * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadProperty )( 
            ITfPersistentPropertyLoaderAnchor * This,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [out] */ IStream **ppStream);
        
        END_INTERFACE
    } ITfPersistentPropertyLoaderAnchorVtbl;

    interface ITfPersistentPropertyLoaderAnchor
    {
        CONST_VTBL struct ITfPersistentPropertyLoaderAnchorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfPersistentPropertyLoaderAnchor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfPersistentPropertyLoaderAnchor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfPersistentPropertyLoaderAnchor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfPersistentPropertyLoaderAnchor_LoadProperty(This,pHdr,ppStream)	\
    (This)->lpVtbl -> LoadProperty(This,pHdr,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfPersistentPropertyLoaderAnchor_LoadProperty_Proxy( 
    ITfPersistentPropertyLoaderAnchor * This,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [out] */ IStream **ppStream);


void __RPC_STUB ITfPersistentPropertyLoaderAnchor_LoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfPersistentPropertyLoaderAnchor_INTERFACE_DEFINED__ */


#ifndef __ITextStoreAnchorServices_INTERFACE_DEFINED__
#define __ITextStoreAnchorServices_INTERFACE_DEFINED__

/* interface ITextStoreAnchorServices */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITextStoreAnchorServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa80e9fe-2021-11d2-93e0-0060b067b86e")
    ITextStoreAnchorServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Serialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unserialize( 
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceLoadProperty( 
            /* [in] */ ITfProperty *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRange( 
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITextStoreAnchorServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITextStoreAnchorServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITextStoreAnchorServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITextStoreAnchorServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Serialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ ITfRange *pRange,
            /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Unserialize )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp,
            /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
            /* [in] */ IStream *pStream,
            /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);
        
        HRESULT ( STDMETHODCALLTYPE *ForceLoadProperty )( 
            ITextStoreAnchorServices * This,
            /* [in] */ ITfProperty *pProp);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRange )( 
            ITextStoreAnchorServices * This,
            /* [in] */ IAnchor *paStart,
            /* [in] */ IAnchor *paEnd,
            /* [out] */ ITfRangeAnchor **ppRange);
        
        END_INTERFACE
    } ITextStoreAnchorServicesVtbl;

    interface ITextStoreAnchorServices
    {
        CONST_VTBL struct ITextStoreAnchorServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITextStoreAnchorServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoreAnchorServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoreAnchorServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoreAnchorServices_Serialize(This,pProp,pRange,pHdr,pStream)	\
    (This)->lpVtbl -> Serialize(This,pProp,pRange,pHdr,pStream)

#define ITextStoreAnchorServices_Unserialize(This,pProp,pHdr,pStream,pLoader)	\
    (This)->lpVtbl -> Unserialize(This,pProp,pHdr,pStream,pLoader)

#define ITextStoreAnchorServices_ForceLoadProperty(This,pProp)	\
    (This)->lpVtbl -> ForceLoadProperty(This,pProp)

#define ITextStoreAnchorServices_CreateRange(This,paStart,paEnd,ppRange)	\
    (This)->lpVtbl -> CreateRange(This,paStart,paEnd,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Serialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ ITfRange *pRange,
    /* [out] */ TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream);


void __RPC_STUB ITextStoreAnchorServices_Serialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_Unserialize_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp,
    /* [in] */ const TF_PERSISTENT_PROPERTY_HEADER_ANCHOR *pHdr,
    /* [in] */ IStream *pStream,
    /* [in] */ ITfPersistentPropertyLoaderAnchor *pLoader);


void __RPC_STUB ITextStoreAnchorServices_Unserialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_ForceLoadProperty_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ ITfProperty *pProp);


void __RPC_STUB ITextStoreAnchorServices_ForceLoadProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITextStoreAnchorServices_CreateRange_Proxy( 
    ITextStoreAnchorServices * This,
    /* [in] */ IAnchor *paStart,
    /* [in] */ IAnchor *paEnd,
    /* [out] */ ITfRangeAnchor **ppRange);


void __RPC_STUB ITextStoreAnchorServices_CreateRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoreAnchorServices_INTERFACE_DEFINED__ */


#ifndef __ITfProperty2_INTERFACE_DEFINED__
#define __ITfProperty2_INTERFACE_DEFINED__

/* interface ITfProperty2 */
/* [unique][uuid][object] */ 

#define	TF_FNV_BACKWARD	( 0x1 )

#define	TF_FNV_NO_CONTAINED	( 0x2 )


EXTERN_C const IID IID_ITfProperty2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("db261faa-2142-486a-b5c6-d2101bc03d2e")
    ITfProperty2 : public ITfProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindNextValue( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfProperty2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfProperty2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfProperty2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfProperty2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ITfProperty2 * This,
            /* [out] */ GUID *pguid);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRanges )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [out] */ IEnumTfRanges **ppEnum,
            /* [in] */ ITfRange *pTargetRange);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ITfProperty2 * This,
            /* [out] */ ITfContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *FindRange )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppRange,
            /* [in] */ TfAnchor aPos);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueStore )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfPropertyStore *pPropStore);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange,
            /* [in] */ const VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextValue )( 
            ITfProperty2 * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BOOL *pfContained,
            /* [out] */ ITfRange **ppRangeNextValue);
        
        END_INTERFACE
    } ITfProperty2Vtbl;

    interface ITfProperty2
    {
        CONST_VTBL struct ITfProperty2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfProperty2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfProperty2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfProperty2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfProperty2_GetType(This,pguid)	\
    (This)->lpVtbl -> GetType(This,pguid)

#define ITfProperty2_EnumRanges(This,ec,ppEnum,pTargetRange)	\
    (This)->lpVtbl -> EnumRanges(This,ec,ppEnum,pTargetRange)

#define ITfProperty2_GetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)


#define ITfProperty2_FindRange(This,ec,pRange,ppRange,aPos)	\
    (This)->lpVtbl -> FindRange(This,ec,pRange,ppRange,aPos)

#define ITfProperty2_SetValueStore(This,ec,pRange,pPropStore)	\
    (This)->lpVtbl -> SetValueStore(This,ec,pRange,pPropStore)

#define ITfProperty2_SetValue(This,ec,pRange,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,ec,pRange,pvarValue)

#define ITfProperty2_Clear(This,ec,pRange)	\
    (This)->lpVtbl -> Clear(This,ec,pRange)


#define ITfProperty2_FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)	\
    (This)->lpVtbl -> FindNextValue(This,ec,pRangeQuery,tfAnchorQuery,dwFlags,pfContained,ppRangeNextValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfProperty2_FindNextValue_Proxy( 
    ITfProperty2 * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [in] */ DWORD dwFlags,
    /* [out] */ BOOL *pfContained,
    /* [out] */ ITfRange **ppRangeNextValue);


void __RPC_STUB ITfProperty2_FindNextValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfProperty2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0229 */
/* [local] */ 

#define	TF_DA_PRIORITY_HIGHEST	( 0 )

#define	TF_DA_PRIORITY_DEFAULT_SPELLING	( 8 )

#define	TF_DA_PRIORITY_DEFAULT_GRAMMAR	( 16 )

#define	TF_DA_PRIORITY_DEFAULT	( 24 )

#define	TF_DA_PRIORITY_LOWEST	( 31 )

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0229_0001
    {
    ULONG uPriority;
    GUID guidProperty;
    } 	TF_DA_PROPERTY;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0229_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0229_v0_0_s_ifspec;

#ifndef __IEnumTfCollection_INTERFACE_DEFINED__
#define __IEnumTfCollection_INTERFACE_DEFINED__

/* interface IEnumTfCollection */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c760b20-ed66-4dbd-9ff1-68fc21c02922")
    IEnumTfCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfCollection **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfCollection * This,
            /* [out] */ IEnumTfCollection **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfCollection * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfCollectionVtbl;

    interface IEnumTfCollection
    {
        CONST_VTBL struct IEnumTfCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfCollection_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfCollection_Next(This,ulCount,rgCollection,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgCollection,pcFetched)

#define IEnumTfCollection_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfCollection_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfCollection_Clone_Proxy( 
    IEnumTfCollection * This,
    /* [out] */ IEnumTfCollection **ppClone);


void __RPC_STUB IEnumTfCollection_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Next_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *rgCollection,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfCollection_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Reset_Proxy( 
    IEnumTfCollection * This);


void __RPC_STUB IEnumTfCollection_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCollection_Skip_Proxy( 
    IEnumTfCollection * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfCollection_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfCollection_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionMgr */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4e3d2d48-3c17-457d-84a1-f209476de897")
    ITfDisplayAttributeCollectionMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCollections( 
            /* [out] */ IEnumTfCollection **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCollections )( 
            ITfDisplayAttributeCollectionMgr * This,
            /* [out] */ IEnumTfCollection **ppEnum);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionMgrVtbl;

    interface ITfDisplayAttributeCollectionMgr
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeCollectionMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionMgr_EnumCollections(This,ppEnum)	\
    (This)->lpVtbl -> EnumCollections(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionMgr_EnumCollections_Proxy( 
    ITfDisplayAttributeCollectionMgr * This,
    /* [out] */ IEnumTfCollection **ppEnum);


void __RPC_STUB ITfDisplayAttributeCollectionMgr_EnumCollections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionMgr_INTERFACE_DEFINED__ */


#ifndef __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__
#define __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__

/* interface ITfDisplayAttributeCollectionProvider */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfDisplayAttributeCollectionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3977526d-1a0a-435a-8d06-ecc9516b484f")
    ITfDisplayAttributeCollectionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCollectionCount( 
            /* [out] */ ULONG *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCollection( 
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfDisplayAttributeCollectionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfDisplayAttributeCollectionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollectionCount )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [out] */ ULONG *puCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetCollection )( 
            ITfDisplayAttributeCollectionProvider * This,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
            /* [out] */ ULONG *pcGUIDsOut);
        
        END_INTERFACE
    } ITfDisplayAttributeCollectionProviderVtbl;

    interface ITfDisplayAttributeCollectionProvider
    {
        CONST_VTBL struct ITfDisplayAttributeCollectionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfDisplayAttributeCollectionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfDisplayAttributeCollectionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfDisplayAttributeCollectionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfDisplayAttributeCollectionProvider_GetCollectionCount(This,puCount)	\
    (This)->lpVtbl -> GetCollectionCount(This,puCount)

#define ITfDisplayAttributeCollectionProvider_GetCollection(This,uCount,prgProperty,pcGUIDsOut)	\
    (This)->lpVtbl -> GetCollection(This,uCount,prgProperty,pcGUIDsOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollectionCount_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [out] */ ULONG *puCount);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollectionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfDisplayAttributeCollectionProvider_GetCollection_Proxy( 
    ITfDisplayAttributeCollectionProvider * This,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ TF_DA_PROPERTY *prgProperty,
    /* [out] */ ULONG *pcGUIDsOut);


void __RPC_STUB ITfDisplayAttributeCollectionProvider_GetCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfDisplayAttributeCollectionProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0232 */
/* [local] */ 

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_msctfp_0232_0001
    {
    ITfRange *pRange;
    TF_DISPLAYATTRIBUTE tfDisplayAttr;
    } 	TF_RENDERINGMARKUP;



extern RPC_IF_HANDLE __MIDL_itf_msctfp_0232_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0232_v0_0_s_ifspec;

#ifndef __IEnumTfRenderingMarkup_INTERFACE_DEFINED__
#define __IEnumTfRenderingMarkup_INTERFACE_DEFINED__

/* interface IEnumTfRenderingMarkup */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c03d21b-95a7-4ba0-ae1b-7fce12a72930")
    IEnumTfRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfRenderingMarkup **ppClone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfRenderingMarkup * This,
            /* [out] */ IEnumTfRenderingMarkup **ppClone);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfRenderingMarkup * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfRenderingMarkupVtbl;

    interface IEnumTfRenderingMarkup
    {
        CONST_VTBL struct IEnumTfRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfRenderingMarkup_Clone(This,ppClone)	\
    (This)->lpVtbl -> Clone(This,ppClone)

#define IEnumTfRenderingMarkup_Next(This,ulCount,rgMarkup,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgMarkup,pcFetched)

#define IEnumTfRenderingMarkup_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfRenderingMarkup_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Clone_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [out] */ IEnumTfRenderingMarkup **ppClone);


void __RPC_STUB IEnumTfRenderingMarkup_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Next_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_RENDERINGMARKUP *rgMarkup,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfRenderingMarkup_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Reset_Proxy( 
    IEnumTfRenderingMarkup * This);


void __RPC_STUB IEnumTfRenderingMarkup_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfRenderingMarkup_Skip_Proxy( 
    IEnumTfRenderingMarkup * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfRenderingMarkup_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfContextRenderingMarkup_INTERFACE_DEFINED__
#define __ITfContextRenderingMarkup_INTERFACE_DEFINED__

/* interface ITfContextRenderingMarkup */
/* [unique][uuid][object] */ 

#define	TF_GRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_INCLUDE_PROPERTY	( 0x1 )

#define	TF_FRM_BACKWARD	( 0x2 )

#define	TF_FRM_NO_CONTAINED	( 0x4 )

#define	TF_FRM_NO_RANGE	( 0x8 )


EXTERN_C const IID IID_ITfContextRenderingMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a305b1c0-c776-4523-bda0-7c5a2e0fef10")
    ITfContextRenderingMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextRenderingMarkup( 
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfContextRenderingMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfContextRenderingMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfContextRenderingMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeCover,
            /* [out] */ IEnumTfRenderingMarkup **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FindNextRenderingMarkup )( 
            ITfContextRenderingMarkup * This,
            /* [in] */ TfEditCookie ec,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ITfRange *pRangeQuery,
            /* [in] */ TfAnchor tfAnchorQuery,
            /* [out] */ ITfRange **ppRangeFound,
            /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);
        
        END_INTERFACE
    } ITfContextRenderingMarkupVtbl;

    interface ITfContextRenderingMarkup
    {
        CONST_VTBL struct ITfContextRenderingMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfContextRenderingMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfContextRenderingMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfContextRenderingMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfContextRenderingMarkup_GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)	\
    (This)->lpVtbl -> GetRenderingMarkup(This,ec,dwFlags,pRangeCover,ppEnum)

#define ITfContextRenderingMarkup_FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)	\
    (This)->lpVtbl -> FindNextRenderingMarkup(This,ec,dwFlags,pRangeQuery,tfAnchorQuery,ppRangeFound,ptfRenderingMarkup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_GetRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeCover,
    /* [out] */ IEnumTfRenderingMarkup **ppEnum);


void __RPC_STUB ITfContextRenderingMarkup_GetRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfContextRenderingMarkup_FindNextRenderingMarkup_Proxy( 
    ITfContextRenderingMarkup * This,
    /* [in] */ TfEditCookie ec,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ITfRange *pRangeQuery,
    /* [in] */ TfAnchor tfAnchorQuery,
    /* [out] */ ITfRange **ppRangeFound,
    /* [out] */ TF_RENDERINGMARKUP *ptfRenderingMarkup);


void __RPC_STUB ITfContextRenderingMarkup_FindNextRenderingMarkup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfContextRenderingMarkup_INTERFACE_DEFINED__ */


#ifndef __ITfBackgroundThreadMgr_INTERFACE_DEFINED__
#define __ITfBackgroundThreadMgr_INTERFACE_DEFINED__

/* interface ITfBackgroundThreadMgr */
/* [unique][uuid][local][object] */ 

typedef BOOL ( *TfBackgroundThreadCallback )( 
    /* [in] */ BOOL fCleanup,
    /* [in] */ void *pvPrivate);

typedef BOOL ( *TfWakeAppBackgroundThreadProc )( void);


EXTERN_C const IID IID_ITfBackgroundThreadMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("38462b47-6127-4464-bd2f-46957c31ad0e")
    ITfBackgroundThreadMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AppInitBackgroundThread( 
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppUninitBackgroundThread( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseBackgroundCallback( 
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseBackgroundCallback( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WakeBackgroundThread( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfBackgroundThreadMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfBackgroundThreadMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppInitBackgroundThread )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
            /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
            /* [out] */ void **ppvPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *AppUninitBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ TfBackgroundThreadCallback pfnCallback,
            /* [in] */ void *pvPrivate,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseBackgroundCallback )( 
            ITfBackgroundThreadMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *WakeBackgroundThread )( 
            ITfBackgroundThreadMgr * This);
        
        END_INTERFACE
    } ITfBackgroundThreadMgrVtbl;

    interface ITfBackgroundThreadMgr
    {
        CONST_VTBL struct ITfBackgroundThreadMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfBackgroundThreadMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfBackgroundThreadMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfBackgroundThreadMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfBackgroundThreadMgr_AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)	\
    (This)->lpVtbl -> AppInitBackgroundThread(This,pfnWakeThread,ppfnCallback,ppvPrivate)

#define ITfBackgroundThreadMgr_AppUninitBackgroundThread(This)	\
    (This)->lpVtbl -> AppUninitBackgroundThread(This)

#define ITfBackgroundThreadMgr_AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)	\
    (This)->lpVtbl -> AdviseBackgroundCallback(This,pfnCallback,pvPrivate,pdwCookie)

#define ITfBackgroundThreadMgr_UnadviseBackgroundCallback(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseBackgroundCallback(This,dwCookie)

#define ITfBackgroundThreadMgr_WakeBackgroundThread(This)	\
    (This)->lpVtbl -> WakeBackgroundThread(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppInitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfWakeAppBackgroundThreadProc pfnWakeThread,
    /* [out] */ TfBackgroundThreadCallback *ppfnCallback,
    /* [out] */ void **ppvPrivate);


void __RPC_STUB ITfBackgroundThreadMgr_AppInitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AppUninitBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_AppUninitBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_AdviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ TfBackgroundThreadCallback pfnCallback,
    /* [in] */ void *pvPrivate,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_AdviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Proxy( 
    ITfBackgroundThreadMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfBackgroundThreadMgr_UnadviseBackgroundCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfBackgroundThreadMgr_WakeBackgroundThread_Proxy( 
    ITfBackgroundThreadMgr * This);


void __RPC_STUB ITfBackgroundThreadMgr_WakeBackgroundThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfBackgroundThreadMgr_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msctfp_0235 */
/* [local] */ 

#endif // MSCTFP_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_msctfp_0235_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msctfp_0235_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\ntgdi.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdi.h
*
* Structures defining kernel-mode entry points for GDI.
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

// Trace creation of all GDI SURFACE objects
#define TRACE_SURFACE_ALLOCS    (DBG || 1)


// PRIVATE

W32KAPI BOOL     APIENTRY NtGdiInit();
W32KAPI int      APIENTRY NtGdiSetDIBitsToDeviceInternal(IN HDC hdcDest,IN int xDst,IN int yDst,IN DWORD cx,IN DWORD cy,
                                                         IN int xSrc,IN int ySrc,IN DWORD iStartScan,IN DWORD cNumScan,
                                                         IN LPBYTE pInitBits,IN LPBITMAPINFO pbmi,IN DWORD iUsage,
                                                         IN UINT cjMaxBits,IN UINT cjMaxInfo,IN BOOL bTransformCoordinates,
                                                         IN HANDLE hcmXform);
W32KAPI BOOL     APIENTRY NtGdiGetFontResourceInfoInternalW(IN LPWSTR pwszFiles,IN ULONG cwc,IN ULONG cFiles,IN UINT cjIn,
                                                            OUT LPDWORD pdwBytes,OUT LPVOID pvBuf,IN DWORD iType);
W32KAPI DWORD    APIENTRY NtGdiGetGlyphIndicesW(IN HDC hdc,IN LPWSTR pwc,IN int cwc,OUT LPWORD pgi,IN DWORD iMode);
W32KAPI DWORD    APIENTRY NtGdiGetGlyphIndicesWInternal(IN HDC hdc,IN LPWSTR pwc,IN int cwc,OUT LPWORD pgi,IN DWORD iMode, BOOL bSubset);
W32KAPI HPALETTE APIENTRY NtGdiCreatePaletteInternal(IN LPLOGPALETTE pLogPal,IN UINT cEntries);
W32KAPI BOOL     APIENTRY NtGdiArcInternal(IN ARCTYPE arctype,IN HDC hdc,IN int x1,IN int y1,IN int x2,IN int y2,IN int x3,
                                           IN int y3,IN int x4,IN int y4);
W32KAPI int      APIENTRY NtGdiStretchDIBitsInternal(IN HDC hdc,IN int xDst,IN int yDst,IN int cxDst,IN int cyDst,IN int xSrc,
                                                     IN int ySrc,IN int cxSrc,IN int cySrc,IN LPBYTE pjInit,IN LPBITMAPINFO pbmi,
                                                     IN DWORD dwUsage,IN DWORD dwRop4,IN UINT cjMaxInfo,IN UINT cjMaxBits,IN HANDLE hcmXform);
W32KAPI ULONG    APIENTRY NtGdiGetOutlineTextMetricsInternalW(IN HDC hdc,IN ULONG cjotm,OUT OUTLINETEXTMETRICW *potmw,
                                                              OUT TMDIFF *ptmd);
W32KAPI BOOL     APIENTRY NtGdiGetAndSetDCDword(IN HDC hdc,IN UINT u,IN DWORD dwIn,OUT DWORD *pdwResult);
W32KAPI HANDLE   APIENTRY NtGdiGetDCObject(IN HDC hdc,IN int itype);
W32KAPI HDC      APIENTRY NtGdiGetDCforBitmap(IN HBITMAP hsurf);

W32KAPI BOOL     APIENTRY NtGdiGetMonitorID(IN HDC hdc, IN DWORD dwSize, OUT LPWSTR pszMonitorID);

// flags returned from GetUFI and passed to GetUFIBits
#define FL_UFI_PRIVATEFONT      1
#define FL_UFI_DESIGNVECTOR_PFF 2
#define FL_UFI_MEMORYFONT       4

W32KAPI INT      APIENTRY NtGdiGetLinkedUFIs(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufiLinkedUFIs,IN INT BufferSize);
W32KAPI BOOL     APIENTRY NtGdiSetLinkedUFIs(IN HDC hdc,IN PUNIVERSAL_FONT_ID pufiLinks,IN ULONG uNumUFIs);
W32KAPI BOOL     APIENTRY NtGdiGetUFI(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufi,OUT DESIGNVECTOR *pdv,OUT ULONG *pcjDV,
                                      OUT ULONG *pulBaseCheckSum,OUT FLONG  *pfl);
W32KAPI BOOL     APIENTRY NtGdiForceUFIMapping(IN HDC hdc,IN PUNIVERSAL_FONT_ID pufi);
        BOOL     APIENTRY NtGdiGetUFIBits(IN PUNIVERSAL_FONT_ID pufi, IN ULONG cjMaxBytes, OUT PVOID pjBits,
                                          OUT PULONG pulFileSize,IN FLONG  fl);
W32KAPI BOOL     APIENTRY NtGdiGetUFIPathname(IN PUNIVERSAL_FONT_ID pufi,OUT ULONG* pcwc,OUT LPWSTR pwszPathname,
                                              OUT ULONG* pcNumFiles, IN FLONG fl, OUT BOOL *pbMemFont, OUT ULONG *pcjView,
                                              OUT PVOID pvView, OUT BOOL  *pbTTC, OUT ULONG *piTTC);
W32KAPI BOOL     APIENTRY NtGdiAddRemoteFontToDC(IN HDC hdc,IN PVOID pvBuffer, IN ULONG cjBuffer,IN PUNIVERSAL_FONT_ID pufi);
W32KAPI HANDLE   APIENTRY NtGdiAddFontMemResourceEx(IN PVOID pvBuffer,IN DWORD cjBuffer,IN DESIGNVECTOR *pdv,IN ULONG cjDV,
                                                    OUT DWORD *pNumFonts);
W32KAPI BOOL     APIENTRY NtGdiRemoveFontMemResourceEx(IN HANDLE hMMFont);
W32KAPI BOOL     APIENTRY NtGdiUnmapMemFont(IN PVOID pvView);
W32KAPI BOOL     APIENTRY NtGdiRemoveMergeFont(IN HDC hdc,IN UNIVERSAL_FONT_ID *pufi);
W32KAPI BOOL     APIENTRY NtGdiAnyLinkedFonts();

// local printing with embedded fonts

W32KAPI BOOL     APIENTRY NtGdiGetEmbUFI(IN HDC hdc,OUT PUNIVERSAL_FONT_ID pufi,OUT DESIGNVECTOR *pdv,OUT ULONG *pcjDV,
                                      OUT ULONG *pulBaseCheckSum,OUT FLONG  *pfl, OUT KERNEL_PVOID *embFontID);
W32KAPI ULONG   APIENTRY  NtGdiGetEmbedFonts();
W32KAPI BOOL    APIENTRY  NtGdiChangeGhostFont(IN KERNEL_PVOID *pfontID, IN BOOL bLoad);
W32KAPI BOOL    APIENTRY  NtGdiAddEmbFontToDC(IN HDC hdc, IN VOID **pFontID);

W32KAPI BOOL     APIENTRY NtGdiFontIsLinked(IN HDC hdc);
W32KAPI ULONG_PTR APIENTRY NtGdiPolyPolyDraw(IN HDC hdc,IN PPOINT ppt,IN PULONG pcpt,IN ULONG ccpt,IN int iFunc);
W32KAPI LONG     APIENTRY NtGdiDoPalette(IN HPALETTE hpal,IN WORD iStart,IN WORD cEntries,IN PALETTEENTRY *pPalEntries,
                                         IN DWORD iFunc,IN BOOL bInbound);
W32KAPI BOOL     APIENTRY NtGdiComputeXformCoefficients(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiGetWidthTable(IN HDC hdc,IN ULONG cSpecial,IN WCHAR *pwc,IN ULONG cwc,OUT USHORT *psWidth,
                                             OUT WIDTHDATA *pwd, OUT FLONG *pflInfo);
W32KAPI int      APIENTRY NtGdiDescribePixelFormat(IN HDC hdc,IN int ipfd,IN UINT cjpfd,OUT PPIXELFORMATDESCRIPTOR ppfd);
W32KAPI BOOL     APIENTRY NtGdiSetPixelFormat(IN HDC hdc,IN int ipfd);
W32KAPI BOOL     APIENTRY NtGdiSwapBuffers(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiSetupPublicCFONT(IN HDC hdc,IN HFONT hf,IN ULONG ulAve);


W32KAPI DWORD  APIENTRY NtGdiDxgGenericThunk(IN ULONG_PTR ulIndex,
                                             IN ULONG_PTR ulHandle,
                                             IN OUT SIZE_T *pdwSizeOfPtr1,
                                             IN OUT PVOID pvPtr1,
                                             IN OUT SIZE_T *pdwSizeOfPtr2,
                                             IN OUT PVOID pvPtr2);
W32KAPI DWORD    APIENTRY NtGdiDdAddAttachedSurface(IN HANDLE hSurface,IN HANDLE hSurfaceAttached,
                                                    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData);
W32KAPI BOOL     APIENTRY NtGdiDdAttachSurface(IN HANDLE  hSurfaceFrom, IN HANDLE  hSurfaceTo);
W32KAPI DWORD    APIENTRY NtGdiDdBlt(IN HANDLE hSurfaceDest,IN HANDLE hSurfaceSrc,IN OUT PDD_BLTDATA puBltData);
W32KAPI DWORD    APIENTRY NtGdiDdCanCreateSurface(IN HANDLE hDirectDraw,IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdColorControl(IN HANDLE hSurface,IN OUT PDD_COLORCONTROLDATA puColorControlData);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateDirectDrawObject(IN HDC hdc);
W32KAPI DWORD    APIENTRY NtGdiDdCreateSurface(IN HANDLE hDirectDraw,IN HANDLE* hSurface,
                                               IN OUT DDSURFACEDESC* puSurfaceDescription,
                                               IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
                                               IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
                                               IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
                                               IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
                                               OUT HANDLE* puhSurface);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateSurfaceObject(IN HANDLE hDirectDrawLocal,IN HANDLE hSurface,IN PDD_SURFACE_LOCAL puSurfaceLocal,
                                                     IN PDD_SURFACE_MORE puSurfaceMore, IN PDD_SURFACE_GLOBAL puSurfaceGlobal,IN BOOL bComplete);
W32KAPI BOOL     APIENTRY NtGdiDdDeleteSurfaceObject(IN HANDLE hSurface);
W32KAPI BOOL     APIENTRY NtGdiDdDeleteDirectDrawObject(HANDLE hDirectDrawLocal);
W32KAPI DWORD    APIENTRY NtGdiDdDestroySurface(IN HANDLE hSurface, IN BOOL bRealDestroy);
        HANDLE   APIENTRY NtGdiDdDuplicateSurface(IN HANDLE hSurface);
W32KAPI DWORD    APIENTRY NtGdiDdFlip(IN HANDLE hSurfaceCurrent,IN HANDLE hSurfaceTarget,IN HANDLE hSurfaceCurrentLeft,IN HANDLE hSurfaceTargetLeft,IN OUT PDD_FLIPDATA puFlipData);
W32KAPI DWORD    APIENTRY NtGdiDdGetAvailDriverMemory(IN HANDLE hDirectDraw, IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData);
W32KAPI DWORD    APIENTRY NtGdiDdGetBltStatus(IN HANDLE hSurface,IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData);
W32KAPI HDC      APIENTRY NtGdiDdGetDC(IN HANDLE hSurface,IN PALETTEENTRY* puColorTable);
W32KAPI DWORD    APIENTRY NtGdiDdGetDriverInfo(IN HANDLE hDirectDraw, IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData);
W32KAPI DWORD    APIENTRY NtGdiDdGetFlipStatus(IN HANDLE hSurface,IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData);
W32KAPI DWORD    APIENTRY NtGdiDdGetScanLine(IN HANDLE hDirectDraw, IN OUT PDD_GETSCANLINEDATA puGetScanLineData);
W32KAPI DWORD    APIENTRY NtGdiDdSetExclusiveMode(IN HANDLE hDirectDraw,IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData);
W32KAPI DWORD    APIENTRY NtGdiDdFlipToGDISurface(IN HANDLE hDirectDraw,IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdLock(IN HANDLE hSurface,IN OUT PDD_LOCKDATA puLockData,IN HDC hdcClip);
W32KAPI BOOL     APIENTRY NtGdiDdQueryDirectDrawObject(IN HANDLE,OUT PDD_HALINFO,DWORD*,OUT LPD3DNTHAL_CALLBACKS,OUT LPD3DNTHAL_GLOBALDRIVERDATA,OUT PDD_D3DBUFCALLBACKS,OUT LPDDSURFACEDESC,OUT DWORD*,OUT VIDEOMEMORY*,OUT DWORD*,OUT DWORD*);
W32KAPI BOOL     APIENTRY NtGdiDdReenableDirectDrawObject(IN HANDLE hDirectDrawLocal,IN OUT BOOL* pubNewMode);
W32KAPI BOOL     APIENTRY NtGdiDdReleaseDC(IN HANDLE hSurface);
W32KAPI BOOL     APIENTRY NtGdiDdResetVisrgn(IN HANDLE hSurface,IN HWND hwnd);
W32KAPI DWORD    APIENTRY NtGdiDdSetColorKey(IN HANDLE hSurface,IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData);
W32KAPI DWORD    APIENTRY NtGdiDdSetOverlayPosition(IN HANDLE hSurfaceSource,IN HANDLE hSurfaceDestination,
                                                    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData);
W32KAPI VOID     APIENTRY NtGdiDdUnattachSurface(IN HANDLE hSurface,IN HANDLE hSurfaceAttached);
W32KAPI DWORD    APIENTRY NtGdiDdUnlock(IN HANDLE hSurface,IN OUT PDD_UNLOCKDATA puUnlockData);
W32KAPI DWORD    APIENTRY NtGdiDdUpdateOverlay(IN HANDLE hSurfaceDestination, IN HANDLE hSurfaceSource,
                                               IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData);
W32KAPI DWORD    APIENTRY NtGdiDdWaitForVerticalBlank(IN HANDLE hDirectDraw,IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData);
W32KAPI HANDLE   APIENTRY NtGdiDdGetDxHandle(IN HANDLE hDirectDraw,IN HANDLE hSurface,IN BOOL bRelease);
W32KAPI BOOL     APIENTRY NtGdiDdSetGammaRamp(IN HANDLE hDirectDraw,IN HDC hdc,IN LPVOID lpGammaRamp);


W32KAPI DWORD    APIENTRY NtGdiDdLockD3D(IN HANDLE hSurface,IN OUT PDD_LOCKDATA puLockData);
W32KAPI DWORD    APIENTRY NtGdiDdUnlockD3D(IN HANDLE hSurface, IN OUT PDD_UNLOCKDATA puUnlockData);
W32KAPI DWORD    APIENTRY NtGdiDdCreateD3DBuffer(HANDLE hDirectDraw, HANDLE* hSurface, IN OUT DDSURFACEDESC* puSurfaceDescription,
                                                 IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData, IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
                                                 IN OUT DD_SURFACE_MORE* puSurfaceMoreData, IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
                                                 IN OUT HANDLE* puhSurface);
W32KAPI DWORD    APIENTRY NtGdiDdCanCreateD3DBuffer(IN HANDLE hDirectDraw,IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);
W32KAPI DWORD    APIENTRY NtGdiDdDestroyD3DBuffer(IN HANDLE hSurface);
W32KAPI DWORD    APIENTRY NtGdiD3dContextCreate(IN HANDLE hDirectDrawLocal,IN HANDLE hSurfColor,IN HANDLE hSurfZ,
                                                IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci);

W32KAPI DWORD    APIENTRY NtGdiD3dContextDestroy(LPD3DNTHAL_CONTEXTDESTROYDATA);

W32KAPI DWORD    APIENTRY NtGdiD3dContextDestroyAll(OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad);

W32KAPI DWORD    APIENTRY NtGdiD3dValidateTextureStageState(IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData);
W32KAPI DWORD    APIENTRY NtGdiD3dDrawPrimitives2(IN HANDLE hCmdBuf, IN HANDLE hVBuf, IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
                                                  IN OUT FLATPTR* pfpVidMemCmd, IN OUT DWORD* pdwSizeCmd, IN OUT FLATPTR* pfpVidMemVtx,
                                                  IN OUT DWORD* pdwSizeVtx);
W32KAPI DWORD    APIENTRY NtGdiDdGetDriverState(IN OUT PDD_GETDRIVERSTATEDATA pdata);
W32KAPI DWORD    APIENTRY NtGdiDdCreateSurfaceEx(IN HANDLE hDirectDraw, IN HANDLE hSurface,IN DWORD dwSurfaceHandle);
W32KAPI DWORD    APIENTRY NtGdiDvpCanCreateVideoPort(IN HANDLE hDirectDraw, IN OUT PDD_CANCREATEVPORTDATA puCanCreateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpColorControl(IN HANDLE hVideoPort,IN OUT PDD_VPORTCOLORDATA puVPortColorData);
W32KAPI HANDLE   APIENTRY NtGdiDvpCreateVideoPort(IN HANDLE hDirectDraw,IN OUT PDD_CREATEVPORTDATA puCreateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpDestroyVideoPort(IN HANDLE hVideoPort,IN OUT PDD_DESTROYVPORTDATA puDestroyVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpFlipVideoPort(IN HANDLE hVideoPort,IN HANDLE hDDSurfaceCurrent,IN HANDLE hDDSurfaceTarget,
                                                IN OUT PDD_FLIPVPORTDATA puFlipVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortBandwidth(IN HANDLE hVideoPort, IN OUT PDD_GETVPORTBANDWIDTHDATA puGetVPortBandwidthData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortField(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTFIELDDATA puGetVPortFieldData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortFlipStatus(IN HANDLE hDirectDraw,IN OUT PDD_GETVPORTFLIPSTATUSDATA puGetVPortFlipStatusData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortInputFormats(IN HANDLE hVideoPort, IN OUT PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortLine(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTLINEDATA puGetVPortLineData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortOutputFormats(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTOUTPUTFORMATDATA puGetVPortOutputFormatData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoPortConnectInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETVPORTCONNECTDATA puGetVPortConnectData);
W32KAPI DWORD    APIENTRY NtGdiDvpGetVideoSignalStatus(IN HANDLE hVideoPort,IN OUT PDD_GETVPORTSIGNALDATA puGetVPortSignalData);
W32KAPI DWORD    APIENTRY NtGdiDvpUpdateVideoPort(IN HANDLE hVideoPort, IN HANDLE* phSurfaceVideo,IN HANDLE* phSurfaceVbi,IN OUT PDD_UPDATEVPORTDATA puUpdateVPortData);
W32KAPI DWORD    APIENTRY NtGdiDvpWaitForVideoPortSync(IN HANDLE hVideoPort,IN OUT PDD_WAITFORVPORTSYNCDATA puWaitForVPortSyncData);
W32KAPI DWORD    APIENTRY NtGdiDvpAcquireNotification(IN HANDLE hVideoPort,IN OUT HANDLE* hEvent,IN LPDDVIDEOPORTNOTIFY pNotify);
W32KAPI DWORD    APIENTRY NtGdiDvpReleaseNotification(IN HANDLE hVideoPort,IN HANDLE hEvent);

W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompGuids(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData);
W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompFormats(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData);
W32KAPI DWORD    APIENTRY NtGdiDdGetMoCompBuffInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData);
W32KAPI DWORD    APIENTRY NtGdiDdGetInternalMoCompInfo(IN HANDLE hDirectDraw,IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData);
W32KAPI HANDLE   APIENTRY NtGdiDdCreateMoComp(IN HANDLE hDirectDraw,IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdDestroyMoComp(IN HANDLE hMoComp,IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdBeginMoCompFrame(IN HANDLE hMoComp, IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData);
W32KAPI DWORD    APIENTRY NtGdiDdEndMoCompFrame(IN HANDLE hMoComp,IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData);
W32KAPI DWORD    APIENTRY NtGdiDdRenderMoComp(IN HANDLE hMoComp,IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData);
W32KAPI DWORD    APIENTRY NtGdiDdQueryMoCompStatus(IN OUT HANDLE hMoComp,IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData);

W32KAPI DWORD    APIENTRY NtGdiDdAlphaBlt(IN HANDLE hSurfaceDest, IN HANDLE hSurfaceSrc,IN OUT PDD_BLTDATA puBltData);

// Image32

W32KAPI BOOL     APIENTRY NtGdiAlphaBlend(IN HDC hdcDst, IN LONG DstX,IN LONG DstY,IN LONG DstCx,IN LONG DstCy,IN HDC hdcSrc,
                                          IN LONG SrcX,IN LONG SrcY, IN LONG SrcCx, IN LONG SrcCy, IN BLENDFUNCTION BlendFunction,
                                          IN HANDLE hcmXform);
W32KAPI BOOL     APIENTRY NtGdiGradientFill(IN HDC hdc,IN PTRIVERTEX pVertex,IN ULONG uVertex,IN PVOID pMesh,IN ULONG uMesh,IN ULONG ulMode);

// icm (Image Color Matching)
W32KAPI BOOL     APIENTRY NtGdiSetIcmMode(IN HDC hdc,IN ULONG nCommand,IN ULONG ulMode);

#define ICM_SET_MODE             1
#define ICM_SET_CALIBRATE_MODE   2
#define ICM_SET_COLOR_MODE       3
#define ICM_CHECK_COLOR_MODE     4

typedef struct _LOGCOLORSPACEEXW
{
    LOGCOLORSPACEW lcsColorSpace;
    DWORD          dwFlags;
} LOGCOLORSPACEEXW, *PLOGCOLORSPACEEXW;

#define LCSEX_ANSICREATED    0x0001 // Created by CreateColorSpaceA()
#define LCSEX_TEMPPROFILE    0x0002 // Color profile is temporary file

W32KAPI HANDLE   APIENTRY NtGdiCreateColorSpace(IN PLOGCOLORSPACEEXW pLogColorSpace);
W32KAPI BOOL     APIENTRY NtGdiDeleteColorSpace(IN HANDLE hColorSpace);
W32KAPI BOOL     APIENTRY NtGdiSetColorSpace(IN HDC hdc,IN HCOLORSPACE hColorSpace);

W32KAPI HANDLE   APIENTRY NtGdiCreateColorTransform(IN HDC hdc,IN LPLOGCOLORSPACEW pLogColorSpaceW,IN PVOID pvSrcProfile,
                                                    IN ULONG cjSrcProfile,IN PVOID pvDestProfile, IN ULONG cjDestProfile,
                                                    IN PVOID pvTargetProfile, IN ULONG cjTargetProfile);
W32KAPI BOOL     APIENTRY NtGdiDeleteColorTransform(IN HDC hdc, IN HANDLE hColorTransform);
W32KAPI BOOL     APIENTRY NtGdiCheckBitmapBits(IN HDC hdc,IN HANDLE hColorTransform,IN PVOID pvBits, IN ULONG bmFormat,
                                               IN DWORD dwWidth, IN DWORD dwHeight,IN DWORD dwStride,OUT PBYTE paResults);

W32KAPI ULONG    APIENTRY NtGdiColorCorrectPalette(IN HDC hdc,IN HPALETTE hpal,IN ULONG FirstEntry,IN ULONG NumberOfEntries,
                                                   IN OUT PALETTEENTRY *ppalEntry,IN ULONG);

W32KAPI ULONG_PTR APIENTRY NtGdiGetColorSpaceforBitmap(IN HBITMAP hsurf);

typedef enum _COLORPALETTEINFO
{
    ColorPaletteQuery,
    ColorPaletteSet
} COLORPALETTEINFO, *PCOLORPALETTEINFO;

W32KAPI BOOL     APIENTRY NtGdiGetDeviceGammaRamp(IN HDC hdc, OUT LPVOID lpGammaRamp);
W32KAPI BOOL     APIENTRY NtGdiSetDeviceGammaRamp(IN HDC hdc, IN LPVOID  lpGammaRamp);

W32KAPI BOOL     APIENTRY NtGdiIcmBrushInfo(IN HDC hdc,IN HBRUSH hbrush,IN OUT PBITMAPINFO pbmiDIB, IN OUT PVOID pvBits,
                                            IN OUT ULONG *pulBits, OUT DWORD *piUsage, OUT BOOL *pbAlreadyTran, IN ULONG Command);

typedef enum _ICM_DIB_INFO_CMD
{
    IcmQueryBrush,
    IcmSetBrush
} ICM_DIB_INFO, *PICM_DIB_INFO;

// PUBLIC

W32KAPI VOID     APIENTRY NtGdiFlush();
W32KAPI HDC      APIENTRY NtGdiCreateMetafileDC(IN HDC hdc);

W32KAPI BOOL     APIENTRY NtGdiMakeInfoDC(IN HDC hdc, IN BOOL bSet);
W32KAPI HANDLE   APIENTRY NtGdiCreateClientObj(IN ULONG ulType);
W32KAPI BOOL     APIENTRY NtGdiDeleteClientObj(IN HANDLE h);

W32KAPI LONG     APIENTRY NtGdiGetBitmapBits(IN HBITMAP hbm, IN ULONG cjMax, OUT PBYTE pjOut);

W32KAPI BOOL     APIENTRY NtGdiDeleteObjectApp(IN HANDLE hobj);
W32KAPI int      APIENTRY NtGdiGetPath(IN HDC hdc, OUT LPPOINT pptlBuf, OUT LPBYTE pjTypes,IN int cptBuf);

W32KAPI HDC      APIENTRY NtGdiCreateCompatibleDC(IN HDC hdc);
W32KAPI HBITMAP  APIENTRY NtGdiCreateDIBitmapInternal(IN HDC hdc,IN INT cx,IN INT cy, IN DWORD fInit, IN LPBYTE pjInit,
                                                      IN LPBITMAPINFO pbmi, IN DWORD iUsage,IN UINT cjMaxInitInfo,
                                                      IN UINT cjMaxBits, IN FLONG f, IN HANDLE hcmXform);
W32KAPI HBITMAP  APIENTRY NtGdiCreateDIBSection(IN HDC hdc,IN HANDLE hSectionApp,IN DWORD dwOffset, IN LPBITMAPINFO pbmi,
                                                IN DWORD iUsage,IN UINT cjHeader,IN FLONG fl, IN ULONG_PTR dwColorSpace,
                                                OUT PVOID *ppvBits);

W32KAPI HBRUSH   APIENTRY NtGdiCreateSolidBrush(IN COLORREF cr, IN HBRUSH hbr);
W32KAPI HBRUSH   APIENTRY NtGdiCreateDIBBrush(IN PVOID pv, IN FLONG fl, IN UINT  cj, IN BOOL  b8X8, IN BOOL bPen,
                                              IN PVOID pClient);
W32KAPI HBRUSH   APIENTRY NtGdiCreatePatternBrushInternal(IN HBITMAP hbm,IN BOOL bPen,IN BOOL b8X8);
W32KAPI HBRUSH   APIENTRY NtGdiCreateHatchBrushInternal(IN ULONG ulStyle,IN COLORREF clrr,IN BOOL bPen);

W32KAPI HPEN     APIENTRY NtGdiExtCreatePen(IN ULONG flPenStyle, IN ULONG ulWidth, IN ULONG iBrushStyle,
                                            IN ULONG ulColor, IN ULONG_PTR  lClientHatch, IN ULONG_PTR   lHatch,
                                            IN ULONG cstyle, IN PULONG pulStyle, IN ULONG cjDIB, IN BOOL bOldStylePen,
                                            IN HBRUSH hbrush);
W32KAPI HRGN     APIENTRY NtGdiCreateEllipticRgn(IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI HRGN     APIENTRY NtGdiCreateRoundRectRgn(IN int xLeft, IN int yTop, IN int xRight, IN int yBottom,
                                                  IN int xWidth, IN int yHeight);
W32KAPI HANDLE   APIENTRY NtGdiCreateServerMetaFile(IN DWORD iType, IN ULONG cjData, IN LPBYTE pjData, IN DWORD mm,
                                                    IN DWORD xExt, IN DWORD yExt);
W32KAPI HRGN     APIENTRY NtGdiExtCreateRegion(IN LPXFORM px, IN DWORD cj, IN LPRGNDATA prgn);
W32KAPI ULONG    APIENTRY NtGdiMakeFontDir(IN FLONG flEmbed,OUT PBYTE pjFontDir,IN unsigned cjFontDir, IN LPWSTR pwszPathname, IN unsigned cjPathname);

W32KAPI BOOL     APIENTRY NtGdiPolyDraw(IN HDC hdc,IN LPPOINT ppt,IN LPBYTE pjAttr,IN ULONG cpt);
W32KAPI BOOL     APIENTRY NtGdiPolyTextOutW(IN HDC hdc,IN POLYTEXTW *pptw,IN UINT cStr,IN DWORD dwCodePage);

W32KAPI ULONG    APIENTRY NtGdiGetServerMetaFileBits(IN HANDLE hmo, IN ULONG cbData, OUT LPBYTE lpClientData,OUT PDWORD piType,
                                                     OUT PDWORD pmm, OUT PDWORD pxExt, OUT PDWORD pyExt);
W32KAPI BOOL     APIENTRY NtGdiEqualRgn(IN HRGN hrgn1,IN HRGN hrgn2);
W32KAPI BOOL     APIENTRY NtGdiGetBitmapDimension(IN HBITMAP hbm, OUT LPSIZE psize);
W32KAPI UINT     APIENTRY NtGdiGetNearestPaletteIndex(IN HPALETTE hpal,IN COLORREF crColor);
W32KAPI BOOL     APIENTRY NtGdiPtVisible(IN HDC hdc,IN int x,IN int y);
W32KAPI BOOL     APIENTRY NtGdiRectVisible(IN HDC hdc,IN LPRECT prc);
W32KAPI BOOL     APIENTRY NtGdiRemoveFontResourceW(IN WCHAR *pwszFiles, IN ULONG cwc,IN ULONG cFiles, IN ULONG fl,
                                                   IN DWORD dwPidTid,IN DESIGNVECTOR *pdv);
W32KAPI BOOL     APIENTRY NtGdiResizePalette(IN HPALETTE hpal,IN UINT cEntry);
W32KAPI BOOL     APIENTRY NtGdiSetBitmapDimension(IN HBITMAP hbm,IN int cx,IN int cy,OUT LPSIZE  psizeOut);
W32KAPI int      APIENTRY NtGdiOffsetClipRgn(IN HDC hdc,IN int x,IN int y);
W32KAPI int      APIENTRY NtGdiSetMetaRgn(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSetTextJustification(IN HDC hdc, IN int lBreakExtra,IN int cBreak);
W32KAPI int      APIENTRY NtGdiGetAppClipBox(IN HDC hdc,OUT LPRECT prc);
W32KAPI BOOL     APIENTRY NtGdiGetTextExtentExW(IN HDC hdc, IN LPWSTR lpwsz, IN ULONG cwc,IN ULONG dxMax,
                                                OUT ULONG *pcCh,OUT PULONG pdxOut,OUT LPSIZE psize,IN FLONG fl);
W32KAPI BOOL     APIENTRY NtGdiGetCharABCWidthsW(IN HDC hdc,IN UINT wchFirst,IN ULONG cwch,IN PWCHAR pwch,
                                                 IN FLONG fl,OUT PVOID pvBuf);
W32KAPI DWORD    APIENTRY NtGdiGetCharacterPlacementW(IN HDC hdc,IN LPWSTR pwsz,IN int nCount, IN int nMaxExtent,
                                                      IN OUT LPGCP_RESULTSW pgcpw, IN DWORD dwFlags);
W32KAPI BOOL     APIENTRY NtGdiAngleArc(IN HDC hdc,IN int x,IN int y, IN DWORD dwRadius,IN DWORD dwStartAngle, IN DWORD dwSweepAngle);
W32KAPI BOOL     APIENTRY NtGdiBeginPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSelectClipPath(IN HDC hdc, IN int iMode);
W32KAPI BOOL     APIENTRY NtGdiCloseFigure(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiEndPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiAbortPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiFillPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiStrokeAndFillPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiStrokePath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiWidenPath(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiFlattenPath(IN HDC hdc);
W32KAPI HRGN     APIENTRY NtGdiPathToRegion(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiSetMiterLimit(IN HDC hdc,IN DWORD dwNew,IN OUT PDWORD pdwOut);
W32KAPI BOOL     APIENTRY NtGdiSetFontXform(IN HDC hdc,IN DWORD dwxScale,IN DWORD dwyScale);
W32KAPI BOOL     APIENTRY NtGdiGetMiterLimit(IN HDC hdc,OUT PDWORD pdwOut);
W32KAPI BOOL     APIENTRY NtGdiEllipse(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiRectangle(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiRoundRect(IN HDC hdc, IN int x1,IN int y1,IN int x2,IN int y2,IN int x3,IN int y3);
W32KAPI BOOL     APIENTRY NtGdiPlgBlt(IN HDC hdcTrg,IN LPPOINT pptlTrg,IN HDC hdcSrc,IN int xSrc, IN int ySrc,
                                      IN int cxSrc, IN int cySrc,IN HBITMAP hbmMask,IN int xMask, IN int yMask, IN DWORD crBackColor);
W32KAPI BOOL     APIENTRY NtGdiMaskBlt(IN HDC hdc,IN int xDst,IN int yDst,IN int cx,IN int cy,IN HDC hdcSrc,IN int xSrc,
                                       IN int ySrc, IN HBITMAP hbmMask, IN int xMask,IN int yMask,IN DWORD dwRop4,IN DWORD crBackColor);
W32KAPI BOOL     APIENTRY NtGdiExtFloodFill(IN HDC hdc,IN INT x,IN INT y, IN COLORREF crColor,IN UINT iFillType);
W32KAPI BOOL     APIENTRY NtGdiFillRgn(IN HDC hdc,IN HRGN hrgn,IN HBRUSH hbrush);
W32KAPI BOOL     APIENTRY NtGdiFrameRgn(IN HDC hdc,IN HRGN hrgn,IN HBRUSH hbrush,IN int xWidth,IN int yHeight);
W32KAPI COLORREF APIENTRY NtGdiSetPixel(IN HDC hdcDst, IN int x, IN int y, IN COLORREF crColor);
W32KAPI DWORD    APIENTRY NtGdiGetPixel(IN HDC hdc, IN int x, IN int y);
W32KAPI BOOL     APIENTRY NtGdiStartPage(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiEndPage(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiStartDoc(IN HDC hdc,IN DOCINFOW *pdi,OUT BOOL *pbBanding, IN INT iJob);
W32KAPI BOOL     APIENTRY NtGdiEndDoc(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiAbortDoc(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiUpdateColors(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiGetCharWidthW(IN HDC hdc,IN UINT wcFirst,IN UINT cwc,IN PWCHAR pwc,
                                             IN FLONG fl,OUT PVOID pvBuf);
W32KAPI BOOL     APIENTRY NtGdiGetCharWidthInfo(IN HDC hdc,OUT PCHWIDTHINFO pChWidthInfo);
W32KAPI int      APIENTRY NtGdiDrawEscape(IN HDC hdc,IN int iEsc,IN int cjIn, IN LPSTR pjIn);
W32KAPI int      APIENTRY NtGdiExtEscape(IN HDC hdc,IN PWCHAR pDriver,IN int nDriver,IN int iEsc, IN int cjIn, IN LPSTR pjIn,
                                         IN int cjOut, OUT LPSTR pjOut);
W32KAPI ULONG    APIENTRY NtGdiGetFontData(IN HDC hdc,IN DWORD dwTable,IN DWORD dwOffset,OUT PVOID  pvBuf,IN ULONG cjBuf);
W32KAPI ULONG    APIENTRY NtGdiGetGlyphOutline(IN HDC hdc, IN WCHAR wch, IN UINT iFormat, OUT LPGLYPHMETRICS pgm,
                                               IN ULONG cjBuf,OUT PVOID pvBuf, IN LPMAT2 pmat2, IN BOOL bIgnoreRotation);
W32KAPI BOOL     APIENTRY NtGdiGetETM(IN HDC hdc,OUT EXTTEXTMETRIC *petm);
W32KAPI BOOL     APIENTRY NtGdiGetRasterizerCaps(OUT LPRASTERIZER_STATUS praststat, IN ULONG cjBytes);
W32KAPI ULONG    APIENTRY NtGdiGetKerningPairs(IN HDC hdc,IN ULONG cPairs,OUT KERNINGPAIR *pkpDst);
W32KAPI BOOL     APIENTRY NtGdiMonoBitmap(IN HBITMAP hbm);
W32KAPI HBITMAP  APIENTRY NtGdiGetObjectBitmapHandle(IN HBRUSH hbr,OUT UINT *piUsage);
W32KAPI ULONG    APIENTRY NtGdiEnumObjects(IN HDC hdc,IN int iObjectType,IN ULONG cjBuf,OUT PVOID pvBuf);
W32KAPI BOOL     APIENTRY NtGdiResetDC(IN HDC hdc, IN LPDEVMODEW pdm,OUT PBOOL pbBanding,IN VOID *pDriverInfo2, OUT VOID *ppUMdhpdev);
W32KAPI DWORD    APIENTRY NtGdiSetBoundsRect(IN HDC hdc,IN LPRECT prc,IN DWORD f);
W32KAPI BOOL     APIENTRY NtGdiGetColorAdjustment(IN HDC hdc,OUT PCOLORADJUSTMENT pcaOut);
W32KAPI BOOL     APIENTRY NtGdiSetColorAdjustment(IN HDC hdc, IN PCOLORADJUSTMENT pca);
W32KAPI BOOL     APIENTRY NtGdiCancelDC(IN HDC hdc);
W32KAPI HDC      APIENTRY NtGdiOpenDCW(IN PUNICODE_STRING pustrDevice, IN DEVMODEW *pdm, IN PUNICODE_STRING pustrLogAddr,
                                       IN ULONG iType, IN HANDLE hspool, IN VOID *pDriverInfo2, OUT VOID *pUMdhpdev);
W32KAPI BOOL     APIENTRY NtGdiGetDCDword( IN HDC hdc, IN UINT u, OUT DWORD *Result);
        PVOID    APIENTRY NtGdiMapSharedHandleTable(VOID);
W32KAPI BOOL     APIENTRY NtGdiGetDCPoint(IN HDC hdc,IN UINT iPoint,OUT PPOINTL pptOut);
W32KAPI BOOL     APIENTRY NtGdiScaleViewportExtEx(IN HDC hdc, IN int xNum, IN int xDenom, IN int yNum,
                                                  IN int yDenom, OUT LPSIZE pszOut);
W32KAPI BOOL     APIENTRY NtGdiScaleWindowExtEx(IN HDC hdc, IN int xNum,IN int xDenom, IN int yNum, IN int yDenom, OUT LPSIZE pszOut);
W32KAPI BOOL     APIENTRY NtGdiSetVirtualResolution(IN HDC hdc, IN int cxVirtualDevicePixel,IN int cyVirtualDevicePixel,
                                                    IN int cxVirtualDeviceMm, IN int cyVirtualDeviceMm);
W32KAPI BOOL     APIENTRY NtGdiSetSizeDevice(IN HDC hdc, IN int cxVirtualDevice,IN int cyVirtualDevice);
W32KAPI BOOL     APIENTRY NtGdiGetTransform(IN HDC hdc, IN DWORD iXform, OUT LPXFORM pxf);
W32KAPI BOOL     APIENTRY NtGdiModifyWorldTransform(IN HDC hdc, IN LPXFORM pxf,IN DWORD iXform);
W32KAPI BOOL     APIENTRY NtGdiCombineTransform(OUT LPXFORM pxfDst,IN LPXFORM pxfSrc1,IN LPXFORM pxfSrc2);
W32KAPI BOOL     APIENTRY NtGdiTransformPoints(IN HDC hdc,IN PPOINT pptIn,OUT PPOINT pptOut, IN int c,IN int iMode);
W32KAPI LONG     APIENTRY NtGdiConvertMetafileRect(IN HDC hdc,IN OUT PRECTL prect);

W32KAPI int      APIENTRY NtGdiGetTextCharsetInfo(IN HDC hdc, OUT LPFONTSIGNATURE lpSig, IN DWORD dwFlags);
        BOOL     APIENTRY NtGdiTranslateCharsetInfo(IN OUT DWORD FAR *lpSrc,  OUT LPCHARSETINFO lpCs, IN DWORD dwFlags);

W32KAPI BOOL     APIENTRY NtGdiDoBanding(IN HDC hdc, IN BOOL bStart, OUT POINTL *pptl, OUT PSIZE pSize);
W32KAPI ULONG    APIENTRY NtGdiGetPerBandInfo( IN HDC hdc, IN OUT PERBANDINFO *ppbi);

#define GS_NUM_OBJS_ALL    0
#define GS_HANDOBJ_CURRENT 1
#define GS_HANDOBJ_MAX     2
#define GS_HANDOBJ_ALLOC   3
#define GS_LOOKASIDE_INFO  4
W32KAPI NTSTATUS APIENTRY NtGdiGetStats(IN HANDLE hProcess,IN int iIndex, IN int iPidType, OUT PVOID pResults,IN UINT cjResultSize);

//API's used by USER
W32KAPI BOOL     APIENTRY NtGdiSetMagicColors(IN HDC hdc,IN PALETTEENTRY peMagic,IN ULONG Index);

W32KAPI HBRUSH   APIENTRY NtGdiSelectBrush(IN HDC hdc,IN HBRUSH hbrush);
W32KAPI HPEN     APIENTRY NtGdiSelectPen(IN HDC hdc,IN HPEN hpen);
W32KAPI HBITMAP  APIENTRY NtGdiSelectBitmap(IN HDC hdc,IN HBITMAP hbm);
W32KAPI HFONT    APIENTRY NtGdiSelectFont(IN HDC hdc, IN HFONT hf);

W32KAPI int      APIENTRY NtGdiExtSelectClipRgn(IN HDC hdc, IN HRGN hrgn, IN int iMode);

W32KAPI HPEN     APIENTRY NtGdiCreatePen(IN int iPenStyle, IN int iPenWidth, IN COLORREF cr, IN HBRUSH hbr);

//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// See also:
//      ntgdi\gre\maskblt.cxx
//
#ifndef _WINDOWBLT_NOTIFICATION_
#define _WINDOWBLT_NOTIFICATION_
#endif
#ifdef _WINDOWBLT_NOTIFICATION_
W32KAPI BOOL     APIENTRY NtGdiBitBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx, IN int cy, IN HDC hdcSrc, IN int xSrc,
                                      IN int ySrc, IN DWORD rop4, IN DWORD crBackColor, IN FLONG fl);
#else
W32KAPI BOOL     APIENTRY NtGdiBitBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx, IN int cy, IN HDC hdcSrc, IN int xSrc,
                                      IN int ySrc, IN DWORD rop4, IN DWORD crBackColor);
#endif
W32KAPI BOOL     APIENTRY NtGdiTileBitBlt(IN HDC hdcDst,IN RECTL * prectDst, IN HDC hdcSrc, IN RECTL * prectSrc, IN POINTL * pptlOrigin,
                                      IN DWORD rop4, IN DWORD crBackColor);

W32KAPI BOOL     APIENTRY NtGdiTransparentBlt(IN HDC hdcDst, IN int xDst, IN int yDst, IN int cxDst, IN int cyDst,
                                              IN HDC hdcSrc, IN int xSrc, IN int ySrc, IN int cxSrc, IN int cySrc,
                                              IN COLORREF TransColor);
W32KAPI BOOL     APIENTRY NtGdiGetTextExtent(IN HDC hdc, IN LPWSTR lpwsz, IN int cwc, OUT LPSIZE psize, IN UINT flOpts);
W32KAPI BOOL     APIENTRY NtGdiGetTextMetricsW(IN HDC hdc, OUT TMW_INTERNAL * ptm, IN ULONG cj);
W32KAPI int      APIENTRY NtGdiGetTextFaceW(IN HDC hdc, IN int cChar, OUT LPWSTR pszOut, IN BOOL bAliasName);
W32KAPI int      APIENTRY NtGdiGetRandomRgn(IN HDC hdc, IN HRGN hrgn, IN int iRgn);
W32KAPI BOOL     APIENTRY NtGdiExtTextOutW(IN HDC hdc, IN int x, IN int y, IN UINT flOpts, IN LPRECT prcl, IN LPWSTR pwsz,
                                           IN int cwc, IN LPINT pdx, IN DWORD dwCodePage);
W32KAPI int      APIENTRY NtGdiIntersectClipRect(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI HRGN     APIENTRY NtGdiCreateRectRgn(IN int xLeft, IN int yTop, IN int xRight, IN int yBottom);
W32KAPI BOOL     APIENTRY NtGdiPatBlt(IN HDC hdcDst,IN int x,IN int y,IN int cx,IN int cy, IN DWORD rop4);
typedef struct _POLYPATBLT POLYPATBLT,*PPOLYPATBLT;
W32KAPI BOOL     APIENTRY NtGdiPolyPatBlt(IN HDC hdc,IN DWORD rop4, IN PPOLYPATBLT pPoly, IN DWORD Count, IN DWORD Mode);

W32KAPI BOOL     APIENTRY NtGdiUnrealizeObject(IN HANDLE h);
W32KAPI HANDLE   APIENTRY NtGdiGetStockObject(IN int iObject);
W32KAPI HBITMAP  APIENTRY NtGdiCreateCompatibleBitmap(IN HDC hdc,IN int cx,IN int cy);
W32KAPI BOOL     APIENTRY NtGdiLineTo(IN HDC hdc, IN int x, IN int y);
W32KAPI BOOL     APIENTRY NtGdiMoveTo(IN HDC hdc,IN int x,IN int y,OUT LPPOINT pptOut);
W32KAPI int      APIENTRY NtGdiExtGetObjectW(IN HANDLE h,IN int cj,OUT LPVOID pvOut);
W32KAPI int      APIENTRY NtGdiGetDeviceCaps(IN HDC hdc, IN int i);
W32KAPI BOOL     APIENTRY NtGdiGetDeviceCapsAll (IN HDC hdc, OUT PDEVCAPS pDevCaps);
W32KAPI BOOL     APIENTRY NtGdiStretchBlt(IN HDC hdcDst, IN int xDst, IN int yDst, IN int cxDst, IN int cyDst,
                                          IN HDC hdcSrc, IN int xSrc, IN int ySrc, IN int cxSrc, IN int cySrc,
                                          IN DWORD dwRop,IN DWORD dwBackColor);
W32KAPI BOOL     APIENTRY NtGdiSetBrushOrg(IN HDC hdc,IN int x, IN int y, OUT LPPOINT pptOut);
W32KAPI HBITMAP  APIENTRY NtGdiCreateBitmap(IN int cx, IN int cy, IN UINT cPlanes, IN UINT cBPP, OUT LPBYTE pjInit);
W32KAPI HPALETTE APIENTRY NtGdiCreateHalftonePalette(IN HDC hdc);
W32KAPI BOOL     APIENTRY NtGdiRestoreDC(IN HDC hdc,IN int iLevel);
W32KAPI int      APIENTRY NtGdiExcludeClipRect(IN HDC hdc,IN int xLeft,IN int yTop,IN int xRight,IN int yBottom);
W32KAPI int      APIENTRY NtGdiSaveDC(IN HDC hdc);
W32KAPI int      APIENTRY NtGdiCombineRgn(IN HRGN hrgnDst,IN HRGN hrgnSrc1, IN HRGN hrgnSrc2,IN int iMode);
W32KAPI BOOL     APIENTRY NtGdiSetRectRgn(IN HRGN hrgn,IN int xLeft,IN int  yTop, IN int xRight,IN int yBottom);
W32KAPI LONG     APIENTRY NtGdiSetBitmapBits(IN HBITMAP hbm,IN ULONG cj,IN PBYTE pjInit);

W32KAPI int      APIENTRY NtGdiGetDIBitsInternal(IN HDC hdc, IN HBITMAP hbm, IN UINT iStartScan,IN UINT cScans,
                                                 OUT LPBYTE pBits, IN OUT LPBITMAPINFO pbmi, IN UINT iUsage,
                                                 IN UINT cjMaxBits, IN UINT cjMaxInfo);
W32KAPI int      APIENTRY NtGdiOffsetRgn(IN HRGN hrgn,IN int cx,IN int  cy);
W32KAPI int      APIENTRY NtGdiGetRgnBox(IN HRGN hrgn, OUT LPRECT prcOut);
W32KAPI BOOL     APIENTRY NtGdiRectInRegion(IN HRGN hrgn, OUT LPRECT prcl);
W32KAPI DWORD    APIENTRY NtGdiGetBoundsRect(IN HDC hdc, OUT LPRECT prc,IN DWORD f);
W32KAPI BOOL     APIENTRY NtGdiPtInRegion(IN HRGN hrgn,IN int x,IN int y);
W32KAPI COLORREF APIENTRY NtGdiGetNearestColor(IN HDC hdc, IN COLORREF cr);
W32KAPI UINT     APIENTRY NtGdiGetSystemPaletteUse(IN HDC hdc);
W32KAPI UINT     APIENTRY NtGdiSetSystemPaletteUse(IN HDC hdc, IN UINT ui);
W32KAPI DWORD    APIENTRY NtGdiGetRegionData(IN HRGN hrgn,IN DWORD nCount, OUT LPRGNDATA lpRgnData);
W32KAPI BOOL     APIENTRY NtGdiInvertRgn(IN HDC hdc, IN HRGN hrgn);
        int      APIENTRY NtGdiPerf(IN HDC hdc,IN int iEsc,IN PVOID pvIn);

// MISC FONT API's

int     W32KAPI  APIENTRY NtGdiAddFontResourceW(IN WCHAR *pwszFiles,IN ULONG cwc,IN ULONG cFiles,IN FLONG f,
                                                IN DWORD dwPidTid, IN DESIGNVECTOR *pdv);
#if (_WIN32_WINNT >= 0x0500)
W32KAPI HFONT    APIENTRY NtGdiHfontCreate(IN ENUMLOGFONTEXDVW *pelfw, IN ULONG cjElfw, IN LFTYPE lft,
                                           IN FLONG  fl, IN PVOID pvCliData);
#else
W32KAPI HFONT    APIENTRY NtGdiHfontCreate(IN LPEXTLOGFONTW pelfw, IN ULONG cjElfw, IN LFTYPE lft,
                                           IN FLONG fl, IN PVOID pvCliData);
#endif

W32KAPI ULONG    APIENTRY NtGdiSetFontEnumeration(IN ULONG ulType);
W32KAPI BOOL     APIENTRY NtGdiEnumFontClose(IN ULONG_PTR idEnum);
#if (_WIN32_WINNT >= 0x0500)
W32KAPI BOOL     APIENTRY NtGdiEnumFontChunk(IN HDC hdc,IN ULONG_PTR idEnum,IN ULONG cefdw,
                                             OUT ULONG *pcefdw,OUT PENUMFONTDATAW pefdw);
#endif
W32KAPI ULONG_PTR  APIENTRY NtGdiEnumFontOpen(IN HDC hdc, IN ULONG iEnumType, IN FLONG flWin31Compat, IN ULONG cwchMax,
                                              IN LPWSTR pwszFaceName, IN ULONG lfCharSet, OUT ULONG *pulCount);

#define TYPE_ENUMFONTS          1
#define TYPE_ENUMFONTFAMILIES   2
#define TYPE_ENUMFONTFAMILIESEX 3

W32KAPI INT      APIENTRY NtGdiQueryFonts(OUT PUNIVERSAL_FONT_ID pufiFontList,IN ULONG nBufferSize,
                                          OUT PLARGE_INTEGER pTimeStamp );

// Console API

W32KAPI BOOL     APIENTRY NtGdiConsoleTextOut(IN HDC hdc, IN POLYTEXTW *lpto,IN UINT nStrings, IN RECTL *prclBounds);
W32KAPI NTSTATUS APIENTRY NtGdiFullscreenControl(IN FULLSCREENCONTROL FullscreenCommand, IN PVOID FullscreenInput,
                                                 IN DWORD FullscreenInputLength, OUT PVOID FullscreenOutput,
                                                 IN OUT PULONG FullscreenOutputLength);


// needed for win95 functionality

W32KAPI DWORD    NtGdiGetCharSet(IN HDC hdc);

// needed for fontlinking

W32KAPI BOOL APIENTRY  NtGdiEnableEudc(IN BOOL);
        UINT APIENTRY  NtGdiEudcQuerySystemLink(OUT LPWSTR pszOut,IN UINT cChar);

W32KAPI BOOL APIENTRY  NtGdiEudcLoadUnloadLink(IN LPCWSTR pBaseFaceName, IN UINT cwcBaseFaceName, IN LPCWSTR pEudcFontPath,
                                               IN UINT cwcEudcFontPath, IN INT iPriority, IN INT iFontLinkType, IN BOOL bLoadLin);
W32KAPI UINT APIENTRY  NtGdiGetStringBitmapW(IN HDC hdc, IN LPWSTR pwsz, IN UINT cwc, OUT BYTE *lpSB, IN UINT cj);
W32KAPI ULONG APIENTRY NtGdiGetEudcTimeStampEx(IN LPWSTR lpBaseFaceName,IN ULONG cwcBaseFaceName,IN BOOL bSystemTimeStamp);
W32KAPI ULONG APIENTRY NtGdiQueryFontAssocInfo(IN HDC hdc);

#if (_WIN32_WINNT >= 0x0500)
W32KAPI DWORD NtGdiGetFontUnicodeRanges(IN HDC hdc, OUT LPGLYPHSET pgs);
#endif

#ifdef LANGPACK
W32KAPI BOOL NtGdiGetRealizationInfo(IN HDC hdc, OUT PREALIZATION_INFO pri, IN HFONT hf);
#endif

typedef struct tagDOWNLOADDESIGNVECTOR {
    UNIVERSAL_FONT_ID ufiBase;
    DESIGNVECTOR      dv;
} DOWNLOADDESIGNVECTOR;

W32KAPI BOOL NtGdiAddRemoteMMInstanceToDC(IN HDC hdc,IN DOWNLOADDESIGNVECTOR *pddv,IN ULONG cjDDV);

        int  APIENTRY NtGdiGetMessage(IN OUT void* );           // client/server
        BOOL APIENTRY NtGdiCall(IN OUT GDICALL*);               // misc helper functions
// user-mode printer support

W32KAPI BOOL APIENTRY NtGdiUnloadPrinterDriver(IN LPWSTR pDriverName,IN ULONG cbDriverName);
W32KAPI BOOL APIENTRY NtGdiEngAssociateSurface(IN HSURF  hsurf,IN HDEV hdev,IN FLONG  flHooks);
W32KAPI BOOL APIENTRY NtGdiEngEraseSurface(IN SURFOBJ *pso,IN RECTL *prcl,IN ULONG iColor);
W32KAPI HBITMAP APIENTRY NtGdiEngCreateBitmap(IN SIZEL sizl,IN LONG lWidth,IN ULONG iFormat,IN FLONG fl,IN PVOID pvBits);
W32KAPI BOOL APIENTRY NtGdiEngDeleteSurface(IN HSURF hsurf);
W32KAPI SURFOBJ* APIENTRY NtGdiEngLockSurface(IN HSURF hsurf);
W32KAPI VOID APIENTRY NtGdiEngUnlockSurface(IN SURFOBJ *);
W32KAPI BOOL APIENTRY NtGdiEngMarkBandingSurface(HSURF hsurf);
W32KAPI HSURF APIENTRY NtGdiEngCreateDeviceSurface(IN DHSURF dhsurf, IN SIZEL sizl, IN ULONG iFormatCompat);
W32KAPI HBITMAP APIENTRY NtGdiEngCreateDeviceBitmap(IN DHSURF dhsurf, IN SIZEL sizl, IN ULONG iFormatCompat);

W32KAPI BOOL APIENTRY NtGdiEngCopyBits(IN SURFOBJ *psoDst,IN SURFOBJ *psoSrc,IN CLIPOBJ *pco,IN XLATEOBJ *pxlo,
                                       IN RECTL *prclDst,IN POINTL *pptlSrc);
W32KAPI BOOL APIENTRY NtGdiEngStretchBlt(IN SURFOBJ *psoDest,IN SURFOBJ *psoSrc,IN SURFOBJ *psoMask,IN CLIPOBJ *pco,
                                         IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlHTOrg, IN RECTL *prclDest,
                                         IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode);
W32KAPI BOOL APIENTRY NtGdiEngBitBlt(IN SURFOBJ *psoDst,IN SURFOBJ *psoSrc,IN SURFOBJ *psoMask,IN CLIPOBJ *pco,IN XLATEOBJ *pxlo,
                                     IN RECTL *prclDst,IN POINTL *pptlSrc,IN POINTL *pptlMask,IN BRUSHOBJ *pbo,IN POINTL *pptlBrush,
                                     IN ROP4 rop4);
W32KAPI BOOL APIENTRY NtGdiEngPlgBlt(IN SURFOBJ *psoTrg,IN SURFOBJ *psoSrc, IN SURFOBJ *psoMsk, IN CLIPOBJ *pco,
                                     IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlBrushOrg, IN POINTFIX *pptfxDest,
                                     IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode);
W32KAPI HPALETTE APIENTRY NtGdiEngCreatePalette(IN ULONG iMode, IN ULONG cColors, IN ULONG *pulColors, IN FLONG flRed,
                                                IN FLONG flGreen, IN FLONG flBlue);
W32KAPI BOOL APIENTRY NtGdiEngDeletePalette(IN HPALETTE hPal);
W32KAPI BOOL APIENTRY NtGdiEngStrokePath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco, IN XFORMOBJ *pxo,
                                         IN BRUSHOBJ *pbo,IN POINTL *pptlBrushOrg,IN LINEATTRS *plineattrs,MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngFillPath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco,IN BRUSHOBJ *pbo,
                                       IN POINTL *pptlBrushOrg,IN MIX mix,IN FLONG flOptions);
W32KAPI BOOL APIENTRY NtGdiEngStrokeAndFillPath(IN SURFOBJ *pso,IN PATHOBJ *ppo,IN CLIPOBJ *pco,IN XFORMOBJ *pxo,
                                                IN BRUSHOBJ *pboStroke,IN LINEATTRS *plineattrs,IN BRUSHOBJ *pboFill,
                                                IN POINTL *pptlBrushOrg,IN MIX mix,IN FLONG flOptions);
W32KAPI BOOL APIENTRY NtGdiEngPaint(IN SURFOBJ *pso, IN CLIPOBJ *pco, IN BRUSHOBJ *pbo, IN POINTL *pptlBrushOrg, IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngLineTo(IN SURFOBJ *pso, IN CLIPOBJ *pco, IN BRUSHOBJ *pbo, IN LONG x1, IN LONG y1,
                                     IN LONG x2, IN LONG y2, IN RECTL *prclBounds, IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngAlphaBlend(IN SURFOBJ *psoDest,IN SURFOBJ *psoSrc, IN CLIPOBJ *pco, XLATEOBJ *pxlo,IN RECTL *prclDest,
                                         IN RECTL *prclSrc,IN BLENDOBJ *pBlendObj);
W32KAPI BOOL APIENTRY NtGdiEngGradientFill(IN SURFOBJ *psoDest,IN CLIPOBJ *pco, IN XLATEOBJ *pxlo, TRIVERTEX *pVertex,
                                           IN ULONG nVertex, IN PVOID pMesh, IN ULONG nMesh, IN RECTL *prclExtents,
                                           IN POINTL *pptlDitherOrg, IN ULONG ulMode);
W32KAPI BOOL APIENTRY NtGdiEngTransparentBlt(IN SURFOBJ *psoDst, IN SURFOBJ *psoSrc, IN CLIPOBJ *pco, IN XLATEOBJ *pxlo,
                                             IN RECTL *prclDst, IN RECTL *prclSrc, IN ULONG iTransColor, ULONG ulReserved);
W32KAPI BOOL APIENTRY NtGdiEngTextOut(IN SURFOBJ *pso,IN STROBJ *pstro, IN FONTOBJ *pfo, IN CLIPOBJ *pco, IN RECTL *prclExtra,
                                      IN RECTL *prclOpaque, IN BRUSHOBJ *pboFore, IN BRUSHOBJ *pboOpaque, IN POINTL *pptlOrg,
                                      IN MIX mix);
W32KAPI BOOL APIENTRY NtGdiEngStretchBltROP(IN SURFOBJ *psoTrg, IN SURFOBJ *psoSrc, IN SURFOBJ *psoMask, IN CLIPOBJ *pco,
                                            IN XLATEOBJ *pxlo, IN COLORADJUSTMENT *pca, IN POINTL *pptlBrushOrg,
                                            IN RECTL *prclTrg, IN RECTL *prclSrc, IN POINTL *pptlMask, IN ULONG iMode,
                                            IN BRUSHOBJ *pbo, IN ROP4 rop4);

W32KAPI ULONG APIENTRY NtGdiXLATEOBJ_cGetPalette(IN XLATEOBJ *pxlo, IN ULONG iPal, IN ULONG cPal, OUT ULONG *pPal);

W32KAPI ULONG    APIENTRY NtGdiCLIPOBJ_cEnumStart(IN CLIPOBJ *pco, IN BOOL bAll, IN ULONG iType, IN ULONG iDirection, IN ULONG cLimit);
W32KAPI BOOL     APIENTRY NtGdiCLIPOBJ_bEnum(IN CLIPOBJ *pco, IN ULONG cj, OUT ULONG *pul);
W32KAPI PATHOBJ* APIENTRY NtGdiCLIPOBJ_ppoGetPath(IN CLIPOBJ *pco);
W32KAPI CLIPOBJ* APIENTRY NtGdiEngCreateClip();
W32KAPI VOID     APIENTRY NtGdiEngDeleteClip(IN CLIPOBJ*pco);

W32KAPI PVOID    APIENTRY NtGdiBRUSHOBJ_pvAllocRbrush(IN BRUSHOBJ *pbo,IN ULONG cj);
W32KAPI PVOID    APIENTRY NtGdiBRUSHOBJ_pvGetRbrush(IN BRUSHOBJ *pbo);
W32KAPI ULONG    APIENTRY NtGdiBRUSHOBJ_ulGetBrushColor(IN BRUSHOBJ *pbo);
W32KAPI HANDLE   APIENTRY NtGdiBRUSHOBJ_hGetColorTransform(IN BRUSHOBJ *pbo);

W32KAPI BOOL     APIENTRY NtGdiXFORMOBJ_bApplyXform(IN XFORMOBJ *pxo, IN ULONG iMode, IN ULONG cPoints, IN PVOID pvIn, OUT PVOID pvOut);
W32KAPI ULONG    APIENTRY NtGdiXFORMOBJ_iGetXform(IN XFORMOBJ *pxo, OUT XFORML *pxform);

W32KAPI VOID     APIENTRY NtGdiFONTOBJ_vGetInfo(IN FONTOBJ *pfo, IN ULONG cjSize, OUT FONTINFO *pfi);
W32KAPI ULONG    APIENTRY NtGdiFONTOBJ_cGetGlyphs(IN FONTOBJ *pfo, IN ULONG iMode, IN ULONG cGlyph, IN HGLYPH *phg, OUT PVOID *ppvGlyph);
W32KAPI XFORMOBJ*  APIENTRY NtGdiFONTOBJ_pxoGetXform(IN FONTOBJ *pfo);
W32KAPI IFIMETRICS* APIENTRY NtGdiFONTOBJ_pifi(IN FONTOBJ *pfo);
W32KAPI FD_GLYPHSET* APIENTRY NtGdiFONTOBJ_pfdg(IN FONTOBJ *pfo);
W32KAPI ULONG    APIENTRY NtGdiFONTOBJ_cGetAllGlyphHandles(IN FONTOBJ *pfo, OUT HGLYPH *phg);
W32KAPI PVOID    APIENTRY  NtGdiFONTOBJ_pvTrueTypeFontFile(IN FONTOBJ *pfo, OUT ULONG *pcjFile);
W32KAPI PFD_GLYPHATTR APIENTRY NtGdiFONTOBJ_pQueryGlyphAttrs(IN FONTOBJ *pfo, IN ULONG iMode);

W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bEnum(IN STROBJ *pstro, OUT ULONG *pc, OUT PGLYPHPOS *ppgpos);
W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bEnumPositionsOnly(IN STROBJ *pstro,ULONG *pc,OUT PGLYPHPOS *ppgpos);
W32KAPI VOID     APIENTRY NtGdiSTROBJ_vEnumStart(IN STROBJ *pstro);
W32KAPI DWORD    APIENTRY NtGdiSTROBJ_dwGetCodePage(IN STROBJ *pstro);
W32KAPI BOOL     APIENTRY NtGdiSTROBJ_bGetAdvanceWidths(IN STROBJ*pstro, IN ULONG iFirst, IN ULONG c, OUT POINTQF*pptqD);
W32KAPI FD_GLYPHSET* APIENTRY NtGdiEngComputeGlyphSet(IN INT nCodePage, IN INT nFirstChar, IN INT cChars);

W32KAPI ULONG    APIENTRY NtGdiXLATEOBJ_iXlate(IN XLATEOBJ *pxlo, IN ULONG iColor);
W32KAPI HANDLE   APIENTRY NtGdiXLATEOBJ_hGetColorTransform(IN XLATEOBJ *pxlo);

W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vGetBounds(IN PATHOBJ *ppo, OUT PRECTFX prectfx);
W32KAPI BOOL     APIENTRY NtGdiPATHOBJ_bEnum(IN PATHOBJ *ppo, OUT PATHDATA  *ppd);  
W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vEnumStart(IN PATHOBJ *ppo);
W32KAPI VOID     APIENTRY NtGdiEngDeletePath(IN PATHOBJ *ppo);
W32KAPI VOID     APIENTRY NtGdiPATHOBJ_vEnumStartClipLines(IN PATHOBJ *ppo, IN CLIPOBJ *pco, IN SURFOBJ *pso, IN LINEATTRS *pla);
W32KAPI BOOL     APIENTRY NtGdiPATHOBJ_bEnumClipLines(IN PATHOBJ *ppo, IN ULONG cb, OUT CLIPLINE *pcl);

W32KAPI BOOL     APIENTRY NtGdiEngCheckAbort(IN SURFOBJ *pso);
W32KAPI DHPDEV            NtGdiGetDhpdev(IN HDEV hdev);

W32KAPI LONG     APIENTRY NtGdiHT_Get8BPPFormatPalette(OUT LPPALETTEENTRY pPaletteEntry, IN USHORT RedGamma,
                                                       IN USHORT GreenGamma, IN USHORT BlueGamma);
W32KAPI LONG     APIENTRY NtGdiHT_Get8BPPMaskPalette(OUT LPPALETTEENTRY pPaletteEntry, IN BOOL Use8BPPMaskPal,
                                                     IN BYTE CMYMask, IN USHORT RedGamma, IN USHORT GreenGamma, IN USHORT BlueGamma);

W32KAPI BOOL              NtGdiUpdateTransform(IN HDC hdc);

W32KAPI DWORD    APIENTRY NtGdiSetLayout(IN HDC hdc, IN LONG wox, IN DWORD dwLayout);
W32KAPI BOOL     APIENTRY NtGdiMirrorWindowOrg(IN HDC hdc);
W32KAPI LONG     APIENTRY NtGdiGetDeviceWidth(IN HDC hdc);

W32KAPI BOOL              NtGdiSetPUMPDOBJ(IN HUMPD humpd, IN BOOL bStoreID, OUT HUMPD *phumpd, OUT BOOL *pbWOW64);
W32KAPI BOOL              NtGdiBRUSHOBJ_DeleteRbrush(IN BRUSHOBJ *pbo, IN BRUSHOBJ *pboB);
W32KAPI BOOL              NtGdiUMPDEngFreeUserMem(IN KERNEL_PVOID *ppv);
W32KAPI HBITMAP APIENTRY NtGdiSetBitmapAttributes(IN HBITMAP hbm, IN DWORD dwFlags);
W32KAPI HBITMAP APIENTRY NtGdiClearBitmapAttributes(IN HBITMAP hbm, IN DWORD dwFlags);
W32KAPI HBRUSH APIENTRY NtGdiSetBrushAttributes(IN HBRUSH hbm, IN DWORD dwFlags);
W32KAPI HBRUSH APIENTRY NtGdiClearBrushAttributes(IN HBRUSH hbm, IN DWORD dwFlags);

// Private draw stream interface

W32KAPI BOOL APIENTRY NtGdiDrawStream(IN HDC, IN ULONG, IN VOID *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\ntgdispl.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdispl.h
*
* Created: 21-Feb-1995 10:05:31
* Author:  Eric Kutter [erick]
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
\**************************************************************************/

#define GDISPOOL_API                0x80000000

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

// NON-API GDISPOOL calls must NOT have MSB set
#define GDISPOOL_TERMINATETHREAD       0x00000000
#define GDISPOOL_INPUT2SMALL           0x00000001
#define GDISPOOL_GETPATHNAME           0x00000002
#define GDISPOOL_UNLOADDRIVER_COMPLETE 0x00000003

// API GDISPOOL messages MUST have MSB set
#define GDISPOOL_WRITE              0x80000000
#define GDISPOOL_OPENPRINTER        0x80000001
#define GDISPOOL_CLOSEPRINTER       0x80000002
#define GDISPOOL_ABORTPRINTER       0x80000003
#define GDISPOOL_STARTDOCPRINTER    0x80000004
#define GDISPOOL_STARTPAGEPRINTER   0x80000005
#define GDISPOOL_ENDPAGEPRINTER     0x80000006
#define GDISPOOL_ENDDOCPRINTER      0x80000007
#define GDISPOOL_GETPRINTERDRIVER   0x80000008
#define GDISPOOL_GETPRINTERDATA     0x80000009
#define GDISPOOL_SETPRINTERDATA     0x8000000a
#define GDISPOOL_ENUMFORMS          0x8000000b
#define GDISPOOL_GETFORM            0x8000000c
#define GDISPOOL_GETPRINTER         0x8000000d

DECLARE_HANDLE(HSPOOLOBJ);

/*********************************Class************************************\
* SPOOLESC
*
*   structure used to communicate between the kernel and spooler process
*
*
* History:
*  27-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

typedef struct _SPOOLESC
{
    ULONG  cj;          // size of this structure including ajData[]
    ULONG  iMsg;        // message index GDISPOOL_...
    HANDLE hSpool;      // spoolss spooler handle
    ULONG  cjOut;       // required size of output buffer

    HSPOOLOBJ hso;      // kernel spool obj

    ULONG  ulRet;       // return value from spooler API

    BYTE  ajData[1];
} SPOOLESC, *PSPOOLESC;

/****************************************************************************
*  GREOPENPRINTER
*  GRESTARTDOCPRINTER
*  GREWRITEPRINTER
*  GREGETPRINTERDATA
*
*  The following structures are used package up the data unique to each
* spooler API
*
*
*  History:
*   5/1/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

typedef struct _GREOPENPRINTER
{
    LONG              cj;
    LONG              cjName;
    LONG              cjDatatype;
    LONG              cjDevMode;
    PRINTER_DEFAULTSW pd;
    LONG              alData[1];

} GREOPENPRINTER;

typedef struct _GREGETPRINTERDRIVER
{
    LONG            cj;
    LONG            cjEnv;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            alData[1];
} GREGETPRINTERDRIVER;


typedef struct _GRESTARTDOCPRINTER
{
    LONG            cj;
    LONG            cjDocName;
    LONG            cjOutputFile;
    HANDLE          hFile;
    DWORD           TargetProcessID;
    LONG            cjDatatype;
    LONG            cjData;
    LONG            alData[1];
} GRESTARTDOCPRINTER;


typedef struct _GREWRITEPRINTER
{
    LONG            cj;
    PULONG          pUserModeData;
    ULONG           cjUserModeData;
    LONG            cjData;
    LONG            alData[1];
} GREWRITEPRINTER;


typedef struct _GREGETPRINTERDATA
{
    LONG            cj;
    LONG            cjValueName;
    DWORD           dwType;
    DWORD           dwNeeded;
    LONG            cjData;
    LONG            alData[1];
} GREGETPRINTERDATA;


typedef struct _GRESETPRINTERDATA
{
    LONG            cj;
    LONG            cjType;
    LONG            cjPrinterData;
    DWORD           dwType;
    LONG            alData[1];
} GRESETPRINTERDATA;


typedef struct _GREENUMFORMS
{
    LONG            cj;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            nForms;
    LONG            alData[1];
} GREENUMFORMS;


typedef struct _GREGETPRINTER
{
    LONG            cj;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            alData[1];
} GREGETPRINTER;


typedef struct _GREGETFORM
{
    LONG            cj;
    LONG            cjFormName;
    DWORD           dwLevel;
    LONG            cjData;
    LONG            alData[1];
} GREGETFORM;


typedef struct _GREINPUT2SMALL
{
    LONG            cj;
    DWORD            dwNeeded;
    BYTE            *pjPsm;
} GREINPUT2SMALL;


typedef struct _GETPATHNAME
{
    LONG            cj;
    WCHAR           awcPath[MAX_PATH+1];
} GREGETPATHNAME;

/**************************************************************************\
 *
 * gre internal spooler entry points
 *
\**************************************************************************/

ULONG GreGetSpoolMessage(PSPOOLESC, PBYTE, ULONG, PULONG, ULONG);

BOOL WINAPI
GreEnumFormsW(
   HANDLE hSpool,
   GREENUMFORMS *pEnumForms,
   GREENUMFORMS *pEnumFormsReturn,
   LONG cjOut );

BOOL
GreGenericW(
    HANDLE hSpool,
    PULONG pX,
    PULONG pXReturn,
    LONG   cjOut,
    LONG   MessageID,
    ULONG  ulFlag );

BOOL WINAPI
GreGetPrinterDriverW(
   HANDLE hSpool,
   GREGETPRINTERDRIVER *pGetPrinterDriver,
   GREGETPRINTERDRIVER *pGetPrinterDriverReturn,
   LONG cjOut );

DWORD
GreStartDocPrinterW(
    HANDLE hSpool,
    GRESTARTDOCPRINTER *pStartDocPrinter,
    GRESTARTDOCPRINTER *pStartDocPrinterReturn
);

BOOL
WINAPI
GreOpenPrinterW(
   GREOPENPRINTER *pOpenPrinter,
   LPHANDLE  phPrinter);


ULONG
GreWritePrinter(
    HANDLE hSpool,
    GREWRITEPRINTER  *pWritePrinter);

BOOL
GrePrinterDriverUnloadW(
    LPWSTR pDriverName);

W32KAPI
BOOL APIENTRY
NtGdiInitSpool();

W32KAPI
ULONG APIENTRY
NtGdiGetSpoolMessage(
    PSPOOLESC psesc,
    ULONG cjMsg,
    PULONG pulOut,
    ULONG cjOut);

ULONG APIENTRY
SendSimpleMessage(
    HANDLE hSpool,
    ULONG iMsg,
    DWORD dwSpoolInstance);

BOOL APIENTRY
GdiInitSpool();

ULONG APIENTRY
GdiGetSpoolMessage(
    PSPOOLESC psesc,
    ULONG cjMsg,
    PULONG pulOut,
    ULONG cjOut);

ULONG APIENTRY
GdiSpoolEsc(
    HANDLE hSpool,
    ULONG iMsg,
    PBYTE pjIn,
    ULONG cjIn,
    PBYTE pjOut,
    ULONG cjOut);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\ntgdistr.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdistr.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
\**************************************************************************/

// PUBLIC Structures and constants

typedef enum _ARCTYPE
{
    ARCTYPE_ARC = 0,
    ARCTYPE_ARCTO,
    ARCTYPE_CHORD,
    ARCTYPE_PIE,
    ARCTYPE_MAX
} ARCTYPE;


//
// Font Types
//

typedef enum _LFTYPE {
    LF_TYPE_USER,                // user (defined by APP)
    LF_TYPE_SYSTEM,              // system stock font
    LF_TYPE_SYSTEM_FIXED,        // system fixed pitch stock font
    LF_TYPE_OEM,                 // oem (terminal) stock font
    LF_TYPE_DEVICE_DEFAULT,      // device default stock font
    LF_TYPE_ANSI_VARIABLE,       // ANSI variable pitch stock font
    LF_TYPE_ANSI_FIXED,          // ANSI fixed pitch stock font
    LF_TYPE_DEFAULT_GUI          // default GUI stock font
} LFTYPE;


// for GetDCDWord

#define DDW_JOURNAL             0
#define DDW_RELABS              1
#define DDW_BREAKEXTRA          2
#define DDW_CBREAK              3
#define DDW_ARCDIRECTION        4
#define DDW_SAVEDEPTH           5
#define DDW_FONTLANGUAGEINFO    6
#define DDW_ISMEMDC             7
#define DDW_MAPMODE             8
#define DDW_TEXTCHARACTEREXTRA  9
#define DDW_MAX                 10  // must equal highest DDW_XXXXX plus one

// for GetAndSetDCDword
#define GASDDW_EPSPRINTESCCALLED   1
#define GASDDW_COPYCOUNT           2
#define GASDDW_TEXTALIGN           3
#define GASDDW_RELABS              4
#define GASDDW_TEXTCHARACTEREXTRA  5
#define GASDDW_SELECTFONT          6
#define GASDDW_MAPPERFLAGS         7
#define GASDDW_MAPMODE             8
#define GASDDW_ARCDIRECTION        9
#define GASDDW_MAX                10  // must equal highest GASDDW_XXXXX plus one

// for GetDCPoint
#define DCPT_VPEXT                 1
#define DCPT_WNDEXT                2
#define DCPT_VPORG                 3
#define DCPT_WNDORG                4
#define DCPT_ASPECTRATIOFILTER     5
#define DCPT_DCORG                 6
#define DCPT_MAX                   7 // must equal highest DCPT_XXXXX plus one

// for GetAndSetDCPoint
#define GASDCPT_CURRENTPOSITION    1
#define GASDCPT_MAX                2 // must equal highest GASDCPT_XXXXX plus one


// private ModifyWorldTransform modes

#define MWT_SET     (MWT_MAX+1)

// modes from converting points

#define XFP_DPTOLP                 0
#define XFP_LPTODP                 1
#define XFP_LPTODPFX               2

//BUGBUG private devcaps for client side xform's

#define HORZSIZEM (int)0x80000000
#define VERTSIZEM (int)0x80000002

//
// Object identifiers
//

#define MFEN_IDENTIFIER     0x5845464D  /* 'MFEN' */
#define MFPICT_IDENTIFIER   0x5F50464D  /* 'MFP_' */

//
// Object types, used for handles.
//
// Note: When modifying this list, also please modify list in hmgrapi.cxx!
//

#define DEF_TYPE            0
#define DC_TYPE             1
#define UNUSED1_TYPE        2   // Unused
#define UNUSED2_TYPE        3   // Unused
#define RGN_TYPE            4
#define SURF_TYPE           5
#define CLIENTOBJ_TYPE      6
#define PATH_TYPE           7
#define PAL_TYPE            8
#define ICMLCS_TYPE         9
#define LFONT_TYPE          10
#define RFONT_TYPE          11
#define PFE_TYPE            12
#define PFT_TYPE            13
#define ICMCXF_TYPE         14
#define SPRITE_TYPE         15
#define BRUSH_TYPE          16
#define UMPD_TYPE           17
#define UNUSED4_TYPE        18  // Unused
#define SPACE_TYPE          19
#define UNUSED5_TYPE        20  // Unused
#define META_TYPE           21
#define EFSTATE_TYPE        22
#define BMFD_TYPE           23  // Unused
#define VTFD_TYPE           24  // Unused
#define TTFD_TYPE           25  // Unused
#define RC_TYPE             26  // Unused
#define TEMP_TYPE           27  // Unused
#define DRVOBJ_TYPE         28
#define DCIOBJ_TYPE         29  // Unused
#define SPOOL_TYPE          30
#define MAX_TYPE            30  // Don't go over 31 -- limited by TYPE_BITS

// SAMEHANDLE/DIFFHANDLE macros
//
// These macros should be used to compare engine handles (such as HDCs, etc),
// when insensitivity to the user defined bits are needed.

// BUGBUG - this should be accessible to USER

#define SAMEHANDLE(H,K) (H == K)
#define DIFFHANDLE(H,K) (H != K)


// the following define the format of GDI handles.  Any information that is needed
// for the type is here.  All other handle information is in gre\hmgr.h.

#define INDEX_BITS         16
#define TYPE_BITS           5
#define ALTTYPE_BITS        2
#define STOCK_BITS          1
#define UNIQUE_BITS         8

#define TYPE_SHIFT          (INDEX_BITS)
#define ALTTYPE_SHIFT       (TYPE_SHIFT + TYPE_BITS)
#define STOCK_SHIFT         (ALTTYPE_SHIFT + ALTTYPE_BITS)

#define MAX_HANDLE_COUNT  0x10000
#define MIN_HANDLE_QUOTA   0x100
#define INITIAL_HANDLE_QUOTA  0x3000
#define MAKE_HMGR_HANDLE(Index,Unique) LongToHandle(((((LONG) Unique) << INDEX_BITS) | ((LONG) Index)))
#define FULLUNIQUE_MASK     0xffff0000
#define FULLUNIQUE_STOCK_MASK (1 << (TYPE_BITS+ALTTYPE_BITS))

// if the GDISTOCKOBJ bit is set in a handle, it is a stock object.

#define GDISTOCKOBJ         (1 << STOCK_SHIFT)
#define IS_STOCKOBJ(h)      ((ULONG_PTR)(h) & GDISTOCKOBJ)

// LO_TYPE(h)  returns the client side type given a GRE handle.
// GRE_TYPE(h) returns the gre side type given a client type

#define LO_TYPE(h)          (DWORD)((ULONG_PTR)(h) & (((1 << (TYPE_BITS + ALTTYPE_BITS)) - 1) << TYPE_SHIFT))
#define GRE_TYPE(h)         (DWORD)(((ULONG_PTR)(h) >> INDEX_BITS) & ((1 << TYPE_BITS) - 1))

// ALTTYPEx are modifiers to distinguish client side object types that all map to
// a single server side type.  BRUSH_TYPE maps to LO_BRUSH_TYPE, LO_PEN_TYPE and LO_EXTPEN_TYPE

#define ALTTYPE1            (1 << ALTTYPE_SHIFT)
#define ALTTYPE2            (2 << ALTTYPE_SHIFT)
#define ALTTYPE3            (3 << ALTTYPE_SHIFT)

#define LO_BRUSH_TYPE       (BRUSH_TYPE     << TYPE_SHIFT)
#define LO_DC_TYPE          (DC_TYPE        << TYPE_SHIFT)
#define LO_BITMAP_TYPE      (SURF_TYPE      << TYPE_SHIFT)
#define LO_PALETTE_TYPE     (PAL_TYPE       << TYPE_SHIFT)
#define LO_FONT_TYPE        (LFONT_TYPE     << TYPE_SHIFT)
#define LO_REGION_TYPE      (RGN_TYPE       << TYPE_SHIFT)
#define LO_ICMLCS_TYPE      (ICMLCS_TYPE    << TYPE_SHIFT)
#define LO_CLIENTOBJ_TYPE   (CLIENTOBJ_TYPE << TYPE_SHIFT)

#define LO_ALTDC_TYPE       (LO_DC_TYPE        | ALTTYPE1)
#define LO_PEN_TYPE         (LO_BRUSH_TYPE     | ALTTYPE1)
#define LO_EXTPEN_TYPE      (LO_BRUSH_TYPE     | ALTTYPE2)
#define LO_DIBSECTION_TYPE  (LO_BITMAP_TYPE    | ALTTYPE1)
#define LO_METAFILE16_TYPE  (LO_CLIENTOBJ_TYPE | ALTTYPE1)
#define LO_METAFILE_TYPE    (LO_CLIENTOBJ_TYPE | ALTTYPE2)
#define LO_METADC16_TYPE    (LO_CLIENTOBJ_TYPE | ALTTYPE3)


//
// Format of HGDIOBJ typedef'ed so it
//  is available in the symbol file.
//
typedef struct {
    ULONG_PTR Index:INDEX_BITS;
    ULONG_PTR Type:TYPE_BITS;
    ULONG_PTR AltType:ALTTYPE_BITS;
    ULONG_PTR Stock:STOCK_BITS;
    ULONG_PTR Unique:UNIQUE_BITS;
} GDIHandleBitFields;


//
// Enum of object types so the values
//  are available in the symbol file.
//
#define ENUMObjType(type)   GDIObjType_##type = type
typedef enum {
    ENUMObjType(DEF_TYPE),
    ENUMObjType(DC_TYPE),
    ENUMObjType(UNUSED1_TYPE),
    ENUMObjType(UNUSED2_TYPE),
    ENUMObjType(RGN_TYPE),
    ENUMObjType(SURF_TYPE),
    ENUMObjType(CLIENTOBJ_TYPE),
    ENUMObjType(PATH_TYPE),
    ENUMObjType(PAL_TYPE),
    ENUMObjType(ICMLCS_TYPE),
    ENUMObjType(LFONT_TYPE),
    ENUMObjType(RFONT_TYPE),
    ENUMObjType(PFE_TYPE),
    ENUMObjType(PFT_TYPE),
    ENUMObjType(ICMCXF_TYPE),
    ENUMObjType(SPRITE_TYPE),
    ENUMObjType(BRUSH_TYPE),
    ENUMObjType(UMPD_TYPE),
    ENUMObjType(UNUSED4_TYPE),
    ENUMObjType(SPACE_TYPE),
    ENUMObjType(UNUSED5_TYPE),
    ENUMObjType(META_TYPE),
    ENUMObjType(EFSTATE_TYPE),
    ENUMObjType(BMFD_TYPE),
    ENUMObjType(VTFD_TYPE),
    ENUMObjType(TTFD_TYPE),
    ENUMObjType(RC_TYPE),
    ENUMObjType(TEMP_TYPE),
    ENUMObjType(DRVOBJ_TYPE),
    ENUMObjType(DCIOBJ_TYPE),
    ENUMObjType(SPOOL_TYPE),
    ENUMObjType(MAX_TYPE),

    GDIObjTypeTotal
} GDIObjType;

#define ENUMLoObjType(type)   GDILoObjType_##type = type
typedef enum {
    ENUMLoObjType(LO_BRUSH_TYPE),
    ENUMLoObjType(LO_DC_TYPE),
    ENUMLoObjType(LO_BITMAP_TYPE),
    ENUMLoObjType(LO_PALETTE_TYPE),
    ENUMLoObjType(LO_FONT_TYPE),
    ENUMLoObjType(LO_REGION_TYPE),
    ENUMLoObjType(LO_ICMLCS_TYPE),
    ENUMLoObjType(LO_CLIENTOBJ_TYPE),

    ENUMLoObjType(LO_ALTDC_TYPE),
    ENUMLoObjType(LO_PEN_TYPE),
    ENUMLoObjType(LO_EXTPEN_TYPE),
    ENUMLoObjType(LO_DIBSECTION_TYPE),
    ENUMLoObjType(LO_METAFILE16_TYPE),
    ENUMLoObjType(LO_METAFILE_TYPE),
    ENUMLoObjType(LO_METADC16_TYPE),
} GDILoObjType;


// fl values for CreateDIBitmapInternal

#define CDBI_INTERNAL           0x0001
#define CDBI_DIBSECTION         0x0002
#define CDBI_NOPALETTE          0x0004


// The UFI allows us to identify four different items:
//
// Device Fonts: CheckSum = 0 and Index identifies the printer driver index of font to
//               use.  Since we assume drivers are identical on both machines we can
//               rely on Index being enough to identify the font.
//
// Type1 Device Fonts: This refers to a Type1 font that has been installed on
//                     the client machine and is enumerated by the postcript driver
//                     as a device font.  In this case CheckSum = 1 and Index
//                     is the checksum of the Type 1 font file.
//
// Type1 Rasterizer: This item identifies not a font, but a Type1 rasterizer.
//                   Here CheckSum = 2 and Index is the version number of the
//                   Type1 rasterizer.  A rasterizer with version number N supports
//                   fonts used by a rasterizers with versions 0-N.  If a rasterizer
//                   exists on a server, this UFI MUST appear FIRST in the list of
//                   UFI's returned to the client.
//
// Engine Font: This includes bitmap, vector, TT, and Type1 fonts rasterized by
//              a Type1 rasterizer.  Here CheckSum is a checksum of the font file
//              and Index is the index of the face in the font file.

#define DEVICE_FONT_TYPE             0
#define TYPE1_FONT_TYPE              1
#define TYPE1_RASTERIZER             2
#define A_VALID_ENGINE_CHECKSUM      3

#define UFI_DEVICE_FONT(pufi) ((pufi)->CheckSum == DEVICE_FONT_TYPE)
#define UFI_TYPE1_FONT(pufi) ((pufi)->CheckSum == TYPE1_FONT_TYPE)
#define UFI_TYPE1_RASTERIZER(pufi) ((pufi)->CheckSum == TYPE1_RASTERIZER)
#define UFI_ENGINE_FONT(pufi) ((pufi)->CheckSum > TYPE1_RASTERIZER)

#define UFI_HASH_VALUE(pufi) (((pufi)->CheckSum==TYPE1_FONT_TYPE) ?                   \
                              (pufi)->Index : (pufi)->CheckSum )

#define UFI_SAME_FACE(pufi1,pufi2)                                                    \
    (((pufi1)->CheckSum == (pufi2)->CheckSum) && ((pufi1)->Index == (pufi2)->Index))

#define UFI_SAME_FILE(pufi1,pufi2) ((((pufi1)->CheckSum==TYPE1_FONT_TYPE)  && ((pufi2)->CheckSum==TYPE1_FONT_TYPE)) ?  \
                                    ((pufi1)->Index == (pufi2)->Index)  :             \
                                    ((pufi1)->CheckSum == (pufi2)->CheckSum))

#define UFI_SAME_RASTERIZER_VERSION(pufiClient,pufiServer)                            \
    (((pufiClient)->CheckSum == (pufiServer)->CheckSum) &&                            \
     ((pufiClient)->Index <= (pufiServer)->Index))

#define UFI_CLEAR_ID(pufi) {(pufi)->CheckSum = (pufi)->Index = 0;}


/*


/**************************************************************************\
 *
 *  // The pointer arithmetic for ENUMFONTDATAW is as follows:
 *
 *  sizeof(ENUMLOGFONTEXW)+sizeof(data appended to logfont) =
 *      dpNtmi - offsetof(ENUMFONTDATAW,u);
 *
 *  sizeof(NTMW_INTERNAL) + sizeof(data appended to NTMW_INTERNAL) =
 *      cjEfdw - dpNtmi;
 *
 *  // typically, if we are talking about mm font we will have:
 *
 *  data appended to logfont       = design vector
 *  data appended to NTMW_INTERNAL = full axes information
 *
\**************************************************************************/

#if (_WIN32_WINNT >= 0x0500)
typedef struct _ENUMFONTDATAW {  // efdw
    ULONG              cjEfdw;   // size of this structure
    ULONG              dpNtmi;   // offset to NTMW_INTERNAL from the top of efdw
    FLONG              flType;
    ENUMLOGFONTEXDVW   elfexw;
// here follows NTMW_INTERNAL at the offset of dpNtmi
} ENUMFONTDATAW, *PENUMFONTDATAW;
#endif

#define ALIGN4(X) (((X) + 3) & ~3)
#define ALIGN8(X) (((X) + 7) & ~7)

// here we define dpNtmi and cjEfdw for "regular", non multiple master fonts:

#if (_WIN32_WINNT >= 0x0500)
#define DP_NTMI0 ALIGN4(offsetof(ENUMFONTDATAW,elfexw) + offsetof(ENUMLOGFONTEXDVW,elfDesignVector) + offsetof(DESIGNVECTOR,dvValues))
#endif
#define CJ_NTMI0 ALIGN4(offsetof(NTMW_INTERNAL,entmw)  + offsetof(ENUMTEXTMETRICW,etmAxesList) + offsetof(AXESLISTW,axlAxisInfo))
#define CJ_EFDW0 (DP_NTMI0 + CJ_NTMI0)


// ENUMFONTDATAW.flType internal values:
//
// ENUMFONT_SCALE_HACK          [Win95 compat] Enumerate font back in several
//                              sizes; mask out before doing callback to app.

#define ENUMFONT_SCALE_HACK  0x80000000
#define ENUMFONT_FLTYPE_MASK ( DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE )

// GreGetTextExtentW flags

#define GGTE_WIN3_EXTENT        0x0001
#define GGTE_GLYPH_INDEX        0x0002

/******************************************************************************
 * stuff for client side text extents and charwidths
 ******************************************************************************/

#define GCW_WIN3          0x00000001    // win3 bold simulation off-by-1 hack
#define GCW_INT           0x00000002    // integer or float
#define GCW_16BIT         0x00000004    // 16-bit or 32-bit widths
#define GCW_GLYPH_INDEX   0x00000008    // input are glyph indices

// stuff for GetCharABCWidths

#define GCABCW_INT            0x00000001
#define GCABCW_GLYPH_INDEX    0x00000002

// stuff for GetTextExtentEx

#define GTEEX_GLYPH_INDEX        0x0001


/**************************************************************************\
 *
 * stuff from csgdi.h
 *
\**************************************************************************/

#define CJSCAN(width,planes,bits) ((((width)*(planes)*(bits)+31) & ~31) / 8)
#define CJSCANW(width,planes,bits) ((((width)*(planes)*(bits)+15) & ~15) / 8)

#define I_ANIMATEPALETTE            0
#define I_SETPALETTEENTRIES         1
#define I_GETPALETTEENTRIES         2
#define I_GETSYSTEMPALETTEENTRIES   3
#define I_GETDIBCOLORTABLE          4
#define I_SETDIBCOLORTABLE          5

#define I_POLYPOLYGON   1
#define I_POLYPOLYLINE  2
#define I_POLYBEZIER    3
#define I_POLYLINETO    4
#define I_POLYBEZIERTO  5
#define I_POLYPOLYRGN   6


HANDLE WINAPI SetObjectOwner(HGDIOBJ, HANDLE);

// BUGBUG
// RANDOM floating point stuff - try to cleanup later.
// BUGBUG
// We littered modules with __CPLUSPLUS to not conflict with efloat.hxx
// efloat.hxx should more or less disappear.
//

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)

  typedef FLOAT EFLOAT_S;

  #define EFLOAT_0        ((FLOAT) 0)
  #define EFLOAT_1Over16  ((FLOAT) 1/16)
  #define EFLOAT_1        ((FLOAT) 1)
  #define EFLOAT_16       ((FLOAT) 16)

  #ifndef __CPLUSPLUS

    extern LONG lCvtWithRound( FLOAT f, LONG l );

    #define efDivEFLOAT(x,y,z) (x=y/z)
    #define vAbsEFLOAT(x)      {if (x<0.0f) x=-x;}
    #define vFxToEf(fx,ef)     {ef = ((FLOAT) fx) / 16.0f;}
    #define vMulEFLOAT(x,y,z)  {x=y*z;}
    #define lEfToF(x)          (*(LONG *)(&x))  // Warning: FLOAT typed as LONG!

    #define bIsOneEFLOAT(x)   (x==1.0f)
    #define bIsOneSixteenthEFLOAT(x)   (x==0.0625f)
    #define bEqualEFLOAT(x,y) (x==y)

    #define lCvt(ef,ll) (lCvtWithRound(ef,ll))
  #endif

#else

  typedef struct _EFLOAT_S
  {
      LONG    lMant;
      LONG    lExp;
  } EFLOAT_S;

  #define EFLOAT_0        {0, 0}
  #define EFLOAT_1Over16  {0x040000000, -2}
  #define EFLOAT_1        {0x040000000, 2}
  #define EFLOAT_16       {0x040000000, 6}


  #ifndef __CPLUSPLUS

    EFLOAT_S *mulff3_c(EFLOAT_S *,const EFLOAT_S *,const EFLOAT_S *);
    EFLOAT_S *divff3_c(EFLOAT_S *,const EFLOAT_S *,const EFLOAT_S *);
    VOID      fxtoef_c(LONG,EFLOAT_S *);
    LONG      eftof_c(EFLOAT_S *);

    #define efDivEFLOAT(x,y,z) (*divff3_c(&x,&y,&z))
    #define vAbsEFLOAT(x)      {if (x.lMant<0) x.lMant=-x.lMant;}
    #define vFxToEf(fx,ef)     (fxtoef_c(fx,&ef))
    #define vMulEFLOAT(x,y,z)  {mulff3_c(&x,&y,&z);}
    #define lEfToF(x)          (eftof_c(&x))  // Warning: FLOAT typed as LONG!

    #define bEqualEFLOAT(x,y) ((x.lMant==y.lMant)&&(x.lExp==y.lExp))
    #define bIsOneEFLOAT(x)   ((x.lMant==0x40000000L)&&(x.lExp==2))
    #define bIsOneSixteenthEFLOAT(x)   ((x.lMant==0x40000000L)&&(x.lExp==-2))

    LONG lCvt(EFLOAT_S,LONG);
  #endif

#endif





typedef struct _WIDTHDATA
{
    USHORT      sOverhang;
    USHORT      sHeight;
    USHORT      sCharInc;
    USHORT      sBreak;
    BYTE        iFirst;
    BYTE        iLast;
    BYTE        iBreak;
    BYTE        iDefault;
    USHORT      sDBCSInc;
    USHORT      sDefaultInc;
} WIDTHDATA;

#define NO_WIDTH 0xFFFF

typedef struct _DEVCAPS
{
    ULONG ulVersion;
    ULONG ulTechnology;
    ULONG ulHorzSizeM;
    ULONG ulVertSizeM;
    ULONG ulHorzSize;
    ULONG ulVertSize;
    ULONG ulHorzRes;
    ULONG ulVertRes;
    ULONG ulBitsPixel;
    ULONG ulPlanes;
    ULONG ulNumPens;
    ULONG ulNumFonts;
    ULONG ulNumColors;
    ULONG ulRasterCaps;
    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulAspectXY;
    ULONG ulLogPixelsX;
    ULONG ulLogPixelsY;
    ULONG ulSizePalette;
    ULONG ulColorRes;
    ULONG ulPhysicalWidth;
    ULONG ulPhysicalHeight;
    ULONG ulPhysicalOffsetX;
    ULONG ulPhysicalOffsetY;
    ULONG ulTextCaps;
    ULONG ulVRefresh;
    ULONG ulDesktopHorzRes;
    ULONG ulDesktopVertRes;
    ULONG ulBltAlignment;
    ULONG ulPanningHorzRes;
    ULONG ulPanningVertRes;
    ULONG xPanningAlignment;
    ULONG yPanningAlignment;
    ULONG ulShadeBlendCaps;
    ULONG ulColorManagementCaps;
} DEVCAPS, *PDEVCAPS;

// This structure is a copy from d3dhal.h. We need it here to have exactly
// the same offset for pvBuffer in D3DNTHAL_CONTEXTCREATEI
typedef struct _D3DHAL_CONTEXTCREATEDATA_DUMMY
{
    LPVOID  lpDDGbl;
    LPVOID  lpDDS;
    LPVOID  lpDDSZ;
    LPVOID  dwrstates;
    LPVOID  dwhContext;
    HRESULT ddrval;     
} D3DHAL_CONTEXTCREATEDATA_DUMMY;

// For D3D context creation information.
typedef struct _D3DNTHAL_CONTEXTCREATEI
{
    // Space for a D3DNTHAL_CONTEXTCREATE record.
    // The structure isn't directly declared here to
    // avoid header inclusion problems.  This field
    // is asserted to be the same size as the actual type.
    D3DHAL_CONTEXTCREATEDATA_DUMMY ContextCreateData;

    // Private buffer information.
    PVOID pvBuffer;
    ULONG cjBuffer;
} D3DNTHAL_CONTEXTCREATEI;

//
// D3D execute buffer batching declarations.
//

#define D3DEX_BATCH_SURFACE_MAX 4

typedef struct _D3DEX_BATCH_HEADER
{
    DWORD nSurfaces;
    DWORD pdds[D3DEX_BATCH_SURFACE_MAX];
} D3DEX_BATCH_HEADER;

#define D3DEX_BATCH_STATE          0
#define D3DEX_BATCH_PRIMITIVE      1
#define D3DEX_BATCH_PRIMITIVE_EXE  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\profmapp.h ===
//=============================================================================
//  profmapp.h  -   Header file for user remap API.
//
//  Copyright (c) Microsoft Corporation 1995-1999
//  All rights reserved
//
//=============================================================================

//=============================================================================
//
// RemapUserProfile
//
// Changes the security of a user profile from one user to another.
//
// pComputer    - Specifies the computer to run the API on
// dwFlags      - Specifies zero or more REMAP_PROFILE_* flags
// pCurrentSid  - Specifies the existing user's SID
// pNewSid      - Specifies the new SID for the profile
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#define REMAP_PROFILE_NOOVERWRITE           0x0001
#define REMAP_PROFILE_NOUSERNAMECHANGE      0x0002
#define REMAP_PROFILE_KEEPLOCALACCOUNT      0x0004

USERENVAPI
BOOL
WINAPI
RemapUserProfileA(
    LPCSTR pComputer,
    DWORD dwFlags,
    PSID pSidCurrent,
    PSID pSidNew
    );
USERENVAPI
BOOL
WINAPI
RemapUserProfileW(
    LPCWSTR pComputer,
    DWORD dwFlags,
    PSID pSidCurrent,
    PSID pSidNew
    );
#ifdef UNICODE
#define RemapUserProfile  RemapUserProfileW
#else
#define RemapUserProfile  RemapUserProfileA
#endif // !UNICODE

BOOL
WINAPI
InitializeProfileMappingApi (
    VOID
    );


//=============================================================================
//
// RemapAndMoveUser
//
// Transfers security settings and the user profile for one user to
// another.
//
// pComputer    - Specifies the computer to run the API on
// dwFlags      - Specifies zero or mor REMAP_PROFILE_* flags
// pCurrentUser - Specifies the existing user's SID
// pNewUser     - Specifies the new SID for the profile
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
RemapAndMoveUserA(
    LPCSTR pComputer,
    DWORD dwFlags,
    LPCSTR pCurrentUser,
    LPCSTR pNewUser
    );
USERENVAPI
BOOL
WINAPI
RemapAndMoveUserW(
    LPCWSTR pComputer,
    DWORD dwFlags,
    LPCWSTR pCurrentUser,
    LPCWSTR pNewUser
    );
#ifdef UNICODE
#define RemapAndMoveUser  RemapAndMoveUserW
#else
#define RemapAndMoveUser  RemapAndMoveUserA
#endif // !UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\pbt.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pbt.h

Abstract:

    Definitions for the Virtual Power Management Device.

Revision History:

    DATE        REV DESCRIPTION
    ----------- --- ----------------------------------------
    15 Jan 1994 TCS Original implementation.

--*/

#ifndef _INC_PBT
#define _INC_PBT


#define WM_POWERBROADCAST               0x0218

#ifndef _WIN32_WCE
#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B
#define PBT_APMRESUMEAUTOMATIC          0x0012
#endif
#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\setup_netdde.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    setup_netdde.c

Abstract:

    This is used by syssetup to enable netdde.  It's generated from various files under
    windows\netdde.  Do not edit by hand.

Revision History:

--*/

#ifndef H__shrtrust
#define H__shrtrust

/*
    NetDDE will fill in the following structure and pass it to NetDDE
    Agent whenever it wants to have an app started in the user's
    context.  The reason for the sharename and modifyId is to that
    a user must explicitly permit NetDDE to start an app on behalf of
    other users.
 */

#define NDDEAGT_CMD_REV         1
#define NDDEAGT_CMD_MAGIC       0xDDE1DDE1

/*      commands        */
#define NDDEAGT_CMD_WINEXEC     0x1
#define NDDEAGT_CMD_WININIT     0x2

/*      return status   */
#define NDDEAGT_START_NO        0x0

#define NDDEAGT_INIT_NO         0x0
#define NDDEAGT_INIT_OK         0x1

typedef struct {
    DWORD       dwMagic;        // must be NDDEAGT_CMD_MAGIC
    DWORD       dwRev;          // must be 1
    DWORD       dwCmd;          // one of above NDDEAGT_CMD_*
    DWORD       qwModifyId[2];  // modify Id of the share
    UINT        fuCmdShow;      // fuCmdShow to use with WinExec()
    char        szData[1];      // sharename\0 cmdline\0
} NDDEAGTCMD;
typedef NDDEAGTCMD *PNDDEAGTCMD;

#define DDE_SHARE_KEY_MAX           512
#define TRUSTED_SHARES_KEY_MAX      512
#define TRUSTED_SHARES_KEY_SIZE     15
#define KEY_MODIFY_ID_SIZE          8

#define DDE_SHARES_KEY_A                "SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_A            "SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_A    "DEFAULT\\"##TRUSTED_SHARES_KEY_A
#define TRUSTED_SHARES_KEY_PREFIX_A     "DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_A    "DDEDBi12345678"
#define KEY_MODIFY_ID_A                 "SerialNumber"
#define KEY_DB_INSTANCE_A               "ShareDBInstance"
#define KEY_CMDSHOW_A                   "CmdShow"
#define KEY_START_APP_A                 "StartApp"
#define KEY_INIT_ALLOWED_A              "InitAllowed"

#define DDE_SHARES_KEY_W                L"SOFTWARE\\Microsoft\\NetDDE\\DDE Shares"
#define TRUSTED_SHARES_KEY_W            L"SOFTWARE\\Microsoft\\NetDDE\\DDE Trusted Shares"
#define DEFAULT_TRUSTED_SHARES_KEY_W    L"DEFAULT\\"##TRUSTED_SHARES_KEY_A
#define TRUSTED_SHARES_KEY_PREFIX_W     L"DDEDBi"
#define TRUSTED_SHARES_KEY_DEFAULT_W    L"DDEDBi12345678"
#define KEY_MODIFY_ID_W                 L"SerialNumber"
#define KEY_DB_INSTANCE_W               L"ShareDBInstance"
#define KEY_CMDSHOW_W                   L"CmdShow"
#define KEY_START_APP_W                 L"StartApp"
#define KEY_INIT_ALLOWED_W              L"InitAllowed"

#define DDE_SHARES_KEY                  TEXT(DDE_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY              TEXT(TRUSTED_SHARES_KEY_A)
#define DEFAULT_TRUSTED_SHARES_KEY      TEXT(DEFAULT_TRUSTED_SHARES_KEY_A)
#define TRUSTED_SHARES_KEY_PREFIX       TEXT(TRUSTED_SHARES_KEY_PREFIX_A)
#define TRUSTED_SHARES_KEY_DEFAULT      TEXT(TRUSTED_SHARES_KEY_DEFAULT_A)
#define KEY_MODIFY_ID                   TEXT(KEY_MODIFY_ID_A)
#define KEY_DB_INSTANCE                 TEXT(KEY_DB_INSTANCE_A)
#define KEY_CMDSHOW                     TEXT(KEY_CMDSHOW_A)
#define KEY_START_APP                   TEXT(KEY_START_APP_A)
#define KEY_INIT_ALLOWED                TEXT(KEY_INIT_ALLOWED_A)

#endif

#if DBG
#define KdPrint(_x_) DbgPrint _x_
#else
#define KdPrint(_x_)
#endif

ULONG DbgPrint(PCH Format, ...);

BOOL GetDBSerialNumber(DWORD *lpdwId);
BOOL GetDBInstance(char *lpszBuf);

TCHAR    szShareKey[] = DDE_SHARES_KEY;
CHAR    szSetup[] = "NetDDE Setup";

#define	SHARES_TO_INIT 3

CHAR *szShareNames[SHARES_TO_INIT] = {
    "Chat$"     ,
    "Hearts$"   ,
    "CLPBK$"
};

BOOL
CreateShareDBInstance()
{
    HKEY            hKey;
    LONG            lRtn;
    BOOL            bOK = TRUE;
    DWORD           InstanceId;
    time_t          time_tmp;

    /*  Create the DDE Share database in the registry if it does not exist. */
    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		  szShareKey,
		  0,
		  KEY_SET_VALUE,
		  &hKey );

    if( lRtn == ERROR_SUCCESS ) {
        /*
         * create data base instance value
         */
        srand((int) time(&time_tmp));
        InstanceId = rand() * rand();
        lRtn = RegSetValueEx( hKey,
            KEY_DB_INSTANCE, 0,
            REG_DWORD,
            (LPBYTE)&InstanceId,
            sizeof( DWORD ) );
        if( lRtn == ERROR_SUCCESS ) {
        } else {
            KdPrint(("SETUPDLL: CreateShareDBInstnace: RegSetValueEx %x failed (%u)\n",InstanceId,lRtn));
            bOK = FALSE;
        }
        RegCloseKey( hKey );
    } else {
    /* Share DB key should have been created from default hives */
        KdPrint(("SETUPDLL: CreateShareDBInstnace: RegOpenKey %s failed (%u)\n",szShareKey,lRtn));
        bOK = FALSE;
    }
    return(bOK);
}

BOOL
CreateDefaultTrust(
HKEY hKeyUserRoot)
{
    HKEY    hKey;
    DWORD   dwDisp;
    DWORD   ret;
    BOOL    bOK;
    char    szTrustedShareKey[TRUSTED_SHARES_KEY_MAX];
    char    szShareKey[DDE_SHARE_KEY_MAX];
    char    szDBInstance[TRUSTED_SHARES_KEY_SIZE + 1];
    DWORD   dwId[2];
    DWORD   dwFlag;
    int	    nLoop;


    if (!GetDBInstance(szDBInstance)) {
        return(FALSE);
    }

    if (!GetDBSerialNumber(dwId)) {
        KdPrint(("SETUPDLL: CreateDefaultTrust: GetDBSerialNumber failed.\n"));
        return(FALSE);
    }

    for (nLoop = 0, bOK = TRUE;
        (nLoop < SHARES_TO_INIT) && bOK ;
            nLoop++) {
        /*
         * For each share to init...
         */

        KdPrint(("Shareing %s\n", szShareNames[nLoop]));

        /*
         * Build up szTrustedSharesKey IAW the DBInstance sring.
         */
        sprintf( szTrustedShareKey,
                "%s\\%s\\%s",
                TRUSTED_SHARES_KEY_A,
                szDBInstance,
                szShareNames[nLoop] );

        /*
         * Create the trusted share key (hKey)
         */
        ret = RegCreateKeyExA( hKeyUserRoot, szTrustedShareKey,
        		0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
        		NULL,
        		&hKey,
        		&dwDisp );

        if( ret != ERROR_SUCCESS )  {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegCreateKeyEx failed on HKEY_CURRENT_USER\\%s. (%u)\n",
                    szTrustedShareKey, ret));
            return(FALSE);
        }

        /*
         * Get the serial number of the database.  Note that the SN of each
         * trust share must == the SN of the database.  Since the non-trusted
         * shares may not have the latest database SN, update all of them to
         * the current database SN as well.  This allows apps like winchat to
         * work when they are called from outside the machine even though they
         * have never been run - which would fix the SNs of their trusts because
         * they automatically set up their trusts.
         */

        /*
         * Set the SN of the trusted share
         */
        ret = RegSetValueEx( hKey,
		       KEY_MODIFY_ID,
		       0,
		       REG_BINARY,
		       (LPBYTE)&dwId,
		       KEY_MODIFY_ID_SIZE );

        if (ret == ERROR_SUCCESS) {
            /*
             * set the StartApp flag to 1
             */
            dwFlag = 1;
            ret = RegSetValueEx( hKey,
                KEY_START_APP,
                0,
                REG_DWORD,
                (LPBYTE)&dwFlag,
                sizeof( DWORD ) );

            if (ret == ERROR_SUCCESS) {
                /*
                 * Set the InitAllowed flag to 1 too.
                 */
   	            ret = RegSetValueEx( hKey,
                    KEY_INIT_ALLOWED,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwFlag,
                    sizeof( DWORD ) );
            }
	    }

        RegCloseKey(hKey);

		if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx failed (%u)\n",ret));
            return(FALSE);
        }

        /*
         * Build up szShareKey
         */
        sprintf( szShareKey,
            "%s\\%s",
            DDE_SHARES_KEY_A,
            szShareNames[nLoop] );

        /*
         * Now open up the base share
         */
        ret = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                szShareKey,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
        		&hKey);

		if (ret != ERROR_SUCCESS) {
            KdPrint(("SETUPDLL: CreateDefaultTrust: RegOpenKeyEx failed on HKEY_LOCAL_MACHINE\\%s. (%u)\n",
                    szShareKey, ret));
            if (ret != ERROR_ACCESS_DENIED) {
                return(FALSE);
            }
        }

        if (ret == ERROR_SUCCESS) {
            ret = RegSetValueEx( hKey,
    		       KEY_MODIFY_ID,
    		       0,
    		       REG_BINARY,
    		       (LPBYTE)&dwId,
    		       KEY_MODIFY_ID_SIZE );

            RegCloseKey(hKey);

    		if (ret != ERROR_SUCCESS) {
                KdPrint(("SETUPDLL: CreateDefaultTrust: RegSetValueEx on HKEY_LOCAL_MACHINE\\%s failed (%u)\n",
                        KEY_MODIFY_ID, ret));
                return(FALSE);
            }
        }

    } // end for

    return(TRUE);
}



BOOL
GetDBInstance(char *lpszBuf)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwInstance;
    DWORD   dwType = REG_DWORD;
    DWORD   cbData = sizeof(DWORD);

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegOpenKeyEx %s failed (%u)\n",szShareKey,lRtn));
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_DB_INSTANCE,
                NULL,
                &dwType,
                (LPBYTE)&dwInstance, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        KdPrint(("SETUPDLL: GetDBInstance: RegQueryValueEx failed (%u)\n",lRtn));
        return(FALSE);
    }
    sprintf(lpszBuf, "%s%08X", TRUSTED_SHARES_KEY_PREFIX, dwInstance);
    return(TRUE);
}

BOOL
GetDBSerialNumber(
DWORD *lpdwId)
{
    LONG    lRtn;
    HKEY    hKey;
    DWORD   dwType = REG_BINARY;
    DWORD   cbData = KEY_MODIFY_ID_SIZE;

    lRtn = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                szShareKey,
                0,
                KEY_QUERY_VALUE,
                &hKey );
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    lRtn = RegQueryValueEx( hKey,
                KEY_MODIFY_ID,
                NULL,
                &dwType,
                (LPBYTE)lpdwId, &cbData );
    RegCloseKey(hKey);
    if (lRtn != ERROR_SUCCESS) {        /* unable to open DB key */
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimcstring.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    CString.h

 Abstract:
    A CString class, pure UNICODE internally.

 History:

    02/22/2001   robkenny     Ported from MFC
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.
    
--*/


#pragma once

#include <limits.h>


namespace ShimLib
{

// Use the standard exception handler, if this is not defined
// the C++ exception handler will be used instead.
//#define USE_SEH

#define AFXAPI              __stdcall
#define AFXISAPI            __stdcall
#define AFXISAPI_CDECL      __cdecl
#define AFX_CDECL           __cdecl
#define AFX_INLINE          __inline
#define AFX_CORE_DATA
#define AFX_DATA
#define AFX_DATADEF
#define AFX_API
#define AFX_COMDAT
#define AFX_STATIC          static

BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength = -1);
BOOL AFXAPI AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE);

inline size_t strlenChars(const char* s1)                                
{
    const char * send = s1;
    while (*send)
    {
        // Can't use CharNextA, since User32 might not be initialized
        if (IsDBCSLeadByte(*send))
        {
            ++send;
        }
        ++send;
    }
    return send - s1;
}

// Prototype for a string comparison routine.
typedef WCHAR *  (__cdecl *_pfn_wcsstr)(const WCHAR * s1, const WCHAR * s2);

template <class CharType> class CStringData
{
public:
    long nRefs;             // reference count
    int nDataLength;        // length of data (including terminator)
    int nAllocLength;       // length of allocation
    // CharType data[nAllocLength]

    CharType* data()           // CharType* to managed data
        { return (CharType*)(this+1); }
};


class CString
{
public:
#ifdef USE_SEH
    // SEH Exception information
    enum
    {
        eCStringNoMemoryException   = STATUS_NO_MEMORY,
        eCStringExceptionValue      = 0x12345678,
    };
    static int              ExceptionFilter(PEXCEPTION_POINTERS pexi);
    static const ULONG_PTR  m_CStringExceptionValue;

#else

    // A class used only for throwing C++ exceptions
    class CStringError
    {
    public:
        CStringError() {};
        ~CStringError() {};
    };
#endif

public:
    static WCHAR ChNil;

public:
// Constructors

    // constructs empty CString
    CString();
    // copy constructor
    CString(const CString & stringSrc);
    // from a single character
    CString(WCHAR ch, int nRepeat = 1);
    // allocate nLen WCHARs space.
    CString(int nLength);
    CString(const WCHAR * lpsz);
    // subset of characters from an ANSI string (converts to WCHAR)
    CString(const WCHAR * lpch, int nLength);

    // Create from an ANSI string
    CString(LPCSTR lpsz);
    CString(LPCSTR lpsz, int nCharacters);


// Attributes & Operations

    // get data length, number of characters
    int GetLength() const;
    // TRUE if zero length
    BOOL IsEmpty() const;
    // clear contents to empty
    void Empty();

    // return pointer to const string
    operator const WCHAR * () const;
    const WCHAR * Get() const;
    // Get, return NULL if string is empty
    const WCHAR * GetNIE() const;
    char * GetAnsi() const;
    // Get ANSI string: caller is responsible for freeing the string
    char * ReleaseAnsi() const;
    // Get, return NULL if string is empty
    char * GetAnsiNIE() const;

    // return single character at zero-based index
    WCHAR GetAt(int nIndex) const;
    // return single character at zero-based index
    WCHAR operator[](int nIndex) const;
    // set a single character at zero-based index
    void SetAt(int nIndex, WCHAR ch);

    // overloaded assignment

    // copy string content from UNICODE string
    const CString & operator=(const WCHAR * lpsz);
    // ref-counted copy from another CString
    const CString & operator=(const CString & stringSrc);
    // set string content to single character
    const CString & operator=(WCHAR ch);
    // copy string content from unsigned chars
    //const CString & operator=(const unsigned WCHAR* psz);

    const CString& CString::operator=(LPCSTR lpsz);

    // string concatenation

    // concatenate from another CString
    const CString & operator+=(const CString & string);

    // concatenate a single character
    const CString & operator+=(WCHAR ch);
    // concatenate a string
    const CString & operator+=(const WCHAR * lpsz);

    friend CString AFXAPI operator+(const CString & string1, const CString & string2);
    friend CString AFXAPI operator+(const CString & string, WCHAR ch);
    friend CString AFXAPI operator+(WCHAR ch, const CString & string);
    friend CString AFXAPI operator+(const CString & string, const WCHAR * lpsz);
    friend CString AFXAPI operator+(const WCHAR * lpsz, const CString & string);

    // string comparison

    // straight character comparison
    int Compare(const WCHAR * lpsz) const;
    // compare ignoring case
    int CompareNoCase(const WCHAR * lpsz) const;
    // NLS aware comparison, case sensitive
    int Collate(const WCHAR * lpsz) const;
    // NLS aware comparison, case insensitive
    int CollateNoCase(const WCHAR * lpsz) const;

    int ComparePart(const WCHAR * lpsz, int start, int nChars) const;
    int ComparePartNoCase(const WCHAR * lpsz, int start, int nChars) const;

    // simple sub-string extraction

    // return nCount characters starting at zero-based nFirst
    CString Mid(int nFirst, int nCount) const;
    // return all characters starting at zero-based nFirst
    CString Mid(int nFirst) const;
    // return first nCount characters in string
    CString Left(int nCount) const;
    // return nCount characters from end of string
    CString Right(int nCount) const;

    //  characters from beginning that are also in passed string
    CString SpanIncluding(const WCHAR * lpszCharSet) const;
    // characters from beginning that are not also in passed string
    CString SpanExcluding(const WCHAR * lpszCharSet) const;


    // upper/lower/reverse conversion

    // NLS aware conversion to uppercase
    void MakeUpper();
    // NLS aware conversion to lowercase
    void MakeLower();
    // reverse string right-to-left
    void MakeReverse();

    // trimming whitespace (either side)

    // remove whitespace starting from right edge
    void TrimRight();
    // remove whitespace starting from left side
    void TrimLeft();

    // trimming anything (either side)

    // remove continuous occurrences of chTarget starting from right
    void TrimRight(WCHAR chTarget);
    // remove continuous occcurrences of characters in passed string,
    // starting from right
    void TrimRight(const WCHAR * lpszTargets);
    // remove continuous occurrences of chTarget starting from left
    void TrimLeft(WCHAR chTarget);
    // remove continuous occcurrences of characters in
    // passed string, starting from left
    void TrimLeft(const WCHAR * lpszTargets);

    // advanced manipulation

    // replace occurrences of chOld with chNew
    int Replace(WCHAR chOld, WCHAR chNew);

    // replace occurrences of substring lpszOld with lpszNew;
    // empty lpszNew removes instances of lpszOld
    int Replace(const WCHAR * lpszOld, const WCHAR * lpszNew);
    // Case insensitive version of Replace
    int ReplaceI(const WCHAR * lpszOld, const WCHAR * lpszNew);

    // remove occurrences of chRemove
    int Remove(WCHAR chRemove);
    // insert character at zero-based index; concatenates
    // if index is past end of string
    int Insert(int nIndex, WCHAR ch);
    // insert substring at zero-based index; concatenates
    // if index is past end of string
    int Insert(int nIndex, const WCHAR * pstr);
    // delete nCount characters starting at zero-based index
    int Delete(int nIndex, int nCount = 1);
    // delete all characters to the right of nIndex
    void Truncate(int nIndex);

    // searching

    // find character starting at left, -1 if not found
    int Find(WCHAR ch) const;
    // find character starting at right
    int ReverseFind(WCHAR ch) const;
    // find character starting at zero-based index and going right
    int Find(WCHAR ch, int nStart) const;
    // find first instance of any character in passed string
    int FindOneOf(const WCHAR * lpszCharSet) const;
    // find first instance of any character in passed string starting at zero-based index
    int FindOneOf(const WCHAR * lpszCharSet, int nCount) const;
    // find first instance of substring
    int Find(const WCHAR * lpszSub) const;
    // find first instance of substring starting at zero-based index
    int Find(const WCHAR * lpszSub, int nStart) const;

    // find first instance of any character *not* in passed string starting at zero-based index
    int FindOneNotOf(const WCHAR * lpszCharSet, int nCount) const;

    // simple formatting

    // printf-like formatting using passed string
    void AFX_CDECL Format(const WCHAR * lpszFormat, ...);
    // printf-like formatting using referenced string resource
    //void AFX_CDECL Format(UINT nFormatID, ...);
    // printf-like formatting using variable arguments parameter
    void FormatV(const WCHAR * lpszFormat, va_list argList);

    // formatting for localization (uses FormatMessage API)

    // format using FormatMessage API on passed string
    void AFX_CDECL FormatMessage(const WCHAR * lpszFormat, ...);

    // input and output
#ifdef _DEBUG
    friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,
                const CString & string);
#endif
//  friend CArchive& AFXAPI operator<<(CArchive& ar, const CString & string);
//  friend CArchive& AFXAPI operator>>(CArchive& ar, CString & string);

//    friend const CString & AFXAPI AfxGetEmptyString();


    // Access to string implementation buffer as "C" character array

    // get pointer to modifiable buffer at least as long as nMinBufLength
    WCHAR * GetBuffer(int nMinBufLength);
    // release buffer, setting length to nNewLength (or to first nul if -1)
    void ReleaseBuffer(int nNewLength = -1);
    // get pointer to modifiable buffer exactly as long as nNewLength
    WCHAR * GetBufferSetLength(int nNewLength);
    // release memory allocated to but unused by string
    void FreeExtra();

    // Use LockBuffer/UnlockBuffer to turn refcounting off

    // turn refcounting back on
    WCHAR * LockBuffer();
    // turn refcounting off
    void UnlockBuffer();

    // Copy the ansi version of this string into the specified buffer,
    DWORD CopyAnsiBytes(char * lpszBuffer, DWORD nBytes);
    // Copy the ansi version of this string into the specified buffer,
    DWORD CopyAnsiChars(char * lpszBuffer, DWORD nChars);


    // ======================================================================
    // CString extensions: making life easier.
    //
    // Win32 API
    DWORD       GetModuleFileNameW(HMODULE hModule);
    DWORD       GetShortPathNameW(void);
    DWORD       GetLongPathNameW(void);
    DWORD       GetFullPathNameW(void);
    DWORD       GetSystemDirectoryW(void); 
    UINT        GetSystemWindowsDirectoryW(void); 
    DWORD       GetWindowsDirectoryW(void); 
    DWORD       GetTempPathW(void);
    UINT        GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique );
    DWORD       ExpandEnvironmentStringsW(void);
    DWORD       GetCurrentDirectoryW(void);


    // Split this into the seperate path components
    void SplitPath(CString * csDrive, CString * csDir, CString * csName, CString * csExt) const;
    void MakePath(const CString * csDrive, const CString * csDir, const CString * csName, const CString * csExt);
    // Properly append csPath onto the end of this path
    void AppendPath(const WCHAR * lpszPath);
    // Find the trailing path component
    // Return index of the last path seperator or -1 if none found
    int FindLastPathComponent() const;
    // Get the "file" portion of this path
    void GetLastPathComponent(CString & pathComponent) const;
    // Get what's not the "file" portion of this path
    void GetNotLastPathComponent(CString & pathComponent) const;
    // Remove the trailing path component
    void StripPath();
    // Get the drive portion either c:\ or \\machine\
    // Note this is different from SplitPath
    void GetDrivePortion(CString & csDrivePortion) const;

    // Does this string match the pattern
    BOOL PatternMatch(const WCHAR * lpszPattern) const;

    BOOL IsPathSep(int index) const;

    // More efficient versions of above
    void Mid(int nFirst, int nCount, CString & csMid) const;
    void Mid(int nFirst, CString & csMid) const;
    void Left(int nCount, CString & csLeft) const;
    void Right(int nCount, CString & csRight) const;
    void SpanIncluding(const WCHAR * lpszCharSet, CString & csSpanInc) const;
    void SpanExcluding(const WCHAR * lpszCharSet, CString & csSpanExc) const;

    //
    // ======================================================================

// Implementation
public:
    ~CString();
    int GetAllocLength() const;

protected:
    WCHAR * m_pchData;   // pointer to ref counted string data
    mutable char  * m_pchDataAnsi; // pointer to non-UNICODE version of string

    // implementation helpers
    CStringData<WCHAR> * GetData() const;
    void Init();
    void AllocCopy(CString & dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, const WCHAR * lpszSrcData);
    void ConcatCopy(int nSrc1Len, const WCHAR * lpszSrc1Data, int nSrc2Len, const WCHAR * lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, const WCHAR * lpszSrcData);
    void CopyBeforeWrite();
    void AllocBeforeWrite(int nLen);
    void Release();

    //============================================================

    // Used by Replace and ReplaceI
    int ReplaceRoutine(LPCWSTR lpszOld, LPCWSTR lpszNew, _pfn_wcsstr tcsstr);

    static void     Release(CStringData<WCHAR>* pData);
    static int      SafeStrlen(const WCHAR * lpsz);
    static void     FreeData(CStringData<WCHAR>* pData);

    static int                   _afxInitData[];
    static CStringData<WCHAR>*   _afxDataNil;
    static const WCHAR *         _afxPchNil;
};

/*
    End of class definitions.

    Below are routines that are candidates for inlining.

*/
#define afxEmptyString ((CString &)*(CString*)&CString::_afxPchNil)
inline BOOL    IsPathSep(WCHAR ch)
{ 
    return ch ==  L'\\' || ch ==  L'/'; 
}

// Compare helpers
AFX_INLINE bool AFXAPI operator==(const CString & s1, const CString & s2)       { return s1.Compare(s2) == 0; }
AFX_INLINE bool AFXAPI operator==(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) == 0; }
AFX_INLINE bool AFXAPI operator==(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) == 0; }
AFX_INLINE bool AFXAPI operator!=(const CString & s1, const CString & s2)       { return s1.Compare(s2) != 0; }
AFX_INLINE bool AFXAPI operator!=(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) != 0; }
AFX_INLINE bool AFXAPI operator!=(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) != 0; }
AFX_INLINE bool AFXAPI operator<(const CString & s1, const CString & s2)        { return s1.Compare(s2) < 0; }
AFX_INLINE bool AFXAPI operator<(const CString & s1, const WCHAR * s2)          { return s1.Compare(s2) < 0; }
AFX_INLINE bool AFXAPI operator<(const WCHAR * s1, const CString & s2)          { return s2.Compare(s1) > 0; }
AFX_INLINE bool AFXAPI operator>(const CString & s1, const CString & s2)        { return s1.Compare(s2) > 0; }
AFX_INLINE bool AFXAPI operator>(const CString & s1, const WCHAR * s2)          { return s1.Compare(s2) > 0; }
AFX_INLINE bool AFXAPI operator>(const WCHAR * s1, const CString & s2)          { return s2.Compare(s1) < 0; }
AFX_INLINE bool AFXAPI operator<=(const CString & s1, const CString & s2)       { return s1.Compare(s2) <= 0; }
AFX_INLINE bool AFXAPI operator<=(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) <= 0; }
AFX_INLINE bool AFXAPI operator<=(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) >= 0; }
AFX_INLINE bool AFXAPI operator>=(const CString & s1, const CString & s2)       { return s1.Compare(s2) >= 0; }
AFX_INLINE bool AFXAPI operator>=(const CString & s1, const WCHAR * s2)         { return s1.Compare(s2) >= 0; }
AFX_INLINE bool AFXAPI operator>=(const WCHAR * s1, const CString & s2)         { return s2.Compare(s1) <= 0; }

// CString
AFX_INLINE CStringData<WCHAR>* CString::GetData() const            { ASSERT(m_pchData != NULL, "CString::GetData: NULL m_pchData"); return ((CStringData<WCHAR>*)m_pchData)-1; }
AFX_INLINE void CString::Init()                                    { m_pchData = afxEmptyString.m_pchData; m_pchDataAnsi = NULL; }
AFX_INLINE CString::CString()                                      { Init(); }
//AFX_INLINE CString::CString(const unsigned WCHAR* lpsz)          { Init(); *this = (LPCSTR)lpsz; }
//AFX_INLINE const CString & CString::operator=(const unsigned WCHAR* lpsz) { *this = (LPCSTR)lpsz; return *this; }
AFX_INLINE int CString::GetLength() const                          { return GetData()->nDataLength; }
AFX_INLINE int CString::GetAllocLength() const                     { return GetData()->nAllocLength; }
AFX_INLINE BOOL CString::IsEmpty() const                           { return GetData()->nDataLength == 0; }
AFX_INLINE CString::operator const WCHAR *() const                 { return m_pchData; }
AFX_INLINE const WCHAR * CString::Get() const                      { return m_pchData; }
AFX_INLINE const WCHAR * CString::GetNIE() const                   { return IsEmpty() ? NULL : m_pchData; }
AFX_INLINE char  * CString::GetAnsiNIE() const                     { return IsEmpty() ? NULL : GetAnsi(); }
AFX_INLINE char  * CString::ReleaseAnsi() const                    { char * lpsz = GetAnsi(); m_pchDataAnsi = NULL; return lpsz; }
AFX_INLINE int CString::SafeStrlen(const WCHAR * lpsz)             { if ( lpsz == NULL ) return 0; else { SIZE_T ilen = wcslen(lpsz); if ( ilen <= INT_MAX ) return (int) ilen; return 0; } }
AFX_INLINE void CString::FreeData(CStringData<WCHAR>* pData)       { delete pData; }
AFX_INLINE int CString::Compare(const WCHAR * lpsz) const          { ASSERT(AfxIsValidString(lpsz), "CString::Compare: Invalid string"); return wcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
AFX_INLINE int CString::CompareNoCase(const WCHAR * lpsz) const    { ASSERT(AfxIsValidString(lpsz), "CString::CompareNoCase: Invalid string"); return _wcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
AFX_INLINE int CString::Collate(const WCHAR * lpsz) const          { ASSERT(AfxIsValidString(lpsz), "CString::Collate: Invalid string"); return wcscoll(m_pchData, lpsz); }   // locale sensitive
AFX_INLINE int CString::CollateNoCase(const WCHAR * lpsz) const    { ASSERT(AfxIsValidString(lpsz), "CString::CollateNoCase: Invalid string"); return _wcsicoll(m_pchData, lpsz); }   // locale sensitive
AFX_INLINE int CString::ComparePart(const WCHAR * lpsz, int start, int nChars) const    { ASSERT(AfxIsValidString(lpsz), "CString::CompareNoCase: Invalid string"); return wcsncmp(m_pchData+start, lpsz, nChars); }   // MBCS/Unicode aware
AFX_INLINE int CString::ComparePartNoCase(const WCHAR * lpsz, int start, int nChars) const    { ASSERT(AfxIsValidString(lpsz), "CString::CompareNoCase: Invalid string"); return _wcsnicmp(m_pchData+start, lpsz, nChars); }   // MBCS/Unicode aware


AFX_INLINE WCHAR CString::GetAt(int nIndex) const
{
    ASSERT(nIndex >= 0, "CString::GetAt: negative index");
    ASSERT(nIndex < GetData()->nDataLength, "CString::GetData: index larger than string");
    return m_pchData[nIndex];
}
AFX_INLINE WCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    ASSERT(nIndex >= 0, "CString::operator[]: negative index");
    ASSERT(nIndex < GetData()->nDataLength, "CString::GetData: index larger than string");
    return m_pchData[nIndex];
}

AFX_INLINE BOOL CString::IsPathSep(int index) const
{
    return ShimLib::IsPathSep(GetAt(index));
}


#undef afxEmptyString

// ************************************************************************************


// Exception filter for CString __try/__except blocks
// Return EXCEPTION_EXECUTE_HANDLER if this is a CString exception
// otherwise return EXCEPTION_CONTINUE_SEARCH
extern int CStringExceptionFilter(PEXCEPTION_POINTERS pexi);

#if defined(USE_SEH)
#define CSTRING_THROW_EXCEPTION       RaiseException((DWORD)CString::eCStringNoMemoryException, 0, 1, &CString::m_CStringExceptionValue); // Continuable, CString specific memory exception
#define CSTRING_TRY                 __try
#define CSTRING_CATCH               __except( CString::ExceptionFilter(GetExceptionInformation()) )
#else
// If we use the C++ exception handler, we need to make sure we have the /GX compile flag
#define CSTRING_THROW_EXCEPTION     throw CString::CStringError();
#define CSTRING_TRY                 try
#define CSTRING_CATCH               catch( CString::CStringError & cse )
#endif


};  // end of namespace ShimLib




// ************************************************************************************


namespace ShimLib
{

/*++

    Read a registry value into this CString.
    REG_EXPAND_SZ is automatically expanded and the type is changed to REG_SZ
    If the type is not REG_SZ or REG_EXPAND_SZ, then csRegValue.GetLength()
    is the number of *bytes* in the string.
    
    This is typically used to only read REG_SZ/REG_EXPAND_SZ registry values.
    
    Note: This API may only be called after SHIM_STATIC_DLLS_INITIALIZED
    
--*/

LONG RegQueryValueExW(
        CString & csValue,
        HKEY hKeyRoot,
        const WCHAR * lpszKey,
        const WCHAR * lpszValue,
        LPDWORD lpType);

/*++

    Get the ShSpecial folder name.
    
    Note: This API may only be called after SHIM_STATIC_DLLS_INITIALIZED
    
--*/

BOOL SHGetSpecialFolderPathW(
    CString & csFolder,
    int nFolder,
    HWND hwndOwner = NULL
);


// ************************************************************************************
/*++

    A tokenizer--a replacement for strtok.

    Init the class with the string and token delimiter.
    Call GetToken to peel off the next token.

++*/

class CStringToken
{
public:
    CStringToken(const CString & csToken, const CString & csDelimit);

    // Get the next token
    BOOL            GetToken(CString & csNextToken);

    // Count the number of remaining tokens.
    int             GetCount() const;

protected:
    int             m_nPos;
    CString         m_csToken;
    CString         m_csDelimit;

    BOOL            GetToken(CString & csNextToken, int & nPos) const;
};

// ************************************************************************************

/*++

    A simple class to assist in command line parsing

--*/

class CStringParser
{
public:
    CStringParser(const WCHAR * lpszCl, const WCHAR * lpszSeperators);
    ~CStringParser();

    int         GetCount() const;                   // Return the current number of args
    CString &   Get(int nIndex);
    CString &   operator[](int nIndex);

    // Give ownership of the CString array to the caller
    // Caller must call delete [] cstring
    CString *           ReleaseArgv();

protected:
    int                 m_ncsArgList;
    CString *           m_csArgList;

    void                SplitSeperator(const CString & csCl, const CString & csSeperator);
    void                SplitWhite(const CString & csCl);
};


inline int  CStringParser::GetCount() const
{
    return m_ncsArgList;
}

inline CString & CStringParser::Get(int nIndex)
{
    return m_csArgList[nIndex];
}

inline CString & CStringParser::operator[](int nIndex)
{
    return m_csArgList[nIndex];
}

inline CString * CStringParser::ReleaseArgv()
{
    CString * argv = m_csArgList;

    m_csArgList     = NULL;
    m_ncsArgList    = 0;

    return argv;
}



};  // end of namespace ShimLib


// ************************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimdb.h ===
/*--

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    shimdb.h

Abstract:

    header for the database file access functions used by the App Compat shimming system

Author:

    dmunsil 02/02/2000

Revision History:

Notes:

    This "database" is more of a tagged file, designed to mimic the structure of an XML
    file. An XML file can be converted into this packed data format easily, and all strings
    will by default be packed into a stringtable and referenced by a DWORD identifier, so files
    that contain a lot of common strings (like the XML used by the App Compat tema) will not
    bloat.

    To see the actual tags used by the shimdb, look in shimtags.h.

    For the high-level interface used by the loader in NTDLL, look at ntbaseapi.c

--*/

#ifndef _SHIMDB_H_
#define _SHIMDB_H_

/*++

    Supported configurations:

        UNICODE with NT apis
        ANSI    with WIN32 apis

    By default the library is UNICODE
    To use (and link) Win32 library


--*/

#ifdef SDB_ANSI_LIB

    #define LPCTSTR LPCSTR
    #define LPTSTR  LPSTR
    #define TCHAR   CHAR

#else

    #define LPCTSTR LPCWSTR
    #define LPTSTR  LPWSTR
    #define TCHAR   WCHAR

#endif

#define SDBAPI          STDAPICALLTYPE


typedef WORD            TAG;
typedef WORD            TAG_TYPE;

typedef DWORD           TAGID;
typedef DWORD           TAG_OFFSET;
typedef DWORD           STRINGREF;
typedef DWORD           INDEXID;

#define TAGID_NULL      0
#define STRINGREF_NULL  0
#define INDEXID_NULL    ((INDEXID)-1)
#define TAG_NULL        0

#define TAGID_ROOT      0 // implied root list tag that can be passed in as a parent

#define TAG_SIZE_UNFINISHED 0xFFFFFFFF

//
// define TAGREF so we can use tags accross databases
//
typedef DWORD           TAGREF;

///////////////////////////////////////////////////////////////////////////////
//
// TAG TYPES
//

//
// The most significant 4 bits tell you the basic type and size of data,
// and the lower 12 are the specific tag.
//
// In this way, even if we add more tags to the db, older readers can read
// the data because the type is either implied (for the first 5 types)
// or supplied (for all other types).
//
// WARNING: it is important that only the first 5 types have implied sizes.
// any future types should use a size or backwards compatibility will not be
// maintained.

//
// The following tags have an implied size.
//
#define TAG_TYPE_NULL           0x1000  // implied size 0
#define TAG_TYPE_BYTE           0x2000  // implied size 1
#define TAG_TYPE_WORD           0x3000  // implied size 2
#define TAG_TYPE_DWORD          0x4000  // implied size 4
#define TAG_TYPE_QWORD          0x5000  // implied size 8
#define TAG_TYPE_STRINGREF      0x6000  // implied size 4, for strings that should be tokenized

//
// These tags have a size after them (the size is type TAG_OFFSET)
//
#define TAG_TYPE_LIST           0x7000
#define TAG_TYPE_STRING         0x8000
#define TAG_TYPE_BINARY         0x9000


#define TAGREF_NULL 0
#define TAGREF_ROOT 0


//
// Special define for stripping out just the type from a tag.
//
#define TAG_STRIP_TYPE          0xF000

//
// This macro strips off the lower bits of the TAG and returns the upper bits, which
// give the basic type of tag. All the tag types are defined above.
//
// The type info is purely used internally by the DB to tell whether the tag has
// an implied size, or if the DB needs to do something special with the data before
// handing it back to the caller.
//

#define GETTAGTYPE(tag)         ((tag) & TAG_STRIP_TYPE)


typedef PVOID HSDB;


struct tagHOOKAPI;


typedef struct tagHOOKAPIEX {
    DWORD               dwShimID;
    struct tagHOOKAPI*  pTopOfChain;
    struct tagHOOKAPI*  pNext;

} HOOKAPIEX, *PHOOKAPIEX;

typedef struct tagHOOKAPI {

    char*   pszModule;                  // the name of the module
    char*   pszFunctionName;            // the name of the API in the module
    PVOID   pfnNew;                     // pointer to the new stub API
    PVOID   pfnOld;                     // pointer to the old API
    DWORD   dwFlags;                    // used internally - important info about status
    union {
        struct tagHOOKAPI* pNextHook;   // used internally - (obsolete -- old mechanism)
        PHOOKAPIEX pHookEx;             // used internally - pointer to an internal extended
                                        //                   info struct
    };
} HOOKAPI, *PHOOKAPI;

//
// OBSOLETE !
//
// If the hook DLL ever patches LoadLibraryA/W it must call PatchNewModules
// so that the shim knows to patch any new loaded DLLs
//
typedef VOID (*PFNPATCHNEWMODULES)(VOID);

typedef PHOOKAPI (*PFNGETHOOKAPIS)(LPSTR   pszCmdLine,
                                   LPWSTR  pwszShim,
                                   DWORD*  pdwHooksCount);

//
// These structures are part of the protocol between NTVDM and the shim engine
// for patching task "import tables"
//
typedef struct tagAPIDESC {

    char*   pszModule;
    char*   pszApi;

} APIDESC, *PAPIDESC;


typedef struct tagVDMTABLE {

    int         nApiCount;

    PVOID*      ppfnOrig;
    APIDESC*    pApiDesc;

} VDMTABLE, *PVDMTABLE;



//
// Shim engine notification events
//
#define SN_STATIC_DLLS_INITIALIZED      1
#define SN_PROCESS_DYING                2
#define SN_DLL_LOADING                  3

//
// This is the prototype for the notification function
// that the shim engine calls into the shim DLLs for various
// reasons (defined above).
//
typedef void (*PFNNOTIFYSHIMS)(int nReason, UINT_PTR extraInfo);


#define SHIM_COMMAND_LINE_MAX_BUFFER    1024

///////////////////////////////////////////////////////////////////////////////
//
// PATCH STRUCTURES
//

typedef struct _PATCHOP {

    DWORD   dwOpcode;               // Opcode to be performed
    DWORD   dwNextOpcode;           // Relative offset to next opcode
    #pragma warning( disable : 4200 )
    BYTE    data[];                 // Data for this operation type is dependent
                                    // on the op-code.
    #pragma warning( default : 4200 )

} PATCHOP, *PPATCHOP;

typedef struct _RELATIVE_MODULE_ADDRESS {

    DWORD address;           // Relative address from beginning of loaded module
    BYTE  reserved[3];       // Reserved for system use
    WCHAR moduleName[32];    // Module name for this address.

} RELATIVE_MODULE_ADDRESS, *PRELATIVE_MODULE_ADDRESS;

typedef struct _PATCHWRITEDATA {

    DWORD                   dwSizeData;     // Size of patch data in bytes
    RELATIVE_MODULE_ADDRESS rva;            // Relative address where this patch data is
                                            // to be applied.
    #pragma warning( disable : 4200 )
    BYTE                    data[];         // Patch data bytes.
    #pragma warning( default : 4200 )

} PATCHWRITEDATA, *PPATCHWRITEDATA;

typedef struct _PATCHMATCHDATA {

    DWORD                   dwSizeData;     // Size of matching data data in bytes
    RELATIVE_MODULE_ADDRESS rva;            // Relative address where this patch data is
                                            // to be verified.
    #pragma warning( disable : 4200 )
    BYTE                    data[];         // Matching data bytes.
    #pragma warning( default : 4200 )

} PATCHMATCHDATA, *PPATCHMATCHDATA;


typedef enum _PATCHOPCODES {
   
    PEND = 0, // no more opcodes
    PSAA,     // Set Activate Address, SETACTIVATEADDRESS
    PWD,      // Patch Write Data, PATCHWRITEDATA
    PNOP,     // No Operation
    PMAT,     // Patch match the matching bytes but do not replace the bytes.

} PATCHOPCODES;


//
// HEADER STRUCTURE
//
#define SHIMDB_MAGIC            0x66626473  // 'sdbf' (reversed because of little-endian ordering)
#define SHIMDB_MAJOR_VERSION    2           // Don't change this unless fundamentals
                                            // change (like TAG size, etc.)

#define SHIMDB_MINOR_VERSION    0           // This is for info only -- ignored on read

typedef struct _DB_HEADER {
    DWORD       dwMajorVersion;
    DWORD       dwMinorVersion;
    DWORD       dwMagic;
} DB_HEADER, *PDB_HEADER;

//
// INDEX_RECORD STRUCTURE
//

#pragma pack (push, 4)
typedef struct _INDEX_RECORD {
    ULONGLONG   ullKey;
    TAGID       tiRef;
} INDEX_RECORD;

typedef INDEX_RECORD UNALIGNED *PINDEX_RECORD;

#pragma pack (pop)



//
// Forward declaration.
//
struct _DB;
typedef struct _DB* PDB;


//
// This flag is used in apphelp entries.
// When set, it denotes entries that only have apphelp information.
//
#define SHIMDB_APPHELP_ONLY     0x00000001


typedef enum _PATH_TYPE {
    DOS_PATH,
    NT_PATH
} PATH_TYPE;

typedef struct _FIND_INFO {
    TAGID       tiIndex;
    TAGID       tiCurrent;
    TAGID       tiEndIndex; // last record after FindFirst if index is UNIQUE
    TAG         tName;

    DWORD       dwIndexRec;
    DWORD       dwFlags;
    ULONGLONG   ullKey;      // calculated key for this entry

    union {
        LPCTSTR     szName;
        DWORD       dwName;  // for dword search
        GUID*       pguidName;
    };

} FIND_INFO, *PFIND_INFO;

#define SDB_MAX_LAYERS  8
#define SDB_MAX_EXES    4
#define SDB_MAX_SDBS    16

typedef struct tagSDBQUERYRESULT {
    
    TAGREF atrExes[SDB_MAX_EXES];
    TAGREF atrLayers[SDB_MAX_LAYERS];
    TAGREF trAppHelp;                   // If there is an apphelp to display, the EXE
                                        // entry will be here.

    DWORD  dwExeCount;                  // number of elements in atrexes
    DWORD  dwLayerCount;                // number of elements in atrLayers

    GUID   guidID;                      // last exe's GUID
    DWORD  dwFlags;                     // last exe's flags

    //
    // New entries are here to preserve compatibility.
    // Only some entries will be valid in this map.
    //
    DWORD  dwCustomSDBMap;              // entry map, technically not needed
    GUID   rgGuidDB[SDB_MAX_SDBS];

} SDBQUERYRESULT, *PSDBQUERYRESULT;


//
// Information related to TAG_DRIVER tag in the db.
// Use SdbReadDriverInformation to retrieve this struct.
//
typedef struct tagENTRYINFO {

    GUID     guidID;                   // guid ID for this entry
    DWORD    dwFlags;                  // registry flags for this exe
    TAGID    tiData;                   // optional id for a TAG_DATA tag
    GUID     guidDB;                   // optional guid for the database where
                                       // this entry is located
} SDBENTRYINFO, *PSDBENTRYINFO;


//
// Flags used by SDBDATABASEINFO.dwFlags
//
#define DBINFO_GUID_VALID   0x00000001
#define DBINFO_SDBALLOC     0x10000000

typedef struct tagSDBDATABASEINFO {
    
    DWORD    dwFlags;         // flags -- which struct members are valid (and
                              // perhaps flags relevant to db content in the future
    DWORD    dwVersionMajor;  // major version
    DWORD    dwVersionMinor;  // minor version (time stamp)
    LPTSTR   pszDescription;  // description, optional
    GUID     guidDB;          // database id

} SDBDATABASEINFO, *PSDBDATABASEINFO;


///////////////////////////////////////////////////////////////////////////////
//
// APIs to read/write/access the shim database
//


//
// READ functions
//

BYTE
SDBAPI
SdbReadBYTETag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    IN  BYTE  jDefault
    );

WORD
SDBAPI
SdbReadWORDTag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    IN  WORD  wDefault
    );

DWORD
SDBAPI
SdbReadDWORDTag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    IN  DWORD dwDefault
    );

ULONGLONG
SDBAPI
SdbReadQWORDTag(
    IN  PDB       pdb,
    IN  TAGID     tiWhich,
    IN  ULONGLONG qwDefault
    );

BOOL
SDBAPI
SdbReadBinaryTag(
    IN  PDB   pdb,
    IN  TAGID tiWhich,
    OUT PBYTE pBuffer,
    IN  DWORD dwBufferSize
    );

BOOL
SDBAPI
SdbReadStringTag(
    IN  PDB    pdb,
    IN  TAGID  tiWhich,
    OUT LPTSTR pwszBuffer,
    IN  DWORD  dwBufferSize
    );

LPTSTR
SDBAPI
SdbGetStringTagPtr(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );


BYTE
SDBAPI
SdbReadBYTETagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    IN  BYTE   jDefault
    );

WORD
SDBAPI
SdbReadWORDTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    IN  WORD   wDefault
    );

DWORD
SDBAPI
SdbReadDWORDTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    IN  DWORD  dwDefault
    );

ULONGLONG
SDBAPI
SdbReadQWORDTagRef(
    IN  HSDB      hSDB,
    IN  TAGREF    trWhich,
    IN  ULONGLONG qwDefault
    );

BOOL
SDBAPI
SdbReadStringTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    OUT LPTSTR pwszBuffer,
    IN  DWORD  dwBufferSize
    );


//
// GENERAL ACCESS FUNCTIONS
//

TAGID
SDBAPI
SdbGetFirstChild(
    IN  PDB   pdb,
    IN  TAGID tiParent
    );

TAGID
SDBAPI
SdbGetNextChild(
    IN  PDB   pdb,
    IN  TAGID tiParent,
    IN  TAGID tiPrev
    );

TAG
SDBAPI
SdbGetTagFromTagID(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );

DWORD
SDBAPI
SdbGetTagDataSize(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );

PVOID
SDBAPI
SdbGetBinaryTagData(
    IN  PDB   pdb,
    IN  TAGID tiWhich
    );


BOOL
SDBAPI
SdbIsTagrefFromMainDB(
    TAGREF trWhich
    );

BOOL
SDBAPI
SdbIsTagrefFromLocalDB(
    TAGREF trWhich
    );

typedef struct tagATTRINFO *PATTRINFO;

//////////////////////////////////////////////////////////////////////////
// Grab Matching Information Function Declaration
//

//
// Filters available for SdbGrabMatchingInfo
//
#define GRABMI_FILTER_NORMAL        0
#define GRABMI_FILTER_PRIVACY       1
#define GRABMI_FILTER_DRIVERS       2
#define GRABMI_FILTER_VERBOSE       3
#define GRABMI_FILTER_SYSTEM        4
#define GRABMI_FILTER_THISFILEONLY  5
#define GRABMI_FILTER_NOCLOSE       0x10000000
#define GRABMI_FILTER_APPEND        0x20000000
#define GRABMI_FILTER_LIMITFILES    0x40000000
#define GRABMI_FILTER_NORECURSE     0x80000000

#define GRABMI_IMPOSED_FILE_LIMIT   25

typedef enum GMI_RESULT {
    
    GMI_FAILED    = FALSE,
    GMI_SUCCESS   = TRUE,
    GMI_CANCELLED = -1

} GMI_RESULT;


BOOL
SDBAPI
SdbGrabMatchingInfo(
    LPCTSTR szMatchingPath,
    DWORD   dwFilter,
    LPCTSTR szFile
    );


typedef BOOL (CALLBACK* PFNGMIProgressCallback)(
    LPVOID    lpvCallbackParam, // application-defined parameter
    LPCTSTR   lpszRoot,         // root directory path
    LPCTSTR   lpszRelative,     // relative path
    PATTRINFO pAttrInfo,        // attributes
    LPCWSTR   pwszXML           // resulting xml
    );

GMI_RESULT
SDBAPI
SdbGrabMatchingInfoEx(
    LPCTSTR                 szMatchingPath,
    DWORD                   dwFilter,
    LPCTSTR                 szFile,
    PFNGMIProgressCallback  pfnCallback,
    LPVOID                  lpvCallbackParam
    );

//
// Module-type constants
//
#define MT_UNKNOWN_MODULE 0
#define MT_DOS_MODULE 1
#define MT_W16_MODULE 2
#define MT_W32_MODULE 3


//////////////////////////////////////////////////////////////////////////
//
// TAGREF functions
//
//////////////////////////////////////////////////////////////////////////

BOOL
SDBAPI
SdbTagIDToTagRef(
    IN  HSDB    hSDB,
    IN  PDB     pdb,
    IN  TAGID   tiWhich,
    OUT TAGREF* ptrWhich
    );

BOOL
SDBAPI
SdbTagRefToTagID(
    IN  HSDB   hSDB,
    IN  TAGREF trWhich,
    OUT PDB*   ppdb,
    OUT TAGID* ptiWhich
    );


//
// SEARCH functions
//

TAGID
SDBAPI
SdbFindFirstTag(
    IN  PDB   pdb,
    IN  TAGID tiParent,
    IN  TAG   tTag
    );

TAGID
SDBAPI
SdbFindNextTag(
    IN  PDB   pdb,
    IN  TAGID tiParent,
    IN  TAGID tiPrev
    );

TAGID
SDBAPI
SdbFindFirstNamedTag(
    IN  PDB     pdb,
    IN  TAGID   tiParent,
    IN  TAG     tToFind,
    IN  TAG     tName,
    IN  LPCTSTR pszName
    );

TAGREF
SDBAPI
SdbFindFirstTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trParent,
    IN  TAG    tTag
    );

TAGREF
SDBAPI
SdbFindNextTagRef(
    IN  HSDB   hSDB,
    IN  TAGREF trParent,
    IN  TAGREF trPrev
    );

//
// DB access APIs
//

//
// Flags for SdbInitDatabase.
//
#define HID_DOS_PATHS          0x00000001       // use DOS paths
#define HID_DATABASE_FULLPATH  0x00000002       // pszDatabasePath is a full path to the main db
#define HID_NO_DATABASE        0x00000004       // do not open database at this time

#define HID_DATABASE_TYPE_MASK 0xF00F0000       // mask that shows whether we have any
                                                // database type-related bits
//
// The flags could be OR'd with SDB_DATABASE_* bits
//


HSDB
SDBAPI
SdbInitDatabase(
    IN DWORD dwFlags,
    IN LPCTSTR pszDatabasePath
    );

HSDB
SDBAPI
SdbInitDatabaseInMemory(
    IN LPVOID  pDatabaseImage,
    IN DWORD   dwImageSize
    );

VOID
SDBAPI
SdbReleaseDatabase(
    IN HSDB hSDB
    );

//
// Information - retrieval functions
//

BOOL
SDBAPI
SdbGetDatabaseVersion(
    IN  LPCTSTR pwszFileName,
    OUT LPDWORD lpdwMajor,
    OUT LPDWORD lpdwMinor
    );

BOOL
SDBAPI
SdbGetDatabaseInformation(
    IN  PDB pdb,
    OUT PSDBDATABASEINFO pSdbInfo
    );

BOOL
SDBAPI
SdbGetDatabaseID(
    IN  PDB   pdb,
    OUT GUID* pguidDB
    );

DWORD
SDBAPI
SdbGetDatabaseDescription(
    IN  PDB pdb,
    OUT LPTSTR pszDatabaseDescription,
    IN  DWORD BufferSize
    );

VOID
SDBAPI
SdbFreeDatabaseInformation(
    IN PSDBDATABASEINFO pDBInfo
    );

BOOL
SDBAPI
SdbGetDatabaseInformationByName(
    IN LPCTSTR pszDatabase,
    OUT PSDBDATABASEINFO* ppdbInfo
    );

#define SDBTYPE_SYSMAIN 0x00000001
#define SDBTYPE_SYSTEST 0x00000002
#define SDBTYPE_MSI     0x00000003
#define SDBTYPE_SHIM    0x00000004  // primarily shim db
#define SDBTYPE_APPHELP 0x00000005  // primarily type apphelp
#define SDBTYPE_CUSTOM  0x00010000  // this is an "OR" bit


//
// The function below exists only in user mode on win32 platform
//
BOOL
SDBAPI
SdbUnregisterDatabase(
    IN GUID* pguidDB
    );

BOOL
SDBAPI
SdbGetDatabaseRegPath(
    IN  GUID*  pguidDB,
    OUT LPTSTR pszDatabasePath,
    IN  DWORD  dwBufferSize      // size (in tchars) of the buffer
    );

/////////////////////////////////////////////////////////////////

//
// Database types
// for SdbResolveDatabase and SdbRegisterDatabase
//

//
// flag that indicates that the database is the default one
// WILL NOT be set for custom databases
//
#define SDB_DATABASE_MAIN      0x80000000
#define SDB_DATABASE_TEST      0x40000000  // systest.sdb will have 0xc00000000

//
// types - one or more apply depending on the contents of the database
// (see HID_DATABASE_TYPE values, they should match database types 1:1)

#define SDB_DATABASE_SHIM       0x00010000 // set when database contains apps to be fixed by shimming
#define SDB_DATABASE_MSI        0x00020000 // set when database contains msi entries
#define SDB_DATABASE_DRIVERS    0x00040000 // set when database contains drivers to be blocked
#define SDB_DATABASE_DETAILS    0x00080000 // set when the db contains apphelp details
#define SDB_DATABASE_SP_DETAILS 0x00100000 // set when the db contains SP apphelp details
#define SDB_DATABASE_TYPE_MASK  0xF01F0000

//
// These constants should be used when derefencing "main" databases
//

#define SDB_DATABASE_MAIN_SHIM       (SDB_DATABASE_SHIM       | SDB_DATABASE_MSI | SDB_DATABASE_MAIN)
#define SDB_DATABASE_MAIN_MSI        (SDB_DATABASE_MSI        | SDB_DATABASE_MAIN)
#define SDB_DATABASE_MAIN_DRIVERS    (SDB_DATABASE_DRIVERS    | SDB_DATABASE_MAIN)
#define SDB_DATABASE_MAIN_TEST       (SDB_DATABASE_TEST       | SDB_DATABASE_MAIN | SDB_DATABASE_SHIM | SDB_DATABASE_MSI)
#define SDB_DATABASE_MAIN_DETAILS    (SDB_DATABASE_DETAILS    | SDB_DATABASE_MAIN)
#define SDB_DATABASE_MAIN_SP_DETAILS (SDB_DATABASE_SP_DETAILS | SDB_DATABASE_MAIN)

//
// These are internal GUIDs that always reference certain global databases
//
#define GUID_SZ_SYSMAIN_SDB _T("{11111111-1111-1111-1111-111111111111}");
#define GUID_SZ_APPHELP_SDB _T("{22222222-2222-2222-2222-222222222222}");
#define GUID_SZ_SYSTEST_SDB _T("{33333333-3333-3333-3333-333333333333}");
#define GUID_SZ_DRVMAIN_SDB _T("{F9AB2228-3312-4A73-B6F9-936D70E112EF}"};
//
// the following GUIDs are actually declared in sdbapi.c
//
EXTERN_C const GUID FAR GUID_SYSMAIN_SDB;
EXTERN_C const GUID FAR GUID_APPHELP_SDB;
EXTERN_C const GUID FAR GUID_APPHELP_SP_SDB;
EXTERN_C const GUID FAR GUID_SYSTEST_SDB;
EXTERN_C const GUID FAR GUID_DRVMAIN_SDB;
EXTERN_C const GUID FAR GUID_MSIMAIN_SDB;

BOOL
SDBAPI
SdbGetStandardDatabaseGUID(
    IN  DWORD  dwDatabaseType,
    OUT GUID*  pGuidDB
    );

BOOL
SDBAPI
SdbRegisterDatabase(
    IN LPCTSTR pszDatabasePath,
    IN DWORD   dwDatabaseType
    );

BOOL
SDBAPI
SdbRegisterDatabaseEx(
    IN LPCTSTR    pszDatabasePath,
    IN DWORD      dwDatabaseType,
    IN PULONGLONG pTimeStamp
    );

DWORD
SDBAPI
SdbResolveDatabase(
    IN  GUID*   pguidDB,            // pointer to the database guid to resolve
    OUT LPDWORD lpdwDatabaseType,   // optional pointer to the database type
    OUT LPTSTR  pszDatabasePath,    // optional pointer to the database path
    IN  DWORD   dwBufferSize        // size of the buffer pszDatabasePath in tchars
    );


PDB
SdbGetPDBFromGUID(
    IN  HSDB    hSDB,               // HSDB
    IN  GUID*   pguidDB             // the guid of the DB
    );

BOOL
SdbGetDatabaseGUID(
    IN  HSDB    hSDB,               // HSDB of the sdbContext (optional)
    IN  PDB     pdb,                // PDB of the database in question
    OUT GUID*   pguidDB             // the guid of the DB
    );

TAGREF
SDBAPI
SdbFindMsiPackageByID(
    IN HSDB  hSDB,
    IN GUID* pguidID
    );

void
SdbpGetAppPatchDir(
    LPTSTR szAppPatchPath
    );

//
// GUID manipulation apis - not platform dependent
//

BOOL
SDBAPI
SdbGUIDFromString(
    IN  LPCTSTR lpszGuid,
    OUT GUID*   pGuid
    );

BOOL
SDBAPI
SdbGUIDToString(
    IN  GUID* pGuid,
    OUT LPTSTR pszGuid
    );

BOOL
SDBAPI
SdbIsNullGUID(
    IN GUID* pGuid
    );


//
// open/create and close database.
//

PDB
SDBAPI
SdbOpenDatabase(
    IN  LPCTSTR   pwszPath,
    IN  PATH_TYPE eType
    );

BOOL
SDBAPI
SdbOpenLocalDatabase(
    IN  HSDB    hSDB,
    IN  LPCTSTR pwszLocalDatabase
    );


BOOL
SDBAPI
SdbCloseLocalDatabase(
    IN  HSDB    hSDB
    );

PDB
SDBAPI
SdbCreateDatabase(
    IN  LPCWSTR   pwszPath,
    IN  PATH_TYPE eType
    );

void
SDBAPI
SdbCloseDatabase(
    IN  PDB pdb
    );


//
// Search the database looking for an entry for the specified exe.
//

//
// Flags for SdbGetMatchingExe dwFlags
//
#define SDBGMEF_IGNORE_ENVIRONMENT  0x00000001

BOOL
SdbGetMatchingExe(
    IN  HSDB            hSDB  OPTIONAL,
    IN  LPCTSTR         pwszPath,
    IN  LPCTSTR         szModuleName,
    IN  LPCTSTR         pwszEnvironment,
    IN  DWORD           dwFlags,
    OUT PSDBQUERYRESULT pQueryResult
    );

void
SdbReleaseMatchingExe(
    IN  HSDB   hSDB,
    IN  TAGREF trExe
    );

TAGREF
SDBAPI
SdbGetDatabaseMatch(
    IN HSDB    hSDB,
    IN LPCTSTR szPath,
    IN HANDLE  FileHandle  OPTIONAL,
    IN LPVOID  pImageBase  OPTIONAL,
    IN DWORD   dwImageSize OPTIONAL
    );

TAGREF
SdbGetLayerTagReg(
    IN  HSDB    hSDB,
    IN  LPCTSTR szLayer
    );


PDB
SDBAPI
SdbGetLocalPDB(
    IN HSDB hSDB
    );

LPTSTR
SDBAPI
SdbGetLayerName(
    IN  HSDB   hSDB,
    IN  TAGREF trLayer
    );

TAGREF
SDBAPI
SdbGetNamedLayer(
    IN HSDB hSDB,               // database context
    IN TAGREF trLayerRef        // tagref of a record referencing a layer
    );

#define SBCE_ADDITIVE           0x00000001
#define SBCE_INCLUDESYSTEMEXES  0x00000002
#define SBCE_INHERITENV         0x00000004

DWORD
SdbBuildCompatEnvVariables(
    IN  HSDB            hSDB,
    IN  SDBQUERYRESULT* psdbQuery,
    IN  DWORD           dwFlags,
    IN  LPCWSTR         pwszParentEnv OPTIONAL, // Environment which contains vars we
                                                // shall inherit from
    OUT LPWSTR          pBuffer,
    IN  DWORD           cbSize,                 // size of the buffer in tchars
    OUT LPDWORD         lpdwShimsCount OPTIONAL
    );

//
// MSI-specific functionality
//

typedef enum tagSDBMSILOOKUPSTATE {
    LOOKUP_NONE = 0,    // this should be the first state
    LOOKUP_LOCAL,
    LOOKUP_CUSTOM,
    LOOKUP_TEST,
    LOOKUP_MAIN,
    LOOKUP_DONE         // this should be the last state

} SDBMSILOOKUPSTATE;

typedef struct tagSDBMSIFINDINFO {

    TAGREF    trMatch;              // tagref of the matching package
    GUID      guidID;               // guid of this current package
    FIND_INFO sdbFindInfo;          // standard sdb find info

    // this is used to persist the state of the current search
    //
    SDBMSILOOKUPSTATE sdbLookupState;
    DWORD             dwCustomIndex;

} SDBMSIFINDINFO, *PSDBMSIFINDINFO;

typedef struct tagSDBMSITRANSFORMINFO {

    LPCTSTR   lpszTransformName;    // name of the transform
    TAGREF    trTransform;          // tagref of this transform
    TAGREF    trFile;               // tagref of file for this transform (bits)

} SDBMSITRANSFORMINFO, *PSDBMSITRANSFORMINFO;

//
// Information for any individual MSI package
//
typedef struct tagMSIPACKAGEINFO {

    GUID  guidID;                   // unique guid for this entry
    GUID  guidMsiPackageID;         // guid (non-unique, for this entry)
    GUID  guidDatabaseID;           // guid of the database where this had been found
    DWORD dwPackageFlags;           // Package flags (see below)

} MSIPACKAGEINFO, *PMSIPACKAGEINFO;

#define MSI_PACKAGE_HAS_APPHELP 0x00000001
#define MSI_PACKAGE_HAS_SHIMS   0x00000002

TAGREF
SDBAPI
SdbFindFirstMsiPackage_Str(
    IN  HSDB            hSDB,
    IN  LPCTSTR         lpszGuid,
    IN  LPCTSTR         lpszLocalDB,
    OUT PSDBMSIFINDINFO pFindInfo
    );

TAGREF
SDBAPI
SdbFindFirstMsiPackage(
    IN  HSDB            hSDB,           // in HSDB context
    IN  GUID*           pGuidID,        // in GUID that we're looking for
    IN  LPCTSTR         lpszLocalDB,    // in optional path to local db, dos path style
    OUT PSDBMSIFINDINFO pFindInfo       // pointer to our search context
    );

TAGREF
SDBAPI
SdbFindNextMsiPackage(
    IN     HSDB hSDB,
    IN OUT PSDBMSIFINDINFO pFindInfo
    );

BOOL
SDBAPI
SdbGetMsiPackageInformation(
    IN  HSDB hSDB,
    IN  TAGREF trMatch,
    OUT PMSIPACKAGEINFO pPackageInfo
    );

DWORD
SDBAPI
SdbEnumMsiTransforms(
    IN     HSDB    hSDB,            // in HSDB context
    IN     TAGREF  trMatch,         // matched entry
    OUT    TAGREF* ptrBuffer,       // array of tagrefs to fill with msi transform "fixes"
    IN OUT DWORD*  pdwBufferSize    // pointer to the buffer size, receives the number of
                                    // bytes written
    );


BOOL
SDBAPI
SdbReadMsiTransformInfo(
    IN  HSDB   hSDB,                            // HSDB context
    IN  TAGREF trTransformRef,                  // reference to a transform, returned
                                                //   by SdbEnumMsiTransforms
    OUT PSDBMSITRANSFORMINFO pTransformInfo     // information structure
    );

BOOL
SDBAPI
SdbCreateMsiTransformFile(
    IN  HSDB hSDB,                              // context
    IN  LPCTSTR lpszFileName,                   // filename to write data to
    IN  PSDBMSITRANSFORMINFO pTransformInfo     // pointer to the transform structure
    );

TAGREF
SDBAPI
SdbFindCustomActionForPackage(
    IN HSDB hSDB,
    IN TAGREF trPackage,
    IN LPCTSTR lpszCustomAction);

#define SdbGetFirstMsiTransformForPackage(hSDB, trPackage) \
    (SdbFindFirstTagRef((hSDB), (trPackage), TAG_MSI_TRANSFORM_REF))

#define SdbGetNextMsiTransformForPackage(hSDB, trPackage, trPrevMatch) \
    (SdbFindNextTagRef((hSDB), (trPackage), (trPrevMatch)))


//
// "disable" registry entry masks
//
#define SHIMREG_DISABLE_SHIM    0x00000001
#define SHIMREG_DISABLE_APPHELP 0x00000002 // disables apphelp
#define SHIMREG_APPHELP_NOUI    0x00000004 // suppress apphelp ui
#define SHIMREG_APPHELP_CANCEL  0x10000000 // returns CANCEL as a default action

#define SHIMREG_DISABLE_SXS     0x00000010
#define SHIMREG_DISABLE_LAYER   0x00000020
#define SHIMREG_DISABLE_DRIVER  0x00000040

BOOL
SDBAPI
SdbSetEntryFlags(
    IN  GUID* pGuidID,
    IN  DWORD dwFlags
    );

BOOL
SDBAPI
SdbGetEntryFlags(
    IN  GUID*   pGuid,
    OUT LPDWORD lpdwFlags
    );


//
// Flags used by Get/SetPermLayerKeys
//
#define GPLK_USER               0x00000001
#define GPLK_MACHINE            0x00000002

#define GPLK_ALL                (GPLK_USER | GPLK_MACHINE)


BOOL
SDBAPI
SdbGetPermLayerKeys(
    LPCTSTR szPath,
    LPTSTR  szLayers,
    LPDWORD pdwBytes,
    DWORD   dwFlags
    );

BOOL
SDBAPI
SdbSetPermLayerKeys(
    LPCTSTR  szPath,
    LPCTSTR  szLayers,
    BOOL     bMachine
    );

BOOL
SDBAPI
SdbDeletePermLayerKeys(
    LPCTSTR  szPath,
    BOOL     bMachine
    );

BOOL
SdbGetNthUserSdb(
    IN HSDB        hSDB,        // context
    IN LPCTSTR     wszItemName, // item name (foo.exe or layer name)
    IN BOOL        bLayer,      // true if layer name
    IN OUT LPDWORD pdwIndex,    // (0-based)
    OUT GUID*      pGuidDB      // database guid
    );


//
// APIs to pack/unpack appcompat data package.
//

BOOL
SdbPackAppCompatData(
    IN  HSDB            hSDB,
    IN  PSDBQUERYRESULT pSdbQuery,
    OUT PVOID*          ppData,
    OUT LPDWORD         pdwSize
    );

BOOL
SdbUnpackAppCompatData(
    IN  HSDB            hSDB,
    IN  LPCWSTR         pwszExeName,
    IN  PVOID           pAppCompatData,
    OUT PSDBQUERYRESULT pSdbQuery
    );

DWORD
SdbGetAppCompatDataSize(
    IN  PVOID pAppCompatData
    );


//
// DLL functions
//

BOOL
SdbGetDllPath(
    IN  HSDB   hSDB,
    IN  TAGREF trDllRef,
    OUT LPTSTR pwszBuffer
    );

//
// PATCH functions
//

BOOL
SdbReadPatchBits(
    IN  HSDB    hSDB,
    IN  TAGREF  trPatchRef,
    OUT PVOID   pBuffer,
    OUT LPDWORD lpdwBufferSize
    );


//
// SDBDRIVERINFO query function
//

BOOL
SDBAPI
SdbReadEntryInformation(
    IN  HSDB           hSDB,
    IN  TAGREF         trDriver,
    OUT PSDBENTRYINFO  pEntryInfo
    );


DWORD
SDBAPI
SdbQueryData(
    IN     HSDB    hSDB,
    IN     TAGREF  trExe,
    IN     LPCTSTR lpszPolicyName,    // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize
    );

DWORD
SDBAPI
SdbQueryDataEx(
    IN     HSDB    hSDB,              // database handle
    IN     TAGREF  trExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize,    // pointer to buffer size
    OUT    TAGREF* ptrData            // optional pointer to the retrieved data tag
    );

DWORD
SdbQueryDataExTagID(
    IN     PDB     pdb,               // database handle
    IN     TAGID   tiExe,             // tagref of the matching exe
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the policy names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize,    // pointer to buffer size
    OUT    TAGID*  ptiData            // optional pointer to the retrieved data tag
    );


//
// Defines to keep kernel-mode code more readable
//
#define SdbQueryDriverInformation SdbQueryData
#define SdbReadDriverInformation  SdbReadEntryInformation

#define SDBDRIVERINFO             SDBENTRYINFO;
#define PSDBDRIVERINFO            PSDBENTRYINFO;

//
// Query attribute APIs
//

PVOID
SdbGetFileInfo(
    IN  HSDB    hSDB,
    IN  LPCTSTR pwszFilePath,
    IN  HANDLE  hFile OPTIONAL,
    IN  LPVOID  pImageBase OPTIONAL,
    IN  DWORD   dwImageSize OPTIONAL,
    IN  BOOL    bNoCache
    );

VOID
SdbFreeFileInfo(
    IN  PVOID pFileInfo
    );


//
// Get item from item ref
//

TAGREF
SdbGetItemFromItemRef(
    IN  HSDB   hSDB,
    IN  TAGREF trItemRef,
    IN  TAG    tagItemKey,
    IN  TAG    tagItemTAGID,
    IN  TAG    tagItem
    );

#define SdbGetShimFromShimRef(hSDB, trShimRef)     \
        (SdbGetItemFromItemRef(hSDB, trShimRef, TAG_NAME, TAG_SHIM_TAGID, TAG_SHIM))

#define SdbGetPatchFromPatchRef(hSDB, trPatchRef)     \
        (SdbGetItemFromItemRef(hSDB, trPatchRef, TAG_NAME, TAG_PATCH_TAGID, TAG_PATCH))

#define SdbGetFlagFromFlagRef(hSDB, trFlagRef)     \
        (SdbGetItemFromItemRef(hSDB, trFlagRef, TAG_NAME, TAG_FLAG_TAGID, TAG_FLAG))

// INDEX functions

BOOL SdbDeclareIndex(
    IN  PDB      pdb,
    IN  TAG      tWhich,
    IN  TAG      tKey,
    IN  DWORD    dwEntries,
    IN  BOOL     bUniqueKey,
    OUT INDEXID* piiIndex
    );

BOOL
SdbStartIndexing(
    IN  PDB pdb,
    IN  INDEXID iiWhich
    );

BOOL
SdbStopIndexing(
    IN  PDB pdb,
    IN  INDEXID iiWhich
    );

BOOL
SdbCommitIndexes(
    IN  PDB pdb
    );

TAGID
SdbFindFirstDWORDIndexedTag(
    IN  PDB         pdb,
    IN  TAG         tWhich,
    IN  TAG         tKey,
    IN  DWORD       dwName,
    OUT FIND_INFO*  pFindInfo
    );

TAGID
SdbFindNextDWORDIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    );

TAGID
SdbFindFirstStringIndexedTag(
    IN  PDB        pdb,
    IN  TAG        tWhich,
    IN  TAG        tKey,
    IN  LPCTSTR    pwszName,
    OUT FIND_INFO* pFindInfo
    );

TAGID
SdbFindNextStringIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    );

TAGID
SdbFindFirstGUIDIndexedTag(
    IN  PDB         pdb,
    IN  TAG         tWhich,
    IN  TAG         tKey,
    IN  GUID*       pGuidName,
    OUT FIND_INFO*  pFindInfo
    );

TAGID
SdbFindNextGUIDIndexedTag(
    IN  PDB        pdb,
    OUT FIND_INFO* pFindInfo
    );


ULONGLONG
SdbMakeIndexKeyFromString(
    IN  LPCTSTR pwszKey
    );

//
// These macros allow to make a key from dword or a guid
//

#define MAKEKEYFROMDWORD(dwValue) \
    ((ULONGLONG)(dwValue))


#if defined(_WIN64)
ULONGLONG
SdbMakeIndexKeyFromGUID(
    IN GUID* pGuid
    );
#define MAKEKEYFROMGUID(pGuid) SdbMakeIndexKeyFromGUID(pGuid)

#else /* ! WIN64 */

#define MAKEKEYFROMGUID(pGuid) \
    ((ULONGLONG)((*(PULONGLONG)(pGuid)) ^ (*((PULONGLONG)(pGuid) + 1))))

#endif /* WIN64 */


TAGID
SdbGetIndex(
    IN  PDB     pdb,
    IN  TAG     tWhich,
    IN  TAG     tKey,
    OUT LPDWORD lpdwFlags OPTIONAL
    );

#define SdbIsIndexAvailable(pdb, tWhich, tKey)  \
                (SdbGetIndex(pdb, tWhich, tKey, NULL))

//
// WRITE FUNCTIONS
//

TAGID
SdbBeginWriteListTag(
    IN  PDB pdb,
    IN  TAG tTag
    );

BOOL
SdbEndWriteListTag(
    IN  PDB   pdb,
    IN  TAGID tiList
    );

BOOL
SdbWriteStringTagDirect(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszData
    );

BOOL
SdbWriteStringRefTag(
    IN  PDB       pdb,
    IN  TAG       tTag,
    IN  STRINGREF srData
    );

BOOL
SdbWriteNULLTag(
    IN  PDB pdb,
    IN  TAG tTag
    );

BOOL
SdbWriteBYTETag(
    IN  PDB  pdb,
    IN  TAG  tTag,
    IN  BYTE jData
    );

BOOL
SdbWriteWORDTag(
    IN  PDB  pdb,
    IN  TAG  tTag,
    IN  WORD wData
    );

BOOL
SdbWriteDWORDTag(
    IN  PDB   pdb,
    IN  TAG   tTag,
    IN  DWORD dwData
    );

BOOL
SdbWriteQWORDTag(
    IN  PDB       pdb,
    IN  TAG       tTag,
    IN  ULONGLONG qwData
    );

BOOL
SdbWriteStringTag(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszData
    );

BOOL
SdbWriteBinaryTag(
    IN  PDB   pdb,
    IN  TAG   tTag,
    IN  PBYTE pBuffer,
    IN  DWORD dwSize
    );

BOOL
SdbWriteBinaryTagFromFile(
    IN  PDB     pdb,
    IN  TAG     tTag,
    IN  LPCWSTR pwszPath
    );


////////////////////////////////////////////////////////////////////////////////////////////
//
//  Attribute retrieval
//
//

//
//  Attribute Information
//  identified by a tag
//
//
typedef struct tagATTRINFO {

    TAG      tAttrID;        // tag for this attribute (includes type)
    DWORD    dwFlags;        // flags : such as "not avail" or "not there yet"

    union {     // anonymous union with values
        ULONGLONG   ullAttr; // QWORD  value (TAG_TYPE_QWORD)
        DWORD       dwAttr;  // DWORD  value (TAG_TYPE_DWORD)
        TCHAR*      lpAttr;  // WCHAR* value (TAG_TYPE_STRINGREF)
    };

} ATTRINFO, *PATTRINFO;

//
// Flags that go into ATTRINFO's dwFlags field
//
//

#define ATTRIBUTE_AVAILABLE 0x00000001  // this will be set if attribute was obtained
#define ATTRIBUTE_FAILED    0x00000002  // this will be set if we tried to get it
                                        // and failed
BOOL
SDBAPI
SdbGetFileAttributes(
    IN  LPCTSTR    lpwszFileName,
    OUT PATTRINFO* ppAttrInfo,
    OUT LPDWORD    lpdwAttrCount);

BOOL
SDBAPI
SdbFreeFileAttributes(
    IN PATTRINFO pFileAttributes);

BOOL
SDBAPI
SdbFormatAttribute(
    IN  PATTRINFO pAttrInfo,
    OUT LPTSTR    pchBuffer,
    IN  DWORD     dwBufferSize);

////////////////////////////////////////////////////////////////////////////////////////////
//
//
// High-level functions to extract information related to apphelp
//
//

typedef struct tagAPPHELP_DATA {
   DWORD  dwFlags;      // flags (if any)
   DWORD  dwSeverity;   // can be none APPTYPE_NONE (0)
   DWORD  dwHTMLHelpID; // help id
   LPTSTR szAppName;

   TAGREF trExe;        // matched on this exe (in apphelp section)

   LPTSTR szURL;        // URL
   LPTSTR szLink;       // link text

   LPTSTR szAppTitle;   // title
   LPTSTR szContact;    // contact info
   LPTSTR szDetails;    // details

   //
   // non-apphelp data (this is managed by the host app
   //
   DWORD  dwData;
   
   BOOL   bSPEntry;     // TRUE if this entry is in apph_sp.sdb

} APPHELP_DATA, *PAPPHELP_DATA;


BOOL
SdbReadApphelpData(
    IN  HSDB          hSDB,
    IN  TAGREF        trExe,
    OUT PAPPHELP_DATA pData
    );


BOOL
SdbReadApphelpDetailsData(
    IN  PDB           pdbDetails,
    OUT PAPPHELP_DATA pData
    );

////////////////////////////////////////////////////////////////////////////////////////////
//
//
// A few functions from apphelp.dll
//
//

BOOL
SDBAPI
SetPermLayers(
    IN  LPCWSTR pwszPath,   // path to the file to set a permanent layer on
    IN  LPCWSTR pwszLayers, // layers to apply to the file, separated by spaces
    IN  BOOL    bMachine    // TRUE if the layers should be persisted per machine
    );

BOOL
SDBAPI
GetPermLayers(
    IN  LPCWSTR pwszPath,   // path to the file to set a permanent layer on
    OUT LPWSTR  pwszLayers, // layers to apply to the file, separated by spaces
    OUT DWORD*  pdwBytes,   // input: number of bytes available; output is number of bytes needed
    IN  DWORD   dwFlags
    );

BOOL
SDBAPI
AllowPermLayer(
    IN  LPCWSTR pwszPath   // path to the file to check whether you can set a permanent layer on
    );

typedef struct _NTVDM_FLAGS {
    
    DWORD   dwWOWCompatFlags;
    DWORD   dwWOWCompatFlagsEx;
    DWORD   dwUserWOWCompatFlags;
    DWORD   dwWOWCompatFlags2;
    DWORD   dwWOWCompatFlagsFE;
    DWORD   dwFlagsInfoSize;        // size of the memory area pointed to by pFlagsInfo
    PVOID   pFlagsInfo;             // pointer that is used to store flags-related information

} NTVDM_FLAGS, *PNTVDM_FLAGS;

//
// Macros we use to obtain flags command lines
//

#define MAKEQWORD(dwLow, dwHigh) \
    ( ((ULONGLONG)(dwLow)) | ( ((ULONGLONG)(dwHigh)) << 32) )

#define GET_WOWCOMPATFLAGS_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM1, MAKEQWORD(dwFlag, 0), ppCmdLine)

#define GET_WOWCOMPATFLAGSEX_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM1, MAKEQWORD(0, dwFlag), ppCmdLine)

#define GET_USERWOWCOMPATFLAGS_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM2, MAKEQWORD(dwFlag, 0), ppCmdLine)

#define GET_WOWCOMPATFLAGS2_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM2, MAKEQWORD(0, dwFlag), ppCmdLine)

#define GET_WOWCOMPATFLAGSFE_CMDLINE(pFlagInfo, dwFlag, ppCmdLine) \
    SdbQueryFlagInfo(pFlagInfo, TAG_FLAGS_NTVDM3, MAKEQWORD(dwFlag, 0), ppCmdLine)



typedef struct _APPHELP_INFO {

    //
    //  html help id mode
    //
    DWORD   dwHtmlHelpID;       // html help id
    DWORD   dwSeverity;         // must have
    LPCTSTR lpszAppName;
    GUID    guidID;             // entry guid

    //
    //  Conventional mode
    //
    TAGID   tiExe;              // the TAGID of the exe entry within the DB
    GUID    guidDB;             // the guid of the DB that has the EXE entry

    BOOL    bOfflineContent;
    BOOL    bUseHTMLHelp;
    LPCTSTR lpszChmFile;
    LPCTSTR lpszDetailsFile;
    
    //
    // preserve users choice on the dialog if user chooses to persist settings
    //
    BOOL    bPreserveChoice;

} APPHELP_INFO, *PAPPHELP_INFO;


////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Functions to access apphelp functionality
//
//

BOOL
ApphelpGetNTVDMInfo(
    IN  LPCWSTR pwszPath,       // path to the app in NT format
    IN  LPCWSTR pwszModule,     // module name
    IN  LPCWSTR pEnvironment,   // pointer to the environment of the task that is
                                // being created or NULL if we are to use the main NTVDM
                                // environment block.
    OUT LPWSTR pszCompatLayer,  // The new compat layer variable. with format:
                                // "Alpha Bravo Charlie" -- allow 256 chars for this.
    OUT PNTVDM_FLAGS pFlags,    // The flags
    OUT PAPPHELP_INFO pAHInfo   // If there is apphelp to display, this will be filled
                                // in with non-null values
    );

BOOL
ApphelpShowDialog(
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    IN  PHANDLE         phProcess   // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.
    );


typedef PVOID HAPPHELPINFOCONTEXT;

typedef enum tagAPPHELPINFORMATIONCLASS {
    ApphelpFlags,
    ApphelpExeName,
    ApphelpAppName,
    ApphelpVendorName,
    ApphelpHtmlHelpID,
    ApphelpProblemSeverity,
    ApphelpLinkURL,
    ApphelpLinkText,
    ApphelpTitle,
    ApphelpDetails,
    ApphelpContact,
    ApphelpHelpCenterURL,
    ApphelpExeTagID,
    ApphelpDatabaseGUID  // this is guid of a database containing the match
} APPHELPINFORMATIONCLASS;

PDB
SDBAPI
SdbOpenApphelpDetailsDatabase(
    IN LPCWSTR pwsDetailsDatabasePath OPTIONAL
    );

PDB
SDBAPI
SdbOpenApphelpDetailsDatabaseSP(
    void
    );

HAPPHELPINFOCONTEXT
SDBAPI
SdbOpenApphelpInformation(
    IN GUID* pguidDB,
    IN GUID* pguidID
    );

HAPPHELPINFOCONTEXT
SDBAPI
SdbOpenApphelpInformationByID(
    IN HSDB   hSDB,
    IN TAGREF trEntry,
    IN DWORD  dwDatabaseType                // pass the type of db you are using
    );

BOOL
SDBAPI
SdbCloseApphelpInformation(
    IN HAPPHELPINFOCONTEXT hctx
    );

DWORD
SDBAPI
SdbQueryApphelpInformation(
    IN  HAPPHELPINFOCONTEXT hctx,
    IN  APPHELPINFORMATIONCLASS InfoClass,
    OUT LPVOID pBuffer,                     // may be NULL
    IN  DWORD  cbSize                       // may be 0 if pBuffer is NULL
    );

BOOL
SDBAPI
SdbQueryFlagMask(
    IN  HSDB hSDB,
    IN  SDBQUERYRESULT* pQueryResult,
    IN  TAG tMaskType,
    OUT ULONGLONG* pullFlags,
    IN OUT PVOID* ppFlagInfo OPTIONAL
    );

BOOL
SDBAPI
SdbEscapeApphelpURL(
    OUT    LPWSTR    szResult,      // escaped string (output)
    IN OUT LPDWORD   pdwCount,      // count of tchars in the buffer pointed to by szResult
    IN     LPCWSTR   szToEscape     // string to escape
    );

BOOL
SDBAPI
SdbSetApphelpDebugParameters(
    IN HAPPHELPINFOCONTEXT hctx,
    IN LPCWSTR pszDetailsDatabase OPTIONAL,
    IN BOOL    bOfflineContent OPTIONAL, // pass FALSE
    IN BOOL    bUseHtmlHelp    OPTIONAL, // pass FALSE
    IN LPCWSTR pszChmFile      OPTIONAL  // pass NULL
    );

BOOL
SdbShowApphelpDialog(               // returns TRUE if success, whether we should run the app is in pRunApp
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    OUT PHANDLE         phProcess,  // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.
    IN OUT BOOL*        pRunApp
    );


//
// WOW cmd line for flags interface
// instead of calling SdbQueryFlagInfo the macros above should be used
//

BOOL
SDBAPI
SdbQueryFlagInfo(
    IN PVOID pvFlagInfo,
    IN TAG tFlagType,
    IN ULONGLONG ullFlagMask,
    OUT LPCTSTR * ppCmdLine
    );

BOOL
SDBAPI
SdbFreeFlagInfo(
    IN PVOID pvFlagInfo
    );


////////////////////////////////////////////////////////////////////////////////////////////
//
//  App Verifier macros/defs
//
//

typedef enum _VLOG_LEVEL {
    VLOG_LEVEL_INFO,
    VLOG_LEVEL_WARNING,
    VLOG_LEVEL_ERROR
} VLOG_LEVEL, *PVLOG_LEVEL;

typedef enum _AVRF_INFO_ID {
    // INFO ID                     type actually being passed in PVOID param
    // -------                     -----------------------------------------
    AVRF_INFO_NUM_SHIMS,        // LPDWORD (preallocated) (szName should be NULL)
    AVRF_INFO_SHIM_NAMES,       // LPWSTR * (array of same size as value of AVRF_INFO_NUM_SHIMS)
                                //     (array is preallocated, strings are allocated by shim)
                                //     (szName should be NULL)
    AVRF_INFO_DESCRIPTION,      // LPWSTR (allocated by shim)
    AVRF_INFO_FRIENDLY_NAME,    // LPWSTR (allocated by shim)
    AVRF_INFO_INCLUDE_EXCLUDE,  // LPWSTR (allocated by shim)
    AVRF_INFO_FLAGS,            // LPDWORD (preallocated)
    AVRF_INFO_OPTIONS_PAGE,     // LPPROPSHEETPAGE (preallocated)
    AVRF_INFO_VERSION,          // LPDWORD (preallocated), HIWORD=major version, LOWORD=minor version
    AVRF_INFO_GROUPS            // LPDWORD (preallocated)
} AVRF_INFO_ID, *PAVRF_INFO_ID;


//
// FLAGS for verifier shims (all flags default to FALSE)
//

#define AVRF_FLAG_NO_DEFAULT    0x00000001      // this shim should not be turned on by default
#define AVRF_FLAG_NO_WIN2K      0x00000002      // this shim should not be used on win2K
#define AVRF_FLAG_NO_SHIM       0x00000004      // this "shim" is a placeholder and shouldn't actually 
                                                // be applied to an app
#define AVRF_FLAG_NO_TEST       0x00000008      // this "shim" is not a test, and is purely for adding
                                                // a page to the options dialog
#define AVRF_FLAG_NOT_SETUP     0x00000010      // this shim is not appropriate for setup apps
#define AVRF_FLAG_ONLY_SETUP    0x00000020      // this shim is only appropriate for setup apps
#define AVRF_FLAG_RUN_ALONE     0x00000040      // this shim should be run by itself with no other shims applied

//
// GROUPS for verifier shims (by default, shims are in no groups)
//

#define AVRF_GROUP_SETUP        0x00000001      // suitable for checking setup programs
#define AVRF_GROUP_NON_SETUP    0x00000002      // suitable for checking non-setup programs (can be both)
#define AVRF_GROUP_LOGO         0x00000004      // shims that are useful for logo testing

//
// magic number tells us if we're using the same shim interface
//
#define VERIFIER_SHIMS_MAGIC  'avfr'

typedef DWORD (*_pfnGetVerifierMagic)(void);
typedef BOOL (*_pfnQueryShimInfo)(LPCWSTR szName, AVRF_INFO_ID eInfo, PVOID pInfo);

//
// special callback, so a shim can be notified when it is activated or deactivated for a
// specific application.
//
typedef BOOL (*_pfnActivateCallback)(LPCWSTR szAppName, BOOL bActivate);

//
// Where we store default verifier shim settings
//
#define AVRF_DEFAULT_SETTINGS_NAME  TEXT("{default}")
#define AVRF_DEFAULT_SETTINGS_NAME_W  L"{default}"
#define AVRF_DEFAULT_SETTINGS_NAME_A  "{default}"

typedef struct _SHIM_DESCRIPTION {
    
    LPWSTR  szName;
    LPWSTR  szDescription;
    LPWSTR  szExcludes;         // comma separated module names
    LPWSTR  szIncludes;         // comma separated module names
    DWORD   dwFlags;

} SHIM_DESCRIPTION, *PSHIM_DESCRIPTION;

#define ENUM_SHIMS_MAGIC  'enum'

typedef DWORD (*_pfnEnumShims)(PSHIM_DESCRIPTION pShims, DWORD dwMagic);
typedef BOOL  (*_pfnIsVerifierDLL)(void);


////////////////////////////////////////////////////////////////////////////////////////////
//
//  Miscelaneous macros/defs
//
//

//
// Match modes for EXEs
//
#define MATCH_NORMAL    0
#define MATCH_EXCLUSIVE 1
#define MATCH_ADDITIVE  2

//
// the struct below packs into a WORD
// older compilers won't like this union
// (because of nameless members)
//

typedef union tagMATCHMODE {
    struct {
        USHORT Type : 4; // type of match
        USHORT Flags: 4; // flags for matching

        // future expansion here

    };

    WORD  wMatchMode;         // we use this to init from the database

    DWORD dwMatchMode;        // this is the "whole" match mode

} MATCHMODE, *PMATCHMODE;

//
// match modes:
//
// normal    -- find a match, we're done
// additive  -- keep the match, then keep matching according to flags
// exclusive -- keep the match, throw away all other matches
//

static const MATCHMODE MatchModeDefaultMain   = { { MATCH_NORMAL,   0 } };
#define MATCHMODE_DEFAULT_MAIN (MatchModeDefaultMain.wMatchMode)

static const MATCHMODE MatchModeDefaultCustom = { { MATCH_ADDITIVE, 0 } };
#define MATCHMODE_DEFAULT_CUSTOM (MatchModeDefaultCustom.wMatchMode)


#define MAKE_MATCHMODE(dwMatchMode, Type, Flags) \
        {   \
            ((PMATCHMODE)&(dwMatchMode))->Type  = Type;  \
            ((PMATCHMODE)&(dwMatchMode))->Flags = Flags; \
        }

//
// Pre-defined match modes for shimdbc
//

static const MATCHMODE MatchModeNormal    = { { MATCH_NORMAL,    0   } };
static const MATCHMODE MatchModeAdditive  = { { MATCH_ADDITIVE,  0   } };
static const MATCHMODE MatchModeExclusive = { { MATCH_EXCLUSIVE, 0   } };

#define MATCHMODE_NORMAL_SHIMDBC     (MatchModeNormal.wMatchMode)
#define MATCHMODE_ADDITIVE_SHIMDBC   (MatchModeAdditive.wMatchMode)
#define MATCHMODE_EXCLUSIVE_SHIMDBC  (MatchModeExclusive.wMatchMode)


//
// Runtime platform flags
//
#define RUNTIME_PLATFORM_FLAG_NOT          0x80000000
#define RUNTIME_PLATFORM_FLAG_NOT_ELEMENT  0x00000080
#define RUNTIME_PLATFORM_FLAG_VALID        0x00000040
#define RUNTIME_PLATFORM_MASK_ELEMENT      0x000000FF
#define RUNTIME_PLATFORM_MASK_VALUE        0x0000003F
#define RUNTIME_PLATFORM_ANY               0xC0000000 // no valid bits + NOT + flag

//
// Shimdbc compile-time platform (OS_PLATFORM) flags
//
#define OS_PLATFORM_NONE                   0x00000000
#define OS_PLATFORM_I386                   0x00000001
#define OS_PLATFORM_IA64                   0x00000002
#define OS_PLATFORM_ALL                    0xFFFFFFFF

//
// These definitions are used for OS SKU attribute tags on EXE entries
//
#define OS_SKU_NONE                        0x00000000 // None
#define OS_SKU_PER                         0x00000001 // Personal
#define OS_SKU_PRO                         0x00000002 // Professional
#define OS_SKU_SRV                         0x00000004 // Server
#define OS_SKU_ADS                         0x00000008 // Advanced Server
#define OS_SKU_DTC                         0x00000010 // Datacenter
#define OS_SKU_BLA                         0x00000020 // Blade Server
#define OS_SKU_TAB                         0x00000040 // TabletPC
#define OS_SKU_MED                         0x00000080 // eHome
#define OS_SKU_ALL                         0xFFFFFFFF

#ifndef ARRAYSIZE
#define ARRAYSIZE(rg) (sizeof(rg)/sizeof((rg)[0]))
#endif

#ifndef OFFSETOF
#define OFFSETOF offsetof
#endif

#define CHARCOUNT(sz) (sizeof(sz) / sizeof(sz[0]))

//
// our reg key locations
//
#define APPCOMPAT_LOCATION              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags")

#define APPCOMPAT_KEY_PATH              APPCOMPAT_LOCATION
#define APPCOMPAT_KEY_PATH_CUSTOM       APPCOMPAT_LOCATION TEXT("\\Custom")
#define APPCOMPAT_KEY_PATH_INSTALLEDSDB APPCOMPAT_LOCATION TEXT("\\InstalledSDB")

#define POLICY_KEY_APPCOMPAT            TEXT("Software\\Policies\\Microsoft\\Windows\\AppCompat")
#define POLICY_VALUE_DISABLE_ENGINE     TEXT("DisableEngine")
#define POLICY_VALUE_DISABLE_WIZARD     TEXT("DisableWizard")
#define POLICY_VALUE_DISABLE_PROPPAGE   TEXT("DisablePropPage")
#define POLICY_VALUE_APPHELP_LOG        TEXT("LogAppHelpEvents")

// NT API versions
#define APPCOMPAT_KEY_PATH_MACHINE      TEXT("\\Registry\\Machine\\") APPCOMPAT_LOCATION

#define APPCOMPAT_KEY_PATH_NT           TEXT("\\") APPCOMPAT_LOCATION
#define APPCOMPAT_PERM_LAYER_PATH       TEXT("\\") APPCOMPAT_LOCATION TEXT("\\Layers")
#define APPCOMPAT_KEY_PATH_MACHINE_CUSTOM  APPCOMPAT_KEY_PATH_MACHINE TEXT("\\Custom")

#define APPCOMPAT_KEY_PATH_MACHINE_INSTALLEDSDB APPCOMPAT_KEY_PATH_MACHINE TEXT("\\InstalledSDB")


//
// our reg key locations
//

#define POLICY_VALUE_APPHELP_LOG_A      "LogAppHelpEvents"


//
// our reg key locations
//
#define APPCOMPAT_LOCATION_W                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags"

#define APPCOMPAT_KEY_PATH_W                APPCOMPAT_LOCATION_W
#define APPCOMPAT_KEY_PATH_CUSTOM_W         APPCOMPAT_LOCATION_W L"\\Custom"
#define APPCOMPAT_KEY_PATH_INSTALLEDSDB_W   APPCOMPAT_LOCATION_W L"\\InstalledSDB"

#define POLICY_KEY_APPCOMPAT_W              L"Software\\Policies\\Microsoft\\Windows\\AppCompat"
#define POLICY_VALUE_DISABLE_ENGINE_W       L"DisableEngine"
#define POLICY_VALUE_DISABLE_WIZARD_W       L"DisableWizard"
#define POLICY_VALUE_DISABLE_PROPPAGE_W     L"DisablePropPage"
#define POLICY_VALUE_APPHELP_LOG_W          L"LogAppHelpEvents"

//
// LUA all-users redirection location
//
#define LUA_REDIR       ("%ALLUSERSPROFILE%\\Application Data\\Redirected")
#define LUA_REDIR_W     TEXT("%ALLUSERSPROFILE%\\Application Data\\Redirected")

//
// debug output support
//
typedef enum tagSHIMDBGLEVEL {
    sdlError   = 1,
    sdlWarning = 2,
    sdlFail    = 1,  // this means we have failed some api, not necessarily fatal
    sdlInfo    = 3,
    sdlUser    = 4
} SHIMDBGLEVEL;

//
// This flag marks the debug out for pipe
//
#define sdlLogPipe 0x00000080UL
#define sdlMask    0x0000007FUL

#define FILTER_DBG_LEVEL(level) ((int)((level) & sdlMask))


extern int __cdecl ShimDbgPrint(INT iDebugLevel, PCH FunctionName, PCH Format, ...);

#if DBG // Define _DEBUG_SPEW when compiling checked

    #ifndef _DEBUG_SPEW
        #define _DEBUG_SPEW
    #endif

#endif // DBG


#ifdef _DEBUG_SPEW

//
// This value is a large number (initiallly)
// We will initialize it from the environment upon the first call
// to ShimDbgPrint
//
extern int g_iShimDebugLevel;

#define DBGPRINT( _x_ ) \
    {                                 \
        if (g_iShimDebugLevel) {      \
            ShimDbgPrint _x_;         \
        }                             \
    }

#else

#define DBGPRINT(_x_)

#endif // _DEBUG_SPEW


///////////////////////////////////////////////////////////////////////////////
//
// SHIM TAGS
//

//
// Function to get the tag names given a tag ID.
//
// WARNING !!! : If you add new tags make sure you update SdbApi\attributes.c
//               with the name of the tag in the global gaTagInfo.
//
LPCTSTR
SDBAPI
SdbTagToString(
    TAG tag
    );


//
// LIST types for shimdb
//
#define TAG_DATABASE            (0x1 | TAG_TYPE_LIST)
#define TAG_LIBRARY             (0x2 | TAG_TYPE_LIST)
#define TAG_INEXCLUDE           (0x3 | TAG_TYPE_LIST)
#define TAG_SHIM                (0x4 | TAG_TYPE_LIST)
#define TAG_PATCH               (0x5 | TAG_TYPE_LIST)
#define TAG_APP                 (0x6 | TAG_TYPE_LIST)
#define TAG_EXE                 (0x7 | TAG_TYPE_LIST)
#define TAG_MATCHING_FILE       (0x8 | TAG_TYPE_LIST)
#define TAG_SHIM_REF            (0x9 | TAG_TYPE_LIST)
#define TAG_PATCH_REF           (0xA | TAG_TYPE_LIST)
#define TAG_LAYER               (0xB | TAG_TYPE_LIST)
#define TAG_FILE                (0xC | TAG_TYPE_LIST)
#define TAG_APPHELP             (0xD | TAG_TYPE_LIST)
#define TAG_LINK                (0xE | TAG_TYPE_LIST)   // Description list w/lang ids and urls
#define TAG_DATA                (0xF | TAG_TYPE_LIST)
#define TAG_MSI_TRANSFORM       (0x10| TAG_TYPE_LIST)
#define TAG_MSI_TRANSFORM_REF   (0x11| TAG_TYPE_LIST)
#define TAG_MSI_PACKAGE         (0x12| TAG_TYPE_LIST)
#define TAG_FLAG                (0x13| TAG_TYPE_LIST)
#define TAG_MSI_CUSTOM_ACTION   (0x14| TAG_TYPE_LIST)
#define TAG_FLAG_REF            (0x15| TAG_TYPE_LIST)
#define TAG_ACTION              (0x16| TAG_TYPE_LIST)


//
// STRINGREF types for shimdb
//

#define TAG_NAME                (0x1  | TAG_TYPE_STRINGREF)
#define TAG_DESCRIPTION         (0x2  | TAG_TYPE_STRINGREF)
#define TAG_MODULE              (0x3  | TAG_TYPE_STRINGREF)
#define TAG_API                 (0x4  | TAG_TYPE_STRINGREF)
#define TAG_VENDOR              (0x5  | TAG_TYPE_STRINGREF)
#define TAG_APP_NAME            (0x6  | TAG_TYPE_STRINGREF)
#define TAG_COMMAND_LINE        (0x8  | TAG_TYPE_STRINGREF)
#define TAG_COMPANY_NAME        (0x9  | TAG_TYPE_STRINGREF)
#define TAG_DLLFILE             (0xA  | TAG_TYPE_STRINGREF)
#define TAG_WILDCARD_NAME       (0xB  | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_NAME        (0x10 | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_VERSION     (0x11 | TAG_TYPE_STRINGREF)
#define TAG_FILE_DESCRIPTION    (0x12 | TAG_TYPE_STRINGREF)
#define TAG_FILE_VERSION        (0x13 | TAG_TYPE_STRINGREF)
#define TAG_ORIGINAL_FILENAME   (0x14 | TAG_TYPE_STRINGREF)
#define TAG_INTERNAL_NAME       (0x15 | TAG_TYPE_STRINGREF)
#define TAG_LEGAL_COPYRIGHT     (0x16 | TAG_TYPE_STRINGREF)
#define TAG_16BIT_DESCRIPTION   (0x17 | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_DETAILS     (0x18 | TAG_TYPE_STRINGREF) // Details in single language
#define TAG_LINK_URL            (0x19 | TAG_TYPE_STRINGREF)
#define TAG_LINK_TEXT           (0x1A | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_TITLE       (0x1B | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_CONTACT     (0x1C | TAG_TYPE_STRINGREF)
#define TAG_SXS_MANIFEST        (0x1D | TAG_TYPE_STRINGREF)
#define TAG_DATA_STRING         (0x1E | TAG_TYPE_STRINGREF)
#define TAG_MSI_TRANSFORM_FILE  (0x1F | TAG_TYPE_STRINGREF)
#define TAG_16BIT_MODULE_NAME   (0x20 | TAG_TYPE_STRINGREF)
#define TAG_LAYER_DISPLAYNAME   (0x21 | TAG_TYPE_STRINGREF)
#define TAG_COMPILER_VERSION    (0x22 | TAG_TYPE_STRINGREF)
#define TAG_ACTION_TYPE         (0x23 | TAG_TYPE_STRINGREF)

#define TAG_STRINGTABLE         (0x801 | TAG_TYPE_LIST)


//
// DWORD types for shimdb
//
#define TAG_SIZE                (0x1  | TAG_TYPE_DWORD)
#define TAG_OFFSET              (0x2  | TAG_TYPE_DWORD)
#define TAG_CHECKSUM            (0x3  | TAG_TYPE_DWORD)
#define TAG_SHIM_TAGID          (0x4  | TAG_TYPE_DWORD)
#define TAG_PATCH_TAGID         (0x5  | TAG_TYPE_DWORD)
#define TAG_MODULE_TYPE         (0x6  | TAG_TYPE_DWORD)
#define TAG_VERDATEHI           (0x7  | TAG_TYPE_DWORD)
#define TAG_VERDATELO           (0x8  | TAG_TYPE_DWORD)
#define TAG_VERFILEOS           (0x9  | TAG_TYPE_DWORD)
#define TAG_VERFILETYPE         (0xA  | TAG_TYPE_DWORD)
#define TAG_PE_CHECKSUM         (0xB  | TAG_TYPE_DWORD)
#define TAG_PREVOSMAJORVER      (0xC  | TAG_TYPE_DWORD)
#define TAG_PREVOSMINORVER      (0xD  | TAG_TYPE_DWORD)
#define TAG_PREVOSPLATFORMID    (0xE  | TAG_TYPE_DWORD)
#define TAG_PREVOSBUILDNO       (0xF  | TAG_TYPE_DWORD)
#define TAG_PROBLEMSEVERITY     (0x10 | TAG_TYPE_DWORD)
#define TAG_LANGID              (0x11 | TAG_TYPE_DWORD)
#define TAG_VER_LANGUAGE        (0x12 | TAG_TYPE_DWORD)

#define TAG_ENGINE              (0x14 | TAG_TYPE_DWORD)
#define TAG_HTMLHELPID          (0x15 | TAG_TYPE_DWORD)
#define TAG_INDEX_FLAGS         (0x16 | TAG_TYPE_DWORD)
#define TAG_FLAGS               (0x17 | TAG_TYPE_DWORD)
#define TAG_DATA_VALUETYPE      (0x18 | TAG_TYPE_DWORD)
#define TAG_DATA_DWORD          (0x19 | TAG_TYPE_DWORD)
#define TAG_LAYER_TAGID         (0x1A | TAG_TYPE_DWORD)
#define TAG_MSI_TRANSFORM_TAGID (0x1B | TAG_TYPE_DWORD)
#define TAG_LINKER_VERSION      (0x1C | TAG_TYPE_DWORD)
#define TAG_LINK_DATE           (0x1D | TAG_TYPE_DWORD)
#define TAG_UPTO_LINK_DATE      (0x1E | TAG_TYPE_DWORD)
#define TAG_OS_SERVICE_PACK     (0x1F | TAG_TYPE_DWORD)


#define TAG_FLAG_TAGID          (0x20 | TAG_TYPE_DWORD)
#define TAG_RUNTIME_PLATFORM    (0x21 | TAG_TYPE_DWORD)
#define TAG_OS_SKU              (0x22 | TAG_TYPE_DWORD)

#define TAG_TAGID               (0x801| TAG_TYPE_DWORD)

//
// STRING types
//
#define TAG_STRINGTABLE_ITEM    (0x801 | TAG_TYPE_STRING)

//
// NULL types for shimdb (existence/nonexistence is treated like a BOOL)
//
#define TAG_INCLUDE                  (0x1 | TAG_TYPE_NULL)
#define TAG_GENERAL                  (0x2 | TAG_TYPE_NULL)
#define TAG_MATCH_LOGIC_NOT          (0x3 | TAG_TYPE_NULL)
#define TAG_APPLY_ALL_SHIMS          (0x4 | TAG_TYPE_NULL)
#define TAG_USE_SERVICE_PACK_FILES   (0x5 | TAG_TYPE_NULL)

//
// QWORD types for shimdb
//
#define TAG_TIME                     (0x1 | TAG_TYPE_QWORD)
#define TAG_BIN_FILE_VERSION         (0x2 | TAG_TYPE_QWORD)
#define TAG_BIN_PRODUCT_VERSION      (0x3 | TAG_TYPE_QWORD)
#define TAG_MODTIME                  (0x4 | TAG_TYPE_QWORD)
#define TAG_FLAG_MASK_KERNEL         (0x5 | TAG_TYPE_QWORD)
#define TAG_UPTO_BIN_PRODUCT_VERSION (0x6 | TAG_TYPE_QWORD)
#define TAG_DATA_QWORD               (0x7 | TAG_TYPE_QWORD)
#define TAG_FLAG_MASK_USER           (0x8 | TAG_TYPE_QWORD)
#define TAG_FLAGS_NTVDM1             (0x9 | TAG_TYPE_QWORD)
#define TAG_FLAGS_NTVDM2             (0xA | TAG_TYPE_QWORD)
#define TAG_FLAGS_NTVDM3             (0xB | TAG_TYPE_QWORD)
#define TAG_FLAG_MASK_SHELL          (0xC | TAG_TYPE_QWORD)
#define TAG_UPTO_BIN_FILE_VERSION    (0xD | TAG_TYPE_QWORD)



//
// BINARY types for shimdb
//
#define TAG_PATCH_BITS               (0x2 | TAG_TYPE_BINARY)
#define TAG_FILE_BITS                (0x3 | TAG_TYPE_BINARY)
#define TAG_EXE_ID                   (0x4 | TAG_TYPE_BINARY)
#define TAG_DATA_BITS                (0x5 | TAG_TYPE_BINARY)
#define TAG_MSI_PACKAGE_ID           (0x6 | TAG_TYPE_BINARY)  // msi package id is a guid
#define TAG_DATABASE_ID              (0x7 | TAG_TYPE_BINARY)  // database guid

#define TAG_INDEX_BITS               (0x801 | TAG_TYPE_BINARY)

//
// INDEX types for shimdb
//
#define TAG_INDEXES             (0x802 | TAG_TYPE_LIST)
#define TAG_INDEX               (0x803 | TAG_TYPE_LIST)

//
// WORD types
//
#define TAG_MATCH_MODE          (0x1 | TAG_TYPE_WORD)

#define TAG_TAG                 (0x801 | TAG_TYPE_WORD)
#define TAG_INDEX_TAG           (0x802 | TAG_TYPE_WORD)
#define TAG_INDEX_KEY           (0x803 | TAG_TYPE_WORD)

//
// let the typedefs take the course..
//

#undef LPCTSTR
#undef LPTSTR
#undef TCHAR


#endif // _SHIMDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimhookmacro.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ShimHookMacro.h

 Abstract:

    Shim hooking macros for version 2

 Notes:

    None

 History:

    10/29/2000 markder  Created
    12/06/2000 robkenny Converted to use namespaces
    09/11/2001 mnikkel Modified DPFN and LOGN to retain LastError

--*/

#pragma once

#ifndef _ShimHookMacro_h_
#define _ShimHookMacro_h_

//
// These are dwReason values that the shim notification functions
// can be called with.
//

//
// This means that all the static linked DLLs have run their init routines.
//
#define SHIM_STATIC_DLLS_INITIALIZED                100

//
// This means that the current process is about to die.
// This gives the shims a chance to do cleanup work while all the modules
// are still loaded.
//
#define SHIM_PROCESS_DYING                          101

//
// This notification is sent to notify the shims that a DLL is unloading
//
#define SHIM_DLL_LOADING                            102

extern PLDR_DATA_TABLE_ENTRY g_DllLoadingEntry;
#define GETDLLLOADINGHANDLE()   (g_DllLoadingEntry)


//
// This debug macro needs to be in this file because it needs access
// to g_szModuleName which is only defined inside the namespace.
//
inline void DPFN(ShimLib::DEBUGLEVEL dwDetail, LPCSTR pszFmt, ...)
{
#if DBG
	// This must be the first line of this routine to preserve LastError.
	DWORD dwLastError = GetLastError();

    extern const CHAR * g_szModuleName; // created by the DECLARE_SHIM macro, inside of the shim's namespace
    
    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    ShimLib::DebugPrintfList(g_szModuleName, dwDetail, pszFmt, vaArgList);

    va_end(vaArgList);
    
	// This must be the last line of this routine to preserve LastError.
	SetLastError(dwLastError); 
#else
    dwDetail; 
    pszFmt;
#endif

}

inline void LOGN(ShimLib::DEBUGLEVEL dwDetail, LPCSTR pszFmt, ...)
{
	// This must be the first line of this routine to preserve LastError.
	DWORD dwLastError = GetLastError();

    extern const CHAR * g_szModuleName;

    if (ShimLib::g_bFileLogEnabled)
    {
        va_list vaArgList;
        va_start(vaArgList, pszFmt);

        ShimLib::ShimLogList(g_szModuleName, dwDetail, pszFmt, vaArgList);

        va_end(vaArgList);
    }
#if DBG
    // If logging isn't enabled, dump to the debugger
    else
    {
        va_list vaArgList;
        va_start(vaArgList, pszFmt);

        ShimLib::DebugPrintfList(g_szModuleName, dwDetail, pszFmt, vaArgList);

        va_end(vaArgList);
    }   
#endif

 	// This must be the last line of this routine to preserve LastError.
	SetLastError(dwLastError); 
}


#define APIHOOK(hook) APIHook_##hook
#define COMHOOK(iface, hook) COMHook_##iface##_##hook

#define APIHOOK_ENUM_BEGIN                          enum {
#define APIHOOK_ENUM_ENTRY(hook)                    APIHOOK_##hook##,
#define APIHOOK_ENUM_ENTRY_COMSERVER(module)        APIHOOK_##module##_DllGetClassObject,
#define APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()                                             \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DDRAW)    \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DSOUND)   \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DPLAYX)   \
                                                    APIHOOK_ENUM_ENTRY_COMSERVER(DINPUT)   \
                                                    APIHOOK_ENUM_ENTRY(DirectDrawCreate)   \
                                                    APIHOOK_ENUM_ENTRY(DirectDrawCreateEx) \
                                                    APIHOOK_ENUM_ENTRY(DirectSoundCreate)  \
                                                    APIHOOK_ENUM_ENTRY(DirectPlayCreate)   \
                                                    APIHOOK_ENUM_ENTRY(DirectInputCreateA) \
                                                    APIHOOK_ENUM_ENTRY(DirectInputCreateW) \
                                                    APIHOOK_ENUM_ENTRY(DirectInputCreateEx)

#define APIHOOK_ENUM_END                            APIHOOK_Count };

#define HOOK_BEGIN                                                                  \
PHOOKAPI                                                                            \
InitializeHooksMulti(                                                               \
    DWORD fdwReason,                                                                \
    LPSTR pszCmdLine,                                                               \
    DWORD* pdwHookCount                                                             \
    )                                                                               \
{                                                                                   \
    DPFN(eDbgLevelSpew,                                                             \
        "[InitializeHooksMulti] fdwReason(%d) pszCmdLine(%s)\n",                    \
        fdwReason, pszCmdLine);                                                     \
                                                                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        lstrcpynA( g_szCommandLine, pszCmdLine, SHIM_COMMAND_LINE_MAX_BUFFER);      \
                                                                                    \
        g_pAPIHooks =                                                               \
            (PHOOKAPI) ShimMalloc(sizeof(HOOKAPI)*APIHOOK_Count);                   \
        if (g_pAPIHooks == NULL) {                                                  \
            return NULL;                                                            \
        }                                                                           \
        *pdwHookCount = APIHOOK_Count;                                              \
    }

#define HOOK_END                                                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        DPFN(eDbgLevelSpew,                                                         \
            "[InitializeHooksMulti] pdwHookCount(%d)\n",                            \
            pdwHookCount ? *pdwHookCount : 0);                                      \
    }                                                                               \
    return g_pAPIHooks;                                                             \
}

#define APIHOOK_ENTRY(module, hook)                                                 \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##hook##].pszModule = #module;                          \
        g_pAPIHooks[APIHOOK_##hook##].pszFunctionName = #hook;                      \
        g_pAPIHooks[APIHOOK_##hook##].pfnNew = APIHOOK(hook);                       \
    }

#define APIHOOK_ENTRY_NAME(module, hook, hookname)                                  \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##hook##].pszModule = #module;                          \
        g_pAPIHooks[APIHOOK_##hook##].pszFunctionName = #hookname;                  \
        g_pAPIHooks[APIHOOK_##hook##].pfnNew = APIHOOK(hook);                       \
    }

#define APIHOOK_ENTRY_ORD(module, hook, hookord)                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##hook##].pszModule = #module;                          \
        g_pAPIHooks[APIHOOK_##hook##].pszFunctionName = (char *)IntToPtr(hookord);  \
        g_pAPIHooks[APIHOOK_##hook##].pfnNew = APIHOOK(hook);                       \
    }

#define APIHOOK_ENTRY_COMSERVER(module)                                                                 \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                                              \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszModule = #module ".DLL";                   \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszFunctionName = "DllGetClassObject";        \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pfnNew = APIHOOK(module##_DllGetClassObject); \
    }

#define APIHOOK_ENTRY_DIRECTX_COMSERVER()                                           \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        APIHOOK_ENTRY_COMSERVER(DDRAW)                                              \
        APIHOOK_ENTRY_COMSERVER(DSOUND)                                             \
        APIHOOK_ENTRY_COMSERVER(DPLAYX)                                             \
        APIHOOK_ENTRY_COMSERVER(DINPUT)                                             \
        APIHOOK_ENTRY(DDRAW.DLL, DirectDrawCreate)                                  \
        APIHOOK_ENTRY(DDRAW.DLL, DirectDrawCreateEx)                                \
        APIHOOK_ENTRY(DSOUND.DLL, DirectSoundCreate)                                \
        APIHOOK_ENTRY(DPLAYX.DLL, DirectPlayCreate)                                 \
        APIHOOK_ENTRY(DINPUT.DLL, DirectInputCreateA)                               \
        APIHOOK_ENTRY(DINPUT.DLL, DirectInputCreateW)                               \
        APIHOOK_ENTRY(DINPUT.DLL, DirectInputCreateEx)                              \
    }

#define COMHOOK_ENTRY(obj, iface, hook, vtblndx)                                    \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        AddComHook(CLSID_##obj, IID_##iface, COMHOOK(iface, hook), vtblndx);        \
    }

#define DECLARE_SHIM(shim)                                                          \
    namespace NS_##shim                                                             \
    {                                                                               \
        const CHAR *    g_szModuleName = #shim;                                     \
        CHAR            g_szCommandLine[SHIM_COMMAND_LINE_MAX_BUFFER];              \
        PHOOKAPI        g_pAPIHooks = NULL;                                         \
        BOOL            g_bSubshimUsed = FALSE;                                     \
        extern PHOOKAPI InitializeHooksMulti(DWORD, LPSTR, DWORD*);                 \
    };

#define MULTISHIM_BEGIN()                                                                                    \
VOID ShimLib::InitializeHooks(DWORD)                                                                         \
{                                                                                                            \
    g_dwShimVersion = 2;                                                                                     \
}                                                                                                            \
PHOOKAPI ShimLib::InitializeHooksEx(DWORD fdwReason, LPWSTR pwszShim, LPSTR pszCmdLine, DWORD* pdwHookCount) \
{                                                                                                            \
    PHOOKAPI pAPIHooks = NULL;                                                                               \
    g_bMultiShim = TRUE;


#define MULTISHIM_ENTRY(shim)                                                                         \
    if ((fdwReason == DLL_PROCESS_ATTACH && pwszShim != NULL && 0 == _wcsicmp( pwszShim, L#shim )) || \
        (fdwReason == DLL_PROCESS_DETACH && NS_##shim::g_bSubshimUsed) ||                             \
        (fdwReason == SHIM_PROCESS_DYING && NS_##shim::g_bSubshimUsed) ||                             \
        (fdwReason == SHIM_DLL_LOADING && NS_##shim::g_bSubshimUsed) ||                               \
        (fdwReason == SHIM_STATIC_DLLS_INITIALIZED && NS_##shim::g_bSubshimUsed)) {                   \
        NS_##shim::g_bSubshimUsed = TRUE;                                                             \
        pAPIHooks = NS_##shim::InitializeHooksMulti( fdwReason, pszCmdLine, pdwHookCount );           \
    }

#define MULTISHIM_END()                                                         \
    return pAPIHooks;                                                           \
}

#define MULTISHIM_NOTIFY_FUNCTION() NotifyFn
#define NOTIFY_FUNCTION       NotifyFn

#define CALL_MULTISHIM_NOTIFY_FUNCTION()   NotifyFn(fdwReason);
#define CALL_NOTIFY_FUNCTION                                                    \
    if (FALSE == NotifyFn(fdwReason) &&                                         \
        fdwReason == DLL_PROCESS_ATTACH) {                                      \
        *pdwHookCount = 0;                                                      \
        DPFN(eDbgLevelSpew,                                                     \
            "[InitializeHooksMulti] NotifyFn returned FALSE, fail load shim\n", \
            g_pAPIHooks);                                                       \
        return NULL;                                                            \
    }

#define ORIGINAL_API(hook)                                                      \
    (*(_pfn_##hook##)(g_pAPIHooks[APIHOOK_##hook##].pfnOld))

#define _ORIGINAL_API(hook, proto)                                              \
    (*(_pfn_##proto##)(g_pAPIHooks[APIHOOK_##hook##].pfnOld))

#define ORIGINAL_COM(iface, hook, pThis)                                        \
    (*(_pfn_##iface##_##hook##)(LookupOriginalCOMFunction(*((PVOID *) pThis), COMHOOK(iface, hook), TRUE )))

#define COMMAND_LINE \
    (g_szCommandLine)

#define IMPLEMENT_COMSERVER_HOOK(module)                                         \
HRESULT                                                                          \
APIHOOK(##module##_DllGetClassObject)(                                           \
    REFCLSID rclsid,                                                             \
    REFIID riid,                                                                 \
    LPVOID * ppv                                                                 \
    )                                                                            \
{                                                                                \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = _ORIGINAL_API(module##_DllGetClassObject, DllGetClassObject)(     \
                                rclsid, riid,  ppv);                             \
                                                                                 \
    if (S_OK ==  hrReturn) {                                                     \
        HookCOMInterface(rclsid, riid, ppv, TRUE);                               \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}

#define IMPLEMENT_DIRECTX_COMSERVER_HOOKS()                                      \
IMPLEMENT_COMSERVER_HOOK(DDRAW)                                                  \
IMPLEMENT_COMSERVER_HOOK(DSOUND)                                                 \
IMPLEMENT_COMSERVER_HOOK(DPLAYX)                                                 \
IMPLEMENT_COMSERVER_HOOK(DINPUT)                                                 \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectDrawCreate)(                                                       \
    IN GUID FAR *lpGUID,                                                         \
    OUT LPVOID *lplpDD,                                                          \
    OUT IUnknown* pUnkOuter                                                      \
    )                                                                            \
{                                                                                \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectDrawCreate)(lpGUID, lplpDD, pUnkOuter);        \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectDraw, IID_IDirectDraw, lplpDD, FALSE);      \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectDrawCreateEx)(                                                     \
    GUID FAR *lpGUID,                                                            \
    LPVOID *lplpDD,                                                              \
    REFIID iid,                                                                  \
    IUnknown* pUnkOuter                                                          \
    )                                                                            \
{                                                                                \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectDrawCreateEx)(                                 \
        lpGUID,                                                                  \
        lplpDD,                                                                  \
        iid,                                                                     \
        pUnkOuter);                                                              \
                                                                                 \
    if (S_OK ==  hrReturn) {                                                     \
        HookCOMInterface(CLSID_DirectDraw, iid, lplpDD, FALSE);                  \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectSoundCreate)(                                                      \
    LPCGUID lpcGuid,                                                             \
    LPDIRECTSOUND *ppDS,                                                         \
    LPUNKNOWN pUnkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectSoundCreate)(                                  \
        lpcGuid,                                                                 \
        ppDS,                                                                    \
        pUnkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectSound,                                      \
                         IID_IDirectSound,                                       \
                         (LPVOID*) ppDS,                                         \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectPlayCreate)(                                                       \
    LPGUID lpGUIDSP,                                                             \
    LPDIRECTPLAY FAR *lplpDP,                                                    \
    IUnknown *lpUnk)                                                             \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectPlayCreate)(                                   \
        lpGUIDSP,                                                                \
        lplpDP,                                                                  \
        lpUnk);                                                                  \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectPlay,                                       \
                         IID_IDirectPlay,                                        \
                         (LPVOID*) lplpDP,                                       \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectInputCreateA)(                                                     \
    HINSTANCE hinst,                                                             \
    DWORD dwVersion,                                                             \
    LPDIRECTINPUTA * lplpDirectInput,                                            \
    LPUNKNOWN punkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectInputCreateA)(                                 \
        hinst,                                                                   \
        dwVersion,                                                               \
        lplpDirectInput,                                                         \
        punkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectInput,                                      \
                         IID_IDirectInputA,                                      \
                         (LPVOID*) lplpDirectInput,                              \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectInputCreateW)(                                                     \
    HINSTANCE hinst,                                                             \
    DWORD dwVersion,                                                             \
    LPDIRECTINPUTW * lplpDirectInput,                                            \
    LPUNKNOWN punkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectInputCreateW)(                                 \
        hinst,                                                                   \
        dwVersion,                                                               \
        lplpDirectInput,                                                         \
        punkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectInput,                                      \
                         IID_IDirectInputW,                                      \
                         (LPVOID*) lplpDirectInput,                              \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                \
                                                                                 \
HRESULT                                                                          \
APIHOOK(DirectInputCreateEx)(                                                    \
    HINSTANCE hinst,                                                             \
    DWORD dwVersion,                                                             \
    REFIID riidltf,                                                              \
    LPVOID * ppvOut,                                                             \
    LPUNKNOWN punkOuter)                                                         \
{                                                                                \
                                                                                 \
    HRESULT hrReturn = E_FAIL;                                                   \
                                                                                 \
    hrReturn = ORIGINAL_API(DirectInputCreateEx)(                                \
        hinst,                                                                   \
        dwVersion,                                                               \
        riidltf,                                                                 \
        ppvOut,                                                                  \
        punkOuter);                                                              \
                                                                                 \
    if (S_OK == hrReturn) {                                                      \
        HookCOMInterface(CLSID_DirectInput,                                      \
                         riidltf,                                                \
                         (LPVOID*) ppvOut,                                       \
                         FALSE);                                                 \
    }                                                                            \
                                                                                 \
    return hrReturn;                                                             \
}                                                                                

// Only add this hook to the list if bDeclare is TRUE
// otherwise a blank entry is added.
#define APIHOOK_ENTRY_OR_NOT(bDeclare, module, hook)                                \
    if (bDeclare) {                                                                 \
        APIHOOK_ENTRY(module, hook)                                                 \
    }

// Only add this hook to the list if bDeclare is TRUE
// otherwise a blank entry is added.
#define APIHOOK_ENTRY_COMSERVER_OR_NOT(bDeclare, module)                            \
    if (bDeclare) {                                                                 \
        APIHOOK_ENTRY_COMSERVER(module)                                             \
    } else {                                                                        \
        APIHOOK_ENTRY_COMSERVER_BLANK(module)                                       \
    }


#define APIHOOK_ENTRY_COMSERVER_BLANK(module)                                       \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszModule = "";           \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pszFunctionName = "";     \
        g_pAPIHooks[APIHOOK_##module##_DllGetClassObject].pfnNew = NULL;            \
    }


#endif // _SHIMHOOKMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimhook.h ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

    ShimHook.h

 Abstract:

    Main header for shim DLLs

 Notes:

    None

 History:

    10/29/1999 markder      Created
    07/16/2001 clupu        Merged multiple headers into ShimHook.h
    08/13/2001 robkenny     Cleaned up, readied for publishing.

--*/

#pragma once

#ifndef _SHIM_HOOK_H_
#define _SHIM_HOOK_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntldr.h>
#include <ntddscsi.h>

#include <windows.h>
// Disable warning C4201: nonstandard extension used : nameless struct/union
// Allows shims to be compiled at Warning Level 4
#pragma warning ( disable : 4201 ) 
#include <mmsystem.h>
#pragma warning ( default : 4201 ) 
#include <WinDef.h>

#ifdef __cplusplus
extern "C" {
#endif
    #include <shimdb.h>
#ifdef __cplusplus
}
#endif



namespace ShimLib
{
/*++

  Globals
  
--*/

extern HINSTANCE    g_hinstDll;         // The Shim's dll handle
extern BOOL         g_bMultiShim;       // Does this dll handle multiple shims?
extern DWORD        g_dwShimVersion;    //



/*++

  Typedefs and enums
  
--*/

typedef struct tagSHIM_COM_HOOK
{
    CLSID*              pCLSID;
    IID*                pIID;
    DWORD               dwVtblIndex;
    PVOID               pfnNew;
    PVOID               pfnOld;
} SHIM_COM_HOOK, *PSHIM_COM_HOOK;

typedef struct tagSHIM_IFACE_FN_MAP
{
    PVOID               pVtbl;
    PVOID               pfnNew;
    PVOID               pfnOld;
    PVOID               pNext;
} SHIM_IFACE_FN_MAP, *PSHIM_IFACE_FN_MAP;

typedef struct tagSHIM_HOOKED_OBJECT
{
    PVOID               pThis;
    CLSID*              pCLSID;
    DWORD               dwRef;
    BOOL                bAddRefTrip;
    BOOL                bClassFactory;
    PVOID               pNext;
} SHIM_HOOKED_OBJECT, *PSHIM_HOOKED_OBJECT;


/*++

  Prototypes
  
--*/


//  These declarations are needed to hook all known exported APIs that return a COM object.
PVOID       LookupOriginalCOMFunction( PVOID pVtbl, PVOID pfnNew, BOOL bThrowExceptionIfNull );
void        DumpCOMHooks();
void        InitializeHooks(DWORD fdwReason);
PHOOKAPI    InitializeHooksEx(DWORD, LPWSTR, LPSTR, DWORD*);
VOID        HookObject(IN CLSID *pCLSID, IN REFIID riid, OUT LPVOID *ppv, OUT PSHIM_HOOKED_OBJECT pOb, IN BOOL bClassFactory );
VOID        HookCOMInterface(REFCLSID rclsid, REFIID riid, LPVOID * ppv, BOOL bClassFactory);
VOID        AddComHook(REFCLSID clsid, REFIID iid, PVOID hook, DWORD vtblndx);


};  // end of namespace ShimLib



/*++

  Defines
  
--*/

#define IMPLEMENT_SHIM_BEGIN(shim)                                              \
namespace NS_##shim                                                             \
{                                                                               \
    extern const CHAR * g_szModuleName;                                         \
    extern CHAR         g_szCommandLine[SHIM_COMMAND_LINE_MAX_BUFFER];          \
    extern PHOOKAPI     g_pAPIHooks;

#define IMPLEMENT_SHIM_STANDALONE(shim)                                         \
namespace NS_##shim                                                             \
{                                                                               \
    const CHAR * g_szModuleName;                                                \
    CHAR         g_szCommandLine[SHIM_COMMAND_LINE_MAX_BUFFER];                 \
    PHOOKAPI     g_pAPIHooks;                                                   \
                                                                                \
extern PHOOKAPI InitializeHooksMulti(                                           \
    DWORD fdwReason,                                                            \
    LPSTR pszCmdLine,                                                           \
    DWORD* pdwHookCount                                                         \
    );                                                                          \
}                                                                               \
                                                                                \
namespace ShimLib {                                                             \
VOID                                                                            \
InitializeHooks(DWORD fdwReason)                                                \
{                                                                               \
    g_dwShimVersion = 2;                                                        \
}                                                                               \
                                                                                \
PHOOKAPI                                                                        \
InitializeHooksEx(                                                              \
    DWORD fdwReason,                                                            \
    LPWSTR pwszShim,                                                            \
    LPSTR pszCmdLine,                                                           \
    DWORD* pdwHookCount                                                         \
    )                                                                           \
{                                                                               \
    using namespace NS_##shim;                                                  \
    return InitializeHooksMulti(                                                \
                fdwReason,                                                      \
                pszCmdLine,                                                     \
                pdwHookCount );                                                 \
}                                                                               \
}                                                                               \
namespace NS_##shim                                                             \
{                                                                               \

#define IMPLEMENT_SHIM_END                                                      \
};


/*++

  ShimLib specific include files
  
--*/

#include "ShimProto.h"
#include "ShimLib.h"


#endif // _SHIM_HOOK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimhapi.h ===
////////////////////////////////////////////////////////////////////////////////////
//
// File:    shim.h
//
// History:    May-99   clupu       Created.
//             Aug-99   v-johnwh    Various bug fixes.
//          23-Nov-99   markder     Support for multiple shim DLLs, chaining
//                                  of hooks. General clean-up.
//          11-Feb-00   markder     Reverted to W2K shipped shim structures.
// 
// Desc:    Contains all structure and function definitions for the shim mechanism.
//
////////////////////////////////////////////////////////////////////////////////////

#ifndef __SHIM_H__
#define __SHIM_H__

struct tagHOOKAPI;

typedef struct tagHOOKAPIEX {
    DWORD               dwShimID;
    struct tagHOOKAPI   *pTopOfChain;
    struct tagHOOKAPI   *pNext;
} HOOKAPIEX, *PHOOKAPIEX;

typedef struct tagHOOKAPI {
    
    char*   pszModule;                  // the name of the module
    char*   pszFunctionName;            // the name of the API in the module
    PVOID   pfnNew;                     // pointer to the new stub API
    PVOID   pfnOld;                     // pointer to the old API
    DWORD   dwFlags;                    // used internally - important info about status
    union {
        struct tagHOOKAPI *pNextHook;   // used internally - (obsolete -- old mechanism)
        PHOOKAPIEX pHookEx;             // used internally - pointer to an internal extended info struct
    };
} HOOKAPI, *PHOOKAPI;

/*
 * If the hook DLL ever patches LoadLibraryA/W it must call PatchNewModules
 * so that the shim knows to patch any new loaded DLLs
 */
typedef VOID (*PFNPATCHNEWMODULES)(VOID);

typedef PHOOKAPI (*PFNGETHOOKAPIS)(LPSTR pszCmdLine,
                                   PFNPATCHNEWMODULES pfnPatchNewModules,
                                   DWORD* pdwHooksCount);

#define SHIM_COMMAND_LINE_MAX_BUFFER 1024

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimlib.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ShimLib.h

 Abstract:

    Routines available in ShimLib.lib

 Notes:

    None

 History:

    08/13/2001  robkenny    Created.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.
    08/15/2001  robkenny    Merged several include files.
    09/11/2001  mnikkel     Modified DPFN and LOGN to retain LastError

--*/

#pragma once


#include <Windows.h>

// ***************************************************************************
// ***************************************************************************


namespace ShimLib
{


// Debug levels
typedef enum 
{    
    eDbgLevelBase  = 0,
    eDbgLevelError,
    eDbgLevelWarning,
    eDbgLevelInfo,
    eDbgLevelSpew = 9,
} DEBUGLEVEL;


extern BOOL         g_bFileLogEnabled;  // Is the LOG() routine logging to a file.



// Environment variable with the name of the log file
#define szFileLogEnvironmentVariable "SHIM_FILE_LOG"
#define wszFileLogEnvironmentVariable L"SHIM_FILE_LOG"

// Debug environment variable, values = 0 -> 9
#define szDebugEnvironmentVariable "SHIM_DEBUG_LEVEL"    


void        APPBreakPoint(void);
VOID        ShimLogList(LPCSTR szShimName, DEBUGLEVEL dwDbgLevel, LPCSTR pszFmt, va_list arglist);
VOID        ShimLog(    LPCSTR szShimName, DEBUGLEVEL dwDbgLevel, LPCSTR pszFmt, ...);

BOOL        InitFileLogSupport(char* pszShim);
VOID        __cdecl FileLog(DWORD dwDetail, LPSTR pszFmt, ...);


#if DBG
    VOID    DebugPrintfList(LPCSTR szShimName, DEBUGLEVEL dwDetail, LPCSTR szFmt, va_list vaArgList);
    VOID    DebugPrintf(    LPCSTR szShimName, DEBUGLEVEL dwDetail, LPCSTR szFmt, ...);
#endif


// ***************************************************************************
// ***************************************************************************

/*++

  Shim debug routines.
  
--*/

// Our own version of ASSERT

#ifdef ASSERT
#undef ASSERT
#endif

#if DBG
    VOID DebugAssert(LPCSTR szFile, DWORD dwLine, BOOL bAssert, LPCSTR szHelpString);

    #define ASSERT(a, b) DebugAssert(__FILE__, __LINE__, a, b)
#else
    #pragma warning(disable : 4002)
    #define ASSERT(a, b)
    #pragma warning(default : 4002)
#endif

inline void DPF(LPCSTR szShimName, DEBUGLEVEL dwDetail, LPSTR pszFmt, ...)
{
#if DBG
	// This must be the first line of this routine to preserve LastError.
	DWORD dwLastError = GetLastError();
	
    va_list vaArgList;
    va_start(vaArgList, pszFmt);

    DebugPrintfList(szShimName, dwDetail, pszFmt, vaArgList);

    va_end(vaArgList);

	// This must be the last line of this routine to preserve LastError.
	SetLastError(dwLastError); 
#else
    szShimName;
    dwDetail;
    pszFmt;
#endif
}

inline void LOG(LPCSTR szShimName, DEBUGLEVEL dwDetail, LPSTR pszFmt, ...)
{
    if (g_bFileLogEnabled)
    {
		// This must be the first line of this routine to preserve LastError.
		DWORD dwLastError = GetLastError();
		
        va_list vaArgList;
        va_start(vaArgList, pszFmt);

        ShimLogList(szShimName, dwDetail, pszFmt, vaArgList);

        va_end(vaArgList);
        
		// This must be the last line of this routine to preserve LastError.
		SetLastError(dwLastError);
	}
}

};  // end of namespace ShimLib


// ***************************************************************************
// ***************************************************************************
/*++

  The shim system uses its own heap.
  Malloc, free, new and delete are redirected to these routines:
  
--*/

namespace ShimLib
{
void *      __cdecl ShimMalloc(size_t size);
void        __cdecl ShimFree(void * memory);
void *      __cdecl ShimCalloc(size_t num, size_t size);
void *      __cdecl ShimRealloc(void * memory, size_t size);

};  // end of namespace ShimLib

// We override malloc/free with our own versions using a private heap.
#define malloc(size)            ShimLib::ShimMalloc(size)
#define free(memory)            ShimLib::ShimFree(memory)
#define calloc(num, size)       ShimLib::ShimCalloc(num, size)
#define realloc(memory, size)   ShimLib::ShimRealloc(memory, size)


inline void * __cdecl operator new(size_t size)
{
    return ShimLib::ShimMalloc(size);
}

inline void * operator new[]( size_t size )
{
    return ShimLib::ShimMalloc(size);
}

inline void __cdecl operator delete(void * memory)
{
    ShimLib::ShimFree(memory);
}

inline void operator delete[]( void * memory )
{
    ShimLib::ShimFree(memory);
}




#include "ShimCString.h"


// ***************************************************************************
// ***************************************************************************
/*++

  ShimLib routines
  
--*/
namespace ShimLib
{

/*++

  Prototypes for various helper routines.
  
--*/

PVOID       HookCallback( PVOID pfnOld, PVOID pfnNew );

UINT        GetDriveTypeFromHandle(HANDLE hFile);
UINT        GetDriveTypeFromFileNameA(LPCSTR lpFileName, char *lpDriveLetter = NULL);
UINT        GetDriveTypeFromFileNameW(LPCWSTR lpFileName, WCHAR *lpDriveLetter = NULL);
inline BOOL IsOnCDRom(HANDLE hFile) { return GetDriveTypeFromHandle(hFile) == DRIVE_CDROM; }
inline BOOL IsOnCDRomA(LPCSTR lpFileName) { return GetDriveTypeFromFileNameA(lpFileName) == DRIVE_CDROM; }
inline BOOL IsOnCDRomW(LPCWSTR lpFileName) { return GetDriveTypeFromFileNameW(lpFileName) == DRIVE_CDROM; }

BOOL        IsImage16BitA(LPCSTR lpFileName);
BOOL        IsImage16BitW(LPCWSTR lpFileName);

WCHAR *     ToUnicode(const char * lpszAnsi);
char *      ToAnsi(const WCHAR * lpszUnicode);

LPWSTR *    _CommandLineToArgvW(LPCWSTR lpCmdLine, int * pNumArgs);
LPSTR *     _CommandLineToArgvA(LPCSTR lpCmdLine,  int * pNumArgs);

char *      StringDuplicateA(const char * strToCopy);
WCHAR *     StringDuplicateW(const WCHAR * wstrToCopy);
char *      StringNDuplicateA(const char * strToCopy, int stringLength);
WCHAR *     StringNDuplicateW(const WCHAR * wstrToCopy, int stringLength);

int         SafeStringCopyW(WCHAR *lpDest, DWORD nDestChars, const WCHAR *lpSrc, DWORD nSrcChars);

VOID        SkipBlanksW(const WCHAR *& str);

BOOL        PatternMatchW(LPCWSTR szPattern, LPCWSTR szTestString);


// stristr is *not* DBCS safe
char *      __cdecl stristr(const char* string, const char * strCharSet);

WCHAR *     __cdecl wcsistr(const WCHAR* string, const WCHAR * strCharSet);
char *      __cdecl _strtok(char *strToken, const char *strDelimit);


BOOL        bIsSafeDisc1();
BOOL        bIsSafeDisc2();

BOOL        IsNTVDM(void);


WCHAR *     W9xPathMassageW(const WCHAR * uncorrect);

BOOL        MakeShimUnloadLast(HMODULE hMod);

DEBUGLEVEL  GetDebugLevel(void);

};  // end of namespace ShimLib



// ***************************************************************************
// ***************************************************************************
/*++

  AppAndCommandLine is a class used to parse lpApplicationName and lpCommandline
  exactly as it would be by CreateProcess().

--*/

namespace ShimLib
{

class AppAndCommandLine
{
protected:
    CString          csApplicationName;
    CString          csCommandLine;
    CString          csCommandLineNoAppName;
    CString          csShortCommandLine;

    BOOL             GetAppnameAndCommandline(const WCHAR * lpcApp, const WCHAR * lpcCl);

public:
    AppAndCommandLine(const char * lpcApplicationName, const char * lpcCommandLine);
    AppAndCommandLine(const WCHAR * lpcApplicationName, const WCHAR * lpcCommandLine);

    inline const CString &     GetApplicationName() const;
    inline const CString &     GetCommandline() const;
    inline const CString &     GetCommandlineNoAppName() const;

    const CString &            GetShortCommandLine();
};


inline const CString & AppAndCommandLine::GetApplicationName() const
{
    return csApplicationName;
}

inline const CString & AppAndCommandLine::GetCommandline() const
{
    return csCommandLine;
}

inline const CString & AppAndCommandLine::GetCommandlineNoAppName() const
{
    return csCommandLineNoAppName;
}



};  // end of namespace ShimLib


// ***************************************************************************
// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimpatch.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993-1998
//
// File:        ldrpatch.h
//
// Contents:    Patch data structures
//
// History:     13-Oct-99   v-johnwh        created
//              15-Feb-00   markder         Changed CHARs to WCHARs
//
//---------------------------------------------------------------------------

#ifndef _LDRPATCH_H_
#define _LDRPATCH_H_

typedef struct _PATCHOP
{
   DWORD dwOpcode;        // opcode to be performed
   DWORD dwNextOpcode;    // relative offset to next opcode
   #pragma warning( disable : 4200 )
      BYTE data[];        //data for this operation type is dependent on the operation code
   #pragma warning( default : 4200 )
} PATCHOP, *PPATCHOP;

typedef struct _RELATIVE_MODULE_ADDRESS
{
   DWORD address;        //relative address from beginning of loaded module
   BYTE  reserved[3];    //reserved for system use
   WCHAR moduleName[32]; //module name for this address.
} RELATIVE_MODULE_ADDRESS, *PRELATIVE_MODULE_ADDRESS;

typedef struct _PATCHWRITEDATA
{
   DWORD dwSizeData;     //size of patch data in bytes
   RELATIVE_MODULE_ADDRESS rva; //relative address where this patch data is to be applied.
   #pragma warning( disable : 4200 )
      BYTE data[];     //patch data bytes.
   #pragma warning( default : 4200 )
} PATCHWRITEDATA, *PPATCHWRITEDATA;

typedef struct _PATCHMATCHDATA
{
   DWORD dwSizeData;     //size of matching data data in bytes
   RELATIVE_MODULE_ADDRESS rva; //relative address where this patch data is to be verified.
   #pragma warning( disable : 4200 )
      BYTE data[];     //Matching data bytes.
   #pragma warning( default : 4200 )
} PATCHMATCHDATA, *PPATCHMATCHDATA;

typedef struct _SETACTIVATEADDRESS
{
   RELATIVE_MODULE_ADDRESS rva; //relative address where this patch data is to be applied.
} SETACTIVATEADDRESS, *PSETACTIVATEADDRESS;

typedef struct _HOOKPATCHINFO
{
   DWORD dwHookAddress;                // Address of a hooked function
   PSETACTIVATEADDRESS pData;          // Pointer to the real patch data
   PVOID pThunkAddress;                // Pointer to the call thunk
   struct _HOOKPATCHINFO *pNextHook;      
} HOOKPATCHINFO, *PHOOKPATCHINFO;

typedef enum _PATCHOPCODES
{
   PEND = 0, //no more opcodes
   PSAA,     //Set Activate Address, SETACTIVATEADDRESS
   PWD,      //Patch Write Data, PATCHWRITEDATA
   PNOP,     //No Operation
   PMAT,     //Patch match the matching bytes but do not replace the bytes.
} PATCHOPCODES;

#endif //_LDRPATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\stdexts.c ===
/****************************** Module Header ******************************\
* Module Name: stdexts.c
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdexts.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
DWORD                   dwCurrentPc;
WINDBG_EXTENSION_APIS  *lpExtensionApis;
#ifdef KERNEL
DWORD                   dwProcessor;
#endif // KERNEL

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit()
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }
    return fCtrlCHit;
}



VOID moveBlock(
PVOID pdst,
PVOID src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem((DWORD_PTR)src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}



BOOL tryMoveBlock(
PVOID pdst,
PVOID src,
DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem((DWORD_PTR)src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }
    return(fSuccess);
}



VOID moveExp(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            fSuccess = tryMoveBlock(&dwGlobal, (PVOID)dwGlobal, sizeof(DWORD));
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, (PVOID)dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExp(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    DWORD_PTR addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, (PVOID)addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
PVOID pdst,
LPSTR pszExp)
{
    DWORD dw;
    DWORD_PTR addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, (PVOID)addr)) {
            *((PDWORD)pdst) = dw;
            return(TRUE);
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return(FALSE);
}


BOOL tryMoveExpPtr(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dwGlobal;
    BOOL fSuccess = TRUE;

    try {
        dwGlobal = (DWORD_PTR)EvalExp(pszExp);
#ifndef KERNEL
        if (IsWinDbg()) {
            if (!tryMove(dwGlobal, (PVOID)dwGlobal)) {
                DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) failed.\n", pszExtName, pdst, pszExp);
                fSuccess = FALSE;
            }
        }
#endif // !KERNEL
        *((PDWORD_PTR)pdst) = dwGlobal;
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }
    return(fSuccess);
}


VOID moveExpValuePtr(
PVOID pdst,
LPSTR pszExp)
{
    DWORD_PTR dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, (PVOID)dw, sizeof(dw))) {
            *((PDWORD_PTR)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


/***************************************************************************
 * Common command parsing stuff                                            *
 ***************************************************************************/
PVOID EvalExp(
LPSTR psz)
{
    PVOID p;

    p = (PVOID)(lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == NULL) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }
    return p;
}



PVOID OptEvalExp(
LPSTR psz)
{
    while (*psz == ' ')
        psz++;
    if (*psz == '\0') {
        return(NULL);
    }
    return(EvalExp(psz));
}



PVOID OptEvalExp2(
LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    PVOID dwRet = NULL;

    while (*psz == ' ')
        psz++;
    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;
    return(dwRet);
}



DWORD StringToOpts(
LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return(OPTS_ERROR);     // any non-letter option is an error.
        }
        psz++;
    }
    return(opts);
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
LPSTR *ppszArgs,
LPSTR pszLegalArgs) // OPTIONAL
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return(Opts);
        }
    }
    return(Opts);
}



VOID PrintHuge(
LPSTR psz)
{
    /*
     * Looks like this is faulting these days - Print seems to be fixed
     * so I'm leaving this entry point for compatibility. (SAS)
     */
#ifdef ITWORKS
#define HUNK_SIZE   400
    int cch;
    CHAR chSave;

    /*
     * since dorky Print extension can't handle very long strings,
     * break it up into peices for it to chew.
     */
    cch = strlen(psz);
    while (cch > HUNK_SIZE) {
        chSave = psz[HUNK_SIZE];
        psz[HUNK_SIZE] = '\0';
        Print(psz);
        psz[HUNK_SIZE] = chSave;
        psz += HUNK_SIZE;
        cch -= HUNK_SIZE;
    }
#endif
    Print(psz);
}



/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
PVOID pFunction,
LPSTR pszName,
int type,
LPSTR pszLegalOpts,
HANDLE hcp,
HANDLE hct,
DWORD dwcp,
#ifdef KERNEL
DWORD dwp,
#else // !KERNEL
PWINDBG_EXTENSION_APIS lpea,
#endif // !KERNEL
LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    PVOID param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
#ifdef KERNEL
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;
#else // !KERNEL
    lpExtensionApis = lpea;
#endif // !KERNLE

#if 0
    DEBUGPRINT("CommonEP(%x, \"%s\", %d, \"%s\", %x, %x, %x, %x, \"%s\")\n",
            pFunction,
            pszName,
            type,
            pszLegalOpts,
            hcp,
            hct,
            dwcp,
#ifdef KERNEL
            dwp,
#else // !KERNLE
            lpea,
#endif // !KERNEL
            lpas);
#endif

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#ifdef KERNEL
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    DWORD dwcp,                                         \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#else // !KERNEL
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    DWORD dwcp,                                         \
    PWINDBG_EXTENSION_APIS lpea,                        \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, lpea, lpas); \
}
#endif // !KERNEL
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ')
        lpas++;

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                PrintHuge(he[i].pszHelp2);
            }
        }
        return(TRUE);
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                PrintHuge(he[i].pszHelp2);
                return(TRUE);
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimproto.h ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    ShimProto.h

 Abstract:

    Definitions for use by all modules

 Notes:

    None

 History:

    12/09/1999 robkenny Created
    01/10/2000 linstev  Format to new style
    08/16/2000 prashkud Added VFW header file.
    08/22/2000 a-brienw Added winmm.h, mciSendCommand,
                        and mciSendString    
    11/17/2000 mnikkel  Added GetObjectA
    11/29/2000 andyseti Added DirectPlay
    02/02/2001 a-leelat Added ScreenToClient
    03/07/2001 mnikkel  Added GetLastError
    03/19/2001 a-leelat Added PdhAddCounter
    05/17/2001 prashkud Added MsiGetProperty
    05/21/2001 mnikkel  Added PrintDlgA
    12/14/2001 hioh     Added ImmAssociateContext

--*/

#ifndef _SHIMPROTO_H_
#define _SHIMPROTO_H_

#include <tapi.h>
#include <dinput.h>
#include <dplay.h>
#include <vfw.h>
#include <winmm.h>
#include <pdh.h>
#include <ras.h>
#include <Softpub.h>
#include <WinCrypt.h>
#include <WinTrust.h>
#include <ImageHlp.h>
#include <iphlpapi.h>
#include <winerror.h>
#include <shellapi.h>
#include <shlobj.h>
#include <ole2.h>
#include <ddraw.h>
#include <dsound.h>
#include <commdlg.h>
#include <winspool.h>
#include <msi.h>

typedef BOOL        (WINAPI *_pfn_DeviceIoControl)(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);
typedef BOOL        (WINAPI *_pfn_CloseHandle)( HANDLE hObject );
typedef UINT        (WINAPI *_pfn_SetHandleCount)(UINT uNewCount);
typedef NTSTATUS    (WINAPI *_pfn_NtClose)(HANDLE Handle);
typedef BOOL        (WINAPI *_pfn_DuplicateHandle)( HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions );
typedef BOOL        (WINAPI *_pfn_CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL        (WINAPI *_pfn_CreateProcessW)(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL        (WINAPI *_pfn_CreateProcessAsUserA)(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef BOOL        (WINAPI *_pfn_CreateProcessAsUserW)(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
typedef NTSTATUS    (WINAPI *_pfn_NtCreateProcessEx)(PHANDLE ProcessHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ParentProcess, ULONG Flags, HANDLE SectionHandle, HANDLE DebugPort, HANDLE ExceptionPort, ULONG JobMemberLevel);
typedef HANDLE      (WINAPI *_pfn_CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
typedef VOID        (WINAPI *_pfn_ExitThread)(DWORD dwExitCode);
typedef BOOL        (WINAPI *_pfn_TerminateThread)(HANDLE hThread, DWORD dwExitCode);
typedef BOOL        (WINAPI *_pfn_SetThreadPriority)(HANDLE hThread, int nPriority);
typedef BOOL        (WINAPI *_pfn_SetPriorityClass)(HANDLE hProcess, DWORD dwPriorityClass);
typedef HANDLE      (WINAPI *_pfn_CreateSemaphoreA)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_CreateSemaphoreW)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
typedef HWND        (WINAPI *_pfn_CreateWindowA)(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef HWND        (WINAPI *_pfn_CreateWindowW)(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef HWND        (WINAPI *_pfn_CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef HWND        (WINAPI *_pfn_CreateWindowExW)(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
typedef BOOL        (WINAPI *_pfn_DestroyWindow)(HWND hWnd);
typedef HWND        (WINAPI *_pfn_GetFocus)(VOID);
typedef BOOL        (WINAPI *_pfn_EnumChildWindows)(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);
typedef ATOM        (WINAPI *_pfn_RegisterClassA)(CONST WNDCLASSA *lpWndClass);
typedef ATOM        (WINAPI *_pfn_RegisterClassW)(CONST WNDCLASSW *lpWndClass);
typedef ATOM        (WINAPI *_pfn_RegisterClassExA)(CONST WNDCLASSEXA *lpWndClass);
typedef ATOM        (WINAPI *_pfn_RegisterClassExW)(CONST WNDCLASSEXW *lpWndClass);
typedef BOOL        (WINAPI *_pfn_GetClassInfoA)(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass);
typedef UINT        (WINAPI *_pfn_GetDlgItemTextA)(HWND hDlg, int nIDDlgItem, LPSTR lpString, int nMaxCount);
typedef BOOL        (WINAPI *_pfn_SetDlgItemTextA)(HWND hWnd, int nIDDlgItem, LPCSTR lpString);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef INT_PTR     (WINAPI *_pfn_DialogBoxIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogParamA)(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogParamW)(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogIndirectParamA)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogIndirectParamW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef HWND        (WINAPI *_pfn_CreateDialogIndirectParamAorW)(HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM lInitParam);
typedef BOOL        (WINAPI *_pfn_EndDialog)(HWND hDlg, int nResult);
typedef HWND        (WINAPI *_pfn_SetFocus)(HWND hwnd);
typedef DWORD       (WINAPI *_pfn_GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
typedef WORD        (WINAPI *_pfn_GetClassWord)(HWND hWnd, int nIndex);
typedef WORD        (WINAPI *_pfn_GetWindowWord)(HWND hWnd, int nUnknown);
typedef WORD        (WINAPI *_pfn_SetWindowWord)(HWND hWnd, int nUnknown, WORD wUnknown);
typedef HWND        (WINAPI *_pfn_GetSysModalWindow)(void);
typedef HWND        (WINAPI *_pfn_SetSysModalWindow)(HWND hWnd);
                    
typedef BOOL        (WINAPI *_pfn_GetMenuItemInfoA)(HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFO lpmii);
typedef BOOL        (WINAPI *_pfn_GetMenuItemInfoW)(HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFO lpmii);
                    
typedef BOOL        (WINAPI *_pfn_CopyFileA)( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
typedef BOOL        (WINAPI *_pfn_CopyFileW)( LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
typedef BOOL        (WINAPI *_pfn_CopyFileExA)( LPCSTR lpExistingFileName,LPCSTR lpNewFileName,LPPROGRESS_ROUTINE lpProgressRoutine,LPVOID lpData,LPBOOL pbCancel,DWORD dwCopyFlags );
typedef BOOL        (WINAPI *_pfn_CopyFileExW)( LPCWSTR lpExistingFileName,LPCWSTR lpNewFileName,LPPROGRESS_ROUTINE lpProgressRoutine,LPVOID lpData,LPBOOL pbCancel,DWORD dwCopyFlags );
typedef BOOL        (WINAPI *_pfn_CreateDirectoryA)( LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreateDirectoryW)( LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreateDirectoryExA)( LPCSTR lpTemplateDirectory,LPCSTR lpNewDirectory,LPSECURITY_ATTRIBUTES lpSecurityAttributes );
typedef BOOL        (WINAPI *_pfn_CreateDirectoryExW)( LPCWSTR lpTemplateDirectory,LPCWSTR lpNewDirectory,LPSECURITY_ATTRIBUTES lpSecurityAttributes );
typedef DWORD       (WINAPI *_pfn_GetCurrentDirectoryA)(DWORD nBufferLength, LPSTR lpBuffer);
typedef DWORD       (WINAPI *_pfn_GetCurrentDirectoryW)(DWORD nBufferLength, LPWSTR lpBuffer);
typedef BOOL        (WINAPI *_pfn_DeleteFileA)( LPCSTR lpFileName );
typedef BOOL        (WINAPI *_pfn_DeleteFileW)( LPCWSTR lpFileName );
typedef NTSTATUS    (WINAPI *_pfn_NtDeleteFile)(POBJECT_ATTRIBUTES ObjectAttributes);
typedef BOOL        (WINAPI *_pfn_FreeLibrary)( HMODULE hModule );
typedef BOOL        (WINAPI *_pfn_FreeResource)(HGLOBAL hMem);
typedef BOOL        (WINAPI *_pfn_GetBinaryTypeA)( LPCSTR lpApplicationName, LPDWORD lpBinaryType);
typedef BOOL        (WINAPI *_pfn_GetBinaryTypeW)( LPCWSTR lpApplicationName, LPDWORD lpBinaryType);
typedef DWORD       (WINAPI *_pfn_GetFullPathNameA)( LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
typedef DWORD       (WINAPI *_pfn_GetFullPathNameW)( LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
typedef DWORD       (WINAPI *_pfn_GetShortPathNameA)(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer );
typedef DWORD       (WINAPI *_pfn_GetShortPathNameW)(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer );
typedef BOOL        (WINAPI *_pfn_MoveFileA)(LPCSTR lpExistingFileName,  LPCSTR lpNewFileName);
typedef BOOL        (WINAPI *_pfn_MoveFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
typedef BOOL        (WINAPI *_pfn_MoveFileExA)(LPCSTR lpExistingFileName, LPCSTR lpNewNewFileName, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewNewFileName, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_MoveFileWithProgressA)(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_MoveFileWithProgressW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
typedef BOOL        (WINAPI *_pfn_ReplaceFileA)(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
typedef BOOL        (WINAPI *_pfn_ReplaceFileW)(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved);
                    
typedef DWORD       (WINAPI *_pfn_WNetAddConnectionA)(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName);
typedef DWORD       (WINAPI *_pfn_WNetAddConnectionW)(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName);
                    
typedef BOOL        (WINAPI *_pfn_SetCurrentDirectoryA)(LPCSTR lpPathName);
typedef BOOL        (WINAPI *_pfn_SetCurrentDirectoryW)(LPCWSTR lpPathName);
typedef HFILE       (WINAPI *_pfn_OpenFile)(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);
typedef NTSTATUS    (WINAPI *_pfn_NtOpenFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, ULONG ShareAccess, ULONG OpenOptions);
                    
typedef HFILE       (WINAPI *_pfn__lopen)(LPCSTR, int);
typedef HFILE       (WINAPI *_pfn__lcreat)(LPCSTR, int);
typedef LONG        (WINAPI *_pfn__hwrite)(HFILE hFile, LPCSTR lpBuffer, LONG lBytes);
typedef HFILE       (WINAPI *_pfn__lclose)(HFILE hFile);
typedef LONG        (WINAPI *_pfn__llseek)(HFILE hFile, LONG lOffset, int iOrigin);
typedef UINT        (WINAPI *_pfn__lread)(HFILE hFile, LPVOID lpBuffer, UINT uBytes);
typedef UINT        (WINAPI *_pfn__lwrite)(HFILE hFile, LPCSTR lpBuffer, UINT uBytes);
                    
typedef HANDLE      (WINAPI *_pfn_CreateFileA)( LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef HANDLE      (WINAPI *_pfn_CreateFileW)( LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
typedef NTSTATUS    (WINAPI *_pfn_NtCreateFile)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);
typedef HANDLE      (WINAPI *_pfn_CreateFileMappingA)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_CreateFileMappingW)(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
typedef HANDLE      (WINAPI *_pfn_OpenFileMappingA)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_OpenFileMappingW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
typedef PVOID       (WINAPI *_pfn_MapViewOfFile)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap);
typedef PVOID       (WINAPI *_pfn_MapViewOfFileEx)(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, DWORD dwNumberOfBytesToMap, LPVOID lpBaseAddress);
typedef BOOL        (WINAPI *_pfn_UnMapViewOfFile)(LPCVOID lpBaseAddress);
                    
typedef NTSTATUS    (WINAPI *_pfn_NtSetInformationFile)(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
                    
typedef VOID        (WINAPI *_pfn_LZClose)(INT hFile);
typedef LONG        (WINAPI *_pfn_LZCopy)(INT hSource, INT hDest);
typedef void        (WINAPI *_pfn_LZDone)(void);
typedef INT         (WINAPI *_pfn_LZInit)(INT hfSource);
typedef INT         (WINAPI *_pfn_LZOpenFile)(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);
typedef INT         (WINAPI *_pfn_LZRead)(INT hFile, LPSTR lpBuffer, INT cbRead);
typedef LONG        (WINAPI *_pfn_LZSeek)(INT hFile, LONG lOffset, INT iOrigin);
typedef int         (WINAPI *_pfn_LZStart)(void);
typedef LONG        (WINAPI *_pfn_CopyLZFile)(int nUnknown1, int nUnknown2);
                    
typedef BOOL        (WINAPI *_pfn_DeleteFileA)( LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_DeleteFileW)( LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_DeleteObject)(HGDIOBJ hObject);
                    
typedef BOOL        (WINAPI *_pfn_ExitWindowsEx)( UINT uFlags, DWORD dwReserved );
typedef UINT_PTR    (WINAPI *_pfn_SetTimer)(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
typedef BOOL        (WINAPI *_pfn_FreeLibrary)(HMODULE hLibModule);
                    
typedef HANDLE      (WINAPI *_pfn_FindFirstFileA)     (LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
typedef HANDLE      (WINAPI *_pfn_FindFirstFileW)     (LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
typedef HANDLE      (WINAPI *_pfn_FindFirstFileExA)   (LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
typedef HANDLE      (WINAPI *_pfn_FindFirstFileExW)   (LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
typedef BOOL        (WINAPI *_pfn_FindNextFileA)      (HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
typedef BOOL        (WINAPI *_pfn_FindNextFileW)      (HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
typedef BOOL        (WINAPI *_pfn_FindClose)          (HANDLE hFindFile);
                    
typedef LPSTR       (WINAPI *_pfn_GetCommandLineA)(VOID);
typedef LPWSTR      (WINAPI *_pfn_GetCommandLineW)(VOID);
typedef BOOL        (WINAPI *_pfn_ReadProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead);
typedef BOOL        (WINAPI *_pfn_WriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesWritten);
typedef HMODULE     (WINAPI *_pfn_GetModuleHandleA)(LPCSTR lpModuleName);
typedef HMODULE     (WINAPI *_pfn_GetModuleHandleW)(LPCWSTR lpModuleName);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameExA)(HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetModuleFileNameExW)(HANDLE hProcess, HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
                    
typedef HRESULT     (WINAPI *_pfn_DllGetClassObject)( REFCLSID rclsid, REFIID riid, PVOID * ppv );
typedef HRESULT     (WINAPI *_pfn_DirectDrawCreate)(GUID FAR *lpGUID, LPVOID *lplpDD, IUnknown* pUnkOuter ); 
typedef HRESULT     (WINAPI *_pfn_DirectDrawCreateEx)(GUID FAR *lpGUID, LPVOID *lplpDD, REFIID iid, IUnknown* pUnkOuter );
typedef HRESULT     (WINAPI *_pfn_DirectInputCreateA)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTA *lplpDirectInput, LPUNKNOWN punkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectInputCreateW)(HINSTANCE hinst, DWORD dwVersion, LPDIRECTINPUTW *lplpDirectInput, LPUNKNOWN punkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectInputCreateEx)(HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID * ppvOut, LPUNKNOWN punkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectSoundCreate)(LPCGUID lpcGuid, LPDIRECTSOUND *ppDS, LPUNKNOWN pUnkOuter);
typedef HRESULT     (WINAPI *_pfn_DirectPlayCreate)(LPGUID lpGUIDSP, LPDIRECTPLAY *lplpDP, IUnknown *lpUnk);
                    
typedef BOOL        (WINAPI *_pfn_GetDiskFreeSpaceA)(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
typedef BOOL        (WINAPI *_pfn_GetDiskFreeSpaceW)(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters);
typedef DWORD       (WINAPI *_pfn_GetFileAttributesA)(LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetFileAttributesW)(LPCWSTR wcsFileName);
typedef BOOL        (WINAPI *_pfn_GetFileAttributesExA)(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
typedef BOOL        (WINAPI *_pfn_GetFileAttributesExW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
typedef NTSTATUS    (WINAPI *_pfn_NtQueryAttributesFile)(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_BASIC_INFORMATION FileInformation);
typedef NTSTATUS    (WINAPI *_pfn_NtQueryFullAttributesFile)(POBJECT_ATTRIBUTES ObjectAttributes, PFILE_NETWORK_OPEN_INFORMATION FileInformation);
typedef BOOL        (WINAPI *_pfn_GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION);
typedef DWORD       (WINAPI *_pfn_GetFileVersionInfoSizeA)( LPSTR lptstrFilename, LPDWORD lpdwHandle );
typedef DWORD       (WINAPI *_pfn_GetFileVersionInfoSizeW)( LPWSTR lptstrFilename, LPDWORD lpdwHandle );
typedef BOOL        (WINAPI *_pfn_GetFileVersionInfoA)( LPSTR lpstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef BOOL        (WINAPI *_pfn_GetFileVersionInfoW)( LPWSTR lpstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
typedef BOOL        (WINAPI *_pfn_SetFileAttributesA)(LPCSTR lpFileName, DWORD dwFileAttributes);
typedef BOOL        (WINAPI *_pfn_SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
                    
typedef DWORD       (WINAPI *_pfn_GetProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize);
typedef BOOL        (WINAPI *_pfn_WriteProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString);
typedef BOOL        (WINAPI *_pfn_WriteProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);
typedef BOOL        (WINAPI *_pfn_WriteProfileSectionA)(LPCSTR lpAppName, LPCSTR lpString);
typedef BOOL        (WINAPI *_pfn_WriteProfileSectionW)(LPCWSTR lpAppName, LPCWSTR lpString);
typedef UINT        (WINAPI *_pfn_GetProfileIntA)(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault);
typedef UINT        (WINAPI *_pfn_GetProfileIntW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
typedef UINT        (WINAPI *_pfn_GetPrivateProfileIntA)(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
typedef UINT        (WINAPI *_pfn_GetPrivateProfileIntW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetProfileSectionA)(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetProfileSectionW)(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionA)(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionW)(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionNamesA)(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileSectionNamesW)(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileStringA)( LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR  lpReturnedString, DWORD  nSize, LPCSTR lpFileName);
typedef DWORD       (WINAPI *_pfn_GetPrivateProfileStringW)( LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR  lpReturnedString, DWORD  nSize, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_GetPrivateProfileStructA)(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_GetPrivateProfileStructW)(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileSectionA)(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileSectionW)(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStringA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStringW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStructA)(LPCSTR lpAppName, LPCSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_WritePrivateProfileStructW)(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);
                    
typedef FARPROC     (WINAPI *_pfn_GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
typedef VOID        (WINAPI *_pfn_GetProcessorSpeed)(VOID);
typedef HANDLE      (WINAPI *_pfn_GetStdHandle)(DWORD nStdHandle);
                    
typedef DWORD       (WINAPI *_pfn_GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
typedef LPVOID      (WINAPI *_pfn_GetEnvironmentStrings)();
typedef LPVOID      (WINAPI *_pfn_GetEnvironmentStringsA)();
typedef LPVOID      (WINAPI *_pfn_GetEnvironmentStringsW)();
typedef BOOL        (WINAPI *_pfn_FreeEnvironmentStringsA)(LPSTR lpszEnvironmentBlock);
typedef BOOL        (WINAPI *_pfn_FreeEnvironmentStringsW)(LPWSTR lpszEnvironmentBlock);
typedef DWORD       (WINAPI *_pfn_ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_ExpandEnvironmentStringsW)(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
                    
typedef HPALETTE    (WINAPI *_pfn_CreatePalette)(CONST LOGPALETTE *lplgpl);
typedef UINT        (WINAPI *_pfn_SetPaletteEntries)(HPALETTE hpal, UINT iStart, UINT cEntries, CONST PALETTEENTRY *lppe);
typedef BOOL        (WINAPI *_pfn_AnimatePalette)(HPALETTE hpal, UINT iStartIndex, UINT cEntries, CONST PALETTEENTRY *ppe);
typedef BOOL        (WINAPI *_pfn_ResizePalette)(HPALETTE hpal, UINT nEntries);
typedef HDC         (WINAPI *_pfn_GetDC)(HWND hWnd);
typedef HDC         (WINAPI *_pfn_GetWindowDC)(HWND hWnd);
typedef HPALETTE    (WINAPI *_pfn_SelectPalette)(HDC hdc, HPALETTE hpal, BOOL bForceBackground);
typedef UINT        (WINAPI *_pfn_RealizePalette)(HDC hdc);
typedef UINT        (WINAPI *_pfn_SetSystemPaletteUse)(HDC hdc, UINT uUsage);
                    
typedef UINT        (WINAPI *_pfn_GetSystemPaletteEntries)( HDC hdc, UINT iStartIndex, UINT nEntries, LPPALETTEENTRY lppe);
typedef DWORD       (WINAPI *_pfn_GetVersion)();
typedef BOOL        (WINAPI *_pfn_GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
typedef BOOL        (WINAPI *_pfn_GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);
                    
typedef BOOL        (WINAPI *_pfn_InitializeSecurityDescriptor)( PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
typedef HRESULT     (WINAPI *_pfn_SafeArrayAccessData)(SAFEARRAY*, void HUGEP**);
                    
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryA)(LPCSTR lpLibFileName);
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryW)(LPCWSTR lpLibFileName);
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryExA)(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef HINSTANCE   (WINAPI *_pfn_LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
typedef DWORD       (WINAPI *_pfn_LoadModule)(LPCSTR lpModuleName, LPVOID lpParameterBlock);
typedef BOOL        (WINAPI *_pfn_LookupPrivilegeValueA)( LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid );
typedef BOOL        (WINAPI *_pfn_LookupPrivilegeValueW)( LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid );
                    
typedef int         (WINAPI *_pfn_MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
typedef int         (WINAPI *_pfn_MessageBoxW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
typedef int         (WINAPI *_pfn_MessageBoxExA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId);
typedef int         (WINAPI *_pfn_MessageBoxExW)(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId);
typedef BOOL        (WINAPI *_pfn_SetMessageQueue)(int nUnknown);
                    
typedef VOID        (WINAPI *_pfn_OutputDebugStringA)(LPCSTR lpOutputString);
typedef VOID        (WINAPI *_pfn_OutputDebugStringW)(LPCWSTR lpOutputString);
typedef void        (WINAPI *_pfn_SetDebugErrorLevel)(DWORD dwLevel);
                    
typedef LONG        (WINAPI *_pfn_RegConnectRegistryA)(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegConnectRegistryW)(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegCreateKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegCreateKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegCreateKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
typedef LONG        (WINAPI *_pfn_RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
typedef LONG        (WINAPI *_pfn_RegOpenKeyA)(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenKeyW)(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenKeyExA)(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
typedef LONG        (WINAPI *_pfn_RegOpenCurrentUser)(REGSAM samDesired, PHKEY phkResult);
typedef LONG        (WINAPI *_pfn_RegOpenUserClassesRoot)(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult);
typedef LONG        (WINAPI *_pfn_RegQueryValueA)(HKEY hkey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData);
typedef LONG        (WINAPI *_pfn_RegQueryValueW)(HKEY hkey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);
typedef LONG        (WINAPI *_pfn_RegQueryValueExA)(HKEY hkey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegQueryValueExW)(HKEY hkey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegEnumValueA)(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegEnumValueW)(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
typedef LONG        (WINAPI *_pfn_RegEnumKeyA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cbName);
typedef LONG        (WINAPI *_pfn_RegEnumKeyW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
typedef LONG        (WINAPI *_pfn_RegEnumKeyExA)(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
typedef LONG        (WINAPI *_pfn_RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
typedef LONG        (WINAPI *_pfn_RegQueryInfoKeyA)(HKEY hKey, LPSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
typedef LONG        (WINAPI *_pfn_RegQueryInfoKeyW)(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime); 
typedef LONG        (WINAPI *_pfn_RegCloseKey)(HKEY hkey);
typedef LONG        (WINAPI *_pfn_RegSetValueA)(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData);
typedef LONG        (WINAPI *_pfn_RegSetValueW)(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
typedef LONG        (WINAPI *_pfn_RegSetValueExA)(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData);
typedef LONG        (WINAPI *_pfn_RegSetValueExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE * lpData, DWORD cbData);
typedef NTSTATUS    (WINAPI *_pfn_NtSetValueKey)(HANDLE KeyHandle, PUNICODE_STRING ValueName, ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize);
typedef NTSTATUS    (WINAPI *_pfn_NtQueryValueKey)(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
typedef LONG        (WINAPI *_pfn_RegDeleteKeyA)(HKEY hKey,LPCSTR lpSubKey);
typedef LONG        (WINAPI *_pfn_RegDeleteKeyW)(HKEY hKey,LPCWSTR lpSubKey);
typedef LONG        (WINAPI *_pfn_RegDeleteValueA)(HKEY hKey, LPCSTR lpValueName);
typedef LONG        (WINAPI *_pfn_RegDeleteValueW)(HKEY hKey, LPCWSTR lpValueName);
                    
typedef SC_HANDLE   (WINAPI *_pfn_CreateServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, LPCSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword);
typedef SC_HANDLE   (WINAPI *_pfn_CreateServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, LPCWSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCWSTR lpBinaryPathName, LPCWSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCWSTR lpDependencies, LPCWSTR lpServiceStartName, LPCWSTR lpPassword);
typedef SC_HANDLE   (WINAPI *_pfn_OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
typedef SC_HANDLE   (WINAPI *_pfn_OpenServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
typedef BOOL        (WINAPI *_pfn_QueryServiceStatus)(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
typedef BOOL        (WINAPI *_pfn_QueryServiceConfigA)(SC_HANDLE hService, LPQUERY_SERVICE_CONFIGA lpServiceConfig, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
typedef BOOL        (WINAPI *_pfn_ChangeServiceConfigA)(SC_HANDLE hService, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCSTR lpBinaryPathName, LPCSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCSTR lpDependencies, LPCSTR lpServiceStartName, LPCSTR lpPassword, LPCSTR lpDisplayName);
typedef BOOL        (WINAPI *_pfn_CloseServiceHandle)(SC_HANDLE hSCObject);
                    
typedef int         (WINAPI *_pfn_ReleaseDC)(HWND hWnd, HDC hdc);
                    
typedef DWORD       (WINAPI *_pfn_GetEnvironmentVariableA)(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
typedef DWORD       (WINAPI *_pfn_GetEnvironmentVariableW)(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
                    
typedef BOOL        (WINAPI *_pfn_RemoveDirectoryA)(LPCSTR lpFileName);
typedef BOOL        (WINAPI *_pfn_RemoveDirectoryW)(LPCWSTR lpFileName);
                    
typedef LPVOID      (WINAPI *_pfn_VirtualAlloc)(LPVOID lpAddress, DWORD dwSize, DWORD flAllocationType, DWORD flProtect);
typedef BOOL        (WINAPI *_pfn_VirtualFree)(LPVOID lpAddress, DWORD dwSize, DWORD dwFreeType);
typedef BOOL        (WINAPI *_pfn_VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
                    
typedef DWORD       (WINAPI *_pfn_CreateIpForwardEntry)(PMIB_IPFORWARDROW pRoute);
typedef DWORD       (WINAPI *_pfn_GetIpForwardTable)(PMIB_IPFORWARDTABLE pIpForwardTable, PULONG pdwSize, BOOL bOrder);
                    
typedef PVOID       (WINAPI *_pfn_RtlAllocateHeap)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);
typedef BOOLEAN     (WINAPI *_pfn_RtlFreeHeap)(HANDLE HeapHandle, DWORD Flags, LPVOID lpMem);
typedef DWORD       (WINAPI *_pfn_RtlSizeHeap)(HANDLE HeapHandle, DWORD Flags, LPCVOID lpMem);
typedef PVOID       (WINAPI *_pfn_RtlReAllocateHeap)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, DWORD dwBytes);
typedef HANDLE      (WINAPI *_pfn_HeapCreate)(DWORD flOptions, DWORD dwInitialSize, DWORD dwMaximumSize);
typedef BOOL        (WINAPI *_pfn_HeapDestroy)(HANDLE hHeap);
typedef UINT        (WINAPI *_pfn_HeapCompact)(HANDLE hHeap, DWORD dwFlags);
typedef HGLOBAL     (WINAPI *_pfn_GlobalAlloc)(UINT uFlags, SIZE_T uBytes);
typedef HLOCAL      (WINAPI *_pfn_LocalAlloc)(UINT uFlags, SIZE_T uBytes);
typedef UINT        (WINAPI *_pfn_LocalCompact)(UINT uUnknown);
typedef HLOCAL      (WINAPI *_pfn_LocalDiscard)(HLOCAL hlocMem);
typedef HLOCAL      (WINAPI *_pfn_LocalReAlloc)(HLOCAL,SIZE_T,UINT);
typedef UINT        (WINAPI *_pfn_LocalShrink)(HLOCAL hMem, UINT uUnknown);
typedef HGLOBAL     (WINAPI *_pfn_GlobalReAlloc)(HGLOBAL,SIZE_T,UINT);
typedef DWORD       (WINAPI *_pfn_GlobalCompact)(DWORD);
typedef void        (WINAPI *_pfn_GlobalFix)(HGLOBAL hMem);
typedef UINT        (WINAPI *_pfn_GlobalFlags)(HGLOBAL hMem);
typedef HGLOBAL     (WINAPI *_pfn_GlobalFree)(HGLOBAL hMem);
typedef void        (WINAPI *_pfn_GlobalUnfix)(HGLOBAL hMem);
typedef BOOL        (WINAPI *_pfn_GlobalUnWire)(HGLOBAL hMem);
typedef char FAR*   (WINAPI *_pfn_GlobalWire)(HGLOBAL hMem);
                    
typedef HLOCAL      (WINAPI *_pfn_LocalFree)(HLOCAL hMem);
typedef LPVOID      (WINAPI *_pfn_VirtualAlloc)(LPVOID, DWORD ,DWORD, DWORD);
typedef BOOL        (WINAPI *_pfn_VirtualFree)(LPVOID, DWORD, DWORD);
                    
typedef BOOL        (WINAPI *_pfn_HeapValidate)(HANDLE, DWORD, LPCVOID);
typedef BOOL        (WINAPI *_pfn_HeapWalk)(HANDLE, LPPROCESS_HEAP_ENTRY);
typedef BOOL        (WINAPI *_pfn_HeapLock)(HANDLE);
typedef BOOL        (WINAPI *_pfn_HeapUnlock)(HANDLE);
typedef LPVOID      (WINAPI *_pfn_LocalLock)(HLOCAL);
typedef BOOL        (WINAPI *_pfn_LocalUnlock)(HLOCAL);
typedef HANDLE      (WINAPI *_pfn_LocalHandle)(LPCVOID);
typedef UINT        (WINAPI *_pfn_LocalSize)(HLOCAL);
typedef UINT        (WINAPI *_pfn_LocalFlags)(HLOCAL);
typedef HGLOBAL     (WINAPI *_pfn_GlobalFree)(HGLOBAL hMem);
typedef LPVOID      (WINAPI *_pfn_GlobalLock)(HGLOBAL);
typedef BOOL        (WINAPI *_pfn_GlobalUnlock)(HGLOBAL);
typedef HANDLE      (WINAPI *_pfn_GlobalHandle)(LPCVOID);
typedef UINT        (WINAPI *_pfn_GlobalSize)(HGLOBAL);
typedef UINT        (WINAPI *_pfn_GlobalFlags)(HGLOBAL);
typedef VOID        (__cdecl *_pfn_free)(VOID* pMem);
typedef COLORREF    (WINAPI *_pfn_SetBkColor)(HDC hdc, COLORREF crColor);
typedef LONG        (WINAPI *_pfn_SetClassLongA)(HWND hWnd, int nIndex, LONG dwnewLong);
typedef WORD        (WINAPI *_pfn_SetClassWord)(HWND hWnd, int nIndex, WORD wNewWord);
typedef COLORREF    (WINAPI *_pfn_SetTextColor)(HDC hdc, COLORREF crColor);
typedef LONG        (WINAPI *_pfn_SetWindowLongA)(HWND hWnd, int nIndex, LONG dwnewLong);
typedef LONG        (WINAPI *_pfn_SetWindowLongW)(HWND hWnd, int nIndex, LONG dwnewLong);
typedef BOOL        (WINAPI *_pfn_MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
typedef BOOL        (WINAPI *_pfn_SetWindowPos)( HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags );
                    
typedef HINSTANCE   (WINAPI *_pfn_ShellExecuteA)(HWND hwnd, LPCSTR lpVerb, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
typedef HINSTANCE   (WINAPI *_pfn_ShellExecuteW)(HWND hwnd, LPCWSTR lpVerb, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
typedef BOOL        (WINAPI *_pfn_ShellExecuteExA)(LPSHELLEXECUTEINFOA lpExecInfo);
typedef BOOL        (WINAPI *_pfn_ShellExecuteExW)(LPSHELLEXECUTEINFOW lpExecInfo);
                    
typedef BOOL        (WINAPI *_pfn_SHGetPathFromIDListA)(LPCITEMIDLIST pidl, LPSTR pszPath);
typedef BOOL        (WINAPI *_pfn_SHGetPathFromIDListW)(LPCITEMIDLIST pidl, LPWSTR pszPath);
typedef int         (WINAPI *_pfn_SHFileOperationA)(LPSHFILEOPSTRUCTA lpFileOp);
typedef int         (WINAPI *_pfn_SHFileOperationW)(LPSHFILEOPSTRUCTW lpFileOp);
typedef HRESULT     (WINAPI *_pfn_SHGetSpecialFolderLocation)( HWND hwndOwner, int nFolder, LPITEMIDLIST *ppidl );
typedef HRESULT     (WINAPI *_pfn_SHGetFolderLocation)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwReserved,  LPITEMIDLIST *ppidl );
typedef HRESULT     (WINAPI *_pfn_SHGetFolderPathA)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPSTR pszPath );
typedef HRESULT     (WINAPI *_pfn_SHGetFolderPathW)( HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath );
typedef BOOL        (WINAPI *_pfn_SHGetSpecialFolderPathA)( HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate );
typedef BOOL        (WINAPI *_pfn_SHGetSpecialFolderPathW)( HWND hwndOwner, LPWSTR lpszPath, int nFolder, BOOL fCreate );
typedef HRESULT     (WINAPI *_pfn_SHGetFileInfoA)(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags);
typedef BOOL        (WINAPI *_pfn_SetForegroundWindow)(HWND hWnd);
typedef BOOL        (WINAPI *_pfn_ShowWindow)( HWND hWnd, INT nCmdShow );
                    
typedef BOOL        (WINAPI *_pfn_VerQueryValueA)( const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
typedef BOOL        (WINAPI *_pfn_VerQueryValueW)( const LPVOID pBlock, LPWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen);
                    
typedef int         (WINAPI *_pfn_vsnprintf)(char *buffer, size_t count, const char *format, va_list argptr);
                    
typedef MCIERROR    (WINAPI *_pfn_mciSendCommandA)(MCIDEVICEID IDDevice, UINT uMsg, DWORD fdwCommand, DWORD dwParam);
typedef MCIERROR    (WINAPI *_pfn_mciSendStringA)(LPCSTR lpszCommand, LPSTR lpszReturnString, UINT cchReturn, HANDLE hwndCallback);
typedef MMRESULT    (WINAPI *_pfn_waveOutOpen)(LPHWAVEOUT phwo, UINT uDeviceID, LPWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwCallbackInstance, DWORD fdwOpen);
typedef MMRESULT    (WINAPI *_pfn_waveOutClose)(HWAVEOUT hwo);
typedef MMRESULT    (WINAPI *_pfn_waveOutReset)(HWAVEOUT hwo);
typedef MMRESULT    (WINAPI *_pfn_waveOutPause)(HWAVEOUT hwo);
typedef MMRESULT    (WINAPI *_pfn_waveOutUnprepareHeader)(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
                    
typedef MMRESULT    (WINAPI *_pfn_waveOutGetDevCapsA)(UINT uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);
typedef MMRESULT    (WINAPI *_pfn_waveOutGetDevCapsW)(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);
typedef MMRESULT    (WINAPI *_pfn_wod32Message)(UINT uDeviceID, UINT uMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);

typedef MMRESULT    (*_pfn_midiOutGetDevCapsA)(UINT_PTR uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);
typedef MMRESULT    (*_pfn_midiOutOpen)(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

typedef UINT        (WINAPI *_pfn_WinExec)(LPCSTR lpCmdLine, UINT uCmdShow);
typedef BOOL        (WINAPI *_pfn_IsBadHugeReadPtr)(const void _huge* lp, DWORD cb);
typedef BOOL        (WINAPI *_pfn_IsBadHugeWritePtr)(const void _huge* lp, DWORD cb);
                    
typedef BOOL        (WINAPI *_pfn_SetTimeZoneInformation)(CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation);
                    
typedef HRESULT     (*_pfn_IXMLDOMDocument_load)(PVOID pThis, VARIANT xmlSource, VARIANT_BOOL *isSuccessful);
                    
typedef ULONG       (*_pfn_AddRef)( PVOID pThis );
typedef ULONG       (*_pfn_Release)( PVOID pThis );
typedef HRESULT     (*_pfn_QueryInterface)( PVOID pThis, REFIID iid, PVOID* ppvObject );
typedef HRESULT     (*_pfn_CreateInstance)( PVOID pThis, IUnknown * pUnkOuter, REFIID riid, void ** ppvObject );
typedef HRESULT     (*_pfn_IPersistFile_Save)(PVOID pThis, LPCOLESTR pszFileName,  BOOL fRemember);
typedef HRESULT     (*_pfn_IShellLinkA_SetPath)( PVOID pThis, LPCSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkW_SetPath)( PVOID pThis, LPCWSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkA_SetWorkingDirectory)( PVOID pThis, LPCSTR pszDir );
typedef HRESULT     (*_pfn_IShellLinkW_SetWorkingDirectory)( PVOID pThis, LPCWSTR pszDir );
typedef HRESULT     (*_pfn_IShellLinkA_GetWorkingDirectory)( PVOID pThis, LPCSTR pszDir, int cchMaxPath );
typedef HRESULT     (*_pfn_IShellLinkW_GetWorkingDirectory)( PVOID pThis, LPCWSTR pszDir, int cchMaxPath );
typedef HRESULT     (*_pfn_IShellLinkA_SetArguments)( PVOID pThis, LPCSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkW_SetArguments)( PVOID pThis, LPCWSTR pszFile );
typedef HRESULT     (*_pfn_IShellLinkA_SetIconLocation)( PVOID pThis, LPCSTR pszIconLocation, int nIcon );
typedef HRESULT     (*_pfn_IShellLinkW_SetIconLocation)( PVOID pThis, LPCWSTR pszIconLocation, int nIcon );
typedef HRESULT     (*_pfn_IShellLinkA_Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags );
typedef HRESULT     (*_pfn_IShellLinkW_Resolve)( PVOID pThis, HWND hwnd, DWORD fFlags );
typedef HRESULT     (*_pfn_IDirectDraw_CreateSurface)(PVOID pThis, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw2_CreateSurface)(PVOID pThis, LPDDSURFACEDESC lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw4_CreateSurface)(PVOID pThis, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw7_CreateSurface)(PVOID pThis, LPDDSURFACEDESC2 lpDDSurfaceDesc, LPDIRECTDRAWSURFACE* lplpDDSurface, IUnknown* pUnkOuter);
typedef HRESULT     (*_pfn_IDirectDraw7_GetDeviceIdentifier)(PVOID pThis, LPDDDEVICEIDENTIFIER2 lpDeviceIdentifier, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw2_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw4_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw7_SetCooperativeLevel)(PVOID pThis, HWND hWnd,DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP);
typedef HRESULT     (*_pfn_IDirectDraw2_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw4_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDraw7_SetDisplayMode)(PVOID pThis, DWORD dwWidth, DWORD dwHeight, DWORD dwBPP, DWORD dwRefreshRate, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDrawSurface_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface7_GetDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC FAR *lphDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface7_ReleaseDC)(LPDIRECTDRAWSURFACE lpDDSurface, HDC hDC);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Lock)(LPDIRECTDRAWSURFACE lpDDSurface, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_Lock)(LPDIRECTDRAWSURFACE lpDDSurface, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_Lock)(LPDIRECTDRAWSURFACE lpDDSurface, LPRECT lpDestRect, LPDDSURFACEDESC lpDDSurfaceDesc, DWORD dwFlags, HANDLE hEvent);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Unlock)(LPDIRECTDRAWSURFACE lpDDSurface, LPVOID lpSurfaceData);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Restore)(LPDIRECTDRAWSURFACE lpDDSurface);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Blt)(LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFX);
typedef HRESULT     (*_pfn_IDirectDrawSurface2_Blt)(LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFX);
typedef HRESULT     (*_pfn_IDirectDrawSurface4_Blt)(LPDIRECTDRAWSURFACE lpDDDestSurface, LPRECT lpDestRect, LPDIRECTDRAWSURFACE lpDDSrcSurface, LPRECT lpSrcRect, DWORD dwFlags, LPDDBLTFX lpDDBltFX);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Flip)(LPDIRECTDRAWSURFACE lpDDSurface, LPDIRECTDRAWSURFACE lpDDSurfaceDest, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectDrawSurface_Release)(PVOID pThis);
typedef HRESULT     (*_pfn_IDirectDrawSurface_SetPalette)(PVOID pThis, LPDIRECTDRAWPALETTE lpDDPalette);
typedef HRESULT     (*_pfn_IDirectDrawGammaControl_SetGammaRamp)(PVOID pThis, DWORD  dwFlags, LPDDGAMMARAMP lpRampData);
typedef HRESULT     (*_pfn_IDirectPlay3A_EnumConnections)(PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);
typedef HRESULT     (*_pfn_IDirectPlay4A_EnumConnections)(PVOID pThis, LPCGUID lpguidApplication, LPDPENUMCONNECTIONSCALLBACK lpEnumCallback, LPVOID lpContext, DWORD dwFlags);
typedef HRESULT     (*_pfn_IShellFolder_GetDisplayNameOf)( PVOID pThis, LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName );
typedef HRESULT     (*_pfn_SHGetDesktopFolder)(IShellFolder **ppshf);

typedef HRESULT     (*_pfn_IDirectInput_CreateDevice)(PVOID pThis, REFGUID rguid, LPDIRECTINPUTDEVICE *lplpDirectInputDevice, LPUNKNOWN pUnkOuter);
typedef HRESULT     (*_pfn_IDirectInputDevice_Acquire)(PVOID pThis);
typedef HRESULT     (*_pfn_IDirectInputDevice_GetDeviceData)(PVOID pThis, DWORD cbObjectData, LPDIDEVICEOBJECTDATA rgdod, LPDWORD pdwInOut, DWORD dwFlags);
                    
typedef HRESULT     (*_pfn_IDirectSound_Release)(PVOID pThis);
                    
typedef LONG        (*_pfn_ChangeDisplaySettingsA)(LPDEVMODEA lpDevMode, DWORD dwflags);
typedef LONG        (*_pfn_ChangeDisplaySettingsW)(LPDEVMODEW lpDevMode, DWORD dwflags);
typedef LONG        (*_pfn_ChangeDisplaySettingsExA)(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
typedef LONG        (*_pfn_ChangeDisplaySettingsExW)(LPCWSTR lpszDeviceName, LPDEVMODEW lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
typedef BOOL        (*_pfn_EnumDisplaySettingsA)(LPCSTR lpszDeviceName, DWORD iModeNum, LPDEVMODEA lpDevMode);
typedef BOOL        (*_pfn_EnumDisplaySettingsW)(LPCWSTR lpszDeviceName, DWORD iModeNum, LPDEVMODEW lpDevMode); 
typedef HBITMAP     (*_pfn_CreateDIBSection)(HDC hdc, CONST BITMAPINFO *pbmi, UINT iUsage, VOID *ppvBits, HANDLE hSection, DWORD dwOffset);
typedef HFONT       (*_pfn_CreateFontIndirectA)(CONST LOGFONTA *lplf);
typedef HFONT       (*_pfn_CreateFontIndirectW)(CONST LOGFONTW *lplf);
typedef BOOL        (*_pfn_Ellipse)(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
typedef BOOL        (*_pfn_Rectangle)(HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
typedef UINT        (*_pfn_SetDIBColorTable)(HDC hdc, UINT uStartIndex, UINT cEntries, CONST RGBQUAD *pColors);
typedef int         (*_pfn_SetStretchBltMode)(HDC hdc, int iStretchMode);
typedef BOOL        (*_pfn_StretchBlt)(HDC hdcDest, int nXOriginDest, int nYOriginDest, int nWidthDest, int nHeightDest, HDC hdcSrc, int nXOriginSrc, int nYOriginSrc, int nWidthSrc, int nHeightSrc, DWORD dwRop);
typedef int         (*_pfn_StretchDIBits)(HDC hdc, int XDest, int YDest, int nDestWidth, int nDestHeight, int XSrc, int YSrc, int nSrcWidth, int nSrcHeight, CONST VOID *lpBits, CONST BITMAPINFO *lpBitsInfo, UINT iUsage, DWORD dwRop);
                    
typedef HGDIOBJ     (*_pfn_GetCurrentObject)(HDC hdc, UINT uObjectType);
typedef COLORREF    (*_pfn_GetPixel)(HDC hdc, int XPos, int nYPos);
typedef COLORREF    (*_pfn_SetPixel)(HDC hdc, int XPos, int nYPos, COLORREF crColor);
typedef BOOL        (*_pfn_GetTextExtentPointA)(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize);
typedef BOOL        (*_pfn_GetTextExtentPointW)(HDC hdc, LPCWSTR lpString, int cbString, LPSIZE lpSize);
typedef BOOL        (*_pfn_GetTextExtentPoint32A)(HDC hdc, LPCSTR lpString, int cbString, LPSIZE lpSize);
typedef int         (*_pfn_GetTextFaceA)(HDC hdc, int nCount, LPSTR lpFaceName);
typedef BOOL        (*_pfn_GetTextMetricsA)(HDC hdc, LPTEXTMETRICA lptm);
typedef BOOL        (*_pfn_LineTo)(HDC hdc, int nXEnd, int nYEnd);
typedef BOOL        (*_pfn_MoveToEx)(HDC hdc, int X, int Y, LPPOINT lpPoint);
typedef BOOL        (*_pfn_TextOutA)(HDC hdc, int nXStart, int nYStart, LPCSTR lpString, int cbString);
                    
typedef VOID        (*_pfn_GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo);
typedef VOID        (*_pfn_GetStartupInfoW)(LPSTARTUPINFOW lpStartupInfo);
                    
typedef DWORD       (*_pfn_SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
typedef DWORD       (*_pfn_ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
typedef DWORD       (*_pfn_WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
typedef NTSTATUS    (WINAPI *_pfn_NtWriteFile)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
typedef NTSTATUS    (WINAPI *_pfn_NtWriteFileGather)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PFILE_SEGMENT_ELEMENT SegmentArray, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
                    
typedef HANDLE      (*_pfn_CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
typedef HANDLE      (*_pfn_CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
typedef BOOL        (*_pfn_ReleaseMutex)(HANDLE hMutex);
typedef DWORD       (*_pfn_WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
                    
typedef VOID        (*_pfn_Sleep)(DWORD dwMilliseconds);
typedef DWORD       (*_pfn_SleepEx)(DWORD dwMilliseconds, BOOL bAlertable);
typedef HRESULT     (*_pfn_CoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID *ppv);
typedef HRESULT     (*_pfn_CoCreateInstanceEx)(REFCLSID rclsid, IUnknown *punkOuter, DWORD dwClsCtx, COSERVERINFO *pServerInfo, ULONG cmq, MULTI_QI *pResults );
typedef HRESULT     (*_pfn_ShCoCreateInstance)(LPCTSTR pszCLSID, const CLSID * pclsid, IUnknown *punkOuter, REFIID riid, void **ppv);
typedef HRESULT     (*_pfn_CoQueryProxyBlanket)(IUnknown * pProxy,DWORD * pAuthnSvc,DWORD * pAuthzSvc,OLECHAR ** pServerPrincName,DWORD * pAuthnLevel,DWORD * pImpLevel,RPC_AUTH_IDENTITY_HANDLE * ppAuthInfo,DWORD * pCapabilities);
typedef HRESULT     (*_pfn_CoSetProxyBlanket)(IUnknown * pProxy,DWORD dwAuthnSvc,DWORD dwAuthzSvc,WCHAR * pServerPrincName,DWORD dwAuthnLevel,DWORD dwImpLevel,RPC_AUTH_IDENTITY_HANDLE   pAuthInfo,DWORD dwCapabilities);
                    
                    
typedef BOOL        (*_pfn_AppendMenuA)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPSTR lpNewItem);
typedef BOOL        (*_pfn_AppendMenuW)(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPWSTR lpNewItem);
                    
typedef BOOL        (*_pfn_ResumeThread)(HANDLE hThread);
                    
typedef DWORD       (*_pfn_NetUserAdd)(LPCWSTR servername, DWORD level, LPBYTE buf, LPDWORD parm_err);
typedef LONG        (*_pfn_LsaStorePrivateData)(PVOID PolicyHandle, PVOID KeyName, PVOID PrivateData);
                    
typedef void        (*_pfn_exit)(int status);
                    
typedef BOOL        (*_pfn_EnumPrintersA)(DWORD Flags, LPSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned);
typedef BOOL        (*_pfn_EnumPrintersW)(DWORD Flags, LPWSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned);
typedef DWORD       (*_pfn_PrinterMessageBoxA)(HANDLE hPrinter, DWORD Error, HWND hWnd, LPSTR pText, LPSTR pCaption, DWORD dwType);
typedef DWORD       (*_pfn_PrinterMessageBoxW)(HANDLE hPrinter, DWORD Error, HWND hWnd, LPWSTR pText, LPWSTR pCaption, DWORD dwType);
typedef DWORD       (*_pfn_WaitForPrinterChange)(HANDLE hPrinter, DWORD Flags);
                    
typedef int         (*_pfn_OpenIndex)(HANDLE hsrch, LPCSTR pszIndexFile, PBYTE pbSourceName, PUINT pcbSourceNameLimit, PUINT pTime1, PUINT pTime2);
typedef BOOL        (*_pfn_GetMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
typedef BOOL        (*_pfn_GetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
typedef BOOL        (*_pfn_PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
typedef BOOL        (*_pfn_PeekMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
typedef LRESULT     (*_pfn_SendMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef LRESULT     (*_pfn_SendMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef LONG        (*_pfn_DispatchMessageA)(LPMSG lpmsg);
typedef LONG        (*_pfn_DispatchMessageW)(LPMSG lpmsg);
typedef BOOL        (*_pfn_Module32First)(HANDLE SnapSection, PVOID lpme);
typedef BOOL        (*_pfn_GetSaveFileNameA)(LPOPENFILENAMEA lpofn);
typedef BOOL        (*_pfn_GetSaveFileNameW)(LPOPENFILENAMEW lpofn);
typedef BOOL        (*_pfn_GetOpenFileNameA)(LPOPENFILENAMEA lpofn);
typedef BOOL        (*_pfn_GetOpenFileNameW)(LPOPENFILENAMEW lpofn);
typedef UINT        (*_pfn_GetTempFileNameA)(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);
typedef UINT        (*_pfn_GetTempFileNameW)(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
typedef LRESULT     (*_pfn_CallWindowProcA)(WNDPROC pfn, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
typedef BOOL        (*_pfn_ControlService)(SC_HANDLE hService, DWORD dwControl, PVOID lpServiceStatus);
typedef UINT        (*_pfn_GetEnhMetaFileHeader)(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader);
typedef HMETAFILE   (*_pfn_GetMetaFileA)(LPCSTR lpszString);
typedef HMETAFILE   (*_pfn_GetMetaFileW)(LPCWSTR lpszString);
typedef UINT        (*_pfn_GetMetaFileBitsEx)(HMETAFILE hmf, UINT nSize, LPVOID lpvData);
typedef BOOL        (*_pfn_PlayMetaFile)(HDC hdc, HMETAFILE hmf);
typedef BOOL        (*_pfn_PlayMetaFileRecord)(HDC hdc, LPHANDLETABLE lpHandletable, LPMETARECORD lpMetaRecord, UINT nHandles);
typedef HMETAFILE   (*_pfn_CopyMetaFileA)(HMETAFILE hmfSrc, LPCSTR lpszFile);
typedef HMETAFILE   (*_pfn_CopyMetaFileW)(HMETAFILE hmfSrc, LPCWSTR lpszFile);
typedef HMETAFILE   (*_pfn_SetMetaFileBitsEx)(UINT nSize, CONST BYTE *lpData);
typedef BOOL        (*_pfn_PostMessageW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef BOOL        (*_pfn_PostMessageA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
typedef DWORD       (*_pfn_timeGetTime)(VOID);  
typedef int         (*_pfn_GetDeviceCaps)(HDC hdc, int nIndex);
typedef int         (*_pfn_GetSystemMetrics)(int nIndex);
typedef DWORD       (*_pfn_GetSysColor)(int nIndex);
typedef int         (*_pfn_ToAscii)(UINT uVirtKey, UINT uScanCode, PBYTE lpKeyState, LPWORD lpChar, UINT uFlags);
typedef int         (*_pfn_ToAsciiEx)(UINT uVirtKey, UINT uScanCode, PBYTE lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl);
typedef SHORT       (*_pfn_GetAsyncKeyState)(int vKey);
typedef BOOL        (*_pfn_CloseProfileUserMapping)();
typedef BOOL        (*_pfn_BackupSeek)(HANDLE  hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowBytesSeeked, LPDWORD lpdwHighBytesSeeked, LPVOID *lpContext);
typedef HANDLE      (*_pfn_CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
typedef HANDLE      (*_pfn_CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
typedef BOOL        (*_pfn_SetEvent)(HANDLE hEvent);
typedef BOOL        (*_pfn_ResetEvent)(HANDLE hEvent);
typedef DWORD       (*_pfn_SearchPathA)(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart);
typedef DWORD       (*_pfn_SearchPathW)(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
typedef DWORD       (*_pfn_GetWindowsDirectoryA)(LPSTR lpPath,DWORD Size);
typedef DWORD       (*_pfn_GetWindowsDirectoryW)(LPWSTR lpPath,DWORD Size);
typedef DWORD       (*_pfn_GetSystemDirectoryA)(LPSTR lpPath,DWORD Size);
typedef DWORD       (*_pfn_GetSystemDirectoryW)(LPWSTR lpPath,DWORD Size);
typedef BOOL        (*_pfn_SystemParametersInfoA)(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);
typedef BOOL        (*_pfn_SystemParametersInfoW)(UINT wFlag, UINT wParam, PVOID lParam, UINT flags);

typedef LPTOP_LEVEL_EXCEPTION_FILTER (WINAPI *_pfn_SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
typedef PVOID       (*_pfn_RtlAddVectoredExceptionHandler)(ULONG FirstHandler, PVOID VectoredHandler);
typedef VOID        (*_pfn__endthread)(VOID);
typedef long        (*_pfn__hread)( HFILE hFile, LPVOID lpBuffer, long lBytes );
typedef long        (*_pfn__lseek)( int handle, long offset, int origin );
                    
typedef BOOL        (*_pfn_PlaySoundA)(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);
typedef BOOL        (*_pfn_PlaySoundW)(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);
typedef BOOL        (*_pfn_sndPlaySoundA)(LPCSTR lpszSound, UINT fuSound);
typedef BOOL        (*_pfn_sndPlaySoundW)(LPCWSTR lpszSound, UINT fuSound);
                    
typedef HCURSOR     (*_pfn_SetCursor)(HCURSOR hCursor);
typedef int         (*_pfn_ShowCursor)(BOOL bShow);
typedef BOOL        (*_pfn_EnumProcessModules)(HANDLE,HMODULE *,DWORD,LPDWORD);
typedef BOOL        (*_pfn_ClipCursor)(CONST RECT *lpRect);
typedef BOOL        (*_pfn_GetCursorPos)(LPPOINT lpPoint);
typedef BOOL        (*_pfn_SetCursorPos)(int X, int Y);
typedef BOOL        (*_pfn_SetSysColors)(int cElements, CONST INT *lpaElements, CONST COLORREF *lpaRgbValues);
                    
typedef HWND        (*_pfn_GetDesktopWindow)();
typedef LONG        (*_pfn_GetWindowLongA)(HWND, INT);
typedef int         (*_pfn_GetWindowTextA)(HWND hWnd, LPSTR lpString, int nMaxCount);
typedef int         (*_pfn_GetWindowTextW)(HWND hWnd, LPWSTR lpString, int nMaxCount);
typedef BOOL        (*_pfn_SetWindowTextA)(HWND hWnd, LPCSTR lpString);
typedef BOOL        (*_pfn_SetWindowTextW)(HWND hWnd, LPCWSTR lpString);
typedef int         (*_pfn_DrawTextA)( HDC hDC, LPCSTR lpString, int nCount, LPRECT lpRect, UINT uFormat );
typedef int         (*_pfn_DrawTextW)( HDC hDC, LPCWSTR lpString,int nCount, LPRECT lpRect, UINT uFormat );
typedef BOOL        (*_pfn_IsRectEmpty)( CONST RECT *lprc );
                    
typedef LONG        (*_pfn_DocumentPropertiesA)(HWND hWnd, HANDLE hPrinter, LPSTR pDeviceName,  PDEVMODEA pDevModeOutput, PDEVMODEA pDevModeInput, DWORD fMode);
typedef LONG        (*_pfn_DocumentPropertiesW)(HWND hWnd, HANDLE hPrinter, LPWSTR pDeviceName, PDEVMODEW pDevModeOutput, PDEVMODEW pDevModeInput, DWORD fMode);
typedef BOOL        (*_pfn_OpenPrinterA)(LPSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSA pDefault);
typedef BOOL        (*_pfn_OpenPrinterW)(LPWSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSW pDefault);
typedef BOOL        (*_pfn_SetPrinterA)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD Command);
typedef BOOL        (*_pfn_SetPrinterW)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD Command);
typedef DWORD       (*_pfn_DeviceCapabilitiesA)(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, CONST DEVMODE *pDevMode);
typedef BOOL        (*_pfn_AddPrinterConnectionA)(LPSTR pName);
typedef BOOL        (*_pfn_DeletePrinterConnectionA)(LPSTR pName);
                    
typedef HDC         (*_pfn_CreateDCA)(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, CONST DEVMODEA *pdm);
typedef HDC         (*_pfn_CreateDCW)(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, CONST DEVMODEW *pdm);
typedef HDC         (*_pfn_ResetDCA)(HDC hdc, CONST DEVMODEA *lpInitData );
typedef HDC         (*_pfn_CreateCompatibleDC)(HDC hdc);
typedef BOOL        (*_pfn_DeleteDC)(HDC hdc);
typedef HGDIOBJ     (*_pfn_SelectObject)(HDC hdc, HGDIOBJ hgdiobj);
                    
typedef BOOL        (*_pfn_StartPage)(HDC hdc);
typedef HHOOK       (*_pfn_SetWindowsHookExA)(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId);
typedef HHOOK       (*_pfn_SetWindowsHookExW)(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId);
typedef BOOL        (*_pfn_UnhookWindowsHookEx)(HHOOK hhk);
typedef HHOOK       (*_pfn_SetWindowsHookA)(int idHook, HOOKPROC lpfn);
typedef HHOOK       (*_pfn_SetWindowsHookW)(int idHook, HOOKPROC lpfn);
typedef BOOL        (*_pfn_UnhookWindowsHook)(int idHook, HOOKPROC lpfn);
                    
typedef BOOL        (*_pfn_BitBlt)(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, HDC hdcSrc, int nXSrc, int nYSrc, DWORD dwRop);
typedef DWORD       (*_pfn_SuspendThread)(HANDLE hThread);
                    
typedef LONG        (WINAPI *_pfn_lineNegotiateAPIVersion)( HLINEAPP hLineApp, DWORD dwDeviceID, DWORD dwAPILowVersion, DWORD dwAPIHighVersion, LPDWORD lpdwAPIVersion, LPLINEEXTENSIONID lpExtensionID );
typedef LONG        (WINAPI *_pfn_lineInitialize)( LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCSTR lpszAppName, LPDWORD lpdwNumDevs );
typedef LONG        (WINAPI *_pfn_lineInitializeExA)( LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCSTR lpszFriendlyAppName, LPDWORD lpdwNumDevs, LPDWORD lpdwAPIVersion, LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams );
typedef LONG        (WINAPI *_pfn_lineInitializeExW)( LPHLINEAPP lphLineApp, HINSTANCE hInstance, LINECALLBACK lpfnCallback, LPCWSTR lpszFriendlyAppName, LPDWORD lpdwNumDevs, LPDWORD lpdwAPIVersion, LPLINEINITIALIZEEXPARAMS lpLineInitializeExParams );
                    
typedef HANDLE      (*_pfn_LoadImageA)(HINSTANCE hinst, LPCSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
                    
typedef int         (WINAPI *_pfn_GetDIBits)( HDC hdc, HBITMAP hbmp, UINT uStartScan, UINT cScanLines, LPVOID lpvBits, LPBITMAPINFO lpbi, UINT uUsage);
                    
typedef HRESULT     (*_pfn_CoInitialize)(LPVOID pReserved);
typedef HRESULT     (*_pfn_CoInitializeSecurity)(PSECURITY_DESCRIPTOR pVoid, LONG cAuthSvc, SOLE_AUTHENTICATION_SERVICE *asAuthSvc, void *pReserved1, DWORD dwAuthnLevel, DWORD dwImpLevel, SOLE_AUTHENTICATION_LIST *pAuthList, DWORD dwCapabilities, void *pReserved3);
typedef HIC         (*_pfn_ICLocate)(DWORD, DWORD, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER, WORD);
                    
typedef MMRESULT    (WINAPI *_pfn_joyGetDevCapsA)( UINT uJoyID, LPJOYCAPS pjc, UINT cbjc );
typedef MMRESULT    (WINAPI *_pfn_joyGetPos)( UINT uJoyID, LPJOYINFO pji );
typedef MMRESULT    (WINAPI *_pfn_mmioSetInfo)(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT wFlags);
                    
typedef int         (*_pfn_wvsprintfA)(LPSTR, LPCSTR, va_list);
                    
typedef int         (*_pfn_GetObjectA)(HGDIOBJ hgdiobj, int cbBuffer, LPVOID lpvObject);

typedef int         (WINAPI *_pfn_wglDescribePixelFormat)(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
                    
typedef BOOL        (WINAPI *_pfn_CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
                    
typedef int         (*_pfn_LdrAccessResource)(PVOID DllHandle,const IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,PVOID *Address,PULONG Size);
                    
typedef HICON       (WINAPI *_pfn_CreateIcon)(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, CONST BYTE *lpbANDbits, CONST BYTE *lpbXORbits);
                    
typedef BOOL        (WINAPI *_pfn_ScreenToClient)(HWND hWnd, LPPOINT lpPoint);
typedef HRESULT     (WINAPI *_pfn_SafeArrayAccessData)(SAFEARRAY *, void HUGEP **);
                    
typedef DWORD       (WINAPI *_pfn_GetTempPathA)(DWORD nBufferLength, LPSTR lpBuffer);
typedef DWORD       (WINAPI *_pfn_GetTempPathW)(DWORD nBufferLength, LPWSTR lpBuffer);
typedef DWORD       (WINAPI *_pfn_GetLastError)(VOID);
                    
typedef BOOL        (WINAPI *_pfn_WinHelpA)(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, DWORD dwData);

typedef PDH_STATUS  (__stdcall *_pfn_PdhAddCounterA)(IN HQUERY hQuery, IN LPCSTR szFullCounterPath, IN DWORD_PTR dwUserData, IN HCOUNTER *phCounter);
typedef HWND        (WINAPI *_pfn_GetDlgItem)(HWND, int);
typedef DWORD       (WINAPI *_pfn_VerInstallFileW)(DWORD, LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,LPWSTR,PUINT);
typedef DWORD       (WINAPI *_pfn_VerInstallFileA)(DWORD, LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,LPSTR,PUINT);
typedef LONG        (WINAPI *_pfn_lstrcmpiA)(LPCSTR, LPCSTR);
typedef DWORD       (WINAPI *_pfn_RasSetEntryPropertiesA)(LPCSTR, LPCSTR, LPRASENTRYA, DWORD, LPBYTE, DWORD);
typedef DWORD       (WINAPI *_pfn_RasSetEntryPropertiesW)(LPCWSTR, LPCWSTR, LPRASENTRYW, DWORD, LPBYTE, DWORD);
                    
typedef BOOL        (WINAPI *_pfn_GlobalMemoryStatus)(LPMEMORYSTATUS);
typedef LANGID      (WINAPI *_pfn_GetUserDefaultUILanguage)();
typedef HANDLE      (WINAPI *_pfn_SetClipboardData)(UINT, HANDLE);
                    
typedef int         (WINAPI *_pfn_MultiByteToWideChar)(UINT, DWORD, LPCSTR, int, LPWSTR, int);
typedef BOOL        (WINAPI *_pfn_GetCharWidthA)(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
typedef BOOL        (WINAPI *_pfn_GetCharWidthW)(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
typedef UINT        (WINAPI *_pfn_GetKBCodePage)(void);
                    
typedef int         (WINAPI *_pfn_WideCharToMultiByte)(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, LPBOOL);
typedef UINT        (WINAPI *_pfn_MsiGetPropertyA)(MSIHANDLE, LPCSTR, LPSTR, DWORD*);
typedef UINT        (WINAPI *_pfn_MsiGetPropertyW)(MSIHANDLE, LPCWSTR, LPWSTR, DWORD*);
                    
typedef BOOL        (WINAPI *_pfn_PrintDlgA)(LPPRINTDLG lppd);
                    
typedef MCIERROR    (WINAPI *_pfn_mciSendCommandA)(MCIDEVICEID, UINT, DWORD, DWORD);
                    
typedef BOOL        (WINAPI *_pfn_CertCloseStore)(HCERTSTORE, DWORD);
typedef BOOL        (WINAPI *_pfn_CryptVerifyMessageSignature)(PCRYPT_VERIFY_MESSAGE_PARA,DWORD ,const BYTE *,DWORD ,BYTE *,DWORD *,PCCERT_CONTEXT *);
typedef BOOL        (WINAPI *_pfn_ImageGetCertificateData)(HANDLE,DWORD,LPWIN_CERTIFICATE,PDWORD);
typedef BOOL        (WINAPI *_pfn_ImageGetCertificateHeader)(HANDLE,DWORD,LPWIN_CERTIFICATE);
typedef PCCERT_CONTEXT (WINAPI *_pfn_CertGetSubjectCertificateFromStore)(HCERTSTORE,DWORD,PCERT_INFO);
typedef HCERTSTORE  (WINAPI *_pfn_CertDuplicateStore)(HCERTSTORE);
typedef PCCERT_CONTEXT (WINAPI *_pfn_CertEnumCertificatesInStore)(HCERTSTORE, PCCERT_CONTEXT);
typedef DWORD       (WINAPI *_pfn_CertRDNValueToStrA)(DWORD,PCERT_RDN_VALUE_BLOB,LPSTR,DWORD);
typedef PCERT_RDN_ATTR (WINAPI *_pfn_CertFindRDNAttr)(LPCSTR,PCERT_NAME_INFO);
typedef BOOL        (WINAPI *_pfn_CryptDecodeObject)(DWORD,LPCSTR,const BYTE *,DWORD,DWORD,void *,DWORD *);
typedef HRESULT     (WINAPI *_pfn_WinVerifyTrust)(HWND, GUID *, WINTRUST_DATA *);
                    
typedef DWORD       (WINAPI *_pfn_CreateIpForwardEntry)(PMIB_IPFORWARDROW pRoute);
typedef DWORD       (WINAPI *_pfn_GetIpForwardTable)(PMIB_IPFORWARDTABLE pIpForwardTable, PULONG pdwSize, BOOL bOrder);

typedef BOOL        (WINAPI *_pfn_StartServiceA)(SC_HANDLE hService, DWORD, LPCSTR *);

typedef BOOL        (__stdcall *_pfn_AngleArc)(HDC hdc, int X, int Y, DWORD dwRadius, FLOAT eStartAngle, FLOAT eSweepAngle );
typedef BOOL        (__stdcall *_pfn_Arc)( HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc );
typedef BOOL        (__stdcall *_pfn_ArcTo)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2);
typedef BOOL        (__stdcall *_pfn_ChoosePixelFormat)( HDC  hdc,CONST PIXELFORMATDESCRIPTOR *  ppfd );
typedef BOOL        (__stdcall *_pfn_Chord)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2 );
typedef int         (_stdcall *_pfn_CombineRgn)(HRGN hrgnDest,HRGN hrgnSrc1,HRGN hrgnSrc2,int fnCombineMode );
typedef HENHMETAFILE (_stdcall *_pfn_CloseEnhMetaFile)(HDC hdc);
typedef HMETAFILE   (_stdcall *_pfn_CloseMetaFile)(HDC hdc);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmap)(int nWidthIn, int nHeightIn, UINT cPlanesIn, UINT cBitPerPixelIn, CONST VOID * pvBitsIn);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmapIndirect)(CONST BITMAP * lpbmIn);
typedef HBRUSH      (_stdcall *_pfn_CreateBrushIndirect)(CONST LOGBRUSH * lplbIn);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceA)(LPLOGCOLORSPACEA lpLogColorSpace);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceW)(LPLOGCOLORSPACEW lpLogColorSpace);
typedef BOOL        (_stdcall *_pfn_DPtoLP)(HDC hdc,LPPOINT lpPoints,int nCount);
typedef BOOL        (_stdcall *_pfn_DeleteColorSpace)(HCOLORSPACE hColorSpaceIn);
typedef HBITMAP     (_stdcall *_pfn_CreateCompatibleBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrush)(HGLOBAL hglbDIBPacked,UINT fuColorSpec);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrushPt)(CONST VOID *lpPackedDIB,UINT iUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDIBitmap)(HDC hdc,CONST BITMAPINFOHEADER *lpbmih,DWORD fdwInit,CONST VOID *lpbInit,CONST BITMAPINFO *lpbmi,UINT fuUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDiscardableBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgnIndirect)(CONST RECT * lprc);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileA)(HDC hdcRef,LPCSTR lpFilename,CONST RECT* lpRect,LPCSTR lpDescription);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileW)(HDC hdcRef,LPCWSTR lpFilename,CONST RECT* lpRect,LPCWSTR lpDescription);
typedef HFONT       (_stdcall *_pfn_CreateFontA)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCSTR lpszFace);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectA)(CONST LOGFONTA * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectW)(CONST LOGFONTW * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExA)(CONST ENUMLOGFONTEXDVA *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExW)(CONST ENUMLOGFONTEXDVW *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontW)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCWSTR lpszFace);
typedef HPALETTE    (_stdcall *_pfn_CreateHalftonePalette)(HDC hdc);
typedef HBRUSH      (_stdcall *_pfn_CreateHatchBrush)(int fnStyle,COLORREF clrref);
typedef HDC         (_stdcall *_pfn_CreateICA)(LPCSTR lpszDriver,LPCSTR lpszDevice,LPCSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateICW)(LPCWSTR lpszDriver,LPCWSTR lpszDevice,LPCWSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateMetaFileA)(LPCSTR lpszFile);
typedef HDC         (_stdcall *_pfn_CreateMetaFileW)(LPCWSTR lpszFile);
typedef HPALETTE    (_stdcall *_pfn_CreatePalette)(CONST LOGPALETTE *lplgpl);
typedef HBRUSH      (_stdcall *_pfn_CreatePatternBrush)(HBITMAP hbmp);
typedef HPEN        (_stdcall *_pfn_CreatePen)(int fnPenStyle,int nWidth,COLORREF crColor);
typedef HPEN        (_stdcall *_pfn_CreatePenIndirect)(CONST LOGPEN *lplgpn);
typedef HRGN        (_stdcall *_pfn_CreatePolyPolygonRgn)(CONST POINT *lppt,CONST INT *lpPolyCounts,int nCount,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreatePolygonRgn)(CONST POINT *lppt,int cPoints,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreateRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateRectRgnIndirect)(CONST RECT * lprc);
typedef HRGN        (_stdcall *_pfn_CreateRoundRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nWidthEllipse,int nHeightEllipse);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceA)(DWORD fdwHidden,LPCSTR lpszFontRes,LPCSTR lpszFontFile,LPCSTR lpszCurrentPath);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceW)(DWORD fdwHidden,LPCWSTR lpszFontRes,LPCWSTR lpszFontFile,LPCWSTR lpszCurrentPath);
typedef HBRUSH      (_stdcall *_pfn_CreateSolidBrush)(COLORREF crColor);
typedef BOOL        (_stdcall *_pfn_DeleteEnhMetaFile)(HENHMETAFILE hemf);
typedef BOOL        (_stdcall *_pfn_DeleteMetaFile)(HMETAFILE hmf);
typedef BOOL        (_stdcall *_pfn_DeleteObject)(HGDIOBJ hObjectIn);
typedef BOOL        (_stdcall *_pfn_DeleteDC)(HDC hdc);
typedef HPEN        (_stdcall *_pfn_ExtCreatePen)(DWORD dwPenStyle,DWORD dwWidth,CONST LOGBRUSH *lplb,DWORD dwStyleCount,CONST DWORD *lpStyle);
typedef HRGN        (_stdcall *_pfn_ExtCreateRegion)(CONST XFORM *lpXform,DWORD nCount,CONST RGNDATA *lpRgnData);
typedef BOOL        (_stdcall *_pfn_ExtTextOutA)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef BOOL        (_stdcall *_pfn_ExtTextOutW)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCWSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef BOOL        (_stdcall *_pfn_FixBrushOrgEx)(HDC hdc, int nUnknown1, int nUnknown2, LPPOINT lpPoint);
typedef BOOL        (_stdcall *_pfn_FloodFill)(HDC hdc, int nXStart, int nYStart, COLORREF crFill);
typedef LONG        (_stdcall *_pfn_GetBitmapBits)(HBITMAP hbmp,LONG cbBuffer,LPVOID lpvBits);
typedef HGDIOBJ     (_stdcall *_pfn_GetStockObject)(int fnObjectIn);
typedef HDC         (_stdcall *_pfn_BeginPaint)( HWND, LPPAINTSTRUCT );
typedef HICON       (_stdcall *_pfn_CopyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyCursor)(HCURSOR);
typedef BOOL        (_stdcall *_pfn_DestroyAcceleratorTable)(HACCEL);
typedef BOOL        (_stdcall *_pfn_DestroyMenu)(HMENU);
typedef BOOL        (_stdcall *_pfn_EndPaint)(HWND, CONST PAINTSTRUCT * );
typedef HCURSOR     (_stdcall *_pfn_GetCursor)( void );
typedef BOOL        (_stdcall *_pfn_GetIconInfo)( HICON, PICONINFO );
typedef HDC         (_stdcall *_pfn_GetDCEx)(HWND, HRGN, DWORD );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsA)(HINSTANCE, LPCSTR );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsW)(HINSTANCE, LPCWSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapA)(HINSTANCE, LPCSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapW)(HINSTANCE, LPCWSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorA)(HINSTANCE, LPCSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileA)(LPCSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileW)(LPCWSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorW)(HINSTANCE, LPCWSTR );
typedef HICON       (_stdcall *_pfn_LoadIconA)(HINSTANCE, LPCSTR );
typedef HICON       (_stdcall *_pfn_LoadIconW)(HINSTANCE, LPCWSTR );
typedef HANDLE      (_stdcall *_pfn_LoadImageA)(HINSTANCE, LPCSTR, UINT, int, int, UINT );
typedef HANDLE      (_stdcall *_pfn_LoadImageW)(HINSTANCE, LPCWSTR, UINT, int, int, UINT );
typedef HMENU       (_stdcall *_pfn_LoadMenuA)(HINSTANCE, LPCSTR );
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectA)(CONST MENUTEMPLATEA *);
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectW)(CONST MENUTEMPLATEW *);
typedef HMENU       (_stdcall *_pfn_LoadMenuW)(HINSTANCE, LPCWSTR );
typedef BOOL        (_stdcall *_pfn_ReleaseDC)(HWND, HDC );
typedef BOOL        (_stdcall *_pfn_UnregisterClassA)(LPCSTR, HINSTANCE);
typedef BOOL        (_stdcall *_pfn_UnregisterClassW)(LPCWSTR, HINSTANCE);
typedef int         (_stdcall *_pfn_SetWindowRgn)(HWND,HRGN,BOOL);
typedef HMENU       (_stdcall *_pfn_CreateMenu)( VOID );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableA)( LPACCEL lpaccl, int cEntries );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableW)( LPACCEL lpaccl, int cEntries );
typedef HCURSOR     (_stdcall *_pfn_CreateCursor)(HINSTANCE hInst,int xHotSpot,int yHotSpot,int nWidth,int nHeight,CONST VOID *pvANDPlane,CONST VOID *pvXORPlane);
typedef HICON       (_stdcall *_pfn_CreateIconFromResource)(PBYTE presbits,DWORD dwResSize,BOOL fIcon,DWORD dwVer);
typedef HICON       (_stdcall *_pfn_CreateIconFromResourceEx)(PBYTE pbIconBits,DWORD cbIconBits,BOOL fIcon,DWORD dwVersion,int cxDesired,int cyDesired,UINT uFlags);
typedef HANDLE      (_stdcall *_pfn_CopyImage)(HANDLE hImage,UINT uType,int cxDesired,int cyDesired,UINT fuFlags);
typedef HMENU       (_stdcall *_pfn_CreatePopupMenu)( VOID );
typedef BOOL        (_stdcall *_pfn_InsertMenuItemA)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOA lpmii);
typedef BOOL        (_stdcall *_pfn_InsertMenuItemW)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOW lpmii);
typedef HICON       (_stdcall *_pfn_CreateIconIndirect)(PICONINFO piconinfo);
typedef BOOL        (_stdcall *_pfn_GetBitmapDimensionEx)(HBITMAP hBitmap,LPSIZE lpDimension);
typedef BOOL        (_stdcall *_pfn_MaskBlt)(HDC hdcDest,int nXDest,int nYDest,int nWidth,int nHeight,HDC hdcSrc,int nXSrc,int nYSrc,HBITMAP hbmMask,int xMask,int yMask,DWORD dwRop);
typedef LONG        (_stdcall *_pfn_SetBitmapBits)(HBITMAP hbmp,DWORD cBytes,CONST VOID *lpBits);
typedef int         (_stdcall *_pfn_SetDIBits)(HDC hdc,HBITMAP hbmp,UINT uStartScan,UINT cScanLines,CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT fuColorUse);
typedef BOOL        (_stdcall *_pfn_SetBitmapDimensionEx)(HBITMAP hBitmap,int nWidth,int nHeight,LPSIZE lpSize);
typedef HBRUSH      (_stdcall *_pfn_GetSysColorBrush)(int nIndex);
typedef HICON       (_stdcall *_pfn_ExtractAssociatedIconA)(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon);
typedef HICON       (_stdcall *_pfn_ExtractAssociatedIconW)(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon);
typedef BOOL        (_stdcall *_pfn_DrawIcon)(HDC hDC, int X, int Y, HICON hIcon);
typedef BOOL        (_stdcall *_pfn_DrawIconEx)(HDC hDC, int X, int Y, HICON hIcon, int cxWidth, int cyHeight, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);
typedef BOOL        (_stdcall *_pfn_AnyPopup)(void);
typedef int         (_stdcall *_pfn_EnumFontFamiliesA)(HDC hdc, LPCSTR lpszFamily, FONTENUMPROC lpEnumFontFamProc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontFamiliesW)(HDC hdc, LPCWSTR lpszFamily, FONTENUMPROC lpEnumFontFamProc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontFamProc)(ENUMLOGFONT *lpelf, NEWTEXTMETRIC *lpntm, DWORD FontType, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontsA)(HDC hdc, LPCSTR lpFaceName, FONTENUMPROC lpFontFunc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontsW)(HDC hdc, LPCWSTR lpFaceName, FONTENUMPROC lpFontFunc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumFontsProc)(CONST LOGFONT *lplf, CONST TEXTMETRIC *lptm, DWORD dwType, LPARAM lpData);
typedef BOOL        (_stdcall *_pfn_EnumMetaFile)(HDC hdc, HMETAFILE hmf, MFENUMPROC lpMetaFunc, LPARAM lParam);
typedef int         (_stdcall *_pfn_EnumMetaFileProc)(HDC hDC, HANDLETABLE *lpHTable, METARECORD *lpMFR, int nObj, LPARAM lpClientData);

typedef BOOL        (__stdcall *_pfn_AngleArc)(HDC hdc, int X, int Y, DWORD dwRadius, FLOAT eStartAngle, FLOAT eSweepAngle );
typedef BOOL        (__stdcall *_pfn_Arc)( HDC hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nXStartArc, int nYStartArc, int nXEndArc, int nYEndArc );
typedef BOOL        (__stdcall *_pfn_ArcTo)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2);
typedef BOOL        (__stdcall *_pfn_ChoosePixelFormat)( HDC  hdc,CONST PIXELFORMATDESCRIPTOR *  ppfd );
typedef BOOL        (__stdcall *_pfn_Chord)( HDC hdc,int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nXRadial1,int nYRadial1,int nXRadial2,int nYRadial2 );
typedef int         (_stdcall *_pfn_CombineRgn)(HRGN hrgnDest,HRGN hrgnSrc1,HRGN hrgnSrc2,int fnCombineMode );
typedef HENHMETAFILE (_stdcall *_pfn_CloseEnhMetaFile)(HDC hdc);
typedef HMETAFILE   (_stdcall *_pfn_CloseMetaFile)(HDC hdc);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmap)(int nWidthIn, int nHeightIn, UINT cPlanesIn, UINT cBitPerPixelIn, CONST VOID * pvBitsIn);
typedef HBITMAP     (_stdcall *_pfn_CreateBitmapIndirect)(CONST BITMAP * lpbmIn);
typedef HBRUSH      (_stdcall *_pfn_CreateBrushIndirect)(CONST LOGBRUSH * lplbIn);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceA)(LPLOGCOLORSPACEA lpLogColorSpace);
typedef HCOLORSPACE (_stdcall *_pfn_CreateColorSpaceW)(LPLOGCOLORSPACEW lpLogColorSpace);
typedef BOOL        (_stdcall *_pfn_DPtoLP)(HDC hdc,LPPOINT lpPoints,int nCount);
typedef BOOL        (_stdcall *_pfn_DeleteColorSpace)(HCOLORSPACE hColorSpaceIn);
typedef HBITMAP     (_stdcall *_pfn_CreateCompatibleBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrush)(HGLOBAL hglbDIBPacked,UINT fuColorSpec);
typedef HBRUSH      (_stdcall *_pfn_CreateDIBPatternBrushPt)(CONST VOID *lpPackedDIB,UINT iUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDIBitmap)(HDC hdc,CONST BITMAPINFOHEADER *lpbmih,DWORD fdwInit,CONST VOID *lpbInit,CONST BITMAPINFO *lpbmi,UINT fuUsage);
typedef HBITMAP     (_stdcall *_pfn_CreateDiscardableBitmap)(HDC hdc,int nWidth,int nHeight);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateEllipticRgnIndirect)(CONST RECT * lprc);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileA)(HDC hdcRef,LPCSTR lpFilename,CONST RECT* lpRect,LPCSTR lpDescription);
typedef HDC         (_stdcall *_pfn_CreateEnhMetaFileW)(HDC hdcRef,LPCWSTR lpFilename,CONST RECT* lpRect,LPCWSTR lpDescription);
typedef HFONT       (_stdcall *_pfn_CreateFontA)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCSTR lpszFace);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectA)(CONST LOGFONTA * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectW)(CONST LOGFONTW * lplf);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExA)(CONST ENUMLOGFONTEXDVA *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontIndirectExW)(CONST ENUMLOGFONTEXDVW *penumlfex);
typedef HFONT       (_stdcall *_pfn_CreateFontW)(int nHeight,int nWidth,int nEscapement,int nOrientation,int fnWeight,DWORD fdwItalic,DWORD fdwUnderline,DWORD fdwStrikeOut,DWORD fdwCharSet,DWORD fdwOutputPrecision,DWORD fdwClipPrecision,DWORD fdwQuality,DWORD fdwPitchAndFamily,LPCWSTR lpszFace);
typedef HPALETTE    (_stdcall *_pfn_CreateHalftonePalette)(HDC hdc);
typedef HBRUSH      (_stdcall *_pfn_CreateHatchBrush)(int fnStyle,COLORREF clrref);
typedef HDC         (_stdcall *_pfn_CreateICA)(LPCSTR lpszDriver,LPCSTR lpszDevice,LPCSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateICW)(LPCWSTR lpszDriver,LPCWSTR lpszDevice,LPCWSTR lpszOutput,CONST DEVMODE *lpdvmInit);
typedef HDC         (_stdcall *_pfn_CreateMetaFileA)(LPCSTR lpszFile);
typedef HDC         (_stdcall *_pfn_CreateMetaFileW)(LPCWSTR lpszFile);
typedef HPALETTE    (_stdcall *_pfn_CreatePalette)(CONST LOGPALETTE *lplgpl);
typedef HBRUSH      (_stdcall *_pfn_CreatePatternBrush)(HBITMAP hbmp);
typedef HPEN        (_stdcall *_pfn_CreatePen)(int fnPenStyle,int nWidth,COLORREF crColor);
typedef HPEN        (_stdcall *_pfn_CreatePenIndirect)(CONST LOGPEN *lplgpn);
typedef HRGN        (_stdcall *_pfn_CreatePolyPolygonRgn)(CONST POINT *lppt,CONST INT *lpPolyCounts,int nCount,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreatePolygonRgn)(CONST POINT *lppt,int cPoints,int fnPolyFillMode);
typedef HRGN        (_stdcall *_pfn_CreateRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect);
typedef HRGN        (_stdcall *_pfn_CreateRectRgnIndirect)(CONST RECT * lprc);
typedef HRGN        (_stdcall *_pfn_CreateRoundRectRgn)(int nLeftRect,int nTopRect,int nRightRect,int nBottomRect,int nWidthEllipse,int nHeightEllipse);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceA)(DWORD fdwHidden,LPCSTR lpszFontRes,LPCSTR lpszFontFile,LPCSTR lpszCurrentPath);
typedef BOOL        (_stdcall *_pfn_CreateScalableFontResourceW)(DWORD fdwHidden,LPCWSTR lpszFontRes,LPCWSTR lpszFontFile,LPCWSTR lpszCurrentPath);
typedef HBRUSH      (_stdcall *_pfn_CreateSolidBrush)(COLORREF crColor);
typedef BOOL        (_stdcall *_pfn_DeleteEnhMetaFile)(HENHMETAFILE hemf);
typedef BOOL        (_stdcall *_pfn_DeleteMetaFile)(HMETAFILE hmf);
typedef BOOL        (_stdcall *_pfn_DeleteObject)(HGDIOBJ hObjectIn);
typedef BOOL        (_stdcall *_pfn_DeleteDC)(HDC hdc);
typedef HPEN        (_stdcall *_pfn_ExtCreatePen)(DWORD dwPenStyle,DWORD dwWidth,CONST LOGBRUSH *lplb,DWORD dwStyleCount,CONST DWORD *lpStyle);
typedef HRGN        (_stdcall *_pfn_ExtCreateRegion)(CONST XFORM *lpXform,DWORD nCount,CONST RGNDATA *lpRgnData);
typedef BOOL        (_stdcall *_pfn_ExtTextOutA)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef BOOL        (_stdcall *_pfn_ExtTextOutW)(HDC hdc,int X,int Y,UINT fuOptions,CONST RECT* lprc,LPCWSTR lpString,UINT cbCount,CONST INT* lpDx);
typedef LONG        (_stdcall *_pfn_GetBitmapBits)(HBITMAP hbmp,LONG cbBuffer,LPVOID lpvBits);
typedef HGDIOBJ     (_stdcall *_pfn_GetStockObject)(int fnObjectIn);

typedef HDC         (_stdcall *_pfn_BeginPaint)( HWND, LPPAINTSTRUCT );
typedef HICON       (_stdcall *_pfn_CopyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyIcon)(HICON);
typedef BOOL        (_stdcall *_pfn_DestroyCursor)(HCURSOR);
typedef BOOL        (_stdcall *_pfn_DestroyAcceleratorTable)(HACCEL);
typedef BOOL        (_stdcall *_pfn_DestroyMenu)(HMENU);
typedef BOOL        (_stdcall *_pfn_EndPaint)(HWND, CONST PAINTSTRUCT * );
typedef HCURSOR     (_stdcall *_pfn_GetCursor)( void );
typedef BOOL        (_stdcall *_pfn_GetIconInfo)( HICON, PICONINFO );
typedef HDC         (_stdcall *_pfn_GetDCEx)(HWND, HRGN, DWORD );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsA)(HINSTANCE, LPCSTR );
typedef HACCEL      (_stdcall *_pfn_LoadAcceleratorsW)(HINSTANCE, LPCWSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapA)(HINSTANCE, LPCSTR );
typedef HBITMAP     (_stdcall *_pfn_LoadBitmapW)(HINSTANCE, LPCWSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorA)(HINSTANCE, LPCSTR );
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileA)(LPCSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorFromFileW)(LPCWSTR);
typedef HCURSOR     (_stdcall *_pfn_LoadCursorW)(HINSTANCE, LPCWSTR );
typedef HICON       (_stdcall *_pfn_LoadIconA)(HINSTANCE, LPCSTR );
typedef HICON       (_stdcall *_pfn_LoadIconW)(HINSTANCE, LPCWSTR );
typedef HANDLE      (_stdcall *_pfn_LoadImageA)(HINSTANCE, LPCSTR, UINT, int, int, UINT );
typedef HANDLE      (_stdcall *_pfn_LoadImageW)(HINSTANCE, LPCWSTR, UINT, int, int, UINT );
typedef HMENU       (_stdcall *_pfn_LoadMenuA)(HINSTANCE, LPCSTR );
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectA)(CONST MENUTEMPLATEA *);
typedef HMENU       (_stdcall *_pfn_LoadMenuIndirectW)(CONST MENUTEMPLATEW *);
typedef HMENU       (_stdcall *_pfn_LoadMenuW)(HINSTANCE, LPCWSTR );
typedef BOOL        (_stdcall *_pfn_ReleaseDC)(HWND, HDC );
typedef BOOL        (_stdcall *_pfn_UnregisterClassA)(LPCSTR, HINSTANCE);
typedef BOOL        (_stdcall *_pfn_UnregisterClassW)(LPCWSTR, HINSTANCE);
typedef int         (_stdcall *_pfn_SetWindowRgn)(HWND,HRGN,BOOL);
typedef HMENU       (_stdcall *_pfn_CreateMenu)( VOID );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableA)( LPACCEL lpaccl, int cEntries );
typedef HACCEL      (_stdcall *_pfn_CreateAcceleratorTableW)( LPACCEL lpaccl, int cEntries );
typedef HCURSOR     (_stdcall *_pfn_CreateCursor)(HINSTANCE hInst,int xHotSpot,int yHotSpot,int nWidth,int nHeight,CONST VOID *pvANDPlane,CONST VOID *pvXORPlane);
typedef HICON       (_stdcall *_pfn_CreateIconFromResource)(PBYTE presbits,DWORD dwResSize,BOOL fIcon,DWORD dwVer);
typedef HICON       (_stdcall *_pfn_CreateIconFromResourceEx)(PBYTE pbIconBits,DWORD cbIconBits,BOOL fIcon,DWORD dwVersion,int cxDesired,int cyDesired,UINT uFlags);
typedef HANDLE      (_stdcall *_pfn_CopyImage)(HANDLE hImage,UINT uType,int cxDesired,int cyDesired,UINT fuFlags);
typedef HMENU       (_stdcall *_pfn_CreatePopupMenu)( VOID );
typedef BOOL        (_stdcall *_pfn_InsertMenuItemA)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOA lpmii);
typedef BOOL        (_stdcall *_pfn_InsertMenuItemW)(HMENU hMenu,UINT uItem,BOOL fByPosition,LPCMENUITEMINFOW lpmii);
typedef HICON       (_stdcall *_pfn_CreateIconIndirect)(PICONINFO piconinfo);
typedef BOOL        (_stdcall *_pfn_GetBitmapDimensionEx)(HBITMAP hBitmap,LPSIZE lpDimension);
typedef BOOL        (_stdcall *_pfn_MaskBlt)(HDC hdcDest,int nXDest,int nYDest,int nWidth,int nHeight,HDC hdcSrc,int nXSrc,int nYSrc,HBITMAP hbmMask,int xMask,int yMask,DWORD dwRop);
typedef BOOL        (_stdcall *_pfn_PlgBlt)(HDC hdcDest,CONST POINT *lpPoint,HDC hdcSrc,int nXSrc,int nYSrc,int nWidth,int nHeight,HBITMAP hbmMask,int xMask,int yMask);
typedef LONG        (_stdcall *_pfn_SetBitmapBits)(HBITMAP hbmp,DWORD cBytes,CONST VOID *lpBits);
typedef int         (_stdcall *_pfn_SetDIBits)(HDC hdc,HBITMAP hbmp,UINT uStartScan,UINT cScanLines,CONST VOID *lpvBits,CONST BITMAPINFO *lpbmi,UINT fuColorUse);
typedef BOOL        (_stdcall *_pfn_SetBitmapDimensionEx)(HBITMAP hBitmap,int nWidth,int nHeight,LPSIZE lpSize);
typedef HBRUSH      (_stdcall *_pfn_GetSysColorBrush)(int nIndex);

typedef DWORD       (WINAPI *_pfn_WNetEnumResourceA)(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
typedef DWORD       (WINAPI *_pfn_WNetEnumResourceW)(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);
typedef HIMC        (WINAPI *_pfn_ImmAssociateContext)(HWND hWnd, HIMC hIMC);

typedef BOOL        (*_pfn_GetPrinterA)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD cbBuf, LPDWORD pcbNeeded);
typedef BOOL        (*_pfn_GetPrinterW)(HANDLE hPrinter, DWORD Level, LPBYTE pPrinter, DWORD cbBuf, LPDWORD pcbNeeded);

typedef HDESK       (WINAPI *_pfn_CreateDesktopA)(LPCSTR lpszDesktop, LPCSTR lpszDevice, LPDEVMODEA pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef HDESK       (WINAPI *_pfn_CreateDesktopW)(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, LPDEVMODEW pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef HWINSTA     (WINAPI *_pfn_CreateWindowStationA)(LPSTR lpwinsta, DWORD dwReserved, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef HWINSTA     (WINAPI *_pfn_CreateWindowStationW)(LPWSTR lpwinsta, DWORD dwReserved, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
typedef LONG        (WINAPI *_pfn_RegSaveKeyA)(HKEY hKey, LPCSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef LONG        (WINAPI *_pfn_RegSaveKeyW)(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef LONG        (WINAPI *_pfn_RegSaveKeyExA)(HKEY hKey, LPCSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
typedef LONG        (WINAPI *_pfn_RegSaveKeyExW)(HKEY hKey, LPCWSTR lpFile, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);
typedef HANDLE      (WINAPI *_pfn_CreateRemoteThread)(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
typedef HANDLE      (WINAPI *_pfn_CreateJobObjectA)(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName);
typedef HANDLE      (WINAPI *_pfn_CreateJobObjectW)(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName);
typedef BOOL        (WINAPI *_pfn_CreateHardLinkA)(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreateHardLinkW)(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateMailslotA)(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateMailslotW)(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateNamedPipeA)(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef HANDLE      (WINAPI *_pfn_CreateNamedPipeW)(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
typedef BOOL        (WINAPI *_pfn_CreatePipe)(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);
typedef HANDLE      (WINAPI *_pfn_CreateWaitableTimerA)(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName);
typedef HANDLE      (WINAPI *_pfn_CreateWaitableTimerW)(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName);
typedef void        (WINAPI *_pfn_ReleaseStgMedium)(STGMEDIUM *pmedium);


#endif // _SHIMPROTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\shimtags.h ===
/*--

Copyright (c) 1999  Microsoft Corporation

Module Name:

    shimtags.h

Abstract:

    tag definitions for the shim db

Author:

    dmunsil 02/02/2000

Revision History:

Notes:

    These are the tag definitions used by the shim db to pack/unpack shimming info from an XML file,

--*/

#ifndef _SHIMTAGS_H_
#define _SHIMTAGS_H_

//
// LIST types for shimdb
//
#define TAG_DATABASE        (0x1 | TAG_TYPE_LIST)
#define TAG_LIBRARY         (0x2 | TAG_TYPE_LIST)
#define TAG_INEXCLUDE       (0x3 | TAG_TYPE_LIST)
#define TAG_DLL             (0x4 | TAG_TYPE_LIST)
#define TAG_PATCH           (0x5 | TAG_TYPE_LIST)
#define TAG_APP             (0x6 | TAG_TYPE_LIST)     // hopefully never used
#define TAG_EXE             (0x7 | TAG_TYPE_LIST)
#define TAG_MATCHING_FILE   (0x8 | TAG_TYPE_LIST)
#define TAG_DLL_REF         (0x9 | TAG_TYPE_LIST)
#define TAG_PATCH_REF       (0xA | TAG_TYPE_LIST)
#define TAG_LAYER           (0xB | TAG_TYPE_LIST)
#define TAG_FILE            (0xC | TAG_TYPE_LIST)
#define TAG_APPHELP         (0xD | TAG_TYPE_LIST)
#define TAG_LINK            (0xE | TAG_TYPE_LIST) // description list w/lang ids and urls

//
// STRINGREF types for shimdb
//

#define TAG_NAME              (0x1  | TAG_TYPE_STRINGREF)
#define TAG_DESCRIPTION       (0x2  | TAG_TYPE_STRINGREF)
#define TAG_MODULE            (0x3  | TAG_TYPE_STRINGREF)
#define TAG_API               (0x4  | TAG_TYPE_STRINGREF)
#define TAG_VENDOR            (0x5  | TAG_TYPE_STRINGREF)   // hopefully never used
#define TAG_APP_NAME          (0x6  | TAG_TYPE_STRINGREF)
#define TAG_SHORTNAME         (0x7  | TAG_TYPE_STRINGREF)
#define TAG_COMMAND_LINE      (0x8  | TAG_TYPE_STRINGREF)
#define TAG_COMPANY_NAME      (0x9  | TAG_TYPE_STRINGREF)
#define TAG_WILDCARD_NAME     (0xA  | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_NAME      (0x10 | TAG_TYPE_STRINGREF)
#define TAG_PRODUCT_VERSION   (0x11 | TAG_TYPE_STRINGREF)
#define TAG_FILE_DESCRIPTION  (0x12 | TAG_TYPE_STRINGREF)
#define TAG_FILE_VERSION      (0x13 | TAG_TYPE_STRINGREF)
#define TAG_ORIGINAL_FILENAME (0x14 | TAG_TYPE_STRINGREF)
#define TAG_INTERNALNAME      (0x15 | TAG_TYPE_STRINGREF)
#define TAG_LEGALCOPYRIGHT    (0x16 | TAG_TYPE_STRINGREF)
#define TAG_16BITDESCRIPTION  (0x17 | TAG_TYPE_STRINGREF)

#define TAG_APPHELP_DETAILS   (0x18 | TAG_TYPE_STRINGREF) // details in single language
#define TAG_LINK_URL          (0x19 | TAG_TYPE_STRINGREF)
#define TAG_LINK_TEXT         (0x1A | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_TITLE     (0x1B | TAG_TYPE_STRINGREF)
#define TAG_APPHELP_CONTACT   (0x1C | TAG_TYPE_STRINGREF)

#define TAG_SXS_MANIFEST      (0x1D | TAG_TYPE_STRINGREF)

#define TAG_STRINGTABLE       (0x801 | TAG_TYPE_LIST)


//
// DWORD types for shimdb
//
#define TAG_SIZE             (0x1 | TAG_TYPE_DWORD)
#define TAG_OFFSET           (0x2 | TAG_TYPE_DWORD)
#define TAG_CHECKSUM         (0x3 | TAG_TYPE_DWORD)
#define TAG_DLL_TAGID        (0x4 | TAG_TYPE_DWORD)
#define TAG_PATCH_TAGID      (0x5 | TAG_TYPE_DWORD)
#define TAG_MODULETYPE       (0x6 | TAG_TYPE_DWORD)
#define TAG_VERDATEHI        (0x7 | TAG_TYPE_DWORD)
#define TAG_VERDATELO        (0x8 | TAG_TYPE_DWORD)
#define TAG_VERFILEOS        (0x9 | TAG_TYPE_DWORD)
#define TAG_VERFILETYPE      (0xA | TAG_TYPE_DWORD)
#define TAG_PECHECKSUM       (0xB | TAG_TYPE_DWORD)
#define TAG_PREVOSMAJORVER   (0xC | TAG_TYPE_DWORD)
#define TAG_PREVOSMINORVER   (0xD | TAG_TYPE_DWORD)
#define TAG_PREVOSPLATFORMID (0xE | TAG_TYPE_DWORD)
#define TAG_PREVOSBUILDNO    (0xF | TAG_TYPE_DWORD)
#define TAG_PROBLEMSEVERITY  (0x10| TAG_TYPE_DWORD)
#define TAG_LANGID           (0x11| TAG_TYPE_DWORD)

#define TAG_ENGINE           (0x14| TAG_TYPE_DWORD)
#define TAG_HTMLHELPID       (0x15| TAG_TYPE_DWORD)
#define TAG_INDEX_FLAGS      (0x16| TAG_TYPE_DWORD)
#define TAG_FLAGS            (0x17| TAG_TYPE_DWORD)

#define TAG_TAGID            (0x801| TAG_TYPE_DWORD)

//
// STRING types
//
#define TAG_STRINGTABLE_ITEM (0x801 | TAG_TYPE_STRING)

//
// NULL types for shimdb (existence/nonexistence is treated like a BOOL)
//
#define TAG_INCLUDE         (0x1 | TAG_TYPE_NULL)
#define TAG_SAFE            (0x2 | TAG_TYPE_NULL)
#define TAG_GENERAL         (0x3 | TAG_TYPE_NULL)

//
// QWORD types for shimdb
//
#define TAG_TIME                     (0x1 | TAG_TYPE_QWORD)
#define TAG_BIN_FILE_VERSION         (0x2 | TAG_TYPE_QWORD)
#define TAG_BIN_PRODUCT_VERSION      (0x3 | TAG_TYPE_QWORD)
#define TAG_MODTIME                  (0x4 | TAG_TYPE_QWORD)
#define TAG_KERNEL_FLAGS             (0x5 | TAG_TYPE_QWORD)
#define TAG_UPTO_BIN_PRODUCT_VERSION (0x6 | TAG_TYPE_QWORD)

//
// BINARY types for shimdb
//
#define TAG_DLL_BITS        (0x1 | TAG_TYPE_BINARY)
#define TAG_PATCH_BITS      (0x2 | TAG_TYPE_BINARY)
#define TAG_FILE_BITS       (0x3 | TAG_TYPE_BINARY)
#define TAG_EXE_ID          (0x4 | TAG_TYPE_BINARY)

#define TAG_INDEX_BITS      (0x801 | TAG_TYPE_BINARY)

//
// INDEX types for shimdb
//
#define TAG_INDEXES         (0x802 | TAG_TYPE_LIST)
#define TAG_INDEX           (0x803 | TAG_TYPE_LIST)

//
// WORD types
//
#define TAG_TAG             (0x801 | TAG_TYPE_WORD)
#define TAG_INDEX_TAG       (0x802 | TAG_TYPE_WORD)
#define TAG_INDEX_KEY       (0x803 | TAG_TYPE_WORD)

//
// Apps that want to be able to display a text representation
// of the tags can define _WANT_TAG_INFO, and this
// handy static data will be included.
//
#ifdef _WANT_TAG_INFO

typedef struct _TAG_INFO {
    TAG         tWhich;
    WCHAR*      szName;
} TAG_INFO, *PTAG_INFO;

static TAG_INFO gaTagInfo[] = {
    {TAG_DATABASE           ,L"DATABASE"},
    {TAG_LIBRARY            ,L"LIBRARY"},
    {TAG_INEXCLUDE          ,L"INEXCLUDE"},
    {TAG_DLL                ,L"DLL"},
    {TAG_PATCH              ,L"PATCH"},
    {TAG_APP                ,L"APP"},
    {TAG_EXE                ,L"EXE"},
    {TAG_MATCHING_FILE      ,L"MATCHING_FILE"},
    {TAG_DLL_REF            ,L"DLL_REF"},
    {TAG_PATCH_REF          ,L"PATCH_REF"},
    {TAG_LAYER              ,L"LAYER"},
    {TAG_FILE               ,L"FILE"},
    {TAG_APPHELP            ,L"APPHELP"},
    {TAG_LINK               ,L"LINK"},
  
    {TAG_NAME               ,L"NAME"},
    {TAG_DESCRIPTION        ,L"DESCRIPTION"},
    {TAG_MODULE             ,L"MODULE"},
    {TAG_API                ,L"API"},
    {TAG_VENDOR             ,L"VENDOR"},
    {TAG_APP_NAME           ,L"APP_NAME"},
    {TAG_SHORTNAME          ,L"SHORTNAME"},
    {TAG_COMMAND_LINE       ,L"COMMAND_LINE"},
    {TAG_COMPANY_NAME       ,L"COMPANY_NAME"},
    {TAG_WILDCARD_NAME      ,L"WILDCARD_NAME"},
    {TAG_PRODUCT_NAME       ,L"PRODUCT_NAME"},
    {TAG_PRODUCT_VERSION    ,L"PRODUCT_VERSION"},
    {TAG_FILE_DESCRIPTION   ,L"FILE_DESC"},
    {TAG_FILE_VERSION       ,L"FILEVERSION"},
    {TAG_ORIGINAL_FILENAME  ,L"ORIGINALFILENAME"},
    {TAG_INTERNALNAME       ,L"INTERNALNAME"},
    {TAG_LEGALCOPYRIGHT     ,L"LEGALCOPYRIGHT"},
    {TAG_16BITDESCRIPTION   ,L"16BITDESCRIPTION"},
    {TAG_APPHELP_DETAILS    ,L"PROBLEM_DETAILS"},
    {TAG_LINK_URL           ,L"LINK_URL"},
    {TAG_LINK_TEXT          ,L"LINK_TEXT"},
    {TAG_APPHELP_TITLE      ,L"APPHELP_TITLE"},
    {TAG_APPHELP_CONTACT    ,L"APPHELP_CONTACT"},
    {TAG_SXS_MANIFEST       ,L"SXS_MANIFEST"},

    {TAG_SIZE               ,L"SIZE"},
    {TAG_OFFSET             ,L"OFFSET"},
    {TAG_CHECKSUM           ,L"CHECKSUM"},
    {TAG_DLL_TAGID          ,L"DLL_TAGID"},
    {TAG_PATCH_TAGID        ,L"PATCH_TAGID"},
    {TAG_MODULETYPE         ,L"MODULETYPE"},
    {TAG_VERDATEHI          ,L"VERFILEDATEHI"},
    {TAG_VERDATELO          ,L"VERFILEDATELO"},
    {TAG_VERFILEOS          ,L"VERFILEOS"},
    {TAG_VERFILETYPE        ,L"VERFILETYPE"},
    {TAG_PECHECKSUM         ,L"PECHECKSUM"},
    {TAG_PREVOSMAJORVER     ,L"PREVOSMAJORVERSION"},
    {TAG_PREVOSMINORVER     ,L"PREVOSMINORVERSION"},
    {TAG_PREVOSPLATFORMID   ,L"PREVOSPLATFORMID"},
    {TAG_PREVOSBUILDNO      ,L"PREVOSBUILDNO"},
    {TAG_PROBLEMSEVERITY    ,L"PROBLEM_SEVERITY"},
    {TAG_HTMLHELPID         ,L"HTMLHELPID"},
    {TAG_INDEX_FLAGS        ,L"INDEXFLAGS"},
    {TAG_LANGID             ,L"APPHELP_LANGID"},
    {TAG_ENGINE             ,L"ENGINE"},
    {TAG_FLAGS              ,L"FLAGS" },
    
    {TAG_INCLUDE            ,L"INCLUDE"},
    {TAG_SAFE               ,L"SAFE"},
    {TAG_GENERAL            ,L"GENERAL"},

    {TAG_TIME               ,L"TIME"},
    {TAG_BIN_FILE_VERSION   ,L"BIN_FILE_VERSION"},
    {TAG_BIN_PRODUCT_VERSION,L"BIN_PRODUCT_VERSION"},
    {TAG_MODTIME            ,L"MODTIME"},
    {TAG_KERNEL_FLAGS       ,L"KERNEL_FLAGS"},
    {TAG_UPTO_BIN_PRODUCT_VERSION, L"UPTO_BIN_PRODUCT_VERSION"},


    {TAG_DLL_BITS           ,L"DLL_BITS"},
    {TAG_PATCH_BITS         ,L"PATCH_BITS"},
    {TAG_FILE_BITS          ,L"FILE_BITS"},
    {TAG_EXE_ID             ,L"EXE_ID(GUID)"},

    // internal types defined in shimdb.h
    {TAG_STRINGTABLE        ,L"STRINGTABLE"},
    {TAG_INDEXES            ,L"INDEXES"},
    {TAG_INDEX              ,L"INDEX"},
    {TAG_INDEX_TAG          ,L"INDEX_TAG"},
    {TAG_INDEX_KEY          ,L"INDEX_KEY"},
    {TAG_INDEX_BITS         ,L"INDEX_BITS"},
    {TAG_STRINGTABLE_ITEM   ,L"STRTAB_ITEM"},
    {TAG_TAG                ,L"TAG"},
    {TAG_TAGID              ,L"TAGID"},
    

    {TAG_NULL               ,L""} // always needs to be last item
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\vkoem.h ===
/****************************** Module Header ******************************\
* Module Name: vkoem.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This header file OEM Virtual Key definitions
*
* History:
* 04-26-91 IanJa      Created.
\***************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\usp10p.h ===
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//

#ifndef __uspp__
#define __uspp__
#ifdef __cplusplus
extern "C" {
#endif


////    USP10P.H
//
//      Private additions to USP header for use within USP and by the
//      NT5 complex script language pack only.



#if DBG
    #define USPALLOC(a,b)      (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocCache(a, b))
    #define USPALLOCTEMP(a, b) (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocTemp(a, b))
    #define USPFREE(a)         (DG.psFile=__FILE__, DG.iLine=__LINE__, UspFreeMem(a))
#else
    #define USPALLOC(a,b)      UspAllocCache(a, b)
    #define USPALLOCTEMP(a, b) UspAllocTemp(a, b)
    #define USPFREE(a)         UspFreeMem (a)
#endif



/////   LPK entry point serialisation
//
//      Since it is not possible to guarantee that Uniscribe and the
//      LPK receive process deatachment after all their clients, we
//      need to track Uniscribe shutdown.
//
//      At each LPK entrypoint, the LPK calls EnterLpk, and after each exit
//      it calls ExitLpk.
//
//      If Uniscribe is detached, or being detatched, EnterLpk fails. In this
//      case, the LPK entrypoint must do something safe and return directly.
//
//      Uniscribe maintains an LPK nesting level. If a process detach occurs
//      during LPK execution, a detachPending flag is set and will be processed
//      at the ExitLpk that pops all the nesting.


void LpkPresent();  // Used by LPK to disable cleanup at PROCESS_DETACH time




/////   UspAllocCache
//
//      Allocate long term memory for use caching font tables


HRESULT WINAPI UspAllocCache(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspAllocTemp
//
//      Allocate short term memory with lifetime no more than an API call


HRESULT WINAPI UspAllocTemp(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspFreeMem
//
//


HRESULT WINAPI UspFreeMem(
    void  *pv);                 // In   memory to be freed






/////   SCRIPT_STRING_ANALYSIS
//
//      This structure provides all parameters required for script analysis.
//
//

#define MAX_PLANE_0_FONT   13       // max number of non-surrogate fallback fonts
#define MAX_SURROGATE_FONT 16       // max number of the surrogate fallback fonts

// Max fallback fonts including user font (Cannot exceed 31 because usage is recorded in a bitset) 
// and Microsoft Sans Serif and surrogate fallback fonts.
#define MAX_FONT           MAX_PLANE_0_FONT + MAX_SURROGATE_FONT // 29 fonts
                                    
#define DUMMY_MAX_FONT  7           // dummy one for dummy entries

typedef struct tag_STRING_ANALYSIS {

// Input variables - Initialised by the caller

    HDC             hdc;            // Only required for shaping (GCP_Ligate && lpOrder or lpGlyphs arrays specified)

    DWORD           dwFlags;        // See ScriptStringAnalyse
    CHARSETINFO     csi;            // As returned by TranslateCharsetInfo

    // Input buffers

    WCHAR          *pwInChars;      // Unicode input string
    int             cInChars;       // String length
    int             iHotkeyPos;     // Derived from '&' positions if SSA_HOTKEY set

    int             iMaxExtent;     // Required maximum pixel width (used if clipping or fitting)
    const int      *piDx;           // Logical advance width array

    SCRIPT_CONTROL  sControl;
    SCRIPT_STATE    sState;

    SCRIPT_TABDEF  *pTabdef;        // Tabstop definition

    int             cMaxItems;      // Number of entries in pItems
    SCRIPT_ITEM    *pItems;

    // Low cost analysis output buffers
    // No shaping required when fLigate=FALSE
    // Must be at least as long as the input string

    BYTE           *pbLevel;        // Array of item level
    int            *piVisToLog;     // Visual to Logical mapping
    WORD           *pwLeftGlyph;    // Leftmost glyph of each logical item
    WORD           *pwcGlyphs;      // Count of glyphs in each logical item

    SCRIPT_LOGATTR *pLogAttr;       // Cursor points, word and line breaking (indexed in logical order)

    // High cost analysis output buffers
    // Require hDC to be set
    // Must be at least nGlyphs long.

    int             cMaxGlyphs;     // Max glyphs to create
    WORD           *pwGlyphs;       // Output glyph array
    WORD           *pwLogClust;     // logical to visual mapping
    SCRIPT_VISATTR *pVisAttr;       // Justification insertion points (visual order) and other flags
    int            *piAdvance;      // Advance widths
    int            *piJustify;      // Justified advance widths
    GOFFSET        *pGoffset;       // x,y combining character offsets


    // Font fallback

    DWORD           dwFallbacksUsed;// Bitmap of fallback fonts used
    BYTE           *pbFont;         // Font index per item, 0 means original user font

    
    // Obsolete - have to leave them here so the subsequent layout
    // remains unchanged for old LPK to use (wchao, 12/14/2000).
    // we used the first two slots in hf_dummy array for some needed flags
    // take a look to isAssociated and isPrinting
    
    SCRIPT_CACHE    sc_dummy[DUMMY_MAX_FONT];   
    HFONT           isAssociated;               // used as flag to indicate if the user selected font is associated
    HFONT           hf_dummy[DUMMY_MAX_FONT-1]; 

    int             iCurFont;       // 0 For users font
    LOGFONTA        lfA;            // Logfont from the original DC - only set if font fallback happens

// Output variables


    // Item analysis

    int             cItems;        // Number of items analysed == Index of terminal (sentinel) item in pItem


    // Generated glyphs and character measurements
    // Note that
    //  1) nOutGlyphs may be more or less than nInChars.
    //  2) nOutChars may be less than nInChars if fClip was requested.

    int             cOutGlyphs;     // Number of glyphs generated
    int             cOutChars;      // Number of characters generated
    ABC             abc;
    SIZE            size;           // Size of whole line (pixel width and height)

    // For client use

    void           *pvClient;

    
    // fallback font store

    // we store in the items sc[MAX_PLANE_0_FONT-1] and hf[MAX_PLANE_0_FONT-1] the data for Microsoft Sans Serif
    // font which has hight same as the selected user font height.
    // note that hf[1] will have the font data for Microsoft Sans Serif font too but
    // with adjusted height.
    // the items in sc and hf arrays which have index greater than or equal MAX_PLANE_0_FONT will be used 
    // for surrogate fallback fonts.
    
    SCRIPT_CACHE    sc[MAX_FONT];   // Script cache for each fallback, [0] is users font
    HFONT           hf[MAX_FONT];   // Handles to fallback fonts, [0] is users font

} STRING_ANALYSIS;


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\stdexts.h ===
/****************************** Module Header ******************************\
* Module Name: stdexts.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#ifdef NOEXTAPI
#undef NOEXTAPI
#endif // !NOEXTAPI

#define NOEXTAPI
#include <wdbgexts.h>

/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern DWORD                   dwCurrentPc;
extern WINDBG_EXTENSION_APIS  *lpExtensionApis;
#ifdef KERNEL
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;
#endif // KERNEL

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, PVOID src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, PVOID src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PVOID pdst, LPSTR pszExp);
VOID moveExpValuePtr(PVOID pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

PVOID OptEvalExp(LPSTR psz);
PVOID OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
PVOID EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, PVOID);
typedef BOOL (* TYPE_STDARGS2)(DWORD, PVOID, PVOID);
typedef BOOL (* TYPE_STDARGS3)(DWORD, PVOID, PVOID, PVOID);
typedef BOOL (* TYPE_STDARGS4)(DWORD, PVOID, PVOID, PVOID, PVOID);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, PVOID param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2, PVOID param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, PVOID param1, PVOID param2, PVOID param3, PVOID param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\w32w64.h ===
/****************************** Module Header ******************************\
* Module Name: w32w64.h
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* This header file contains macros used to access kernel mode data
* from user mode for wow64.
*
* History:
* 08-18-98 PeterHal     Created.
\***************************************************************************/

#ifndef _W32W64_
#define _W32W64_


/*
 * Kernel32 includes this structure, but we don't want to use _ptr64 in it yet.
 * Kernel32 does not use any shared memory itself.
 */
#if defined(BUILD_WOW6432) && !defined(_KERNEL32_)

    #define KPTR_MODIFIER __ptr64

    typedef VOID * __ptr64          KERNEL_PVOID;
    typedef unsigned __int64        KERNEL_UINT_PTR;
    typedef __int64                 KERNEL_INT_PTR;
    typedef unsigned __int64        KERNEL_ULONG_PTR;
    typedef __int64                 KERNEL_LONG_PTR;

    #define KHANDLE_NULL            0

    #ifdef STRICT
    typedef void * KPTR_MODIFIER KHANDLE;
    #define DECLARE_KHANDLE(name) typedef struct name##__ * KPTR_MODIFIER K ## name
    #else
    typedef KERNEL_PVOID KHANDLE;
    #define DECLARE_KHANDLE(name) typedef KHANDLE K ## name
    #endif

#else

    #define KPTR_MODIFIER

    typedef PVOID                   KERNEL_PVOID;
    typedef UINT_PTR                KERNEL_UINT_PTR;
    typedef INT_PTR                 KERNEL_INT_PTR;
    typedef ULONG_PTR               KERNEL_ULONG_PTR;
    typedef LONG_PTR                KERNEL_LONG_PTR;

    #define KHANDLE_NULL            NULL

    #define DECLARE_KHANDLE(name) typedef name K ## name
    typedef HANDLE KHANDLE;

#endif



#endif // _W32W64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\veriflog.h ===
/*++

    Copyright (c) 2001  Microsoft Corporation

    Module Name:

        VerifLog.h

    Abstract:

        Headers for the AppVerifier log file.

    Revision History:

    04/26/2001  dmunsil     Created.
    08/14/2001  robkenny    Inserted inside the ShimLib namespace.


--*/

#pragma once

#include <stdio.h>
#include "ShimCString.h"
#include "shimdb.h"
#include "avrfutil.h"

namespace ShimLib
{


extern BOOL g_bVerifierLogEnabled;   // enable/disable file logging

class CVerifierLog {
public:
    CString m_strShimName;
    DWORD   m_dwEntries;
    BOOL    m_bHeaderDumped;


    CVerifierLog(LPCSTR szShimName, DWORD dwEntries) {
        m_strShimName = szShimName;
        m_dwEntries = dwEntries;
        m_bHeaderDumped = FALSE;
    }
 
    void __cdecl 
    VLog(
        VLOG_LEVEL eLevel,
        DWORD dwLogNum, 
        LPCSTR pszFmt, 
        ...
        );


    void
    DumpLogEntry(
        DWORD   dwLogNum,
        UINT    unResTitle,
        UINT    unResDescription,
        UINT    unResURL
        );

    void
    DumpShimHeader(void);

};

//
// helper functions
//
BOOL 
InitVerifierLogSupport(
    void);

void
ReleaseVerifierLogSupport(
    void);

void 
WriteToSessionLog(
    LPCSTR szLine
    );

void 
WriteToProcessLog(
    LPCSTR szLine
    );

int 
VLogLoadString(
    HMODULE   hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax);

//
// Goes at top of shim cpp file, or in shared header file for shim
//
#define BEGIN_DEFINE_VERIFIER_LOG(shim) enum {

#define VERIFIER_LOG_ENTRY(entry) entry,

#define END_DEFINE_VERIFIER_LOG(shim)     VLOG_ENTRIES_##shim };                    


//
// goes at top of shim file, after includes and above defines and before any code
//
#define INIT_VERIFIER_LOG(shim) static CVerifierLog g_VLog(#shim, VLOG_ENTRIES_##shim)

//
// goes in shim init section
//
// once for each log entry
#define DUMP_VERIFIER_LOG_ENTRY(entry, title, desc, url)                            \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        g_VLog.DumpLogEntry(entry, title, desc, url);                               \
    }
    
//
// for each log entry required
//
#define VLOG g_VLog.VLog

#define VLOG_MAX_DESC 4096
#define VLOG_MAX_FRIENDLY_NAME 256

//
// goes in each shim module
//
#define SHIM_INFO_BEGIN()                                                           \
BOOL                                                                                \
QueryShimInfo(AVRF_INFO_ID eInfo, PVOID pInfo)                                      \
{

#define SHIM_INFO_DESCRIPTION(res_desc)                                             \
    if (eInfo == AVRF_INFO_DESCRIPTION) {                                           \
        LPWSTR *pszTemp = (LPWSTR*)pInfo;                                           \
        *pszTemp =                                                                  \
            (LPWSTR)ShimMalloc(VLOG_MAX_DESC * sizeof(WCHAR));                      \
        if (*pszTemp) {                                                             \
            VLogLoadString(g_hinstDll,                                              \
                       res_desc,                                                    \
                       (LPWSTR)*pszTemp,                                            \
                       VLOG_MAX_DESC);                                              \
            return TRUE;                                                            \
        }                                                                           \
    }
    
#define SHIM_INFO_FRIENDLY_NAME(res_name)                                           \
    if (eInfo == AVRF_INFO_FRIENDLY_NAME) {                                         \
        LPWSTR *pszTemp = (LPWSTR*)pInfo;                                           \
        *pszTemp =                                                                  \
            (LPWSTR)ShimMalloc(VLOG_MAX_FRIENDLY_NAME * sizeof(WCHAR));             \
        if (*pszTemp) {                                                             \
            VLogLoadString(g_hinstDll,                                              \
                       res_name,                                                    \
                       (LPWSTR)*pszTemp,                                            \
                       VLOG_MAX_FRIENDLY_NAME);                                     \
            return TRUE;                                                            \
        }                                                                           \
    }

#define SHIM_INFO_FLAGS(flags)                                                      \
    if (eInfo == AVRF_INFO_FLAGS) {                                                 \
        *((DWORD*)pInfo) = flags;                                                   \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_GROUPS(groups)                                                    \
    if (eInfo == AVRF_INFO_GROUPS) {                                                \
        *((DWORD*)pInfo) = groups;                                                  \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_VERSION(major, minor)                                             \
    if (eInfo == AVRF_INFO_VERSION) {                                               \
        *((DWORD*)pInfo) = (((DWORD)major) << 16) | minor;                          \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_INCLUDE_EXCLUDE(string)                                           \
    if (eInfo == AVRF_INFO_INCLUDE_EXCLUDE) {                                       \
        *((LPWSTR*)pInfo) = L##string;                                              \
        return TRUE;                                                                \
    }
    
#define SHIM_INFO_OPTIONS_PAGE(res_template, dlgproc)                               \
    if (eInfo == AVRF_INFO_OPTIONS_PAGE) {                                          \
        LPPROPSHEETPAGE lpSheet = (LPPROPSHEETPAGE)pInfo;                           \
                                                                                    \
        lpSheet->hInstance = g_hinstDll;                                            \
        lpSheet->pszTemplate = (LPCWSTR)res_template;                               \
        lpSheet->pfnDlgProc = (DLGPROC)dlgproc;                                     \
                                                                                    \
        return TRUE;                                                                \
    }


#define SHIM_INFO_END()                                                             \
    return FALSE;                                                                   \
}                                                                                   

//
// goes in Main.cpp
//
#define DECLARE_VERIFIER_SHIM(name)                                                 \
    namespace NS_##name                                                             \
    {                                                                               \
        extern BOOL QueryShimInfo(AVRF_INFO_ID eInfo, PVOID pInfo);                 \
    };

// in multi-shim init
#define INIT_VLOG_SUPPORT()                                                         \
    if (fdwReason == DLL_PROCESS_ATTACH) {                                          \
        InitVerifierLogSupport();                                                   \
    }
    

#define DECLARE_VERIFIER_DLL()                                                      \
extern "C" DWORD                                                                    \
GetVerifierMagic(void)                                                              \
{                                                                                   \
    return VERIFIER_SHIMS_MAGIC;                                                    \
}                                                                                   \
/*                                                                                  \
 *  Cause a compile error if the prototype in shimdb.w is out of sync with call     \
 */                                                                                 \
static _pfnGetVerifierMagic __TEST_GetVerifierMagic_PROTO = GetVerifierMagic;
 


#define ENUM_VERIFIER_SHIMS_BEGIN()                                                 \
extern "C" BOOL                                                                     \
QueryShimInfo(LPCWSTR szName, AVRF_INFO_ID eInfo, PVOID pInfo)                      \
{                                                                                   \
    DWORD dwCount = 0;

#define ENUM_VERIFIER_SHIMS_ENTRY(name)                                             \
    if (eInfo == AVRF_INFO_NUM_SHIMS) {                                             \
        dwCount++;                                                                  \
    } else if (eInfo == AVRF_INFO_SHIM_NAMES) {                                     \
        ((LPWSTR*)pInfo)[dwCount] = L#name;                                         \
        dwCount++;                                                                  \
    } else if (szName && _wcsicmp(szName, L#name) == 0) {                           \
        return NS_##name::QueryShimInfo(eInfo, pInfo);                              \
    }
    

#define ENUM_VERIFIER_SHIMS_END()                                                   \
    if (eInfo == AVRF_INFO_NUM_SHIMS) {                                             \
        *((DWORD*)pInfo) = dwCount;                                                 \
        return TRUE;                                                                \
    }                                                                               \
    if (eInfo == AVRF_INFO_SHIM_NAMES) {                                            \
        return TRUE;                                                                \
    }                                                                               \
                                                                                    \
    return FALSE;                                                                   \
}                                                                                   \
/*                                                                                  \
 *  Cause a compile error if the prototype in shimdb.w is out of sync with call     \
 */                                                                                 \
static _pfnQueryShimInfo __TEST_QueryShimInfo_PROTO = QueryShimInfo;



};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\winconp.h ===
#ifndef _WINCONP_
#define _WINCONP_

#ifdef __cplusplus
extern "C" {
#endif
#define ALTNUMPAD_BIT         0x04000000 // AltNumpad OEM char (copied from ntuser\inc\kbd.h)
#define CONSOLE_SELECTION_INVERTED      0x0010   // selection is inverted (turned off)
#define CONSOLE_SELECTION_VALID         (CONSOLE_SELECTION_IN_PROGRESS | \
                                         CONSOLE_SELECTION_NOT_EMPTY | \
                                         CONSOLE_MOUSE_SELECTION | \
                                         CONSOLE_MOUSE_DOWN)

#define ENABLE_INSERT_MODE     0x0020
#define ENABLE_QUICK_EDIT_MODE 0x0040
#define ENABLE_PRIVATE_FLAGS   0x0080

WINBASEAPI
BOOL
WINAPI
GetConsoleKeyboardLayoutNameA( OUT LPSTR );
WINBASEAPI
BOOL
WINAPI
GetConsoleKeyboardLayoutNameW( OUT LPWSTR );
#ifdef UNICODE
#define GetConsoleKeyboardLayoutName  GetConsoleKeyboardLayoutNameW
#else
#define GetConsoleKeyboardLayoutName  GetConsoleKeyboardLayoutNameA
#endif // !UNICODE

//
// Registry strings
//

#define CONSOLE_REGISTRY_STRING      (L"Console")
#define CONSOLE_REGISTRY_FONTSIZE    (L"FontSize")
#define CONSOLE_REGISTRY_FONTFAMILY  (L"FontFamily")
#define CONSOLE_REGISTRY_BUFFERSIZE  (L"ScreenBufferSize")
#define CONSOLE_REGISTRY_CURSORSIZE  (L"CursorSize")
#define CONSOLE_REGISTRY_WINDOWSIZE  (L"WindowSize")
#define CONSOLE_REGISTRY_WINDOWPOS   (L"WindowPosition")
#define CONSOLE_REGISTRY_FILLATTR    (L"ScreenColors")
#define CONSOLE_REGISTRY_POPUPATTR   (L"PopupColors")
#define CONSOLE_REGISTRY_FULLSCR     (L"FullScreen")
#define CONSOLE_REGISTRY_QUICKEDIT   (L"QuickEdit")
#define CONSOLE_REGISTRY_FACENAME    (L"FaceName")
#define CONSOLE_REGISTRY_FONTWEIGHT  (L"FontWeight")
#define CONSOLE_REGISTRY_INSERTMODE  (L"InsertMode")
#define CONSOLE_REGISTRY_HISTORYSIZE (L"HistoryBufferSize")
#define CONSOLE_REGISTRY_HISTORYBUFS (L"NumberOfHistoryBuffers")
#define CONSOLE_REGISTRY_HISTORYNODUP (L"HistoryNoDup")
#define CONSOLE_REGISTRY_COLORTABLE  (L"ColorTable%02u")
#define CONSOLE_REGISTRY_EXTENDEDEDITKEY                L"ExtendedEditKey"
#define CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM         L"ExtendedEditkeyCustom"
#define CONSOLE_REGISTRY_WORD_DELIM                     L"WordDelimiters"
#define CONSOLE_REGISTRY_TRIMZEROHEADINGS               L"TrimLeadingZeros"
#define CONSOLE_REGISTRY_LOAD_CONIME                    L"LoadConIme"
#define CONSOLE_REGISTRY_ENABLE_COLOR_SELECTION			L"EnableColorSelection"


#if defined(FE_SB) // scotthsu
    /*
     * Starting code page
     */
#define CONSOLE_REGISTRY_CODEPAGE    (L"CodePage")
#endif

#if defined(FE_SB)
//
// registry strings on HKEY_LOCAL_MACHINE
//
#define MACHINE_REGISTRY_CONSOLE        (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console")
#define MACHINE_REGISTRY_CONSOLEIME     (L"ConsoleIME")


#define MACHINE_REGISTRY_CONSOLE_TTFONT (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont")


#define MACHINE_REGISTRY_CONSOLE_NLS    (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\Nls")


#define MACHINE_REGISTRY_CONSOLE_FULLSCREEN (L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Console\\FullScreen")
#define MACHINE_REGISTRY_INITIAL_PALETTE           (L"InitialPalette")
#define MACHINE_REGISTRY_COLOR_BUFFER              (L"ColorBuffer")
#define MACHINE_REGISTRY_COLOR_BUFFER_NO_TRANSLATE (L"ColorBufferNoTranslate")
#define MACHINE_REGISTRY_MODE_FONT_PAIRS           (L"ModeFontPairs")
#define MACHINE_REGISTRY_FS_CODEPAGE               (L"CodePage")


#define MACHINE_REGISTRY_EUDC    (L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\CodePage\\EUDCCodeRange")


//
// TrueType font list
//

// doesn't available bold when add BOLD_MARK on first of face name.
#define BOLD_MARK    (L'*')

typedef struct _TT_FONT_LIST {
    SINGLE_LIST_ENTRY List;
    UINT  CodePage;
    BOOL  fDisableBold;
    TCHAR FaceName1[LF_FACESIZE];
    TCHAR FaceName2[LF_FACESIZE];
} TTFONTLIST, *LPTTFONTLIST;
#endif // FE_SB



//
// State information structure
//

typedef struct _CONSOLE_STATE_INFO {
    UINT      Length;
    COORD     ScreenBufferSize;
    COORD     WindowSize;
    INT       WindowPosX;
    INT       WindowPosY;
    COORD     FontSize;
    UINT      FontFamily;
    UINT      FontWeight;
    WCHAR     FaceName[LF_FACESIZE];
    UINT      CursorSize;
    BOOL      FullScreen;
    BOOL      QuickEdit;
    BOOL      AutoPosition;
    BOOL      InsertMode;
    WORD      ScreenAttributes;
    WORD      PopupAttributes;
    BOOL      HistoryNoDup;
    UINT      HistoryBufferSize;
    UINT      NumberOfHistoryBuffers;
    COLORREF  ColorTable[ 16 ];
#if defined(FE_SB)
    /*
     * Startting code page
     */
    UINT      CodePage;
#endif // FE_SB
    HWND      hWnd;
    WCHAR     ConsoleTitle[1];
} CONSOLE_STATE_INFO, *PCONSOLE_STATE_INFO;


//
// Messages sent from properties applet to console server
//

#define CM_PROPERTIES_START          (WM_USER+200)
#define CM_PROPERTIES_UPDATE         (WM_USER+201)
#define CM_PROPERTIES_END            (WM_USER+202)


//
// Extended Line Edit
//

#define EK_INVALID  ' '

//
// Special key for previous word erase
//
#define EXTKEY_ERASE_PREV_WORD  (0x7f)


//
// Ensure the alignment is WORD boundary
//

#include <pshpack2.h>

typedef struct {
    WORD wMod;
    WORD wVirKey;
    WCHAR wUnicodeChar;
} ExtKeySubst;

typedef struct {
    ExtKeySubst keys[3];    // 0: Ctrl
                            // 1: Alt
                            // 2: Ctrl+Alt
} ExtKeyDef;

typedef ExtKeyDef ExtKeyDefTable['Z' - 'A' + 1];

typedef struct {
    DWORD dwVersion;
    DWORD dwCheckSum;
    ExtKeyDefTable table;
} ExtKeyDefBuf;

//
// Restore the previous alignment
//

#include <poppack.h>


#ifdef __cplusplus
}
#endif

#endif // _WINCONP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\windowsp.h ===
/*++ BUILD Version: 0001    Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    windowsp.h
Abstract:

    Master include file for Windows applications.

--*/
#ifndef _WINDOWSP_
#define _WINDOWSP_
#endif /* _WINDOWSP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\winsprlp.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    WinSpolp.h

Abstract:

    Header file for Print APIs

Revision History:

--*/
#ifndef _WINSPOLP_
#define _WINSPOLP_
#ifdef __cplusplus
extern "C" {
#endif
#define PRINTER_ATTRIBUTE_UPDATEWININI      0x80000000
typedef struct _ADDJOB_INFO_2W {
    LPWSTR    pData;
    DWORD     JobId;
} ADDJOB_INFO_2W, *PADDJOB_INFO_2W, *LPADDJOB_INFO_2W;

#define DRIVER_INFO_PRIVATE_LEVEL         100
#define DRIVER_INFO_VERSION_LEVEL         DRIVER_INFO_PRIVATE_LEVEL + 1
//
// You must change RPC_DRIVER_INFCAT_INFO_1 in winspl.idl if you
// want to change structure DRIVER_INFCAT_INFO_1
//
typedef struct _DRIVER_FINFCAT_INFO_1 {
    PCWSTR  pszCatPath;         // full path to the dirver cat file
    PCWSTR  pszCatNameOnSystem; // new cat name used under CatRoot
} DRIVER_INFCAT_INFO_1;

//
// You must change RPC_DRIVER_INFCAT_INFO_2 in winspl.idl if you
// want to change structure DRIVER_INFCAT_INFO_2
//
typedef struct _DRIVER_INFCAT_INFO_2 {
    PCWSTR  pszCatPath;       // full path to the dirver cat file
    PCWSTR  pszInfPath;       // full path to the dirver INF file
    PCWSTR  pszSrcLoc;        // Information abou the Source Inf
    DWORD   dwMediaType;      // Source Media Type
    DWORD   dwCopyStyle;      // Copy Style
} DRIVER_INFCAT_INFO_2;

typedef enum {
    DRIVER_FILE     = 0,
    CONFIG_FILE     = 1,
    DATA_FILE       = 2,
    HELP_FILE       = 3,
    DEPENDENT_FILE  = 4
} DRIVER_FILE_TYPE;

typedef struct _DRIVER_FILE_INFO    {
    DWORD               FileNameOffset;
    DRIVER_FILE_TYPE    FileType;
    DWORD               FileVersion;
} DRIVER_FILE_INFO, *PDRIVER_FILE_INFO, *LPDRIVER_FILE_INFO;

typedef struct _DRIVER_INFO_VERSION {
    DWORD                   cVersion;
    LPWSTR                  pName;
    LPWSTR                  pEnvironment;
    LPDRIVER_FILE_INFO      pFileInfo;
    DWORD                   dwFileCount;
    LPWSTR                  pMonitorName;
    LPWSTR                  pDefaultDataType;
    LPWSTR                  pszzPreviousNames;
    FILETIME                ftDriverDate;
    DWORDLONG               dwlDriverVersion;
    LPWSTR                  pszMfgName;
    LPWSTR                  pszOEMUrl;
    LPWSTR                  pszHardwareID;
    LPWSTR                  pszProvider;
} DRIVER_INFO_VERSION, *PDRIVER_INFO_VERSION, *LPDRIVER_INFO_VERSION;
#define APD_DONT_COPY_FILES_TO_CLUSTER   0x00001000
#define APD_COPY_TO_ALL_SPOOLERS         0x00002000
#define APD_NO_UI                        0x00004000
#define APD_INSTALL_WARNED_DRIVER        0x00008000
#define APD_RETURN_BLOCKING_STATUS_CODE  0x00010000
#define APD_DONT_SET_CHECKPOINT          0x00020000

// FLAGS for AddDriverCatalog
#define APDC_NONE                        0x00000000
#define APDC_USE_ORIGINAL_CAT_NAME       0x00000001
#define EPD_ALL_LOCAL_AND_CLUSTER        TEXT("AllCluster")
//Internal for printprocessor interface
#define DI_CHANNEL_WRITE        2    // Direct write only - background read thread ok
#define PRINTER_ENUM_CLUSTER     0x00000800
typedef struct _SPOOL_FILE_INFO_1 {
    DWORD       dwVersion;
    HANDLE      hSpoolFile;
    DWORD       dwAttributes;
} SPOOL_FILE_INFO_1, *PSPOOL_FILE_INFO_1;
HANDLE
WINAPI
GetSpoolFileHandle(
    HANDLE  hPrinter
);

HANDLE
WINAPI
CommitSpoolData(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile,
    DWORD   cbCommit
);

BOOL
WINAPI
CloseSpoolFileHandle(
    HANDLE  hPrinter,
    HANDLE  hSpoolFile
);
BOOL
WINAPI
AddDriverCatalog(
    IN HANDLE    hPrinter,
    IN DWORD     Level,
    IN VOID      *pvDriverInfCatInfo,
    IN DWORD     dwCatalogCopyFiles
);
BOOL
WINAPI
AddPerMachineConnectionA(
   IN LPCSTR    pServer,
   IN LPCSTR    pPrinterName,
   IN LPCSTR    pPrintServer,
   IN LPCSTR    pProvider
);
BOOL
WINAPI
AddPerMachineConnectionW(
   IN LPCWSTR    pServer,
   IN LPCWSTR    pPrinterName,
   IN LPCWSTR    pPrintServer,
   IN LPCWSTR    pProvider
);
#ifdef UNICODE
#define AddPerMachineConnection  AddPerMachineConnectionW
#else
#define AddPerMachineConnection  AddPerMachineConnectionA
#endif // !UNICODE

BOOL
WINAPI
DeletePerMachineConnectionA(
   IN LPCSTR    pServer,
   IN LPCSTR    pPrinterName
);
BOOL
WINAPI
DeletePerMachineConnectionW(
   IN LPCWSTR    pServer,
   IN LPCWSTR    pPrinterName
);
#ifdef UNICODE
#define DeletePerMachineConnection  DeletePerMachineConnectionW
#else
#define DeletePerMachineConnection  DeletePerMachineConnectionA
#endif // !UNICODE

BOOL
WINAPI
EnumPerMachineConnectionsA(
    IN LPCSTR   pServer,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
BOOL
WINAPI
EnumPerMachineConnectionsW(
    IN LPCWSTR   pServer,
    OUT LPBYTE  pPrinterEnum,
    IN DWORD   cbBuf,
    OUT LPDWORD pcbNeeded,
    OUT LPDWORD pcReturned
);
#ifdef UNICODE
#define EnumPerMachineConnections  EnumPerMachineConnectionsW
#else
#define EnumPerMachineConnections  EnumPerMachineConnectionsA
#endif // !UNICODE
BOOL
WINAPI
SeekPrinter(
    IN HANDLE hPrinter,
    IN LARGE_INTEGER liDistanceToMove,
    OUT PLARGE_INTEGER pliNewPointer,
    IN DWORD dwMoveMethod,
    IN BOOL bWrite
);
BOOL
WINAPI
SplReadPrinter(
    HANDLE  hPrinter,
    LPBYTE  *pBuf,
    DWORD   cbBuf
);
BOOL
WINAPI
EnumPrinterPropertySheets(
    IN HANDLE  hPrinter,
    IN HWND    hWnd,
    IN LPFNADDPROPSHEETPAGE    lpfnAdd,
    IN LPARAM  lParam
);

#define ENUMPRINTERPROPERTYSHEETS_ORD     100
BOOL
WINAPI
PublishPrinterA(
    IN HWND       hwnd,
    IN LPCSTR     pszUNCName,
    IN LPCSTR     pszDN,
    IN LPCSTR     pszCN,
    OUT LPSTR     *ppszDN,
    IN DWORD      dwAction
);

BOOL
WINAPI
PublishPrinterW(
    IN HWND       hwnd,
    IN LPCWSTR    pszUNCName,
    IN LPCWSTR    pszDN,
    IN LPCWSTR    pszCN,
    OUT LPWSTR    *ppszDN,
    IN DWORD      dwAction
);

#define PUBLISHPRINTER_QUERY                1
#define PUBLISHPRINTER_DELETE_DUPLICATES    2
#define PUBLISHPRINTER_FAIL_ON_DUPLICATE    3
#define PUBLISHPRINTER_IGNORE_DUPLICATES    4
BOOL
ClusterSplOpen(
    IN LPCTSTR pszServer,
    IN LPCTSTR pszResource,
    OUT PHANDLE phSpooler,
    IN LPCTSTR pszName,
    IN LPCTSTR pszAddress
);

BOOL
ClusterSplClose(
    IN HANDLE hSpooler
);

BOOL
ClusterSplIsAlive(
    IN HANDLE hSpooler
);
#define    SPLREG_NO_REMOTE_PRINTER_DRIVERS           TEXT("NoRemotePrinterDrivers")
#define    SPLREG_NON_RAW_TO_MASQ_PRINTERS            TEXT("NonRawToMasqPrinters")
#define    SPLREG_CHANGE_ID                           TEXT("ChangeId")
#define    SPLREG_CLUSTER_LOCAL_ROOT_KEY              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Print\\Cluster")
#define    SPLREG_CLUSTER_UPGRADE_KEY                 TEXT("ClusterUpgrade")
#define    SPLREG_CLUSTER_DRIVER_DIRECTORY            TEXT("ClusterDriverDirectory")
BOOL
SpoolerInit(
    VOID
    );
#ifdef __cplusplus
}
#endif
#endif // _WINSPOLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\winfont.h ===
/******************************Module*Header*******************************\
* Module Name: winfont.h
*
* font file headers for 2.0 and 3.0 windows *.fnt files
*
* Created: 25-Oct-1990 11:08:08
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* (General description of its use)
*
*
\**************************************************************************/


/******************************Public*Macro********************************\
* WRITE_WORD
*
* Writes a word to the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define WRITE_WORD(pv, word)                                        \
{                                                                   \
    *(PBYTE) (pv)       = (BYTE) ((word) & 0x00ff);                 \
    *((PBYTE) (pv) + 1) = (BYTE) (((word) & 0xff00) >> 8);          \
}


/******************************Public*Macro********************************\
* READ_WORD
*
* Reads a word from the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define READ_WORD(pv)                                               \
( (WORD)                                                            \
    ( ((WORD)*(PBYTE) (pv)) & (WORD)0x00ff ) |                      \
    ( ((WORD)*((PBYTE) (pv) + (WORD)1) & (WORD)0x00ff) << 8 )       \
)



/******************************Public*Macro********************************\
* WRITE_DWORD
*
* Writes a dword to the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


#define WRITE_DWORD(pv, dword)                                      \
{                                                                   \
    *(PBYTE) (pv)       = (BYTE) ((dword) & 0x000000ff);            \
    *((PBYTE) (pv) + 1) = (BYTE) (((dword) & 0x0000ff00) >> 8 );    \
    *((PBYTE) (pv) + 2) = (BYTE) (((dword) & 0x00ff0000) >> 16);    \
    *((PBYTE) (pv) + 3) = (BYTE) (((dword) & 0xff000000) >> 24);    \
}


/******************************Public*Macro********************************\
* READ_DWORD
*
* Reads a DWORD from the misaligned address, pv.
*
* !!! Note: this only works for little-endian.
*
* History:
*  11-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define READ_DWORD(pv)                                              \
( (DWORD)                                                           \
    ( (*(PBYTE) (pv)) & 0x000000ff ) |                              \
    ( (*((PBYTE) (pv) + 1) & 0x000000ff) << 8 ) |                   \
    ( (*((PBYTE) (pv) + 2) & 0x000000ff) << 16) |                   \
    ( (*((PBYTE) (pv) + 3) & 0x000000ff) << 24)                     \
)


// font file header (2.0 ddk adaptation guide, 7.7.3.
// and 3.0 ddk,  Adaptation Guide section 13.3)

// CAUTION: These structures, as they are defined in the Adaptation Guide are
//          out of allignment.(Not even WORD alligned,let alone DWORD alligned.)
//          Here we make our own structures, so that when
//          disk files are read in the data is copied in correctly, and so that
//          the data can be accessed in memory regardless of the architecture.

/**************************************************************************\

// the original structure was

typedef struct {
    WORD    Version;          // Always 17985 for the Nonce
    DWORD   Size;             // Size of whole file
    char    Copyright[60];
    WORD    Type;             // Raster Font if Type & 1 == 0
    WORD    Points;           // Nominal Point size
    WORD    VertRes;          // Nominal Vertical resolution
    WORD    HorizRes;         // Nominal Horizontal resolution
    WORD    Ascent;           // Height of Ascent
    WORD    IntLeading;       // Internal (Microsoft) Leading
    WORD    ExtLeading;       // External (Microsoft) Leading
    BYTE    Italic;           // Italic font if set
    BYTE    Underline;        // Etc.
    BYTE    StrikeOut;        // Etc.
    WORD    Weight;           // Weight: 200 = regular
    BYTE    CharSet;          // ANSI=0. other=255
    WORD    PixWidth;         // Fixed width. 0 ==> Variable
    WORD    PixHeight;        // Fixed Height
    BYTE    Family;           // Pitch and Family
    WORD    AvgWidth;         // Width of character 'X'
    WORD    MaxWidth;         // Maximum width
    BYTE    FirstChar;        // First character defined in font
    BYTE    LastChar;         // Last character defined in font
    BYTE    DefaultChar;          // Sub. for out of range chars.
    BYTE    BreakChar;        // Word Break Character
    WORD    WidthBytes;       // No.Bytes/row of Bitmap
    DWORD   Device;           // Pointer to Device Name string
    DWORD   Face;           // Pointer to Face Name String
    DWORD   BitsPointer;        // Pointer to Bit Map
    DWORD   BitsOffset;     // Offset to Bit Map
    } FontHeaderType;       // Above pointers all rel. to start of file

// the original 3.0 header:

typedef struct {
    WORD    fsVersion;
    DWORD   fsSize;
    char    fsCopyright[60];
    WORD    fsType;           // Type field for the font
    WORD    fsPoints;         // Point size of font
    WORD    fsVertRes;        // Vertical digitization
    WORD    fsHorizRes;       // Horizontal digitization
    WORD    fsAscent;         // Baseline offset from char cell top
    WORD    fsInternalLeading;    // Internal leading included in font
    WORD    fsExternalLeading;    // Prefered extra space between lines
    BYTE    fsItalic;         // Flag specifying if italic
    BYTE    fsUnderline;          // Flag specifying if underlined
    BYTE    fsStrikeOut;          // Flag specifying if struck out
    WORD    fsWeight;         // Weight of font
    BYTE    fsCharSet;        // Character set of font
    WORD    fsPixWidth;       // Width field for the font
    WORD    fsPixHeight;          // Height field for the font
    BYTE    fsPitchAndFamily;     // Flag specifying pitch and family
    WORD    fsAvgWidth;       // Average character width
    WORD    fsMaxWidth;       // Maximum character width
    BYTE    fsFirstChar;          // First character in the font
    BYTE    fsLastChar;       // Last character in the font
    BYTE    fsDefaultChar;        // Default character for out of range
    BYTE    fsBreakChar;          // Character to define wordbreaks
    WORD    fsWidthBytes;         // Number of bytes in each row
    DWORD   fsDevice;         // Offset to device name
    DWORD   fsFace;           // Offset to face name
    DWORD   fsBitsPointer;        // Bits pointer
    DWORD   fsBitsOffset;         // Offset to the begining of the bitmap
    BYTE    fsDBfiller;       // Word alignment for the offset table

    DWORD   fsFlags;          // Bit flags
    WORD    fsAspace;         // Global A space, if any
    WORD    fsBspace;         // Global B space, if any
    WORD    fsCspace;         // Global C space, if any
    DWORD   fsColorPointer;       // offset to color table, if any
    DWORD   fsReserved[4];        //
    BYTE    fsCharOffset;         // Area for storing the char. offsets

    } FontHeader30;

typedef struct tagFFH {
    WORD        fhVersion        ;
    DWORD       fhSize           ;
    char        fhCopyright[60]  ;
    WORD        fhType           ;
    WORD        fhPoints         ;
    WORD        fhVertRes        ;
    WORD        fhHorizRes       ;
    WORD        fhAscent         ;
    WORD        fhInternalLeading;
    WORD        fhExternalLeading;
    BYTE        fhItalic         ;
    BYTE        fhUnderline      ;
    BYTE        fhStrikeOut      ;
    WORD        fhWeight         ;
    BYTE        fhCharSet        ;
    WORD        fhPixWidth       ;
    WORD        fhPixHeight      ;
    BYTE        fhPitchAndFamily ;
    WORD        fhAvgWidth       ;
    WORD        fhMaxWidth       ;
    BYTE        fhFirstChar      ;
    BYTE        fhLastChar       ;
    BYTE        fhDefaultChar    ;
    BYTE        fhBreakChar      ;
    WORD        fhWidthBytes     ;
    DWORD       fhDevice         ;
    DWORD       fhFace           ;
    DWORD       fhBitsPointer    ;
    } FFH;

\**************************************************************************/


// type of the font file

#define TYPE_RASTER                     0x0000
#define TYPE_VECTOR                     0x0001
#define TYPE_BITS_IN_ROM                0x0004
#define TYPE_REALIZED_BY_DEVICE         0x0080

// reserved fields in the fsType field, used are 0-th,2-nd, and 7-th bit

#define BITS_RESERVED (~(TYPE_VECTOR|TYPE_BITS_IN_ROM|TYPE_REALIZED_BY_DEVICE))

// supported in win 3.0

#define DFF_FIXED                0x01    // fixed font
#define DFF_PROPORTIONAL         0x02    // proportional font

// not supported in win 3.0, except maybe if someone has
// custom created such a font, using font editor or a similar tool

#define DFF_ABCFIXED             0x04    // ABC fixed font
#define DFF_ABCPROPORTIONAL      0x08    // ABC proportional font
#define DFF_1COLOR               0x10
#define DFF_16COLOR              0x20
#define DFF_256COLOR             0x40
#define DFF_RGBCOLOR             0x80


// here we list offsets of all fields of the original  structures
// as they are computed under the assumption that the C compiler does not
// insert any paddings between fields

#define  OFF_Version          0L   //   WORD     Always 17985 for the Nonce
#define  OFF_Size             2L   //   DWORD    Size of whole file
#define  OFF_Copyright        6L   //   char[60]

// Note: Win 3.1 hack.  The LSB of Type is used by Win 3.1 as an engine type
//       and font embedding flag.  Font embedding is a form of a "hidden
//       font file".  The MSB of Type is the same as the fsSelection from
//       IFIMETRICS.  (Strictly speaking, the MSB of Type is equal to the
//       LSB of IFIMETRICS.fsSelection).

#define  OFF_Type            66L   //   WORD     Raster Font if Type & 1 == 0
#define  OFF_Points          68L   //   WORD     Nominal Point size
#define  OFF_VertRes         70L   //   WORD     Nominal Vertical resolution
#define  OFF_HorizRes        72L   //   WORD     Nominal Horizontal resolution
#define  OFF_Ascent          74L   //   WORD     Height of Ascent
#define  OFF_IntLeading      76L   //   WORD     Internal (Microsoft) Leading
#define  OFF_ExtLeading      78L   //   WORD     External (Microsoft) Leading
#define  OFF_Italic          80L   //   BYTE     Italic font if set
#define  OFF_Underline       81L   //   BYTE     Etc.
#define  OFF_StrikeOut       82L   //   BYTE     Etc.
#define  OFF_Weight          83L   //   WORD     Weight: 200 = regular
#define  OFF_CharSet         85L   //   BYTE     ANSI=0. other=255
#define  OFF_PixWidth        86L   //   WORD     Fixed width. 0 ==> Variable
#define  OFF_PixHeight       88L   //   WORD     Fixed Height
#define  OFF_Family          90L   //   BYTE     Pitch and Family
#define  OFF_AvgWidth        91L   //   WORD     Width of character 'X'
#define  OFF_MaxWidth        93L   //   WORD     Maximum width
#define  OFF_FirstChar       95L   //   BYTE     First character defined in font
#define  OFF_LastChar        96L   //   BYTE     Last character defined in font
#define  OFF_DefaultChar     97L   //   BYTE     Sub. for out of range chars.
#define  OFF_BreakChar       98L   //   BYTE     Word Break Character
#define  OFF_WidthBytes      99L   //   WORD     No.Bytes/row of Bitmap
#define  OFF_Device         101L   //   DWORD    Pointer to Device Name string
#define  OFF_Face           105L   //   DWORD    Pointer to Face Name String
#define  OFF_BitsPointer    109L   //   DWORD    Pointer to Bit Map
#define  OFF_BitsOffset     113L   //   DWORD    Offset to Bit Map
#define  OFF_jUnused20      117L   //   BYTE     byte filler
#define  OFF_OffTable20     118L   //   WORD     here begins char table for 2.0

// 3.0 addition

#define  OFF_jUnused30      117L       //  BYTE      enforces word allignment
#define  OFF_Flags      118L       //  DWORD     Bit flags
#define  OFF_Aspace     122L       //  WORD      Global A space, if any
#define  OFF_Bspace     124L       //  WORD      Global B space, if any
#define  OFF_Cspace     126L       //  WORD      Global C space, if any
#define  OFF_ColorPointer   128L       //  DWORD     offset to color table, if any
#define  OFF_Reserved       132L       //  DWORD[4]
#define  OFF_OffTable30     148L       //  WORD      Area for storing the char. offsets in 3.0

// latest offset for pscript device font pfm files [bodind]

#if 0

// This is from win31 sources \drivers\printers\pstt\utils\pfm.c [bodind]
........

WORD dfWidthBytes;
DWORD dfDevice;
DWORD dfFace;
DWORD dfBitsPointer;
DWORD dfBitsOffset;  // up to here the offsets are the same as in *.fon files

WORD  dfSizeFields;
DWORD dfExtMetricsOffset;
DWORD dfExtentTable;
DWORD dfOriginTable;
DWORD dfPairKernTable;
DWORD dfTrackKernTable;
DWORD dfDriverInfo;
DWORD dfReserved;

#endif

#define  OFF_SizeFields         117L
#define  OFF_ExtMetricsOffset   119L
#define  OFF_ExtentTable        123L
#define  OFF_OriginTable        127L
#define  OFF_PairKernTable      131L
#define  OFF_TrackKernTable     135L
#define  OFF_DriverInfo         139L
#define  OFF_ReservedPscript    143L


// FFH offsets

#define  OFF_FFH_Version          0L   //   WORD     Always 17985 for the Nonce
#define  OFF_FFH_Size             2L   //   DWORD    Size of whole file
#define  OFF_FFH_Copyright        6L   //   char[60]
#define  OFF_FFH_Type            66L   //   WORD     Raster Font if Type & 1 == 0
#define  OFF_FFH_Points          68L   //   WORD     Nominal Point size
#define  OFF_FFH_VertRes         70L   //   WORD     Nominal Vertical resolution
#define  OFF_FFH_HorizRes        72L   //   WORD     Nominal Horizontal resolution
#define  OFF_FFH_Ascent          74L   //   WORD     Height of Ascent
#define  OFF_FFH_IntLeading      76L   //   WORD     Internal (Microsoft) Leading
#define  OFF_FFH_ExtLeading      78L   //   WORD     External (Microsoft) Leading
#define  OFF_FFH_Italic          80L   //   BYTE     Italic font if set
#define  OFF_FFH_Underline       81L   //   BYTE     Etc.
#define  OFF_FFH_StrikeOut       82L   //   BYTE     Etc.
#define  OFF_FFH_Weight          83L   //   WORD     Weight: 200 = regular
#define  OFF_FFH_CharSet         85L   //   BYTE     ANSI=0. other=255
#define  OFF_FFH_PixWidth        86L   //   WORD     Fixed width. 0 ==> Variable
#define  OFF_FFH_PixHeight       88L   //   WORD     Fixed Height
#define  OFF_FFH_Family          90L   //   BYTE     Pitch and Family
#define  OFF_FFH_AvgWidth        91L   //   WORD     Width of character 'X'
#define  OFF_FFH_MaxWidth        93L   //   WORD     Maximum width
#define  OFF_FFH_FirstChar       95L   //   BYTE     First character defined in font
#define  OFF_FFH_LastChar        96L   //   BYTE     Last character defined in font
#define  OFF_FFH_DefaultChar     97L   //   BYTE     Sub. for out of range chars.
#define  OFF_FFH_BreakChar       98L   //   BYTE     Word Break Character
#define  OFF_FFH_WidthBytes      99L   //   WORD     No.Bytes/row of Bitmap
#define  OFF_FFH_Device         101L   //   DWORD    Pointer to Device Name string
#define  OFF_FFH_Face           105L   //   DWORD    Pointer to Face Name String
#define  OFF_FFH_BitsPointer    109L   //   DWORD    Pointer to Bit Map

#define SIZEFFH (OFF_FFH_BitsPointer + 4)


// This is used in NtGdiMakeFontDir

#define CJ_FONTDIR (SIZEFFH + LF_FACESIZE + LF_FULLFACESIZE + LF_FACESIZE + 10)




// header sizes in bytes of the original headers

#define  HDRSIZE20         117L   //   or 113L ?
#define  HDRSIZE30         148L   //   CharOffset is not counted as header

#define  HDRSIZEDIFF       (HDRSIZE30 - HDRSIZE20)   // 31 byte



// ranges for some quantities

#define MAX_PT_SIZE         999     // max size in points

// weight range

#define MIN_WEIGHT             1    // adaptation guide
#define MAX_WEIGHT          1000    // adaptation guide

// maximal size of bitmap font in pixels, (bound on cx and cy)

#define  MAX_PEL_SIZE  64

// 2.0 fonts have offsets that fit into 64k

#define SEGMENT_SIZE 65536L     // IN bytes

// offset limit for 2.0 font files

#define MAX_20_OFFSET      65534   // 64K - 2

// sizes of the offset table entries for the 2.0 and 3.0 fonts respectively

#define CJ_ENTRY_20  4   // two bytes for cx + two bytes for the offset
#define CJ_ENTRY_30  6   // two bytes for cx + four bytes for the offset


#define WINWT_TO_PANWT(x) ((x)/100 + 1)

// From [Windows 3.1] gdifeng.inc

#define WIN_VERSION 0x0310
#define GDI_VERSION 0x0101


// From [Windows 3.1] gdipfont.inc

#define PF_ENGINE_TYPE  0x03
#define PF_ENCAPSULATED 0x80        // used in FFH.fhType to identify hidden (embedded) font
#define PANDFTYPESHIFT  1

// for embeded fonts

#define PF_TID          0x40    // if set use TID ( WOW apps )
                                // otherwise use PID ( NT apps )


// From [Windows 3.1] fonteng2.asm
#define DEF_BRK_CHARACTER   0x0201  // default char for all TT fonts


// BITMAP size related macros

// number of bytes in a scan of a monobitmap that actually contain some info
// Note that this is the same as ((((cx) + 7) & ~7) >> 3), the last two bits
// are lost anyway because of >> 3

#define CJ_SCAN(cx) (((cx) + 7) >> 3)

// move this to a common place so we don't have it in multiple places
// given a byte count, compute the minimum 4 byte (DWORD) aligned size (in bytes)

#define ALIGN4(X) (((X) + 3) & ~3)

// size of the whole  bimtap, only dword pad the last scan

#define CJ_BMP(cx,cy) ALIGN4(CJ_SCAN(cx) * (cy))

// get the size of GLYPHDATA  structure that at the bottom has appended
// a dib format bitmap for the glyph
// Add  offsetof(GLYPHDATA,aulBMData[2]) to cjDIB to account for cx and cy
// are stored in aulBMData[0] and aulBMData[1] respectively

#define CJ_GLYPHDATA(cx,cy) (offsetof(GLYPHBITS,aj) + CJ_BMP(cx,cy))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\wingdip.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wingdi.h

Abstract:

    Procedure declarations, constant definitions and macros for the GDI
    component.

--*/
#ifndef _WINGDIP_
#define _WINGDIP_
#ifdef __cplusplus
extern "C" {
#endif
// BitBlt RTL mirroring rop (RTL_MIRRORING)
// RTL Layout Constants (RTL_MIRRORING)
// SetLayout Metafile call (RTL_MIRRORING)
#define LCS_DEVICE_RGB                  0x00000001L
#define LCS_DEVICE_CMYK                 0x00000002L
#define BI_CMYK      10L
#define BI_CMYKRLE8  11L
#define BI_CMYKRLE4  12L
#define CAPS1         94    /* Extra Caps */

/* CAPS1 (Win 9x internal) */
#define C1_TRANSPARENT      0x0001
#define TC_TT_ABLE          0x0002
#define C1_TT_CR_ANY        0x0004
#define C1_EMF_COMPLIANT    0x0008
#define C1_DIBENGINE        0x0010
#define C1_GAMMA_RAMP       0x0020 /* CM_GAMMA_RAMP for NT */
#define C1_DIC              0x0040 /* CM_DEVICE_ICM for NT */
#define C1_REINIT_ABLE      0x0080
#define C1_GLYPH_INDEX      0x0100
#define C1_BIT_PACKED       0x0200
#define C1_BYTE_PACKED      0x0400
#define C1_COLORCURSOR      0x0800
#define C1_CMYK_ABLE        0x1000 /* CM_CMYK_COLOR for NT */
#define C1_SLOW_CARD        0x2000

/* CAPS1 (NT 5 internal) */
#define C1_MIRROR_DEVICE    0x4000

#define CBM_CREATEDIB   0x02L   /* create DIB bitmap */
#define DMDUP_LAST      DMDUP_HORIZONTAL
#define DMTT_LAST             DMTT_DOWNLOAD_OUTLINE
#define DMDO_LAST       DMDO_270
#define DMDFO_LAST      DMDFO_CENTER
#define DMDISPLAYFLAGS_VALID    0x00000004
#define DMICMMETHOD_LAST    DMICMMETHOD_DEVICE
#define DMICM_LAST          DMICM_ABS_COLORIMETRIC
#define DMMEDIA_LAST          DMMEDIA_GLOSSY
#define DMDITHER_LAST       DMDITHER_GRAYSCALE

/* EnumDisplayDevices */

#if (_WIN32_WINNT >= 0x0501)
#define EDD_DISPLAY_DEVICE_PRUNED       0x00000001
#endif /* _WIN32_WINNT >= 0x0501 */
#define DISPLAY_DEVICE_POWERED_OFF         0x80000000
#define DISPLAY_DEVICE_ACPI                0x40000000
#define DISPLAY_DEVICE_DUALVIEW            0x20000000
#define DISPLAY_DEVICE_PRUNE_FREQ          0x80000000
#define DISPLAY_DEVICE_PRUNE_RESOLUTION    0x40000000

WINGDIAPI int  WINAPI GetTextFaceAliasW(HDC hdc,int c,LPWSTR pwsz);
WINGDIAPI HBITMAP SetBitmapAttributes(HBITMAP hbm, DWORD dwFlags);
WINGDIAPI HBITMAP ClearBitmapAttributes(HBITMAP hbm, DWORD dwFlags);
WINGDIAPI DWORD   GetBitmapAttributes(HBITMAP hbm);
#define SBA_STOCK 0x00000001
WINGDIAPI HBRUSH SetBrushAttributes(HBRUSH hbr, DWORD dwFlags);
WINGDIAPI HBRUSH ClearBrushAttributes(HBRUSH hbr, DWORD dwFlags);
WINGDIAPI DWORD  GetBrushAttributes(HBRUSH hbr);
/* DC_MANUFACTURER is DC_ICC_MANUFACTURER in 16 bit PRINT.H */
/* DC_MODEL is DC_ICC_MODEL in 16 bit PRINT.H               */
HANDLE WINAPI SetObjectOwner( IN HGDIOBJ, IN HANDLE);
// Mirroring APIs (RTL_MIRRORING)
#if(WINVER >= 0x0500)
WINGDIAPI BOOL  WINAPI MirrorRgn(IN HWND, IN HRGN);
WINGDIAPI DWORD WINAPI SetLayoutWidth(IN HDC, IN LONG, IN DWORD);
#endif /* WINVER >= 0x0500 */

#if (_WIN32_WINNT >= 0x0500)

//
// alpha blend flags
//

#define AC_USE_HIGHQUALITYFILTER             0x01
#define AC_MIRRORBITMAP                      0x80

WINGDIAPI BOOL  WINAPI GdiAlphaBlend( IN HDC, IN int, IN int, IN int, IN int, IN HDC, IN int, IN int, IN int, IN int, IN BLENDFUNCTION);

WINGDIAPI BOOL  WINAPI GdiTransparentBlt(IN HDC,IN int,IN int,IN int,IN int,IN HDC,IN int,IN int,IN int,IN int,IN UINT);

WINGDIAPI BOOL  WINAPI GdiGradientFill( IN HDC, IN PTRIVERTEX, IN ULONG, IN PVOID, IN ULONG, IN ULONG);

#endif



#if (_WIN32_WINNT >= 0x0501)

#ifndef DS_ENABLE_BLT
#define DS_ENABLE_BLT 0
#endif

#define DS_MAGIC                'DrwS'
#define DS_SETTARGETID          0
#define DS_SETSOURCEID          1

#define DS_NINEGRIDID           9

#if DS_ENABLE_BLT
#define DS_BLTID                10
#define DS_SETBLENDID           11
#define DS_SETCOLORKEYID        12
#endif

typedef struct _DS_HEADER
{
    ULONG   magic;
} DS_HEADER;

typedef struct _DS_SETTARGET
{
    ULONG   ulCmdID;
    ULONG   hdc;
    RECTL   rclDstClip;
} DS_SETTARGET;

typedef struct _DS_SETSOURCE
{
    ULONG   ulCmdID;
    ULONG   hbm;
} DS_SETSOURCE;

#define DSDNG_STRETCH         0x01
#define DSDNG_TILE            0x02
#define DSDNG_PERPIXELALPHA   0x04
#define DSDNG_TRANSPARENT     0x08
#define DSDNG_MUSTFLIP        0x10
#define DSDNG_TRUESIZE        0x20

typedef struct _DS_NINEGRIDINFO
{
    ULONG            flFlags;
    LONG             ulLeftWidth;
    LONG             ulRightWidth;
    LONG             ulTopHeight;
    LONG             ulBottomHeight;
    COLORREF         crTransparent;
} DS_NINEGRIDINFO;

typedef struct _DS_NINEGRID
{
    ULONG            ulCmdID;
    RECTL            rclDst;
    RECTL            rclSrc;
    DS_NINEGRIDINFO  ngi;
} DS_NINEGRID;

#if DS_EANBLE_BLT

#define DSBLT_HTILE           0x01
#define DSBLT_VTILE           0x02
#define DSBLT_ALPHABLEND      0x04
#define DSBLT_TRANSPARENT     0x08

typedef struct _DS_BLT
{
    ULONG            ulCmdID;
    RECTL            rclDst;
    RECTL            rclSrc;
    FLONG            flFlags;
} DS_BLT;

typedef struct _DS_SETBLEND
{
    BLENDFUNCTION   blendFunction;
} DS_SETBLEND;

typedef struct _DS_SETCOLORKEY
{
    COLORREF         crColorKey;
} DS_SETCOLORKEY;
#endif

WINGDIAPI BOOL  WINAPI GdiDrawStream( IN HDC, IN ULONG, IN VOID *);

#endif
// Ansi version of CreateColorSpace
// (Windows 98 comaptible record)
// Unicode version of StartDoc record
// SetLayout Metafile Record (RTL_MIRRORING)
#ifdef __cplusplus
}
#endif

#define CCB_NOVIDEOMEMORY       0x01000000

// Old fields that Chicago won't support that we can't publically
// support anymore

#define HS_SOLIDCLR         6
#define HS_DITHEREDCLR      7
#define HS_SOLIDTEXTCLR     8
#define HS_DITHEREDTEXTCLR  9
#define HS_SOLIDBKCLR       10
#define HS_DITHEREDBKCLR    11
#define HS_API_MAX          12

#define DIB_PAL_INDICES     2 /* No color table indices into surf palette */

// Private indicies for GetStockObject over the CS interface.

#define PRIV_STOCK_COLORSPACE   (STOCK_LAST +  1)
#define PRIV_STOCK_BITMAP       (STOCK_LAST +  2)
#define PRIV_STOCK_LAST         PRIV_STOCK_BITMAP

#define DCB_WINDOWMGR   0x00008000L

// GetTransform flags.

#define XFORM_WORLD_TO_PAGE       0x0203
#define XFORM_WORLD_TO_DEVICE     0x0204
#define XFORM_PAGE_TO_DEVICE      0x0304
#define XFORM_PAGE_TO_WORLD       0x0302
#define XFORM_DEVICE_TO_WORLD     0x0402
#define XFORM_DEVICE_TO_PAGE      0x0403


#if(WINVER >= 0x0500)
#define EMR_DRAWESCAPE                 105
#define EMR_EXTESCAPE                  106
// Unicode version of StartDoc record
#define EMR_STARTDOC                   107
#define EMR_SMALLTEXTOUT               108
#define EMR_FORCEUFIMAPPING            109
#define EMR_NAMEDESCAPE                110
#define EMR_SETLINKEDUFIS              119
#define EMR_SETTEXTJUSTIFICATION       120
#endif /* WINVER >= 0x0500 */

enum DCTYPE {
    DCTYPE_DIRECT,
    DCTYPE_MEMORY,
    DCTYPE_INFO};

// the following structure is only used for GetETM postscript escape

typedef struct _EXTTEXTMETRIC {
    SHORT  etmSize;
    SHORT  etmPointSize;
    SHORT  etmOrientation;
    SHORT  etmMasterHeight;
    SHORT  etmMinScale;
    SHORT  etmMaxScale;
    SHORT  etmMasterUnits;
    SHORT  etmCapHeight;
    SHORT  etmXHeight;
    SHORT  etmLowerCaseAscent;
    SHORT  etmLowerCaseDescent;
    SHORT  etmSlant;
    SHORT  etmSuperScript;
    SHORT  etmSubScript;
    SHORT  etmSuperScriptSize;
    SHORT  etmSubScriptSize;
    SHORT  etmUnderlineOffset;
    SHORT  etmUnderlineWidth;
    SHORT  etmDoubleUpperUnderlineOffset;
    SHORT  etmDoubleLowerUnderlineOffset;
    SHORT  etmDoubleUpperUnderlineWidth;
    SHORT  etmDoubleLowerUnderlineWidth;
    SHORT  etmStrikeOutOffset;
    SHORT  etmStrikeOutWidth;
    WORD   etmNKernPairs;
    WORD   etmNKernTracks;
} EXTTEXTMETRIC;

// the following structure is only used for GETPAIRKERNTABLE escape

#pragma pack(1)
typedef struct _KERNPAIR
{
    WORD  wBoth;
    SHORT sAmount;
} KERNPAIR, *LPKERNPAIR;
#pragma pack()

BOOL
GetETM(
    HDC hdc,
    EXTTEXTMETRIC *petm);


HFONT
APIENTRY
GetHFONT(
    HDC);


HANDLE         GdiCreateLocalMetaFilePict(HANDLE hRemote);
HENHMETAFILE   GdiCreateLocalEnhMetaFile(HANDLE hRemote);
HANDLE         GdiConvertBitmapV5(LPBYTE,int,HPALETTE,UINT);
HANDLE         GdiConvertMetaFilePict(HANDLE hmfp);
HANDLE         GdiConvertEnhMetaFile(HENHMETAFILE hmf);
HDC            GdiConvertAndCheckDC(HDC hdc);
HBRUSH         GdiConvertBrush(HBRUSH hbrush);
HDC            GdiConvertDC(HDC hdc);
HRGN           GdiConvertRegion(HRGN hrgn);
BOOL           GdiValidateHandle(HANDLE hObj);
BOOL           GdiReleaseDC(HDC hdc);
HANDLE         GdiFixUpHandle(HANDLE h);
int            GdiGetCharDimensions(HDC hdc,TEXTMETRICW *lptm,LPINT lpcy);
DWORD          GdiGetCodePage(HDC hdc);

// Driver-specific pixel format support in GDI
int  APIENTRY GdiDescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);
BOOL APIENTRY GdiSetPixelFormat(HDC, int);
BOOL APIENTRY GdiSwapBuffers(HDC);

// OpenGL metafile support in GDI
BOOL APIENTRY GdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb, LPRECTL prclBounds);
BOOL APIENTRY GdiAddGlsBounds(HDC hdc, LPRECTL prclBounds);
BOOL APIENTRY GdiIsMetaPrintDC(HDC hdc);

// OpenGL metafile support in OpenGL
BOOL APIENTRY GlmfInitPlayback(HDC hdc, ENHMETAHEADER *pemh,
                               LPRECTL prclDest);
BOOL APIENTRY GlmfBeginGlsBlock(HDC hdc);
BOOL APIENTRY GlmfPlayGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds);
BOOL APIENTRY GlmfEndGlsBlock(HDC hdc);
BOOL APIENTRY GlmfEndPlayback(HDC hdc);
BOOL APIENTRY GlmfCloseMetaFile(HDC hdc);

BOOL  APIENTRY GdiPlayJournal(HDC,LPWSTR,DWORD,DWORD,int);

typedef int (CALLBACK* EMFPLAYPROC)( HDC, INT, HANDLE );

// User Mode Driver Unload

BOOL WINAPI GdiArtificialDecrementDriver(
    LPWSTR       pDriverDllName,
    DWORD        dwDriverAttributes
);

// Print processor interfaces and definitions

#define  EMF_PP_NORMAL      0x01
#define  EMF_PP_FORM        0x02

#define  EMF_PP_COLOR_OPTIMIZATION  0x01

BOOL WINAPI GdiPlayEMF(
    LPWSTR      pwszPrinterName,
    LPDEVMODEW  pDevmode,
    LPWSTR      pwszDocName,
    EMFPLAYPROC pfnPageQueryFn,
    HANDLE      hPageQuery
);

HANDLE WINAPI GdiGetSpoolFileHandle(
    LPWSTR     pwszPrinterName,
    LPDEVMODEW pDevmode,
    LPWSTR     pwszDocName);

BOOL WINAPI GdiDeleteSpoolFileHandle(
    HANDLE     SpoolFileHandle);

DWORD WINAPI GdiGetPageCount(
    HANDLE     SpoolFileHandle);

HDC WINAPI GdiGetDC(
    HANDLE     SpoolFileHandle);

HANDLE WINAPI GdiGetPageHandle(
    HANDLE     SpoolFileHandle,
    DWORD      Page,
    LPDWORD    pdwPageType);

BOOL WINAPI GdiStartDocEMF(
    HANDLE     SpoolFileHandle,
    DOCINFOW   *pDocInfo);

BOOL WINAPI GdiStartPageEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiPlayPageEMF(
    HANDLE     SpoolFileHandle,
    HANDLE     hemf,
    RECT       *prectDocument,
    RECT       *prectBorder,
    RECT       *prectClip);

BOOL WINAPI GdiPlayPrivatePageEMF(
    HANDLE       SpoolFileHandle,
    HENHMETAFILE hEnhMetaFile,
    RECT         *prectDocument);

BOOL WINAPI GdiEndPageEMF(
    HANDLE     SpoolFileHandle,
    DWORD      dwOptimization);

BOOL WINAPI GdiEndDocEMF(
    HANDLE     SpoolFileHandle);

BOOL WINAPI GdiGetDevmodeForPage(
    HANDLE     SpoolFileHandle,
    DWORD      dwPageNumber,
    PDEVMODEW  *pCurrDM,
    PDEVMODEW  *pLastDM);

BOOL WINAPI GdiResetDCEMF(
    HANDLE     SpoolFileHandle,
    PDEVMODEW  pCurrDM);


ULONG cGetTTFFromFOT(WCHAR *,ULONG,WCHAR *,FLONG *,FLONG *, DWORD *, BOOL);
BOOL bMakePathNameW (WCHAR *, WCHAR *, WCHAR **, FLONG *);
BOOL bInitSystemAndFontsDirectoriesW(WCHAR **, WCHAR **);
#define FONT_IN_FONTS_DIR     1
#define FONT_IN_SYSTEM_DIR    2
#define FONT_RELATIVE_PATH    4
#define FONT_ISNOT_FOT        8

#ifdef LANGPACK
BOOL LpkInitialize();
VOID APIENTRY GdiSetLastError(ULONG iError);

#define FRINFO_BITMAP   1
#define FRINFO_VECTOR   2
#define FRINFO_OTHER    3

typedef struct tagREALIZATION_INFO {
    UINT uFontTechnology;
    UINT uRealizationID;
    UINT uFontFileID;
} REALIZATION_INFO, *PREALIZATION_INFO;

BOOL APIENTRY GdiRealizationInfo(HDC, PREALIZATION_INFO);
WINGDIAPI BOOL  WINAPI GetTextExtentExPointWPri(HDC, LPCWSTR, int, int, LPINT, LPINT, LPSIZE);
BOOL APIENTRY GdiIsPlayMetafileDC(HDC hdc);
#endif

//
// Font Enumeration defines
//

#define FE_FILTER_NONE        0L
#define FE_FILTER_TRUETYPE    1L
#define FE_AA_ON              2L      // force antialiased text
#define FE_SET_AA             4L
#define FE_AA_ANY_SIZE        8L
#define FE_CT_ON             16L      // set antialiazing type to ClearType
#define FE_SET_CT            32L
#define FE_CT_BGR            64L      // set color stripes order RGB vs BGR
#define FE_SET_RGB_BGR      128L
#define FE_CT_HORSTRIPES    256L      // set color stripes direction VERTICAL vs HORIZINTAL
#define FE_SET_STRIPES_DIR  512L
#define FE_SET_CONTRAST    1024L

#define DEFAULT_CT_CONTRAST 1400

ULONG
WINAPI SetFontEnumeration (
    ULONG   ulType);


//
// Private Control Panel entry point to enumerate fonts by file.
//

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L
#define GFRI_ISTRUETYPE     3L
#define GFRI_TTFILENAME     4L
#define GFRI_ISREMOVED      5L
#if defined(FE_SB) // for GetFontResourceInfo()
#define GFRI_FONTMETRICS    6L
#endif // FE_SB

// file path separator for Add/RemoveFontResourceA/W

#define PATH_SEPARATOR L'|'


WINGDIAPI BOOL
WINAPI
GetFontResourceInfoW(
    LPWSTR  lpPathname,
    LPDWORD lpBytes,
    LPVOID  lpBuffer,
    DWORD   iType);

BOOL WINAPI GdiGetMessage(VOID *pv);


typedef enum _GdiCallId {
    MapFontFile_        = 1
  , UnmapFontFile_      = 2
  , GetFilePath_        = 3
  , LpkInstalled_       = 4
  , ComputeGlyphSet_    = 5
  , LoadModuleForWrite_ = 6
  , FreeModule_         = 7
  , GetFileChangeTime_  = 8
  , GetCurrentCodePage_ = 9
} GdiCallId;

typedef struct _GDICALL {
    GdiCallId Id;
    union {
        struct {
            ULONG iFile;
            PVOID pvUser;
            ULONG ByteCount;
        } MapFontFileArgs;
        struct {
            ULONG iFile;
        } UnmapFontFileArgs;
        struct {
            BOOL ReturnValue;
            HANDLE h;
            WCHAR (*pDest)[MAX_PATH+1];
        } GetFilePathArgs;
        struct {
            BOOL ReturnValue;
        } LpkInstalledArgs;
        struct {
                           BOOL   ReturnValue;
            struct _FD_GLYPHSET **ppGlyphSet;
            union {
                          ULONG   ByteCount;
            struct _FD_GLYPHSET  *pGlyphSet;
                                           };
                            INT   nCodePage;
                            INT   nFirstChar;
                            INT   cChars;
        } ComputeGlyphSetArgs;
        struct {
                    HANDLE ReturnValue;
                     WCHAR *pwsz;       // pointer to string
                     ULONG cj;
        } LoadModuleForWriteArgs;
        struct {
            HANDLE h;
        } FreeModuleArgs;
        struct {
            BOOL ReturnValue;
            HANDLE h;
            LARGE_INTEGER Time;
        } GetFileChangeTimeArgs;
        struct {
            USHORT OemCodePage;
            USHORT AnsiCodePage;
        } GetCurrentCodePageArgs;
    };
} GDICALL;

BOOL WINAPI GdiCall(GDICALL *pCall);

typedef struct  _CHWIDTHINFO
{
    LONG    lMaxNegA;
    LONG    lMaxNegC;
    LONG    lMinWidthD;
} CHWIDTHINFO,  *PCHWIDTHINFO;

BOOL
APIENTRY
GetCharWidthInfo(
    HDC            hdc,
    PCHWIDTHINFO   pChWidthInfo
);


/**************************************************************************\
*
*   tmdiff struc, contains the fields that are possibly different
*   between ansi and unicode versions of TEXTMETRICA and TEXTMETRICW
*
*   ONLY independent quantities are put into the strucure. Dependent ones,
*   such as tmDescent and maybe tmOverhang should be computed on the fly
*
*   tmDesc = tmHt - tmAsc
*   tmOverhang = tt ? 0 : ((tmHt - 1)/2 + (BOLD ? 1 : 0))
*
\**************************************************************************/

// this is a font with nonnegative a and c spaces, good for console

#if (_WIN32_WINNT >= 0x0500)

typedef struct _TMDIFF
{
    ULONG       cjotma;     // size of OUTLINETEXTMETRICSA
    BYTE        chFirst;
    BYTE        chLast;
    BYTE        chDefault;
    BYTE        chBreak;
} TMDIFF; // DIFF between TEXTMETRICA and TEXTMETRICW

#else

typedef struct _TMDIFF
{
    ULONG       cjotma;     // size of OUTLINETEXTMETRICSA
    FLONG       fl;         // flags, for now only TMD_NONNEGATIVE_AC
    BYTE        chFirst;
    BYTE        chLast;
    BYTE        chDefault;
    BYTE        chBreak;
} TMDIFF; // DIFF between TEXTMETRICA and TEXTMETRICW

#endif // (_WIN32_WINNT >= 0x0500)

// used to return correct GetTextMetricsA/W

typedef struct _TMW_INTERNAL
{
    TEXTMETRICW tmw;
    TMDIFF      tmdTmw;
} TMW_INTERNAL;

#if (_WIN32_WINNT >= 0x0500)

// this one is only used in enumeration,
// new textmetricsex returned by EnumFontFamiliesEx, fontsignature is returned

typedef struct _NTMW_INTERNAL
{
    TMDIFF           tmdNtmw;
    ENUMTEXTMETRICW  entmw;
} NTMW_INTERNAL;

#else

#define TMD_NONNEGATIVE_AC 1

typedef struct _NTMW_INTERNAL
{
    NEWTEXTMETRICEXW ntmw;
    TMDIFF           tmd;
} NTMW_INTERNAL;

#endif // (_WIN32_WINNT >= 0x0500)

// flags for AddFontResourceW
// AFRW_ADD_LOCAL_FONT : add ONLY if it is a local font
// AFRW_ADD_REMOTE_FONT: add ONLY if it is NOT local font
// if neither one LOCAL or REMOTE bit is set, just add the font

#define AFRW_ADD_LOCAL_FONT  0X01
#define AFRW_ADD_REMOTE_FONT 0X02
#define FRW_EMB_TID        0x04
#define FRW_EMB_PID        0x08
#define FRW_PVT_CLEANUP    0x80

#if (_WIN32_WINNT >= 0x0500)
int GdiAddFontResourceW( LPWSTR, DWORD, DESIGNVECTOR *);
#endif

// Win31 compatibility stuff
// GetAppCompatFlags flag values

#define GACF_IGNORENODISCARD        0x00000001
#define GACF_FORCETEXTBAND          0x00000002
#define GACF_ONELANDGRXBAND         0x00000004
#define GACF_IGNORETOPMOST          0x00000008
#define GACF_CALLTTDEVICE           0x00000010
#define GACF_MULTIPLEBANDS          0x00000020
#define GACF_ALWAYSSENDNCPAINT      0x00000040
#define GACF_EDITSETTEXTMUNGE       0x00000080
#define GACF_MOREEXTRAWNDWORDS      0x00000100
#define GACF_TTIGNORERASTERDUPE     0x00000200
#define GACF_HACKWINFLAGS           0x00000400
#define GACF_DELAYHWHNDSHAKECHK     0x00000800
#define GACF_ENUMHELVNTMSRMN        0x00001000
#define GACF_ENUMTTNOTDEVICE        0x00002000
#define GACF_SUBTRACTCLIPSIBS       0x00004000
#define GACF_FORCETTGRAPHICS        0x00008000
#define GACF_NOHRGN1                0x00010000
#define GACF_NCCALCSIZEONMOVE       0x00020000
#define GACF_SENDMENUDBLCLK         0x00040000
#define GACF_30AVGWIDTH             0x00080000
#define GACF_GETDEVCAPSNUMLIE       0x00100000

#define GACF_WINVER31               0x00200000      //
#define GACF_INCREASESTACK          0x00400000      //
#define GACF_HEAPSLACK              0x00400000      //
#define GACF_FORCEWIN31DEVMODESIZE  0x00800000      // (replaces PEEKMESSAGEIDLE)
#define GACF_31VALIDMASK            0xFFE4800C      //
#define GACF_DISABLEFONTASSOC       0x01000000      // Used in FE only
#define GACF_JAPANESCAPEMENT        0x01000000      // Used in FE only
#define GACF_IGNOREFAULTS           0x02000000      //
#define GACF_NOEMFSPOOLING          0x04000000      //
#define GACF_RANDOM3XUI             0x08000000      //
#define GACF_USEPRINTINGESCAPES     0x00000004      // re-use GACF_ONELANDGRXBAND
#define GACF_FORCERASTERMODE        0x00008000      // re-use GACF_FORCETTGRAPHICS
#define GACF_DONTJOURNALATTACH      0x10000000      //
#define GACF_DISABLEDBCSPROPTT      0x20000000      // Used in FE only
#define GACF_NOBRUSHCACHE           0x20000000      // re-use GACF_DISABLEDBCSPROPTT
#define GACF_MIRRORREGFONTS         0x40000000      //
#define GACF_NOSMOOTHSCROLLING      0x40000000      // re-use GACF_MIRRORREGFONTS
#define GACF_TTIGNOREDDEVICE        0x80000000      // Used in Word97-J only
#define GACF_NOSCROLLBARCTXMENU     0x80000000      // re-use GACF_TTIGNOREDDEVICE #119380


LPDEVMODEW
WINAPI
GdiConvertToDevmodeW(
    LPDEVMODEA pdma
    );




typedef struct _UNIVERSAL_FONT_ID {
    ULONG   CheckSum;
    ULONG   Index;
} UNIVERSAL_FONT_ID, *PUNIVERSAL_FONT_ID;

WINGDIAPI
INT
WINAPI
GdiQueryFonts(
    PUNIVERSAL_FONT_ID,
    ULONG,
    PLARGE_INTEGER
    );


WINGDIAPI
BOOL
WINAPI
GdiConsoleTextOut(
    HDC hdc,
    POLYTEXTW *lpto,
    UINT nStrings,
    RECTL *prclBounds
    );

typedef enum _FULLSCREENCONTROL {
    FullscreenControlEnable,               // 0
    FullscreenControlDisable,              // 1
    FullscreenControlSetCursorPosition,    // 2
    FullscreenControlSetCursorAttributes,  // 3
    FullscreenControlRegisterVdm,          // 4
    FullscreenControlSetPalette,           // 5
    FullscreenControlSetColors,            // 6
    FullscreenControlLoadFont,             // 7
    FullscreenControlRestoreHardwareState, // 8
    FullscreenControlSaveHardwareState,    // 9
    FullscreenControlCopyFrameBuffer,      // a
    FullscreenControlReadFromFrameBuffer,  // b
    FullscreenControlWriteToFrameBuffer,   // c
    FullscreenControlReverseMousePointer,  // d
    FullscreenControlSetMode,              // e
    FullscreenControlSetScreenInformation, // f
    FullscreenControlSpecificVideoControl, // 10 (for specific NEC PC-98)
    FullscreenControlCopyFrameBufferDB,    // 11
    FullscreenControlWriteToFrameBufferDB, // 12
    FullscreenControlReverseMousePointerDB // 13
} FULLSCREENCONTROL;

WINGDIAPI
BOOL
WINAPI
GdiFullscreenControl(
    FULLSCREENCONTROL FullscreenCommand,
    PVOID  FullscreenInuut,
    DWORD  FullscreenInputLength,
    PVOID  FullscreenOutput,
    PULONG FullscreenOutputLength
    );



#define IS_ANY_DBCS_CHARSET( CharSet )                              \
                   ( ((CharSet) == SHIFTJIS_CHARSET)    ? TRUE :    \
                     ((CharSet) == HANGEUL_CHARSET)     ? TRUE :    \
                     ((CharSet) == CHINESEBIG5_CHARSET) ? TRUE :    \
                     ((CharSet) == GB2312_CHARSET)      ? TRUE : FALSE )


typedef struct _UMTHDR {
    ULONG cjSize;
    ULONG ulType;
    ULONG ulReserved1;
    ULONG ulReserved2;
} UMTHDR;

WINGDIAPI
ULONG
WINAPI
GdiPrinterThunk(
    UMTHDR *pumth,
    PVOID pvOut,
    ULONG cjOut
    );

#define GPT_ERROR   0xffffffff

#endif /* _WINGDIP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\winuserp.h ===
/*++
Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    winuserp.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the User
    component.

--*/
#ifndef _WINUSERP_
#define _WINUSERP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#ifdef STRICT
#else /* !STRICT */
#endif /* !STRICT */
#ifdef STRICT
#else /* !STRICT */
#endif /* !STRICT */
#ifdef UNICODE
#else  /* !UNICODE */
#endif /* UNICODE */
#define RT_MENUEX       MAKEINTRESOURCE(13)     // RT_MENU subtype
#define RT_NAMETABLE    MAKEINTRESOURCE(15)     // removed in 3.1
#define RT_DIALOGEX     MAKEINTRESOURCE(18)     // RT_DIALOG subtype
#define RT_LAST         MAKEINTRESOURCE(24)
#define RT_AFXFIRST     MAKEINTRESOURCE(0xF0)   // reserved: AFX
#define RT_AFXLAST      MAKEINTRESOURCE(0xFF)   // reserved: AFX
/* Max number of characters. Doesn't include termination character */
#define WSPRINTF_LIMIT 1024
#define SETWALLPAPER_METRICS    ((LPWSTR)-2)
#define SB_MAX              3
#define SB_CMD_MAX          8
#define AW_VALID                    (AW_HOR_POSITIVE |\
                                     AW_HOR_NEGATIVE |\
                                     AW_VER_POSITIVE |\
                                     AW_VER_NEGATIVE |\
                                     AW_CENTER       |\
                                     AW_HIDE         |\
                                     AW_ACTIVATE     |\
                                     AW_BLEND        |\
                                     AW_SLIDE)
/*
 * GetAppCompatFlags2 flags
 */
#define GACF2_ANIMATIONOFF        0x00000001  // do not animate menus and listboxes
#define GACF2_KCOFF               0x00000002  // do not send Keyboard Cues messages
#define GACF2_NO50EXSTYLEBITS     0x00000004  // mask out post-4.0 extended style bits for SetWindowLong
#define GACF2_NODRAWPATRECT       0x00000008  // disable DRAWPATTERNRECT accel via ExtEscape()
#define GACF2_MSSHELLDLG          0x00000010  // if there is a request for MS Shell Dlg (which
                                              // usually maps to MS Sans Serif (bitmap) on NT 4 and
                                              // Microsoft Sans Serif (TrueType) on NT 5), then
                                              // behave as though we are using the bitmap
                                              // font (MS Sans Serif).
#define GACF2_NODDETRKDYING       0x00000020  // Be like Win9x: don't post WM_DDE_TERMINATE if
                                              // the window is destroyed while in a conversation
#define GACF2_GIVEUPFOREGROUND    0x00000040  // In W2k, we have changed foreground semantics to stop
                                              // foreground focus stealing by one app if another app
                                              // is active. However, this has caused  a few app compat
                                              // bugs. This appcompat flag is used to enable the old foreground
                                              // focus behaviour for these bugs.
#define GACF2_ACTIVEMENUS         0x00000080  // In W2k, we set the inactive look on menus that belong
                                              // to non-rofeground windows.  Some applications get in trouble
                                              // see #58227
#define GACF2_EDITNOMOUSEHIDE     0x00000100  // Typing in edit controls hides the cursor.
                                              // Some apps are surprised by that: #307615
#define GACF2_NOBATCHING          0X00000200  // Turn GDI batching off
#define GACF2_FONTSUB             0X00000400  // Only for Notes R5
#define GACF2_NO50EXSTYLEBITSCW   0x00000800  // mask out post-4.0 extended style bits for CreateWindow
#define GACF2_NOCUSTOMPAPERSIZES  0x00001000  // PostScript driver bit for Harvard Graphics
#define GACF2_DDE                 0x00002000  // all the DDE hacks
#define GACF2_DEFAULTCHARSET      0x00004000  // LOGFONT bit for QuickBook OCR-A font
#define GACF2_NOCHAR_DEADKEY      0x00008000  // No character composition on dead key on dead key (NT4 behavior)
#define GACF2_NO_TRYEXCEPT_CALLWNDPROC \
                                  0x00010000  // No try ~ except clause around WndProc call, let the app's handler
                                              // handle it even though it skips some API stacks.
                                              // See #359866
#define GACF2_NO_INIT_ECFLAGS_ON_SETFOCUS \
                                  0x00020000  // Do not initialize insert & replace flags (Korean specific)
                                              // in PED on WM_SETFOCUS, if this appcompat flag is set.
                                              // To workaround a bogus app bug who send input messages before setting
                                              // the focus to the edit control. See NtRaid #411686.

#define GACF2_DDENOSYNC           0x00040000  // Do not reject sent dde messages even if there is
                                              // an unprocessed message in the queue.
                                              // see WhistlerRaid #95367 (Check COMPATFLAGS2_FORWOW
                                              // below also)

#define GACF2_FORCEFUSION         0x00800000  // Set this flag to enable fusion in 16bit apps


/*
 * zzzInitTask masks out pti->dwCompatFlags2
 * If you need to add bits for 16bit apps include
 * that bit in this mask
 *
 */
#define COMPATFLAGS2_FORWOW       GACF2_DDENOSYNC | GACF2_GIVEUPFOREGROUND | GACF2_FORCEFUSION


#define GACF2_NOGHOST             0x00080000  // No window ghosting for this application. See bug #268100.
#define GACF2_DDENOASYNCREG       0x00100000  // Use Sendmessage instead of PostMessage in DDE RegisterService(). See bug# 156088.
#define GACF2_STRICTLLHOOK        0x00200000  // Apply strict timeout rule for LL hook. See WindowsBug 307738.
#define GACF2_NOSHADOW            0x00400000  // don't apply window shadow. see bug# 364717
#define GACF2_NOTIMERCBPROTECTION 0x01000000  // don't protect from unregistered WM_TIMER with lParam (callback pfn).

/*
 * Version macros
 */
#define VERMAX          0x9900  // ignore the version

#define VER51           0x0501
#define VER50           0x0500
#define VER40           0x0400
#define VER31           0x030A
#define VER30           0x0300

#define Is510Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER51)
#define Is500Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER50)
#define Is400Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER40)
#define Is310Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER31)
#define Is300Compat(dwExpWinVer)  (LOWORD(dwExpWinVer) >= VER30)

#define VK_NONE           0x00
/*
 * NEC PC-9800 Series definitions
 */
#define VK_OEM_NEC_SEPARATE 0x6C
#define VK_APPCOMMAND_FIRST    0xA6
#define VK_APPCOMMAND_LAST     0xB7
/*
 * Fujitsu/OASYS definitions - clash with SpeedRacer etc.
 */
#define VK_OEM_OAS_1      0xB4
#define VK_OEM_OAS_2      0xB5
#define VK_OEM_OAS_3      0xB6
#define VK_OEM_OAS_4      0xB7
#define VK_OEM_OAS_5      0xB8
#define VK_OEM_OAS_6      0xB9
#define VK_OEM_OAS_7      0xC1
#define VK_OEM_OAS_8      0xC2
#define VK_OEM_OAS_9      0xC3
#define VK_OEM_OAS_10     0xC4
#define VK_OEM_OAS_11     0xC5
#define VK_OEM_OAS_12     0xC6
#define VK_OEM_OAS_13     0xC7
#define VK_OEM_OAS_14     0xC8
#define VK_OEM_OAS_15     0xC9
#define VK_OEM_OAS_16     0xCA
#define VK_OEM_OAS_17     0xCB
#define VK_OEM_OAS_18     0xCC
#define VK_OEM_OAS_19     0xCD
#define VK_OEM_OAS_20     0xCE
#define VK_OEM_OAS_21     0xCF
#define VK_OEM_OAS_22     0xD0
#define VK_OEM_OAS_23     0xD1
#define VK_OEM_OAS_24     0xD2
#define VK_OEM_OAS_25     0xD3
#define VK_OEM_OAS_26     0xD4
#define VK_OEM_OAS_27     0xD5
#define VK_OEM_OAS_28     0xD6
#define VK_OEM_OAS_29     0xD7
#define VK_OEM_FJ_DUMMY   0xEF

#define VK_UNKNOWN        0xFF
/*
 * Additional modifier keys.
 * Used for ISO9995 "Information technology - Keyboard layouts for text and
 * office systems" (French Canadian keyboard,
 */
#define VK_GROUPSHIFT     0xE5
#define VK_RGROUPSHIFT    0xE6
#if !defined(_WIN32_WINDOWS)
#define WH_HARDWARE         8
#endif
#ifdef REDIRECTION
#define  WH_HITTEST         15
#endif // REDIRECTION
#define WH_CHOOKS          (WH_MAXHOOK - WH_MINHOOK + 1)
#ifdef REDIRECTION
#define HCBT_GETCURSORPOS  10
#endif // REDIRECTION
#define MSGF_MOVE           3
#define MSGF_SIZE           4
#define MSGF_CBTHOSEBAGSUSEDTHIS  7
#define MSGF_MAINLOOP       8
#define APPCOMMAND_FIRST                  1
#define APPCOMMAND_LAST                   52
#ifdef REDIRECTION
typedef struct tagHTHOOKSTRUCT {
    POINT pt;
    HWND hwndHit;
} HTHOOKSTRUCT, FAR *LPHTHOOKSTRUCT, *PHTHOOKSTRUCT;
#endif // REDIRECTION
#define KLF_UNLOADPREVIOUS  0x00000004
#define KLF_FAILSAFE        0x00000200

/*
 * Keyboard Layout Attributes
 * These are specified in the layout DLL itself, or in the registry under
 * MACHINE\System\CurrentControlSet\Control\Keyboard Layouts\*\Attributes
 * as KLF_ values between 0x00010000 and 0x00800000.  Any attributes specified
 * by the layout DLL are ORed with the attributes obtained from the registry.
 */
#define KLF_LRM_RLM         0x00020000
#define KLF_ATTRIBUTE2      0x00040000
#define KLF_ATTRIBUTE3      0x00080000
#define KLF_ATTRIBUTE4      0x00100000
#define KLF_ATTRIBUTE5      0x00200000
#define KLF_ATTRIBUTE6      0x00400000
#define KLF_ATTRIBUTE7      0x00800000
#define KLF_ATTRMASK        0x00FF0000
#define KLF_INITTIME        0x80000000
#define KLF_VALID           0xC000039F | KLF_ATTRMASK

WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutEx(
    IN HKL hkl,
    IN LPCWSTR pwszKLID,
    IN UINT Flags);

#ifdef REDIRECTION
#define DESKTOP_QUERY_INFORMATION   0x0101L
#define DESKTOP_REDIRECT            0x0102L
#endif // REDIRECTION
#ifndef NOWINDOWSTATION
#endif  /* !NOWINDOWSTATION */

WINUSERAPI
DWORD
WINAPI
CreateSystemThreads(
    IN LPVOID pUnused);

BOOL WowWaitForMsgAndEvent(IN HANDLE hevent);
WINUSERAPI VOID WINAPI RegisterSystemThread(IN DWORD flags, IN DWORD reserved);
#define RST_DONTATTACHQUEUE       0x00000001
#define RST_DONTJOURNALATTACH     0x00000002
#define RST_ALWAYSFOREGROUNDABLE  0x00000004
#define RST_FAULTTHREAD           0x00000008
#define GWL_WOWWORDS        (-1)
#ifdef _WIN64
#undef GWL_WOWWORDS
#endif /* _WIN64 */
#define GWLP_WOWWORDS       (-1)
#define GCL_WOWWORDS        (-27)
#define GCL_WOWMENUNAME     (-29)
#ifdef _WIN64
#undef GCL_WOWWORDS
#endif /* _WIN64 */
#define GCLP_WOWWORDS       (-27)
#define WM_SIZEWAIT                     0x0004
#define WM_SETVISIBLE                   0x0009
#define WM_SYSTEMERROR                  0x0017
/*
 * This is used by DefWindowProc() and DefDlgProc(), it's the 16-bit version
 * of the WM_CTLCOLORBTN, WM_CTLCOLORDLG, ... messages.
 */
#define WM_CTLCOLOR                     0x0019
#define WM_LOGOFF                       0x0025
#define WM_ALTTABACTIVE                 0x0029
#define WM_FILESYSCHANGE                0x0034

#define WM_SHELLNOTIFY                  0x0034
#define SHELLNOTIFY_DISKFULL            0x0001
#define SHELLNOTIFY_OLELOADED           0x0002
#define SHELLNOTIFY_OLEUNLOADED         0x0003
#define SHELLNOTIFY_WALLPAPERCHANGED    0x0004

#define WM_ISACTIVEICON                 0x0035
#define WM_QUERYPARKICON                0x0036
#define WM_WINHELP                      0x0038
#define WM_FULLSCREEN                   0x003A
#define WM_CLIENTSHUTDOWN               0x003B
#define WM_DDEMLEVENT                   0x003C
#define MM_CALCSCROLL                   0x003F
#define WM_TESTING                      0x0040
#define WM_OTHERWINDOWCREATED           0x0042
#define WM_OTHERWINDOWDESTROYED         0x0043
#define WM_COPYGLOBALDATA               0x0049
#define WM_LOGONNOTIFY                  0x004C
#define WM_KEYF1                        0x004D
#define WM_ACCESS_WINDOW                0x004F
#define WM_FINALDESTROY                 0x0070  /* really destroy (window not locked) */
#define WM_MEASUREITEM_CLIENTDATA       0x0071  /* WM_MEASUREITEM bug clientdata thunked already */
#define WM_SYNCTASK                     0x0089

#define WM_KLUDGEMINRECT                0x008B
#define WM_LPKDRAWSWITCHWND             0x008C
#define WM_NCMOUSEFIRST                 0x00A0

/*
 * Skip value 0x00AA, which would correspond to the non-client
 * mouse wheel message if there were such a message.
 * We do that in order to maintain a constant value for
 * the difference between the client and nonclient version of
 * a mouse message, e.g.
 *     WM_LBUTTONDOWN - WM_NCLBUTTONDOWN == WM_XBUTTONDOWN - WM_NCXBUTTONDOWN
 */

#define WM_NCXBUTTONFIRST               0x00AB
#define WM_NCXBUTTONLAST                0X00AD
#define WM_NCMOUSELAST                  0x00AD

#if(_WIN32_WINNT >= 0x0501)
#define WM_NCUAHDRAWCAPTION             0x00AE
#define WM_NCUAHDRAWFRAME               0x00AF
#endif /* _WIN32_WINNT >= 0x0501 */
#define WM_CONVERTREQUESTEX             0x0108
#define WM_YOMICHAR                     0x0108
#define WM_CONVERTREQUEST               0x010A
#define WM_CONVERTRESULT                0x010B
#define WM_INTERIM                      0x010C
#define WM_SYSTIMER                     0x0118
#define UIS_LASTVALID                   UIS_INITIALIZE
#define UISF_VALID                     (UISF_HIDEFOCUS | \
                                        UISF_HIDEACCEL | \
                                        UISF_ACTIVE)
#define WM_LBTRACKPOINT                 0x0131

#define WM_CTLCOLORFIRST                0x0132
#define WM_CTLCOLORLAST                 0x0138

#define MN_FIRST                        0x01E0
#define MN_SETHMENU                     (MN_FIRST + 0)
    // We need to expose this message for compliance.
    // Make sure this remains equal to (MN_FIRST + 1)
#define MN_SIZEWINDOW                   (MN_FIRST + 2)
#define MN_OPENHIERARCHY                (MN_FIRST + 3)
#define MN_CLOSEHIERARCHY               (MN_FIRST + 4)
#define MN_SELECTITEM                   (MN_FIRST + 5)
#define MN_CANCELMENUS                  (MN_FIRST + 6)
#define MN_SELECTFIRSTVALIDITEM         (MN_FIRST + 7)

#define MN_GETPPOPUPMENU                (MN_FIRST + 10)
#define MN_FINDMENUWINDOWFROMPOINT      (MN_FIRST + 11)
#define MN_SHOWPOPUPWINDOW              (MN_FIRST + 12)
#define MN_BUTTONDOWN                   (MN_FIRST + 13)
#define MN_MOUSEMOVE                    (MN_FIRST + 14)
#define MN_BUTTONUP                     (MN_FIRST + 15)
#define MN_SETTIMERTOOPENHIERARCHY      (MN_FIRST + 16)
#define MN_DBLCLK                       (MN_FIRST + 17)
#define MN_ACTIVATEPOPUP                (MN_FIRST + 18)
#define MN_ENDMENU                      (MN_FIRST + 19)
#define MN_DODRAGDROP                   (MN_FIRST + 20)
#define MN_LASTPOSSIBLE                 (MN_FIRST + 31)
#define WM_XBUTTONFIRST                 0x020B
#define WM_XBUTTONLAST                  0X020D
#define XBUTTON_MASK  (XBUTTON1 | XBUTTON2)
#define WM_DROPOBJECT                   0x022A
#define WM_QUERYDROPOBJECT              0x022B

#define WM_BEGINDRAG                    0x022C
#define WM_DRAGLOOP                     0x022D
#define WM_DRAGSELECT                   0x022E
#define WM_DRAGMOVE                     0x022F
#define WM_KANJIFIRST                   0x0280
#define WM_IME_SYSTEM                   0x0287
#define WM_KANJILAST                    0x029F

#define WM_TRACKMOUSEEVENT_FIRST        0x02A0
#define WM_TRACKMOUSEEVENT_LAST         0x02AF
#define WM_PALETTEGONNACHANGE           0x0310
#define WM_CHANGEPALETTE                0x0311
#define WM_SYSMENU                      0x0313
#define WM_HOOKMSG                      0x0314
#define WM_EXITPROCESS                  0x0315
#define WM_WAKETHREAD                   0x0316
#define WM_UAHINIT                      0x031B
#define WM_DESKTOPNOTIFY                0x031C
#define WM_NOTIFYWOW                    0x0340
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F

#define WM_INTERNAL_DDE_FIRST           0x03E0
#define WM_INTERNAL_DDE_LAST            0x03EF
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F

#define WM_MM_RESERVED_FIRST            0x03A0
#define WM_MM_RESERVED_LAST             0x03DF

#define WM_CBT_RESERVED_FIRST           0x03F0
#define WM_CBT_RESERVED_LAST            0x03FF
/* wParam for WM_NOTIFYWOW message  */
#define WMNW_UPDATEFINDREPLACE  0
#define WMSZ_KEYSIZE        0
#define WMSZ_MOVE           9
#define WMSZ_KEYMOVE        10
#define WMSZ_SIZEFIRST      WMSZ_LEFT
#define HTLAMEBUTTON        22

/*
 * The prototype of the function to call when the user clicks
 * on the Lame button in the caption
 */

typedef VOID (*PLAMEBTNPROC)(HWND, PVOID);
#define SMTO_BROADCAST      0x0004
#define SMTO_VALID          0x000F
#define ICON_RECREATE       3
#define WVR_MINVALID        WVR_ALIGNTOP
#define WVR_MAXVALID        WVR_VALIDRECTS
#if(WINVER >= 0x0500)
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_NONCLIENT | TME_QUERY | TME_CANCEL)
#else
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_QUERY | TME_CANCEL)
#endif
#define WS_VALID            (WS_OVERLAPPED     | \
                             WS_POPUP          | \
                             WS_CHILD          | \
                             WS_MINIMIZE       | \
                             WS_VISIBLE        | \
                             WS_DISABLED       | \
                             WS_CLIPSIBLINGS   | \
                             WS_CLIPCHILDREN   | \
                             WS_MAXIMIZE       | \
                             WS_CAPTION        | \
                             WS_BORDER         | \
                             WS_DLGFRAME       | \
                             WS_VSCROLL        | \
                             WS_HSCROLL        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_GROUP          | \
                             WS_TABSTOP        | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)
#define WS_EX_DRAGOBJECT        0x00000002L
#if(WINVER >= 0x0501)
#define WS_EXP_GHOSTMAKEVISIBLE 0x00000800L
#endif /* WINVER >= 0x0501 */
#define WS_EX_ANSICREATOR       0x80000000L
#ifdef REDIRECTION
#define WS_EX_EXTREDIRECTED     0x01000000L
#endif // REDIRECTION

/*
 * These are not extended styles but rather state bits.
 * We use these bit positions to delay the addition of a new
 * state DWORD in the window structure.
 */
#define WS_EXP_UIFOCUSHIDDEN    0x80000000
#define WS_EXP_UIACCELHIDDEN    0x40000000
#define WS_EXP_REDIRECTED       0x20000000
#define WS_EXP_COMPOSITING      0x10000000
#define WS_EXP_UIACTIVE         0x04000000L

#define WS_EXP_UIVALID         (WS_EXP_UIFOCUSHIDDEN | \
                                WS_EXP_UIACCELHIDDEN | \
                                WS_EXP_UIACTIVE)

#define WS_EXP_PRIVATE         (WS_EXP_UIFOCUSHIDDEN | \
                                WS_EXP_UIACCELHIDDEN | \
                                WS_EXP_REDIRECTED    | \
                                WS_EXP_COMPOSITING   | \
                                WS_EXP_UIACTIVE      | \
                                WS_EXP_GHOSTMAKEVISIBLE)

/*
 * RTL Mirroring Extended Styles (RTL_MIRRORING)
 */
#define WS_EX_LAYOUTVBHRESERVED 0x00200000L
#define WS_EX_LAYOUTBTTRESERVED 0x00800000L
#define WS_EX_ALLEXSTYLES    (WS_EX_TRANSPARENT | WS_EX_DLGMODALFRAME | WS_EX_DRAGOBJECT | WS_EX_NOPARENTNOTIFY | WS_EX_TOPMOST | WS_EX_ACCEPTFILES)

#define WS_EX_VALID          (WS_EX_DLGMODALFRAME  | \
                              WS_EX_DRAGOBJECT     | \
                              WS_EX_NOPARENTNOTIFY | \
                              WS_EX_TOPMOST        | \
                              WS_EX_ACCEPTFILES    | \
                              WS_EX_TRANSPARENT    | \
                              WS_EX_ALLEXSTYLES)

#define WS_EX_VALID40        (WS_EX_VALID          | \
                              WS_EX_MDICHILD       | \
                              WS_EX_WINDOWEDGE     | \
                              WS_EX_CLIENTEDGE     | \
                              WS_EX_CONTEXTHELP    | \
                              WS_EX_TOOLWINDOW     | \
                              WS_EX_RIGHT          | \
                              WS_EX_LEFT           | \
                              WS_EX_RTLREADING     | \
                              WS_EX_LEFTSCROLLBAR  | \
                              WS_EX_CONTROLPARENT  | \
                              WS_EX_STATICEDGE     | \
                              WS_EX_APPWINDOW)

#define WS_EX_VALID50        (WS_EX_VALID40        | \
                              WS_EX_LAYERED        | \
                              WS_EX_NOINHERITLAYOUT| \
                              WS_EX_LAYOUTRTL      | \
                              WS_EX_NOACTIVATE)

#ifdef REDIRECTION
#define WS_EX_VALID51        (WS_EX_VALID50        | \
                              WS_EX_COMPOSITED     | \
                              WS_EX_EXTREDIRECTED)
#else
#define WS_EX_VALID51        (WS_EX_VALID50        | \
                              WS_EX_COMPOSITED)
#endif // REDIRECTION

#define WS_EX_INTERNAL       (WS_EX_DRAGOBJECT     | \
                              WS_EX_ANSICREATOR)

/*
 * We currently return to applications only the valid Ex_Style bits.
 * If declaring another macro i.e. WS_EX_VALID60, make sure to change WS_EX_ALLVALID
 */
#define WS_EX_ALLVALID        WS_EX_VALID51


#define WF_DIALOG_WINDOW      0x00010000     // used in WOW32 -- this is a state flag, not a style flag
#define CS_KEYCVTWINDOW     0x0004
#define CS_OEMCHARS         0x0010  /* reserved (see user\server\usersrv.h) */
#define CS_NOKEYCVT         0x0100
#define CS_LVB              0x0400
#define CS_SYSTEM           0x8000
#define CS_VALID            (CS_VREDRAW           | \
                             CS_HREDRAW           | \
                             CS_KEYCVTWINDOW      | \
                             CS_DBLCLKS           | \
                             CS_OEMCHARS          | \
                             CS_OWNDC             | \
                             CS_CLASSDC           | \
                             CS_PARENTDC          | \
                             CS_NOKEYCVT          | \
                             CS_NOCLOSE           | \
                             CS_SAVEBITS          | \
                             CS_BYTEALIGNCLIENT   | \
                             CS_BYTEALIGNWINDOW   | \
                             CS_GLOBALCLASS       | \
                             CS_DROPSHADOW        | \
                             CS_IME)
#define CS_VALID31            0x0800ffef
#define CS_VALID40            0x0803feeb
#define BDR_VALID       0x000F
#define BF_VALID       (BF_MIDDLE |  \
                        BF_SOFT   |  \
                        BF_ADJUST |  \
                        BF_FLAT   |  \
                        BF_MONO   |  \
                        BF_LEFT   |  \
                        BF_TOP    |  \
                        BF_RIGHT  |  \
                        BF_BOTTOM |  \
                        BF_DIAGONAL)
#define DFC_CACHE               0xFFFF
#define DFCS_CAPTIONALL         0x000F
#define DFCS_INMENU             0x0040
#define DFCS_INSMALL            0x0080
#define DFCS_MENUARROWUP        0x0008
#define DFCS_MENUARROWDOWN      0x0010

#define DFCS_SCROLLMIN          0x0000
#define DFCS_SCROLLVERT         0x0000
#define DFCS_SCROLLMAX          0x0001
#define DFCS_SCROLLHORZ         0x0002
#define DFCS_SCROLLLINE         0x0004

#define DFCS_CACHEICON          0x0000
#define DFCS_CACHEBUTTONS       0x0001

#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* DRAWFRAMECONTROLPROC)(
    IN     HDC,
    IN OUT LPRECT,
    IN     UINT,
    IN     UINT);
#endif /* _WIN32_WINNT >= 0x0501 */
#define DC_LAMEBUTTON       0x0400
#define DC_NOVISIBLE        0x0800
#define DC_NOSENDMSG        0x2000
#define DC_CENTER           0x4000
#define DC_FRAME            0x8000
#define DC_CAPTION          (DC_ICON | DC_TEXT | DC_BUTTONS)
#define DC_NC               (DC_CAPTION | DC_FRAME)

/* flags for WM_NCUAHDRAWFRAME */
#if(_WIN32_WINNT >= 0x0501)
#define DF_ACTIVE           0x0001
#define DF_HUNGREDRAW       0x2000
#endif /* _WIN32_WINNT >= 0x0501 */
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* DRAWCAPTIONPROC)(
    IN HWND,
    IN HDC,
    IN CONST RECT *,
    IN UINT);
#endif /* _WIN32_WINNT >= 0x0501 */

WINUSERAPI
BOOL
WINAPI
DrawCaptionTempA(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HFONT,
    IN HICON,
    IN LPCSTR,
    IN UINT);
WINUSERAPI
BOOL
WINAPI
DrawCaptionTempW(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HFONT,
    IN HICON,
    IN LPCWSTR,
    IN UINT);
#ifdef UNICODE
#define DrawCaptionTemp  DrawCaptionTempW
#else
#define DrawCaptionTemp  DrawCaptionTempA
#endif // !UNICODE
#define IDANI_CLOSE         2
#define CF_FIRST            0
#define WPF_VALID              (WPF_SETMINPOSITION     | \
                                WPF_RESTORETOMAXIMIZED)
/*
 * MEASUREITEMSTRUCT_EX for ownerdraw
 * used when server initiates a WM_MEASUREITEM and adds the additional info
 * of whether the itemData needs to be thunked when the message is sent to
 * the client (see also WM_MEASUREITEM_CLIENTDATA
 */
typedef struct tagMEASUREITEMSTRUCT_EX {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
    BOOL       bThunkClientData;
} MEASUREITEMSTRUCT_EX, NEAR *PMEASUREITEMSTRUCT_EX, FAR *LPMEASUREITEMSTRUCT_EX;
typedef BOOL (CALLBACK* INTERNALGETMESSAGEPROC)(OUT LPMSG lpMsg, IN HWND hwnd,
        IN UINT wMsgFilterMin, IN UINT wMsgFilterMax, IN UINT flags, IN BOOL fGetMessage);
#define PM_VALID           (PM_NOREMOVE | \
                            PM_REMOVE   | \
                            PM_NOYIELD  | \
                            PM_QS_INPUT | \
                            PM_QS_POSTMESSAGE | \
                            PM_QS_PAINT | \
                            PM_QS_SENDMESSAGE)
#define MOD_SAS         0x8000

#define MOD_VALID           (MOD_ALT|MOD_CONTROL|MOD_SHIFT|MOD_WIN|MOD_SAS)
#define EW_RESTARTWINDOWS    0x0042L
#define EW_REBOOTSYSTEM      0x0043L
#define EWX_REALLYLOGOFF     ENDSESSION_LOGOFF

#define EWX_CANCELED                0x00000080
#define EWX_SYSTEM_CALLER           0x00000100
#define EWX_WINLOGON_CALLER         0x00000200
#define EWX_WINLOGON_OLD_SYSTEM     0x00000400
#define EWX_WINLOGON_OLD_SHUTDOWN   0x00000800
#define EWX_WINLOGON_OLD_REBOOT     0x00001000
#define EWX_WINLOGON_API_SHUTDOWN   0x00002000
#define EWX_WINLOGON_OLD_POWEROFF   0x00004000
#define EWX_NOTIFY                  0x00008000
#define EWX_NONOTIFY                0x00010000
#define EWX_WINLOGON_INITIATED      0x00020000
#define EWX_TERMSRV_INITIATED       0x00040000
#define EWX_VALID                   (EWX_LOGOFF            | \
                                     EWX_SHUTDOWN          | \
                                     EWX_REBOOT            | \
                                     EWX_FORCE             | \
                                     EWX_POWEROFF          | \
                                     EWX_FORCEIFHUNG       | \
                                     EWX_NOTIFY            | \
                                     EWX_TERMSRV_INITIATED)

#define SHUTDOWN_FLAGS (EWX_SHUTDOWN | EWX_REBOOT | EWX_POWEROFF |            \
                        EWX_WINLOGON_OLD_SHUTDOWN | EWX_WINLOGON_OLD_REBOOT | \
                        EWX_WINLOGON_OLD_POWEROFF)

/*
 * Shutdown logging stuff
 */
#define SR_EVENT_INITIATE_CLEAN       1
#define SR_EVENT_INITIATE_CLEAN_ABORT 2
#define SR_EVENT_EXITWINDOWS          3
#define SR_EVENT_DIRTY                4

typedef struct _SHUTDOWN_REASON
{
    UINT   cbSize;             /* Set to sizeof(SHUTDOWN_REASON) */
    UINT   uFlags;             /* Shutdown flags; e.g., EWX_SHUTDOWN */
    DWORD  dwReasonCode;       /* Optional field */
    DWORD  dwEventType;        /* See #defines above */
    BOOL   fShutdownCancelled; /* Optional field */
    LPWSTR lpszComment;        /* Optional field */
} SHUTDOWN_REASON, *PSHUTDOWN_REASON;

WINUSERAPI
BOOL
WINAPI
RecordShutdownReason(
    PSHUTDOWN_REASON psr);

WINUSERAPI
BOOL
WINAPI
DisplayExitWindowsWarnings(
    UINT uExitWindowsFlags);

#define BSM_COMPONENTS          0x0000000F
#define BSM_VALID               0x0000001F
#define BSF_QUEUENOTIFYMESSAGE  0x20000000
#define BSF_SYSTEMSHUTDOWN      0x40000000
#define BSF_MSGSRV32OK          0x80000000
#define BSF_VALID               0x000007FF
#define BSF_ASYNC               (BSF_POSTMESSAGE | BSF_SENDNOTIFYMESSAGE)
//
// NOTE: Completion port-based notification is not implemented in Win2K,
// nor is it planned for Whistler.
//
#define DEVICE_NOTIFY_COMPLETION_HANDLE 0x00000002

WINUSERAPI
ULONG
WINAPI
DeviceEventWorker(
    IN HWND    hWnd,
    IN WPARAM  wParam,
    IN LPARAM  lParam,
    IN DWORD   dwFlags,
    OUT PDWORD pdwResult
    );
typedef BOOL (CALLBACK* WAITMESSAGEEXPROC)(UINT fsWakeMask, DWORD dwTimeout);
#define PW_VALID               (PW_CLIENTONLY)
#define LWA_VALID              (LWA_COLORKEY            | \
                                LWA_ALPHA)
#define ULW_VALID              (ULW_COLORKEY            | \
                                ULW_ALPHA               | \
                                ULW_OPAQUE)
#define FLASHW_FLASHNOFG    0x00000008
#define FLASHW_TIMERCALL    0x00000400
#define FLASHW_DONE         0x00000800
#define FLASHW_STARTON      0x00001000
#define FLASHW_COUNTING     0x00002000
#define FLASHW_KILLTIMER    0x00004000
#define FLASHW_ON           0x00008000
#define FLASHW_VALID        (FLASHW_ALL | FLASHW_TIMERNOFG)
#define FLASHW_COUNTMASK    0xFFFF0000
#define FLASHW_CALLERBITS   (FLASHW_VALID | FLASHW_COUNTMASK)
#define SWP_STATECHANGE     0x8000  /* force size, move messages */
#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */

#define SWP_DEFERDRAWING    0x2000
#define SWP_CREATESPB       0x4000

#define SWP_CHANGEMASK      (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_NOCHANGE        (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_VALID1          (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE | SWP_FRAMECHANGED)
#define SWP_VALID2          (SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCOPYBITS | SWP_NOOWNERZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE | SWP_NOSENDCHANGING | SWP_ASYNCWINDOWPOS | SWP_DEFERDRAWING | SWP_CREATESPB)
#define SWP_VALID           (SWP_VALID1 | SWP_VALID2)
#define SWP_NOTIFYCREATE    0x10000000
#define SWP_NOTIFYDESTROY   0x20000000
#define SWP_NOTIFYACTIVATE  0x40000000
#define SWP_NOTIFYFS        0x80000000
#define SWP_NOTIFYALL       (SWP_NOTIFYCREATE | SWP_NOTIFYDESTROY | SWP_NOTIFYACTIVATE | SWP_NOTIFYFS)

#undef SWP_VALID
#define SWP_VALID           (SWP_DEFERERASE      | \
                             SWP_ASYNCWINDOWPOS  | \
                             SWP_NOCOPYBITS      | \
                             SWP_NOOWNERZORDER   | \
                             SWP_NOSENDCHANGING  | \
                             SWP_NOSIZE          | \
                             SWP_NOMOVE          | \
                             SWP_NOZORDER        | \
                             SWP_NOREDRAW        | \
                             SWP_NOACTIVATE      | \
                             SWP_FRAMECHANGED    | \
                             SWP_SHOWWINDOW      | \
                             SWP_HIDEWINDOW)
#define HWND_GROUPTOTOP HWND_TOPMOST
/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#include <pshpack2.h>

/*
 * Chicago dialog template
 */
typedef struct {
    WORD wDlgVer;
    WORD wSignature;
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE2;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2A;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGTEMPLATE2W LPDLGTEMPLATE2;
#else
typedef LPDLGTEMPLATE2A LPDLGTEMPLATE2;
#endif // UNICODE
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2A;
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPCDLGTEMPLATE2W LPCDLGTEMPLATE2;
#else
typedef LPCDLGTEMPLATE2A LPCDLGTEMPLATE2;
#endif // UNICODE
/*
 * Dialog item template for NT 1.0a/Chicago (dit2)
 */
typedef struct {
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    short x;
    short y;
    short cx;
    short cy;
    DWORD dwID;
} DLGITEMTEMPLATE2;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef PDLGITEMTEMPLATE2W PDLGITEMTEMPLATE2;
#else
typedef PDLGITEMTEMPLATE2A PDLGITEMTEMPLATE2;
#endif // UNICODE
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGITEMTEMPLATE2W LPDLGITEMTEMPLATE2;
#else
typedef LPDLGITEMTEMPLATE2A LPDLGITEMTEMPLATE2;
#endif // UNICODE

#include <poppack.h> /* Resume normal packing */

/*
 * The driver flags corresponding to these mouse events are
 * shifted to the right by one, e.g.
 *     MOUSEEVENTF_LEFTDOWN >> 1 == MOUSE_LEFT_BUTTON_DOWN
 *
 * The mouse driver sends the fourth and fifth buttons corresponding
 * as button flags, so we define MOUSEEVENTF_ flags INTERNALLY for
 * mimicking the input sent by the driver.
 */

#define MOUSEEVENTF_DRIVER_X1DOWN   0x0080 /* x1 button down */
#define MOUSEEVENTF_DRIVER_X1UP     0x0100 /* x1 button up */
#define MOUSEEVENTF_DRIVER_X2DOWN   0x0200 /* x2 button down */
#define MOUSEEVENTF_DRIVER_X2UP     0x0400 /* x2 button up */
/* Legal MOUSEEVENTF_ flags that indicate a button has been pressed or the wheel moved */
#define MOUSEEVENTF_BUTTONMASK           \
            (MOUSEEVENTF_LEFTDOWN |      \
            MOUSEEVENTF_LEFTUP |         \
            MOUSEEVENTF_RIGHTDOWN |      \
            MOUSEEVENTF_RIGHTUP |        \
            MOUSEEVENTF_MIDDLEDOWN |     \
            MOUSEEVENTF_MIDDLEUP |       \
            MOUSEEVENTF_XDOWN |          \
            MOUSEEVENTF_XUP |            \
            MOUSEEVENTF_WHEEL)

/* MOUSEEVENTF_ flags that indicate useful data in the mouseData field */
#define MOUSEEVENTF_MOUSEDATAMASK         \
            (MOUSEEVENTF_XDOWN |          \
            MOUSEEVENTF_XUP |             \
            MOUSEEVENTF_WHEEL)

typedef DWORD (CALLBACK* GETQUEUESTATUSPROC)(IN UINT flags);
typedef DWORD (CALLBACK* MSGWAITFORMULTIPLEOBJECTSEXPROC)(IN DWORD nCount, IN CONST HANDLE *pHandles, IN DWORD dwMilliseconds, IN DWORD dwWakeMask, IN DWORD dwFlags);
#define MWMO_VALID          0x0007
#define QS_SMSREPLY         0x0200
#define QS_THREADATTACHED   0x0800
#define QS_EXCLUSIVE        0x1000      // wait for these events only!!
#define QS_EVENT            0x2000      // signifies event message
#define QS_TRANSFER         0x4000      // Input was transfered from another thread
//                          0x8000      // unused, but should not be used for external API.
                                        // Win9x has used this for SMSREPLY
#define QS_VALID           (QS_KEY           | \
                            QS_MOUSEMOVE     | \
                            QS_MOUSEBUTTON   | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_SENDMESSAGE   | \
                            QS_TRANSFER      | \
                            QS_HOTKEY        | \
                            QS_ALLPOSTMESSAGE| \
                            QS_RAWINPUT)

/*
 * QS_EVENT is used to clear the QS_EVENT bit, QS_EVENTSET is used to
 * set the bit.
 *
 * Include QS_SENDMESSAGE because the queue events
 * match what a win3.1 app would see as the QS_SENDMESSAGE bit. Plus 16 bit
 * apps don't even know about QS_EVENT.
 */
#define QS_EVENTSET        (QS_EVENT | QS_SENDMESSAGE)
/*
 * When you add a system metric, be sure to
 * add it to userexts.c in the function Idsi.
 */
#define SM_UNUSED_64            64
#define SM_UNUSED_65            65
#define SM_UNUSED_66            66
#define SM_BOOLEANS             85
/*
 * Add system metrics that don't take space in gpsi->aiSysMet here.
 */
/*
 * To add a BOOLEAN system metric increment SM_ENDBOOLRANGE by 1 and make your
 * SM_XXXX constant that new value.
 */

#define SM_STARTBOOLRANGE       0x2000
#define SM_ENDBOOLRANGE         0x2000
/*
 * When you add a system metric, be sure to
 * add it to userexts.c in the function Idsi.
 */
#if(_WIN32_WINNT >= 0x0501)
typedef int (CALLBACK* GETSYSTEMMETRICSPROC)(IN int nIndex);
#endif /* _WIN32_WINNT >= 0x0501 */
#define PMB_VALID       PMB_ACTIVE

WINUSERAPI
UINT
WINAPI
PaintMenuBar(
    IN HWND hwnd,
    IN HDC hdc,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN DWORD dwFlags);

WINUSERAPI
UINT
WINAPI
CalcMenuBar(
    IN HWND hwnd,
    IN int iLeftOffset,
    IN int iRightOffset,
    IN int iTopOffset,
    IN LPCRECT prcWnd);
WINUSERAPI
int
WINAPI
DrawMenuBarTemp(
    IN HWND,
    IN HDC,
    IN LPCRECT,
    IN HMENU,
    IN HFONT);
WINUSERAPI BOOL WINAPI SetSystemMenu( IN HWND, IN HMENU);
/*
 * MNS_ values are stored in pMenu->fFlags.
 * Low order bits are used for internal MF* flags defined in user.h
 */
#define MNS_LAST            0x04000000
#define MNS_VALID           0xFC000000
#define MIM_MASK                    0x8000001F
#define MNGOF_GAP            0x00000003
#define MNGOF_CROSSBOUNDARY  0x00000004
#define MIIM_MASK        0x000001FF
#define HBMMENU_MIN                 ((HBITMAP)  0)
#define HBMMENU_MBARFIRST           ((HBITMAP)  2)
#define HBMMENU_UNUSED              ((HBITMAP)  4)
#define HBMMENU_MBARLAST            ((HBITMAP)  7)
#define HBMMENU_POPUPFIRST          ((HBITMAP)  8)
#define HBMMENU_POPUPLAST           ((HBITMAP) 11)
#define HBMMENU_MAX                 ((HBITMAP) 12)
/*
 * Make sure to keep this in synch with the MENUITEMINFO structure. It should
 * be equal to the size of the structure pre NT5.
 */
#define SIZEOFMENUITEMINFO95 FIELD_OFFSET(MENUITEMINFO, hbmpItem)
#define TPM_SYSMENU         0x0200L
#define TPM_FIRSTANIBITPOS  10
#define TPM_ANIMATIONBITS   0x3C00L
#define TPM_VALID      (TPM_LEFTBUTTON   | \
                        TPM_RIGHTBUTTON  | \
                        TPM_LEFTALIGN    | \
                        TPM_CENTERALIGN  | \
                        TPM_RIGHTALIGN   | \
                        TPM_TOPALIGN     | \
                        TPM_VCENTERALIGN | \
                        TPM_BOTTOMALIGN  | \
                        TPM_HORIZONTAL   | \
                        TPM_VERTICAL     | \
                        TPM_NONOTIFY     | \
                        TPM_RECURSE      | \
                        TPM_RETURNCMD    | \
                        TPM_HORPOSANIMATION | \
                        TPM_HORNEGANIMATION | \
                        TPM_VERPOSANIMATION | \
                        TPM_VERNEGANIMATION | \
                        TPM_NOANIMATION     |\
                        TPM_LAYOUTRTL)
typedef struct _dropfilestruct {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point
   BOOL fNC;                           // is it on NonClient area
   BOOL fWide;                         // WIDE character switch
} DROPFILESTRUCT, FAR * LPDROPFILESTRUCT;
#define DT_VALID                    0x0007ffff  /* union of all others */
#undef DT_VALID
#define DT_VALID           (DT_CENTER          | \
                            DT_RIGHT           | \
                            DT_VCENTER         | \
                            DT_BOTTOM          | \
                            DT_WORDBREAK       | \
                            DT_SINGLELINE      | \
                            DT_EXPANDTABS      | \
                            DT_TABSTOP         | \
                            DT_NOCLIP          | \
                            DT_EXTERNALLEADING | \
                            DT_CALCRECT        | \
                            DT_NOPREFIX        | \
                            DT_INTERNAL        | \
                            DT_EDITCONTROL     | \
                            DT_PATH_ELLIPSIS   | \
                            DT_END_ELLIPSIS    | \
                            DT_MODIFYSTRING    | \
                            DT_RTLREADING      | \
                            DT_WORD_ELLIPSIS   | \
                            DT_NOFULLWIDTHCHARBREAK |\
                            DT_HIDEPREFIX      | \
                            DT_PREFIXONLY      )

#define DST_TEXTMAX     0x0002
#define DST_GLYPH       0x0005
#define DST_TYPEMASK    0x0007
#define DST_GRAYSTRING  0x0008
#define DSS_DEFAULT     0x0040
#define DSS_INACTIVE    0x0100
#define DCX_INVALID          0x00000800L
#define DCX_INUSE            0x00001000L
#define DCX_SAVEDRGNINVALID  0x00002000L
#define DCX_REDIRECTED       0x00004000L
#define DCX_OWNDC            0x00008000L

#define DCX_USESTYLE         0x00010000L
#define DCX_NEEDFONT         0x00020000L
#define DCX_NODELETERGN      0x00040000L
#define DCX_NOCLIPCHILDREN   0x00080000L

#define DCX_NORECOMPUTE      0x00100000L
#define DCX_DESTROYTHIS      0x00400000L
#define DCX_CREATEDC         0x00800000L

#define DCX_REDIRECTEDBITMAP 0x08000000L
#define DCX_PWNDORGINVISIBLE 0x10000000L
#define DCX_NOMIRROR         0x40000000L // Don't RTL Mirror DC (RTL_MIRRORING)
#define DCX_DONTRIPONDESTROY 0x80000000L


#define DCX_MATCHMASK       (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_REDIRECTED       | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_NORESETATTRS     | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_CREATEDC)

#define DCX_VALID           (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_NORESETATTRS     | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_PARENTCLIP       | \
                             DCX_EXCLUDERGN       | \
                             DCX_INTERSECTRGN     | \
                             DCX_EXCLUDEUPDATE    | \
                             DCX_INTERSECTUPDATE  | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_INVALID          | \
                             DCX_INUSE            | \
                             DCX_SAVEDRGNINVALID  | \
                             DCX_OWNDC            | \
                             DCX_USESTYLE         | \
                             DCX_NEEDFONT         | \
                             DCX_NODELETERGN      | \
                             DCX_NOCLIPCHILDREN   | \
                             DCX_NORECOMPUTE      | \
                             DCX_VALIDATE         | \
                             DCX_DESTROYTHIS      | \
                             DCX_CREATEDC)

WINUSERAPI
BOOL
WINAPI
AlignRects(
    IN OUT LPRECT arc,
    IN DWORD cCount,
    IN DWORD iPrimary,
    IN DWORD dwFlags);

//
// AlignRects flags
//

#define CUDR_NORMAL             0x0000
#define CUDR_NOSNAPTOGRID       0x0001
#define CUDR_NORESOLVEPOSITIONS 0x0002
#define CUDR_NOCLOSEGAPS        0x0004
#define CUDR_NOPRIMARY          0x0010
#if(_WIN32_WINNT >= 0x0501)
typedef int (CALLBACK* SETWINDOWRGNPROC)(IN HWND hWnd, IN HRGN hRgn, IN BOOL bRedraw);
#endif /* _WIN32_WINNT >= 0x0501 */
#define RDW_REDRAWWINDOW        0x1000  /* Called from RedrawWindow()*/
#define RDW_SUBTRACTSELF        0x2000  /* Subtract self from hrgn   */

#define RDW_COPYRGN             0x4000  /* Copy the passed-in region */
#define RDW_IGNOREUPDATEDIRTY   0x8000  /* Ignore WFUPDATEDIRTY      */
#define RDW_INVALIDATELAYERS    0x00010000 /* Allow layered windows invalidation */

#define RDW_VALIDMASK          (RDW_INVALIDATE      | \
                                RDW_INTERNALPAINT   | \
                                RDW_ERASE           | \
                                RDW_VALIDATE        | \
                                RDW_NOINTERNALPAINT | \
                                RDW_NOERASE         | \
                                RDW_NOCHILDREN      | \
                                RDW_ALLCHILDREN     | \
                                RDW_UPDATENOW       | \
                                RDW_ERASENOW        | \
                                RDW_FRAME           | \
                                RDW_NOFRAME)
#define SW_EXACTTIME        0x0020
#define SW_SCROLLWINDOW     0x8000  /* Called from ScrollWindow() */

#define SW_VALIDFLAGS      (SW_SCROLLWINDOW     | \
                            SW_SCROLLCHILDREN   | \
                            SW_INVALIDATE       | \
                            SW_SMOOTHSCROLL     | \
                            SW_EXACTTIME        | \
                            SW_ERASE)
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* ENABLESCROLLBARPROC)(IN HWND hWnd, IN UINT wSBflags, IN UINT wArrows);
#endif /* _WIN32_WINNT >= 0x0501 */
#define ESB_MAX             0x0003
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* ADJUSTWINDOWRECTEXPROC)(IN OUT LPRECT lpRect, IN DWORD dwStyle,
        IN BOOL bMenu, IN DWORD dwExStyle);
#endif /* _WIN32_WINNT >= 0x0501 */

/*
 * Help Engine stuff
 *
 * Note: for Chicago this is in winhelp.h and called WINHLP
 */
typedef struct {
    WORD cbData;              /* Size of data                     */
    WORD usCommand;           /* Command to execute               */
    ULONG_PTR ulTopic;        /* Topic/context number (if needed) */
    DWORD ulReserved;         /* Reserved (internal use)          */
    WORD offszHelpFile;       /* Offset to help file in block     */
    WORD offabData;           /* Offset to other data in block    */
} HLP, *LPHLP;

#if(WINVER >= 0x0500)
#define MB_LASTVALIDTYPE MB_CANCELTRYCONTINUE
#else
#define MB_LASTVALIDTYPE MB_RETRYCANCEL
#endif
#define MBEX_VALIDL                 0xf3f7
#define MBEX_VALIDH                 1
WINUSERAPI
int
WINAPI
MessageBoxTimeoutA(
    IN HWND hWnd,
    IN LPCSTR lpText,
    IN LPCSTR lpCaption,
    IN UINT uType,
    IN WORD wLanguageId,
    IN DWORD dwTimeout);
WINUSERAPI
int
WINAPI
MessageBoxTimeoutW(
    IN HWND hWnd,
    IN LPCWSTR lpText,
    IN LPCWSTR lpCaption,
    IN UINT uType,
    IN WORD wLanguageId,
    IN DWORD dwTimeout);
#ifdef UNICODE
#define MessageBoxTimeout  MessageBoxTimeoutW
#else
#define MessageBoxTimeout  MessageBoxTimeoutA
#endif // !UNICODE


#define MB_VALID                   (MB_OK                   | \
                                    MB_OKCANCEL             | \
                                    MB_ABORTRETRYIGNORE     | \
                                    MB_YESNOCANCEL          | \
                                    MB_YESNO                | \
                                    MB_RETRYCANCEL          | \
                                    MB_ICONHAND             | \
                                    MB_ICONQUESTION         | \
                                    MB_ICONEXCLAMATION      | \
                                    MB_ICONASTERISK         | \
                                    MB_DEFBUTTON1           | \
                                    MB_DEFBUTTON2           | \
                                    MB_DEFBUTTON3           | \
                                    MB_DEFBUTTON4           | \
                                    MB_APPLMODAL            | \
                                    MB_SYSTEMMODAL          | \
                                    MB_TASKMODAL            | \
                                    MB_HELP                 | \
                                    MB_TOPMOST              | \
                                    MB_RIGHT                | \
                                    MB_RTLREADING           | \
                                    MB_NOFOCUS              | \
                                    MB_SETFOREGROUND        | \
                                    MB_DEFAULT_DESKTOP_ONLY | \
                                    MB_SERVICE_NOTIFICATION | \
                                    MB_TYPEMASK             | \
                                    MB_USERICON             | \
                                    MB_ICONMASK             | \
                                    MB_DEFMASK              | \
                                    MB_MODEMASK             | \
                                    MB_MISCMASK)
#define CWP_VALID           (CWP_SKIPINVISIBLE | CWP_SKIPDISABLED | CWP_SKIPTRANSPARENT)
#define COLOR_3DALTFACE         25
#if(WINVER >= 0x0501)
#define COLOR_ENDCOLORS         COLOR_MENUBAR
#else
#define COLOR_ENDCOLORS         COLOR_INFOBK
#endif /* WINVER >= 0x0501 */
#define COLOR_MAX               (COLOR_ENDCOLORS+1)
WINUSERAPI
HANDLE
WINAPI
SetSysColorsTemp(
    IN CONST COLORREF *,
    IN CONST HBRUSH *,
    IN UINT_PTR wCnt);
/*
 * RTL Mirroring APIs (RTL_MIRRORING)
 */

WINUSERAPI
BOOL
WINAPI
SetDeskWallpaper(
    IN LPCSTR lpString);

WINUSERAPI
HWND
WINAPI
CreateDialogIndirectParamAorW(
    IN HANDLE hmod,
    IN LPCDLGTEMPLATE lpDlgTemplate,
    IN HWND hwndOwner,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam,
    IN UINT fAnsi);

WINUSERAPI
INT_PTR
WINAPI
DialogBoxIndirectParamAorW(
    IN HINSTANCE hmod,
    IN LPCDLGTEMPLATEW lpDlgTemplate,
    IN HWND hwndOwner,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam,
    IN UINT fAnsiFlags);

WINUSERAPI
void
WINAPI
LoadLocalFonts(void);

WINUSERAPI
UINT
WINAPI
UserRealizePalette(IN HDC hdc);

WINUSERAPI BOOL    WINAPI  SetShellWindow( IN HWND);
WINUSERAPI BOOL    WINAPI  SetShellWindowEx( IN HWND, IN HWND);
WINUSERAPI HWND    WINAPI  GetProgmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetProgmanWindow( IN HWND);
WINUSERAPI HWND    WINAPI  GetTaskmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetTaskmanWindow( IN HWND);
WINUSERAPI
BOOL
WINAPI
IsWindowInDestroy(IN HWND hwnd);

WINUSERAPI
BOOL
WINAPI
IsServerSideWindow(IN HWND hwnd);
WINUSERAPI HWND WINAPI GetNextQueueWindow ( IN HWND hWnd, IN INT nCmd);
#define MF_CHANGE_VALID   (MF_INSERT          | \
                           MF_CHANGE          | \
                           MF_APPEND          | \
                           MF_DELETE          | \
                           MF_REMOVE          | \
                           MF_BYCOMMAND       | \
                           MF_BYPOSITION      | \
                           MF_SEPARATOR       | \
                           MF_ENABLED         | \
                           MF_GRAYED          | \
                           MF_DISABLED        | \
                           MF_UNCHECKED       | \
                           MF_CHECKED         | \
                           MF_USECHECKBITMAPS | \
                           MF_STRING          | \
                           MF_BITMAP          | \
                           MF_OWNERDRAW       | \
                           MF_POPUP           | \
                           MF_MENUBARBREAK    | \
                           MF_MENUBREAK       | \
                           MF_UNHILITE        | \
                           MF_HILITE          | \
                           MF_SYSMENU)

#define MF_VALID          (MF_CHANGE_VALID    | \
                           MF_HELP            | \
                           MF_MOUSESELECT)

#define MFT_MASK            0x00036B64L
#define MFS_HOTTRACK        MF_APPEND
#define MFS_MASK            0x0000108BL
#define MFS_HOTTRACKDRAWN   0x10000000L
#define MFS_CACHEDBMP       0x20000000L
#define MFS_BOTTOMGAPDROP   0x40000000L
#define MFS_TOPGAPDROP      0x80000000L
#define MFS_GAPDROP         0xC0000000L

#define MFR_POPUP           0x01
#define MFR_END             0x80

#define MFT_OLDAPI_MASK     0x00006B64L
#define MFS_OLDAPI_MASK     0x0000008BL
#define MFT_NONSTRING       0x00000904L
#define MFT_BREAK           0x00000060L
typedef struct {        // version 1
    DWORD dwHelpID;
    DWORD fType;
    DWORD fState;
    DWORD menuId;
    WORD  wResInfo;
    WCHAR mtString[1];
} MENUITEMTEMPLATE2, *PMENUITEMTEMPLATE2;
#define SC_LAMEBUTTON   0xF190
#define IDC_NWPEN           MAKEINTRESOURCE(32531)
#define IDC_HUNG            MAKEINTRESOURCE(32632)
WINUSERAPI UINT PrivateExtractIconExA(
    IN LPCSTR szFileName,
    IN int      nIconIndex,
    OUT HICON   *phiconLarge,
    OUT HICON   *phiconSmall,
    IN UINT     nIcons);
WINUSERAPI UINT PrivateExtractIconExW(
    IN LPCWSTR szFileName,
    IN int      nIconIndex,
    OUT HICON   *phiconLarge,
    OUT HICON   *phiconSmall,
    IN UINT     nIcons);
#ifdef UNICODE
#define PrivateExtractIconEx  PrivateExtractIconExW
#else
#define PrivateExtractIconEx  PrivateExtractIconExA
#endif // !UNICODE
#define LR_GLOBAL           0x0100
#define LR_ENVSUBST         0x0200
#define LR_ACONFRAME        0x0400
#define LR_CREATEREALDIB    0x0800
#define LR_VALID            0xF8FF
#define DI_VALID       (DI_MASK | DI_IMAGE | DI_COMPAT | DI_DEFAULTSIZE | DI_NOMIRROR)
#define OBM_STARTUP         32733
#define OBM_TRUETYPE        32732
#define OBM_HELP            32731
#define OBM_HELPD           32730
#define OBM_RDRVERT         32559
#define OBM_RDRHORZ         32660
#define OBM_RDR2DIM         32661
#define OCR_NWPEN           32631
#define OCR_HELP            32651


#define OCR_RDRVERT         32652
#define OCR_RDRHORZ         32653
#define OCR_RDR2DIM         32654
#define OCR_RDRNORTH        32655
#define OCR_RDRSOUTH        32656
#define OCR_RDRWEST         32657
#define OCR_RDREAST         32658
#define OCR_RDRNORTHWEST    32659
#define OCR_RDRNORTHEAST    32660
#define OCR_RDRSOUTHWEST    32661
#define OCR_RDRSOUTHEAST    32662

#define OCR_AUTORUN         32663

/*
 * Default Cursor IDs to get original image from User
 */
#define OCR_FIRST_DEFAULT           100
#define OCR_ARROW_DEFAULT           100
#define OCR_IBEAM_DEFAULT           101
#define OCR_WAIT_DEFAULT            102
#define OCR_CROSS_DEFAULT           103
#define OCR_UPARROW_DEFAULT         104
#define OCR_SIZENWSE_DEFAULT        105
#define OCR_SIZENESW_DEFAULT        106
#define OCR_SIZEWE_DEFAULT          107
#define OCR_SIZENS_DEFAULT          108
#define OCR_SIZEALL_DEFAULT         109
#define OCR_NO_DEFAULT              110
#define OCR_APPSTARTING_DEFAULT     111
#define OCR_HELP_DEFAULT            112
#define OCR_NWPEN_DEFAULT           113
#define OCR_HAND_DEFAULT            114
#define OCR_ICON_DEFAULT            115
#define OCR_AUTORUN_DEFAULT         116
#define COCR_CONFIGURABLE           (OCR_AUTORUN_DEFAULT - OCR_FIRST_DEFAULT + 1)
/* Default IDs for original User images */
#define OIC_FIRST_DEFAULT           100
#define OIC_APPLICATION_DEFAULT     100
#define OIC_HAND_DEFAULT            101
#define OIC_WARNING_DEFAULT         101
#define OIC_QUESTION_DEFAULT        102
#define OIC_EXCLAMATION_DEFAULT     103
#define OIC_ERROR_DEFAULT           103
#define OIC_ASTERISK_DEFAULT        104
#define OIC_INFORMATION_DEFAULT     104
#define OIC_WINLOGO_DEFAULT         105
#define COIC_CONFIGURABLE           (OIC_WINLOGO_DEFAULT - OIC_FIRST_DEFAULT + 1)
#define IDUSERICON      20
#define ES_FMTMASK          0x0003L
#define ES_COMBOBOX         0x0200L
#define EM_SETFONT              0x00C3 /* no longer suported */
#define EM_SETWORDBREAK         0x00CA /* no longer suported */
#define EM_MSGMAX               0x00DA
#define BS_IMAGEMASK        0x000000C0L
#define BS_HORZMASK         0x00000300L
#define BS_VERTMASK         0x00000C00L
#define BS_ALIGNMASK        0x00000F00L
#define SS_TEXTMAX0         0x00000002L
#define SS_TEXTMIN1         0x0000000BL
#define SS_TEXTMAX1         0x0000000DL
#define ISSSTEXTOROD(bType) (((bType) <= SS_TEXTMAX0) \
                                || (((bType) >= SS_TEXTMIN1) && ((bType) <= SS_TEXTMAX1)))
#define DDL_NOFILES         0x1000
#define DDL_VALID          (DDL_READWRITE  | \
                            DDL_READONLY   | \
                            DDL_HIDDEN     | \
                            DDL_SYSTEM     | \
                            DDL_DIRECTORY  | \
                            DDL_ARCHIVE    | \
                            DDL_POSTMSGS   | \
                            DDL_DRIVES     | \
                            DDL_EXCLUSIVE)
/*
 * Valid dialog style bits for Chicago compatibility.
 */
//#define DS_VALID_FLAGS (DS_ABSALIGN|DS_SYSMODAL|DS_LOCALEDIT|DS_SETFONT|DS_MODALFRAME|DS_NOIDLEMSG | DS_SETFOREGROUND)
#define DS_VALID_FLAGS   0x1FFF

#define SCDLG_CLIENT            0x0001
#define SCDLG_ANSI              0x0002
#define SCDLG_NOREVALIDATE      0x0004
#define SCDLG_16BIT             0x0008      // Created for a 16 bit thread; common dialogs

#define DS_VALID31          0x01e3L
#define DS_VALID40          0x7FFFL
#define DS_RECURSE      DS_CONTROL  /* BOGUS GOING AWAY */
#define DS_COMMONDIALOG     0x4000L

#define DS_NONBOLD  DS_3DLOOK   /* BOGUS GOING AWAY */
#define LBCB_CARETON            0x01A3
#define LBCB_CARETOFF           0x01A4
#define LB_INSERTSTRINGUPPER    0x01AA
#define LB_INSERTSTRINGLOWER    0x01AB
#define LB_ADDSTRINGUPPER       0x01AC
#define LB_ADDSTRINGLOWER       0x01AD
#define LBCB_STARTTRACK         0x01AE
#define LBCB_ENDTRACK           0x01AF
#define CBEC_SETCOMBOFOCUS          (CB_MSGMAX+1)
#define CBEC_KILLCOMBOFOCUS         (CB_MSGMAX+2)
#define SIF_RETURNOLDPOS    0x1000
#define SIF_NOSCROLL        0x2000
#define SIF_MASK            0x701F
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* GETSCROLLINFOPROC)(IN HWND, IN int, IN OUT LPSCROLLINFO);
typedef int  (CALLBACK* SETSCROLLINFOPROC)(IN HWND, IN int, IN LPCSCROLLINFO, IN BOOL);
#endif /* _WIN32_WINNT >= 0x0501 */
#define HELP_HB_NORMAL    0x0000L
#define HELP_HB_STRING    0x0100L
#define HELP_HB_STRUCT    0x0200L
#define GR_MAXOBJECT      1
#if(_WIN32_WINNT >= 0x0500)
/*
 * Query win32k statistics -internal
 * QUERYUSER_CS         Query critical section usage
 * QUERYUSER_HANDLES    Query user per-process user handle count
 */

#define QUC_PID_TOTAL           0xffffffff
#define QUERYUSER_HANDLES       0x1
#if defined (USER_PERFORMANCE)
#define QUERYUSER_CS            0x2

/*
 *  The counters in CSSTATISTICS refer to the USER critical section:
 *      cExclusive counts how many times the CS was aquired exclusive
 *      cShared counts how many times the CS was aquired shared
 *      i64TimeExclusive counts the time (NtQueryPerformanceCounter() units)
 *      spent in the resource since the last query.
 */
typedef struct _tagCSStatistics {
        DWORD   cExclusive;
        DWORD   cShared;
        __int64 i64TimeExclusive;
} CSSTATISTICS;
#endif // USER_PERFORMANCE

BOOL
WINAPI
QueryUserCounters(
    IN  DWORD   dwQueryType,
    IN  LPVOID  pvIn,
    IN  DWORD   dwInSize,
    OUT LPVOID  pvResult,
    IN  DWORD   dwOutSize
);
#endif /* _WIN32_WINNT >= 0x0500 */
#define SPI_TIMEOUTS                0x0007
#define SPI_KANJIMENU               0x0008
#define SPI_UNUSED39                0x0027
#define SPI_UNUSED40                0x0028
#define SPI_UNUSED108              0x006C
#define SPI_UNUSED109              0x006D
#define SPI_MAX                   0x0074

/*
 * ADDING NEW SPI_* VALUES
 * If the value is a BOOL, it should be added after SPI_STARTBOOLRANGE
 * If the value is a DWORD, it should be added after SPI_STARTDWORDRANGE
 * If the value is a structure or a string, go ahead and setup SPI_START*RANGE....
 */

/*
 * If adding a new SPI value in the following ranges:
 * -You must define both SPI_GET* and SPI_SET* using consecutive numbers
 * -The low order bit of SPI_GET* must be 0
 * -The low order bit of SPI_SET* must be 1
 * -Properly update SPI_MAX*RANGE
 * -Add the default value to kernel\globals.c in the proper *CPUserPreferences* variable
 * -Add the default value to the proper registry hives.
 * -If your value requires some special validation, do so in kernel\ntstubs.c
 * -If you find something wrong in this documentation, FIX IT!.
 */
#define SPIF_SET                  0x0001
#define SPIF_BOOL                 0x1000
#define SPIF_DWORD                0x2000
#define SPIF_RANGETYPEMASK        0x3000
/*
 * BOOLeans range.
 * For GET, pvParam is a pointer to a BOOL
 * For SET, pvParam is the value
 */
#define SPI_STARTBOOLRANGE                  0x1000
#define SPI_UNUSED1010                      0x1010
#define SPI_UNUSED1011                      0x1011
/*
 * All SPI_s for UI effects must be < SPI_GETUIEFFECTS
 */
#define SPI_MAXBOOLRANGE                    0x1040
#define SPI_BOOLRANGECOUNT ((SPI_MAXBOOLRANGE - SPI_STARTBOOLRANGE) / 2)
#define SPI_BOOLMASKDWORDSIZE (((SPI_BOOLRANGECOUNT - 1) / 32) + 1)

/*
 * DWORDs range.
 * For GET, pvParam is a pointer to a DWORD
 * For SET, pvParam is the value
 */
#define SPI_STARTDWORDRANGE                 0x2000
#define FE_FONTSMOOTHINGTYPE_VALID          (FE_FONTSMOOTHINGSTANDARD | FE_FONTSMOOTHINGCLEARTYPE | FE_FONTSMOOTHINGDOCKING)
#define FE_FONTSMOOTHINGORIENTATION_VALID          (FE_FONTSMOOTHINGORIENTATIONRGB)
#define SPI_MAXDWORDRANGE                   0x2014
#define SPI_DWORDRANGECOUNT ((SPI_MAXDWORDRANGE - SPI_STARTDWORDRANGE) / 2)
#define SPIF_VALID            (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE)
#define ARW_VALID                   0x000FL
#define MAX_SCHEME_NAME_SIZE 128
#define CDS_RAWMODE         0x00000040
#define CDS_TRYCLOSEST      0x00000080
#define CDS_EXCLUSIVE       0x80000000
#define CDS_VALID           0xD00000FF
#define EDS_SHOW_DUPLICATES           0x00000001
#define EDS_SHOW_MONITOR_NOT_CAPABLE  0x00000002
void LoadRemoteFonts(void);
#if(_WIN32_WINNT >= 0x0501)
typedef BOOL (CALLBACK* SYSTEMPARAMETERSINFO) (
    IN UINT,
    IN UINT,
    IN OUT PVOID,
    IN UINT);
#endif /* _WIN32_WINNT >= 0x0501 */
#define FKF_VALID           0x0000007F
#define SKF_VALID           0x000001FF
#define SKF_STATEINFO         0xffff0000
#define MKF_VALID           0x000000FF
#define MKF_STATEINFO       0xB3000000
#define ATF_VALID           0x00000003
#define SSF_VALID           0x00000007
#define TKF_VALID           0x0000003F

WINUSERAPI VOID WINAPI RegisterNetworkCapabilities( IN DWORD dwBitsToSet, IN DWORD dwValues);
#define RNC_NETWORKS              0x00000001
#define RNC_LOGON                 0x00000002

#if !defined(WINNT)     // Win95 version of EndTask
WINUSERAPI DWORD WINAPI EndTask( IN HWND hwnd, IN DWORD idProcess, IN LPSTR lpszCaption, IN DWORD dwFlags);
#define ET_ALLOWFORWAIT     0x00000001
#define ET_TRYTOKILLNICELY  0x00000002
#define ET_NOUI             0x00000004
#define ET_NOWAIT           0x00000008
#define ET_VALID           (ET_ALLOWFORWAIT | ET_TRYTOKILLNICELY | ET_NOUI | ET_NOWAIT)
#endif

#define LOGON_LOGOFF          0
#define LOGON_INPUT_TIMEOUT   1
#define LOGON_RESTARTSHELL    2


#if (_WIN32_WINNT >= 0x0500)
#define LOGON_ACCESSNOTIFY    3
#define LOGON_POWERSTATE      4
#define LOGON_LOCKWORKSTATION 5

#define SESSION_RECONNECTED   6
#define SESSION_DISCONNECTED  7
#define SESSION_LOGOFF        8
#define LOGON_PLAYEVENTSOUND  9
#if(_WIN32_WINNT >= 0x0501)
#define LOGON_POWEREVENT      10
#endif /* _WIN32_WINNT >= 0x0501 */
#define LOGON_LOGOFFCANCELED  11
#if(_WIN32_WINNT >= 0x0501)
#define LOGON_SHOW_POWER_MESSAGE 12
#define LOGON_REMOVE_POWER_MESSAGE 13
#define SESSION_PRERECONNECT  14
#define SESSION_DISABLESCRNSAVER   15
#define SESSION_ENABLESCRNSAVER     16
#define SESSION_PRERECONNECTDESKTOPSWITCH  17
#define SESSION_HELPASSISTANTSHADOWSTART   18
#define SESSION_HELPASSISTANTSHADOWFINISH  19
#define SESSION_DISCONNECTPIPE     20

#define LOCK_NORMAL           0
#define LOCK_RESUMEHIBERNATE  1
#endif /* _WIN32_WINNT >= 0x0501 */

/*
 * Notification codes for WM_DESKTOPNOTIFY
 */
#define DESKTOP_RELOADWALLPAPER 0

#define    ACCESS_STICKYKEYS            0x0001
#define    ACCESS_FILTERKEYS            0x0002
#define    ACCESS_MOUSEKEYS             0x0003
#define    ACCESS_TOGGLEKEYS            0x0004
#define    ACCESS_HIGHCONTRAST          0x0005  // notification dlg
#define    ACCESS_UTILITYMANAGER        0x0006
#define    ACCESS_HIGHCONTRASTON        0x0008
#define    ACCESS_HIGHCONTRASTOFF       0x0009
#define    ACCESS_HIGHCONTRASTCHANGE    0x000A
#define    ACCESS_HIGHCONTRASTONNOREG   0x000C
#define    ACCESS_HIGHCONTRASTOFFNOREG  0x000D
#define    ACCESS_HIGHCONTRASTCHANGENOREG 0x000E
#define    ACCESS_HIGHCONTRASTNOREG  0x0004


#define USER_SOUND_DEFAULT                0      // default MB sound
#define USER_SOUND_SYSTEMHAND             1      // MB_ICONHAND shifted
#define USER_SOUND_SYSTEMQUESTION         2      // MB_ICONQUESTION shifted
#define USER_SOUND_SYSTEMEXCLAMATION      3      // MB_ICONEXCLAMATION shifted
#define USER_SOUND_SYSTEMASTERISK         4      // MB_ICONASTERISK shifted
#define USER_SOUND_MENUPOPUP              5
#define USER_SOUND_MENUCOMMAND            6
#define USER_SOUND_OPEN                   7
#define USER_SOUND_CLOSE                  8
#define USER_SOUND_RESTOREUP              9
#define USER_SOUND_RESTOREDOWN            10
#define USER_SOUND_MINIMIZE               11
#define USER_SOUND_MAXIMIZE               12
#define USER_SOUND_SNAPSHOT               13
#define USER_SOUND_MAX                    14


#ifdef _NTPOAPI_
typedef struct tagPOWERSTATEPARAMS {
    POWER_ACTION        SystemAction;
    SYSTEM_POWER_STATE  MinSystemState;
    ULONG               Flags;
    BOOL                FullScreenMode;
} POWERSTATEPARAMS, *PPOWERSTATEPARAMS;
#endif

#endif

#define LOGON_FLG_MASK      0xF0000000
#define LOGON_FLG_SHIFT     28

#define STARTF_DESKTOPINHERIT   0x40000000
#define STARTF_SCREENSAVER      0x80000000

#define WSS_ERROR       0
#define WSS_BUSY        1
#define WSS_IDLE        2

#define DTF_CENTER    0x00   /* Center the bitmap (default)                  */
#define DTF_TILE      0x01   /* Tile the bitmap                              */
#define DTF_STRETCH   0x02   /* Stretch bitmap to cover screen.              */
#if 0 /* the following have not been used anywhere in NT since at least 1992 */
#define DTF_NOPALETTE 0x04   /* Realize palette, otherwise match to default. */
#define DTF_RETAIN    0x08   /* Retain bitmap, ignore win.ini changes        */
#define DTF_FIT       0x10   /* Fit the bitmap to the screen (scaled).       */
#endif

#ifdef _INC_DDEMLH
BOOL DdeIsDataHandleReadOnly(
    IN HDDEDATA hData);

int DdeGetDataHandleFormat(
    IN HDDEDATA hData);

DWORD DdeGetCallbackInstance(VOID);
#endif /* defined _INC_DDEMLH */

#define LPK_TABBED_TEXT_OUT 0
#define LPK_PSM_TEXT_OUT    1
#define LPK_DRAW_TEXT_EX    2
#define LPK_EDIT_CONTROL    3

VOID
WINAPI
InitializeLpkHooks(
    IN CONST FARPROC *lpfpLpkHooks
);

WINUSERAPI
HWND
WINAPI
WOWFindWindow(
    IN LPCSTR lpClassName,
    IN LPCSTR lpWindowName);

int
WINAPI
InternalDoEndTaskDlg(
    IN TCHAR* pszTitle);

DWORD
WINAPI
InternalWaitCancel(
    IN HANDLE handle,
    IN DWORD dwMilliseconds);

HANDLE
WINAPI
InternalCreateCallbackThread(
    IN HANDLE hProcess,
    IN ULONG_PTR lpfn,
    IN ULONG_PTR dwData);

WINUSERAPI
UINT
WINAPI
GetInternalWindowPos(
    IN HWND hWnd,
    OUT LPRECT lpRect,
    IN LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
SetInternalWindowPos(
    IN HWND hWnd,
    IN UINT cmdShow,
    IN LPRECT lpRect,
    IN LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
CalcChildScroll(
    IN HWND hWnd,
    IN UINT sb);

WINUSERAPI
BOOL
WINAPI
RegisterTasklist(
    IN HWND hWndTasklist);

WINUSERAPI
BOOL
WINAPI
CascadeChildWindows(
    IN HWND hWndParent,
    IN UINT flags);

WINUSERAPI
BOOL
WINAPI
TileChildWindows(
    IN HWND hWndParent,
    IN UINT flags);

/*
 * Services support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterServicesProcess(
    IN DWORD dwProcessId);

/*
 * Logon support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterLogonProcess(
    IN DWORD dwProcessId,
    IN BOOL fSecure);

WINUSERAPI
UINT
WINAPI
LockWindowStation(
    IN HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
UnlockWindowStation(
    IN HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
SetWindowStationUser(
    IN HWINSTA hWindowStation,
    IN PLUID pLuidUser,
    IN PSID pSidUser,
    IN DWORD cbSidUser);

WINUSERAPI
BOOL
WINAPI
SetDesktopBitmap(
    IN HDESK hdesk,
    IN HBITMAP hbmWallpaper,
    IN DWORD dwStyle);

WINUSERAPI
BOOL
WINAPI
SetLogonNotifyWindow(
    IN HWND    hWndNotify);

WINUSERAPI
UINT
WINAPI
GetIconId(
    IN HANDLE hRes,
    IN LPSTR lpszType);

WINUSERAPI
int
WINAPI
CriticalNullCall(
    VOID);

WINUSERAPI
int
WINAPI
NullCall(
    VOID);

WINUSERAPI
VOID
WINAPI
UserNotifyConsoleApplication(
    IN DWORD dwProcessId);

WINUSERAPI
BOOL
WINAPI
EnterReaderModeHelper(
    HWND hwnd);

/*
 * Reserved console space.
 *
 * This was moved from the console code so that we can localize it
 * in one place.  This was necessary for dealing with the background
 * color, which we need to have for the hungapp drawing.  These are
 * stored in the extra-window-bytes of each console.
 */
#define GWL_CONSOLE_WNDALLOC  (3 * sizeof(DWORD))
#define GWL_CONSOLE_PID       0
#define GWL_CONSOLE_TID       4
#define GWL_CONSOLE_BKCOLOR   8


VOID vFontSweep();
VOID vLoadLocalT1Fonts();
VOID vLoadRemoteT1Fonts();


#ifndef NOMSG

#define TM_INMENUMODE     0x0001
#define TM_POSTCHARBREAKS 0x0002

WINUSERAPI
BOOL
WINAPI
TranslateMessageEx(
    IN CONST MSG *lpMsg,
    IN UINT flags);

#endif /* !NOMSG */

/*
 * Those values can be specified as nAnsiChar for MBToWCSEx
 * USER_AWCONV_COUNTSTRING:      Count the length of the string including trailing \0
 * USER_AWCONV_COUNTSTRINGSZ:    Count the length of the string excluding trailing \0
 *
 * Note: The result includes trailing \0 if USER_AWCONV_COUNTSTRING is specified.
 *  USER_AWCONV_COUNTSTRINGSZ will not null-terminate the restult string. It may return
 * 0 if the source strlen() == 0.
 */
#define USER_AWCONV_COUNTSTRING          (-1)
#define USER_AWCONV_COUNTSTRINGSZ        (-2)


WINUSERAPI
int
WINAPI
WCSToMBEx(
    IN WORD wCodePage,
    IN LPCWSTR pUnicodeString,
    IN int cbUnicodeChar,
    OUT LPSTR *ppAnsiString,
    IN int nAnsiChar,
    IN BOOL bAllocateMem);

WINUSERAPI
int
WINAPI
MBToWCSEx(
    IN WORD wCodePage,
    IN LPCSTR pAnsiString,
    IN int nAnsiChar,
    OUT LPWSTR *ppUnicodeString,
    IN int cbUnicodeChar,
    IN BOOL bAllocateMem);

#define UPUSP_USERLOGGEDON        0x00000001
#define UPUSP_POLICYCHANGE        0x00000002
#define UPUSP_REMOTESETTINGS      0x00000004


#define UPUSP_USERLOGGEDON        0x00000001
#define UPUSP_POLICYCHANGE        0x00000002
#define UPUSP_REMOTESETTINGS      0x00000004

WINUSERAPI
BOOL
WINAPI
UpdatePerUserSystemParameters(
    IN HANDLE hToken,
    IN DWORD  dwFlags);

typedef VOID  (APIENTRY *PFNW32ET)(VOID);

WINUSERAPI
BOOL
WINAPI
RegisterUserHungAppHandlers(
    IN PFNW32ET pfnW32EndTask,
    IN HANDLE   hEventWowExec);

WINUSERAPI
ATOM
WINAPI
RegisterClassWOWA(
    IN PVOID   lpWndClass,
    IN LPDWORD pdwWOWstuff);

WINUSERAPI
LONG
WINAPI
GetClassWOWWords(
    IN HINSTANCE hInstance,
    OUT LPCTSTR pString);

WINUSERAPI
DWORD
WINAPI
CurrentTaskLock(
    IN DWORD hlck);

WINUSERAPI
HDESK
WINAPI
GetInputDesktop(
    VOID);

#define WINDOWED       0
#define FULLSCREEN     1
#define GDIFULLSCREEN  2
#define FULLSCREENMIN  4


#define WCSToMB(pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar,\
bAllocateMem)\
WCSToMBEx(0, pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar, bAllocateMem)

#define MBToWCS(pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar,\
bAllocateMem)\
MBToWCSEx(0, pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar, bAllocateMem)

#define ID(string) (((ULONG_PTR)string & ~0x0000ffff) == 0)

/*
 * For setting RIT timers and such.  GDI uses this for the cursor-restore
 * timer.
 */
#define TMRF_READY      0x0001
#define TMRF_SYSTEM     0x0002
#define TMRF_RIT        0x0004
#define TMRF_INIT       0x0008
#define TMRF_ONESHOT    0x0010
#define TMRF_WAITING    0x0020
#define TMRF_PTIWINDOW  0x0040


/*
 * For GDI SetAbortProc support.
 */

WINUSERAPI
int
WINAPI
CsDrawTextA(
    IN HDC hDC,
    IN LPCSTR lpString,
    IN int nCount,
    IN LPRECT lpRect,
    IN UINT uFormat);
WINUSERAPI
int
WINAPI
CsDrawTextW(
    IN HDC hDC,
    IN LPCWSTR lpString,
    IN int nCount,
    IN LPRECT lpRect,
    IN UINT uFormat);
#ifdef UNICODE
#define CsDrawText  CsDrawTextW
#else
#define CsDrawText  CsDrawTextA
#endif // !UNICODE

WINUSERAPI
LONG
WINAPI
CsTabbedTextOutA(
    IN HDC hDC,
    IN int X,
    IN int Y,
    IN LPCSTR lpString,
    IN int nCount,
    IN int nTabPositions,
    IN LPINT lpnTabStopPositions,
    IN int nTabOrigin);
WINUSERAPI
LONG
WINAPI
CsTabbedTextOutW(
    IN HDC hDC,
    IN int X,
    IN int Y,
    IN LPCWSTR lpString,
    IN int nCount,
    IN int nTabPositions,
    IN LPINT lpnTabStopPositions,
    IN int nTabOrigin);
#ifdef UNICODE
#define CsTabbedTextOut  CsTabbedTextOutW
#else
#define CsTabbedTextOut  CsTabbedTextOutA
#endif // !UNICODE

WINUSERAPI
int
WINAPI
CsFrameRect(
    IN HDC hDC,
    IN CONST RECT *lprc,
    IN HBRUSH hbr);

#ifdef UNICODE
#define CsDrawText      CsDrawTextW
#define CsTabbedTextOut CsTabbedTextOutW
#else /* !UNICODE */
#define CsDrawText      CsDrawTextA
#define CsTabbedTextOut CsTabbedTextOutA
#endif /* !UNICODE */

/*
 * Custom Cursor action.
 */
WINUSERAPI
HCURSOR
WINAPI
GetCursorFrameInfo( // Obsolete? - IanJa
    IN HCURSOR hcur,
    OUT LPWSTR id,
    IN int iFrame,
    OUT LPDWORD pjifRate,
    OUT LPINT pccur);


/*
 * WOW: replace cursor/icon handle
 */

WINUSERAPI
BOOL
WINAPI
SetCursorContents( IN HCURSOR hCursor, IN HCURSOR hCursorNew);


#ifdef WX86

/*
 *  Wx86
 *  export from wx86.dll to convert an x86 hook proc to risc address.
 */
typedef
PVOID
(*PFNWX86HOOKCALLBACK)(
    SHORT HookType,
    PVOID HookProc
    );

typedef
HMODULE
(*PFNWX86LOADX86DLL)(
    LPCWSTR lpLibFileName,
    DWORD   dwFlags
    );


typedef
BOOL
(*PFNWX86FREEX86DLL)(
    HMODULE hMod
    );

#endif







typedef struct _TAG {
    DWORD type;
    DWORD style;
    DWORD len;
} TAG, *PTAG;

#define MAKETAG(a, b, c, d) (DWORD)(a | (b<<8) | ((DWORD)c<<16) | ((DWORD)d<<24))


/* Valid TAG types. */

/* 'ASDF' (CONT) - Advanced Systems Data Format */

#define TAGT_ASDF MAKETAG('A', 'S', 'D', 'F')


/* 'RAD ' (CONT) - ?R Animation ?Definition (an aggregate type) */

#define TAGT_RAD  MAKETAG('R', 'A', 'D', ' ')


/* 'ANIH' (DATA) - ANImation Header */
/* Contains an ANIHEADER structure. */

#define TAGT_ANIH MAKETAG('A', 'N', 'I', 'H')


/*
 * 'RATE' (DATA) - RATE table (array of jiffies)
 * Contains an array of JIFs.  Each JIF specifies how long the corresponding
 * animation frame is to be displayed before advancing to the next frame.
 * If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
 * otherwise the count == anih.cFrames.
 */
#define TAGT_RATE MAKETAG('R', 'A', 'T', 'E')

/*
 * 'SEQ ' (DATA) - SEQuence table (array of frame index values)
 * Countains an array of DWORD frame indices.  anih.cSteps specifies how
 * many.
 */
#define TAGT_SEQ  MAKETAG('S', 'E', 'Q', ' ')


/* 'ICON' (DATA) - Windows ICON format image (replaces MPTR) */

#define TAGT_ICON MAKETAG('I', 'C', 'O', 'N')


/* 'TITL' (DATA) - TITLe string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that titles the file. */

#define TAGT_TITL MAKETAG('T', 'I', 'T', 'L')


/* 'AUTH' (DATA) - AUTHor string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that indicates the author of the file. */

#define TAGT_AUTH MAKETAG('A', 'U', 'T', 'H')



#define TAGT_AXOR MAKETAG('A', 'X', 'O', 'R')


/* Valid TAG styles. */

/* 'CONT' - CONTainer chunk (contains other DATA and CONT chunks) */

#define TAGS_CONT MAKETAG('C', 'O', 'N', 'T')


/* 'DATA' - DATA chunk */

#define TAGS_DATA MAKETAG('D', 'A', 'T', 'A')

typedef DWORD JIF, *PJIF;

typedef struct _ANIHEADER {     /* anih */
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

/* If the AF_ICON flag is specified the fields cx, cy, cBitCount, and */
/* cPlanes are all unused.  Each frame will be of type ICON and will */
/* contain its own dimensional information. */

#define AF_ICON     0x0001L     /* Windows format icon/cursor animation */
#define AF_SEQUENCE 0x0002L     /* Animation is sequenced */
#define WINEVENT_32BITCALLER    0x8000  //  - unused in NT
#define WINEVENT_VALID          0x0007  //
#ifdef REDIRECTION
#define EVENT_SYSTEM_REDIRECTEDPAINT    0x0018
#endif // REDIRECTION
// Output from DISPID_ACC_STATE (IanJa: taken from oleacc.h)
/*
 * CONSTANTS
 */

/*
 * Object constants (these are NOT public).  OBJID are public IDs for
 * standard frame elements.  But the indeces for their elements are not.
 */

// TITLEBAR
#define INDEX_TITLEBAR_SELF             0
#define INDEX_TITLEBAR_IMEBUTTON        1
#define INDEX_TITLEBAR_MINBUTTON        2
#define INDEX_TITLEBAR_MAXBUTTON        3
#define INDEX_TITLEBAR_HELPBUTTON       4
#define INDEX_TITLEBAR_CLOSEBUTTON      5

#define INDEX_TITLEBAR_MIC              1
#define INDEX_TITLEBAR_MAC              5

#define INDEX_TITLEBAR_RESTOREBUTTON    6 // The min/max buttons turn into this


// SCROLLBAR
#define INDEX_SCROLLBAR_SELF            0
#define INDEX_SCROLLBAR_UP              1
#define INDEX_SCROLLBAR_UPPAGE          2
#define INDEX_SCROLLBAR_THUMB           3
#define INDEX_SCROLLBAR_DOWNPAGE        4
#define INDEX_SCROLLBAR_DOWN            5

#define INDEX_SCROLLBAR_MIC             1
#define INDEX_SCROLLBAR_MAC             5

#define INDEX_SCROLLBAR_LEFT            7
#define INDEX_SCROLLBAR_LEFTPAGE        8
#define INDEX_SCROLLBAR_HORZTHUMB       9
#define INDEX_SCROLLBAR_RIGHTPAGE       10
#define INDEX_SCROLLBAR_RIGHT           11

#define INDEX_SCROLLBAR_HORIZONTAL      6
#define INDEX_SCROLLBAR_GRIP            12


// COMBOBOXES
#define INDEX_COMBOBOX                  0
#define INDEX_COMBOBOX_ITEM             1
#define INDEX_COMBOBOX_BUTTON           2
#define INDEX_COMBOBOX_LIST             3

#define CCHILDREN_COMBOBOX              3


#define CBLISTBOXID 1000
#define CBEDITID    1001
#define CBBUTTONID  1002


// CURSORS
#define CURSOR_SYSTEM_NOTHING           -1
#define CURSOR_SYSTEM_UNKNOWN           0
#define CURSOR_SYSTEM_ARROW             1
#define CURSOR_SYSTEM_IBEAM             2
#define CURSOR_SYSTEM_WAIT              3
#define CURSOR_SYSTEM_CROSS             4
#define CURSOR_SYSTEM_UPARROW           5
#define CURSOR_SYSTEM_SIZENWSE          6
#define CURSOR_SYSTEM_SIZENESW          7
#define CURSOR_SYSTEM_SIZEWE            8
#define CURSOR_SYSTEM_SIZENS            9
#define CURSOR_SYSTEM_SIZEALL           10
#define CURSOR_SYSTEM_NO                11
#define CURSOR_SYSTEM_APPSTARTING       12
#define CURSOR_SYSTEM_HELP              13
#define CURSOR_SYSTEM_NWPEN             14
#define CURSOR_SYSTEM_HAND              15
#define CCURSOR_SYSTEM                  15

#define     GA_MIN          1
#define     GA_MAX          3
#if(_WIN32_WINNT >= 0x0500)

/*
 * The max number of tags to fail that can be
 * specified to Win32PoolAllocationStats. If tagsCount is more than
 * this value then all the pool allocations will fail.
 */
#define MAX_TAGS_TO_FAIL        256

BOOL
WINAPI
Win32PoolAllocationStats(
    IN  LPDWORD parrTags,
    IN  SIZE_T  tagCount,
    OUT SIZE_T* lpdwMaxMem,
    OUT SIZE_T* lpdwCrtMem,
    OUT LPDWORD lpdwMaxAlloc,
    OUT LPDWORD lpdwCrtAlloc);

#define WHF_DESKTOP             0x00000001
#define WHF_SHAREDHEAP          0x00000002
#define WHF_CSRSS               0x00000004
#define WHF_ALL                 (WHF_DESKTOP | WHF_SHAREDHEAP | WHF_CSRSS)

#define WHF_VALID               WHF_ALL

VOID
WINAPI
DbgWin32HeapFail(
    DWORD    dwFlags,
    BOOL     bFail
);

typedef struct tagDBGHEAPSTAT {
    DWORD   dwTag;
    DWORD   dwSize;
    DWORD   dwCount;
} DBGHEAPSTAT, *PDBGHEAPSTAT;

DWORD
WINAPI
DbgWin32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD    dwLen,
    DWORD    dwFlags
);

#define WPROTOCOLNAME_LENGTH    10
#define WAUDIONAME_LENGTH       10

typedef struct tagWSINFO {
    WCHAR ProtocolName[WPROTOCOLNAME_LENGTH];
    WCHAR AudioDriverName[WAUDIONAME_LENGTH];
} WSINFO, *PWSINFO;

BOOL
GetWinStationInfo(
    WSINFO* pWsInfo);

#endif /* _WIN32_WINNT >= 0x0500 */
/*
 * The handle to this structure is passed in the lParam
 * of WM_INPUT message.
 * The application can call GetRawInputData API to
 * get the detailed information, including the header
 * and all the content of the Raw Input.
 *
 * For the bulk read the RawInput in the message loop,
 * the application may call GetRawInputBuffer API.
 *
 * For the device specific information,
 * the application may call GetRawInputDeviceInfo API.
 *
 * Raw Input is available only when the application
 * calls SetRawInputDevices with valid device
 * specifications.
 */
#define RID_GETTYPE_INPUT           0x10000000
#define RID_GETTYPE_DEVICE          0x20000000
#define RID_GETTYPE_MASK            0xf0000000
#define RIDEV_ADD_OR_MODIFY     0x00000000
#define RIDEV_MODEMASK          0x00000001
#define RIDEV_INCLUDE           0x00000000
#define RIDEV_VALID             0x00000731

/*
 * vkey table counts, macros, etc. input synchonized key state tables have
 * 2 bits per vkey: fDown, fToggled. Async key state tables have 3 bits:
 * fDown, fToggled, fDownSinceLastRead.
 *
 * Important! The array gafAsyncKeyState matches the bit positions of the
 * afKeyState array in each thread info block. The fDownSinceLastRead bit
 * for the async state is stored in a separate bit array, called
 * gafAsyncKeyStateRecentDown.
 *
 * It is important that the bit positions of gafAsyncKeyState and
 * pti->afKeyState match because we copy from one to the other to maintain
 * key state synchronization between threads.
 *
 * These macros below MUST be used when setting / querying key state.
 */
#define CVKKEYSTATE                 256
#define CBKEYSTATE                  (CVKKEYSTATE >> 2)
#define CBKEYSTATERECENTDOWN        (CVKKEYSTATE >> 3)
#define KEYSTATE_TOGGLE_BYTEMASK    0xAA    // 10101010
#define KEYSTATE_DOWN_BYTEMASK      0x55    // 01010101

/*
 * Two bits per VK (down & toggle) so we can pack 4 VK keystates into 1 byte:
 *
 *              Byte 0                           Byte 1
 * .---.---.---.---.---.---.---.---. .---.---.---.---.---.---.---.---. .-- -
 * | T | D | T | D | T | D | T | D | | T | D | T | D | T | D | T | D | |
 * `---'---'---'---'---'---'---'---' `---'---'---'---'---'---'---'---' `-- -
 * : VK 3  : VK 2  : VK 1  : VK 0  : : VK 7  : VK 6  : VK 5  : VK 4  : :
 *
 * KEY_BYTE(pb, vk)   identifies the byte containing the VK's state
 * KEY_DOWN_BIT(vk)   identifies the VK's down bit within a byte
 * KEY_TOGGLE_BIT(vk) identifies the VK's toggle bit within a byte
 */
#define KEY_BYTE(pb, vk)   pb[((BYTE)(vk)) >> 2]
#define KEY_DOWN_BIT(vk)   (1 << ((((BYTE)(vk)) & 3) << 1))
#define KEY_TOGGLE_BIT(vk) (1 << (((((BYTE)(vk)) & 3) << 1) + 1))

#define TestKeyDownBit(pb, vk)     (KEY_BYTE(pb,vk) &   KEY_DOWN_BIT(vk))
#define SetKeyDownBit(pb, vk)      (KEY_BYTE(pb,vk) |=  KEY_DOWN_BIT(vk))
#define ClearKeyDownBit(pb, vk)    (KEY_BYTE(pb,vk) &= ~KEY_DOWN_BIT(vk))
#define TestKeyToggleBit(pb, vk)   (KEY_BYTE(pb,vk) &   KEY_TOGGLE_BIT(vk))
#define SetKeyToggleBit(pb, vk)    (KEY_BYTE(pb,vk) |=  KEY_TOGGLE_BIT(vk))
#define ClearKeyToggleBit(pb, vk)  (KEY_BYTE(pb,vk) &= ~KEY_TOGGLE_BIT(vk))
#define ToggleKeyToggleBit(pb, vk) (KEY_BYTE(pb,vk) ^=  KEY_TOGGLE_BIT(vk))

/*
 * Similar to the above, but here we need only one bit per VK (down)
 * so we can pack 8 VK down states into 1 byte.
 */
#define RKEY_BYTE(pb, vk) pb[((BYTE)(vk)) >> 3]
#define RKEY_BIT(vk)      (1 << ((BYTE)(vk) & 7))

#define TestKeyRecentDownBit(pb, vk)  (RKEY_BYTE(pb,vk) &   RKEY_BIT(vk))
#define SetKeyRecentDownBit(pb, vk)   (RKEY_BYTE(pb,vk) |=  RKEY_BIT(vk))
#define ClearKeyRecentDownBit(pb, vk) (RKEY_BYTE(pb,vk) &= ~RKEY_BIT(vk))

#define TestKeyStateDown(pq, vk)\
        TestKeyDownBit(pq->afKeyState, vk)
#define SetKeyStateDown(pq, vk)\
        SetKeyDownBit(pq->afKeyState, vk)
#define ClearKeyStateDown(pq, vk)\
        ClearKeyDownBit(pq->afKeyState, vk)
#define TestKeyStateToggle(pq, vk)\
        TestKeyToggleBit(pq->afKeyState, vk)
#define SetKeyStateToggle(pq, vk)\
        SetKeyToggleBit(pq->afKeyState, vk)
#define ClearKeyStateToggle(pq, vk)\
        ClearKeyToggleBit(pq->afKeyState, vk)

#define TestAsyncKeyStateDown(vk)\
        TestKeyDownBit(gafAsyncKeyState, vk)
#define SetAsyncKeyStateDown(vk)\
        SetKeyDownBit(gafAsyncKeyState, vk)
#define ClearAsyncKeyStateDown(vk)\
        ClearKeyDownBit(gafAsyncKeyState, vk)
#define TestAsyncKeyStateToggle(vk)\
        TestKeyToggleBit(gafAsyncKeyState, vk)
#define SetAsyncKeyStateToggle(vk)\
        SetKeyToggleBit(gafAsyncKeyState, vk)
#define ClearAsyncKeyStateToggle(vk)\
        ClearKeyToggleBit(gafAsyncKeyState, vk)
#define TestAsyncKeyStateRecentDown(vk)\
        TestKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)
#define SetAsyncKeyStateRecentDown(vk)\
        SetKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)
#define ClearAsyncKeyStateRecentDown(vk)\
        ClearKeyRecentDownBit(gafAsyncKeyStateRecentDown, vk)


#if(_WIN32_WINNT >= 0x0501)

#ifndef NOUSER
#ifndef NOSCROLL
#ifndef NOSYSMETRICS
#ifndef NOSYSPARAMSINFO

typedef BOOL (CALLBACK* OVERRIDEWNDPROC)(HWND, UINT, WPARAM, LPARAM, LRESULT*, void**);
typedef BOOL (CALLBACK* FORCERESETUSERAPIHOOK)(HMODULE hmod);
typedef VOID (CALLBACK* MDIREDRAWFRAMEPROC)(HWND hwndChild, BOOL fAdd);

/*
 * Flags passed to UAH DLL's indicating current status of UAH.
 *
 * UIAH_INITIALIZE   : UAH are being initialized for current process and DLL has just been loaded.
 * UIAH_UNINITIALIZE : UAH are being uninitialized for current process and DLL is about to be unloaded.
 * UIAH_UNHOOK       : UAH have been unregistered system-wide but DLL can't be unloaded due to outstanding
 *                     API calls into it.  Table of function pointers (guah) has been reset to native
 *                     user32 functions to prevent further calls.
 */
#define UIAH_INITIALIZE     0
#define UIAH_UNINITIALIZE   1
#define UIAH_UNHOOK         2

typedef struct tagMSGMASK {
    BYTE *              rgb;
    DWORD               cb;
} MSGMASK, *PMSGMASK;

typedef struct tagUSEROWPINFO {
    OVERRIDEWNDPROC     pfnBeforeOWP;
    OVERRIDEWNDPROC     pfnAfterOWP;
    MSGMASK             mm;
} USEROWPINFO, *PUSEROWPINFO;

typedef struct tagUSERAPIHOOK {
    DWORD                  cbSize;
    WNDPROC                pfnDefWindowProcA;
    WNDPROC                pfnDefWindowProcW;
    MSGMASK                mmDWP;
    GETSCROLLINFOPROC      pfnGetScrollInfo;
    SETSCROLLINFOPROC      pfnSetScrollInfo;
    ENABLESCROLLBARPROC    pfnEnableScrollBar;
    ADJUSTWINDOWRECTEXPROC pfnAdjustWindowRectEx;
    SETWINDOWRGNPROC       pfnSetWindowRgn;
    USEROWPINFO            uoiWnd;
    USEROWPINFO            uoiDlg;
    GETSYSTEMMETRICSPROC   pfnGetSystemMetrics;
    SYSTEMPARAMETERSINFO   pfnSystemParametersInfoA;
    SYSTEMPARAMETERSINFO   pfnSystemParametersInfoW;
    FORCERESETUSERAPIHOOK  pfnForceResetUserApiHook;
    DRAWFRAMECONTROLPROC   pfnDrawFrameControl;
    DRAWCAPTIONPROC        pfnDrawCaption;
    MDIREDRAWFRAMEPROC     pfnMDIRedrawFrame;
} USERAPIHOOK, *PUSERAPIHOOK;

typedef BOOL (CALLBACK* INITUSERAPIHOOK)(DWORD dwCmd, void* pvParam);


WINUSERAPI
BOOL
WINAPI
RegisterUserApiHook(
    IN HINSTANCE hmod,
    IN INITUSERAPIHOOK pfnUserApiHook);

WINUSERAPI
BOOL
WINAPI
UnregisterUserApiHook(VOID);

#endif  /*!NOSYSPARAMSINFO*/
#endif  /*!NOSYSMETRICS*/
#endif  /* NOSCROLL */


/*
 * Message Hook
 */

#ifndef NOMSG

typedef struct tagMESSAGEPUMPHOOK {
    DWORD               cbSize;
    INTERNALGETMESSAGEPROC
                        pfnInternalGetMessage;
    WAITMESSAGEEXPROC   pfnWaitMessageEx;
    GETQUEUESTATUSPROC  pfnGetQueueStatus;
    MSGWAITFORMULTIPLEOBJECTSEXPROC
                        pfnMsgWaitForMultipleObjectsEx;
} MESSAGEPUMPHOOK;

typedef BOOL (CALLBACK* INITMESSAGEPUMPHOOK)(DWORD dwCmd, void* pvParam);

WINUSERAPI
BOOL
WINAPI
RegisterMessagePumpHook(
    IN INITMESSAGEPUMPHOOK pfnInitMPH);

WINUSERAPI
BOOL
WINAPI
UnregisterMessagePumpHook();

#endif /* NOMSG */

#endif  /* NOUSER */
#endif /* _WIN32_WINNT >= 0x0501 */

#ifdef REDIRECTION
WINUSERAPI
BOOL
WINAPI
SetProcessRedirectionMode(
    IN HANDLE hProcess,
    IN BOOL bRedirectionMode);

WINUSERAPI
BOOL
WINAPI
GetProcessRedirectionMode(
    IN HANDLE hProcess,
    OUT PBOOL pbRedirectionMode);

WINUSERAPI
BOOL
WINAPI
SetDesktopRedirectionMode(
IN HANDLE hProcess,
IN BOOL bRedirectionMode);

WINUSERAPI
BOOL
WINAPI
GetDesktopRedirectionMode(
IN HANDLE hProcess,
OUT PBOOL pbRedirectionMode);
#endif // REDIRECTION

/*
 * We set this bit in GetDeviceChangeInfo to signify that the drive letter
 * represents a new drive.
 */
#define HMCE_ARRIVAL 0x80000000

/*
 * Shutdown reason code
 */
#include <reason.h>

typedef struct _REASON_INITIALISER {
    DWORD dwCode;
    DWORD dwNameId;
    DWORD dwDescId;
} REASON_INITIALISER;

typedef struct _REASON
{
    DWORD dwCode;
    WCHAR szName[MAX_REASON_NAME_LEN + 1];
    WCHAR szDesc[MAX_REASON_DESC_LEN + 1];
} REASON, *PREASON;

typedef struct _REASONDATA
{
    REASON** rgReasons;
    int cReasons;
    int cReasonCapacity;
    DWORD dwReasonSelect;
    WCHAR szComment[MAX_REASON_COMMENT_LEN + 1];
    WCHAR szBugID[MAX_REASON_BUGID_LEN + 1];
    int cCommentLen;
    int cBugIDLen;
} REASONDATA, *PREASONDATA;


BOOL ReasonCodeNeedsComment(DWORD dwCode);
BOOL ReasonCodeNeedsBugID(DWORD dwCode);
BOOL BuildReasonArray(REASONDATA *pdata, BOOL forCleanUI, BOOL forDirtyUI);
VOID DestroyReasons(REASONDATA *pdata);
BOOL GetReasonTitleFromReasonCode(DWORD code, WCHAR *title, DWORD dwTitleLen);

// Reason Titles
#define IDS_REASON_UNPLANNED_HARDWARE_MAINTENANCE_TITLE         8250
#define IDS_REASON_PLANNED_HARDWARE_MAINTENANCE_TITLE           8251
#define IDS_REASON_UNPLANNED_HARDWARE_INSTALLATION_TITLE        8252
#define IDS_REASON_PLANNED_HARDWARE_INSTALLATION_TITLE          8253

#define IDS_REASON_UNPLANNED_OPERATINGSYSTEM_UPGRADE_TITLE      8254
#define IDS_REASON_PLANNED_OPERATINGSYSTEM_UPGRADE_TITLE        8255
#define IDS_REASON_UNPLANNED_OPERATINGSYSTEM_RECONFIG_TITLE     8256
#define IDS_REASON_PLANNED_OPERATINGSYSTEM_RECONFIG_TITLE       8257

#define IDS_REASON_APPLICATION_HUNG_TITLE                       8258
#define IDS_REASON_APPLICATION_UNSTABLE_TITLE                   8259
#define IDS_REASON_APPLICATION_MAINTENANCE_TITLE                8260

#define IDS_REASON_UNPLANNED_OTHER_TITLE                        8261
#define IDS_REASON_PLANNED_OTHER_TITLE                          8262

#define IDS_REASON_SYSTEMFAILURE_BLUESCREEN_TITLE               8263
#define IDS_REASON_POWERFAILURE_CORDUNPLUGGED_TITLE             8264
#define IDS_REASON_POWERFAILURE_ENVIRONMENT_TITLE               8265
#define IDS_REASON_OTHERFAILURE_HUNG_TITLE                      8266
#define IDS_REASON_OTHERFAILURE_TITLE                           8267
#define IDS_REASON_APPLICATION_PM_TITLE                         8268

// Default reason title returned by GetReasonTitleFromReasonCode
#define IDS_REASON_DEFAULT_TITLE                                8269

// Reason Descriptions
#define IDS_REASON_HARDWARE_MAINTENANCE_DESCRIPTION             8275
#define IDS_REASON_HARDWARE_INSTALLATION_DESCRIPTION            8276

#define IDS_REASON_OPERATINGSYSTEM_UPGRADE_DESCRIPTION          8277
#define IDS_REASON_OPERATINGSYSTEM_RECONFIG_DESCRIPTION         8278

#define IDS_REASON_APPLICATION_HUNG_DESCRIPTION                 8279
#define IDS_REASON_APPLICATION_UNSTABLE_DESCRIPTION             8280
#define IDS_REASON_APPLICATION_MAINTENANCE_DESCRIPTION          8281

#define IDS_REASON_OTHER_DESCRIPTION                            8282

#define IDS_REASON_SYSTEMFAILURE_BLUESCREEN_DESCRIPTION         8283
#define IDS_REASON_POWERFAILURE_CORDUNPLUGGED_DESCRIPTION       8284
#define IDS_REASON_POWERFAILURE_ENVIRONMENT_DESCRIPTION         8285
#define IDS_REASON_OTHERFAILURE_HUNG_DESCRIPTION                8286
#define IDS_REASON_APPLICATION_PM_DESCRIPTION                   8287



#define WC_HARDERRORHANDLER "HardErrorHandler"
#define COPYDATA_HARDERROR  "HardError"

typedef struct _tagHardErrorData
{
    DWORD   dwSize;             // Size of this structure
    DWORD   dwError;            // Hard Error
    DWORD   dwFlags;            // Hard Error flags
    UINT    uOffsetTitleW;      // Offset to UNICODE Title
    UINT    uOffsetTextW;       // Offset to UNICODE Text
} HARDERRORDATA, *PHARDERRORDATA;
#ifdef __cplusplus
}
#endif  /* __cplusplus */
#endif  /* !_WINUSERP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\winfaxp.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    winfax.h

Abstract:

    This module contains the WIN32 FAX APIs.

--*/

#ifndef _FAXAPIP_
#define _FAXAPIP_

#ifdef __cplusplus
extern "C" {
#endif

#define FPF_OBSOLETE      0x00000008
#define FPF_NEW           0x00000010
#define FPF_SELECTED      0x00000020

//
// the reserved fields are private data used
// by the fax monitor and winfax.
//
//
// Reserved[0] == 0xffffffff
// Reserved[1] == Print job id
//
// Reserved[0] == 0xfffffffe   start of a broadcast job
//

typedef struct _FAX_TAPI_LOCATIONSA {
    DWORD               PermanentLocationID;
    LPCSTR              LocationName;
    DWORD               CountryCode;
    DWORD               AreaCode;
    DWORD               NumTollPrefixes;
    LPCSTR              TollPrefixes;
} FAX_TAPI_LOCATIONSA, *PFAX_TAPI_LOCATIONSA;
typedef struct _FAX_TAPI_LOCATIONSW {
    DWORD               PermanentLocationID;
    LPCWSTR             LocationName;
    DWORD               CountryCode;
    DWORD               AreaCode;
    DWORD               NumTollPrefixes;
    LPCWSTR             TollPrefixes;
} FAX_TAPI_LOCATIONSW, *PFAX_TAPI_LOCATIONSW;
#ifdef UNICODE
typedef FAX_TAPI_LOCATIONSW FAX_TAPI_LOCATIONS;
typedef PFAX_TAPI_LOCATIONSW PFAX_TAPI_LOCATIONS;
#else
typedef FAX_TAPI_LOCATIONSA FAX_TAPI_LOCATIONS;
typedef PFAX_TAPI_LOCATIONSA PFAX_TAPI_LOCATIONS;
#endif // UNICODE


typedef struct _FAX_TAPI_LOCATION_INFOA {
    DWORD                   CurrentLocationID;
    DWORD                   NumLocations;
    PFAX_TAPI_LOCATIONSA    TapiLocations;
} FAX_TAPI_LOCATION_INFOA, *PFAX_TAPI_LOCATION_INFOA;
typedef struct _FAX_TAPI_LOCATION_INFOW {
    DWORD                   CurrentLocationID;
    DWORD                   NumLocations;
    PFAX_TAPI_LOCATIONSW    TapiLocations;
} FAX_TAPI_LOCATION_INFOW, *PFAX_TAPI_LOCATION_INFOW;
#ifdef UNICODE
typedef FAX_TAPI_LOCATION_INFOW FAX_TAPI_LOCATION_INFO;
typedef PFAX_TAPI_LOCATION_INFOW PFAX_TAPI_LOCATION_INFO;
#else
typedef FAX_TAPI_LOCATION_INFOA FAX_TAPI_LOCATION_INFO;
typedef PFAX_TAPI_LOCATION_INFOA PFAX_TAPI_LOCATION_INFO;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetVersion(
    IN  HANDLE FaxHandle,
    OUT LPDWORD Version
    );

typedef BOOL
(WINAPI *PFAXGETVERSION)(
    IN  HANDLE FaxHandle,
    OUT LPDWORD Version
    );

WINFAXAPI
BOOL
WINAPI
FaxGetTapiLocationsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOA *TapiLocationInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxGetTapiLocationsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOW *TapiLocationInfo
    );
#ifdef UNICODE
#define FaxGetTapiLocations  FaxGetTapiLocationsW
#else
#define FaxGetTapiLocations  FaxGetTapiLocationsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETTAPILOCATIONSA)(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOA *TapiLocationInfo
    );
typedef BOOL
(WINAPI *PFAXGETTAPILOCATIONSW)(
    IN  HANDLE FaxHandle,
    OUT PFAX_TAPI_LOCATION_INFOW *TapiLocationInfo
    );
#ifdef UNICODE
#define PFAXGETTAPILOCATIONS  PFAXGETTAPILOCATIONSW
#else
#define PFAXGETTAPILOCATIONS  PFAXGETTAPILOCATIONSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxSetTapiLocationsA(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOA TapiLocationInfo
    );
WINFAXAPI
BOOL
WINAPI
FaxSetTapiLocationsW(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOW TapiLocationInfo
    );
#ifdef UNICODE
#define FaxSetTapiLocations  FaxSetTapiLocationsW
#else
#define FaxSetTapiLocations  FaxSetTapiLocationsA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXSETTAPILOCATIONSA)(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOA TapiLocationInfo
    );
typedef BOOL
(WINAPI *PFAXSETTAPILOCATIONSW)(
    IN  HANDLE FaxHandle,
    IN  PFAX_TAPI_LOCATION_INFOW TapiLocationInfo
    );
#ifdef UNICODE
#define PFAXSETTAPILOCATIONS  PFAXSETTAPILOCATIONSW
#else
#define PFAXSETTAPILOCATIONS  PFAXSETTAPILOCATIONSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetMapiProfilesA(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
WINFAXAPI
BOOL
WINAPI
FaxGetMapiProfilesW(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
#ifdef UNICODE
#define FaxGetMapiProfiles  FaxGetMapiProfilesW
#else
#define FaxGetMapiProfiles  FaxGetMapiProfilesA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETMAPIPROFILESA)(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
typedef BOOL
(WINAPI *PFAXGETMAPIPROFILESW)(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *MapiProfiles
    );
#ifdef UNICODE
#define PFAXGETMAPIPROFILES  PFAXGETMAPIPROFILESW
#else
#define PFAXGETMAPIPROFILES  PFAXGETMAPIPROFILESA
#endif // !UNICODE

typedef struct FaxSecurityDescriptor {
    DWORD   Id;
    LPWSTR  FriendlyName;
    LPBYTE  SecurityDescriptor;
} FAX_SECURITY_DESCRIPTOR, * PFAX_SECURITY_DESCRIPTOR;


WINFAXAPI
BOOL
WINAPI
FaxGetSecurityDescriptorCount(
    IN HANDLE FaxHandle,
    OUT LPDWORD Count
    );

WINFAXAPI
BOOL
WINAPI
FaxGetSecurityDescriptor(
    IN HANDLE FaxHandle,
    IN DWORD Id,
    OUT PFAX_SECURITY_DESCRIPTOR * FaxSecurityDescriptor
    );

WINFAXAPI
BOOL
WINAPI
FaxSetSecurityDescriptor(
    IN HANDLE FaxHandle,
    IN PFAX_SECURITY_DESCRIPTOR FaxSecurityDescriptor
    );

WINFAXAPI
BOOL
WINAPI
FaxGetInstallType(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );

typedef BOOL
(WINAPI *PFAXGETINSTALLTYPE)(
    IN  HANDLE FaxHandle,
    OUT LPDWORD InstallType,
    OUT LPDWORD InstalledPlatforms,
    OUT LPDWORD ProductType
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\wowgdip.h ===
/******************************Module*Header*******************************\
* Module Name: wowgdip.h                                                   *
*                                                                          *
* Declarations of GDI services provided to WOW.                            *
*                                                                          *
* Created: 30-Jan-1993 13:14:57                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) Microsoft Corporation. All rights reserved.                *
\**************************************************************************/

extern BOOL GdiCleanCacheDC(HDC hdcLocal);
extern int APIENTRY SetBkModeWOW(HDC hdc,int iMode);
extern int APIENTRY SetPolyFillModeWOW(HDC hdc,int iMode);
extern int APIENTRY SetROP2WOW(HDC hdc,int iMode);
extern int APIENTRY SetStretchBltModeWOW(HDC hdc,int iMode);
extern UINT APIENTRY SetTextAlignWOW(HDC hdc,UINT iMode);
extern DWORD APIENTRY GetGlyphOutlineWow( HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, CONST MAT2* );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\directui.h ===
/*
 * DirectUI main header
 */

#ifndef DUI_INC_DIRECTUI_H_INCLUDED
#define DUI_INC_DIRECTUI_H_INCLUDED

#pragma once

// External dependencies

// The following is required to build using DirectUI

/******************************************************
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers
#endif

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0500     // TODO: Remove this when updated headers are available
#endif

// Windows Header Files
#ifndef WINVER
#define WINVER 0x0500
#endif 

#include <windows.h>            // Windows
#include <windowsx.h>           // User macros

// COM Header Files
#include <objbase.h>            // CoCreateInstance, IUnknown

// C RunTime Header Files
#include <stdlib.h>             // Standard library
#include <malloc.h>             // Memory allocation
#include <wchar.h>              // Character routines
#include <process.h>            // Multi-threaded routines

// DirectUser
#define GADGET_ENABLE_TRANSITIONS
#include <duser.h>
*******************************************************/

// Base Published

#include "duierror.h"
#include "duialloc.h"
#include "duisballoc.h"
#include "duisurface.h"
#include "duiuidgen.h"
#include "duifontcache.h"
#include "duibtreelookup.h"
#include "duivaluemap.h"
#include "duidynamicarray.h"

// Util Published

#include "duiconvert.h"
#include "duiemfload.h"
#include "duigadget.h"

// Core Published

#include "duielement.h"
#include "duievent.h"
#include "duiexpression.h"
#include "duihost.h"
#include "duilayout.h"
#include "duiproxy.h"
#include "duisheet.h"
#include "duithread.h"
#include "duivalue.h"
#include "duiaccessibility.h"

// Control Published

#include "duibutton.h"
#include "duiedit.h"
#include "duicombobox.h"
#include "duinative.h"
#include "duiprogress.h"
#include "duirefpointelement.h"
#include "duirepeatbutton.h"
#include "duiscrollbar.h"
#include "duiscrollviewer.h"
#include "duiselector.h"
#include "duithumb.h"
#include "duiviewer.h"

// Layout Published

#include "duiborderlayout.h"
#include "duifilllayout.h"
#include "duiflowlayout.h"
#include "duigridlayout.h"
#include "duininegridlayout.h"
#include "duirowlayout.h"
#include "duiverticalflowlayout.h"

// Parser Published

#include "duiparserobj.h"

#endif // DUI_INC_DIRECTUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\wowuserp.h ===
/******************************Module*Header*******************************\
* Module Name: wowuserp.h                                                  *
*                                                                          *
* Declarations of USER services provided to WOW.                           *
*                                                                          *
* Created: 03-Mar-1993                                                     *
* Author: John Colleran [johnc]                                            *
*                                                                          *
* Copyright (c) Microsoft Corporation. All rights reserved.                *
\**************************************************************************/

#include "w32w64.h"

#pragma pack(1)
typedef struct _NE_MODULE_SEG {
    USHORT ns_sector;
    USHORT ns_cbseg;
    USHORT ns_flags;
    USHORT ns_minalloc;
    USHORT ns_handle;
} NEMODULESEG;
typedef struct _NE_MODULE_SEG UNALIGNED *PNEMODULESEG;
#pragma pack()


// Shared WOW32 prototypes called by USER32.
typedef HLOCAL  (WINAPI *PFNLALLOC)(UINT dwFlags, UINT dwBytes, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLREALLOC)(HLOCAL hMem, UINT dwBytes, UINT dwFlags, HANDLE hInstance, PVOID* ppv);
typedef LPVOID  (WINAPI *PFNLLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef BOOL    (WINAPI *PFNLUNLOCK)(HLOCAL hMem, HANDLE hInstance);
typedef UINT    (WINAPI *PFNLSIZE)(HLOCAL hMem, HANDLE hInstance);
typedef HLOCAL  (WINAPI *PFNLFREE)(HLOCAL hMem, HANDLE hInstance);
typedef WORD    (WINAPI *PFN16GALLOC)(UINT flags, DWORD cb);
typedef VOID    (WINAPI *PFN16GFREE)(WORD h16Mem);
typedef DWORD   (WINAPI *PFNGETMODFNAME)(HANDLE hModule, LPTSTR lpszPath, DWORD cchPath);
typedef VOID    (WINAPI *PFNEMPTYCB)(VOID);
typedef DWORD   (WINAPI *PFNGETEXPWINVER)(HANDLE hModule);
typedef HANDLE  (WINAPI *PFNFINDA)(HANDLE hModule, LPCSTR lpName,  LPCSTR lpType,  WORD wLang);
typedef HANDLE  (WINAPI *PFNFINDW)(HANDLE hModule, LPCWSTR lpName, LPCWSTR lpType, WORD wLang);
typedef HANDLE  (WINAPI *PFNLOAD)(HANDLE hModule, HANDLE hResInfo);
typedef BOOL    (WINAPI *PFNFREE)(HANDLE hResData, HANDLE hModule);
typedef LPSTR   (WINAPI *PFNLOCK)(HANDLE hResData, HANDLE hModule);
typedef BOOL    (WINAPI *PFNUNLOCK)(HANDLE hResData, HANDLE hModule);
typedef DWORD   (WINAPI *PFNSIZEOF)(HANDLE hModule, HANDLE hResInfo);
typedef DWORD   (WINAPI *PFNWOWWNDPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef BOOL    (WINAPI *PFNWOWDLGPROCEX)(HWND hwnd, UINT uMsg, WPARAM uParam, LPARAM lParam, DWORD dw, PVOID adwWOW);
typedef int     (WINAPI *PFNWOWEDITNEXTWORD)(LPSTR lpch, int ichCurrent, int cch, int code, DWORD dwProc16);
typedef VOID    (WINAPI *PFNWOWCBSTOREHANDLE)(WORD wFmt, WORD h16);
typedef WORD    (FASTCALL *PFNGETPROCMODULE16)(DWORD vpfn);
typedef VOID    (FASTCALL *PFNWOWMSGBOXINDIRECTCALLBACK)(DWORD vpfnCallback, LPHELPINFO lpHelpInfo);
typedef int     (WINAPI *PFNWOWILSTRCMP)(LPCWSTR lpString1, LPCWSTR lpString2);
typedef VOID    (FASTCALL *PFNWOWTELLWOWTHEHDLG)(HWND hDlg);
typedef DWORD	(FASTCALL *PFNWOWTASK16SCHEDNOTIFY)(DWORD NotifyParm ,DWORD dwParam);

// Shared USER32 prototypes called by WOW32
typedef HWND    (WINAPI *PFNCSCREATEWINDOWEX)(DWORD dwExStyle, LPCTSTR lpClassName,
        LPCTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HANDLE hInstance, LPVOID lpParam, DWORD Flags);
typedef VOID    (WINAPI *PFNDIRECTEDYIELD)(DWORD ThreadId);
typedef VOID    (WINAPI *PFNFREEDDEDATA)(HANDLE hDDE, BOOL fIgnorefRelease, BOOL fFreeTruelyGlobalObjects);
typedef LONG    (WINAPI *PFNGETCLASSWOWWORDS)(HINSTANCE hInstance, LPCTSTR pString);
typedef BOOL    (WINAPI *PFNINITTASK)(UINT dwExpWinVer, DWORD dwAppCompatFlags,DWORD dwUserWOWCompatFlags, LPCSTR lpszModName, LPCSTR lpszBaseFileName, DWORD hTaskWow, DWORD dwHotkey, DWORD idTask, DWORD dwX, DWORD dwY, DWORD dwXSize, DWORD dwYSize);
typedef ATOM    (WINAPI *PFNREGISTERCLASSWOWA)(PVOID lpWndClass, LPDWORD pdwWOWstuff);
typedef BOOL    (WINAPI *PFNREGISTERUSERHUNGAPPHANDLERS)(PFNW32ET pfnW32EndTask, HANDLE hEventWowExec);
typedef HWND    (WINAPI *PFNSERVERCREATEDIALOG)(HANDLE hmod, LPDLGTEMPLATE lpDlgTemplate, DWORD cb, HWND hwndOwner , DLGPROC pfnWndProc, LPARAM dwInitParam, UINT fFlags);
typedef HCURSOR (WINAPI *PFNSERVERLOADCREATECURSORICON)(HANDLE hmod, LPTSTR lpModName, DWORD dwExpWinVer, LPCTSTR lpName, DWORD cb, PVOID pcur, LPTSTR lpType, BOOL fClient);
typedef HMENU   (WINAPI *PFNSERVERLOADCREATEMENU)(HANDLE hMod, LPTSTR lpName, CONST LPMENUTEMPLATE pmt, DWORD cb, BOOL fCallClient);
typedef BOOL    (WINAPI *PFNWOWCLEANUP)(HANDLE hInstance, DWORD hTaskWow);
typedef BOOL    (WINAPI *PFNWOWMODULEUNLOAD)(HANDLE hModule);
typedef HWND    (WINAPI *PFNWOWFINDWINDOW)(LPCSTR lpClassName, LPCSTR lpWindowName);
typedef HBITMAP (WINAPI *PFNWOWLOADBITMAPA)(HINSTANCE hmod, LPCSTR lpName, LPBYTE pResData, DWORD cbResData);
typedef BOOL    (WINAPI *PFNWOWWAITFORMSGANDEVENT)(HANDLE hevent);
typedef BOOL    (WINAPI *PFNYIELDTASK)(VOID);
typedef DWORD   (WINAPI *PFNGETFULLUSERHANDLE)(WORD wHandle);
typedef DWORD   (WINAPI *PFNGETMENUINDEX)(HMENU hMenu, HMENU hSubMenu);
typedef WORD    (WINAPI *PFNWOWGETDEFWINDOWPROCBITS)(PBYTE pDefWindowProcBits, WORD cbDefWindowProcBits);
typedef VOID    (WINAPI *PFNFILLWINDOW)(HWND hwndParent, HWND hwnd, HDC hdc, HANDLE hBrush);

// other prototypes
typedef BOOL    (WINAPI *PFNWOWGLOBALFREEHOOK)(HGLOBAL hMem);


/*
 * MEASUREITEMSTRUCT itemWidth tag telling wow the itemData is a flat pointer
 */
#define MIFLAG_FLAT      0x464C4154

/*
 * WOWTask16SchedNotify NotifyParm values
 */
#define WOWSCHNOTIFY_WAIT  0x00000000
#define WOWSCHNOTIFY_RUN   0x00000001

/*
 * CallWindowProc Bits
 */
#define WOWCLASS_RPL_MASK  0x00060000  // the LDT bits that store the 2 high bits
#define WNDPROC_WOWPROC     0xC0000000  // These bits for WOW Window Procs
#define WNDPROC_WOWMASK     0x3fffffff  // To mask off wow bits
#define WNDPROC_HANDLE      0xFFFF      // HIWORD(x) == 0xFFFF for handle

// USER needs a way to distinguish between a WOW and a Win32 window proc. We
// used to achieve this by always setting the MSB of a 16:16 address as 1 (and
// storing the MSB in the Table indicator bit of the LDT which is always 1). The
// MSB of a user mode flat address was guranteed to be never 1 as the user mode
// address space was limited to 2GB. Starting with NT 5.0, user mode address
// space is being increased to 3GB. This change breaks the above assumption
// that a 32bit user mode flat address will never have the MSB as 1.
// To work around this problem, WOW is going to use the  two bits of a
// 16:16 address instead of just one. We will set both these bits as 1 because
// with 3GB address space, the user mode flat addresses cannot have 11 as the
// first two bits. To achieve this, we will save the 2 most significant bits of
// the selector in the bit 1 and bit 2. We are able to do this because for WOW
// because both these bits have fixed values.
//
// SudeepB 21-Nov-1996

#ifndef _WIN64

// MarkWOWProc
// zero out the RPL bits
// get the high two bit in position where they have to be saved
// save the high bits and mark it a wow proc

#define MarkWOWProc(vpfnProc,result)                                  \
{                                                                     \
    ULONG temp1,temp2;                                                \
    temp1 = (ULONG)vpfnProc & ~WOWCLASS_RPL_MASK;                     \
    temp2 = ((ULONG)vpfnProc & WNDPROC_WOWPROC) >> 13;                \
    (ULONG)result = temp1 | temp2 | WNDPROC_WOWPROC;                  \
}

// UnMarkWOWProc
// mask off the marker bits
// get the saved bits to right places
// restore the saved bits and set the RPL field correctly

#define UnMarkWOWProc(vpfnProc,result)                     \
{                                                          \
    ULONG temp1,temp2;                                     \
    temp1 = (ULONG)vpfnProc & WNDPROC_WOWMASK;             \
    temp2 = ((ULONG)vpfnProc & WOWCLASS_RPL_MASK) << 13;   \
    result = temp1 | temp2 | WOWCLASS_RPL_MASK;            \
}

#define IsWOWProc(vpfnProc) (((ULONG)vpfnProc & WNDPROC_WOWPROC) == WNDPROC_WOWPROC)

#else

#define MarkWOWProc(vpfnProc,result)    DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define UnMarkWOWProc(vpfnProc,result)  DBG_UNREFERENCED_PARAMETER(vpfnProc)
#define IsWOWProc(vpfnProc)             (FALSE)

#endif

/*
 * CreateWindow flags
 */
#define CW_FLAGS_ANSI       0x00000001

typedef struct tagAPFNWOWHANDLERSIN
{
    // In'ees - passed from WOW32 to USER32 and called by USER32
    PFNLALLOC                           pfnLocalAlloc;
    PFNLREALLOC                         pfnLocalReAlloc;
    PFNLLOCK                            pfnLocalLock;
    PFNLUNLOCK                          pfnLocalUnlock;
    PFNLSIZE                            pfnLocalSize;
    PFNLFREE                            pfnLocalFree;
    PFNGETEXPWINVER                     pfnGetExpWinVer;
    PFN16GALLOC                         pfn16GlobalAlloc;
    PFN16GFREE                          pfn16GlobalFree;
    PFNEMPTYCB                          pfnEmptyCB;
    PFNFINDA                            pfnFindResourceEx;
    PFNLOAD                             pfnLoadResource;
    PFNFREE                             pfnFreeResource;
    PFNLOCK                             pfnLockResource;
    PFNUNLOCK                           pfnUnlockResource;
    PFNSIZEOF                           pfnSizeofResource;
    PFNWOWWNDPROCEX                     pfnWowWndProcEx;
    PFNWOWDLGPROCEX                     pfnWowDlgProcEx;
    PFNWOWEDITNEXTWORD                  pfnWowEditNextWord;
    PFNWOWCBSTOREHANDLE                 pfnWowCBStoreHandle;
    PFNGETPROCMODULE16                  pfnGetProcModule16;
    PFNWOWMSGBOXINDIRECTCALLBACK        pfnWowMsgBoxIndirectCallback;
    PFNWOWILSTRCMP                      pfnWowIlstrsmp;
    PFNWOWTELLWOWTHEHDLG                pfnWOWTellWOWThehDlg;
    PFNWOWTASK16SCHEDNOTIFY		pfnWowTask16SchedNotify;
} PFNWOWHANDLERSIN, * APFNWOWHANDLERSIN;


typedef struct tagAPFNWOWHANDLERSOUT
{
    // Out'ees - passed from USER32 to WOW32 and called/used by WOW32
    DWORD                               dwBldInfo;
    PFNCSCREATEWINDOWEX                 pfnCsCreateWindowEx;
    PFNDIRECTEDYIELD                    pfnDirectedYield;
    PFNFREEDDEDATA                      pfnFreeDDEData;
    PFNGETCLASSWOWWORDS                 pfnGetClassWOWWords;
    PFNINITTASK                         pfnInitTask;
    PFNREGISTERCLASSWOWA                pfnRegisterClassWOWA;
    PFNREGISTERUSERHUNGAPPHANDLERS      pfnRegisterUserHungAppHandlers;
    PFNSERVERCREATEDIALOG               pfnServerCreateDialog;
    PFNSERVERLOADCREATECURSORICON       pfnServerLoadCreateCursorIcon;
    PFNSERVERLOADCREATEMENU             pfnServerLoadCreateMenu;
    PFNWOWCLEANUP                       pfnWOWCleanup;
    PFNWOWMODULEUNLOAD                  pfnWOWModuleUnload;
    PFNWOWFINDWINDOW                    pfnWOWFindWindow;
    PFNWOWLOADBITMAPA                   pfnWOWLoadBitmapA;
    PFNWOWWAITFORMSGANDEVENT            pfnWowWaitForMsgAndEvent;
    PFNYIELDTASK                        pfnYieldTask;
    PFNGETFULLUSERHANDLE                pfnGetFullUserHandle;
    PFNGETMENUINDEX                     pfnGetMenuIndex;
    PFNWOWGETDEFWINDOWPROCBITS          pfnWowGetDefWindowProcBits;
    PFNFILLWINDOW                       pfnFillWindow;
    INT *                               aiWowClass;
} PFNWOWHANDLERSOUT, * APFNWOWHANDLERSOUT;


//
// The WW structure is embedded at the end of USER's WND structure.
// However, WOW and USER use different names to access the WW
// fields. So this structure is defined as a union of two structures,
// WHICH MUST HAVE THE SAME SIZE, just different field names.
//
// Make sure that WND_CNT_WOWDWORDS matches the number of DWORDs
//  used by the WOW only fields.
//
// FindPWW(hwnd) returns a read-only pointer to this structure for
// a given window.  To change elements of this structure, use
// SETWW (== SetWindowLong) with the appropriate GWL_WOW* offset
// defined below.
//

/* WOW class/handle type identifiers (see WARNING below)
 */

#define FNID_START                  0x0000029A
#define FNID_END                    0x000002B8

#define WOWCLASS_UNKNOWN    0   // here begin our "window handle" classes
#define WOWCLASS_WIN16      1
#define WOWCLASS_BUTTON     2
#define WOWCLASS_COMBOBOX   3
#define WOWCLASS_EDIT       4
#define WOWCLASS_LISTBOX    5
#define WOWCLASS_MDICLIENT  6
#define WOWCLASS_SCROLLBAR  7
#define WOWCLASS_STATIC     8
#define WOWCLASS_DESKTOP    9
#define WOWCLASS_DIALOG     10
#define WOWCLASS_ICONTITLE  11
#define WOWCLASS_MENU       12
#define WOWCLASS_SWITCHWND  13
#define WOWCLASS_COMBOLBOX  14
#define WOWCLASS_MAX        14  // Always equal to the last value used.

#define WOWCLASS_NOTHUNK    0xFF // not an actual class index
//
// WARNING! The above sequence and values must be maintained otherwise the
// table in WMSG16.C for message thunking must be changed.  Same goes for
// table in WALIAS.C.
//


//
// When including this from USER, VPWNDPROC is undefined
//
#ifndef _WALIAS_
typedef DWORD VPWNDPROC;
typedef DWORD VPSZ;
#endif

typedef struct tagWOWCLS {
    VPSZ       vpszMenu;
    WORD       iClsExtra;   // app's value for class extra
    WORD       hMod16;
    } WC;

typedef WC UNALIGNED *PWC;

typedef struct _WW { /* ww */
    /*
     *
     * WOW/USER fields
     * NOTE: The order and size of the following 4 fields is assumed
     *       by the SetWF, ClrWF, TestWF, MaskWF macros.
     *       Specifically, state must remain the first field in this structure.
     *
     */
    DWORD         state;        // State flags
    DWORD         state2;       //
    DWORD         ExStyle;      // Extended Style
    DWORD         style;        // Style flags

    KHANDLE       hModule;      // Handle to module instance data (32-bit).
    WORD          hMod16;       // WOW only -- hMod of wndproc
    WORD          fnid;         // record window proc used by this hwnd
                        // access through GETFNID

} WW, *PWW, **PPWW;

// this is tied to WFISINITIALIZED in ntuser\inc\user.h
#define WINDOW_IS_INITIALIZED   0x80000000

ULONG_PTR UserRegisterWowHandlers(APFNWOWHANDLERSIN apfnWowIn, APFNWOWHANDLERSOUT apfnWowOut);

VOID WINAPI RegisterWowBaseHandlers(PFNWOWGLOBALFREEHOOK pfn);

BOOL
InitTask(
    UINT dwExpWinVer,
    DWORD dwAppCompatFlags,
    DWORD dwAppCompatFlagsEx,
    LPCSTR lpszModName,
    LPCSTR lpszBaseFileName,
    DWORD hTaskWow,
    DWORD dwHotkey,
    DWORD idTask,
    DWORD dwX,
    DWORD dwY,
    DWORD dwXSize,
    DWORD dwYSize);

// Following bits occupy the hiword of hTaskWow which is actually only a WORD
#define HTW_IS16BIT	0x80000000
#define HTW_ISMEOW	0x40000000

BOOL YieldTask(VOID);

#define DY_OLDYIELD     ((DWORD)-1)
VOID DirectedYield(DWORD ThreadId);
DWORD UserGetInt16State(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiaccessibility.h ===
/*
 * Accessibility support
 */

#ifndef DUI_CORE_ACCESSIBILITY_H_INCLUDED
#define DUI_CORE_ACCESSIBILITY_H_INCLUDED

#pragma once

#include <oleauto.h>
#include <oleacc.h>

#if !defined(SUPPRESS)

#define SUPPRESS(ClassName) \
private: \
ClassName(const ClassName & copy); \
ClassName & operator=(const ClassName & rhs); \
public:

#endif

namespace DirectUI
{
class Element;
class HWNDElement;
class HWNDHost;

void NotifyAccessibilityEvent(IN DWORD dwEvent, Element * pe);

class DuiAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
public:
    static HRESULT Create(Element * pe, DuiAccessible ** ppDA);
    
    SUPPRESS(DuiAccessible);

    //
    // Our IAccessible implementations can be disconnected from the actual
    // element at any time.
    //
    virtual HRESULT Disconnect();

    DuiAccessible() { }
    void Initialize(Element * pe) { _pe = pe; _cRefs = 1; }
    virtual ~DuiAccessible();

public:
    //
    // IUnknown methods
    //
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);

    //
    // IDispatch methods
    //
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    //
    // IAccessible methods
    //
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChildAtPoint);
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
    STDMETHOD(get_accChild)(VARIANT varChildIndex, IDispatch **ppdispChild);
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    STDMETHOD(get_accChildCount)(long *pChildCount);
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);
    STDMETHOD(put_accName)(VARIANT varChild, BSTR szName);
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue);
    STDMETHOD(put_accValue)(VARIANT varChild, BSTR pszValue);
    STDMETHOD(get_accDescription)(VARIANT varChild, BSTR *pszDescription);
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);
    STDMETHOD(get_accHelp)(VARIANT varChild, BSTR *pszHelp);
    STDMETHOD(get_accHelpTopic)(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
    STDMETHOD(get_accFocus)(VARIANT *pvarFocusChild);
    STDMETHOD(get_accSelection)(VARIANT *pvarSelectedChildren);
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);

    //
    // IEnumVARIANT methods
    //
    STDMETHOD(Next)(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched);
    STDMETHOD(Skip)(unsigned long celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumVARIANT ** ppenum);

    //
    // IOleWindow methods
    //
    STDMETHOD(GetWindow)(HWND * phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

protected:
    Element * GetAccessibleParent(Element * pe);
    HRESULT GetDispatchFromElement(Element * pe, IDispatch ** ppDispatch);

protected:
    Element * _pe;
    
private:
    LONG _cRefs;
};

class HWNDElementAccessible : public DuiAccessible
{
public:
    static HRESULT Create(HWNDElement * pe, DuiAccessible ** ppDA);
    SUPPRESS(HWNDElementAccessible);

    //
    // Our IAccessible implementations can be disconnected from the actual
    // element at any time.
    //
    virtual HRESULT Disconnect();

    HWNDElementAccessible() { }
    HRESULT Initialize(HWNDElement * pe);
    virtual ~HWNDElementAccessible();
    
public:
    //
    // IAccessible methods
    //
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    
private:
    IAccessible * _pParent;
};

class HWNDHostAccessible : public DuiAccessible
{
public:
    static HRESULT Create(HWNDHost * pe, DuiAccessible ** ppDA);
    SUPPRESS(HWNDHostAccessible);

    //
    // Our IAccessible implementations can be disconnected from the actual
    // element at any time.
    //
    virtual HRESULT Disconnect();

    HWNDHostAccessible() { }
    HRESULT Initialize(HWNDHost * pe);
    virtual ~HWNDHostAccessible();
    
public:
    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    
    //
    // IAccessible methods
    //
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChildAtPoint);
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
    STDMETHOD(get_accChild)(VARIANT varChildIndex, IDispatch **ppdispChild);
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    STDMETHOD(get_accChildCount)(long *pChildCount);
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);
    STDMETHOD(put_accName)(VARIANT varChild, BSTR szName);
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue);
    STDMETHOD(put_accValue)(VARIANT varChild, BSTR pszValue);
    STDMETHOD(get_accDescription)(VARIANT varChild, BSTR *pszDescription);
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);
    STDMETHOD(get_accHelp)(VARIANT varChild, BSTR *pszHelp);
    STDMETHOD(get_accHelpTopic)(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
    STDMETHOD(get_accFocus)(VARIANT *pvarFocusChild);
    STDMETHOD(get_accSelection)(VARIANT *pvarSelectedChildren);
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);

    //
    // IEnumVARIANT methods
    //
    STDMETHOD(Next)(unsigned long celt, VARIANT * rgvar, unsigned long * pceltFetched);
    STDMETHOD(Skip)(unsigned long celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumVARIANT ** ppenum);
    
    //
    // IOleWindow methods
    //
    STDMETHOD(GetWindow)(HWND * phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

private:
    IAccessible * _pCtrl;
    IEnumVARIANT * _pEnum;
    IOleWindow * _pOleWindow;
};

} // namespace DirectUI

#endif // DUI_CORE_ACCESSIBILITY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiborderlayout.h ===
/*
 * BorderLayout
 */

#ifndef DUI_BORDERLAYOUT_H_INCLUDED
#define DUI_BORDERLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// BorderLayout positions
#define BLP_Left        0
#define BLP_Top         1
#define BLP_Right       2
#define BLP_Bottom      3
#define BLP_Client      4

////////////////////////////////////////////////////////
// BorderLayout

class BorderLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual void OnAdd(Element* pec, Element** ppeAdd, UINT cCount);
    virtual void OnRemove(Element* pec, Element** ppeRemove, UINT cCount);
    virtual void OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    BorderLayout() { }
    void Initialize();
    virtual ~BorderLayout() { }

    Element* _peClientPos;
    SIZE _sizeDesired;

    SIZE GetMaxCenter(Element* pec, int x, int y, int cw, int ch, int mTop, int mLeft, int mRight, int mBottom, bool setValues, HDC hDC);
    SIZE GetMaxLeftRight(Element* pec, int current, int x, int y, int cw, int ch, int mTop, int mLeft, int mRight, int mBottom, bool setValues, HDC hDC);
    SIZE GetMaxTopBottom(Element* pec, int current, int x, int y, int cw, int ch, int mTop, int mLeft, int mRight, int mBottom, bool setValues, HDC hDC = NULL);
    int NextChild(int i, Element* pec, Element** ppeCurrent, int* playoutPos);

private:
    void SetClient(Element* pe);
};

} // namespace DirectUI

#endif // DUI_BORDERLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duialloc.h ===
/*
 * Global memory allocation
 */

#ifndef DUI_BASE_ALLOC_H_INCLUDED
#define DUI_BASE_ALLOC_H_INCLUDED

#pragma once

#include <new.h>

namespace DirectUI
{

extern HANDLE g_hHeap;

inline void* HAlloc(SIZE_T s)
{
    return HeapAlloc(g_hHeap, 0, s);
}

inline void* HAllocAndZero(SIZE_T s)
{ 
    return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, s);
}

inline void* HReAlloc(void* p, SIZE_T s)
{ 
    return HeapReAlloc(g_hHeap, 0, p, s);
}

inline void* HReAllocAndZero(void* p, SIZE_T s)
{ 
    return HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, p, s);
}

inline void HFree(void* p)
{
    HeapFree(g_hHeap, 0, p);
}

template <typename T> inline T* HNew()
{
    T* p = (T*)HAlloc(sizeof(T));
    if (p)
        new(p) T;

    return p;
}

template <typename T> inline T* HNewAndZero()
{
    T* p = (T*)HAllocAndZero(sizeof(T));
    if (p)
        new(p) T;

    return p;
}

template <typename T> inline void HDelete(T* p)
{
    p->~T();
    HFree(p);
}

} // namespace DirectUI

#endif // DUI_BASE_ALLOC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duibtreelookup.h ===
/*
 * BTreeLookup
 */

/*
 * Stores data and associated key and uses a binary search for quick lookup
 * Used if gets are much more frequent than gets
 *
 * Keys are compared as pointers. If fKeyIsWStr is true, Keys are dereferenced
 * as WCHAR* and compared
 */

#ifndef DUI_BASE_BTREELOOKUP_H_INCLUDED
#define DUI_BASE_BTREELOOKUP_H_INCLUDED

#pragma once

namespace DirectUI
{

template <typename D> class BTreeLookup
{
    typedef struct
    {
        void* pKey;
        D tData;
    } ENTRY, *PENTRY;

    typedef void (*PBTENUMCALLBACK)(void* pKey, D tData);

public:
    static HRESULT Create(bool fKeyIsWStr, OUT BTreeLookup<D>** ppBTree);
    virtual ~BTreeLookup();

    void Destroy() { HDelete< BTreeLookup<D> >(this); }

    D* GetItem(void* pKey);                  // Pointer to Value (NULL if doesn't exist, internal copy returned)
    HRESULT SetItem(void* pKey, D* ptData);  // Setup Key/Value map, creates new is doesn't exist (via indirection)
    HRESULT SetItem(void* pKey, D tData);    // Setup Key/Value map, creates new is doesn't exist
    void Remove(void* pKey);                 // Removes Key/Value map, ok if Key doesn't exist
    void Enum(PBTENUMCALLBACK pfnCallback);  // Callback with every item in map

    static int __cdecl ENTRYCompare(const void* pA, const void* pB);
    static int __cdecl WStrENTRYCompare(const void* pA, const void* pB);

    BTreeLookup() { }
    void Initialize(bool fKeyIsWStr);

private:
    UINT _uListSize;
    PENTRY _pList;
    bool _fKeyIsWStr;
};

template <typename D> HRESULT BTreeLookup<D>::Create(bool fKeyIsWStr, OUT BTreeLookup<D>** ppBTree)
{
    *ppBTree = NULL;

    // Instantiate
    BTreeLookup<D>* pbt = HNew< BTreeLookup<D> >();
    if (!pbt)
        return E_OUTOFMEMORY;

    pbt->Initialize(fKeyIsWStr);

    *ppBTree = pbt;

    return S_OK;
}

template <typename D> void BTreeLookup<D>::Initialize(bool fKeyIsWStr)
{
    _uListSize = 0;
    _pList = NULL;
    _fKeyIsWStr = fKeyIsWStr;
}

template <typename D> BTreeLookup<D>::~BTreeLookup()
{
    if (_pList)
        HFree(_pList);
}

template <typename D> D* BTreeLookup<D>::GetItem(void* pKey)
{
    DUIAssert(_fKeyIsWStr ? pKey != NULL : true, "pKey may not be NULL");

    //PENTRY pEntry = NULL;

    if (_pList)
    {
        //ENTRY eKey = { pKey }; // Create ENTRY key, populate key field
        //pEntry = (PENTRY)bsearch(&eKey, _pList, _uListSize, sizeof(ENTRY), ENTRYCompare);

        PENTRY pEntry;
        int uPv;
        int uLo = 0;
        int uHi = _uListSize - 1;
        while (uLo <= uHi)
        {
            uPv = (uHi + uLo) / 2;

            pEntry = _pList + uPv;

            // Locate
            if (!_fKeyIsWStr)
            {
                // Key is numeric
                if ((UINT_PTR)pKey == (UINT_PTR)pEntry->pKey)
                    return &(pEntry->tData);

                if ((UINT_PTR)pKey < (UINT_PTR)pEntry->pKey)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
            else
            {
                // Key is pointer to a wide string
                int cmp = _wcsicmp((LPCWSTR)pKey, (LPCWSTR)pEntry->pKey);

                if (!cmp)
                    return &(pEntry->tData);

                if (cmp < 0)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
        }
    }

    //return pEntry ? &(pEntry->tData) : NULL;
    return NULL;
}

template <typename D> HRESULT BTreeLookup<D>::SetItem(void* pKey, D tData)
{
    D* pData = GetItem(pKey);  // Find current entry (if exits)

    if (pData)
    {
        // Entry found and have pointer to data of entry
        *pData = tData;
    }
    else
    {
        // Entry not found, allocate room for new entry, store, and sort

        // New size
        UINT uNewSize = _uListSize + 1;

        if (_pList)
        {
            DUIAssert(uNewSize > 1, "Tracked list size and actual size differ");

            PENTRY pNewList = (PENTRY)HReAlloc(_pList, sizeof(ENTRY) * uNewSize);
            if (!pNewList)
                return E_OUTOFMEMORY;

            _pList = pNewList;
        }
        else
        {
            DUIAssert(uNewSize == 1, "Tracked list size and actual list size differ");

            _pList = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!_pList)
                return E_OUTOFMEMORY;
        }

        // Update size
        _uListSize = uNewSize;

        // Store
        _pList[_uListSize - 1].pKey = pKey;
        _pList[_uListSize - 1].tData = tData;

        // Sort
        qsort(_pList, _uListSize, sizeof(ENTRY), !_fKeyIsWStr ? ENTRYCompare : WStrENTRYCompare);
    }

    return S_OK;
}

template <typename D> HRESULT BTreeLookup<D>::SetItem(void* pKey, D* ptData)
{
    D* pData = GetItem(pKey);  // Find current entry (if exits)

    if (pData)
    {
        // Entry found and have pointer to data of entry
        *pData = *ptData;
    }
    else
    {
        // Entry not found, allocate room for new entry, store, and sort

        // New size
        UINT uNewSize = _uListSize + 1;

        if (_pList)
        {
            DUIAssert(uNewSize > 1, "Tracked list size and actual list size differ");

            PENTRY pNewList = (PENTRY)HReAlloc(_pList, sizeof(ENTRY) * uNewSize);
            if (!pNewList)
                return E_OUTOFMEMORY;

            _pList = pNewList;
        }
        else
        {
            DUIAssert(uNewSize == 1, "Tracked list size and actual list size differ");

            _pList = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!_pList)
                return E_OUTOFMEMORY;
        }

        // Update size
        _uListSize = uNewSize;

        // Store
        _pList[_uListSize - 1].pKey = pKey;
        _pList[_uListSize - 1].tData = *ptData;

        // Sort
        qsort(_pList, _uListSize, sizeof(ENTRY), !_fKeyIsWStr ? ENTRYCompare : WStrENTRYCompare);
    }

    return S_OK;
}

// Returns success even if key isn't found
template <typename D> void BTreeLookup<D>::Remove(void* pKey)
{
    // Validate parameters
    DUIAssert(_fKeyIsWStr ? pKey != NULL : true, "Invalid parameter: pKey == NULL");

    if (_pList)
    {
        // Search for ENTRY with key
        //ENTRY eKey = { pKey };
        //PENTRY pEntry = (PENTRY)bsearch(&eKey, _pList, _uListSize, sizeof(ENTRY), ENTRYCompare);

        PENTRY pEntry = NULL;
        int uPv;
        int uLo = 0;
        int uHi = _uListSize - 1;
        while (uLo <= uHi)
        {
            uPv = (uHi + uLo) / 2;

            pEntry = _pList + uPv;

            // Locate
            if (!_fKeyIsWStr)
            {
                // Key is numeric
                if ((UINT_PTR)pKey == (UINT_PTR)pEntry->pKey)
                    break;

                if ((UINT_PTR)pKey < (UINT_PTR)pEntry->pKey)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }
            else
            {
                // Key is pointer to a wide string
                int cmp = _wcsicmp((LPCWSTR)pKey, (LPCWSTR)pEntry->pKey);

                if (!cmp)
                    break;

                if (cmp < 0)
                    uHi = uPv - 1;
                else
                    uLo = uPv + 1;
            }

            pEntry = NULL;
        }

        if (pEntry)
        {
            UINT uIndex = (UINT)(((UINT_PTR)pEntry - (UINT_PTR)_pList) / sizeof(ENTRY));

            DUIAssert(uIndex < _uListSize, "Index out of bounds");

            // ENTRY found, move all entries after this entry down
            MoveMemory(pEntry, pEntry + 1, (_uListSize - uIndex - 1) * sizeof(ENTRY));

            // One less entry
            UINT uNewSize = _uListSize - 1;

            // Trim allocation
            if (uNewSize == 0)
            {
                HFree(_pList);
                _pList = NULL;
            }
            else
            {
                PENTRY pNewList = (PENTRY)HReAlloc(_pList, uNewSize * sizeof(ENTRY));

                // List is becoming smaller, if re-allocation failed, keep previous and continue
                if (pNewList)
                    _pList = pNewList;
            }

            // Update size
            _uListSize = uNewSize;
        }
    }
}

template <typename D> void BTreeLookup<D>::Enum(PBTENUMCALLBACK pfnCallback)
{
    if (_pList)
    {
        for (UINT i = 0; i < _uListSize; i++)
            pfnCallback(_pList[i].pKey, _pList[i].tData);
    }
}

template <typename D> int __cdecl BTreeLookup<D>::ENTRYCompare(const void* pA, const void* pB)
{
    PENTRY pEA = (PENTRY)pA;
    PENTRY pEB = (PENTRY)pB;

    if ((UINT_PTR)pEA->pKey == (UINT_PTR)pEB->pKey)
        return 0;
    else if ((UINT_PTR)pEA->pKey < (UINT_PTR)pEB->pKey)
        return -1;
    else
        return 1;
}

template <typename D> int __cdecl BTreeLookup<D>::WStrENTRYCompare(const void* pA, const void* pB)
{
    PENTRY pEA = (PENTRY)pA;
    PENTRY pEB = (PENTRY)pB;

    // Ignore case
    return _wcsicmp((LPCWSTR)pEA->pKey, (LPCWSTR)pEB->pKey);
}

} // namespace DirectUI

#endif // DUI_BASE_BTREELOOKUP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\directuipp.h ===
/*
 * DirectUI UI file pre-process header
 */

#ifndef DUI_INC_DIRECTUIPP_H_INCLUDED
#define DUI_INC_DIRECTUIPP_H_INCLUDED

/*
 * NOTE: Various system #defines are replicated here for 2 reasons:
 *    1) Preprocessing a file like winuser.h results in a huge UIPP file
 *    2) The resultant UIPP file cannot be parsed by DUI due to function prototypes
 */


/*
 * SYSMETRIC: Retrieves system dependent information (integer values)
 *
 * Can use GetSystemMetrics() SM_* values plus DirectUI-specific values
 * as argument
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// GetSystemMetrics()

#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXDLGFRAME           7
#define SM_CYDLGFRAME           8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXFRAME              32
#define SM_CYFRAME              33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43
#define SM_CXFIXEDFRAME         SM_CXDLGFRAME
#define SM_CYFIXEDFRAME         SM_CYDLGFRAME
#define SM_CXSIZEFRAME          SM_CXFRAME
#define SM_CYSIZEFRAME          SM_CYFRAME
#define SM_SECURE               44
#define SM_CXEDGE               45
#define SM_CYEDGE               46
#define SM_CXMINSPACING         47
#define SM_CYMINSPACING         48
#define SM_CXSMICON             49
#define SM_CYSMICON             50
#define SM_CYSMCAPTION          51
#define SM_CXSMSIZE             52
#define SM_CYSMSIZE             53
#define SM_CXMENUSIZE           54
#define SM_CYMENUSIZE           55
#define SM_ARRANGE              56
#define SM_CXMINIMIZED          57
#define SM_CYMINIMIZED          58
#define SM_CXMAXTRACK           59
#define SM_CYMAXTRACK           60
#define SM_CXMAXIMIZED          61
#define SM_CYMAXIMIZED          62
#define SM_NETWORK              63
#define SM_CLEANBOOT            67
#define SM_CXDRAG               68
#define SM_CYDRAG               69
#define SM_SHOWSOUNDS           70
#define SM_CXMENUCHECK          71
#define SM_CYMENUCHECK          72
#define SM_SLOWMACHINE          73
#define SM_MIDEASTENABLED       74
#define SM_MOUSEWHEELPRESENT    75
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80
#define SM_SAMEDISPLAYFORMAT    81
#define SM_CMETRICS             83

#endif // DIRECTUIPP_IGNORESYSDEF

#define DSM_NCMAX               -1
#define DSM_CAPTIONFONTSIZE     -1
#define DSM_CAPTIONFONTWEIGHT   -2
#define DSM_CAPTIONFONTSTYLE    -3
#define DSM_MENUFONTSIZE        -4
#define DSM_MENUFONTWEIGHT      -5
#define DSM_MENUFONTSTYLE       -6
#define DSM_MESSAGEFONTSIZE     -7
#define DSM_MESSAGEFONTWEIGHT   -8
#define DSM_MESSAGEFONTSTYLE    -9
#define DSM_SMCAPTIONFONTSIZE   -10
#define DSM_SMCAPTIONFONTWEIGHT -11
#define DSM_SMCAPTIONFONTSTYLE  -12
#define DSM_STATUSFONTSIZE      -13
#define DSM_STATUSFONTWEIGHT    -14
#define DSM_STATUSFONTSTYLE     -15
#define DSM_NCMIN               -15

#define DSM_ICMAX               -16
#define DSM_ICONFONTSIZE        -16
#define DSM_ICONFONTWEIGHT      -17
#define DSM_ICONFONTSTYLE       -18
#define DSM_ICMIN               -18


/*
 * SYSMETRICSTR: Retrieves system dependent information (string values)
 *
 * Can use DirectUI-specific values as argument
 */

#define DSMS_NCMIN              1
#define DSMS_CAPTIONFONTFACE    1
#define DSMS_MENUFONTFACE       2
#define DSMS_MESSAGEFONTFACE    3
#define DSMS_SMCAPTIONFONTFACE  4
#define DSMS_STATUSFONTFACE     5
#define DSMS_NCMAX              5

#define DSMS_ICMIN              6
#define DSMS_ICONFONTFACE       6
#define DSMS_ICMAX              6


#ifndef DIRECTUIPP_IGNORESYSDEF

/*
 * DrawFrameControl
 */

#define DFC_CAPTION             1
#define DFC_MENU                2
#define DFC_SCROLL              3
#define DFC_BUTTON              4
#define DFC_POPUPMENU           5

#define DFCS_CAPTIONCLOSE       0x0000
#define DFCS_CAPTIONMIN         0x0001
#define DFCS_CAPTIONMAX         0x0002
#define DFCS_CAPTIONRESTORE     0x0003
#define DFCS_CAPTIONHELP        0x0004

#define DFCS_MENUARROW          0x0000
#define DFCS_MENUCHECK          0x0001
#define DFCS_MENUBULLET         0x0002
#define DFCS_MENUARROWRIGHT     0x0004
#define DFCS_SCROLLUP           0x0000
#define DFCS_SCROLLDOWN         0x0001
#define DFCS_SCROLLLEFT         0x0002
#define DFCS_SCROLLRIGHT        0x0003
#define DFCS_SCROLLCOMBOBOX     0x0005
#define DFCS_SCROLLSIZEGRIP     0x0008
#define DFCS_SCROLLSIZEGRIPRIGHT 0x0010

#define DFCS_BUTTONCHECK        0x0000
#define DFCS_BUTTONRADIOIMAGE   0x0001
#define DFCS_BUTTONRADIOMASK    0x0002
#define DFCS_BUTTONRADIO        0x0004
#define DFCS_BUTTON3STATE       0x0008
#define DFCS_BUTTONPUSH         0x0010

#define DFCS_INACTIVE           0x0100
#define DFCS_PUSHED             0x0200
#define DFCS_CHECKED            0x0400

#define DFCS_TRANSPARENT        0x0800
#define DFCS_HOT                0x1000

#define DFCS_ADJUSTRECT         0x2000
#define DFCS_FLAT               0x4000
#define DFCS_MONO               0x8000

#endif // DIRECTUIPP_IGNORESYSDEF

/*
 * Themes Support (from TmSchema.h)
 *
 * Can't include UxTheme headers directly since they use 'enum' 
 * instead of #define. So, the preprocessor won't resolve to numbers.
 */

#ifndef DIRECTUIPP_IGNORESYSDEF

// Button parts
#define BP_PUSHBUTTON           1
#define BP_RADIOBUTTON          2
#define BP_GROUPBOX             3
#define BP_CHECKBOX             4
#define BP_USERBUTTON           5

// PushButton states
#define PBS_NORMAL              1
#define PBS_HOT                 2
#define PBS_PRESSED             3
#define PBS_DISABLED            4
#define PBS_DEFAULTED           5

// RadioButton states
#define RBS_UNCHECKEDNORMAL     1
#define RBS_UNCHECKEDHOT        2
#define RBS_UNCHECKEDPRESSED    3
#define RBS_UNCHECKEDDISABLED   4
#define RBS_CHECKEDNORMAL       5
#define RBS_CHECKEDHOT          6
#define RBS_CHECKEDPRESSED      7
#define RBS_CHECKEDDISABLED     8

// CheckBox states
#define CBS_UNCHECKEDNORMAL     1
#define CBS_UNCHECKEDHOT        2
#define CBS_UNCHECKEDPRESSED    3
#define CBS_UNCHECKEDDISABLED   4
#define CBS_CHECKEDNORMAL       5
#define CBS_CHECKEDHOT          6
#define CBS_CHECKEDPRESSED      7
#define CBS_CHECKEDDISABLED     8
#define CBS_MIXEDNORMAL         9
#define CBS_MIXEDHOT            10
#define CBS_MIXEDPRESSED        11
#define CBS_MIXEDDISABLED       12

// ScrollBar parts
#define SBP_ARROWBTN            1
#define SBP_THUMBBTNHORZ        2
#define SBP_THUMBBTNVERT        3
#define SBP_LOWERTRACKHORZ      4
#define SBP_UPPERTRACKHORZ      5
#define SBP_LOWERTRACKVERT      6
#define SBP_UPPERTRACKVERT      7
#define SBP_GRIPPERHORZ         8
#define SBP_GRIPPERVERT         9
#define SBP_SIZEBOX             10

// ArrowBtn states
#define ABS_UPNORMAL            1
#define ABS_UPHOT               2
#define ABS_UPPRESSED           3
#define ABS_UPDISABLED          4
#define ABS_DOWNNORMAL          5
#define ABS_DOWNHOT             6
#define ABS_DOWNPRESSED         7
#define ABS_DOWNDISABLED        8    
#define ABS_LEFTNORMAL          9
#define ABS_LEFTHOT             10
#define ABS_LEFTPRESSED         11
#define ABS_LEFTDISABLED        12
#define ABS_RIGHTNORMAL         13
#define ABS_RIGHTHOT            14
#define ABS_RIGHTPRESSED        15
#define ABS_RIGHTDISABLED       16

// ScrollBar states
#define SCRBS_NORMAL            1
#define SCRBS_HOT               2
#define SCRBS_PRESSED           3
#define SCRBS_DISABLED          4

// SizeBox states
#define SZB_RIGHTALIGN          1
#define SZB_LEFTALIGN           2

// Toolbar parts
#define TP_BUTTON               1
#define TP_DROPDOWNBUTTON       2
#define TP_SPLITBUTTON          3
#define TP_SPLITBUTTONDROPDOWN  4
#define TP_SEPARATOR            5
#define TP_SEPARATORVERT        6

// Toolbar states
#define TS_NORMAL               1
#define TS_HOT                  2
#define TS_PRESSED              3
#define TS_DISABLED             4
#define TS_CHECKED              5
#define TS_HOTCHECKED           6

#endif // DIRECTUIPP_IGNORESYSDEF

#endif // DUI_INC_DIRECTUIPP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duibutton.h ===
/*
 * Button
 */

#ifndef DUI_CONTROL_BUTTON_H_INCLUDED
#define DUI_CONTROL_BUTTON_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Button

// ButtonClick event
struct ButtonClickEvent : Event
{
    UINT  nCount;
    UINT  uModifiers;
    POINT pt;
};

struct ButtonContextEvent : Event
{
    UINT uModifiers;
    POINT pt;
};

// Class definition
class Button : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    // Event types
    static UID Click;
    static UID Context;

    // Property definitions
    static PropertyInfo* PressedProp;
    static PropertyInfo* CapturedProp;

    // Quick property accessors
    bool GetPressed()           DUIQuickGetter(bool, GetBool(), Pressed, Specified)
    bool GetCaptured()          DUIQuickGetter(bool, GetBool(), Captured, Specified)

    HRESULT SetPressed(bool v)  DUIQuickSetter(CreateBool(v), Pressed)
    HRESULT SetCaptured(bool v) DUIQuickSetter(CreateBool(v), Captured)
     
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // override the DefaultAction() of Element.
    virtual HRESULT DefaultAction();

    Button() { }
    HRESULT Initialize(UINT nActive);
    virtual ~Button() { }

private:
    BOOL  _bRightPressed;
};

} // namespace DirectUI

#endif // DUI_CONTROL_BUTTON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duicombobox.h ===
// Combobox.h
//

#ifndef DUI_CONTROL_COMBOBOX_H_INCLUDED
#define DUI_CONTROL_COMBOBOX_H_INCLUDED

#include "duihwndhost.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Combobox

// SelectionChange event
struct SelectionIndexChangeEvent : Event
{
    int iOld;
    int iNew;
};

// Class definition
class Combobox : public HWNDHost
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Control notifications
    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    // Sizing callback
    virtual BOOL OnAdjustWindowSize(int x, int y, UINT uFlags);

    // Rendering
    SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    int AddString(LPCWSTR lpszString);

    // Event types
    static UID SelectionChange;

    // Property definitions
    static PropertyInfo* SelectionProp;

    // Quick property accessors
    int     GetSelection()             DUIQuickGetter(int, GetInt(), Selection, Specified)

    HRESULT SetSelection(int v)        DUIQuickSetter(CreateInt(v), Selection)

    Combobox() { }
    virtual ~Combobox() { }
    HRESULT Initialize(UINT nActive) { return HWNDHost::Initialize(HHC_CacheFont | HHC_SyncText | HHC_SyncPaint, nActive); }

    virtual HWND CreateHWND(HWND hwndParent);
};

} // namespace DirectUI

#endif // DUI_CONTROL_COMBOBOX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiconvert.h ===
/*
 * Conversion
 */

#ifndef DUI_UTIL_CONVERT_H_INCLUDED
#define DUI_UTIL_CONVERT_H_INCLUDED

#pragma once

namespace DirectUI
{

#define DUIARRAYSIZE(a)    (sizeof(a) / sizeof(a[0]))

/////////////////////////////////////////////////////////////////////////////
// String conversion

#define DUI_CODEPAGE    CP_ACP  // String conversion codepage

LPSTR UnicodeToMultiByte(LPCWSTR pszUnicode, int cChars = -1, int* pMultiBytes = NULL);
LPWSTR MultiByteToUnicode(LPCSTR pszMulti, int dBytes = -1, int* pUniChars = NULL);

/////////////////////////////////////////////////////////////////////////////
// Atom conversion

ATOM StrToID(LPCWSTR psz);

/////////////////////////////////////////////////////////////////////////////
// Bitmap conversion

HBITMAP LoadDDBitmap(LPCWSTR pszBitmap, HINSTANCE hResLoad, int cx, int cy);
#ifdef GADGET_ENABLE_GDIPLUS
HRESULT LoadDDBitmap(LPCWSTR pszBitmap, HINSTANCE hResLoad, int cx, int cy, UINT nFormat, OUT Gdiplus::Bitmap** ppgpbmp);
#endif
HBITMAP ProcessAlphaBitmapI(HBITMAP hbmSource);
#ifdef GADGET_ENABLE_GDIPLUS
Gdiplus::Bitmap * ProcessAlphaBitmapF(HBITMAP hbmSource, UINT nFormat);
#endif

/////////////////////////////////////////////////////////////////////////////
// Color conversion

inline COLORREF RemoveAlpha(COLORREF cr) { return ~(255 << 24) & cr; }
inline COLORREF NearestPalColor(COLORREF cr) { return (0x02000000) | cr; }

const int SysColorEnumOffset = 10000; // Used to identify a system color enum
inline bool IsSysColorEnum(int c) { return c >= SysColorEnumOffset; }
inline int MakeSysColorEnum(int c) { return c + SysColorEnumOffset; }
inline int ConvertSysColorEnum(int c) { return c - SysColorEnumOffset; }

HBRUSH BrushFromEnumI(int c);
COLORREF ColorFromEnumI(int c);
#ifdef GADGET_ENABLE_GDIPLUS
Gdiplus::Color ColorFromEnumF(int c);
#endif

#ifdef GADGET_ENABLE_GDIPLUS

inline Gdiplus::Color RemoveAlpha(Gdiplus::Color cr)
{ 
    return Gdiplus::Color(cr.GetR(), cr.GetG(), cr.GetB());
}

inline Gdiplus::Color Convert(COLORREF cr)
{
    return Gdiplus::Color(GetAValue(cr), GetRValue(cr), GetGValue(cr), GetBValue(cr));
}

#endif

inline IsOpaque(BYTE bAlphaLevel)
{
    return bAlphaLevel >= 250;
}

inline IsTransparent(BYTE bAlphaLevel)
{
    return bAlphaLevel <= 5;
}

int PointToPixel(int nPoint);
int RelPixToPixel(int nRelPix);

inline int PointToPixel(int nPoint, int nDPI)
{
    return -MulDiv(nPoint, nDPI, 72);
}

inline int RelPixToPixel(int nRelPix, int nDPI)
{
    return MulDiv(nRelPix, nDPI, 96);
}

/////////////////////////////////////////////////////////////////////////////
// Bitmap conversion

bool IsPalette(HWND hWnd = NULL);
//HPALETTE PALToHPALETTE(LPWSTR pPALFile, bool bMemFile = false, DWORD dMemFileSize = 0, LPRGBQUAD pRGBQuad = NULL, LPWSTR pError = NULL);

} // namespace DirectUI

#endif // DUI_UTIL_CONVERT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiedit.h ===
// edit.h
//

#ifndef DUI_CONTROL_EDIT_H_INCLUDED
#define DUI_CONTROL_EDIT_H_INCLUDED

#include "duihwndhost.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Edit

// EditEnter event
struct EditEnterEvent : Event
{
};

// Class definition
class Edit : public HWNDHost
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnInput(InputEvent* pie);

    // Control notifications
    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    virtual UINT MessageCallback(GMSG* pGMsg);

    // Rendering
    SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // Event types
    static UID Enter;

    // Property definitions
    static PropertyInfo* MultilineProp;
    static PropertyInfo* PasswordCharacterProp;
    static PropertyInfo* DirtyProp;

    // Quick property accessors
    int GetPasswordCharacter()              DUIQuickGetter(int, GetInt(), PasswordCharacter, Specified)
    bool GetMultiline()                     DUIQuickGetter(bool, GetBool(), Multiline, Specified)
    bool GetDirty()                         DUIQuickGetter(bool, GetBool(), Dirty, Specified)
    

    HRESULT SetPasswordCharacter(int v)     DUIQuickSetter(CreateInt(v), PasswordCharacter)
    HRESULT SetMultiline(bool v)            DUIQuickSetter(CreateBool(v), Multiline)
    HRESULT SetDirty(bool v);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Edit() { }
    virtual ~Edit() { }
    HRESULT Initialize(UINT nActive) { return HWNDHost::Initialize(HHC_CacheFont | HHC_SyncText | HHC_SyncPaint, nActive); }

protected:

    virtual HWND CreateHWND(HWND hwndParent);
};

} // namespace DirectUI

#endif // DUI_CONTROL_EDIT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duidynamicarray.h ===
/*
 * Dynamic array
 */

#ifndef DUI_BASE_DYNAMICARRAY_H_INCLUDED
#define DUI_BASE_DYNAMICARRAY_H_INCLUDED

#pragma once

namespace DirectUI
{

//-------------------------------------------------------------------------
//
// DyanamicArray
//
// Stores values in an array the double size when it reaches capacity
//
// Compile DEBUG for bounds checking and other DUIAsserts, see public class
// declarations for API
//
// Values are stored natively. Type is chosen at compile time. For example
// (Value is type BYTE, initial capacity is 10):
//
// DynamicArray<BYTE>* pda;
// DynamicArray<BYTE>::Create(10, &pda);
//
// pda->Add(4);
// pda->Insert(0, 7);
//
// DUITrace("0: %d\n", pda->GetItem(0));  // a[0] = 7
// DUITrace("1: %d\n", pda->GetItem(1));  // a[1] = 4
//
// pda->Remove(0);
//
// DUITrace("0: %d\n", pda->GetItem(0));  // a[0] = 4
//
// The Value type must support the following operation:
//    Assignment (=)
//
//-------------------------------------------------------------------------

template <typename T> class DynamicArray
{
public:                                                // API
    static HRESULT Create(UINT uCapacity, bool fZeroData, OUT DynamicArray<T>** ppArray);
    virtual ~DynamicArray();
    void Destroy() { HDelete< DynamicArray<T> >(this); }

    // 'Ptr' methods return addesses, note that Add and Insert may cause the array
    // to be reallocated and moved in memory. Be sure not to use pointers after
    // an Add or Insert operation

    typedef int (__cdecl *QSORTCMP )(const void*, const void*);

    HRESULT Add(T tItem);                              // Insert Item at end of list (double capacity if needed)
    HRESULT AddPtr(OUT T** ppNewItem);                 // Allocate room for Item at end of list and return pointer (double capacity if needed)
    HRESULT Insert(UINT uIndex, T tItem);              // Insert Item at location (double capacity if needed)
    HRESULT InsertPtr(UINT uIndex, OUT T** pNewItem);  // Allocate room at insertion point and return pointer (double capacity if needed)
    void SetItem(UINT uIndex, T tItem);                // Overwrite Item at location
    T GetItem(UINT uIndex);                            // Get Item at location
    T* GetItemPtr(UINT uIndex);                        // Get pointer to Item at location
    UINT GetSize();                                    // Return size of array (not current capacity)
    UINT GetIndexPtr(T* pItem);                        // Return index of Item based on its pointer
    int GetIndexOf(T tItem);                           // Return index of Item
    void Remove(UINT uIndex);                          // Remove Item at location
    void Reset();                                      // Reset array to be reused (make zero size)
    bool WasMoved();                                   // May be called right after Add or Insert to determine if da was moved in memory
    HRESULT Clone(OUT DynamicArray<T>** ppClone);      // Make exact copy of array
    bool IsEqual(DynamicArray<T>* pda);                // Return true if contents are equal to da
    void Sort(QSORTCMP fpCmp);                         // Sort the array
    void MakeImmutable();                              // Write-once, make so can only do read-only operations
    void MakeWritable();                               // Make read/write

    bool fLock       : 1;

    DynamicArray() { }
    HRESULT Initialize(UINT uCapacity, bool fZeroData);

private:
    UINT _uSize;
    UINT _uCapacity;
    T* _pData;

	bool _fZeroData  : 1;                   // Zero memory for data if InsertPtr is used
    bool _fWasMoved  : 1;                   // On a reallocation (via Add or Insert), true if fLock was moved
    bool _fImmutable : 1;                   // If true, can only do read-only operations
};

template <typename T> HRESULT DynamicArray<T>::Create(UINT uCapacity, bool fZeroData, OUT DynamicArray<T>** ppArray)
{
    *ppArray = NULL;

    // Instantiate
    DynamicArray<T>* pda = HNew< DynamicArray<T> >();
    if (!pda)
        return E_OUTOFMEMORY;

    HRESULT hr = pda->Initialize(uCapacity, fZeroData);
    if (FAILED(hr))
    {
        pda->Destroy();
        return hr;
    }

    *ppArray = pda;

    return S_OK;
}

template <typename T> HRESULT DynamicArray<T>::Initialize(UINT uCapacity, bool fZeroData)
{
    _uCapacity = uCapacity;
    _uSize = 0;

    if (_uCapacity)  // Allocate only if have an initial capacity
    {
        _pData = (T*)HAlloc(sizeof(T) * _uCapacity);
        if (!_pData)
            return E_OUTOFMEMORY;
    }
    else
        _pData = NULL;

    _fZeroData = fZeroData;
    _fWasMoved = false;
    _fImmutable = false;
    fLock = false;

    return S_OK;
}

template <typename T> DynamicArray<T>::~DynamicArray()
{
    if (_pData)
        HFree(_pData);
}

// Copy data into array
template <typename T> HRESULT DynamicArray<T>::Add(T tItem)
{
    return Insert(_uSize, tItem);
}

template <typename T> HRESULT DynamicArray<T>::AddPtr(OUT T** ppNewItem)
{
    return InsertPtr(_uSize, ppNewItem);
}

template <typename T> HRESULT DynamicArray<T>::Insert(UINT uIndex, T tItem)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    _fWasMoved = false;

    DUIAssert(uIndex <= _uSize, "DynamicArray index out of bounds");

    // Resize if needed
    if (_uSize == _uCapacity)
    {
        // Double capacity of list
        UINT uNewCapacity = _uCapacity;

        if (uNewCapacity == 0)
        {
            uNewCapacity = 1;
        }
        else
        {
            uNewCapacity *= 2;
        }

        // Reallocate current fLock
        UINT_PTR pOld = (UINT_PTR)_pData;

        if (_pData)
        {
            T* pNewData = (T*)HReAlloc(_pData, sizeof(T) * uNewCapacity);
            if (!pNewData)
                return E_OUTOFMEMORY;

            _pData = pNewData;
        }
        else
        {
            _pData = (T*)HAlloc(sizeof(T) * uNewCapacity);
            if (!_pData)
                return E_OUTOFMEMORY;
        }

        // Update capacity field
        _uCapacity = uNewCapacity;

        if (pOld != (UINT_PTR)_pData)
            _fWasMoved = true;
    }

    // Shift data at index down one slot
    MoveMemory(_pData + (uIndex + 1), _pData + uIndex, (_uSize - uIndex) * sizeof(T));

    // Copy new data at insertion point
    _pData[uIndex] = tItem;

    _uSize++;

    return S_OK;
}

template <typename T> HRESULT DynamicArray<T>::InsertPtr(UINT uIndex, T** pNewItem)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    _fWasMoved = false;

    DUIAssert(uIndex <= _uSize, "DynamicArray index out of bounds");

    // Resize if needed
    if (_uSize == _uCapacity)
    {
        // Double capacity of list
        UINT uNewCapacity = _uCapacity;

        if (uNewCapacity == 0)
        {
            uNewCapacity = 1;
        }
        else
        {
            uNewCapacity *= 2;
        }

        // Reallocate current fLock
        UINT_PTR pOld = (UINT_PTR)_pData;

        if (_pData)
        {
            T* pNewData = (T*)HReAlloc(_pData, sizeof(T) * uNewCapacity);
            if (!pNewData)
                return E_OUTOFMEMORY;

            _pData = pNewData;
        }
        else
        {
            _pData = (T*)HAlloc(sizeof(T) * uNewCapacity);
            if (!_pData)
                return E_OUTOFMEMORY;
        }

        // Update capacity field
        _uCapacity = uNewCapacity;

        if (pOld != (UINT_PTR)_pData)
            _fWasMoved = true;
    }

    // Shift data at index down one slot
    MoveMemory(_pData + (uIndex + 1), _pData + uIndex, (_uSize - uIndex) * sizeof(T));

    _uSize++;

    if (_fZeroData)
        ZeroMemory(_pData + uIndex, sizeof(T));

    *pNewItem = _pData + uIndex;

    return S_OK;
}

template <typename T> void DynamicArray<T>::SetItem(UINT uIndex, T tItem)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    // Copy new data at insertion point
    _pData[uIndex] = tItem;
}

template <typename T> T DynamicArray<T>::GetItem(UINT uIndex)
{
    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    return _pData[uIndex];
}

template <typename T> T* DynamicArray<T>::GetItemPtr(UINT uIndex)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    return _pData + uIndex;
}

template <typename T> UINT DynamicArray<T>::GetIndexPtr(T* pItem)
{
    DUIAssert((((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T)) >= 0 && (((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T)) < _uSize, "GetIndexPtr out of bounds");
    return (UINT)(((UINT_PTR)pItem - (UINT_PTR)_pData) / sizeof(T));
}

template <typename T> int DynamicArray<T>::GetIndexOf(T tItem)
{
    for (UINT i = 0; i < _uSize; i++)
    {
        if (_pData[i] == tItem)
            return i;
    }

    return -1;
}

template <typename T> UINT DynamicArray<T>::GetSize()
{
    return _uSize;
}

template <typename T> void DynamicArray<T>::Remove(UINT uIndex)
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    DUIAssert(uIndex < _uSize, "DynamicArray index out of bounds");

    // Shift memory
    MoveMemory(_pData + uIndex, _pData + (uIndex + 1), (_uSize - uIndex - 1) * sizeof(T));

    _uSize--;
}

template <typename T> void DynamicArray<T>::Reset()
{
    DUIAssert(!_fImmutable, "Only read operations allowed on immutable DynamicArray");

    _uSize = 0;
    _fWasMoved = false;
    fLock = false;
}

template <typename T> bool DynamicArray<T>::WasMoved()
{
    return _fWasMoved;
}

template <typename T> HRESULT DynamicArray<T>::Clone(OUT DynamicArray<T>** ppClone)  // New instance returned
{
    // Validate parameters
    DUIAssert(ppClone, "Invalid parameter: ppClone == NULL");

    *ppClone = NULL;

    DynamicArray<T>* pda = HNew< DynamicArray<T> >();
    if (!pda)
        return E_OUTOFMEMORY;

    pda->_uSize = _uSize;
    pda->_uCapacity = _uCapacity;
    pda->_fZeroData = _fZeroData;
    pda->_fWasMoved = _fWasMoved;
    pda->_fImmutable = false;
    pda->_pData = NULL;

    if (_pData)
    {
        pda->_pData = (T*)HAlloc(sizeof(T) * _uCapacity);
        if (!pda->_pData)
        {
            pda->Destroy();
            return E_OUTOFMEMORY;
        }

        CopyMemory(pda->_pData, _pData, sizeof(T) * _uSize);
    }

    *ppClone = pda;

    return S_OK;
}

template <typename T> bool DynamicArray<T>::IsEqual(DynamicArray<T>* pda)
{
    if (!pda)
        return false;

    if (_uSize != pda->_uSize)
        return false;

    DUIAssert(!((_pData && !pda->_pData) || (!_pData && pda->_pData)), "Invalid comparison");

    if (_pData && memcmp(_pData, pda->_pData, sizeof(T) * _uSize) != 0)
        return false;

    return true;
}

template <typename T> void DynamicArray<T>::Sort(QSORTCMP fpCmp)
{
    if (_uSize)
    {
        qsort(_pData, _uSize, sizeof(T), fpCmp);
    }
}

template <typename T> void DynamicArray<T>::MakeImmutable()
{
#if DBG
    _fImmutable = true;
#endif
}

template <typename T> void DynamicArray<T>::MakeWritable()
{
#if DBG
    _fImmutable = false;
#endif
}

} // namespace DirectUI

#endif // DUI_BASE_DYNAMICARRAY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duievent.h ===
/*
 * Event
 */

#ifndef DUI_CORE_EVENT_H_INCLUDED
#define DUI_CORE_EVENT_H_INCLUDED

#pragma once

namespace DirectUI
{

class Element;

////////////////////////////////////////////////////////
// Generic event structures

// Eventing system is based on DU's messaging system
// All DUI events are packaged into a DU message

#define GM_DUIEVENT     GM_USER - 2

struct Event
{
    // TODO: cbSize
    Element* peTarget;
    UID uidType;
    bool fHandled;
    UINT nStage;
};

BEGIN_STRUCT(GMSG_DUIEVENT, EventMsg)
    Event* pEvent;
END_STRUCT(GMSG_DUIEVENT)

////////////////////////////////////////////////////////
// System event structures

////////////////////////////////////////////////////////
// Input event type

struct InputEvent
{
    Element* peTarget;
    bool fHandled;
    UINT nStage;
    UINT nDevice;
    UINT nCode;
    UINT uModifiers;
};

// Input event GINPUT_MOUSE nCode extra fields
struct MouseEvent : InputEvent
{
    POINT ptClientPxl;
    BYTE bButton;
    UINT nFlags;
};

struct MouseDragEvent: MouseEvent
{
    SIZE  sizeDelta;
    BOOL  fWithin;
};

struct MouseClickEvent: MouseEvent
{
    UINT cClicks;
};

struct MouseWheelEvent: MouseEvent
{
    short sWheel;
};

// Input event GINPUT_KEYBOARD nCode extra fields
struct KeyboardEvent : InputEvent
{
    WCHAR ch;
    WORD cRep;
    WORD wFlags;
};

////////////////////////////////////////////////////////
// Action event type

// TODO


struct KeyboardNavigateEvent : Event
{
    int iNavDir;
};


////////////////////////////////////////////////////////
// DUI Element query message

// Eventing system is based on DU's messaging system
// All DUI events are packaged into a DU message

#define GM_DUIGETELEMENT   GM_USER - 3

BEGIN_STRUCT(GMSG_DUIGETELEMENT, EventMsg)
    Element* pe;
END_STRUCT(GMSG_DUIGETELEMENT)


////////////////////////////////////////////////////////
// DUI Accessibility default action

// Accessibility default actions are always async

#define GM_DUIACCDEFACTION  GM_USER - 4

} // namespace DirectUI

#endif // DUI_CORE_EVENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiemfload.h ===
/*
 * Metafile converter/loader
 */

#ifndef DUI_UTIL_EMFLOAD_H_INCLUDED
#define DUI_UTIL_EMFLOAD_H_INCLUDED

#pragma once

namespace DirectUI
{

#define HIMETRICINCH    2540
#define APM_SIGNATURE   0x9AC6CDD7

// Metafile Pagemaker structures
#ifndef RC_INVOKED
#pragma pack(2)
typedef struct tagRECTS
{
    short left;
    short top;
    short right;
    short bottom;
} RECTS, *PRECTS;

typedef struct tagAPMFILEHEADER
{
    DWORD key;
    WORD  hmf;
    RECTS bbox;
    WORD  inch;
    DWORD reserved;
    WORD  checksum;
} APMFILEHEADER, *PAPMFILEHEADER;
#pragma pack()
#endif

HENHMETAFILE LoadMetaFile(LPCWSTR pszMetaFile);
HENHMETAFILE LoadMetaFile(UINT uRCID, HINSTANCE hInst);
HENHMETAFILE LoadMetaFile(void* pData, UINT cbSize);

} // namespace DirectUI

#endif // DUI_UTIL_EMFLOAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duierror.h ===
/*
 * Error checking support methods
 */

#ifndef DUI_BASE_ERROR_H_INCLUDED
#define DUI_BASE_ERROR_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// DirectUser debugging services

#define QUOTE(s) #s
#define STRINGIZE(s) QUOTE(s)
#define _countof(x) (sizeof(x) / sizeof(x[0]))

DECLARE_INTERFACE(IDebug)
{
    STDMETHOD_(BOOL, AssertFailedLine)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum) PURE;
    STDMETHOD_(BOOL, IsValidAddress)(THIS_ const void * lp, UINT nBytes, BOOL bReadWrite) PURE;
    STDMETHOD_(void, BuildStack)(THIS_ HGLOBAL * phStackData, UINT * pcCSEntries) PURE;
    STDMETHOD_(BOOL, Prompt)(THIS_ LPCSTR pszExpression, LPCSTR pszFileName, UINT idxLineNum, LPCSTR pszTitle) PURE;
};

EXTERN_C DUSER_API IDebug* WINAPI GetDebug();
EXTERN_C DUSER_API void _cdecl AutoTrace(const char* pszFormat, ...);

#define IDebug_AssertFailedLine(p, a, b, c)         (p ? (p)->AssertFailedLine(a, b, c) : false)
#define IDebug_IsValidAddress(p, a, b, c)           (p ? (p)->IsValidAddress(a, b, c) : false)
#define IDebug_BuildStack(p, a, b)                  (p ? (p)->BuildStack(a, b) : false)
#define IDebug_Prompt(p, a, b, c, d)                (p ? (p)->Prompt(a, b, c, d) : false)

// Define AutoDebugBreak

#ifndef AutoDebugBreak
#define AutoDebugBreak() ForceDebugBreak()
#endif

////////////////////////////////////////////////////////
// DirectUI debugging macros

#if DBG

#define DUIAssert(f, comment) \
    { \
        if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    }

#define DUIAssertNoMsg(f) \
    { \
        if (!((f)) && IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)), __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    } 

#define DUIAssertForce(comment) \
    { \
        if (IDebug_AssertFailedLine(GetDebug(), STRINGIZE((f)) "\r\n" comment, __FILE__, __LINE__)) \
            AutoDebugBreak(); \
    }

#define DUIPrompt(comment, prompt) \
    { \
        if (IDebug_Prompt(GetDebug(), comment, __FILE__, __LINE__, prompt)) \
            AutoDebugBreak(); \
    } 

#define DUIVerifyNoMsg(f)               DUIAssertNoMsg((f))

#define DUIVerify(f, comment)           DUIAssert((f), comment)

#define DUITrace                        AutoTrace

#else

#define DUIAssertNoMsg(f)               ((void)0)
#define DUIAssert(f, comment)           ((void)0)
#define DUIAssertForce(comment)         ((void)0)

#define DUIPrompt(comment, prompt)      ((void)0)

#define DUIVerifyNoMsg(f)               ((void)(f))
#define DUIVerify(f, comment)           ((void)(f, comment))

#define DUITrace                        1 ? (void) 0 : AutoTrace

#endif

////////////////////////////////////////////////////////
// Error codes

// If any DUI API can fail to an abnormal program event, the API's return value
// is always HRESULT. Any API that isn't part of this category either returns
// void or any other data type
//
// All erroneous program events (internal invalid state or invalid parameters)
// are handled by asserts

#define DUI_E_USERFAILURE               MAKE_DUERROR(1001)
#define DUI_E_NODEFERTABLE              MAKE_DUERROR(1002)
#define DUI_E_PARTIAL                   MAKE_DUERROR(1003)

////////////////////////////////////////////////////////
// Profiling support

#ifdef PROFILING

void ICProfileOn();
void ICProfileOff();

#define ProfileOn()    ICProfileOn()
#define ProfileOff()   ICProfileOff()
#else
#define ProfileOn()
#define ProfileOff()

#endif

////////////////////////////////////////////////////////
// Quick profiling

#define StartBlockTimer()  __int64 _dFreq, _dStart, _dStop; \
                           QueryPerformanceFrequency((LARGE_INTEGER*)&_dFreq); \
                           QueryPerformanceCounter((LARGE_INTEGER*)&_dStart)

#define StopBlockTimer()   QueryPerformanceCounter((LARGE_INTEGER*)&_dStop)

#define BlockTime()        (((_dStop - _dStart) * 1000) / _dFreq)


void ForceDebugBreak();

} // namespace DirectUI

#endif // DUI_BASE_ERROR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duielement.h ===
/*
 * Element
 */

#ifndef DUI_CORE_ELEMENT_H_INCLUDED
#define DUI_CORE_ELEMENT_H_INCLUDED

#pragma once

#include "duivalue.h"
#include "duievent.h"
#include "duisheet.h"
#include "duilayout.h"

struct IAccessible;

namespace DirectUI
{

#if DBG
extern UINT g_cGetDep;
extern UINT g_cGetVal;
extern UINT g_cOnPropChg;
#endif

class DuiAccessible;

// TODO: Switch DUI listeners to use DirectUser MessageHandlers

/*
 * Element Properties
 *
 * Element provides default behavior for Get/SetValue based on the flags used in PropertyInfo.
 * The Flags also define what indicies are available during property operations.
 *
 * Get/SetValue cannot be overridden. Rather, a default implemention is supplied for GetValue's
 * on all properties. By default, Get's on the Specified and Computed index are handled by a
 * built-in Value Expression (VE) while Get's on Local query a local store (see below for exact
 * default behavior). However, various system properties override this default behavior with
 * different unchangable Value Expressions (implicit VEs) in the Local and Computed indicies.
 *
 * End users will use Normal properties and may occasionally use LocalOnly properties. Although
 * available to derived classes, TriLevel property functionaly is only useful by the system.
 *
 * All property value must be available generically through GetValue.
 *
 * Flags supported (default behavior):
 * 
 * "LocalOnly"
 *   Indicies: Local
 *        Get: Retrieve local value from Element. If none is set, 'Unset' returned.
 *        Set: Stores value locally on the Element. 
 * Dependents: None
 *  Modifiers: Readonly: Disallow Set
 *
 * "Normal"
 *   Indicies: Local, Specified (implicit VE)
 *        Get:     Local: Retrieve local value from Element. If none is set, 'Unset' returned.
 *             Specified: Does a Get on the Local value. If 'Unset', return Property Sheet value
 *                        if Cascade modifier is set. If 'Unset', return parent's value if Inherit
 *                        modifier is set. If 'Unset' return property's Default value. 
 *                        Automatically evaulate value expressions before return.
 *        Set:     Local: Stores value locally on the Element.
 *             Specified: Unsupported.
 * Dependents: Specified is dependent on Local.
 *  Modifiers: Readonly: Disallow Set for Local.
 *              Cascade: Used with Specified Get (see Get description).
 *              Inherit: Used with Specified Get (see Get description).
 *
 * "TriLevel"
 *   Indicies: Local, Specified (implicit VE), Computed (implicit VE)
 *        Get:     Local: Retrieve local value from Element. If none is set, 'Unset' returned.
 *             Specified: Does a Get on the Local value. If 'Unset', return Property Sheet value
 *                        if Cascade modifier is set. If 'Unset', return parent's value if Inherit
 *                        modifier is set. If 'Unset' return property's Default value. 
 *                        Automatically evaulate value expressions before return.
 *              Computed: Does a get of the Specified value.
 *        Set:     Local: Stores value locally on the Element.
 *             Specified: Unsupported.
 *              Computed: Unsupported.
 * Dependents: Computed is dependent on Specified. Specified is dependent on Local.
 *  Modifiers: Readonly: Disallow Set for Local.
 *              Cascade: Used with Specified Get (see Get description).
 *              Inherit: Used with Specified Get (see Get description).
 *
 * SetValue must always be used by derived classes. However, SetValue is sometimes bypassed and
 * Pre/PostSourceChange is called directly in the case of LocalOnly properties that are ReadOnly
 * and are cached directly on the Element (optimization). All other ReadOnly sets use
 * _SetValue since generic storage (of Values) is used. SetValue is used in all other cases.
 *
 * For ReadOnly values, if storing the value is cheap (i.e. bools) and interit and style sheet
 * functionality is not required, it is best to not use generic storage (_SetValue). Rather,
 * write the value directly and call Pre/PostSourceChange directly ("LocalOnly property). 
 * Otherwise, if a ReadOnly value requires inheritance and/or sheet lookups, or the value is
 * seldom different than a default value, use _SetValue (generic storage, "Normal" property).
 *
 * For Normal/ReadOnly, use SetValue, For LocalOnly/ReadOnly, use _SetValue,
 * For internal LocalOnly/ReadOnly, set and store manually (no generic storage)
 *
 * All property values must be settable generically via SetValue except ReadOnly properties.
 * Any "LocalOnly" property that doesn't use generic storage must initialize their members
 * at construction to the property's default value. "Normal" properties will choose the
 * default value automatically when queried. All derived classes (external) will use "Normal"
 * properties.
 *
 * SetValue only accepts the PI_Local index. ReadOnly sets do not fire OnPropertyChanging.
 * All value sets must result in a PreSourceChange, followed by the store update (in which GetValue
 * will retrieve values from), followed by a PostSourceChange. OnPropertyChange and old value
 * compare are optional.
 *
 * Set values are updated immediately (i.e. an immediate GetValue after will produce the updated
 * result). Location and Extent are updated after the defer cycle ends (EndDefer, SetValues are internal).
 */

/*
 * Element Multithreading
 *
 * Elements have context affinity. A single thread is allowed per context. This thread
 * is owned by the context. Only that thread may be allowed to access objects in its
 * context. This requirement is not enforced in this library. The caller application
 * must ensure access to objects in a context happens via the owned thread.
 *
 * A Proxy class is provided to invoke methods on objects from an out-of-context thread.
 *
 * The library supports multiple instances in the same process. This would happen by
 * linking the library to multiple process modules. The only restriction is a thread
 * must access a set of objects consistantly with the same instance of the library code.
 *
 */

/*
 * Error Reporting
 *
 * Conditions that would affect the stability of DirectUI are reported. Some conditions are
 * only reported in Debug builds, and other in both Release and Debug
 *
 *  Debug time reporting:
 *   Erroneous states are reported in Debug (checked) builds. An erroneous state arises
 *   when a programming error is found or when invalid arguments are passed to a method.
 *   Erroneous states cause raising of asserts
 *
 *  Release time reporting:
 *   Abnormal states (such as out of memory or resources) that result in a serious condition
 *   (crash or very irregular state) are reported via HRESULTs. Any DUI API that can fail due to
 *   these types of abnormal states returns an HRESULT. If a method fails, it will recover.
 *   Some methods (such as object creation methods) will recover by freeing any memory or
 *   resources allocated within that method (resulting of a complete undo of all the work it
 *   accomplished up to the point of the failure). Other methods (such as rendering and the defer 
 *   cycle) will do as much work as possible. Upon a failure, they will return an 'incomplete'
 *   error, however, they would have not completed. Failures do not result in crashes or irregular
 *   state. Failures are ignored in callbacks
 */

typedef int (__cdecl *CompareCallback)(const void*, const void*);

// Property indicies
#define PI_Local        1
#define PI_Specified    2
#define PI_Computed     3

// Property flags
#define PF_LocalOnly    0x01
#define PF_Normal       0x02
#define PF_TriLevel     0x03
#define PF_Cascade      0x04
#define PF_Inherit      0x08
#define PF_ReadOnly     0x10

#define PF_TypeBits     0x03  // Map out for LocalOnly, Normal, or Trilevel

// For use in OnPropertyChanged, mask out non-retrieval index property changes
#define IsProp(p)       ((p##Prop == ppi) && ((ppi->fFlags&PF_TypeBits) == iIndex))
#define RetIdx(p)       (p->fFlags&PF_TypeBits)
    
// Property groups
#define PG_AffectsDesiredSize         0x00000001    // Normal priority
#define PG_AffectsParentDesiredSize   0x00000002
#define PG_AffectsLayout              0x00000004
#define PG_AffectsParentLayout        0x00000008
#define PG_AffectsBounds              0x00010000    // Low priority
#define PG_AffectsDisplay             0x00020000

#define PG_NormalPriMask              0x0000FFFF
#define PG_LowPriMask                 0xFFFF0000

// Layout cycle queue modes
#define LC_Pass         0
#define LC_Normal       1
#define LC_Optimize     2

// todo: get these from accessibility
#define GA_NOTHANDLED     ((Element*) -1)

// to be internal
#define NAV_LOGICAL    0x00000001 // unset == directional
#define NAV_FORWARD    0x00000002 // unset == backward
#define NAV_VERTICAL   0x00000004 // unset == horizontal
#define NAV_RELATIVE   0x00000008 // unset == absolute

// to be exposed
#define NAV_FIRST      (NAV_FORWARD | NAV_LOGICAL)
#define NAV_LAST       (NAV_LOGICAL)
#define NAV_UP         (NAV_RELATIVE | NAV_VERTICAL)
#define NAV_DOWN       (NAV_RELATIVE | NAV_VERTICAL | NAV_FORWARD)
#define NAV_LEFT       (NAV_RELATIVE)
#define NAV_RIGHT      (NAV_RELATIVE | NAV_FORWARD)
#define NAV_NEXT       (NAV_RELATIVE | NAV_FORWARD | NAV_LOGICAL)
#define NAV_PREV       (NAV_RELATIVE | NAV_LOGICAL)

// to be exposed
#define DIRECTION_LTR     0
#define DIRECTION_RTL     1

// Asynchronous destroy message (must be async to ensure outstanding
// defer pointers are cleared)
#define GM_DUIASYNCDESTROY            GM_USER - 1


////////////////////////////////////////////////////////
// PropertyInfo

struct IClassInfo;

struct EnumMap
{
    LPCWSTR pszEnum;
    int nEnum;
};

struct PropertyInfo
{
    WCHAR szName[81];
    int fFlags;
    int fGroups;
    int* pValidValues;
    EnumMap* pEnumMaps;
    Value* pvDefault;
    int _iIndex;           // Class-wide unique id (zero-based consecutive, set by ClassInfo)
    int _iGlobalIndex;     // Process-wide unique id (zero-based consecutive, set by ClassInfo (manually set for Element))
    IClassInfo* _pciOwner; // Class that this property is defined on (direct owner, not inherited-by)
};

class Element;

////////////////////////////////////////////////////////
// UpdateCache

struct UpdateCache
{
    Element* peSrc;
    PropertyInfo* ppiSrc;
    int iIndexSrc;
    Value* pvOldSrc;
    Value* pvNewSrc;
};

////////////////////////////////////////////////////////
// Dependencies

struct Dependency
{
    Element* pe;
    PropertyInfo* ppi;
    int iIndex;
};

// Track dependency records in PC list
struct DepRecs
{
    int iDepPos;
    int cDepCnt;
};

struct NavReference
{
    void Init(Element* pe, RECT* prc);

    UINT     cbSize;
    Element* pe;
    RECT*    prc;
};

////////////////////////////////////////////////////////
// Class information interface

// Used so that a class will not be linked out if a class is not referred to
// (and is only referred by the parser)
#define UsingDUIClass(classn) static IClassInfo* _DUI__pCI##classn = ##classn::Class

struct IClassInfo
{
    virtual HRESULT CreateInstance(OUT Element** ppElement) = 0;
    virtual PropertyInfo* EnumPropertyInfo(UINT nEnum) = 0;  // Includes base classes
    virtual UINT GetPICount() = 0;                           // Includes base classes
    virtual UINT GetGlobalIndex() = 0;
    virtual IClassInfo* GetBaseClass() = 0;
    virtual LPCWSTR GetName() = 0;
    virtual bool IsValidProperty(PropertyInfo* ppi) = 0;
    virtual bool IsSubclassOf(IClassInfo* pci) = 0;
    virtual void Destroy() = 0;
};

////////////////////////////////////////////////////////
// Element Listener interface
struct IElementListener
{
    virtual void OnListenerAttach(Element* peFrom) = 0;
    virtual void OnListenerDetach(Element* peFrom) = 0;
    virtual bool OnListenedPropertyChanging(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew) = 0;
    virtual void OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew) = 0;
    virtual void OnListenedInput(Element* peFrom, InputEvent* pInput) = 0;
    virtual void OnListenedEvent(Element* peFrom, Event* pEvent) = 0;
};

#if DBG
////////////////////////////////////////////////////////
// Track "owner" context of this instance to validation that threads that don't
// belong to the context don't access the object.
//
// For side-by-side library support, also store the TLS slot of the instance
// of the library in the process that created this object. This will ensure the 
// thread is using the correct library instance to access the object. 

struct Owner
{
    HDCONTEXT hCtx;
    DWORD dwTLSSlot;
};
#endif

////////////////////////////////////////////////////////
// Element

typedef DynamicArray<Element*> ElementList;
class DeferCycle;
struct PCRecord;

#define EC_NoGadgetCreate       0x1  // Do not create DisplayNode, must be created within constructor override
#define EC_SelfLayout           0x2  // Element will lay out children (via self layout callbacks)

class Element
{
public:

    ////////////////////////////////////////////////////////
    // Construction / destruction

    static HRESULT Create(UINT nCreate, OUT Element** ppe);
    HRESULT Destroy(bool fDelayed = true);  // Destroy self
    HRESULT DestroyAll();                   // Destroy all children

    Element() { }
    virtual ~Element();
    HRESULT Initialize(UINT nCreate);

    ////////////////////////////////////////////////////////
    // Properties (impl in property.cpp)

    // Accessors
    Value* GetValue(PropertyInfo* ppi, int iIndex, UpdateCache* puc = NULL);
    HRESULT SetValue(PropertyInfo* ppi, int iIndex, Value* pv);

    // Additional property methods
    HRESULT RemoveLocalValue(PropertyInfo* ppi);

    // Deferring
    static void StartDefer();
    static void EndDefer();

    // Checks
    inline bool IsValidAccessor(PropertyInfo* ppi, int iIndex, bool bSetting);
    static bool IsValidValue(PropertyInfo* ppi, Value* pv);
    bool IsRTL() { return (GetDirection() == DIRECTION_RTL);}

    // System event callbacks
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);  // Direct
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);   // Direct
    virtual void OnGroupChanged(int fGroups, bool bLowPri);                                      // Direct
    virtual void OnInput(InputEvent* pInput);                                                    // Direct and bubbled
    virtual void OnKeyFocusMoved(Element* peFrom, Element* peTo);                                // Direct and bubbled
    virtual void OnMouseFocusMoved(Element* peFrom, Element* peTo);                              // Direct and bubbled
    virtual void OnDestroy();                                                                    // Direct
    // ContainerCleanup: OnLoadedFromResource(dictionary)
 
    // Generic eventing and callback (pointer is only guaranteed good for the lifetime of the call)
    void FireEvent(Event* pEvent, bool fFull = true);
    virtual void OnEvent(Event* pEvent);

    // Rendering callbacks
    virtual void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);
#ifdef GADGET_ENABLE_GDIPLUS
    virtual void Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prSkipBorder, Gdiplus::RectF* prSkipContent);
#endif
    virtual SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);
    float GetTreeAlphaLevel();

    // Hierarchy
    HRESULT Add(Element* pe);
    virtual HRESULT Add(Element** ppe, UINT cCount);
    HRESULT Insert(Element* pe, UINT iInsertIdx);
    virtual HRESULT Insert(Element** ppe, UINT cCount, UINT iInsertIdx);

    HRESULT Add(Element* pe, CompareCallback lpfnCompare);
    HRESULT SortChildren(CompareCallback lpfnCompare);

    HRESULT Remove(Element* peFrom);
    HRESULT RemoveAll();
    virtual HRESULT Remove(Element** ppe, UINT cCount);

    // Mapping and navigation
    Element* FindDescendent(ATOM atomID);
    void MapElementPoint(Element* peFrom, const POINT* pptFrom, POINT* pptTo);
    Element* GetImmediateChild(Element* peFrom);
    bool IsDescendent(Element* pe);
    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);
    Element* GetKeyWithinChild();
    Element* GetMouseWithinChild();
    bool EnsureVisible();
    bool EnsureVisible(UINT uChild);
    virtual bool EnsureVisible(int x, int y, int cx, int cy);
    virtual void SetKeyFocus();

    // Element Listeners
    HRESULT AddListener(IElementListener* pel);
    void RemoveListener(IElementListener* pel);

    // Effects, animate display node to match current Element state
    void InvokeAnimation(int dAni, UINT nTypeMask);
    void InvokeAnimation(UINT nTypes, UINT nInterpol, float flDuration, float flDelay, bool fPushToChildren = false);
    void StopAnimation(UINT nTypes);

    // Display node callback extension
    virtual UINT MessageCallback(GMSG* pGMsg);

    // Internal defer cycle and Layout-only callbacks 
    SIZE _UpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);
    void _UpdateLayoutPosition(int dX, int dY);
    void _UpdateLayoutSize(int dWidth, int dHeight);

    // Use in DoLayout on children where one or more properties will be changed which will
    // cause a Layout GPC to be queued. This will cancel the layout GPCs and force the child
    // to be included in the current layout cycle
    void _StartOptimizedLayoutQ() { DUIAssertNoMsg(_fBit.fNeedsLayout != LC_Optimize); _fBit.fNeedsLayout = LC_Optimize; }
    void _EndOptimizedLayoutQ() { _fBit.fNeedsLayout = LC_Normal; }

    // Internal defer cycle and PropertySheet-only callbacks
    static void _AddDependency(Element* pe, PropertyInfo* ppi, int iIndex, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr);

    // Internal DirectUser interop
    static HRESULT CALLBACK _DisplayNodeCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg);

    // Internal IUnknown interface impl
    long __stdcall QueryInterface(REFIID iid, void** pvObj) { UNREFERENCED_PARAMETER(iid); UNREFERENCED_PARAMETER(pvObj); return E_NOTIMPL; }
    ULONG __stdcall AddRef() { return 1; }
    ULONG __stdcall Release() { return 1; }
    
private:

    // Value update
    HRESULT _GetDependencies(PropertyInfo* ppi, int iIndex, DepRecs* pdr, int iPCSrcRoot, DeferCycle* pdc);
    static void _VoidPCNotifyTree(int iPCPos, DeferCycle* pdc);

    // Defer cycle
    static void _FlushDS(Element* pe, DeferCycle* pdc);
    static void _FlushLayout(Element* pe, DeferCycle* pdc);

    // Value Update
    HRESULT _PreSourceChange(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    HRESULT _PostSourceChange();

protected:

    // EC_SelfLayout flag at creation activates these methods. No external layouts are used for layout,
    // rather, Element is responsible for layout (use when layout is specific and hierarchy is known)
    virtual void _SelfLayoutDoLayout(int dWidth, int dHeight);
    virtual SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // Internal Set and Remove
    HRESULT _SetValue(PropertyInfo* ppi, int iIndex, Value* pv, bool fInternalCall = true);
    HRESULT _RemoveLocalValue(PropertyInfo* ppi, bool fInternalCall = true);

    // Natvie hosting system event callbacks and retrieval
    virtual void OnHosted(Element* peNewHost);    // Direct
    virtual void OnUnHosted(Element* peOldHost);  // Direct
    void MarkHosted() { _fBit.bHosted = true; }

public:

    inline void DoubleBuffered(bool fEnabled = true)
    {
        if (_hgDisplayNode)
            SetGadgetStyle(_hgDisplayNode, (fEnabled) ? GS_BUFFERED : 0, GS_BUFFERED);
    }

    inline BOOL IsRoot()
    {
        return IsHosted() && (GetParent() == NULL);
    }

    // Return if being hosted by a native root
    inline Element* GetRoot()
    {
        if (!IsHosted())
            return NULL;

        Element * peCur = this;
        while (peCur->GetParent() != NULL) 
        {
            peCur = peCur->GetParent();
        }
            
        return peCur;
    }

    static BTreeLookup<IClassInfo*>* pciMap;

    // Event types
    static UID KeyboardNavigate;

    // Property definitions
    static PropertyInfo* ParentProp;            // 00
    static PropertyInfo* ChildrenProp;          // 01
    static PropertyInfo* VisibleProp;           // 02 
    static PropertyInfo* WidthProp;             // 03
    static PropertyInfo* HeightProp;            // 04
    static PropertyInfo* LocationProp;          // 05
    static PropertyInfo* ExtentProp;            // 06
    static PropertyInfo* XProp;                 // 07
    static PropertyInfo* YProp;                 // 08
    static PropertyInfo* PosInLayoutProp;       // 09
    static PropertyInfo* SizeInLayoutProp;      // 10
    static PropertyInfo* DesiredSizeProp;       // 11
    static PropertyInfo* LastDSConstProp;       // 12
    static PropertyInfo* LayoutProp;            // 13
    static PropertyInfo* LayoutPosProp;         // 14
    static PropertyInfo* BorderThicknessProp;   // 15
    static PropertyInfo* BorderStyleProp;       // 16
    static PropertyInfo* BorderColorProp;       // 17
    static PropertyInfo* PaddingProp;           // 18
    static PropertyInfo* MarginProp;            // 19
    static PropertyInfo* ForegroundProp;        // 20
    static PropertyInfo* BackgroundProp;        // 21
    static PropertyInfo* ContentProp;           // 22
    static PropertyInfo* FontFaceProp;          // 23
    static PropertyInfo* FontSizeProp;          // 24
    static PropertyInfo* FontWeightProp;        // 25
    static PropertyInfo* FontStyleProp;         // 26
    static PropertyInfo* ActiveProp;            // 27
    static PropertyInfo* ContentAlignProp;      // 28
    static PropertyInfo* KeyFocusedProp;        // 29
    static PropertyInfo* KeyWithinProp;         // 30
    static PropertyInfo* MouseFocusedProp;      // 31
    static PropertyInfo* MouseWithinProp;       // 32
    static PropertyInfo* ClassProp;             // 33
    static PropertyInfo* IDProp;                // 34
    static PropertyInfo* SheetProp;             // 35
    static PropertyInfo* SelectedProp;          // 36
    static PropertyInfo* AlphaProp;             // 37
    static PropertyInfo* AnimationProp;         // 38
    static PropertyInfo* CursorProp;            // 39
    static PropertyInfo* DirectionProp;         // 40
    static PropertyInfo* AccessibleProp;        // 41
    static PropertyInfo* AccRoleProp;           // 42
    static PropertyInfo* AccStateProp;          // 43
    static PropertyInfo* AccNameProp;           // 44
    static PropertyInfo* AccDescProp;           // 45
    static PropertyInfo* AccValueProp;          // 46
    static PropertyInfo* AccDefActionProp;      // 47
    static PropertyInfo* ShortcutProp;          // 48
    static PropertyInfo* EnabledProp;           // 49

#if DBG
    Owner owner;
#endif

protected:

    HGADGET _hgDisplayNode;

private:

    int _iIndex;

    BTreeLookup<Value*>* _pvmLocal;

    int _iGCSlot;
    int _iGCLPSlot;
    int _iPCTail;

    IElementListener** _ppel;

    // All "cached" values are caching resulting values from the Specified and Computed IVEs.
    // All local (loc) values are for ReadOnly properties. These values are updated directly
    // since it is not required to go generically through SetValue because they are ReadOnly.
    // They are used often or are cheap to store (bools), so they do not use generic
    // storage (via _SetValue).

    // Cached and local values
    Element* _peLocParent;        // Parent local
    POINT _ptLocPosInLayt;        // Position in layout local
    SIZE _sizeLocSizeInLayt;      // Size in layout local
    SIZE _sizeLocLastDSConst;     // Last desired size constraint local
    SIZE _sizeLocDesiredSize;     // Desired size local

    int _dSpecLayoutPos;          // Cached layout position
    Value* _pvSpecSheet;          // Cached property sheet specified (Value cached due to destruction)
    ATOM _atomSpecID;             // Cached id specified
    int _dSpecAlpha;              // Cached alpha value

    struct _BitMap
    {
        // Local values
        bool bLocKeyWithin       : 1;  // 0  Keyboard within local
        bool bLocMouseWithin     : 1;  // 1  Mouse within local

        // Direct VE cache
        bool bCmpVisible         : 1;  // 2  Cached visible computed
        bool bSpecVisible        : 1;  // 3  Cached visible specified
        UINT fSpecActive         : 2;  // 4  Cached active state specified
        bool bSpecSelected       : 1;  // 5  Cached selected state specified
        bool bSpecKeyFocused     : 1;  // 6  Cached keyboard focused state specified
        bool bSpecMouseFocused   : 1;  // 7  Cached mouse focused state specified
        UINT nSpecDirection      : 1;  // 8  Cached direction specified
        bool bSpecAccessible     : 1;  // 9  Cached accessible specified
        bool bSpecEnabled        : 1;  // 10 Cached enabled specified

        // Indirect VE cache (cache if default value)
        bool bHasChildren        : 1;  // 11 Cached children state (likely to be default value, no full cache)
        bool bHasLayout          : 1;  // 12 Cached layout state (likely to be default value, no full cache)
        bool bHasBorder          : 1;  // 13 Cached border state (likely to be default value, no full cache)
        bool bHasPadding         : 1;  // 14 Cached padding state (likely to be default value, no full cache)
        bool bHasMargin          : 1;  // 15 Cached margin state (likely to be default value, no full cache)
        bool bHasContent         : 1;  // 16 Cached content state (likely to be default value, no full cache)
        bool bDefaultCAlign      : 1;  // 17 Cached content align state (likely to be default value, no full cache)
        bool bWordWrap           : 1;  // 18 Cached content align state (likely to be default value, no full cache)
        bool bHasAnimation       : 1;  // 19 Cached animation state (likely to be default value, no full cache)
        bool bDefaultCursor      : 1;  // 20 Cached cursor state (likely to be default value, no full cache)
        bool bDefaultBorderColor : 1;  // 21 Cached border color state (likely to be default value, no full cache)
        bool bDefaultForeground  : 1;  // 22 Cached foreground state (likely to be default value, no full cache)
        bool bDefaultFontWeight  : 1;  // 23 Cached font weight state (likely to be default value, no full cache)
        bool bDefaultFontStyle   : 1;  // 24 Cached font style state (likely to be default value, no full cache)

        // Layout and UDS flags
        bool bSelfLayout         : 1;  // 25 Element is laying out itself (callbacks active, external layout set is undefined)
        bool bNeedsDSUpdate      : 1;  // 26
        UINT fNeedsLayout        : 2;  // 27

        // Lifetime flags
        bool bDestroyed          : 1;  // 28

        // Hosting flags
        bool bHosted             : 1;  // 29 Initially set by host Element directly

    } _fBit;

public:

    // Element DisplayNode and Index access
    HGADGET GetDisplayNode()     { return _hgDisplayNode; }
    int GetIndex()               { return _iIndex; }
    bool IsDestroyed()           { return _fBit.bDestroyed; }
    bool IsHosted()              { return _fBit.bHosted; }

    // Cache state for faster property value lookup
    bool IsSelfLayout()          { return _fBit.bSelfLayout; }
    bool HasChildren()           { return _fBit.bHasChildren; }   // Quick check before doing lookup
    bool HasLayout()             { return _fBit.bHasLayout; }     // Quick check before doing lookup
    bool HasBorder()             { return _fBit.bHasBorder; }     // Quick check before doing lookup
    bool HasPadding()            { return _fBit.bHasPadding; }    // Quick check before doing lookup
    bool HasMargin()             { return _fBit.bHasMargin; }     // Quick check before doing lookup
    bool HasContent()            { return _fBit.bHasContent; }    // Quick check before doing lookup
    bool IsDefaultCAlign()       { return _fBit.bDefaultCAlign; } // Quick check before doing lookup
    bool IsWordWrap()            { return _fBit.bWordWrap; }      // Quick check before doing lookup
    bool HasAnimation()          { return _fBit.bHasAnimation; }  // Quick check before doing lookup
    bool IsDefaultCursor()       { return _fBit.bDefaultCursor; } // Quick check before doing lookup

    // Quick property accessors (since system has knowledge of its unchangable value expressions, use cached values 
    // directly were possible to bypass GetValue value lookup). Quick accessors are only used during non-cache
    // gets. (PostSourceChange requires GetValue directly (with update-cache flag) for cache updates.)
    // All derived classes do accessors normally (no direct cache lookups)

    #define DUIQuickGetter(t, gv, p, i)                     { Value* pv; t v = (pv = GetValue(p##Prop, PI_##i))->gv; pv->Release(); return v; }
    #define DUIQuickGetterInd(gv, p, i)                     { return (*ppv = GetValue(p##Prop, PI_##i))->gv; }
    #define DUIQuickSetter(cv, p)                           { Value* pv = Value::cv; if (!pv) return E_OUTOFMEMORY; HRESULT hr = SetValue(p##Prop, PI_Local, pv); pv->Release(); return hr; }

    Element* GetParent()                                    { return _peLocParent; }
    bool GetVisible()                                       { return _fBit.bCmpVisible; }
    int GetWidth()                                          DUIQuickGetter(int, GetInt(), Width, Specified)
    int GetHeight()                                         DUIQuickGetter(int, GetInt(), Height, Specified)
    ElementList* GetChildren(Value** ppv)                   { return (*ppv = (HasChildren() ? GetValue(ChildrenProp, PI_Specified) : ChildrenProp->pvDefault))->GetElementList(); }
    int GetX()                                              DUIQuickGetter(int, GetInt(), X, Specified)
    int GetY()                                              DUIQuickGetter(int, GetInt(), Y, Specified)
    Layout* GetLayout(Value** ppv)                          { return (*ppv = (HasLayout() ? GetValue(LayoutProp, PI_Specified) : LayoutProp->pvDefault))->GetLayout(); }
    int GetLayoutPos()                                      { return _dSpecLayoutPos; }
    const RECT* GetBorderThickness(Value** ppv)             { return (*ppv = (HasBorder() ? GetValue(BorderThicknessProp, PI_Specified) : BorderThicknessProp->pvDefault))->GetRect(); }
    int GetBorderStyle()                                    DUIQuickGetter(int, GetInt(), BorderStyle, Specified)
    int GetBorderStdColor()                                 DUIQuickGetter(int, GetInt(), BorderColor, Specified)
    const Fill* GetBorderColor(Value** ppv)                 DUIQuickGetterInd(GetFill(), BorderColor, Specified)
    const RECT* GetPadding(Value** ppv)                     { return (*ppv = (HasPadding() ? GetValue(PaddingProp, PI_Specified) : PaddingProp->pvDefault))->GetRect(); }
    const RECT* GetMargin(Value** ppv)                      { return (*ppv = (HasMargin() ? GetValue(MarginProp, PI_Specified) : MarginProp->pvDefault))->GetRect(); }
    const POINT* GetLocation(Value** ppv)                   DUIQuickGetterInd(GetPoint(), Location, Local)
    const SIZE* GetExtent(Value** ppv)                      DUIQuickGetterInd(GetSize(), Extent, Local)
    const SIZE* GetDesiredSize()                            { return &_sizeLocDesiredSize; }
    int GetForegroundStdColor()                             DUIQuickGetter(int, GetInt(), Foreground, Specified)
    const Fill* GetForegroundColor(Value** ppv)             DUIQuickGetterInd(GetFill(), Foreground, Specified)
    int GetBackgroundStdColor()                             DUIQuickGetter(int, GetInt(), Background, Specified)
    const LPWSTR GetContentString(Value** ppv)              { return (*ppv = (HasContent() ? GetValue(ContentProp, PI_Specified) : Value::pvStringNull))->GetString(); }
    const LPWSTR GetFontFace(Value** ppv)                   DUIQuickGetterInd(GetString(), FontFace, Specified)
    int GetFontSize()                                       DUIQuickGetter(int, GetInt(), FontSize, Specified)
    int GetFontWeight()                                     DUIQuickGetter(int, GetInt(), FontWeight, Specified)
    int GetFontStyle()                                      DUIQuickGetter(int, GetInt(), FontStyle, Specified)
    int GetActive()                                         { return _fBit.fSpecActive; }
    int GetContentAlign()                                   { Value* pv; int v = (pv = (!IsDefaultCAlign() ? GetValue(ContentAlignProp, PI_Specified) : Value::pvIntZero))->GetInt(); pv->Release(); return v; }
    bool GetKeyFocused()                                    { return _fBit.bSpecKeyFocused; }
    bool GetKeyWithin()                                     { return _fBit.bLocKeyWithin; }
    bool GetMouseFocused()                                  { return _fBit.bSpecMouseFocused; }
    bool GetMouseWithin()                                   { return _fBit.bLocMouseWithin; }
    const LPWSTR GetClass(Value** ppv)                      DUIQuickGetterInd(GetString(), Class, Specified)
    ATOM GetID()                                            { return _atomSpecID; }
    PropertySheet* GetSheet()                               { return _pvSpecSheet->GetPropertySheet(); }
    bool GetSelected()                                      { return _fBit.bSpecSelected; }
    int GetAlpha()                                          { return _dSpecAlpha; }
    int GetAnimation()                                      DUIQuickGetter(int, GetInt(), Animation, Specified)
    int GetDirection()                                      DUIQuickGetter(int, GetInt(), Direction, Specified)
    bool GetAccessible()                                    { return _fBit.bSpecAccessible; }
    int GetAccRole()                                        DUIQuickGetter(int, GetInt(), AccRole, Specified)
    int GetAccState()                                       DUIQuickGetter(int, GetInt(), AccState, Specified)
    const LPWSTR GetAccName(Value** ppv)                    DUIQuickGetterInd(GetString(), AccName, Specified)
    const LPWSTR GetAccDesc(Value** ppv)                    DUIQuickGetterInd(GetString(), AccDesc, Specified)
    const LPWSTR GetAccValue(Value** ppv)                   DUIQuickGetterInd(GetString(), AccValue, Specified)
    const LPWSTR GetAccDefAction(Value** ppv)               DUIQuickGetterInd(GetString(), AccDefAction, Specified)
    int GetShortcut()                                       DUIQuickGetter(int, GetInt(), Shortcut, Specified)
    bool GetEnabled()                                       { return _fBit.bSpecEnabled; }

    HRESULT SetVisible(bool v)                              DUIQuickSetter(CreateBool(v), Visible)
    HRESULT SetWidth(int v)                                 DUIQuickSetter(CreateInt(v), Width)
    HRESULT SetHeight(int v)                                DUIQuickSetter(CreateInt(v), Height)
    HRESULT SetX(int v)                                     DUIQuickSetter(CreateInt(v), X)
    HRESULT SetY(int v)                                     DUIQuickSetter(CreateInt(v), Y)
    HRESULT SetLayout(Layout* v)                            DUIQuickSetter(CreateLayout(v), Layout)
    HRESULT SetLayoutPos(int v)                             DUIQuickSetter(CreateInt(v), LayoutPos)
    HRESULT SetBorderThickness(int l, int t, int r, int b)  DUIQuickSetter(CreateRect(l, t, r, b), BorderThickness)
    HRESULT SetBorderStyle(int v)                           DUIQuickSetter(CreateInt(v), BorderStyle)
    HRESULT SetBorderStdColor(int v)                        DUIQuickSetter(CreateInt(v), BorderColor)
    HRESULT SetBorderColor(COLORREF cr)                     DUIQuickSetter(CreateColor(cr), BorderColor)
    HRESULT SetBorderGradientColor(COLORREF cr0, 
            COLORREF cr1, BYTE dType = FILLTYPE_HGradient)  DUIQuickSetter(CreateColor(cr0, cr1, dType), BorderColor)
    HRESULT SetPadding(int l, int t, int r, int b)          DUIQuickSetter(CreateRect(l, t, r, b), Padding)
    HRESULT SetMargin(int l, int t, int r, int b)           DUIQuickSetter(CreateRect(l, t, r, b), Margin)
    HRESULT SetForegroundStdColor(int v)                    DUIQuickSetter(CreateInt(v), Foreground)
    HRESULT SetForegroundColor(COLORREF cr)                 DUIQuickSetter(CreateColor(cr), Foreground)
    HRESULT SetForegroundColor(COLORREF cr0, COLORREF cr1, 
            BYTE dType = FILLTYPE_HGradient)                DUIQuickSetter(CreateColor(cr0, cr1, dType), Foreground)
    HRESULT SetForegroundColor(COLORREF cr0, COLORREF cr1, COLORREF cr2,
            BYTE dType = FILLTYPE_TriHGradient)             DUIQuickSetter(CreateColor(cr0, cr1, cr2, dType), Foreground)
    HRESULT SetBackgroundStdColor(int v)                    DUIQuickSetter(CreateInt(v), Background)
    HRESULT SetBackgroundColor(COLORREF cr)                 DUIQuickSetter(CreateColor(cr), Background)
    HRESULT SetBackgroundColor(COLORREF cr0, COLORREF cr1,
            BYTE dType = FILLTYPE_HGradient)                DUIQuickSetter(CreateColor(cr0, cr1, dType), Background)
    HRESULT SetBackgroundColor(COLORREF cr0, COLORREF cr1, COLORREF cr2,
            BYTE dType = FILLTYPE_TriHGradient)             DUIQuickSetter(CreateColor(cr0, cr1, cr2, dType), Background)
    HRESULT SetContentString(LPCWSTR v)                     DUIQuickSetter(CreateString(v), Content)
    HRESULT SetContentGraphic(LPCWSTR v, 
            BYTE dBlendMode = GRAPHIC_NoBlend,
            UINT dBlendValue = 0)                           DUIQuickSetter(CreateGraphic(v, dBlendMode, dBlendValue), Content)
    HRESULT SetContentGraphic(LPCWSTR v, USHORT cxDesired, 
            USHORT cyDesired)                               DUIQuickSetter(CreateGraphic(v, cxDesired, cyDesired), Content)
    HRESULT SetFontFace(LPCWSTR v)                          DUIQuickSetter(CreateString(v), FontFace)
    HRESULT SetFontSize(int v)                              DUIQuickSetter(CreateInt(v), FontSize)
    HRESULT SetFontWeight(int v)                            DUIQuickSetter(CreateInt(v), FontWeight)
    HRESULT SetFontStyle(int v)                             DUIQuickSetter(CreateInt(v), FontStyle)
    HRESULT SetActive(int v)                                DUIQuickSetter(CreateInt(v), Active)
    HRESULT SetContentAlign(int v)                          DUIQuickSetter(CreateInt(v), ContentAlign)
    HRESULT SetClass(LPCWSTR v)                             DUIQuickSetter(CreateString(v), Class)
    HRESULT SetID(LPCWSTR v)                                DUIQuickSetter(CreateAtom(v), ID)
    HRESULT SetSheet(PropertySheet* v)                      DUIQuickSetter(CreatePropertySheet(v), Sheet)
    HRESULT SetSelected(bool v)                             DUIQuickSetter(CreateBool(v), Selected)
    HRESULT SetAlpha(int v)                                 DUIQuickSetter(CreateInt(v), Alpha)
    HRESULT SetAnimation(int v)                             DUIQuickSetter(CreateInt(v), Animation)
    HRESULT SetStdCursor(int v)                             DUIQuickSetter(CreateInt(v), Cursor)
    HRESULT SetCursor(LPCWSTR v)                            DUIQuickSetter(CreateCursor(v), Cursor)
    HRESULT SetDirection(int v)                             DUIQuickSetter(CreateInt(v), Direction)
    HRESULT SetAccessible(bool v)                           DUIQuickSetter(CreateBool(v), Accessible)
    HRESULT SetAccRole(int v)                               DUIQuickSetter(CreateInt(v), AccRole)
    HRESULT SetAccState(int v)                              DUIQuickSetter(CreateInt(v), AccState)
    HRESULT SetAccName(LPCWSTR v)                           DUIQuickSetter(CreateString(v), AccName)
    HRESULT SetAccDesc(LPCWSTR v)                           DUIQuickSetter(CreateString(v), AccDesc)
    HRESULT SetAccValue(LPCWSTR v)                          DUIQuickSetter(CreateString(v), AccValue)
    HRESULT SetAccDefAction(LPCWSTR v)                      DUIQuickSetter(CreateString(v), AccDefAction)
    HRESULT SetShortcut(int v)                              DUIQuickSetter(CreateInt(v), Shortcut)
    HRESULT SetEnabled(bool v)                              DUIQuickSetter(CreateBool(v), Enabled)

    ////////////////////////////////////////////////////////
    // ClassInfo accessors (static and virtual instance-based)

    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ///////////////////////////////////////////////////////
    // Accessibility support

    DuiAccessible * _pDuiAccessible;
    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);
    HRESULT QueueDefaultAction();
    virtual HRESULT DefaultAction();
};

////////////////////////////////////////////////////////
// Element helpers

Element* ElementFromGadget(HGADGET hGadget);
void QueryDetails(Element* pe, HWND hParent);

////////////////////////////////////////////////////////
// DeferCycle: Per-thread deferring information

// Group notifications: deferred until EndDefer and coalesced
struct GCRecord
{
    Element* pe;
    int fGroups;
};

// Property notifications: deferred until source's dependency
// graph is searched (within SetValue call), not coalesced
struct PCRecord
{
    bool fVoid;
    Element* pe;
    PropertyInfo* ppi;
    int iIndex;
    Value* pvOld;
    Value* pvNew;
    DepRecs dr;
    int iPrevElRec;
};

class DeferCycle
{
public:
    static HRESULT Create(DeferCycle** ppDC);
    void Destroy() { HDelete<DeferCycle>(this); }
    
    void Reset();

    DynamicArray<GCRecord>* pdaGC;            // Group changed database
    DynamicArray<GCRecord>* pdaGCLP;          // Low priority group changed database
    DynamicArray<PCRecord>* pdaPC;            // Property changed database
    ValueMap<Element*,BYTE>* pvmLayoutRoot;   // Layout trees pending
    ValueMap<Element*,BYTE>* pvmUpdateDSRoot; // Update desired size trees pending

    int cEnter;
    bool fFiring;
    int iGCPtr;
    int iGCLPPtr;
    int iPCPtr;
    int iPCSSUpdate;
    int cPCEnter;

    DeferCycle() { }
    HRESULT Initialize();
    virtual ~DeferCycle();
};

#if DBG
// Process-wide element count
extern LONG g_cElement;
#endif

// Per-thread Element slot
extern DWORD g_dwElSlot;

struct ElTls
{
    HDCONTEXT hCtx;         // DirectUser thread context
    int cRef;
    SBAlloc* psba;
    DeferCycle* pdc;
    FontCache* pfc;
    bool fCoInitialized;
    int dEnableAnimations;
#if DBG
    int cDNCBEnter;         // Track when _DisplayNodeCallback is entered
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Per-Context object access

inline bool IsAnimationsEnabled() 
{ 
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls) 
        return false; 
    return (petls->dEnableAnimations == 0); 
}

inline void EnableAnimations()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return;
    petls->dEnableAnimations++;
}

inline void DisableAnimations()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return;
    petls->dEnableAnimations--;
}

inline HDCONTEXT GetContext()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->hCtx;
}

inline DeferCycle* GetDeferObject()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->pdc;
}

inline FontCache* GetFontCache()
{
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->pfc;
}

inline SBAlloc* GetSBAllocator()
{
#if 0
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    if (!petls)
        return NULL;
    return petls->psba;
#else
    ElTls* petls = (ElTls*)TlsGetValue(g_dwElSlot);
    DUIAssert(petls != NULL, "Must have valid SBAllocator");
    return petls->psba;
#endif
}

// Use to check if Element may be accessed via the current thread
#if DBG
inline void ContextCheck(Element* pe)
{
    DUIAssert(pe->owner.dwTLSSlot == g_dwElSlot, "Element being accessed out of side-by-side instance");
    DUIAssert(pe->owner.hCtx == GetContext(), "Element being accessed out of context");
}
#define DUIContextAssert(pe) ContextCheck(pe)
#else
#define DUIContextAssert(pe)
#endif

////////////////////////////////////////////////////////
// Property enumerations

// ActiveProp
#define AE_Inactive             0x00000000
#define AE_Mouse                0x00000001
#define AE_Keyboard             0x00000002
#define AE_MouseAndKeyboard     (AE_Mouse | AE_Keyboard)

// BorderStyleProp
#define BDS_Solid               0
#define BDS_Raised              1
#define BDS_Sunken              2
#define BDS_Rounded             3

// FontStyleProp
#define FS_None                 0x00000000
#define FS_Italic               0x00000001
#define FS_Underline            0x00000002
#define FS_StrikeOut            0x00000004
#define FS_Shadow               0x00000008

// FontWeightProp
#define FW_DontCare             0
#define FW_Thin                 100
#define FW_ExtraLight           200
#define FW_Light                300
#define FW_Normal               400
#define FW_Medium               500
#define FW_SemiBold             600
#define FW_Bold                 700
#define FW_ExtraBold            800
#define FW_Heavy                900
    
// ContentAlignProp (CAE_XY, Y=bits 0-1, X=bits 2-3)
#define CA_TopLeft              0x00000000  // (0,0)
#define CA_TopCenter            0x00000001  // (0,1)
#define CA_TopRight             0x00000002  // (0,2)
#define CA_MiddleLeft           0x00000004  // (1,0)
#define CA_MiddleCenter         0x00000005  // (1,1)
#define CA_MiddleRight          0x00000006  // (1,2)
#define CA_BottomLeft           0x00000008  // (2,0)
#define CA_BottomCenter         0x00000009  // (2,1)
#define CA_BottomRight          0x0000000A  // (2,2)
#define CA_WrapLeft             0x0000000C  // (3,0)
#define CA_WrapCenter           0x0000000D  // (3,1)
#define CA_WrapRight            0x0000000E  // (3,2)

#define CA_EndEllipsis          0x00000010
#define CA_FocusRect            0x00000020

// AnimationProp (Interpolation | CatType [ | CatType | ... ] | Speed)
#define ANI_InterpolMask        0x0000000F
#define ANI_DelayMask           0x000000F0
#define ANI_TypeMask            0x0FFFFF00
#define ANI_SpeedMask           0xF0000000

#define ANI_DefaultInterpol     0x00000000
#define ANI_Linear              0x00000001  // INTERPOLATION_LINEAR
#define ANI_Log                 0x00000002  // INTERPOLATION_LOG
#define ANI_Exp                 0x00000003  // INTERPOLATION_EXP
#define ANI_S                   0x00000004  // INTERPOLATION_S

#define ANI_DelayNone           0x00000000
#define ANI_DelayShort          0x00000010
#define ANI_DelayMedium         0x00000020
#define ANI_DelayLong           0x00000030

#define ANI_AlphaType           0x00000F00
#define ANI_BoundsType          0x0000F000
#define ANI_XFormType           0x000F0000

#define ANI_None                0x00000000
#define ANI_Alpha               0x00000100
#define ANI_Position            0x00001000
#define ANI_Size                0x00002000
#define ANI_SizeH               0x00003000
#define ANI_SizeV               0x00004000
#define ANI_Rect                0x00005000
#define ANI_RectH               0x00006000
#define ANI_RectV               0x00007000
#define ANI_Scale               0x00010000

#define ANI_DefaultSpeed        0x00000000
#define ANI_VeryFast            0x10000000
#define ANI_Fast                0x20000000
#define ANI_MediumFast          0x30000000
#define ANI_Medium              0x40000000
#define ANI_MediumSlow          0x50000000
#define ANI_Slow                0x60000000
#define ANI_VerySlow            0x70000000

// CursorProp
#define CUR_Arrow               0
#define CUR_Hand                1
#define CUR_Help                2
#define CUR_No                  3
#define CUR_Wait                4
#define CUR_SizeAll             5
#define CUR_SizeNESW            6
#define CUR_SizeNS              7
#define CUR_SizeNWSE            8
#define CUR_SizeWE              9
#define CUR_Total              10

// Internal property indicies for property compares. Must match up one to one
// with Element property definitions
#define _PIDX_Parent            0
#define _PIDX_PosInLayout       1
#define _PIDX_SizeInLayout      2
#define _PIDX_DesiredSize       3
#define _PIDX_LastDSConst       4
#define _PIDX_Location          5
#define _PIDX_Extent            6
#define _PIDX_LayoutPos         7
#define _PIDX_Active            8
#define _PIDX_Children          9
#define _PIDX_Layout            10
#define _PIDX_BorderThickness   11
#define _PIDX_Padding           12
#define _PIDX_Margin            13
#define _PIDX_Visible           14
#define _PIDX_X                 15
#define _PIDX_Y                 16
#define _PIDX_ContentAlign      17
#define _PIDX_KeyFocused        18
#define _PIDX_KeyWithin         19
#define _PIDX_MouseFocused      20
#define _PIDX_MouseWithin       21
#define _PIDX_Content           22
#define _PIDX_Sheet             23
#define _PIDX_Width             24
#define _PIDX_Height            25
#define _PIDX_BorderStyle       26
#define _PIDX_BorderColor       27
#define _PIDX_Foreground        28
#define _PIDX_Background        29
#define _PIDX_FontFace          30
#define _PIDX_FontSize          31
#define _PIDX_FontWeight        32
#define _PIDX_FontStyle         33
#define _PIDX_Class             34
#define _PIDX_ID                35
#define _PIDX_Selected          36
#define _PIDX_Alpha             37
#define _PIDX_Animation         38
#define _PIDX_Cursor            39
#define _PIDX_Direction         40
#define _PIDX_Accessible        41
#define _PIDX_AccRole           42
#define _PIDX_AccState          43
#define _PIDX_AccName           44
#define _PIDX_AccDesc           45
#define _PIDX_AccValue          46
#define _PIDX_AccDefAction      47
#define _PIDX_Shortcut          48
#define _PIDX_Enabled           49

#define _PIDX_TOTAL             50

////////////////////////////////////////////////////////
// Class information template

// All classes that derive from Element must create a global instance of this class.
// It maintains a list of the class properties (provides enumeration) and creation method
// C = Class, B = Base class

// Defined in Element.cpp
extern UINT g_iGlobalCI;
extern UINT g_iGlobalPI;

template <typename C, typename B> class ClassInfo : public IClassInfo
{
public:
    // Registration (cannot unregister -- will be registered until UnInitProcess is called)
    static HRESULT Register(LPCWSTR pszName, PropertyInfo** ppPI, UINT cPI)
    {
        HRESULT hr;
    
        // If class mapping doesn't exist, registration fails 
        if (!Element::pciMap)
            return E_FAIL;

        // Check for entry in mapping, if exists, ignore registration
        if (!Element::pciMap->GetItem((void*)pszName))
        {
            // Never been registered, create class info entry
            hr = Create(pszName, ppPI, cPI, &C::Class);
            if (FAILED(hr))
                return hr;
        
            hr = Element::pciMap->SetItem((void*)pszName, C::Class);
            if (FAILED(hr))
                return hr;
        }

        return S_OK;
    }

    // Construction
    static HRESULT Create(LPCWSTR pszName, PropertyInfo** ppPI, UINT cPI, IClassInfo** ppCI)
    {
        *ppCI = NULL;

        // Element map must already exist
        if (!Element::pciMap)
            return E_FAIL;
    
        ClassInfo* pci = HNew<ClassInfo>();
        if (!pci)
            return E_OUTOFMEMORY;

        // Setup state
        pci->_ppPI = ppPI;
        pci->_cPI = cPI;
        pci->_pszName = pszName;

        // Set global index
        pci->_iGlobalIndex = g_iGlobalCI++;

        // Setup property ownership
        for (UINT i = 0; i < cPI; i++)
        {
            ppPI[i]->_iIndex = i;
            ppPI[i]->_iGlobalIndex = g_iGlobalPI++;
            ppPI[i]->_pciOwner = pci;
        }

#if DBG
        // Call string conversion method directly since can't assume Util library is available for header
        CHAR szNameA[101];
        ZeroMemory(szNameA, sizeof(szNameA));
        WideCharToMultiByte(CP_ACP, 0, pszName, -1, szNameA, (sizeof(szNameA) / sizeof(CHAR)) - 1, NULL, NULL);
        //DUITrace("RegDUIClass[%d]: '%s', %d ClassProps\n", pci->_iGlobalIndex, szNameA, cPI);
#endif

        *ppCI = pci;

        return S_OK;
    }

    void Destroy() { HDelete<ClassInfo>(this); }

public:
    HRESULT CreateInstance(OUT Element** ppElement) { return C::Create(ppElement); }
    PropertyInfo* EnumPropertyInfo(UINT nEnum) { return (nEnum < _cPI) ? _ppPI[nEnum] : B::Class->EnumPropertyInfo(nEnum - _cPI); }
    UINT GetPICount() { return _cPI + B::Class->GetPICount(); }
    UINT GetGlobalIndex() { return _iGlobalIndex; }
    IClassInfo* GetBaseClass() { return B::Class; }
    LPCWSTR GetName() { return _pszName; }
    bool IsValidProperty(PropertyInfo* ppi) { return (ppi->_pciOwner == this) ? true : B::Class->IsValidProperty(ppi); }
    bool IsSubclassOf(IClassInfo* pci) { return (pci == this) ? true : B::Class->IsSubclassOf(pci); }

    ClassInfo() { }
    virtual ~ClassInfo() { }

private:
    PropertyInfo** _ppPI;  // Array of properties for this class (C)
    UINT _cPI;             // Count of properties for this class (C)
    UINT _iGlobalIndex;    // Zero-based unique contiguous class id
    LPCWSTR _pszName;      // Class name
};

} // namespace DirectUI

#endif // DUI_CORE_ELEMENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiexpression.h ===
/*
 * Value expressions
 */

#ifndef DUI_CORE_EXPRESSION_H_INCLUDED
#define DUI_CORE_EXPRESSION_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Expression

class Expression
{
public:
    void Destroy() { HDelete<Expression>(this); }
};

} // namespace DirectUI

#endif // DUI_CORE_EXPRESSION_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duifilllayout.h ===
/*
 * FillLayout
 */

#ifndef DUI_FILLLAYOUT_H_INCLUDED
#define DUI_FILLLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// FillLayout positions
// "Auto (-1)" means stretch to size of parent
// All other layout positions describe a limited type of stretch
// (i.e. "left" means stretch all edges to parent except right edge)
#define FLP_Left        0
#define FLP_Top         1
#define FLP_Right       2
#define FLP_Bottom      3

////////////////////////////////////////////////////////
// FillLayout

class FillLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    FillLayout() { };
    void Initialize();   
    virtual ~FillLayout() { };

private:
    RECT rcMargin;  
};

} // namespace DirectUI

#endif // DUI_FILLLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duigadget.h ===
/*
 * Manual Gadget utility methods
 */

#ifndef DUI_UTIL_GADGET_H_INCLUDED
#define DUI_UTIL_GADGET_H_INCLUDED

#pragma once

namespace DirectUI
{

void SetGadgetOpacity(HGADGET hgad, BYTE dAlpha);
void OffsetGadgetPosition(HGADGET hgad, int x, int y);

} // namespace DirectUI

#endif // DUI_UTIL_GADGET_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duifontcache.h ===
/*
 * Font Cache
 */

#ifndef DUI_BASE_FONTCACHE_H_INCLUDED
#define DUI_BASE_FONTCACHE_H_INCLUDED

#pragma once

namespace DirectUI
{

// Supported styles
#define FS_None                 0x00000000
#define FS_Italic               0x00000001
#define FS_Underline            0x00000002
#define FS_StrikeOut            0x00000004

class FontCache
{
public:

    static HRESULT Create(UINT uCacheSize, OUT FontCache** ppCache);
    void Destroy();

    HFONT CheckOutFont(LPWSTR szFamily, int dSize, int dWeight, int dStyle, int dAngle);
    void CheckInFont() { _fLock = false; }

    struct FontRecord
    {
        HFONT hFont;

        WCHAR szFamily[LF_FACESIZE];
        int dSize;
        int dWeight;
        int dStyle;
        int dAngle;

        UINT uHits;
    };

    struct RecordIdx  // Array sorted by frequency of use
    {
        FontCache* pfcContext;  // Context used for global sort routine
        UINT idx;     // Refers to a FontRecord location
    };
    
    UINT _GetRecordHits(UINT uRec) { return (_pDB + uRec)->uHits; }

    FontCache() {}
    HRESULT Initialize(UINT uCacheSize);
    virtual ~FontCache();

private:
    bool _fLock;
    UINT _uCacheSize;
    FontRecord* _pDB;   // Array of cached records
    RecordIdx* _pFreq;  // Array of sorted record indicies by frequency of use
};

} // namespace DirectUI

#endif // DUI_BASE_FONTCACHE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duihost.h ===
/*
 * Host
 */

#ifndef DUI_CORE_HOST_H_INCLUDED
#define DUI_CORE_HOST_H_INCLUDED

#pragma once

#include "duielement.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// HWNDElement

#define HWEM_FLUSHWORKINGSET      WM_USER

class HWNDElement : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);  // Required for ClassInfo (always fails)
    static HRESULT Create(HWND hParent, bool fDblBuffer, UINT nCreate, OUT Element** ppElement);

    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnGroupChanged(int fGroups, bool bLowPri);
    virtual void OnDestroy();
    virtual void OnEvent(Event* pEvent);
    virtual void OnInput(InputEvent* pInput);
    virtual bool CanSetFocus() {return true;}

    Element* ElementFromPoint(POINT* ppt);

    static LRESULT CALLBACK StaticWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);    
    virtual LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void FlushWorkingSet();  // Async

    HWND GetHWND() { return _hWnd; }
    Element* GetKeyFocusedElement();

    void ShowUIState(bool fUpdateAccel, bool fUpdateFocus);
    WORD GetUIState() { return _wUIState; }
    bool ShowAccel() { return !(GetUIState() & UISF_HIDEACCEL); }
    bool ShowFocus() { return !(GetUIState() & UISF_HIDEFOCUS); }

    void SetParentSizeControl(bool bParentSizeControl) {_bParentSizeControl = bParentSizeControl;}
    void SetScreenCenter(bool bScreenCenter) {_bScreenCenter = bScreenCenter;}
    
    // Property definitions
    static PropertyInfo* WrapKeyboardNavigateProp;

    // Quick property accessors
    bool GetWrapKeyboardNavigate()           DUIQuickGetter(bool, GetBool(), WrapKeyboardNavigate, Specified)

    HRESULT SetWrapKeyboardNavigate(bool v)  DUIQuickSetter(CreateBool(v), WrapKeyboardNavigate)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ///////////////////////////////////////////////////////
    // Accessibility support
    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);
    
    HWNDElement() {_bParentSizeControl = false;  _bScreenCenter = false;}
    virtual ~HWNDElement() { }
    HRESULT Initialize(HWND hParent, bool fDblBuffer, UINT nCreate);

protected:

    HWND _hWnd;
    HPALETTE _hPal;
    bool _bParentSizeControl;
    bool _bScreenCenter;
    WORD _wUIState;
};

} // namespace DirectUI

#endif // DUI_CORE_HOST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiflowlayout.h ===
/*
 * FlowLayout
 */

#ifndef DUI_LAYPUT_FLOWLAYOUT_H_INCLUDED
#define DUI_LAYPUT_FLOWLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

struct LINE
{
    UINT cx;             // length of line
    UINT cy;             // thickness of line
    UINT y;              // pixel start of line (always 0 for first line)
    UINT cElements;      // number of elements in line
    UINT* arxElement;    // pixel start of elements in line (one less than cElements -- because first start is always 0)
    UINT iStart;         // index of first element in line
};

////////////////////////////////////////////////////////
// flow layout

class FlowLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign, OUT Layout** ppLayout);
    
    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly);

    int GetLine(Element* pec, Element* pe);

    FlowLayout() { }
    void Initialize(bool fWrap, UINT uYAlign, UINT uXLineAlign, UINT uYLineAlign);
    virtual ~FlowLayout();

protected:
    SIZE BuildCacheInfo(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize);

    bool _fWrap;
    UINT _uXLineAlign;
    UINT _uYLineAlign;
    UINT _uYAlign;
    SIZE _sizeDesired;
    SIZE _sizeLastConstraint;
    UINT _cLines;
    LINE* _arLines;

    static SIZE g_sizeZero;

    // not sure we need to have these -- check i18n dir & dir override flags to see if they're enough
    // bool _bBtoT;
    // bool _bRtoL;
};

} // namespace DirectUI

#endif // DUI_LAYPUT_FLOWLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duigridlayout.h ===
/*
 * Gridlayout
 */

#ifndef DUI_LAYOUT_GRIDLAYOUT_H_INCLUDED
#define DUI_LAYOUT_GRIDLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

////////////////////////////////////////////////////////
// GridLayout

class GridLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(int iRows, int iCols, OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int cx, int cy);
    virtual SIZE UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    GridLayout() { }
    void Initialize(int iRows, int iCols);
    virtual ~GridLayout();

protected:
    UINT _uRows;
    UINT _uCols;
    UINT _fBits;
    int* _arColMargins;
    int* _arRowMargins;

    inline UINT GetCurrentRows(Element* pec);
    inline UINT GetCurrentRows(int c);
    inline UINT GetCurrentCols(Element* pec);
    inline UINT GetCurrentCols(int c);
};

} // namespace DirectUI

#endif // DUI_LAYOUT_GRIDLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duinative.h ===
/*
 * Native
 */

#ifndef DUI_CONTROL_NATIVE_H_INCLUDED
#define DUI_CONTROL_NATIVE_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Top-level native HWND host of HWNDElement

#define NHHO_IgnoreClose          1  // Ignore WM_CLOSE (i.e. Alt-F4, 'X' button), must be closed via DestroyWindow
#define NHHO_NoSendQuitMessage    2
#define NHHO_HostControlsSize     4
#define NHHO_ScreenCenter         8
#define NHHO_DeleteOnHWNDDestroy  16 // If the HWND is destroyed, destroy NativeHWNDHost instance


#define NHHM_ASYNCDESTROY   WM_USER

class NativeHWNDHost
{
public:
    static HRESULT Create(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions, OUT NativeHWNDHost** ppHost);
    void Destroy() { HDelete<NativeHWNDHost>(this); }

    HWND GetHWND() { return _hWnd; }
    Element* GetElement() { return _pe; }
    void Host(Element* pe);
    void ShowWindow(int iShow = SW_SHOWNORMAL) { DUIAssertNoMsg(_hWnd); ::ShowWindow(_hWnd, iShow); }
    void HideWindow() { DUIAssertNoMsg(_hWnd); ::ShowWindow(_hWnd, SW_HIDE); }
    void DestroyWindow() { DUIAssertNoMsg(_hWnd); PostMessage(_hWnd, NHHM_ASYNCDESTROY, 0, 0); }

    static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    NativeHWNDHost() { }
    HRESULT Initialize(LPCWSTR pszTitle, HWND hWndParent, HICON hIcon, int dX, int dY, int dWidth, int dHeight, int iExStyle, int iStyle, UINT nOptions);
    virtual ~NativeHWNDHost() { }

private:
    HWND _hWnd;
    Element* _pe;
    UINT _nOptions;
};

} // namespace DirectUI

#endif // DUI_CONTROL_NATIVE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duihwndhost.h ===
// HWNDHost.h
//

#ifndef DUI_CONTROL_HWNDHOST_H_INCLUDED
#define DUI_CONTROL_HWNDHOST_H_INCLUDED

namespace DirectUI
{

////////////////////////////////////////////////////////
// HWNDHost

// Element to HWND bridge

#define HHC_CacheFont           0x00000001

// HWNDHost subclasses the HWND child and intercepts all input. This input is forward to DUser
// as a normal message (as if the message never originated via the HWND child). After the input
// message routes, it will be sent to the peer gadget and then on to Element (via OnInput).
// A HWND message will be constructed and sent to the HWND child.
//
// The following flags disables the forwarding of the original HWND message into the DUser world.
// Thus, while the underlying gadget may get mouse/key focus, the HWND will appear as a
// "dead area" within the Element.
//
// These options are used if the HWND is used in an environment where it is not guaranteed that
// all messages sent to it will be dispatched. If they aren't, DUser's state cannot by synchronized.

#define HHC_NoMouseForward      0x00000002
#define HHC_NoKeyboardForward   0x00000004
#define HHC_SyncText            0x00000008
#define HHC_SyncPaint           0x00000010

// Class definition
class HWNDHost : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(HHC_CacheFont, AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nCreate, UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnInput(InputEvent* pInput);
    virtual void OnDestroy();

    // HWNDHost system events, control notification
    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    // Sizing callback
    virtual BOOL OnAdjustWindowSize(int x, int y, UINT uFlags);
    
    // Message callback
    virtual UINT MessageCallback(GMSG* pGMsg);

    // Rendering
    virtual void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);
#ifdef GADGET_ENABLE_GDIPLUS
    virtual void Paint(Gdiplus::Graphics* pgpgr, const Gdiplus::RectF* prcBounds, const Gdiplus::RectF* prcInvalid, Gdiplus::RectF* prSkipBorder, Gdiplus::RectF* prSkipContent);
#endif

    HWND GetHWND() { return _hwndCtrl; }
    
    HWND GetHWNDParent() { return _hwndSink; }

    void Detach();

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ///////////////////////////////////////////////////////
    // Accessibility support
    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);

    HWNDHost() { }
    HRESULT Initialize(UINT nCreate, UINT nActive);
    virtual ~HWNDHost() { }

protected:

    virtual void OnHosted(Element* peNewHost);
    virtual void OnUnHosted(Element* peOldHost);
    virtual HWND CreateHWND(HWND hwndParent);

    // Synchronize control and sink to changes
    void SyncRect(UINT nChangeFlags, bool bForceSync = false);
    void SyncParent();
    void SyncStyle();
    void SyncVisible();
    void SyncFont();
    void SyncText();

private:
    // Control and sink subclass procs
    static BOOL CALLBACK _SinkWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);
    static BOOL CALLBACK _CtrlWndProc(void* pThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);

    static const UINT g_rgMouseMap[7][3];   // Gadget input message to HWND input message mapping

    bool _fHwndCreate;                      // On first call, create HWNDs (sink and control)

    HWND _hwndCtrl;                         // Hosted control
    HWND _hwndSink;                         // HWND used to receive control notifications
    WNDPROC _pfnCtrlOrgProc;                // The Controls original WNDPROC

    RECT _rcBounds;                         // Bounds of sink and control (in client coordinates)
    HFONT _hFont;                           // Cached font (optional)

    UINT _nCreate;                          // Creation flags
};

} // namespace DirectUI

#endif // DUI_CONTROL_HWNDHOST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duinavigation.h ===
/*
 * Spatial navigation support
 */

#ifndef DUI_CORE_NAVIGATION_H_INCLUDED
#define DUI_CORE_NAVIGATION_H_INCLUDED

#pragma once

namespace DirectUI
{

//
// This class encapsulates the "standard" approach to spatial
// navigation.  Will need much work in the future.
//
class DuiNavigate
{
public:
    static Element * Navigate(Element * peFrom, ElementList * pelConsider, int nNavDir);
};

}

#endif // DUI_CORE_NAVIGATION_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duilayout.h ===
/*
 * Layout
 */

#ifndef DUI_CORE_LAYOUT_H_INCLUDED
#define DUI_CORE_LAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// Global layout positions
#define LP_None         -3
#define LP_Absolute     -2
#define LP_Auto         -1

////////////////////////////////////////////////////////
// Alignment enumerations

#define ALIGN_LEFT      0
#define ALIGN_TOP       0
#define ALIGN_RIGHT     1
#define ALIGN_BOTTOM    1
#define ALIGN_CENTER    2
#define ALIGN_JUSTIFY   3

// Forward declarations
class Element;
typedef DynamicArray<Element*> ElementList;
struct NavReference;

struct NavScoring
{
    BOOL TrackScore(Element* peTest, Element* peChild);
    void Init(Element* peRelative, int iNavDir, NavReference const* pnr);
    BOOL Try(Element* peChild, int iNavDir, NavReference const* pnr, bool fKeyableOnly);

    int iHighScore;
    Element* peWinner;

private:
    int iBaseIndex;
    int iLow;
    int iHigh;
    int iMajorityScore;
};

/**
 * NOTE: Layouts are currently single context only (non-shareable). All contexts passed in to
 * callbacks (Element* pec) will be the same.
 */

////////////////////////////////////////////////////////
// Base layout

class Layout
{
public:
    static HRESULT Create(Layout** ppLayout);
    void Destroy() { HDelete<Layout>(this); }

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual void OnAdd(Element* pec, Element** ppeAdd, UINT cCount);
    virtual void OnRemove(Element* pec, Element** ppeRemove, UINT cCount);
    virtual void OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP);
    virtual void Attach(Element* pec);
    virtual void Detach(Element* pec);

    // Layout client query methods (omits absolute children)
    UINT GetLayoutChildCount(Element* pec);
    int GetLayoutIndexFromChild(Element* pec, Element* peChild);
    Element* GetChildFromLayoutIndex(Element* pec, int iLayoutIdx, ElementList* peList = NULL);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    Layout() { }
    void Initialize();
    virtual ~Layout();
    
protected:
    static void UpdateLayoutRect(Element* pec, int cxContainer, int cyContainer, Element* peChild, int xElement, int yElement, int cxElement, int cyElement);

    // Dirty bit
    // This exists in base Layout merely as a convenience for derived Layout Managers.
    // Some LMs cache data during an UpdateDesiredSize call. This cached data is used
    // during DoLayout and is usually dependent on number of children and/or layout
    // position of children. This means that if UpdateDesiredSize doesn't get called
    // on these LMs, the cache will be invalid for the DoLayout. Since UpdateDesiredSize is
    // always called by LMs, you cannot assume that you will always get an UpdateDesiredSize
    // before a DoLayout. LMs may terminate UpdateDesiredSize passes because they
    // ran out of room, or couldn't make an allocation. This bit is used to mark
    // if a cache is valid. It is automatically invalidated in the base in the following
    // methods: OnAdd, OnRemove, OnLayoutPosChanged, Attach, and Detach.
    bool IsCacheDirty() { return _fCacheDirty; }
    void SetCacheDirty() { _fCacheDirty = true; }
    void ClearCacheDirty() { _fCacheDirty = false; }

    // TODO: Make shareable (supports only 1 context currently)
    Element* _peClient;

    // TODO: Multiple contexts
    DynamicArray<Element*>* _pdaIgnore;

private:
    bool _fCacheDirty;
    
};

} // namespace DirectUI

#endif // DUI_CORE_LAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiparserobj.h ===
/*
 * Parser
 */

#ifndef DUI_PARSER_PARSEROBJ_H_INCLUDED
#define DUI_PARSER_PARSEROBJ_H_INCLUDED

#pragma once

namespace DirectUI
{

#define MAXIDENT            31

////////////////////////////////////////////////////////
// Parser table definitions

struct EnumTable
{
    LPWSTR pszEnum;
    int nEnum;
};

typedef HRESULT (*PLAYTCREATE)(int, int*, Value**);
struct LayoutTable
{
    LPWSTR pszLaytType;
    PLAYTCREATE pfnLaytCreate;
};

typedef struct
{
    LPWSTR pszElType;
    IClassInfo* pci;
} ElementTable;

struct SysColorTable
{
    LPWSTR pszSysColor;
    int nSysColor;
};

////////////////////////////////////////////////////////
// Parser tree data structures
// Parse tree nodes are any data structure dynamically allocated to store tree information

// Parse tree node types
#define NT_ValueNode            0
#define NT_PropValPairNode      1
#define NT_ElementNode          2
#define NT_AttribNode           3
#define NT_RuleNode             4
#define NT_SheetNode            5
                            
// Tree node base class
struct Node
{
    BYTE nType;
};

// Value node
#define VNT_Normal              0
#define VNT_LayoutCreate        1
#define VNT_SheetRef            2
#define VNT_EnumFixup           3  // Map name to int Value once PropertyInfo is known

struct LayoutCreate
{
    union
    {
        PLAYTCREATE pfnLaytCreate;
        LPWSTR pszLayout;  // Fixup happens immediately during Value creation
    };
    int dNumParams;
    int* pParams;
};

struct EnumsList
{
    int dNumParams;
    LPWSTR* pEnums;  // Enums to be OR'd
};

struct ValueNode : Node
{
    BYTE nValueType;
    union
    {
        Value* pv;        // VNT_Normal
        LayoutCreate lc;  // VNT_LayoutCreate, created during Element creates
        LPWSTR psres;     // VNT_SheetRef
        EnumsList el;     // VNT_EnumFixup
    };
};

// Property/Value Pair
#define PVPNT_Normal            0
#define PVPNT_Fixup             1  // Map name to ppi once Element type is known

struct PropValPairNode : Node
{
    BYTE nPropValPairType;
    union
    {
        PropertyInfo* ppi;  // PVPNT_Normal
        LPWSTR pszProperty; // PVPNT_Fixup
    };
    ValueNode* pvn;

    PropValPairNode* pNext;
};

// Element node
struct ElementNode : Node
{
    IClassInfo* pci;
    PropValPairNode* pPVNodes;
    LPWSTR pszResID;
    Value* pvContent;

    ElementNode* pChild;
    ElementNode* pNext;
};

// Sheet attribute node
#define PALOGOP_Equal           0
#define PALOGOP_NotEqual        1

struct AttribNode : PropValPairNode
{
    UINT nLogOp;
};

// Sheet rule node
struct RuleNode : Node
{
    IClassInfo* pci;
    AttribNode* pCondNodes;
    PropValPairNode* pDeclNodes;

    RuleNode* pNext;
};

// Sheet node
struct SheetNode : Node
{
    Value* pvSheet;  // Create once all Rules are known
    RuleNode* pRules;
    LPWSTR pszResID;
};

// Intermediate parser data structures
struct ParamsList
{
    int dNumParams;
    int* pParams;
};

struct StartTag
{
    WCHAR szTag[MAXIDENT];
    WCHAR szResID[MAXIDENT];
    PropValPairNode* pPVNodes;
};

// Parser

typedef void (CALLBACK *PPARSEERRORCB)(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

class Parser
{
public:
    static HRESULT Create(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);

    static HRESULT Create(const CHAR* pBuffer, int cCharCount, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);
    static HRESULT Create(LPCWSTR pFile, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB, OUT Parser** ppParser);

    void Destroy() { HDelete<Parser>(this); }

    HRESULT CreateElement(LPCWSTR pszResID, Element* peSubstitute, OUT Element** ppElement);
    virtual Value* GetSheet(LPCWSTR pszResID);
    LPCWSTR ResIDFromSheet(Value* pvSheet);

    void GetPath(LPCWSTR pIn, LPWSTR pOut);

    // Parser/scanner only use
    int _Input(CHAR* pBuffer, int cMaxChars);
    void* _TrackNodeAlloc(SIZE_T s);                // Parse-tree node memory
    void _UnTrackNodeAlloc(Node* pn);               // Parse-tree node memory
    void* _TrackAlloc(SIZE_T s);                    // Node-specific state
    void* _TrackTempAlloc(SIZE_T s);                // Parse-time temporary memory
    void _TrackTempAlloc(void* pm);                 // Parse-time temporary memory
    void* _TrackTempReAlloc(void* pm, SIZE_T s);    // Parse-time temporary memory
    void _UnTrackTempAlloc(void* pm);               // Parse-time temporary memory
    void _ParseError(LPCWSTR pszError, LPCWSTR pszToken, int dLine);

    ValueNode* _CreateValueNode(BYTE nValueType, void* pData);
    PropValPairNode* _CreatePropValPairNode(LPCWSTR pszProperty, ValueNode* pvn, UINT* pnLogOp = NULL);
    RuleNode* _CreateRuleNode(LPCWSTR pszClass, AttribNode* pCondNodes, PropValPairNode* pDeclNodes);
    ElementNode* _CreateElementNode(StartTag* pst, Value* pvContent);
    SheetNode* _CreateSheetNode(LPCWSTR pszResID, RuleNode* pRuleNodes);
    static int _QuerySysMetric(int idx);
    static LPCWSTR _QuerySysMetricStr(int idx, LPWSTR psz, UINT c);

    bool WasParseError() { return _fParseError; }
    HANDLE GetHandle(int iHandle) { return _pHList[iHandle]; }
    HINSTANCE GetHInstance() { return static_cast<HINSTANCE>(GetHandle(0)); }  // Always assume 0th item is the default HINSTANCE used

    static HRESULT ReplaceSheets(Element* pe, Parser* pFrom, Parser* pTo);

    DynamicArray<ElementNode*>* _pdaElementList;     // Root Element list
    DynamicArray<SheetNode*>* _pdaSheetList;         // Sheet list

    // Global parser context
    static Parser* g_pParserCtx;
    static bool g_fParseAbort;
    static HDC g_hDC;
    static int g_nDPI;
    static HRESULT g_hrParse;                        // Abnormal errors during parse

    Parser() { }
    HRESULT Initialize(const CHAR* pBuffer, int cCharCount, HANDLE* pHList, PPARSEERRORCB pfnErrorCB);
    HRESULT Initialize(UINT uRCID, HANDLE* pHList, PPARSEERRORCB pfnErrorCB);
    HRESULT Initialize(LPCWSTR pFile, HANDLE* pHList, PPARSEERRORCB pfnErrorCB);

    // Single HINSTANCE, setup internal default list
    // 0th entry is always default HINSTANCE when no handle is specified
    HRESULT Initialize(const CHAR* pBuffer, int cCharCount, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB) { _hDefault = hInst; return Initialize(pBuffer, cCharCount, &_hDefault, pfnErrorCB); }
    HRESULT Initialize(UINT uRCID, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB) { _hDefault = hInst; return Initialize(uRCID, &_hDefault, pfnErrorCB); }
    HRESULT Initialize(LPCWSTR pFile, HINSTANCE hInst, PPARSEERRORCB pfnErrorCB) { _hDefault = hInst; return Initialize(pFile, &_hDefault, pfnErrorCB); }

    virtual ~Parser();

    virtual bool ConvertEnum(LPCWSTR pszEnum, int* pEnum, PropertyInfo* ppi);
    virtual PLAYTCREATE ConvertLayout(LPCWSTR pszLayout);
    virtual IClassInfo* ConvertElement(LPCWSTR pszElement);

private:
    HRESULT _ParseBuffer(const CHAR* pBuffer, int cCharCount);
    void _DestroyTables();

    // Error handling
    bool _fParseError;
    PPARSEERRORCB _pfnErrorCB;

    // Input callback buffer and tracking
    const CHAR* _pInputBuf;
    int _dInputChars;
    int _dInputPtr;

    // Parse tree allocations and temporary parse-time only allocations
    DynamicArray<Node*>* _pdaNodeMemTrack;  // Parser nodes
    DynamicArray<void*>* _pdaMemTrack;      // Parser node extra memory
    DynamicArray<void*>* _pdaTempMemTrack;  // Temp parse-time only memory

    bool _FixupPropValPairNode(PropValPairNode* ppvpn, IClassInfo* pci, bool bRestrictVal);

    WCHAR _szDrive[MAX_PATH];   // Drive letter to the file being parsed
    WCHAR _szPath[MAX_PATH];    // Path to the file being parsed

    HANDLE* _pHList;            // Pointer to handle list used for exposing runtime handles during parse
    HANDLE _hDefault;           // Default handle list (1 item - default HINSTANCE) if no list is provided

    HRESULT _InstantiateElementNode(ElementNode* pn, Element* peSubstitute, Element* peParent, OUT Element** ppElement);
};

} // namespace DirectUI

#endif // DUI_PARSER_PARSEROBJ_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duininegridlayout.h ===
/*
 * NineGridLayout
 */

#ifndef DUI_NINEGRIDLAYOUT_H_INCLUDED
#define DUI_NINEGRIDLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// BorderLayout positions
#define NGLP_TopLeft     0
#define NGLP_Top         1
#define NGLP_TopRight    2
#define NGLP_Left        3
#define NGLP_Client      4
#define NGLP_Right       5
#define NGLP_BottomLeft  6
#define NGLP_Bottom      7
#define NGLP_BottomRight 8

////////////////////////////////////////////////////////
// NineGridLayout

class NineGridLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(OUT Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int dWidth, int dHeight);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual void OnAdd(Element* pec, Element** ppeAdd, UINT cCount);
    virtual void OnRemove(Element* pec, Element** ppeRemove, UINT cCount);
    virtual void OnLayoutPosChanged(Element* pec, Element* peChanged, int dOldLP, int dNewLP);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    NineGridLayout() { };
    void Initialize();   
    virtual ~NineGridLayout() { };

private:
    enum
    {
    };

    enum ESlot
    {
        Margin1  = 0,
        Left     = 1,
        Top      = 1,
        Margin2  = 2,
        Center   = 3,
        Margin3  = 4,
        Right    = 5,
        Bottom   = 5,
        Margin4  = 6,
        NumSlots = 7
    };

    enum EDim
    {
        X       = 0,
        Y       = 1,
        NumDims = 2
    };

    enum EConst
    {
        NumCells    = 9,
        CellsPerRow = 3
    };


    Element* _peTiles[NumCells];
    SIZE _sizeDesired;
    int _length[NumDims][NumSlots];

    void _UpdateTileList(int iTile, Element* pe);
};

} // namespace DirectUI

#endif // DUI_NINEGRIDLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiproxy.h ===
/*
 * Proxy
 */

#ifndef DUI_CORE_PROXY_H_INCLUDED
#define DUI_CORE_PROXY_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Proxy message

#define GM_PROXYINVOKE     GM_USER

BEGIN_STRUCT(GMSG_PROXYINVOKE, EventMsg)
    UINT nType;
    void* pData;
END_STRUCT(GMSG_PROXYINVOKE)


////////////////////////////////////////////////////////
// Proxy

class Proxy
{
public:
    Proxy();
    ~Proxy();

    static HRESULT CALLBACK SyncCallback(HGADGET hgadCur, void * pvCur, EventMsg * pGMsg);

protected:

    // Caller invoke
    void Invoke(UINT nType, void* pData);

    // Callee thread-safe invoke sink
    virtual void OnInvoke(UINT nType, void* pData);

    HGADGET _hgSync;
};

} // namespace DirectUI

#endif // DUI_CORE_PROXY_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiprogress.h ===
/*
 * Progress
 */

#ifndef DUI_CONTROL_PROGRESS_H_INCLUDED
#define DUI_CONTROL_PROGRESS_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Progress

// Class definition
class Progress : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Rendering overrides
    virtual void Paint(HDC hDC, const RECT* prcBounds, const RECT* prcInvalid, RECT* prcSkipBorder, RECT* prcSkipContent);
    virtual SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // Property definitions
    static PropertyInfo* PositionProp;
    static PropertyInfo* MinimumProp;
    static PropertyInfo* MaximumProp;

    // Quick property accessors
    int GetPosition()           DUIQuickGetter(int, GetInt(), Position, Specified)
    int GetMaximum()            DUIQuickGetter(int, GetInt(), Maximum, Specified)
    int GetMinimum()            DUIQuickGetter(int, GetInt(), Minimum, Specified)

    HRESULT SetPosition(int v)  DUIQuickSetter(CreateInt(v), Position)
    HRESULT SetMaximum(int v)   DUIQuickSetter(CreateInt(v), Maximum)
    HRESULT SetMinimum(int v)   DUIQuickSetter(CreateInt(v), Minimum)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Progress() { }
    HRESULT Initialize() { return Element::Initialize(0); }
    virtual ~Progress() { }
};

} // namespace DirectUI

#endif // DUI_CONTROL_PROGRESS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duininegrid.h ===
/*
 * NineGrid bitmap rendering (ported from UxTheme)
 */

#ifndef DUI_UTIL_NINEGRID_H_INCLUDED
#define DUI_UTIL_NINEGRID_H_INCLUDED

#pragma once

namespace DirectUI
{

//---------------------------------------------------------------------------
//#include "uxtheme.h"        // need MARGINS struct from here
typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

//#include "tmschema.h"       // need SIZINGTYPE, VALIGN, HALIGN enums from here
enum SIZINGTYPE
{
    ST_TRUESIZE,
    ST_STRETCH,
    ST_TILE,

    ST_TILEHORZ,
    ST_TILEVERT,
    ST_TILECENTER
};

enum HALIGN
{
    HA_LEFT,
    HA_CENTER,
    HA_RIGHT
};

enum VALIGN
{
    VA_TOP,
    VA_CENTER,
    VA_BOTTOM
};

//---------------------------------------------------------------------------
#ifndef HEIGHT
#define HEIGHT(rc) ((rc).bottom - (rc).top)
#endif
//---------------------------------------------------------------------------
#ifndef WIDTH
#define WIDTH(rc) ((rc).right - (rc).left)
#endif
//---------------------------------------------------------------------------
enum MBSIZING
{
    MB_COPY,
    MB_STRETCH,
    MB_TILE
};
//------------------------------------------------------------------------------------
struct BRUSHBUFF
{
    int iBuffLen;
    BYTE *pBuff;
};
//---------------------------------------------------------------------------
struct MBINFO
{
    DWORD dwSize;       // size of this struct (versioning support)

    HDC hdcDest;
    HDC hdcSrc;
    RECT rcClip;                    // don't draw outside this rect
    HBITMAP hBitmap;

    //---- for quick tiling ----
    BRUSHBUFF *pBrushBuff;

    //---- options ----
    DWORD dwOptions;                // subset DrawNineGrid() option flags

    POINT ptTileOrigin;             // for MBO_TILEORIGIN
    
    BITMAPINFOHEADER *pbmHdr;       // for MBO_DIRECTBITS
    BYTE *pBits;                    // for MBO_DIRECTBITS
    
    COLORREF crTransparent;         // for MBO_TRANSPARENT
    _BLENDFUNCTION AlphaBlendInfo;  // for MBO_ALPHABLEND

    HBRUSH *pCachedBrushes;         // for DNG_CACHEBRUSHES
    int iCacheIndex;                // which brush to use
};
//---------------------------------------------------------------------------
//---- DrawNineGrid() "dwOptions" bits ----

//---- shared with MultiBlt()  ----
#define DNG_ALPHABLEND     (1 << 0)     // use AlphaBlendInfo
#define DNG_TRANSPARENT    (1 << 1)     // transparancy defined by crTransparent
#define DNG_TILEORIGIN     (1 << 2)     // use ptTileOrigin
#define DNG_DIRECTBITS     (1 << 3)     // use pbmHdr & pBits
#define DNG_CACHEBRUSHES   (1 << 4)     // use/set pCachedBrushes
#define DNG_MANUALTILING   (1 << 5)     // loop thru BitBlt's
#define DNG_DIRECTBRUSH    (1 << 6)     // create brushes from temp. extracted DIB's
#define DNG_FLIPGRIDS      (1 << 7)    // all grid images should be flipped

//---- used only by DrawNineGrid()  ----
#define DNG_OMITBORDER     (1 << 16)    // don't draw border
#define DNG_OMITCONTENT    (1 << 17)    // don't draw middle 
#define DNG_SOLIDBORDER    (1 << 18)    // sample borders and draw as solid colors
#define DNG_SOLIDCONTENT   (1 << 19)    // sample content as draw as solid color
#define DNG_BGFILL         (1 << 20)    // use crFill for ST_TRUESIZE
//------------------------------------------------------------------------------------
struct NGINFO
{
    DWORD dwSize;       // size of this struct (versioning support)

    HDC hdcDest;
    RECT rcClip;                    // don't draw outside this rect
    SIZINGTYPE eImageSizing;
    HBITMAP hBitmap;
    RECT rcSrc;             // where to get bits from
    RECT rcDest;            // where to draw bits to
    int iDestMargins[4];   
    int iSrcMargins[4];  

    //---- for quick tiling ----
    BRUSHBUFF *pBrushBuff;

    //---- options ----
    DWORD dwOptions;

    POINT ptTileOrigin;             // for DNG_TILEORIGIN
    
    BITMAPINFOHEADER *pbmHdr;       // for DNG_DIRECTBITS
    BYTE *pBits;                    // for DNG_DIRECTBITS
    
    COLORREF crTransparent;         // for DNG_TRANSPARENT
    _BLENDFUNCTION AlphaBlendInfo;  // for DNG_ALPHABLEND

    HBRUSH *pCachedBrushes;         // for DNG_CACHEBRUSHES

    COLORREF *pcrBorders;           // for DNG_SOLIDBORDERS, DNG_SOLIDCONTENT

    //---- for ST_TRUESIZE images smaller than rcDest ----
    COLORREF crFill;      
    VALIGN eVAlign;
    HALIGN eHAlign;
};
//---------------------------------------------------------------------------
HRESULT MultiBlt(MBINFO *pmb, MBSIZING eSizing, int iDestX, int iDestY, int iDestW, int iDestH,
     int iSrcX, int iSrcY, int iSrcW, int iSrcH);

HRESULT DrawNineGrid(NGINFO *png);
//---------------------------------------------------------------------------

} // namespace DirectUI

#endif // DUI_UTIL_NINEGRID_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duirowlayout.h ===
/*
 * RowLayout
 */

#ifndef DUI_LAYOUT_ROWLAYOUT_H_INCLUDED
#define DUI_LAYOUT_ROWLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

////////////////////////////////////////////////////////
// RowLayout

class RowLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, OUT Value** ppValue);  // For parser
    static HRESULT Create(int idShare, UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout);

    virtual void Attach(Element* pec);
    virtual void Detach(Element* pec);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int cx, int cy);
    virtual SIZE UpdateDesiredSize(Element* pec, int cxConstraint, int cyConstraint, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyableOnly);

    RowLayout() { }
    static HRESULT InternalCreate(UINT uXAlign, UINT uYAlign, OUT Layout** ppLayout);
    void Initialize(UINT uXAlign, UINT uYAlign);
    virtual ~RowLayout();

protected:
    SIZE _sizeDesired;
    BOOL _fRecalc;
    DynamicArray<Element*>* _arpeClients;
    UINT* _arxCols;
    UINT _cCols;
    UINT _uXAlign;
    UINT _uYAlign;
};

} // namespace DirectUI

#endif // DUI_LAYOUT_ROWLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duirefpointelement.h ===
/*
 * RefPointElement
 */

#ifndef DUI_CONTROL_REFPOINTELEMENT_H_INCLUDED
#define DUI_CONTROL_REFPOINTELEMENT_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// RefPointElement

// Class definition
class RefPointElement : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_Inactive, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System Events
    //virtual void OnGroupChanged(int fGroups, bool bLowPri);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Global helpers
    static Element* FindRefPoint(Element* pe, POINT* ppt);
    static RefPointElement* Locate(Element* pe);

    // Property definitions
    static PropertyInfo* ReferencePointProp;
    static PropertyInfo* ActualReferencePointProp;

    // Quick property accessors
    const POINT* GetReferencePoint(Value** ppv)         { *ppv = GetValue(ReferencePointProp, PI_Local); return (*ppv != Value::pvUnset) ? (*ppv)->GetPoint() : NULL; }
    const POINT* GetActualReferencePoint(Value** ppv)   DUIQuickGetterInd(GetPoint(), ActualReferencePoint, Specified)
    
    HRESULT SetReferencePoint(int x, int y)             DUIQuickSetter(CreatePoint(x, y), ReferencePoint)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    RefPointElement() { }
    HRESULT Initialize(UINT nActive);
    virtual ~RefPointElement() { }
};

} // namespace DirectUI

#endif // DUI_CONTROL_REFPOINTELEMENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duirepeatbutton.h ===
/*
 * RepeatButton
 */

#ifndef DUI_CONTROL_REPEATBUTTON_H_INCLUDED
#define DUI_CONTROL_REPEATBUTTON_H_INCLUDED

#pragma once

#include "duibutton.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// RepeatButton

// Class definition
class RepeatButton : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();
    
    RepeatButton() { }
    HRESULT Initialize(UINT nActive);
    virtual ~RepeatButton() { }

private:
    static void CALLBACK _RepeatButtonActionCallback(GMA_ACTIONINFO* pmai);
    
    HACTION _hAction;
    BOOL _fActionDelay;
};

} // namespace DirectUI

#endif // DUI_CONTROL_REPEATBUTTON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiscrollviewer.h ===
/*
 * ScrollViewer
 */

#ifndef DUI_CONTROL_SCROLLVIEWER_H_INCLUDED
#define DUI_CONTROL_SCROLLVIEWER_H_INCLUDED

#pragma once

#include "duiscrollbar.h"
#include "duiviewer.h"

namespace DirectUI
{

#define BV_AsNeeded 0
#define BV_Never    1
#define BV_Always   2

// Auto-pinning support
#define P_None      0
#define P_Horz      1
#define P_Vert      2

////////////////////////////////////////////////////////
// ScrollViewer

// Class definition
class ScrollViewer : public Element, public IElementListener
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);
    virtual void OnInput(InputEvent* pie);

    // System events
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Hierarchy
    virtual HRESULT Add(Element** ppe, UINT cCount);

    // Listener impl
    virtual void OnListenerAttach(Element* peFrom) { peFrom; }
    virtual void OnListenerDetach(Element* peFrom) { peFrom; }
    virtual bool OnListenedPropertyChanging(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew) { peFrom; ppi; iIndex; pvOld; pvNew; return true; }
    virtual void OnListenedPropertyChanged(Element* peFrom, PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnListenedInput(Element* peFrom, InputEvent* pInput) { peFrom; pInput; }
    virtual void OnListenedEvent(Element* peFrom, Event* pEvent) { peFrom; pEvent; }

    // Property definitions
    static PropertyInfo* XOffsetProp;
    static PropertyInfo* YOffsetProp;
    static PropertyInfo* XScrollableProp;
    static PropertyInfo* YScrollableProp;
    static PropertyInfo* XBarVisibilityProp;
    static PropertyInfo* YBarVisibilityProp;
    static PropertyInfo* PinningProp;

    // Quick property accessors
    ScrollBar* GetXScrollBar()          { return _peHScroll; }
    ScrollBar* GetYScrollBar()          { return _peVScroll; }
    
    int GetXOffset()                    DUIQuickGetter(int, GetInt(), XOffset, Specified)
    int GetYOffset()                    DUIQuickGetter(int, GetInt(), YOffset, Specified)
    bool GetXScrollable()               DUIQuickGetter(bool, GetBool(), XScrollable, Specified)
    bool GetYScrollable()               DUIQuickGetter(bool, GetBool(), YScrollable, Specified)
    int GetXBarVisibility()             DUIQuickGetter(int, GetInt(), XBarVisibility, Specified)
    int GetYBarVisibility()             DUIQuickGetter(int, GetInt(), YBarVisibility, Specified)
    int GetPinning()                    DUIQuickGetter(int, GetInt(), Pinning, Specified)

    HRESULT SetXOffset(int v)           DUIQuickSetter(CreateInt(v), XOffset)
    HRESULT SetYOffset(int v)           DUIQuickSetter(CreateInt(v), YOffset)
    HRESULT SetXScrollable(bool v)      DUIQuickSetter(CreateBool(v), XScrollable)
    HRESULT SetYScrollable(bool v)      DUIQuickSetter(CreateBool(v), YScrollable)
    HRESULT SetXBarVisibility(int v)    DUIQuickSetter(CreateInt(v), XBarVisibility)
    HRESULT SetYBarVisibility(int v)    DUIQuickSetter(CreateInt(v), YBarVisibility)
    HRESULT SetPinning(int v)           DUIQuickSetter(CreateInt(v), Pinning)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ScrollViewer() { }
    HRESULT Initialize();
    virtual ~ScrollViewer() { }

protected:

    ScrollBar* _peHScroll;
    ScrollBar* _peVScroll;
    Viewer*    _peViewer;
    Element*   _peContent;

private:
    void CheckScroll(ScrollBar* psb, BOOL fScrollable, int iVisibility);

};

} // namespace DirectUI

#endif // DUI_CONTROL_SCROLLVIEWER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiselector.h ===
/*
 * Selector
 */

#ifndef DUI_CONTROL_SELECTOR_H_INCLUDED
#define DUI_CONTROL_SELECTOR_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Selector

// SelectionChange event
struct SelectionChangeEvent : Event
{
    Element* peOld;
    Element* peNew;
};

// Class definition
class Selector : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);
 
    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnInput(InputEvent* pInput);                                                    // Routed and bubbled
    virtual void OnKeyFocusMoved(Element *peFrom, Element *peTo);

    // Hierarchy
    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);

    // Event types
    static UID SelectionChange;

    // Property definitions
    static PropertyInfo* SelectionProp;

    // Quick property accessors
    Element* GetSelection()             DUIQuickGetter(Element*, GetElement(), Selection, Specified)

    HRESULT SetSelection(Element* v)    DUIQuickSetter(CreateElementRef(v), Selection)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Selector() { }
    HRESULT Initialize() { return Element::Initialize(0); }
    virtual ~Selector() { }
};

} // namespace DirectUI

#endif // DUI_CONTROL_SELECTOR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duisballoc.h ===
/*
 * Fixed-Size Small Block Allocator
 */

#ifndef DUI_BASE_SBALLOC_H_INCLUDED
#define DUI_BASE_SBALLOC_H_INCLUDED

#pragma once

#include "duialloc.h"

namespace DirectUI
{

#define SBALLOC_FILLCHAR    0xFE

struct ISBLeak  // Leak detector, not ref counted
{
    virtual void AllocLeak(void* pBlock) = 0;
};

struct SBSection
{
    SBSection* pNext;
    BYTE* pData;
};

class SBAlloc
{
public:
    static HRESULT Create(UINT uBlockSize, UINT uBlocksPerSection, ISBLeak* pisbLeak, SBAlloc** ppSBA);
    void Destroy();

    void* Alloc();
    void Free(void* pBlock);

    SBAlloc() { }
    virtual ~SBAlloc();

private:
    bool _FillStack();

    UINT _uBlockSize;
    UINT _uBlocksPerSection;
    SBSection* _pSections;
    BYTE** _ppStack;  // Free block cache
    int _dStackPtr;
    ISBLeak* _pisbLeak;
};

} // namespace DirectUI

#endif // DUI_BASE_SBALLOC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duisheet.h ===
/*
 * PropertySheet
 */

#ifndef DUI_CORE_SHEET_H_INCLUDED
#define DUI_CORE_SHEET_H_INCLUDED

#pragma once

namespace DirectUI
{

/*
 * PropertySheets are used as extensions to the unchangeable value expression used
 * for Specified value retrieval on Elements. They provide three main services:
 *
 * * The ability to describe conditional relationships (dependencies) on a per-class level
 * * Values can be overridden by setting a local value on the Element
 * * They can be described declaratively using a CSS-like grammar
 *
 * PropertySheets are a type of value expression (but limited). Thus, they provide
 * a way to change values of properties based on other property changes without hard coding
 * the logic within a derived class of Element (using OnPropertyChanged).
 *
 * Only properties with the "Cascade" flag may be placed in the body of a Rule. Properties
 * that should be marked as cascadable are those that need to be updated based on changes
 * of other properties, but shouldn't be assumed at compile-time what these relationships
 * are. Such properties include any property that drives painting code directly (color,
 * fonts, padding, etc.).
 */

// Foreward declarations
class Value;
struct PropertyInfo;
class Element;
struct IClassInfo;
struct DepRecs;
class DeferCycle;

////////////////////////////////////////////////////////
// Rule addition structures

// Declaration PropertyInfo/Value tuple
struct Decl
{
    PropertyInfo* ppi;    // Implicit index of Specified
    Value* pv;
};

// Single rule conditional (l-operand op r-operand): <PropertyInfo[RetrievalIndex]> <LogOp> <Value>
struct Cond
{
    PropertyInfo* ppi;    // Implicit index of Retrieval index
    UINT nLogOp;
    Value* pv;
};

// PropertySheet Logical operations (nLogOp)
#define PSLO_Equal      0
#define PSLO_NotEqual   1

////////////////////////////////////////////////////////
// Internal database structures

// Conditional to value map
struct CondMap
{
    Cond* pConds;         // NULL terminated
    Value* pv;
    UINT uSpecif;
};

// Dependent list, used for sheet scope and propertyinfo data (conditionals/dependencies)
struct DepList
{
    PropertyInfo** pDeps; // Implicit index of Specified
    UINT cDeps;
};

// Storage for property-specific information
struct PIData : DepList
{
    // Used for PropertyInfo[Specified] lookups. The PropertyInfo will have
    // a list of conditionals (sorted by specificity)
    CondMap* pCMaps;
    UINT cCMaps;
};

// Stored by _pDB, one record per class type
struct Record
{
    DepList ss;    // Sheet scope
    PIData* ppid;  // 0th property data
};

////////////////////////////////////////////////////////
// PropertySheet

class PropertySheet
{
public:
    static HRESULT Create(OUT PropertySheet** ppSheet);
    void Destroy() { HDelete<PropertySheet>(this); }

    HRESULT AddRule(IClassInfo* pci, Cond* pConds, Decl* pDecls);  // Conds and Decls must be NULL or NULL-terminating
    void MakeImmutable();

    Value* GetSheetValue(Element* pe, PropertyInfo* ppi);
    void GetSheetDependencies(Element* pe, PropertyInfo* ppi, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr);
    void GetSheetScope(Element* pe, DepRecs* pdr, DeferCycle* pdc, HRESULT* phr);

    PropertySheet() { }
    HRESULT Initialize();    
    virtual ~PropertySheet();
    
private:
    Record* _pDB;  // Array of per-class data
    IClassInfo** _pCIIdxMap;  // Map _pDB indicies to actual IClassInfo
    UINT _uRuleId;
    DynamicArray<Cond*>* _pdaSharedCond;
    bool _fImmutable;
};

} // namespace DirectUI

#endif // DUI_CORE_SHEET_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duithread.h ===
/*
 * Thread methods, local storage
 */

#ifndef DUI_CORE_THREAD_H_INCLUDED
#define DUI_CORE_THREAD_H_INCLUDED

#pragma once

namespace DirectUI
{

/////////////////////////////////////////////////////////////////////////////
// Synchronization lock

class Lock
{
public:
    Lock() { InitializeCriticalSection(&_cs); }
    ~Lock() { DeleteCriticalSection(&_cs); }
    void Enter() { EnterCriticalSection(&_cs); }
    void Leave() { LeaveCriticalSection(&_cs); }

private:
    CRITICAL_SECTION _cs;
};

extern Lock* g_plkParser;

/////////////////////////////////////////////////////////////////////////////
// Initialization

HRESULT InitProcess();
HRESULT UnInitProcess();

HRESULT InitThread();
HRESULT UnInitThread();

// Control library class registration
HRESULT RegisterAllControls();

/////////////////////////////////////////////////////////////////////////////
// Message pump

void StartMessagePump();
void StopMessagePump();

} // namespace DirectUI

#endif // DUI_CORE_THREAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiscrollbar.h ===
/*
 * ScrollBar
 */

#ifndef DUI_CONTROL_SCROLLBAR_H_INCLUDED
#define DUI_CONTROL_SCROLLBAR_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// ScrollBar

// Scroll bar layout order
#define SBO_Normal          0x00043210
#define SBO_ArrowsAtTop     0x00032140
#define SBO_ArrowsAtBottom  0x00040321

// Scroll event
struct ScrollEvent : Event
{
    int dPos;
};

// Class definition
class ScrollBar : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(true, ppElement); }
    static HRESULT Create(bool fBuildSubTree, OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // Event types
    static UID Scroll;

    // Property definitions
    static PropertyInfo* PositionProp;
    static PropertyInfo* MinimumProp;
    static PropertyInfo* MaximumProp;
    static PropertyInfo* PageProp;
    static PropertyInfo* LineProp;
    static PropertyInfo* VerticalProp;
    static PropertyInfo* ProportionalProp;
    static PropertyInfo* OrderProp;

    // Quick property accessors
    int GetPosition()                   DUIQuickGetter(int, GetInt(), Position, Specified)
    int GetMaximum()                    DUIQuickGetter(int, GetInt(), Maximum, Specified)
    int GetMinimum()                    DUIQuickGetter(int, GetInt(), Minimum, Specified)
    int GetPage()                       DUIQuickGetter(int, GetInt(), Page, Specified)
    int GetLine()                       DUIQuickGetter(int, GetInt(), Line, Specified)
    int GetOrder()                      DUIQuickGetter(int, GetInt(), Order, Specified) 
    bool GetProportional()              DUIQuickGetter(bool, GetBool(), Proportional, Specified)
    bool GetVertical()                  DUIQuickGetter(bool, GetBool(), Vertical, Specified)

    HRESULT SetPosition(int v)          DUIQuickSetter(CreateInt(v), Position) 
    HRESULT SetMaximum(int v)           DUIQuickSetter(CreateInt(v), Maximum) 
    HRESULT SetMinimum(int v)           DUIQuickSetter(CreateInt(v), Minimum) 
    HRESULT SetPage(int v)              DUIQuickSetter(CreateInt(v), Page) 
    HRESULT SetLine(int v)              DUIQuickSetter(CreateInt(v), Line) 
    HRESULT SetOrder(int v)             DUIQuickSetter(CreateInt(v), Order) 
    HRESULT SetProportional(bool v)     DUIQuickSetter(CreateBool(v), Proportional)
    HRESULT SetVertical(bool v)         DUIQuickSetter(CreateBool(v), Vertical) 

    int LineUp(UINT nCount = 1)     { SetPosition(GetPosition() - (nCount * GetLine()));    return GetPosition(); }
    int LineDown(UINT nCount = 1)   { SetPosition(GetPosition() + (nCount * GetLine()));    return GetPosition(); }
    int PageUp(UINT nCount = 1)     { SetPosition(GetPosition() - (nCount * GetPageInc())); return GetPosition(); }
    int PageDown(UINT nCount = 1)   { SetPosition(GetPosition() + (nCount * GetPageInc())); return GetPosition(); }
    int Home()                      { SetPosition(GetMinimum());                            return GetPosition(); }
    int End()                       { SetPosition(GetMaximum());                            return GetPosition(); }

    bool IsScrollable();
    bool IsPinned() { return _fPinned; }

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    ScrollBar() { }
    HRESULT Initialize(bool fBuildSubTree);
    virtual ~ScrollBar() { }

protected:

#define SP_LineUp   0
#define SP_PageUp   1
#define SP_Thumb    2
#define SP_PageDown 3
#define SP_LineDown 4
#define SP_Count    5

    Element* _peParts[SP_Count];

#define _peLineUp   _peParts[SP_LineUp]
#define _peLineDown _peParts[SP_LineDown]
#define _pePageUp   _peParts[SP_PageUp]
#define _pePageDown _peParts[SP_PageDown]
#define _peThumb    _peParts[SP_Thumb]

private:

    int GetPageInc();

    int _posTop;
    int _cTrack;

    bool _fPinned;
};

} // namespace DirectUI

#endif // DUI_CONTROL_SCROLLBAR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duithumb.h ===
/*
 * Thumb
 */

#ifndef DUI_CONTORL_THUMB_H_INCLUDED
#define DUI_CONTORL_THUMB_H_INCLUDED

#pragma once

#include "duibutton.h"

namespace DirectUI
{

////////////////////////////////////////////////////////
// Thumb

// ThumbDrag event
struct ThumbDragEvent : Event
{
    SIZE sizeDelta;
};

// Class definition
class Thumb : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_Mouse, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    // Event types
    static UID Drag;

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Thumb() { }
    HRESULT Initialize(UINT nActive) { return Button::Initialize(nActive); }
    virtual ~Thumb() { }
};

} // namespace DirectUI

#endif // DUI_CONTORL_THUMB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duisurface.h ===
/*
 * Surface
 */

#ifndef DUI_BASE_SURFACE_H_INCLUDED
#define DUI_BASE_SURFACE_H_INCLUDED

#pragma once

#pragma warning(disable: 4127)  // conditional expression is constant

namespace DirectUI
{

////////////////////////////////////////////////////////
// Surface

class Surface
{
public:
    enum EType
    {
        stDC      = GSURFACE_HDC,
#ifdef GADGET_ENABLE_GDIPLUS
        stGdiPlus = GSURFACE_GPGRAPHICS
#endif
    };

    virtual EType GetType() const PURE;
    inline static Surface::EType GetSurfaceType(UINT nSurfaceType);
    inline static UINT GetSurfaceType(Surface::EType type);
};

class DCSurface : public Surface
{
public:
    inline DCSurface(HDC hdc) { _hdc = hdc; }
    inline HDC GetHDC() { return _hdc; }

    virtual EType GetType() const { return Surface::stDC; }
    
protected:
    HDC _hdc;
};

#ifdef GADGET_ENABLE_GDIPLUS

class GpSurface : public Surface
{
public:
    inline GpSurface(Gdiplus::Graphics* pgpgr) { _pgpgr = pgpgr; }
    inline Gdiplus::Graphics* GetGraphics() { return _pgpgr; }

    virtual EType GetType() const { return Surface::stGdiPlus; }
    
protected:
    Gdiplus::Graphics* _pgpgr;
};

#endif // GADGET_ENABLE_GDIPLUS

inline Surface::EType Surface::GetSurfaceType(UINT nSurfaceType)
{
    DUIAssert(stDC == GSURFACE_HDC, "ID's must match");
    return (EType)nSurfaceType;
}

inline UINT Surface::GetSurfaceType(Surface::EType type)
{
    DUIAssert(stDC == GSURFACE_HDC, "ID's must match");
    return (UINT) type;
}

inline HDC CastHDC(Surface* psrf)
{
    DUIAssert(psrf->GetType() == Surface::stDC, "Must be an HDC surface");
    return ((DCSurface*)psrf)->GetHDC();
}

#ifdef GADGET_ENABLE_GDIPLUS

inline Gdiplus::Graphics* CastGraphics(Surface* psrf)
{
    DUIAssert(psrf->GetType() == Surface::stGdiPlus, "Must be a GDI+ surface");
    return ((GpSurface*)psrf)->GetGraphics();
}

#endif // GADGET_ENABLE_GDIPLUS


//
// Some handy alpha-value operations that are used throughout DirectUI
//

#define ARGB(a, r, g, b)    ((a << 24) | RGB(r, g, b))          // Current A values may be 255 (opaque) or 0 (transparent)
#define ORGB(r, g, b)       ARGB(255, r, g, b)                  // Opaque color
#define GetAValue(v)        ((BYTE)((v & 0xFF000000) >> 24))

}; // namespace DirectUI

#endif // DUI_BASE_SURFACE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiverticalflowlayout.h ===
/*
 * Verticalflowlayout
 */

#ifndef DUI_LAYOUT_VERTICALFLOWLAYOUT_H_INCLUDED
#define DUI_LAYOUT_VERTICALFLOWLAYOUT_H_INCLUDED

#pragma once

namespace DirectUI
{

// No layout positions

struct VLINE
{
    UINT cy;             // length of line
    UINT cx;             // thickness of line
    UINT x;              // pixel start of line (always 0 for first line)
    UINT cElements;      // number of elements in line
    UINT* aryElement;    // pixel start of elements in line (one less than cElements -- because first start is always 0)
    UINT iStart;         // index of first element in line
};
    
////////////////////////////////////////////////////////
// vertical flow layout

class VerticalFlowLayout : public Layout
{
public:
    static HRESULT Create(int dNumParams, int* pParams, Value** ppValue);  // For parser
    static HRESULT Create(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign, Layout** ppLayout);

    // Layout callbacks
    virtual void DoLayout(Element* pec, int cx, int cy);
    virtual SIZE UpdateDesiredSize(Element* pec, int dConstW, int dConstH, Surface* psrf);
    virtual Element* GetAdjacent(Element* pec, Element* peFrom, int iNavDir, NavReference const* pnr, bool fKeyableOnly);

    int GetLine(Element* pec, Element* pe);

    VerticalFlowLayout() { }
    void Initialize(bool fWrap, UINT uXAlign, UINT uXLineAlign, UINT uYLineAlign);
    virtual ~VerticalFlowLayout();

protected:
    SIZE BuildCacheInfo(Element *pec, int cxConstraint, int cyConstraint, Surface* psrf, bool fRealSize);

    bool _fWrap;
    UINT _uXLineAlign;
    UINT _uYLineAlign;
    UINT _uXAlign;
    SIZE _sizeDesired;
    SIZE _sizeLastConstraint;
    UINT _cLines;
    VLINE* _arLines;

    static SIZE g_sizeZero;
};

} // namespace DirectUI

#endif // DUI_LAYOUT_VERTICALFLOWLAYOUT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duivaluemap.h ===
/*
 * Value map
 */

#ifndef DUI_BASE_VALUEMAP_H_INCLUDED
#define DUI_BASE_VALUEMAP_H_INCLUDED

#pragma once

namespace DirectUI
{

//-------------------------------------------------------------------------
//
// ValueMap
//
// Stores Key/Value pairs
//
// Compile DEBUG for DUIAsserts, see public class declarations for API
//
// Keys and Values are stored natively and the type of each can be chosen
// at compile time. For example (Key is an int, Value is a string pointer,
// and the map will have 5 buckets):
//
// ValueMap<int,LPWSTR>* pvm;
// ValueMap<int,LPWSTR>::Create(5, &pvm);
// pvm->SetItem(1150, L"One thousand one hundred and fifty");
// LPWSTR psz;
// pvm->GetItem(1150, &psz);
// DUITrace("%s\n", psz);
//
// The Key type must support the following operations:
//    Assignment (=)
//    Int cast for finding bucket (int)
//    Equality (==)
//
// The Value type must support the following operation:
//    Assignment (=)
//
// Given the above, a key can be created based on a string where the
// correct mapping occurs even though the instance of the string is different.
//
//    class StringKey
//    {
//    public:
//        StringKey(LPWSTR);
//        operator =(LPWSTR);
//        BOOL operator ==(StringKey);
//        operator INT_PTR();
//
//    private:
//        LPWSTR pszStr;
//    };
//
//    StringKey::StringKey(LPWSTR pstr)
//    {
//        pszStr = pstr;
//    }
//
//    StringKey::operator =(LPWSTR pstr)
//    {
//        pszStr = pstr;
//    }
//
//    BOOL StringKey::operator ==(StringKey st)
//    {
//        return wcscmp(pszStr, st.pszStr) == 0;
//    }
//
//    StringKey::operator INT_PTR()  // Create hash code from string
//    {
//        int dHash = 0;
//        LPWSTR pstr = pszStr;
//        WCHAR c;
//
//        while (*pstr)
//        {
//            c = *pstr++;
//            dHash += (c << 1) + (c >> 1) + c;
//        }
//
//        return dHash;
//    }
//
// It's usage would be:
//
// ValueMap<StringKey, int> v(11);
//
// v.SetItem(L"My favorite number", 4);
// v.SetItem(L"Your favorite number", 8);
//
// Trace1(L"Mine : %d\n", *v.GetItem(L"My favorite number");      // 4
// Trace1(L"Yours: %d\n", *v.GetItem(L"Your favorite number");    // 8
//
// v.SetItem(L"My favorite number", 5150);
//
// Trace1(L"Mine : %d\n", *v.GetItem(L"My favorite number");      // 5150
//
// v.Remove(L"Your favorite number";
//
// DUIAssert(!v.ContainsKey(L"Your favorite number"), "Error!");    // Mapping is removed
//
//-------------------------------------------------------------------------

template <typename K, typename D> class ValueMap
{
    typedef struct _ENTRY
    {
        bool fInUse;
        K tKey;
        D tData;
        struct _ENTRY* peNext;

    } ENTRY, *PENTRY;

    typedef void (*VMENUMCALLBACK)(K tKey, D tData);

public:                                     // API
    static HRESULT Create(UINT uBuckets, OUT ValueMap<K,D>** ppMap);
    virtual ~ValueMap();
    void Destroy() { HDelete< ValueMap<K,D> >(this); }

    D* GetItem(K, bool);                    // Pointer to Value (NULL if doesn't exist, internal copy returned)
    HRESULT SetItem(K, D*, bool);           // Setup Key/Value map, creates new is doesn't exist (via indirection)
    HRESULT SetItem(K, D, bool);            // Setup Key/Value map, creates new is doesn't exist
    void Remove(K, bool, bool);             // Removes Key/Value map, ok if Key doesn't exist
    void Enum(VMENUMCALLBACK pfnCallback);  // Callback with every item in map
    bool IsEmpty();                         // True if no entries
    K* GetFirstKey();                       // Returns pointer to first key found in table
    HRESULT GetDistribution(WCHAR**);       // Returns a null terminated string describing table distribution (must HFree)

    ValueMap() { }
    HRESULT Initialize(UINT uBuckets);

private:
    UINT _uBuckets;
    PENTRY* _ppBuckets;
};

template <typename K, typename D> HRESULT ValueMap<K,D>::Create(UINT uBuckets, OUT ValueMap<K,D>** ppMap)
{
    DUIAssert(uBuckets > 0, "Must create at least one bucket in ValueMap");

    *ppMap = NULL;

    // Instantiate
    ValueMap<K,D>* pvm = HNew< ValueMap<K,D> >();
    if (!pvm)
        return E_OUTOFMEMORY;

    HRESULT hr = pvm->Initialize(uBuckets);
    if (FAILED(hr))
    {
        pvm->Destroy();
        return hr;
    }

    *ppMap = pvm;

    return S_OK;
}

template <typename K, typename D> HRESULT ValueMap<K,D>::Initialize(UINT uBuckets)
{
    _uBuckets = uBuckets;
    _ppBuckets = (PENTRY*)HAllocAndZero(sizeof(PENTRY) * _uBuckets);

    if (!_ppBuckets)
    {
        // Object isn't created if buckets cannot be allocated
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

template <typename K, typename D> ValueMap<K,D>::~ValueMap()
{
    PENTRY pe;
    PENTRY peNext;

    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe != NULL)
        {
            peNext = pe->peNext;
            HFree(pe);

            pe = peNext;
        }
    }

    HFree(_ppBuckets);
}

template <typename K, typename D> void ValueMap<K,D>::Enum(VMENUMCALLBACK pfnCallback)
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe)
        {
            if (pe->fInUse)
                pfnCallback(pe->tKey, pe->tData);

            pe = pe->peNext;
        }
    }
}

template <typename K, typename D> K* ValueMap<K,D>::GetFirstKey()
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe)
        {
            if (pe->fInUse)
                return &pe->tKey;

            pe = pe->peNext;
        }
    }

    return NULL;
}

template <typename K, typename D> D* ValueMap<K,D>::GetItem(K tKey, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    // Search for items in buckets

    PENTRY pe = _ppBuckets[(UINT)(((fKeyIsPtr) ? (int)tKey >> 2 : (int)tKey) % _uBuckets)];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        pe = pe->peNext;
    }

    return (pe) ? &pe->tData : NULL;
}

// Stores the value of tData (via indirection)
template <typename K, typename D> HRESULT ValueMap<K,D>::SetItem(K tKey, D* pData, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pUnused = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (int)tKey >> 2 : (int)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        if (!pe->fInUse)
        {
            pUnused = pe;
        }

        pe = pe->peNext;
    }

    if (pe)
    {
        // Item found
        pe->tData = *pData;
    }
    else
    {
        // Reuse or create new item
        if (pUnused)
        {
            pUnused->fInUse = true;
            pUnused->tKey = tKey;
            pUnused->tData = *pData;
        }
        else
        {
            pe = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!pe)
                return E_OUTOFMEMORY;

            pe->fInUse = true;
            pe->tKey = tKey;
            pe->tData = *pData;
            pe->peNext = _ppBuckets[uBucket];

            _ppBuckets[uBucket] = pe;
        }
    }

    return S_OK;
}

// Stores the value of tData
template <typename K, typename D> HRESULT ValueMap<K,D>::SetItem(K tKey, D tData, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pUnused = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (UINT_PTR)tKey >> 2 : (INT_PTR)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        if (!pe->fInUse)
        {
            pUnused = pe;
        }

        pe = pe->peNext;
    }

    if (pe)
    {
        // Item found
        pe->tData = tData;
    }
    else
    {
        // Reuse or create new item
        if (pUnused)
        {
            pUnused->fInUse = true;
            pUnused->tKey = tKey;
            pUnused->tData = tData;
        }
        else
        {
            pe = (PENTRY)HAlloc(sizeof(ENTRY));
            if (!pe)
                return E_OUTOFMEMORY;

            pe->fInUse = true;
            pe->tKey = tKey;
            pe->tData = tData;
            pe->peNext = _ppBuckets[uBucket];

            _ppBuckets[uBucket] = pe;
        }
    }

    return S_OK;
}

template <typename K, typename D> void ValueMap<K,D>::Remove(K tKey, bool fFree, bool fKeyIsPtr)
{
    // Pointer based keys are shifted for better distribution

    PENTRY pe;
    PENTRY pePrev = NULL;
    UINT uBucket = (UINT)(((fKeyIsPtr) ? (UINT_PTR)tKey >> 2 : (INT_PTR)tKey) % _uBuckets);

    // Search for items in buckets
    pe = _ppBuckets[uBucket];

    while (pe && !(pe->fInUse && (pe->tKey == tKey)))
    {
        pePrev = pe;      // Keep the previous item
        pe = pe->peNext;
    }

    if (pe)
    {
        if (fFree)
        {
            if (pePrev != NULL)
            {
                pePrev->peNext = pe->peNext;
            }
            else
            {
                _ppBuckets[uBucket] = pe->peNext;
            }

            HFree(pe);
        }
        else
        {
            pe->fInUse = false;
        }
    }
}

template <typename K, typename D> bool ValueMap<K,D>::IsEmpty()
{
    PENTRY pe;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];
        while (pe != NULL)
        {
            if (pe->fInUse)
                return false;

            pe = pe->peNext;
        }
    }

    return true;
}

template <typename K, typename D> HRESULT ValueMap<K,D>::GetDistribution(OUT WCHAR** ppszDist)
{
    *ppszDist = NULL;

    LPWSTR pszOut = (LPWSTR)HAlloc((256 + _uBuckets * 24) * sizeof(WCHAR));
    if (!pszOut)
        return E_OUTOFMEMORY
        
    WCHAR pszBuf[151];

    swprintf(pszOut, L"Buckets for %x (Slots InUse/Total): %d - ", this, _uBuckets);

    PENTRY pe;
    UINT cInUse;
    UINT cCount;
    for (UINT i = 0; i < _uBuckets; i++)
    {
        pe = _ppBuckets[i];

        cInUse = 0;
        cCount = 0;

        while (pe)
        {
            cCount++;
            if (pe->fInUse)
                cInUse++;

            pe = pe->peNext;
        }

        swprintf(pszBuf, L"(B%d): %d/%d ", i, cInUse, cCount);
        wcscat(pszOut, pszBuf);
    }

    return pszOut;
}

} // namespace DirectUI

#endif // DUI_BASE_VALUEMAP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiuidgen.h ===
/*
 * Unique ID generator (application-wide uniqueness)
 */

#ifndef DUI_BASE_UIDGEN_H_INCLUDED
#define DUI_BASE_UIDGEN_H_INCLUDED

namespace DirectUI
{

#define UID BYTE*
#define DefineUniqueID(name) BYTE _uid##name; UID name = &_uid##name;
#define DefineClassUniqueID(classn, name) BYTE _uid##classn##name; UID classn::name = &_uid##classn##name;

} // namespace DirectUI

#endif // DUI_BASE_UIDGEN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duiviewer.h ===
/*
 * Viewer
 */

#ifndef DUI_CONTROL_VIEWER_H_INCLUDED
#define DUI_CONTROL_VIEWER_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Viewer

class Viewer : public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnInput(InputEvent* pie);
    virtual bool OnPropertyChanging(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // Property definitions
    static PropertyInfo* XOffsetProp;
    static PropertyInfo* YOffsetProp;
    static PropertyInfo* XScrollableProp;
    static PropertyInfo* YScrollableProp;

    // Quick property accessors
    int GetXOffset()                    DUIQuickGetter(int, GetInt(), XOffset, Specified)
    int GetYOffset()                    DUIQuickGetter(int, GetInt(), YOffset, Specified)
    bool GetXScrollable()               DUIQuickGetter(bool, GetBool(), XScrollable, Specified)
    bool GetYScrollable()               DUIQuickGetter(bool, GetBool(), YScrollable, Specified)

    HRESULT SetXOffset(int v)           DUIQuickSetter(CreateInt(v), XOffset)
    HRESULT SetYOffset(int v)           DUIQuickSetter(CreateInt(v), YOffset)
    HRESULT SetXScrollable(bool v)      DUIQuickSetter(CreateBool(v), XScrollable)
    HRESULT SetYScrollable(bool v)      DUIQuickSetter(CreateBool(v), YScrollable)

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    bool EnsureVisible(int x, int y, int cx, int cy);

    Viewer() { }
    HRESULT Initialize();
    virtual ~Viewer() { }

private:
    Element* GetContent();
    bool InternalEnsureVisible(int x, int y, int cx, int cy);

};

} // namespace DirectUI

#endif // DUI_CONTROL_VIEWER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duserctrl.h ===
#if !defined(INC__DUserCtrl_h__INCLUDED)
#define INC__DUserCtrl_h__INCLUDED


#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus

#define BEGIN_INTERPOLATION_INTERFACE(i, guid) \
    struct __declspec(uuid(guid)) i;    \
    struct i : public IInterpolation    \
    {

#define END_INTERPOLATION_INTERFACE() \
    };


#define BEGIN_ANIMATION_INTERFACE(i, guid) \
    struct __declspec(uuid(guid)) i;    \
    struct i : public IAnimation        \
    {

#define END_ANIMATION_INTERFACE() \
    };


#else
// TODO: Create C definition
#endif

/***************************************************************************\
*
* ButtonGadget
*
\***************************************************************************/

DEFINE_EVENT(evButtonClicked, "DCADCE53-062B-4d1f-B36F-3F2EB27B88CF");



#ifdef GADGET_ENABLE_COM

/***************************************************************************\
*
* Interpolation
*
\***************************************************************************/

struct __declspec(uuid("E188CC9E-4805-487d-9313-3B22AC8FE336")) IInterpolation;
interface IInterpolation : public IUnknown
{
public:
    STDMETHOD_(float,       Compute)(float flProgress, float flStart, float flEnd) PURE;
};


BEGIN_INTERPOLATION_INTERFACE(ILinearInterpolation, "3FD65045-7BF5-4a65-B137-F441529BD8F4")
END_INTERPOLATION_INTERFACE()


BEGIN_INTERPOLATION_INTERFACE(ILogInterpolation, "98C0FB9A-534D-4b9f-A439-A8E13F0C2D9E")
    STDMETHOD_(void,        SetScale)(float flScale) PURE;
END_INTERPOLATION_INTERFACE()


BEGIN_INTERPOLATION_INTERFACE(IExpInterpolation, "280DC2CC-7703-4147-8356-3FAACE662CD1")
    STDMETHOD_(void,        SetScale)(float flScale) PURE;
END_INTERPOLATION_INTERFACE()


BEGIN_INTERPOLATION_INTERFACE(ISInterpolation, "D07C8B2F-1896-438f-9EC2-6938ABD0D20C")
    STDMETHOD_(void,        SetScale)(float flScale)  PURE;
END_INTERPOLATION_INTERFACE()


#define INTERPOLATION_LINEAR       (1)
#define INTERPOLATION_LOG          (2)
#define INTERPOLATION_EXP          (3)
#define INTERPOLATION_S            (4)

DUSER_API   BOOL        WINAPI  BuildInterpolation(UINT nIPolID, int nVersion, REFIID riid, void ** ppvUnk);


/***************************************************************************\
*
* Animations
*
\***************************************************************************/

#ifdef GADGET_ENABLE_TRANSITIONS

interface IAnimationCallback;

struct __declspec(uuid("7AACE668-81EB-48d7-8734-267C83FF6DFF")) IAnimation;
interface IAnimation : public IUnknown
{
public:
    STDMETHOD_(void,        SetFunction)(IInterpolation * pipol) PURE;

    enum ETime {
        tComplete,          // Completed normally
        tEnd,               // Jumped to end
        tAbort,             // Aborted in place
        tReset,             // Reset to beginning
        tDestroy            // The Gadget being animationed has been destroyed
    };
    STDMETHOD_(void,        SetTime)(ETime time) PURE;
    STDMETHOD_(UINT,        GetID)() const PURE;
    STDMETHOD_(void,        SetCallback)(IAnimationCallback * pcb) PURE;
};


interface IAnimationCallback : public IUnknown
{
public:
    STDMETHOD_(void,        OnComplete)(IAnimation * pAni, IAnimation::ETime time) PURE;
    STDMETHOD_(void,        OnSetTime)(IAnimation * pAni, IAnimation::ETime time) PURE;
};


#define ANIF_USESTART               0x00000001  // Use the specified start values 
                                                // instead of querying the current

struct GANI_DESC
{
    DWORD       cbSize;
    HGADGET     hgadChange;
    GMA_ACTION  act;
    UINT        nAniFlags;
    IInterpolation *    
                pipol;
    IAnimationCallback *
                pcb;
}; 


#define GANI_ALPHACOMPLETE_OPTIMIZE 0x00000001  // Turn off alpha-blending if not needed

struct GANI_ALPHADESC : public GANI_DESC
{
    float       flStart;
    float       flEnd;
    BOOL        fPushToChildren;
    UINT        nOnComplete;
};


struct GANI_SCALEDESC : public GANI_DESC
{
    enum EAlignment {
        aTopLeft,
        aTopCenter,
        aTopRight,
        aMiddleLeft,
        aMiddleCenter,
        aMiddleRight,
        aBottomLeft,
        aBottomCenter,
        aBottomRight
    };

    EAlignment  al;
    float       flStart;
    float       flEnd;
};


struct GANI_RECTDESC : public GANI_DESC
{
    POINT       ptStart;
    POINT       ptEnd;
    SIZE        sizeStart;
    SIZE        sizeEnd;
    UINT        nChangeFlags;
};


#define GANI_ROTATEDIRECTION_SHORT  0   // Shortest arc
#define GANI_ROTATEDIRECTION_LONG   1   // Longer arc
#define GANI_ROTATEDIRECTION_CW     2   // Clock-wise
#define GANI_ROTATEDIRECTION_CCW    3   // Counter clock-wise

struct GANI_ROTATEDESC : public GANI_DESC
{
    float       flStart;
    float       flEnd;
    UINT        nDir;
};


#define ANIMATION_ALPHA            (1)
#define ANIMATION_SCALE            (2)
#define ANIMATION_RECT             (3)
#define ANIMATION_ROTATE           (4)


DUSER_API   BOOL        WINAPI  BuildAnimation(UINT nAniID, int nVersion, GANI_DESC * pDesc, REFIID riid, void ** ppvUnk);
DUSER_API   BOOL        WINAPI  GetGadgetAnimation(HGADGET hgad, UINT nAniID, REFIID riid, void ** ppvUnk);


#endif // GADGET_ENABLE_TRANSITIONS
#endif // GADGET_ENABLE_COM

DUSER_API   BOOL        WINAPI  BuildDropTarget(HGADGET hgadRoot, HWND hwnd);

#ifdef __cplusplus
};
#endif

#endif // INC__DUserCtrl_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duser.h ===
#if !defined(INC__DUser_h__INCLUDED)
#define INC__DUser_h__INCLUDED


#ifdef __cplusplus
#define DEFARG(x)   = x
#else
#define DEFARG(x)
#endif


// 
// Setup implied switches
//

#ifdef GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_COM
#endif // GADGET_ENABLE_TRANSITIONS

#ifdef _GDIPLUS_H
#if !defined(GADGET_ENABLE_GDIPLUS)
#define GADGET_ENABLE_GDIPLUS
#endif
#endif


#ifdef GADGET_ENABLE_ALL

#define GADGET_ENABLE_COM
#define GADGET_ENABLE_OLE
#define GADGET_ENABLE_DX
#define GADGET_ENABLE_TRANSITIONS

#endif // GADGET_ENABLE_ALL


//
// Include external DirectUser definitions.
//

#ifdef GADGET_ENABLE_COM
#include <ObjBase.h>            // CoCreateInstance
#include <unknwn.h>             // IUnknown
#endif

#include "DUserError.h"
#include "DUserCore.h"
#include "DUserUtil.h"

#ifdef GADGET_ENABLE_TRANSITIONS
#include "DUserMotion.h"
#endif

#endif // INC__DUser_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\gadget.h ===
#if !defined(INC__Gadget_h__INCLUDED)
#define INC__Gadget_h__INCLUDED
#pragma once

// Forward declarations used in .gidl files

class Visual;

namespace Gdiplus
{
    class Brush;
    class Font;
    class Pen;
};


// Global helper functions

template <class T>
inline T * 
BuildVisual(Visual * pgvParent)
{
    Visual::VisualCI ci;
    ZeroMemory(&ci, sizeof(ci));
    ci.pgvParent = pgvParent;
    return T::Build(&ci);
}


inline bool IsHandled(HRESULT hr)
{
    return (hr == DU_S_COMPLETE) || (hr == DU_S_PARTIAL);
}


#endif // INC__Gadget_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duivalue.h ===
/*
 * Value
 */

#ifndef DUI_CORE_VALUE_H_INCLUDED
#define DUI_CORE_VALUE_H_INCLUDED

#pragma once

namespace DirectUI
{

////////////////////////////////////////////////////////
// Value

/*
 * Value Multithreading
 * 
 * Values are immutable and are a process-wide resource. A value created in one thread can be
 * used in any thread. Access to them are synchronized (thread-safe) and they do not have
 * thread-affinity.
 *
 * TODO: Impl thread-safety for Values
 */

// Forward declarations
class Element;
class Layout;
class PropertySheet;
class Expression;
typedef DynamicArray<Element*> ElementList;

// Value will maintain the lifetime of ElementLists, Layouts, PropertySheets, and Expressions after
// a new Value is created with a pointer to the object (these objects are created externally). When
// the reference count goes to zero, these objects will be deleted. 

#define DUIV_UNAVAILABLE   -2
#define DUIV_UNSET         -1
#define DUIV_NULL          0
#define DUIV_INT           1
#define DUIV_BOOL          2
#define DUIV_ELEMENTREF    3
#define DUIV_ELLIST        4  // List deleted on Value destruction and made immutable on create (Value only object holding external created ElementList)
#define DUIV_STRING        5  // String duplicated on creation and freed on destruction (Value creates new internal instance)
#define DUIV_POINT         6
#define DUIV_SIZE          7
#define DUIV_RECT          8
#define DUIV_FILL          9
#define DUIV_LAYOUT        10 // Layout object destroyed on Value destruction (Value only object holding external created Layout)
#define DUIV_GRAPHIC       11 // Bitmap handle freed on Value destruction (Value creates new internal instance)
#define DUIV_SHEET         12 // PropertySheet object destroyed on Value destruction and made immutable on create (Value only object holding external created PropertySheet)
#define DUIV_EXPR          13 // Expression object destroyed on Value destruction (Value only object holding external created Expression)
#define DUIV_ATOM          14
#define DUIV_CURSOR        15 // Will not destroy cursor handle upon value destruction

// Value structures and macros

#define FILLTYPE_HGradient            ((BYTE)0)
#define FILLTYPE_VGradient            ((BYTE)1)
#define FILLTYPE_Solid                ((BYTE)2)
#define FILLTYPE_TriHGradient         ((BYTE)3)
#define FILLTYPE_TriVGradient         ((BYTE)4)
#define FILLTYPE_DrawFrameControl     ((BYTE)5)  // DrawFrameControl fill
#define FILLTYPE_DrawThemeBackground  ((BYTE)6)  // DrawThemeBackground fill

struct Fill  // Solid colors and fills
{
    BYTE dType;
    union
    {
        struct
        {
            COLORREF cr;
            COLORREF cr2;
            COLORREF cr3;
        } ref;

        struct
        {
            UINT uType;
            UINT uState;
        } fillDFC;

        struct
        {
            HTHEME hTheme;
            int iPartId;
            int iStateId;
        } fillDTB;
    };
};

// Graphic
// Graphic objects may either have an Alpha channel applied to the entire bitmap, 
// may have full alpha transparency of a particular color in the bitmap (with the
// option of an auto-color pick (upper left corner)), or neither

#define GRAPHICTYPE_Bitmap                  ((BYTE)0)
#define GRAPHICTYPE_Icon                    ((BYTE)1)
#define GRAPHICTYPE_EnhMetaFile             ((BYTE)2)

#ifdef GADGET_ENABLE_GDIPLUS
#define GRAPHICTYPE_GpBitmap                ((BYTE)3)
#endif

// Valid modes for Bitmaps (Alpha or RGB used depending on mode), meaning based on context of use
#define GRAPHIC_NoBlend                     ((BYTE)0)
#define GRAPHIC_AlphaConst                  ((BYTE)1)
#define GRAPHIC_AlphaConstPerPix            ((BYTE)2)
#define GRAPHIC_TransColor                  ((BYTE)3)
#define GRAPHIC_Stretch                     ((BYTE)4)
#define GRAPHIC_NineGrid                    ((BYTE)5)
#define GRAPHIC_NineGridTransColor          ((BYTE)6)
#define GRAPHIC_NineGridAlphaConstPerPix    ((BYTE)7)

struct Graphic
{
    HANDLE hImage;          // Will hold hBitmap, hIcon, hEnhMetaFile or Gdiplus::Bitmap
    HANDLE hAltImage;
    USHORT cx;
    USHORT cy;
    struct
    {
        BYTE dImgType   : 2;
        BYTE dMode      : 3;
        bool bFlip      : 1;
        bool bRTLGraphic: 1;
        bool bFreehImage: 1;
        
        union
        {
            BYTE dAlpha;
            struct
            {
                BYTE r: 8;
                BYTE g: 8;
                BYTE b: 8;
            } rgbTrans;
        };
    } BlendMode;
};

struct Cursor
{
    HCURSOR hCursor;
};

// Compile-time static version of the Value class
struct _StaticValue
{
    BYTE _fReserved0;
    BYTE _fReserved1;
    short _dType;
    int _cRef;
    int _val0;
    int _val1;
    int _val2;
    int _val3;
};

struct _StaticValueColor
{
    BYTE _fReserved0;
    BYTE _fReserved1;
    short _dType;
    int _cRef;
    BYTE dType;
    COLORREF cr;
    COLORREF crSec;
    USHORT x;
    USHORT y;
};

struct _StaticValuePtr
{
    BYTE _fReserved0;
    BYTE _fReserved1;
    short _dType;
    int _cRef;
    void* _ptr;
};

// Value class (24-bytes)
class Value
{
private:
    BYTE _fReserved0;  // Reserved for small block allocator
    BYTE _fReserved1;  // Data alignment padding
    short _dType;
    int _cRef;
    union
    {
        int _intVal;
        bool _boolVal;
        Element* _peVal;
        ElementList* _peListVal;
        LPWSTR _pszVal;
        POINT _ptVal;
        SIZE _sizeVal;
        RECT _rectVal;
        Fill _fillVal;
        Layout* _plVal;
        Graphic _graphicVal;
        PropertySheet* _ppsVal;
        Expression* _pexVal;
        ATOM _atomVal;
        Cursor _cursorVal;
    };

    void _ZeroRelease();

public:

#if DBG
    bool IsZeroRef() { return !_cRef; }
#endif

    // Value creation methods
    static Value* CreateInt(int dValue);
    static Value* CreateBool(bool bValue);
    static Value* CreateElementRef(Element* peValue);
    static Value* CreateElementList(ElementList* peListValue);
    static Value* CreateString(LPCWSTR pszValue, HINSTANCE hResLoad = NULL);
    static Value* CreatePoint(int x, int y);
    static Value* CreateSize(int cx, int cy);
    static Value* CreateRect(int left, int top, int right, int bottom);
    static Value* CreateColor(COLORREF cr);
    static Value* CreateColor(COLORREF cr0, COLORREF cr1, BYTE dType = FILLTYPE_HGradient);
    static Value* CreateColor(COLORREF cr0, COLORREF cr1, COLORREF cr2, BYTE dType = FILLTYPE_TriHGradient);
    static Value* CreateFill(const Fill & clrSrc);
    static Value* CreateDFCFill(UINT uType, UINT uState);
    static Value* CreateDTBFill(HTHEME hTheme, int iPartId, int iStateId);
    static Value* CreateLayout(Layout* plValue);
    static Value* CreateGraphic(HBITMAP hBitmap, BYTE dBlendMode = GRAPHIC_TransColor, UINT dBlendValue = (UINT)-1, bool bFlip = false, bool bRTL = false);
#ifdef GADGET_ENABLE_GDIPLUS
    static Value* CreateGraphic(Gdiplus::Bitmap * pgpbmp, BYTE dBlendMode = GRAPHIC_TransColor, UINT dBlendValue = (UINT)-1, bool bFlip = false, bool bRTL = false);
#endif
    static Value* CreateGraphic(HICON hIcon, bool bFlip = false, bool bRTL = false);
    static Value* CreateGraphic(LPCWSTR pszBMP, BYTE dBlendMode = GRAPHIC_TransColor, UINT dBlendValue = (UINT)-1, USHORT cx = 0, USHORT cy = 0, HINSTANCE hResLoad = NULL,
                                bool bFlip = false, bool bRTL = false);
    static Value* CreateGraphic(LPCWSTR pszICO, USHORT cxDesired, USHORT cyDesired, HINSTANCE hResLoad = NULL, bool bFlip = false, bool bRTL = false);
    static Value* CreateGraphic(HENHMETAFILE hEnhMetaFile, HENHMETAFILE hAltEnhMetaFile = NULL);
    static Value* CreatePropertySheet(PropertySheet* ppsValue);
    static Value* CreateExpression(Expression* pexValue);
    static Value* CreateAtom(LPCWSTR pszValue);
    static Value* CreateCursor(LPCWSTR pszValue);
    static Value* CreateCursor(HCURSOR hValue);

    // Reference count methods
    void AddRef() { if (_cRef != -1) _cRef++; }  // -1 is static value
    void Release() { if (_cRef != -1 && !--_cRef) _ZeroRelease(); }  // -1 is static value
    int GetRefCount() { return _cRef; }

    // Accessors
    int GetType();
    LPVOID GetImage(bool bGetRTL);
    int GetInt();
    bool GetBool();
    Element* GetElement();
    ElementList* GetElementList();     // Invalid if released (object referred to destroyed)
    const LPWSTR GetString();          // Invalid if released (object referred to destroyed)
    const POINT* GetPoint();           // Invalid if released
    const SIZE* GetSize();             // Invalid if released
    const RECT* GetRect();             // Invalid if released
    const Fill* GetFill();             // Invalid if released
    Layout* GetLayout();               // Invalid if released (object referred to destroyed)
    Graphic* GetGraphic();             // Invalid if released (object indirectly referred to destroyed)
    PropertySheet* GetPropertySheet(); // Invalid if released (object referred to destroyed)
    Expression* GetExpression();       // Invalid if released (object referred to destroyed)
    ATOM GetAtom();                    // Invalid if released
    Cursor* GetCursor();               // Invalid if released
    
    // Equality
    bool IsEqual(Value* pv);

    // Conversion
    LPWSTR ToString(LPWSTR psz, UINT c);

    // Common values
    static Value* pvUnavailable;
    static Value* pvNull;
    static Value* pvUnset;
    static Value* pvElementNull;
    static Value* pvElListNull;
    static Value* pvBoolTrue;
    static Value* pvBoolFalse;
    static Value* pvStringNull;
    static Value* pvPointZero;
    static Value* pvSizeZero;
    static Value* pvRectZero;
    static Value* pvIntZero;
    static Value* pvLayoutNull;
    static Value* pvGraphicNull;
    static Value* pvSheetNull;
    static Value* pvExprNull;
    static Value* pvAtomZero;
    static Value* pvCursorNull;
    static Value* pvColorTrans;
};

//LPVOID  GetImage(Graphic *pg, bool bGetRTL);

#define GethBitmap(pv, bGetRTL)            ((HBITMAP)pv->GetImage(bGetRTL))
#define GethIcon(pv, bGetRTL)              ((HICON)pv->GetImage(bGetRTL))
#define GethEnhMetaFile(pv, bGetRTL)       ((HENHMETAFILE)pv->GetImage(bGetRTL))
#define GetGpBitmap(pv, bGetRTL)          ((Gdiplus::Bitmap *)pv->GetImage(bGetRTL))

#define StaticValue(name, type, val0) static _StaticValue name = { 0, 0, type, -1, val0, 0, 0, 0 }
#define StaticValue2(name, type, val0, val1) static _StaticValue name = { 0, 0, type, -1, val0, val1, 0, 0 }
#define StaticValue4(name, type, val0, val1, val2, val3) static _StaticValue name = { 0, 0, type, -1, val0, val1, val2, val3 }
#define StaticValueColorSolid(name, cr) static _StaticValueColor name = { 0, 0, DUIV_FILL, -1, FILLTYPE_Solid, cr, 0, 0, 0 }
#define StaticValuePtr(name, type, ptr) static _StaticValuePtr name = { 0, 0, type, -1, ptr }


// Accessors
inline int 
Value::GetType()
{
    return _dType;
}

inline int 
Value::GetInt()  // Copy passed out
{
    DUIAssert(_dType == DUIV_INT, "Invalid value type");

    return _intVal;
}

inline bool 
Value::GetBool()  // Copy passed out
{
    DUIAssert(_dType == DUIV_BOOL, "Invalid value type");

    return _boolVal;
}

inline Element * 
Value::GetElement()  // Copy passed out
{
    DUIAssert(_dType == DUIV_ELEMENTREF, "Invalid value type");

    return _peVal;
}

inline ElementList * 
Value::GetElementList()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_ELLIST, "Invalid value type");

    return _peListVal;
}

inline const LPWSTR 
Value::GetString()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_STRING, "Invalid value type");

    return _pszVal;
}

inline const POINT *
Value::GetPoint()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_POINT, "Invalid value type");

    return &_ptVal;
}

inline const SIZE *
Value::GetSize()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_SIZE, "Invalid value type");

    return &_sizeVal;
}

inline const RECT *
Value::GetRect()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_RECT, "Invalid value type");

    return &_rectVal;
}

inline const Fill *
Value::GetFill()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_FILL, "Invalid value type");

    return &_fillVal;
}

inline Layout *
Value::GetLayout()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_LAYOUT, "Invalid value type");
    
    return _plVal;
}

inline Graphic *
Value::GetGraphic()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_GRAPHIC, "Invalid value type");
    
    return &_graphicVal;
}

inline PropertySheet * Value::GetPropertySheet()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_SHEET, "Invalid value type");

    return _ppsVal;
}

inline Expression *
Value::GetExpression()  // Copy passed out, invalid (destroyed) if value released
{
    DUIAssert(_dType == DUIV_EXPR, "Invalid value type");
    
    return _pexVal;
}

inline ATOM 
Value::GetAtom()  // Copy passed out
{
    DUIAssert(_dType == DUIV_ATOM, "Invalid value type");
    
    return _atomVal;
}

inline Cursor *
Value::GetCursor()  // Pointer to internal structure, invalid if value released
{
    DUIAssert(_dType == DUIV_CURSOR, "Invalid value type");
    
    return &_cursorVal;
}

} // namespace DirectUI

#endif // DUI_CORE_VALUE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\dusercore.h ===
/***************************************************************************\
*
* File: DUserCore.h
*
* Description:
* DUserCore.h defines the DirectUser/Core, the low-level composition engine.
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__DUserCore_h__INCLUDED)
#define INC__DUserCore_h__INCLUDED

/*
 * Include dependencies
 */

#include <limits.h>             // Standard constants

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

/***************************************************************************\
*
* Basics
*
\***************************************************************************/

DECLARE_HANDLE(HGADGET);
DECLARE_HANDLE(HDCONTEXT);
DECLARE_HANDLE(HCLASS);

DUSER_API   BOOL        WINAPI  DeleteHandle(HANDLE h);
DUSER_API   BOOL        WINAPI  IsStartDelete(HANDLE h, BOOL * pfStarted);

#define IGTM_MIN                (0)     // +
#define IGTM_NONE               (0)     // | No special threading model
#define IGTM_SINGLE             (1)     // | Single threaded application
#define IGTM_SEPARATE           (2)     // | MT with single thread per context 
#define IGTM_MULTIPLE           (3)     // | MT with multiple threads per context
#define IGTM_MAX                (3)     // +

#define IGMM_MIN                (1)     // +
#define IGMM_COMPATIBLE         (1)     // | Core running in Compatible mode
#define IGMM_ADVANCED           (2)     // | Core running in Advanced mode
#define IGMM_STANDARD           (3)     // | Standard mode on Whistler
#define IGMM_MAX                (3)     // +

#define IGPM_MIN                (0)     // +
#define IGPM_BLEND              (0)     // | Optimize for blend between speed / size
#define IGPM_SPEED              (1)     // | Optimize for pure speed
#define IGPM_SIZE               (2)     // | Optimize for minimum working set
#define IGPM_MAX                (2)     // +

typedef struct tagINITGADGET
{
    DWORD       cbSize;         // Size of structure
    UINT        nThreadMode;    // Threading model
    UINT        nMsgMode;       // DirectUser/Core messaging subsystem mode
    UINT        nPerfMode;      // Performance tuning mode
    HDCONTEXT   hctxShare;      // Existing context to share with
} INITGADGET;

DUSER_API   HDCONTEXT   WINAPI  InitGadgets(INITGADGET * pInit);


#define IGC_MIN             (1)
#define IGC_DXTRANSFORM     (1) // DirectX Transforms
#define IGC_GDIPLUS         (2) // GDI+
#define IGC_MAX             (2)

DUSER_API   BOOL        WINAPI  InitGadgetComponent(UINT nOptionalComponent);
DUSER_API   BOOL        WINAPI  UninitGadgetComponent(UINT nOptionalComponent);

DUSER_API   HDCONTEXT   WINAPI  GetContext(HANDLE h);
DUSER_API   BOOL        WINAPI  IsInsideContext(HANDLE h);

#ifdef __cplusplus

#define BEGIN_STRUCT(name, baseclass) \
    struct name : baseclass {

#define END_STRUCT(name)   \
    };

#define FORWARD_STRUCT(name) \
    struct name;

#else

#define BEGIN_STRUCT(name, baseclass) \
    typedef struct tag##name {  \
        baseclass;

#define END_STRUCT(name) \
    } name;

#define FORWARD_STRUCT(name) \
    typedef struct name;

#endif


/***************************************************************************\
*
* Messaging and Events
*
\***************************************************************************/

#define GMF_DIRECT              0x00000000  // + When message reaches hgadMsg
#define GMF_ROUTED              0x00000001  // | Before message reaches hgadMsg
#define GMF_BUBBLED             0x00000002  // | After message reaches hgadMsg
#define GMF_EVENT               0x00000003  // | After message becomes an event
#define GMF_DESTINATION         0x00000003  // + Destination of message

typedef int MSGID;
typedef int PRID;

// New Messages
typedef struct tagGMSG
{
    DWORD       cbSize;         // (REQUIRED) Size of message in bytes
    MSGID       nMsg;           // (REQUIRED) Gadget message
    HGADGET     hgadMsg;        // (REQUIRED) Gadget that message is "about"
} GMSG;

BEGIN_STRUCT(MethodMsg, GMSG)
END_STRUCT(MethodMsg)

BEGIN_STRUCT(EventMsg, MethodMsg)
    UINT        nMsgFlags;      // Flags about message
END_STRUCT(EventMsg)


#define GET_EVENT_DEST(pmsg) \
    (pmsg->nMsgFlags & GMF_DESTINATION)

#define SET_EVENT_DEST(pmsg, dest) \
    (pmsg->nMsgFlags = ((pmsg->nMsgFlags & ~GMF_DESTINATION) | (dest & GMF_DESTINATION)))

#define DEFINE_EVENT(event, guid)       \
    struct __declspec(uuid(guid)) event


/***************************************************************************\
*
* Gadget Classes
*
\***************************************************************************/

#ifndef __cplusplus
#error Requires C++ to compile
#endif

}; // extern "C" 

namespace DUser
{

// Forward declarations
class Gadget;
class SGadget;
struct MessageInfoStub;

};

DUSER_API   HRESULT     WINAPI  DUserDeleteGadget(DUser::Gadget * pg);
DUSER_API   HGADGET     WINAPI  DUserCastHandle(DUser::Gadget * pg);

namespace DUser
{

#define dapi
#define devent

//
// Core Classes
//

class Gadget
{
public:
            void *      m_pDummy;

    inline  HGADGET     GetHandle() const
    {
        return DUserCastHandle(const_cast<Gadget *> (this));
    }

    inline  void        Delete()
    {
        DUserDeleteGadget(this);
    }

            HRESULT     CallStubMethod(MethodMsg * pmsg);
            HRESULT     CallSuperMethod(MethodMsg * pmsg, void * pMT);
            
            UINT        CallStubEvent(EventMsg * pmsg, int nEventMsg);
            UINT        CallSuperEvent(EventMsg * pmsg, void * pMT, int nEventMsg);

    enum ConstructCommand
    {
        ccSuper         = 0,        // Construct the super-class
        ccSetThis       = 1,        // Set this pointer
    };

    struct ConstructInfo
    {
    };
};


class SGadget
{
public:
            Gadget *    m_pgad;
    static  HCLASS      s_hclSuper;

    inline  HGADGET     GetHandle() const
    {
        return DUserCastHandle(const_cast<Gadget *> (m_pgad));
    }

    inline  void        Delete()
    {
        DUserDeleteGadget(m_pgad);
    }
};

typedef HRESULT (SGadget::*MethodProc)(MethodMsg * pmsg);
typedef HRESULT (SGadget::*EventProc)(EventMsg * pmsg);

//
// Delegate support
//

class EventDelegate
{
public:
    typedef HRESULT (CALLBACK Gadget::*Proc)(EventMsg * p1);

    static inline EventDelegate
    Build(Gadget * pvThis, Proc pfn) 
    {
        EventDelegate ed;
        ed.m_pvThis = pvThis;
        ed.m_pfn    = pfn;
        return ed;
    }

    inline HRESULT Invoke(EventMsg * p1)
    {
        return (m_pvThis->*m_pfn)(p1);
    }

    Gadget *    m_pvThis;
    Proc        m_pfn;
};

#define EVENT_DELEGATE(instance, function) \
    DUser::EventDelegate::Build(reinterpret_cast<DUser::Gadget *>(reinterpret_cast<void *>(instance)), \
            reinterpret_cast<DUser::EventDelegate::Proc>(function))


//
// Typedef's
//

typedef HRESULT (CALLBACK * ConstructProc)(DUser::Gadget::ConstructCommand cmd, HCLASS hclCur, DUser::Gadget * pg, void * pvData);
typedef HRESULT (CALLBACK * PromoteProc)(ConstructProc pfnCS, HCLASS hclCur, DUser::Gadget * pg, DUser::Gadget::ConstructInfo * pmicData);
typedef HCLASS  (CALLBACK * DemoteProc)(HCLASS hclCur, DUser::Gadget * pg, void * pvData);


//
// Message information and class structures
//

template<class t, class m>
inline void *
Method(HRESULT (t::*pfn)(m * pmsg))
{
    union
    {
       HRESULT (t::*in)(m * pmsg);
       void * out;
    };

    in = pfn;
    return out;
}

template<class t, class m>
inline void *
Event(HRESULT (t::*pfn)(m * pmsg))
{
    union
    {
       HRESULT (t::*in)(m * pmsg);
       void * out;
    };

    in = pfn;
    return out;
}


struct MessageInfoGuts
{
    void *      pfn;            // IN:  Implementation function
    LPCWSTR     pszMsgName;     // IN:  Name
};

struct MessageClassGuts
{
    DWORD       cbSize;         // IN:  Structure size
    DWORD       nClassVersion;  // IN:  This class's version
    LPCWSTR     pszClassName;   // IN:  Name of new class
    LPCWSTR     pszSuperName;   // IN:  Name of super-class
    MessageInfoGuts *           // IN:  Message information
                rgMsgInfo;
    int         cMsgs;          // IN:  Number of messages being registered
    PromoteProc pfnPromote;     // IN:  Promotion function
    DemoteProc  pfnDemote;      // IN:  Demotion function
    HCLASS      hclNew;         // OUT: Newly created class
    HCLASS      hclSuper;       // OUT: Newly created class's super
};

struct MessageInfoStub
{
    int         cbSlotOffset;   // OUT: Message slot offset
    LPCWSTR     pszMsgName;     // IN:  Name
};

struct MessageClassStub
{
    DWORD       cbSize;
    DWORD       nClassVersion;
    LPCWSTR     pszClassName;
    DUser::MessageInfoStub *
                rgMsgInfo;
    int         cMsgs;
};

struct MessageClassSuper
{
    DWORD       cbSize;
    DWORD       nClassVersion;
    LPCWSTR     pszClassName;
    void *      pmt;
};

}; // namespace DUser

extern "C" {

DUSER_API   HCLASS      WINAPI  DUserRegisterGuts(DUser::MessageClassGuts * pmc);
DUSER_API   HCLASS      WINAPI  DUserRegisterStub(DUser::MessageClassStub * pmc);
DUSER_API   HCLASS      WINAPI  DUserRegisterSuper(DUser::MessageClassSuper * pmc);
DUSER_API   HCLASS      WINAPI  DUserFindClass(LPCWSTR pszName, DWORD nVersion);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserBuildGadget(HCLASS hcl, DUser::Gadget::ConstructInfo * pmicData);

DUSER_API   BOOL        WINAPI  DUserInstanceOf(DUser::Gadget * pg, HCLASS hclTest);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserCastClass(DUser::Gadget * pg, HCLASS hclTest);
DUSER_API   DUser::Gadget *    
                        WINAPI  DUserCastDirect(HGADGET hgad);
DUSER_API   void *      WINAPI  DUserGetGutsData(DUser::Gadget * pg, HCLASS hclData);


/***************************************************************************\
*
* Messages
*
\***************************************************************************/

// Core messages
#define GM_EVENT            32768

#define GM_DESTROY          (1 + GM_EVENT)
#define GM_PAINT            (2 + GM_EVENT)
#define GM_INPUT            (3 + GM_EVENT)
#define GM_CHANGESTATE      (4 + GM_EVENT)
#define GM_CHANGERECT       (5 + GM_EVENT)
#define GM_CHANGESTYLE      (6 + GM_EVENT)
#define GM_QUERY            (7 + GM_EVENT)
#define GM_SYNCADAPTOR      (8 + GM_EVENT)
#define GM_PAINTCACHE       (9 + GM_EVENT)    // TODO: Move into GM_PAINT message

#define GM_USER             (1024 + GM_EVENT) // Starting point for user messages
#define GM_REGISTER         (1000000 + GM_EVENT) // Starting point for registered messages

// Win32 Messages
// TODO: Move these to winuser.h
#define WM_GETROOTGADGET   (WM_USER - 1)

// Message filtering
#define GMFI_PAINT          0x00000001
#define GMFI_INPUTKEYBOARD  0x00000002
#define GMFI_INPUTMOUSE     0x00000004
#define GMFI_INPUTMOUSEMOVE 0x00000008
#define GMFI_CHANGESTATE    0x00000010
#define GMFI_CHANGERECT     0x00000020
#define GMFI_CHANGESTYLE    0x00000040
#define GMFI_ALL            0xFFFFFFFF
#define GMFI_VALID         (GMFI_PAINT |                                                 \
                            GMFI_INPUTKEYBOARD | GMFI_INPUTMOUSE | GMFI_INPUTMOUSEMOVE | \
                            GMFI_CHANGESTATE | GMFI_CHANGERECT | GMFI_CHANGESTYLE)

#define GDESTROY_START      1   // Gadget has started the destruction process
#define GDESTROY_FINAL      2   // Gadget has been fully destroyed

BEGIN_STRUCT(GMSG_DESTROY, EventMsg)
    UINT        nCode;          // Destruction code
END_STRUCT(GMSG_DESTROY)

#define GINPUT_MOUSE        0
#define GINPUT_KEYBOARD     1
#define GINPUT_JOYSTICK     2

BEGIN_STRUCT(GMSG_INPUT, EventMsg)
    UINT        nDevice;        // Input device
    UINT        nCode;          // Specific action
    UINT        nModifiers;     // ctrl, alt, shift, leftbutton, middlebutton, rightbutton
    LONG        lTime;          // Time when message was sent
END_STRUCT(GMSG_INPUT)


#define GMOUSE_MOVE         0
#define GMOUSE_DOWN         1
#define GMOUSE_UP           2
#define GMOUSE_DRAG         3
#define GMOUSE_HOVER        4
#define GMOUSE_WHEEL        5
#define GMOUSE_MAX          5

#define GBUTTON_NONE        0
#define GBUTTON_LEFT        1
#define GBUTTON_RIGHT       2
#define GBUTTON_MIDDLE      3
#define GBUTTON_MAX         3

#define GMODIFIER_LCONTROL  0x00000001
#define GMODIFIER_RCONTROL  0x00000002
#define GMODIFIER_LSHIFT    0x00000004
#define GMODIFIER_RSHIFT    0x00000008
#define GMODIFIER_LALT      0x00000010
#define GMODIFIER_RALT      0x00000020
#define GMODIFIER_LBUTTON   0x00000040
#define GMODIFIER_RBUTTON   0x00000080
#define GMODIFIER_MBUTTON   0x00000100

#define GMODIFIER_CONTROL   (GMODIFIER_LCONTROL | GMODIFIER_RCONTROL)
#define GMODIFIER_SHIFT     (GMODIFIER_LSHIFT   | GMODIFIER_RSHIFT)
#define GMODIFIER_ALT       (GMODIFIER_LALT     | GMODIFIER_RALT)

BEGIN_STRUCT(GMSG_MOUSE, GMSG_INPUT)
    POINT       ptClientPxl;    // Mouse location in client coordinates
    BYTE        bButton;        // Mouse button
    UINT        nFlags;         // Misc. flags
END_STRUCT(GMSG_MOUSE)

BEGIN_STRUCT(GMSG_MOUSEDRAG, GMSG_MOUSE)
    SIZE        sizeDelta;      // Mouse drag distance
    BOOL        fWithin;        // Mouse within gadget's bounds
END_STRUCT(GMSG_MOUSEDRAG)

BEGIN_STRUCT(GMSG_MOUSECLICK, GMSG_MOUSE)
    UINT        cClicks;        // number of clicks in "quick" succession
END_STRUCT(GMSG_MOUSECLICK)

BEGIN_STRUCT(GMSG_MOUSEWHEEL, GMSG_MOUSE)
    short       sWheel;         // Wheel position
END_STRUCT(GMSG_MOUSEWHEEL)

#define GKEY_DOWN           0
#define GKEY_UP             1
#define GKEY_CHAR           2
#define GKEY_SYSDOWN        3
#define GKEY_SYSUP          4
#define GKEY_SYSCHAR        5

BEGIN_STRUCT(GMSG_KEYBOARD, GMSG_INPUT)
    WCHAR       ch;             // Character
    WORD        cRep;           // Repeat count
    WORD        wFlags;         // Misc. flags
END_STRUCT(GMSG_KEYBOARD)


#define GPAINT_RENDER       0   // Render this Gadget into the buffer
#define GPAINT_CACHE        1   // Post-render step for Cached drawing

BEGIN_STRUCT(GMSG_PAINT, EventMsg)
    UINT        nCmd;           // Painting command
    UINT        nSurfaceType;   // Surface type
END_STRUCT(GMSG_PAINT)


BEGIN_STRUCT(GMSG_PAINTRENDERI, GMSG_PAINT)
    LPCRECT     prcGadgetPxl;   // Logical position of gadget
    LPCRECT     prcInvalidPxl;  // Invalid rectangle in container coordinates
    HDC         hdc;            // DC to draw into
END_STRUCT(GMSG_PAINT)


#ifdef GADGET_ENABLE_GDIPLUS
BEGIN_STRUCT(GMSG_PAINTRENDERF, GMSG_PAINT)
    const Gdiplus::RectF *
                prcGadgetPxl;   // Logical position of gadget
    const Gdiplus::RectF *
                prcInvalidPxl;  // Invalid rectangle in container coordinates
    Gdiplus::Graphics *
                pgpgr;          // Graphics to draw into
END_STRUCT(GMSG_PAINT)
#endif // GADGET_ENABLE_GDIPLUS


BEGIN_STRUCT(GMSG_PAINTCACHE, EventMsg)
    LPCRECT     prcGadgetPxl;   // Logical position of gadget
    HDC         hdc;            // DC to draw into
    BYTE        bAlphaLevel;    // General alpha level when copying to destination
    BYTE        bAlphaFormat;   // Alpha format
END_STRUCT(GMSG_PAINTCACHE)


#define GSTATE_KEYBOARDFOCUS    0
#define GSTATE_MOUSEFOCUS       1
#define GSTATE_ACTIVE           2
#define GSTATE_CAPTURE          3

#define GSC_SET             0
#define GSC_LOST            1

BEGIN_STRUCT(GMSG_CHANGESTATE, EventMsg)
    UINT        nCode;          // Change command
    HGADGET     hgadSet;        // Gadget that is receiving the "state"
    HGADGET     hgadLost;       // Gadget that is loosing the "state"
    UINT        nCmd;           // Action that occurred
END_STRUCT(GMSG_CHANGESTATE)


BEGIN_STRUCT(GMSG_CHANGESTYLE, EventMsg)
    UINT        nNewStyle;      // New style
    UINT        nOldStyle;      // Old style
END_STRUCT(GMSG_CHANGESTYLE)


BEGIN_STRUCT(GMSG_CHANGERECT, EventMsg)
    RECT        rcNewRect;
    UINT        nFlags;
END_STRUCT(GMSG_CHANGERECT)


#ifdef GADGET_ENABLE_COM
#define GQUERY_INTERFACE    0
#define GQUERY_OBJECT       1
#endif

#define GQUERY_RECT         2
#define GQUERY_DESCRIPTION  3
#define GQUERY_DETAILS      4
#define GQUERY_HITTEST      5
#define GQUERY_PADDING      6

#ifdef GADGET_ENABLE_OLE
#define GQUERY_DROPTARGET   7
#endif // GADGET_ENABLE_OLE

BEGIN_STRUCT(GMSG_QUERY, EventMsg)
    UINT        nCode;          // Query command
END_STRUCT(GMSG_QUERY)

#ifdef GADGET_ENABLE_COM
BEGIN_STRUCT(GMSG_QUERYINTERFACE, EventMsg)
    IUnknown *  punk;
END_STRUCT(GMSG_QUERYINTERFACE)
#endif

#define GQR_FIXED           0   // Should fix inside bounging box
#define GQR_PRIVERT         1   // Vertical size is priority
#define GQR_PRIHORZ         2   // Horizontal size is priority

BEGIN_STRUCT(GMSG_QUERYRECT, GMSG_QUERY)
    SIZE        sizeBound;      // Rectangle to fit inside
    SIZE        sizeResult;     // Computed rectange
    UINT        nFlags;         // Flags to use in computation
END_STRUCT(GMSG_QUERYRECT)

BEGIN_STRUCT(GMSG_QUERYDESC, GMSG_QUERY)
    WCHAR       szName[128];
    WCHAR       szType[128];
END_STRUCT(GMSG_QUERYDESC)

#define GQDT_HWND           0   // Provided handle refers to parent HWND

BEGIN_STRUCT(GMSG_QUERYDETAILS, GMSG_QUERY)
    UINT        nType;
    HANDLE      hOwner;
END_STRUCT(GMSG_QUERYDETAILS)

#define GQHT_NOWHERE        0   // Location is not "inside"
#define GQHT_INSIDE         1   // Location is generically "inside"
#define GQHT_CHILD          2   // Location is inside child specified by pvResultData
                                // (NOT YET IMPLEMENTED)

BEGIN_STRUCT(GMSG_QUERYHITTEST, GMSG_QUERY)
    POINT       ptClientPxl;    // Location in client pixels
    UINT        nResultCode;    // Result code
    void *      pvResultData;   // Extra result information
END_STRUCT(GMSG_QUERYHITTEST)


BEGIN_STRUCT(GMSG_QUERYPADDING, GMSG_QUERY)
    RECT        rcPadding;      // Extra padding around content
END_STRUCT(GMSG_QUERYPADDING)


#ifdef GADGET_ENABLE_OLE
BEGIN_STRUCT(GMSG_QUERYDROPTARGET, GMSG_QUERY)
    HGADGET     hgadDrop;       // Gadget actually specifying the DropTarget
    IDropTarget *
                pdt;            // DropTarget of Gadget
END_STRUCT(GMSG_QUERYDROPTARGET)
#endif // GADGET_ENABLE_OLE


#define GSYNC_RECT          (1)
#define GSYNC_XFORM         (2)
#define GSYNC_STYLE         (3)
#define GSYNC_PARENT        (4)

BEGIN_STRUCT(GMSG_SYNCADAPTOR, EventMsg)
    UINT        nCode;          // Change code
END_STRUCT(GMSG_SYNCADAPTOR)


typedef HRESULT     (CALLBACK * GADGETPROC)(HGADGET hgadCur, void * pvCur, EventMsg * pMsg);

#define SGM_FULL            0x00000001      // Route and bubble the message
#define SGM_RECEIVECONTEXT  0x00000002      // Use the receiving Gadget's Context
#define SGM_VALID          (SGM_FULL | SGM_RECEIVECONTEXT)

typedef struct tagFGM_INFO
{
    EventMsg* pmsg;             // Message to fire
    UINT        nFlags;         // Flags modifying message being fired
    HRESULT     hr;             // Result of message (if send)
    void *      pvReserved;     // Reserved
} FGM_INFO;

#define FGMQ_SEND           1   // Standard "Send" message queue
#define FGMQ_POST           2   // Standard "Post" message queue

DUSER_API   HRESULT     WINAPI  DUserSendMethod(MethodMsg * pmsg);
DUSER_API   HRESULT     WINAPI  DUserPostMethod(MethodMsg * pmsg);
DUSER_API   HRESULT     WINAPI  DUserSendEvent(EventMsg * pmsg, UINT nFlags);
DUSER_API   HRESULT     WINAPI  DUserPostEvent(EventMsg * pmsg, UINT nFlags);

DUSER_API   BOOL        WINAPI  FireGadgetMessages(FGM_INFO * rgFGM, int cMsgs, UINT idQueue);
DUSER_API   UINT        WINAPI  GetGadgetMessageFilter(HGADGET hgad, void * pvCookie);
DUSER_API   BOOL        WINAPI  SetGadgetMessageFilter(HGADGET hgad, void * pvCookie, UINT nNewFilter, UINT nMask);

DUSER_API   MSGID       WINAPI  RegisterGadgetMessage(const GUID * pguid);
DUSER_API   MSGID       WINAPI  RegisterGadgetMessageString(LPCWSTR pszName);
DUSER_API   BOOL        WINAPI  UnregisterGadgetMessage(const GUID * pguid);
DUSER_API   BOOL        WINAPI  UnregisterGadgetMessageString(LPCWSTR pszName);
DUSER_API   BOOL        WINAPI  FindGadgetMessages(const GUID ** rgpguid, MSGID * rgnMsg, int cMsgs);

DUSER_API   BOOL        WINAPI  AddGadgetMessageHandler(HGADGET hgadMsg, MSGID nMsg, HGADGET hgadHandler);
DUSER_API   BOOL        WINAPI  RemoveGadgetMessageHandler(HGADGET hgadMsg, MSGID nMsg, HGADGET hgadHandler);

DUSER_API   BOOL        WINAPI  GetMessageExA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DUSER_API   BOOL        WINAPI  GetMessageExW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DUSER_API   BOOL        WINAPI  PeekMessageExA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
DUSER_API   BOOL        WINAPI  PeekMessageExW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
DUSER_API   BOOL        WINAPI  WaitMessageEx();

#ifdef UNICODE
#define GetMessageEx        GetMessageExW
#define PeekMessageEx       PeekMessageExW
#else
#define GetMessageEx        GetMessageExA
#define PeekMessageEx       PeekMessageExA
#endif


/***************************************************************************\
*
* Construction, Tree management
*
\***************************************************************************/

#define GC_HWNDHOST         0x00000001      // + Host inside an HWND
#define GC_NCHOST           0x00000002      // | Host inside Non-client of HWND
#define GC_DXHOST           0x00000003      // | Host inside DirectX Surface
#define GC_COMPLEX          0x00000004      // | Complex TreeGadget
#define GC_SIMPLE           0x00000005      // | Simple TreeGadget
#define GC_DETACHED         0x00000006      // | Detached TreeGadget
#define GC_MESSAGE          0x00000007      // | Message-only Gadget
#define GC_TYPE             0x0000000F      // + Type of Gadget to create
#define GC_VALID           (GC_TYPE)

DUSER_API   HGADGET     WINAPI  CreateGadget(HANDLE hParent, UINT nFlags, GADGETPROC pfnProc, void * pvGadgetData);


#define GENUM_CURRENT       0x00000001      // Starting node in enumeration
#define GENUM_SIBLINGS      0x00000002      // Siblings of starting node in enumeration

                                            // + Type of enumeration (exclusive)
#define GENUM_PARENTSUP     0x00000004      // | Parents of this node going up
#define GENUM_PARENTSDOWN   0x00000008      // | Parents of this node going down
#define GENUM_SHALLOWCHILD  0x0000000C      // | Shallow children
#define GENUM_DEEPCHILD     0x00000010      // + Deep children
#define GENUM_TYPE         (GENUM_PARENTSUP | GENUM_PARENTSDOWN | \
                            GENUM_SHALLOWCHILD | GENUM_DEEPCHILD)

#define GENUM_MODIFYTREE    0x00000020      // Allow modifying the Tree during enumeration

#define GENUM_VALID         (GENUM_CURRENT | GENUM_SIBLINGS | GENUM_TYPE | GENUM_MODIFYTREE)

typedef BOOL    (CALLBACK * GADGETENUMPROC)(HGADGET hgad, void * pvData);

DUSER_API   BOOL        WINAPI  EnumGadgets(HGADGET hgadEnum, GADGETENUMPROC pfnProc, void * pvData, UINT nFlags);

#define GORDER_MIN          0
#define GORDER_ANY          0               // Order does not matter
#define GORDER_BEFORE       1               // Move this gadget in-front of sibling
#define GORDER_BEHIND       2               // Move this gadget behind sibling
#define GORDER_TOP          3               // Move to front of sibling z-order
#define GORDER_BOTTOM       4               // Move to bottom of sibling z-order
#define GORDER_FORWARD      5               // Move forward in z-order
#define GORDER_BACKWARD     6               // Move backward in z-order
#define GORDER_MAX          6

DUSER_API   BOOL        WINAPI  SetGadgetOrder(HGADGET hgadMove, HGADGET hgadOther, UINT nCmd);
DUSER_API   BOOL        WINAPI  SetGadgetParent(HGADGET hgadMove, HGADGET hgadParent, HGADGET hgadOther, UINT nCmd);


#define GG_MIN              0
#define GG_PARENT           0
#define GG_NEXT             1
#define GG_PREV             2
#define GG_TOPCHILD         3
#define GG_BOTTOMCHILD      4
#define GG_ROOT             5
#define GG_MAX              5

DUSER_API   HGADGET     WINAPI  GetGadget(HGADGET hgad, UINT nCmd);

/***************************************************************************\
*
* Styles and properties
*
\***************************************************************************/

#define GS_RELATIVE         0x00000001      // Positioning is relative to parent
#define GS_VISIBLE          0x00000002      // Drawing is visible
#define GS_ENABLED          0x00000004      // Input in "enabled"
#define GS_BUFFERED         0x00000008      // Drawing is double-buffered
#define GS_ALLOWSUBCLASS    0x00000010      // Gadget can be subclassed
#define GS_KEYBOARDFOCUS    0x00000020      // Gadget can receive keyboard focus
#define GS_MOUSEFOCUS       0x00000040      // Gadget can receive mouse focus
#define GS_CLIPINSIDE       0x00000080      // Clip drawing inside this Gadget
#define GS_CLIPSIBLINGS     0x00000100      // Clip siblings of this Gadget
#define GS_HREDRAW          0x00000200      // Redraw entire Gadget if resized horizontally
#define GS_VREDRAW          0x00000400      // Redraw entire Gadget if resized vertically
#define GS_OPAQUE           0x00000800      // HINT: Drawing is composited
#define GS_ZEROORIGIN       0x00001000      // Set origin to (0,0)
#define GS_CUSTOMHITTEST    0x00002000      // Requires custom hit-testing
#define GS_ADAPTOR          0x00004000      // Requires extra notifications to host
#define GS_CACHED           0x00008000      // Drawing is cached
#define GS_DEEPPAINTSTATE   0x00010000      // Sub-tree inherits paint state

#define GS_VALID           (GS_RELATIVE | GS_VISIBLE | GS_ENABLED | GS_BUFFERED |       \
                            GS_ALLOWSUBCLASS | GS_KEYBOARDFOCUS | GS_MOUSEFOCUS |       \
                            GS_CLIPINSIDE | GS_CLIPSIBLINGS | GS_HREDRAW | GS_VREDRAW | \
                            GS_OPAQUE | GS_ZEROORIGIN | GS_CUSTOMHITTEST |              \
                            GS_ADAPTOR | GS_CACHED | GS_DEEPPAINTSTATE)

DUSER_API   UINT        WINAPI  GetGadgetStyle(HGADGET hgad);
DUSER_API   BOOL        WINAPI  SetGadgetStyle(HGADGET hgadChange, UINT nNewStyle, UINT nMask);

DUSER_API   HGADGET     WINAPI  GetGadgetFocus();
DUSER_API   BOOL        WINAPI  SetGadgetFocus(HGADGET hgadFocus);
DUSER_API   BOOL        WINAPI  IsGadgetParentChainStyle(HGADGET hgad, UINT nStyle, BOOL * pfVisible, UINT nFlags);
inline BOOL IsGadgetVisible(HGADGET hgad, BOOL * pfVisible, UINT nFlags) {
    return IsGadgetParentChainStyle(hgad, GS_VISIBLE, pfVisible, nFlags); }
inline BOOL IsGadgetEnabled(HGADGET hgad, BOOL * pfEnabled, UINT nFlags) {
    return IsGadgetParentChainStyle(hgad, GS_ENABLED, pfEnabled, nFlags); }

DUSER_API   PRID        WINAPI  RegisterGadgetProperty(const GUID * pguid);
DUSER_API   BOOL        WINAPI  UnregisterGadgetProperty(const GUID * pguid);

DUSER_API   BOOL        WINAPI  GetGadgetProperty(HGADGET hgad, PRID id, void ** ppvValue);
DUSER_API   BOOL        WINAPI  SetGadgetProperty(HGADGET hgad, PRID id, void * pvValue);
DUSER_API   BOOL        WINAPI  RemoveGadgetProperty(HGADGET hgad, PRID id);


/***************************************************************************\
*
* Painting, Transforms
*
\***************************************************************************/

#define BLEND_OPAQUE        255
#define BLEND_TRANSPARENT   0

#define PI                  3.14159265359

DUSER_API   BOOL        WINAPI  InvalidateGadget(HGADGET hgad);
DUSER_API   BOOL        WINAPI  SetGadgetFillI(HGADGET hgadChange, HBRUSH hbrFill, BYTE bAlpha, int w, int h);
#ifdef GADGET_ENABLE_GDIPLUS
DUSER_API   BOOL        WINAPI  SetGadgetFillF(HGADGET hgadChange, Gdiplus::Brush * pgpbr);
#endif // GADGET_ENABLE_GDIPLUS
DUSER_API   BOOL        WINAPI  GetGadgetScale(HGADGET hgad, float * pflX, float * pflY);
DUSER_API   BOOL        WINAPI  SetGadgetScale(HGADGET hgadChange, float flX, float flY);
DUSER_API   BOOL        WINAPI  GetGadgetRotation(HGADGET hgad, float * pflRotationRad);
DUSER_API   BOOL        WINAPI  SetGadgetRotation(HGADGET hgadChange, float flRotationRad);
DUSER_API   BOOL        WINAPI  GetGadgetCenterPoint(HGADGET hgad, float * pflX, float * pflY);
DUSER_API   BOOL        WINAPI  SetGadgetCenterPoint(HGADGET hgadChange, float flX, float flY);


#define GBIM_STYLE          0x00000001
#define GBIM_ALPHA          0x00000002
#define GBIM_FILL           0x00000004
#define GBIM_VALID         (GBIM_STYLE | GBIM_ALPHA | GBIM_FILL)

#define GBIS_FILL           0x00000001
#define GBIS_VALID         (GBIS_FILL)

typedef struct tagBUFFER_INFO
{
    DWORD       cbSize;
    UINT        nMask;
    UINT        nStyle;
    BYTE        bAlpha;
    COLORREF    crFill;
} BUFFER_INFO;

DUSER_API   BOOL        WINAPI  GetGadgetBufferInfo(HGADGET hgad, BUFFER_INFO * pbi);
DUSER_API   BOOL        WINAPI  SetGadgetBufferInfo(HGADGET hgadChange, const BUFFER_INFO * pbi);


#define GRT_VISRGN          0               // VisRgn in container coordinates
#define GRT_MIN             0
#define GRT_MAX             0

DUSER_API   BOOL        WINAPI  GetGadgetRgn(HGADGET hgad, UINT nRgnType, HRGN hrgn, UINT nFlags);

#define GRIM_OPTIONS        0x00000001      // nOptions is valid
#define GRIM_SURFACE        0x00000002      // nSurface is valid
#define GRIM_PALETTE        0x00000004      // Palette is valid
#define GRIM_DROPTARGET     0x00000008      // nDropTarget is valid
#define GRIM_VALID         (GRIM_OPTIONS | GRIM_SURFACE | GRIM_PALETTE | GRIM_DROPTARGET)

#define GSURFACE_MIN        0
#define GSURFACE_HDC        0               // HDC
#define GSURFACE_GPGRAPHICS 1               // Gdiplus::Graphics
#define GSURFACE_MAX        1

#define GRIO_MANUALDRAW     0x00000001      // Call DrawGadgetTree() to draw.
#define GRIO_VALID         (GRIO_MANUALDRAW)

#define GRIDT_MIN           0
#define GRIDT_NONE          0               // Not a drop target
#define GRIDT_FAST          1               // Using OLE2 polling DnD
#define GRIDT_PRECISE       2               // Rescan for positional changes
#define GRIDT_MAX           2

typedef struct tagROOT_INFO
{
    DWORD       cbSize;
    UINT        nMask;
    UINT        nOptions;
    UINT        nSurface;
    UINT        nDropTarget;

    union {
        void *      pvData;
        HPALETTE    hpal;
#ifdef GADGET_ENABLE_GDIPLUS
        Gdiplus::ColorPalette * 
                    pgppal;
#endif // GADGET_ENABLE_GDIPLUS
    };
} ROOT_INFO;

DUSER_API   BOOL        WINAPI  GetGadgetRootInfo(HGADGET hgadRoot, ROOT_INFO * pri);
DUSER_API   BOOL        WINAPI  SetGadgetRootInfo(HGADGET hgadRoot, const ROOT_INFO * pri);


#define GAIO_MOUSESTATE     0x00000001      // Synchronize mouse state
#define GAIO_KEYBOARDSTATE  0x00000002      // Synchronize keyboard state
#define GAIO_ENABLECAPTURE  0x00000004      // Synchronize mouse capture state

#define GAIM_OPTIONS        0x00000001      // nOptions is valid

typedef struct tagADAPTOR_INFO
{
    DWORD       cbSize;
    UINT        nMask;
    UINT        nOptions;
} ADAPTOR_INFO;

DUSER_API   BOOL        WINAPI  GetGadgetAdaptorInfo(HGADGET hgadAdaptor, ADAPTOR_INFO * pai);
DUSER_API   BOOL        WINAPI  SetGadgetAdaptorInfo(HGADGET hgadAdaptor, const ADAPTOR_INFO * pai);


/***************************************************************************\
*
* Position
*
\***************************************************************************/

#define SGR_MOVE            0x00000001      // Gadget is being moved
#define SGR_SIZE            0x00000002      // Gadget is being resized
#define SGR_CHANGEMASK     (SGR_MOVE | SGR_SIZE)

#define SGR_CLIENT          0x00000004      // Relative to itself
#define SGR_PARENT          0x00000008      // Relative to parent
#define SGR_CONTAINER       0x0000000c      // Relative to root container
#define SGR_DESKTOP         0x00000010      // Relative to virtual desktop
#define SGR_OFFSET          0x00000014      // Relative to current position
#define SGR_RECTMASK       (SGR_CLIENT | SGR_PARENT | SGR_CONTAINER | \
                            SGR_DESKTOP | SGR_OFFSET)

#define SGR_ACTUAL          0x00000100      // Actual (non-XForm) rectangle
#define SGR_NOINVALIDATE    0x00000200      // Don't automatically invalidate

#define SGR_VALID_GET      (SGR_RECTMASK | SGR_ACTUAL)
#define SGR_VALID_SET      (SGR_CHANGEMASK | SGR_RECTMASK | SGR_ACTUAL | SGR_NOINVALIDATE)

DUSER_API   BOOL        WINAPI  GetGadgetSize(HGADGET hgad, SIZE * psizeLogicalPxl);
DUSER_API   BOOL        WINAPI  GetGadgetRect(HGADGET hgad, RECT * prcPxl, UINT nFlags);
DUSER_API   BOOL        WINAPI  SetGadgetRect(HGADGET hgadChange, int x, int y, int w, int h, UINT nFlags);


DUSER_API   HGADGET     WINAPI  FindGadgetFromPoint(HGADGET hgadRoot, POINT ptContainerPxl, UINT nStyle, POINT * pptClientPxl);
DUSER_API   BOOL        WINAPI  MapGadgetPoints(HGADGET hgadFrom, HGADGET hgadTo, POINT * rgptClientPxl, int cPts);


/***************************************************************************\
*
* Tickets
*
\***************************************************************************/

DUSER_API   DWORD        WINAPI  GetGadgetTicket(HGADGET hgad);
DUSER_API   HGADGET      WINAPI  LookupGadgetTicket(DWORD dwTicket);

/***************************************************************************\
*
* Special hooks for different containers
*
\***************************************************************************/

DUSER_API   BOOL        WINAPI  ForwardGadgetMessage(HGADGET hgadRoot, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * pr);

#define GDRAW_SHOW          0x00000001
#define GDRAW_VALID         (GDRAW_SHOW)

DUSER_API   BOOL        WINAPI  DrawGadgetTree(HGADGET hgadDraw, HDC hdcDraw, const RECT * prcDraw, UINT nFlags);

typedef BOOL (CALLBACK* ATTACHWNDPROC)(void * pvThis, HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRet);
DUSER_API   BOOL        WINAPI  AttachWndProcA(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);
DUSER_API   BOOL        WINAPI  AttachWndProcW(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);
DUSER_API   BOOL        WINAPI  DetachWndProc(HWND hwnd, ATTACHWNDPROC pfn, void * pvThis);

#ifdef UNICODE
#define AttachWndProc       AttachWndProcW
#else
#define AttachWndProc       AttachWndProcA
#endif

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duserutil.h ===
#if !defined(INC__DUserUtil_h__INCLUDED)
#define INC__DUserUtil_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

DUSER_API   BOOL        WINAPI  UtilSetBackground(HGADGET hgadChange, HBRUSH hbrBack);


/*
 * Utility Functions
 */

#define FS_NORMAL           0x00000000
#define FS_BOLD             0x00000001
#define FS_ITALIC           0x00000002
#define FS_UNDERLINE        0x00000004
#define FS_STRIKEOUT        0x00000008
#define FS_COMPATIBLE       0x00000010  // Use non-Gadget mechanism for computing size

DUSER_API   HFONT       WINAPI  UtilBuildFont(LPCWSTR pszName, int idxDeciSize, DWORD nFlags, HDC hdcDevice DEFARG(NULL));
DUSER_API   BOOL        WINAPI  UtilDrawBlendRect(HDC hdcDest, const RECT * prcDest, HBRUSH hbrFill, BYTE bAlpha, int wBrush, int hBrush);
DUSER_API   BOOL        WINAPI  UtilDrawOutlineRect(HDC hdc, const RECT * prcPxl, HPEN hpenDraw, int nThickness DEFARG(1));
DUSER_API   COLORREF    WINAPI  UtilGetColor(HBITMAP hbmp, POINT * pptPxl DEFARG(NULL));

/***************************************************************************\
*
* Color management
*
\***************************************************************************/

#define SC_AliceBlue            (0)
#define SC_AntiqueWhite         (1)
#define SC_Aqua                 (2)
#define SC_Aquamarine           (3)
#define SC_Azure                (4)
#define SC_Beige                (5)
#define SC_Bisque               (6)
#define SC_Black                (7)
#define SC_BlanchedAlmond       (8)
#define SC_Blue                 (9)
#define SC_BlueViolet           (10)
#define SC_Brown                (11)
#define SC_BurlyWood            (12)
#define SC_CadetBlue            (13)
#define SC_Chartreuse           (14)
#define SC_Chocolate            (15)
#define SC_Coral                (16)
#define SC_CornflowerBlue       (17)
#define SC_Cornsilk             (18)
#define SC_Crimson              (19)
#define SC_Cyan                 (20)
#define SC_DarkBlue             (21)
#define SC_DarkCyan             (22)
#define SC_DarkGoldenrod        (23)
#define SC_DarkGray             (24)
#define SC_DarkGreen            (25)
#define SC_DarkKhaki            (26)
#define SC_DarkMagenta          (27)
#define SC_DarkOliveGreen       (28)
#define SC_DarkOrange           (29)
#define SC_DarkOrchid           (30)
#define SC_DarkRed              (31)
#define SC_DarkSalmon           (32)
#define SC_DarkSeaGreen         (33)
#define SC_DarkSlateBlue        (34)
#define SC_DarkSlateGray        (35)
#define SC_DarkTurquoise        (36)
#define SC_DarkViolet           (37)
#define SC_DeepPink             (38)
#define SC_DeepSkyBlue          (39)
#define SC_DimGray              (40)
#define SC_DodgerBlue           (41)
#define SC_FireBrick            (42)
#define SC_FloralWhite          (43)
#define SC_ForestGreen          (44)
#define SC_Fuchsia              (45)
#define SC_Gainsboro            (46)
#define SC_GhostWhite           (47)
#define SC_Gold                 (48)
#define SC_Goldenrod            (49)
#define SC_Gray                 (50)
#define SC_Green                (51)
#define SC_GreenYellow          (52)
#define SC_Honeydew             (53)
#define SC_HotPink              (54)
#define SC_IndianRed            (55)
#define SC_Indigo               (56)
#define SC_Ivory                (57)
#define SC_Khaki                (58)
#define SC_Lavender             (59)
#define SC_LavenderBlush        (60)
#define SC_LawnGreen            (61)
#define SC_LemonChiffon         (62)
#define SC_LightBlue            (63)
#define SC_LightCoral           (64)
#define SC_LightCyan            (65)
#define SC_LightGoldenrodYellow (66)
#define SC_LightGreen           (67)
#define SC_LightGrey            (68)
#define SC_LightPink            (69)
#define SC_LightSalmon          (70)
#define SC_LightSeaGreen        (71)
#define SC_LightSkyBlue         (72)
#define SC_LightSlateGray       (73)
#define SC_LightSteelBlue       (74)
#define SC_LightYellow          (75)
#define SC_Lime                 (76)
#define SC_LimeGreen            (77)
#define SC_Linen                (78)
#define SC_Magenta              (79)
#define SC_Maroon               (80)
#define SC_MediumAquamarine     (81)
#define SC_MediumBlue           (82)
#define SC_MediumOrchid         (83)
#define SC_MediumPurple         (84)
#define SC_MediumSeaGreen       (85)
#define SC_MediumSlateBlue      (86)
#define SC_MediumSpringGreen    (87)
#define SC_MediumTurquoise      (88)
#define SC_MediumVioletRed      (89)
#define SC_MidnightBlue         (90)
#define SC_MintCream            (91)
#define SC_MistyRose            (92)
#define SC_Moccasin             (93)
#define SC_NavajoWhite          (94)
#define SC_Navy                 (95)
#define SC_OldLace              (96)
#define SC_Olive                (97)
#define SC_OliveDrab            (98)
#define SC_Orange               (99)
#define SC_OrangeRed            (100)
#define SC_Orchid               (101)
#define SC_PaleGoldenrod        (102)
#define SC_PaleGreen            (103)
#define SC_PaleTurquoise        (104)
#define SC_PaleVioletRed        (105)
#define SC_PapayaWhip           (106)
#define SC_PeachPuff            (107)
#define SC_Peru                 (108)
#define SC_Pink                 (109)
#define SC_Plum                 (110)
#define SC_PowderBlue           (111)
#define SC_Purple               (112)
#define SC_Red                  (113)
#define SC_RosyBrown            (114)
#define SC_RoyalBlue            (115)
#define SC_SaddleBrown          (116)
#define SC_Salmon               (117)
#define SC_SandyBrown           (118)
#define SC_SeaGreen             (119)
#define SC_Seashell             (120)
#define SC_Sienna               (121)
#define SC_Silver               (122)
#define SC_SkyBlue              (123)
#define SC_SlateBlue            (124)
#define SC_SlateGray            (125)
#define SC_Snow                 (126)
#define SC_SpringGreen          (127)
#define SC_SteelBlue            (128)
#define SC_Tan                  (129)
#define SC_Teal                 (130)
#define SC_Thistle              (131)
#define SC_Tomato               (132)
#define SC_Turquoise            (133)
#define SC_Violet               (134)
#define SC_Wheat                (135)
#define SC_White                (136)
#define SC_WhiteSmoke           (137)
#define SC_Yellow               (138)
#define SC_YellowGreen          (139)
#define SC_MAXCOLORS            (139)

DUSER_API   COLORREF    WINAPI  GetStdColorI(UINT c);
DUSER_API   HBRUSH      WINAPI  GetStdColorBrushI(UINT c);
DUSER_API   HPEN        WINAPI  GetStdColorPenI(UINT c);
#ifdef GADGET_ENABLE_GDIPLUS

#ifdef __cplusplus
};  // extern "C"

DUSER_API   Gdiplus::Color
                        WINAPI  GetStdColorF(UINT c);
DUSER_API   Gdiplus::Brush *
                        WINAPI  GetStdColorBrushF(UINT c);
DUSER_API   Gdiplus::Pen *
                        WINAPI  GetStdColorPenF(UINT c);

extern "C" {
#endif

#endif // GADGET_ENABLE_GDIPLUS
DUSER_API   LPCWSTR     WINAPI  GetStdColorName(UINT c);
DUSER_API   UINT        WINAPI  FindStdColor(LPCWSTR pszName);
DUSER_API   HPALETTE    WINAPI  GetStdPalette();

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserUtil_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\dusererror.h ===
/***************************************************************************\
*
* File: DUserError.h
*
* Description:
* DUserError.h defines the DirectUser error values common across all of
* DirectUser.
*
* Copyright (C) 2000 by Microsoft Corporation.  All rights reserved.
*
\***************************************************************************/

#if !defined(INC__DUserError_h__INCLUDED)
#define INC__DUserError_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

#define FACILITY_DUSER  FACILITY_ITF
#define MAKE_DUSUCCESS(code)    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DUSER, code)
#define MAKE_DUERROR(code)      MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DUSER, code)

/***************************************************************************\
*
* Error codes
*
\***************************************************************************/

// Callback function definitions

/*
 * Message was not handled at all.
 */
#define DU_S_NOTHANDLED             MAKE_DUSUCCESS(0)

/*
 * Message was completely handled (stop bubbling).
 */
#define DU_S_COMPLETE               MAKE_DUSUCCESS(1)

/*
 * Message was partially handled (continue bubbling).
 */
#define DU_S_PARTIAL                MAKE_DUSUCCESS(2)

/*
 * Enumeration was successful but prematurely stopped by the enumeration 
 * function
 */
#define DU_S_STOPPEDENUMERATION     MAKE_DUSUCCESS(10)


/*
 * The operation was successful, but the object was already created.
 */
#define DU_S_ALREADYEXISTS          MAKE_DUSUCCESS(20)

/*
 * There are not enough Kernel resources to perform the operation
 */
#define DU_E_OUTOFKERNELRESOURCES   MAKE_DUERROR(1)

/*
 * There are not enough GDI resources to perform the operation
 */
#define DU_E_OUTOFGDIRESOURCES      MAKE_DUERROR(2)

/*
 * Generic failure.
 */
#define DU_E_GENERIC                MAKE_DUERROR(10)

/*
 * Generic failure.
 */
#define DU_E_BUSY                   MAKE_DUERROR(11)

/*
 * The Context has not been initialized with InitGadgets().
 */
#define DU_E_NOCONTEXT              MAKE_DUERROR(20)

 /*
 * The object was used in the incorrect context.
 */
#define DU_E_INVALIDCONTEXT         MAKE_DUERROR(30)

/*
 * The Context has been marked to only allow read-only operations.  For example,
 * this may be in the middle of a read-only callback.
 */
#define DU_E_READONLYCONTEXT        MAKE_DUERROR(31)

/*
 * The threading model has already be determined by a previous call to 
 * InitGadgets() and can no longer be changed.
 */
#define DU_E_THREADINGALREADYSET    MAKE_DUERROR(32)

/*
 * Unable to use the IGMM_STANDARD messaging model because it is either 
 * unsupported or cannot be installed.
 */
#define DU_E_CANNOTUSESTANDARDMESSAGING MAKE_DUERROR(33)

/*
 * Can not mix an invalid coordinate mapping, for example having a non-relative
 * child of a relative parent.
 */
#define DU_E_BADCOORDINATEMAP       MAKE_DUERROR(40)

/*
 * Could not find a MSGID for one of the requested messages.  This will be 
 * represented by a '0' in the MSGID field for that message.
 */
#define DU_E_CANNOTFINDMSGID        MAKE_DUERROR(50)

/*
 * The operation is not legal because the specified Gadget does not have a 
 * GS_BUFFERED style.
 */
#define DU_E_NOTBUFFERED            MAKE_DUERROR(60)

/*
 * The specific Gadget has started the destruction and can not be be modified
 * in this manner.
 */
#define DU_E_STARTDESTROY           MAKE_DUERROR(70)

/*
 * The specified DirectUser optional component has not yet been initialized with
 * InitGadgetComponent().
 */
#define DU_E_NOTINITIALIZED         MAKE_DUERROR(80)

/*
 * The specified DirectUser object was not found.
 */
#define DU_E_NOTFOUND               MAKE_DUERROR(90)

/*
 * The specified parmeters are mismatched for the current object state.  For
 * example, the object is specified to use GDI HANDLE's, but the parameter was
 * a GDI+ Object.
 */
#define DU_E_MISMATCHEDTYPES        MAKE_DUERROR(100)

/*
 * GDI+ was unable to be loaded.  It may not be installed on the system or may
 * not be properly initialized.
 */
#define DU_E_CANNOTLOADGDIPLUS      MAKE_DUERROR(110)

/*
 * The specified class was already registered.
 */
#define DU_E_CLASSALREADYREGISTERED MAKE_DUERROR(120)

/*
 * The specified message was not found during class registration.
 */
#define DU_E_MESSAGENOTFOUND        MAKE_DUERROR(121)

/*
 * The specified message was not implemented during class registration.
 */
#define DU_E_MESSAGENOTIMPLEMENTED  MAKE_DUERROR(122)

/*
 * The implementation of the specific class has not yet been registered.
 */
#define DU_E_CLASSNOTIMPLEMENTED    MAKE_DUERROR(123)

/*
 * Sending the message failed.
 */
#define DU_E_MESSAGEFAILED          MAKE_DUERROR(124)


#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserCore_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\dusermotion.h ===
#if !defined(INC__DUserMotion_h__INCLUDED)
#define INC__DUserMotion_h__INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif

/***************************************************************************\
*
* Transitions
*
\***************************************************************************/

#define GTX_TYPE_DXFORM2D       1
#define GTX_TYPE_DXFORM3DRM     2

#define GTX_ITEMTYPE_NONE       0
#define GTX_ITEMTYPE_BITMAP     1
#define GTX_ITEMTYPE_HDC        2
#define GTX_ITEMTYPE_HWND       3
#define GTX_ITEMTYPE_GADGET     4
#define GTX_ITEMTYPE_DXSURFACE  5

#define GTX_EXEC_FORWARD        0x000000000
#define GTX_EXEC_BACKWARD       0x000000001
#define GTX_EXEC_DIR            0x000000001
#define GTX_EXEC_CACHE          0x000000002
#define GTX_EXEC_VALID          (GTX_EXEC_DIR | GTX_EXEC_CACHE)

#define GTX_IF_CROP             0x000000001
#define GTX_IF_VALID            (GTX_IF_CROP)

//
// Standard Transition header
//
struct GTX_TRXDESC
{
    UINT        tt;
};


//
// DirectX Transforms 2D
//

//
// TODO: Change implementation of DXTX2D to have better support for using Trx
// with only one input.  Should automatically create a secondary surface of a
// specified color-key that can be use to transition to.
//

struct GTX_DXTX2D_TRXDESC : public GTX_TRXDESC
{
    CLSID       clsidTransform;
    float       flDuration;
    LPCWSTR     pszCopyright;
};


//
// DirectX Transforms 3D Retained Mode
//
struct GTX_DXTX3DRM_TRXDESC : public GTX_TRXDESC
{
    CLSID       clsidTransform;
    float       flDuration;
    LPCWSTR     pszCopyright;
    IUnknown *  pRM;
};

struct GTX_ITEM
{
    UINT        nFlags;
    UINT        it;
    void *      pvData;
    RECT        rcCrop;
};

struct GTX_PLAY
{
    GTX_ITEM    rgIn[2];
    GTX_ITEM    gxiOut;
    UINT        nFlags;
};

DECLARE_HANDLE(HTRANSITION);

DUSER_API   HTRANSITION WINAPI  CreateTransition(const GTX_TRXDESC * ptx);
DUSER_API   BOOL        WINAPI  PlayTransition(HTRANSITION htrx, const GTX_PLAY * pgx);
DUSER_API   BOOL        WINAPI  GetTransitionInterface(HTRANSITION htrx, IUnknown ** ppUnk);

DUSER_API   BOOL        WINAPI  BeginTransition(HTRANSITION htrx, const GTX_PLAY * pgx);
DUSER_API   BOOL        WINAPI  PrintTransition(HTRANSITION htrx, float fProgress);
DUSER_API   BOOL        WINAPI  EndTransition(HTRANSITION htrx, const GTX_PLAY * pgx);


/***************************************************************************\
*
* Actions
*
\***************************************************************************/

struct GMA_ACTION;

DECLARE_HANDLE(HACTION);

struct GMA_ACTIONINFO
{
    HACTION     hact;           // Handle
    void *      pvData;         // Caller data
    float       flDuration;     // Duration in seconds
    float       flProgress;     // Progress (0 - 1)
    int         cEvent;         // Number of callbacks in this period
    int         cPeriods;       // Number of periods
    BOOL        fFinished;      // TODO: Change to a command
};

typedef void    (CALLBACK * ACTIONPROC)(GMA_ACTIONINFO * pmai);

struct GMA_ACTION
{
    DWORD       cbSize;         // Size of structure
    float       flDelay;        // Delay in seconds before starting
    float       flDuration;     // Duration in seconds of each period (0 = single shot)
    float       flPeriod;       // Time between beginnings of repeats (0 = no gap)
    UINT        cRepeat;        // Number of times to repeat (0 = single, -1 = infinite)
    DWORD       dwPause;        // Pause between callbacks (0 = default, -1 = none)
    ACTIONPROC  pfnProc;        // Function to call
    void *      pvData;         // Caller data
};


DUSER_API   HACTION     WINAPI  CreateAction(const GMA_ACTION * pma);
DUSER_API   BOOL        WINAPI  GetActionTimeslice(DWORD * pdwTimeslice);
DUSER_API   BOOL        WINAPI  SetActionTimeslice(DWORD dwTimeslice);

/***************************************************************************\
*
* Animations
*
\***************************************************************************/

class Visual;

namespace DUser
{

struct KeyFrame
{
    DWORD       cbSize;
};

};  // namespace DUser

DUSER_API   void        WINAPI  DUserStopAnimation(Visual * pgvSubject, PRID pridAni);

DUSER_API   PRID        WINAPI  DUserGetAlphaPRID();
DUSER_API   PRID        WINAPI  DUserGetRectPRID();
DUSER_API   PRID        WINAPI  DUserGetRotatePRID();
DUSER_API   PRID        WINAPI  DUserGetScalePRID();

#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserMotion_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\windows\inc\duser\duserservices.h ===
#if !defined(INC__DUserServices_h__INCLUDED)
#define INC__DUserServices_h__INCLUDED

/*
 * Include dependencies
 */

#include <limits.h>             // Standard constants

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DUSER_EXPORTS
#define DUSER_API
#else
#define DUSER_API __declspec(dllimport)
#endif




#ifdef __cplusplus
};  // extern "C"
#endif

#endif // INC__DUserServices_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\oak\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddkmapi.h
 *  Content:	Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD  dwFunctionNum,
    LPVOID lpvInBuffer,
    DWORD  cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD  cbOutBuffer
);

typedef
DWORD
(FAR PASCAL *LPDXAPI)(
    DWORD   dwFunctionNum,
    LPVOID  lpvInBuffer,
    DWORD   cbInBuffer,
    LPVOID  lpvOutBuffer,
    DWORD   cbOutBuffer
);

#define DXAPI_MAJORVERSION		1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI					0x500

typedef ULONG (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        ULONG_PTR            dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
	HANDLE	            hDirectDraw;
        ULONG_PTR            dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
	HANDLE		    hDirectDraw;
        ULONG               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
	DWORD	ddRVal;
        DWORD	dwCaps;
	DWORD	dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
	DWORD	ddRVal;
	DWORD	dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER			(DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD			(DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	DWORD	dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE			(DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
	DWORD	ddRVal;
	DWORD	dwStateCaps;
	DWORD	dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE			(DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
	DWORD	dwState;
	DWORD	dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK					(DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
	DWORD	ddRVal;
	DWORD	dwSurfHeight;
	DWORD	dwSurfWidth;
	LONG	lSurfPitch;
	PVOID	lpSurface;
	DWORD	SurfaceCaps;
	DWORD	dwFormatFlags;
	DWORD	dwFormatFourCC;
	DWORD	dwFormatBitCount;
	union
	{
	    DWORD	dwRBitMask;
	    DWORD	dwYBitMask;
    	};
    	union
    	{
	    DWORD	dwGBitMask;
	    DWORD	dwUBitMask;
	};
	union
	{
	    DWORD	dwBBitMask;
	    DWORD	dwVBitMask;
	};
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY				(DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
	HANDLE	hDirectDraw;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP				(DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
	HANDLE	hCurrentSurface;
	HANDLE	hTargetSurface;
	DWORD	dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE	(DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
	HANDLE	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
	DWORD	ddRVal;
	HANDLE	hVideoSurface;
	HANDLE	hVBISurface;
	BOOL	bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE		(DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK			(DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
	HANDLE 	            hDirectDraw;
	ULONG	            dwEvents;
	LPDD_NOTIFYCALLBACK pfnCallback;
	ULONG_PTR            dwParam1;
	ULONG_PTR            dwParam2;
	PVOID	            pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK			(DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY				(DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
	HANDLE 	hDirectDraw;
	HANDLE	hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
	DWORD 	ddRVal;
	BOOL	bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE			(DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
	HANDLE  hDirectDraw;
	HANDLE  hVideoPort;
	DWORD   dwStartLine;
	DWORD   dwEndLine;
	DWORD   dwCaptureEveryNFields;
	LPDD_NOTIFYCALLBACK pfnCaptureClose;
	PVOID   pContext;
	DWORD	dwFlags;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
	DWORD	ddRVal;
	HANDLE	hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

    #define DDOPENCAPTURE_VIDEO	0x0001	// Capture from the video stream
    #define DDOPENCAPTURE_VBI	0x0002	// Capture from the VBI stream

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER			(DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
	DWORD   	dwFieldNumber;
	DWORD   	bPolarity;
	LARGE_INTEGER	liTimeStamp;
	DWORD   	ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
	HANDLE  hCapture;
	DWORD   dwFlags;
	PMDL    pMDL;
	PKEVENT pKEvent;
	LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY	0x0001	// lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM	0x0002	// lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT		0x0004	// invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS			(DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB				0x0001
#define DDSTATE_WEAVE				0x0002
#define DDSTATE_EXPLICITLY_SET			0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP		0x0008
#define DDSTATE_SKIPEVENFIELDS			0x0010

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC			0x0001
#define DDEVENT_VP_VSYNC			0x0002
#define DDEVENT_VP_LINE				0x0004
#define DDEVENT_PRERESCHANGE			0x0008
#define DDEVENT_POSTRESCHANGE			0x0010
#define DDEVENT_PREDOSBOX			0x0020
#define DDEVENT_POSTDOSBOX			0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC			0x0001	// dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC			0x0002	// dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE	  		0x0004	// dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE			0x0008	// dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE			0x0010	// dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX			0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX			0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW		0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE			0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT			0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE			0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\oak\inc\d3dnthal.h ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dnthal.h
 *  Content:    Direct3D HAL include file for NT
 *
 ***************************************************************************/

#ifndef _D3DNTHAL_H_
#define _D3DNTHAL_H_

#include <ddrawint.h>
#ifndef _WINDOWS_
#define _WINDOWS_
#include <d3dtypes.h>
#include <d3dcaps.h>
#undef _WINDOWS_
#else
#include <d3dtypes.h>
#include <d3dcaps.h>
#endif

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DNTHAL_NUMCLIPVERTICES    20

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DNTHAL_DEFAULT_TL_NUM ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DNTHAL_DEFAULT_H_NUM  ((32 * 1024) / sizeof (D3DHVERTEX))

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 *
 * For DX5 and subsequent runtimes, D3DNTDEVICEDESC is a user-visible
 * structure that is not seen by the device drivers. The runtime
 * stitches a D3DNTDEVICEDESC together using the D3DNTDEVICEDESC_V1
 * embedded in the GLOBALDRIVERDATA and the extended caps queried
 * from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V1 {
    DWORD               dwSize;                     // Size of D3DNTHALDEVICEDESC_V1 structure
    DWORD               dwFlags;                    // Indicates which fields have valid data
    D3DCOLORMODEL       dcmColorModel;              // Color model of device
    DWORD               dwDevCaps;                  // Capabilities of device
    D3DTRANSFORMCAPS    dtcTransformCaps;           // Capabilities of transform
    BOOL                bClipping;                  // Device can do 3D clipping
    D3DLIGHTINGCAPS     dlcLightingCaps;            // Capabilities of lighting
    D3DPRIMCAPS         dpcLineCaps;
    D3DPRIMCAPS         dpcTriCaps;
    DWORD               dwDeviceRenderBitDepth;     // One of DDBB_8, 16, etc..
    DWORD               dwDeviceZBufferBitDepth;    // One of DDBD_16, 32, etc..
    DWORD               dwMaxBufferSize;            // Maximum execute buffer size
    DWORD               dwMaxVertexCount;           // Maximum vertex count
} D3DNTHALDEVICEDESC_V1, *LPD3DNTHALDEVICEDESC_V1;

#define D3DNTHALDEVICEDESCSIZE_V1 (sizeof(D3DNTHALDEVICEDESC_V1))

/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX5, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX5.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTHALDeviceDesc_V2 {
    DWORD               dwSize;                     // Size of D3DNTDEVICEDESC structure
    DWORD               dwFlags;                    // Indicates which fields have valid data
    D3DCOLORMODEL       dcmColorModel;              // Color model of device
    DWORD               dwDevCaps;                  // Capabilities of device
    D3DTRANSFORMCAPS    dtcTransformCaps;           // Capabilities of transform
    BOOL                bClipping;                  // Device can do 3D clipping
    D3DLIGHTINGCAPS     dlcLightingCaps;            // Capabilities of lighting
    D3DPRIMCAPS         dpcLineCaps;
    D3DPRIMCAPS         dpcTriCaps;
    DWORD               dwDeviceRenderBitDepth;     // One of DDBD_16, etc..
    DWORD               dwDeviceZBufferBitDepth;    // One of DDBD_16, 32, etc..
    DWORD               dwMaxBufferSize;            // Maximum execute buffer size
    DWORD               dwMaxVertexCount;           // Maximum vertex count

    DWORD               dwMinTextureWidth, dwMinTextureHeight;
    DWORD               dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD               dwMinStippleWidth, dwMaxStippleWidth;
    DWORD               dwMinStippleHeight, dwMaxStippleHeight;

} D3DNTHALDEVICEDESC_V2, *LPD3DNTHALDEVICEDESC_V2;

#define D3DNTHALDEVICEDESCSIZE_V2 (sizeof(D3DNTHALDEVICEDESC_V2))

#if(DIRECT3D_VERSION >= 0x0700)
/*
 * This is equivalent to the D3DNTDEVICEDESC understood by DX6, available only
 * from DX6. It is the same as D3DNTDEVICEDESC structure in DX6.
 * D3DNTDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DNTDEVICEDESC together using the
 * D3DNTDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DNTDeviceDesc_V3 {
    DWORD               dwSize;                     // Size of D3DNTDEVICEDESC structure
    DWORD               dwFlags;                    // Indicates which fields have valid data
    D3DCOLORMODEL       dcmColorModel;              // Color model of device
    DWORD               dwDevCaps;                  // Capabilities of device
    D3DTRANSFORMCAPS    dtcTransformCaps;           // Capabilities of transform
    BOOL                bClipping;                  // Device can do 3D clipping
    D3DLIGHTINGCAPS     dlcLightingCaps;            // Capabilities of lighting
    D3DPRIMCAPS         dpcLineCaps;
    D3DPRIMCAPS         dpcTriCaps;
    DWORD               dwDeviceRenderBitDepth;     // One of DDBD_16, etc..
    DWORD               dwDeviceZBufferBitDepth;    // One of DDBD_16, 32, etc..
    DWORD               dwMaxBufferSize;            // Maximum execute buffer size
    DWORD               dwMaxVertexCount;           // Maximum vertex count

    DWORD               dwMinTextureWidth, dwMinTextureHeight;
    DWORD               dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD               dwMinStippleWidth, dwMaxStippleWidth;
    DWORD               dwMinStippleHeight, dwMaxStippleHeight;

    DWORD               dwMaxTextureRepeat;
    DWORD               dwMaxTextureAspectRatio;
    DWORD               dwMaxAnisotropy;
    D3DVALUE            dvGuardBandLeft;
    D3DVALUE            dvGuardBandTop;
    D3DVALUE            dvGuardBandRight;
    D3DVALUE            dvGuardBandBottom;
    D3DVALUE            dvExtentsAdjust;
    DWORD               dwStencilCaps;
    DWORD               dwFVFCaps;                  // low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware
    DWORD               dwTextureOpCaps;
    WORD                wMaxTextureBlendStages;
    WORD                wMaxSimultaneousTextures;
} D3DNTDEVICEDESC_V3, *LPD3DNTDEVICEDESC_V3;

#define D3DNTDEVICEDESCSIZE_V3 (sizeof(D3DNTDEVICEDESC_V3))
#endif /* DIRECT3D_VERSION >= 0x0700 */
/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 *
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */
typedef struct _D3DNTHAL_GLOBALDRIVERDATA {
    DWORD                   dwSize;                 // Size of this structure
    D3DNTHALDEVICEDESC_V1   hwCaps;                 // Capabilities of the hardware
    DWORD                   dwNumVertices;          // see following comment
    DWORD                   dwNumClipVertices;      // see following comment
    DWORD                   dwNumTextureFormats;    // Number of texture formats
    LPDDSURFACEDESC lpTextureFormats;               // Pointer to texture formats
} D3DNTHAL_GLOBALDRIVERDATA;
typedef D3DNTHAL_GLOBALDRIVERDATA *LPD3DNTHAL_GLOBALDRIVERDATA;

#define D3DNTHAL_GLOBALDRIVERDATASIZE (sizeof(D3DNTHAL_GLOBALDRIVERDATA))

#if(DIRECT3D_VERSION >= 0x0700)
/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DDX6EXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    // fields added for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;              // low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

} D3DNTHAL_D3DDX6EXTENDEDCAPS;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DNTHAL_D3DEXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure
    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    // fields added for DX6
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;              // 0 implies TLVERTEX only, 1..8 imply full FVF aware
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
#if(DIRECT3D_VERSION >= 0x0700)
    // fields added for DX7
    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DNTHAL_D3DEXTENDEDCAPS;

typedef D3DNTHAL_D3DEXTENDEDCAPS *LPD3DNTHAL_D3DEXTENDEDCAPS;

#define D3DNTHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DEXTENDEDCAPS))

// This is a temporary fix to make older NT drivers to compile
#define dvVertexProcessingCaps dwVertexProcessingCaps

#if(DIRECT3D_VERSION >= 0x0700)
typedef D3DNTHAL_D3DDX6EXTENDEDCAPS *LPD3DNTHAL_D3DDX6EXTENDEDCAPS;
#define D3DNTHAL_D3DDX6EXTENDEDCAPSSIZE (sizeof(D3DNTHAL_D3DDX6EXTENDEDCAPS))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 */

typedef ULONG_PTR D3DINTHAL_BUFFERHANDLE, *LPD3DINTHAL_BUFFERHANDLE;

typedef struct _D3DNTHAL_CONTEXTCREATEDATA {
    union
    {
        PDD_DIRECTDRAW_GLOBAL   lpDDGbl;    // in:  obsolete
        PDD_DIRECTDRAW_LOCAL    lpDDLcl;    // in:  Driver struct
    };
    union
    {
        PDD_SURFACE_LOCAL       lpDDS;      // in:  obsolete
        PDD_SURFACE_LOCAL       lpDDSLcl;   // in:  Surface to be used as target
    };
    union
    {
        PDD_SURFACE_LOCAL       lpDDSZ;     // in:  obsolete
        PDD_SURFACE_LOCAL       lpDDSZLcl;  // in:  Surface to be used as Z
    };
    DWORD                       dwPID;      // in:  Current process id
    ULONG_PTR                   dwhContext; // in/out: Context handle
    HRESULT                     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTCREATEDATA;
typedef D3DNTHAL_CONTEXTCREATEDATA *LPD3DNTHAL_CONTEXTCREATEDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYDATA;
typedef D3DNTHAL_CONTEXTDESTROYDATA *LPD3DNTHAL_CONTEXTDESTROYDATA;

typedef struct _D3DNTHAL_CONTEXTDESTROYALLDATA {
    DWORD       dwPID;      // in:  Process id to destroy contexts for
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_CONTEXTDESTROYALLDATA;
typedef D3DNTHAL_CONTEXTDESTROYALLDATA *LPD3DNTHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DNTHAL_SCENECAPTUREDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    DWORD       dwFlag;     // in:  Indicates beginning or end
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_SCENECAPTUREDATA;
typedef D3DNTHAL_SCENECAPTUREDATA *LPD3DNTHAL_SCENECAPTUREDATA;

typedef struct _D3DNTHAL_TEXTURECREATEDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    HANDLE      hDDS;       // in:  Handle to surface object
    ULONG_PTR   dwHandle;   // out: Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURECREATEDATA;
typedef D3DNTHAL_TEXTURECREATEDATA *LPD3DNTHAL_TEXTURECREATEDATA;

typedef struct _D3DNTHAL_TEXTUREDESTROYDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    ULONG_PTR   dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREDESTROYDATA;
typedef D3DNTHAL_TEXTUREDESTROYDATA *LPD3DNTHAL_TEXTUREDESTROYDATA;

typedef struct _D3DNTHAL_TEXTURESWAPDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    ULONG_PTR   dwHandle1;  // in:  Handle to texture 1
    ULONG_PTR   dwHandle2;  // in:  Handle to texture 2
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTURESWAPDATA;
typedef D3DNTHAL_TEXTURESWAPDATA *LPD3DNTHAL_TEXTURESWAPDATA;

typedef struct _D3DNTHAL_TEXTUREGETSURFDATA {
    ULONG_PTR   dwhContext; // in:  Context handle
    HANDLE      hDDS;       // out: Handle to surface object
    ULONG_PTR   dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DNTHAL_TEXTUREGETSURFDATA;
typedef D3DNTHAL_TEXTUREGETSURFDATA *LPD3DNTHAL_TEXTUREGETSURFDATA;

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DNTHAL_SCENE_CAPTURE_START    0x00000000L
#define D3DNTHAL_SCENE_CAPTURE_END  0x00000001L

/* --------------------------------------------------------------
 * Return values from HAL functions.
 */

/*
 * The context passed in was bad.
 */
#define D3DNTHAL_CONTEXT_BAD        0x000000200L

/*
 * No more contexts left.
 */
#define D3DNTHAL_OUTOFCONTEXTS      0x000000201L

/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *  retcode = HalCall(HalCallData* lpData);
 */

typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTCREATECB)  (LPD3DNTHAL_CONTEXTCREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYCB) (LPD3DNTHAL_CONTEXTDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_CONTEXTDESTROYALLCB) (LPD3DNTHAL_CONTEXTDESTROYALLDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_SCENECAPTURECB)   (LPD3DNTHAL_SCENECAPTUREDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURECREATECB)  (LPD3DNTHAL_TEXTURECREATEDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREDESTROYCB) (LPD3DNTHAL_TEXTUREDESTROYDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTURESWAPCB)    (LPD3DNTHAL_TEXTURESWAPDATA);
typedef DWORD   (APIENTRY *LPD3DNTHAL_TEXTUREGETSURFCB) (LPD3DNTHAL_TEXTUREGETSURFDATA);

typedef struct _D3DNTHAL_CALLBACKS {
    DWORD                           dwSize;

    // Device context
    LPD3DNTHAL_CONTEXTCREATECB      ContextCreate;
    LPD3DNTHAL_CONTEXTDESTROYCB     ContextDestroy;
    LPD3DNTHAL_CONTEXTDESTROYALLCB  ContextDestroyAll;

    // Scene Capture
    LPD3DNTHAL_SCENECAPTURECB       SceneCapture;

    // Execution
    LPVOID                          dwReserved10;       // Must be zero (was Execute)
    LPVOID                          dwReserved11;       // Must be zero (was ExecuteClipped)
    LPVOID                          dwReserved22;       // Must be zero (was RenderState)
    LPVOID                          dwReserved23;       // Must be zero (was RenderPrimitive)

    ULONG_PTR                       dwReserved;         // Must be zero

    // Textures
    LPD3DNTHAL_TEXTURECREATECB      TextureCreate;
    LPD3DNTHAL_TEXTUREDESTROYCB     TextureDestroy;
    LPD3DNTHAL_TEXTURESWAPCB        TextureSwap;
    LPD3DNTHAL_TEXTUREGETSURFCB     TextureGetSurf;

    LPVOID                           dwReserved12;      // Must be zero
    LPVOID                           dwReserved13;      // Must be zero
    LPVOID                           dwReserved14;      // Must be zero
    LPVOID                           dwReserved15;      // Must be zero
    LPVOID                           dwReserved16;      // Must be zero
    LPVOID                           dwReserved17;      // Must be zero
    LPVOID                           dwReserved18;      // Must be zero
    LPVOID                           dwReserved19;      // Must be zero
    LPVOID                           dwReserved20;      // Must be zero
    LPVOID                           dwReserved21;      // Must be zero

    // Pipeline state
    LPVOID                           dwReserved24;      // Was GetState;

    ULONG_PTR                        dwReserved0;       // Must be zero
    ULONG_PTR                        dwReserved1;       // Must be zero
    ULONG_PTR                        dwReserved2;       // Must be zero
    ULONG_PTR                        dwReserved3;       // Must be zero
    ULONG_PTR                        dwReserved4;       // Must be zero
    ULONG_PTR                        dwReserved5;       // Must be zero
    ULONG_PTR                        dwReserved6;       // Must be zero
    ULONG_PTR                        dwReserved7;       // Must be zero
    ULONG_PTR                        dwReserved8;       // Must be zero
    ULONG_PTR                        dwReserved9;       // Must be zero

} D3DNTHAL_CALLBACKS;
typedef D3DNTHAL_CALLBACKS *LPD3DNTHAL_CALLBACKS;

#define D3DNTHAL_SIZE_V1 sizeof( D3DNTHAL_CALLBACKS )

typedef struct _D3DNTHAL_SETRENDERTARGETDATA {
    ULONG_PTR           dwhContext;     // in:  Context handle
    PDD_SURFACE_LOCAL   lpDDS;          // in:  new render target
    PDD_SURFACE_LOCAL   lpDDSZ;         // in:  new Z buffer
    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_SETRENDERTARGETDATA;
typedef D3DNTHAL_SETRENDERTARGETDATA *LPD3DNTHAL_SETRENDERTARGETDATA;


typedef DWORD (APIENTRY *LPD3DNTHAL_SETRENDERTARGETCB) (LPD3DNTHAL_SETRENDERTARGETDATA);

typedef struct _D3DNTHAL_CALLBACKS2
{
    DWORD                           dwSize;                // size of struct
    DWORD                           dwFlags;               // flags for callbacks

    LPD3DNTHAL_SETRENDERTARGETCB    SetRenderTarget;
    LPVOID                          dwReserved1;           // was Clear
    LPVOID                          dwReserved2;           // was DrawOnePrimitive
    LPVOID                          dwReserved3;           // was DrawOneIndexedPrimitive
    LPVOID                          dwReserved4;           // was DrawPrimitives
} D3DNTHAL_CALLBACKS2;
typedef D3DNTHAL_CALLBACKS2 *LPD3DNTHAL_CALLBACKS2;

#define D3DNTHAL2_CB32_SETRENDERTARGET    0x00000001L


typedef struct _D3DNTHAL_CLEAR2DATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for
                                        //      Z-buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DNTHAL_CLEAR2DATA;
typedef D3DNTHAL_CLEAR2DATA FAR *LPD3DNTHAL_CLEAR2DATA;

typedef struct _D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle
    DWORD               dwFlags;        // in:  Flags, currently set to 0
    ULONG_PTR           dwReserved;     //
    DWORD               dwNumPasses;    // out: Number of passes the hardware
                                        //      can perform the operation in
    HRESULT             ddrval;         // out: return value
} D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA FAR *LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA;

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------

//
// Command structure for vertex buffer rendering
//

typedef struct _D3DNTHAL_DP2COMMAND
{
    BYTE        bCommand;           // vertex command
    BYTE        bReserved;
    union
    {
        WORD    wPrimitiveCount;    // primitive count for unconnected primitives
        WORD    wStateCount;        // count of render states to follow
    };
} D3DNTHAL_DP2COMMAND, *LPDNT3DHAL_DP2COMMAND;

//
// DrawPrimitives2 commands:
//

typedef enum _D3DNTHAL_DP2OPERATION
{
    D3DNTDP2OP_POINTS               = 1,
    D3DNTDP2OP_INDEXEDLINELIST      = 2,
    D3DNTDP2OP_INDEXEDTRIANGLELIST  = 3,
    D3DNTDP2OP_RESERVED0            = 4,
    D3DNTDP2OP_RENDERSTATE          = 8,
    D3DNTDP2OP_LINELIST             = 15,
    D3DNTDP2OP_LINESTRIP            = 16,
    D3DNTDP2OP_INDEXEDLINESTRIP     = 17,
    D3DNTDP2OP_TRIANGLELIST         = 18,
    D3DNTDP2OP_TRIANGLESTRIP        = 19,
    D3DNTDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DNTDP2OP_TRIANGLEFAN          = 21,
    D3DNTDP2OP_INDEXEDTRIANGLEFAN   = 22,
    D3DNTDP2OP_TRIANGLEFAN_IMM      = 23,
    D3DNTDP2OP_LINELIST_IMM         = 24,
    D3DNTDP2OP_TEXTURESTAGESTATE    = 25,
    D3DNTDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DNTDP2OP_INDEXEDLINELIST2     = 27,
    D3DNTDP2OP_VIEWPORTINFO         = 28,
    D3DNTDP2OP_WINFO                = 29,
    D3DNTDP2OP_SETPALETTE           = 30,
    D3DNTDP2OP_UPDATEPALETTE        = 31,
#if(DIRECT3D_VERSION >= 0x0700)
    //new for DX7
    D3DNTDP2OP_ZRANGE               = 32,
    D3DNTDP2OP_SETMATERIAL          = 33,
    D3DNTDP2OP_SETLIGHT             = 34,
    D3DNTDP2OP_CREATELIGHT          = 35,
    D3DNTDP2OP_SETTRANSFORM         = 36,
    D3DNTDP2OP_EXT                  = 37,
    D3DNTDP2OP_TEXBLT               = 38,
    D3DNTDP2OP_STATESET             = 39,
    D3DNTDP2OP_SETPRIORITY          = 40,
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DNTDP2OP_SETRENDERTARGET      = 41,
    D3DNTDP2OP_CLEAR                = 42,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DNTDP2OP_SETTEXLOD            = 43,
    D3DNTDP2OP_SETCLIPPLANE         = 44,
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
    D3DNTDP2OP_CREATEVERTEXSHADER   = 45,
    D3DNTDP2OP_DELETEVERTEXSHADER   = 46,
    D3DNTDP2OP_SETVERTEXSHADER      = 47,
    D3DNTDP2OP_SETVERTEXSHADERCONST = 48,
    D3DNTDP2OP_SETSTREAMSOURCE      = 49,
    D3DNTDP2OP_SETSTREAMSOURCEUM    = 50,
    D3DNTDP2OP_SETINDICES           = 51,
    D3DNTDP2OP_DRAWPRIMITIVE        = 52,
    D3DNTDP2OP_DRAWINDEXEDPRIMITIVE = 53,
    D3DNTDP2OP_CREATEPIXELSHADER    = 54,
    D3DNTDP2OP_DELETEPIXELSHADER    = 55,
    D3DNTDP2OP_SETPIXELSHADER       = 56,
    D3DNTDP2OP_SETPIXELSHADERCONST  = 57,
    D3DNTDP2OP_CLIPPEDTRIANGLEFAN   = 58,
    D3DNTDP2OP_DRAWPRIMITIVE2       = 59,
    D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2= 60,
    D3DNTDP2OP_DRAWRECTPATCH        = 61,
    D3DNTDP2OP_DRAWTRIPATCH         = 62,
    D3DNTDP2OP_VOLUMEBLT            = 63,
    D3DNTDP2OP_BUFFERBLT            = 64,
    D3DNTDP2OP_MULTIPLYTRANSFORM    = 65,
    D3DNTDP2OP_ADDDIRTYRECT         = 66,
    D3DNTDP2OP_ADDDIRTYBOX          = 67,
#endif /* DIRECT3D_VERSION >= 0x0800 */
} D3DNTHAL_DP2OPERATION;

//
// DrawPrimitives2 point primitives
//

typedef struct _D3DNTHAL_DP2POINTS
{
    WORD wCount;
    WORD wVStart;
} D3DNTHAL_DP2POINTS;

//
// DrawPrimitives2 line primitives
//

typedef struct _D3DNTHAL_DP2STARTVERTEX {
    WORD wVStart;
} D3DNTHAL_DP2STARTVERTEX, *LPD3DNTHAL_DP2STARTVERTEX;

typedef struct _D3DNTHAL_DP2LINELIST
{
    WORD wVStart;
} D3DNTHAL_DP2LINELIST;

typedef struct _D3DNTHAL_DP2INDEXEDLINELIST
{
    WORD wV1;
    WORD wV2;
} D3DNTHAL_DP2INDEXEDLINELIST;

typedef struct _D3DNTHAL_DP2LINESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2LINESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDLINESTRIP
{
    WORD wV[2];
} D3DNTHAL_DP2INDEXEDLINESTRIP;

//
// DrawPrimitives2 triangle primitives
//

typedef struct _D3DNTHAL_DP2TRIANGLELIST
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
    WORD wFlags;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLELIST2 {
    WORD wV1;
    WORD wV2;
    WORD wV3;
} D3DNTHAL_DP2INDEXEDTRIANGLELIST2, *LPD3DNTHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DNTHAL_DP2TRIANGLESTRIP
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLESTRIP
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN
{
    WORD wVStart;
} D3DNTHAL_DP2TRIANGLEFAN;

typedef struct _D3DNTHAL_DP2INDEXEDTRIANGLEFAN
{
    WORD wV[3];
} D3DNTHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DNTHAL_DP2TRIANGLEFAN_IMM {
    DWORD dwEdgeFlags;
} D3DNTHAL_DP2TRIANGLEFAN_IMM, *LPD3DNTHAL_DP2TRIANGLEFAN_IMM;

//
// DrawPrimitives2 Renderstate changes
//

typedef struct _D3DNTHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE  RenderState;
    union
    {
        D3DVALUE        fState;
        DWORD           dwState;
    };
} D3DNTHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2RENDERSTATE  * LPD3DNTHAL_DP2RENDERSTATE;

typedef struct _D3DNTHAL_DP2TEXTURESTAGESTATE
{
    WORD  wStage;
    WORD  TSState;
    DWORD dwValue;
} D3DNTHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE  *LPD3DNTHAL_DP2TEXTURESTAGESTATE;

typedef struct _D3DNTHAL_DP2VIEWPORTINFO {
    DWORD dwX;
    DWORD dwY;
    DWORD dwWidth;
    DWORD dwHeight;
} D3DNTHAL_DP2VIEWPORTINFO;
typedef D3DNTHAL_DP2VIEWPORTINFO  *LPD3DNTHAL_DP2VIEWPORTINFO;

typedef struct _D3DNTHAL_DP2WINFO {
    D3DVALUE        dvWNear;
    D3DVALUE        dvWFar;
} D3DNTHAL_DP2WINFO;
typedef D3DNTHAL_DP2WINFO  *LPD3DNTHAL_DP2WINFO;

typedef struct _D3DNTHAL_DP2SETPALETTE
{
    DWORD dwPaletteHandle;
    DWORD dwPaletteFlags;
    DWORD dwSurfaceHandle;
} D3DNTHAL_DP2SETPALETTE;
typedef D3DNTHAL_DP2SETPALETTE  *LPD3DNTHAL_DP2SETPALETTE;

typedef struct _D3DNTHAL_DP2UPDATEPALETTE
{
    DWORD dwPaletteHandle;
    WORD  wStartIndex;
    WORD  wNumEntries;
} D3DNTHAL_DP2UPDATEPALETTE;
typedef D3DNTHAL_DP2UPDATEPALETTE  *LPD3DNTHAL_DP2UPDATEPALETTE;

typedef struct _D3DNTHAL_DP2SETRENDERTARGET
{
    DWORD hRenderTarget;
    DWORD hZBuffer;
} D3DNTHAL_DP2SETRENDERTARGET;
typedef D3DNTHAL_DP2SETRENDERTARGET  *LPD3DNTHAL_DP2SETRENDERTARGET;

#if(DIRECT3D_VERSION >= 0x0700)
// Values for dwOperations in the D3DHAL_DP2STATESET
#define D3DHAL_STATESETBEGIN     0
#define D3DHAL_STATESETEND       1
#define D3DHAL_STATESETDELETE    2
#define D3DHAL_STATESETEXECUTE   3
#define D3DHAL_STATESETCAPTURE   4

typedef struct _D3DNTHAL_DP2STATESET
{
    DWORD               dwOperation;
    DWORD               dwParam;        // State set handle passed with D3DHAL_STATESETBEGIN,
                                        // D3DHAL_STATESETEXECUTE, D3DHAL_STATESETDELETE
                                        // D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   sbType;         // Type use with D3DHAL_STATESETBEGIN/END
} D3DNTHAL_DP2STATESET;
typedef D3DNTHAL_DP2STATESET  *LPD3DNTHAL_DP2STATESET;
//
// T&L Hal specific stuff
//
typedef struct _D3DNTHAL_DP2ZRANGE
{
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;
} D3DNTHAL_DP2ZRANGE;
typedef D3DNTHAL_DP2ZRANGE  *LPD3DNTHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DNTHAL_DP2SETMATERIAL, *LPD3DNTHAL_DP2SETMATERIAL;

typedef struct _D3DNTHAL_DP2SETLIGHT
{
    DWORD       dwIndex;
    union {
        DWORD   lightData;
        DWORD   dwDataType;
    };
} D3DNTHAL_DP2SETLIGHT;
typedef D3DNTHAL_DP2SETLIGHT  *LPD3DNTHAL_DP2SETLIGHT;

typedef struct _D3DNTHAL_DP2SETCLIPPLANE
{
    DWORD       dwIndex;
    D3DVALUE    plane[4];
} D3DNTHAL_DP2SETCLIPPLANE;
typedef D3DNTHAL_DP2SETCLIPPLANE  *LPD3DNTHAL_DP2SETCLIPPLANE;

typedef struct _D3DNTHAL_DP2CREATELIGHT
{
    DWORD dwIndex;
} D3DNTHAL_DP2CREATELIGHT;
typedef D3DNTHAL_DP2CREATELIGHT  *LPD3DNTHAL_DP2CREATELIGHT;

typedef struct _D3DNTHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE   xfrmType;
    D3DMATRIX               matrix;
} D3DNTHAL_DP2SETTRANSFORM;
typedef D3DNTHAL_DP2SETTRANSFORM  *LPD3DNTHAL_DP2SETTRANSFORM;

typedef struct _D3DNTHAL_DP2EXT
{
    DWORD dwExtToken;
    DWORD dwSize;
} D3DNTHAL_DP2EXT;
typedef D3DNTHAL_DP2EXT  *LPD3DNTHAL_DP2EXT;

typedef struct _D3DNTHAL_DP2TEXBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    POINT   pDest;
    RECTL   rSrc;       // src rect
    DWORD   dwFlags;    // blt flags
} D3DNTHAL_DP2TEXBLT;
typedef D3DNTHAL_DP2TEXBLT  *LPD3DNTHAL_DP2TEXBLT;

typedef struct _D3DNTHAL_DP2SETPRIORITY
{
    DWORD dwDDDestSurface;// dest surface
    DWORD dwPriority;
} D3DNTHAL_DP2SETPRIORITY;
typedef D3DNTHAL_DP2SETPRIORITY  *LPD3DNTHAL_DP2SETPRIORITY;

typedef struct _D3DNTHAL_DP2CLEAR
{
  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear
    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer
    RECT                Rects[1];       // in:  Rectangles to clear
} D3DNTHAL_DP2CLEAR;
typedef D3DNTHAL_DP2CLEAR  *LPD3DNTHAL_DP2CLEAR;

typedef struct _D3DNTHAL_DP2SETTEXLOD
{
    DWORD dwDDSurface;
    DWORD dwLOD;
} D3DNTHAL_DP2SETTEXLOD;
typedef D3DNTHAL_DP2SETTEXLOD  *LPD3DNTHAL_DP2SETTEXLOD;

#endif /* DIRECT3D_VERSION >= 0x0700 */


typedef struct _D3DNTHAL_DRAWPRIMITIVES2DATA
{
    ULONG_PTR               dwhContext;             // in: Context handle
    DWORD                   dwFlags;                // in: flags (look below)
    DWORD                   dwVertexType;           // in: vertex type
    PDD_SURFACE_LOCAL       lpDDCommands;           // in: vertex buffer command data
    DWORD                   dwCommandOffset;        // in: offset to start of vb commands
    DWORD                   dwCommandLength;        // in: number of bytes of command data
    union
    {
        PDD_SURFACE_LOCAL   lpDDVertex;             // in: surface containing vertex data
        LPVOID              lpVertices;             // in: User mode pointer to vertices
    };
    DWORD                   dwVertexOffset;         // in: offset to start of vertex data
    DWORD                   dwVertexLength;         // in: number of vertices of vertex data
    DWORD                   dwReqVertexBufSize;     // in: number of bytes required for
                                                    //     the next vertex buffer
    DWORD                   dwReqCommandBufSize;    // in: number if bytes required for
                                                    //     the next commnand buffer
    LPDWORD                 lpdwRStates;            // in: Pointer to the array where render states are updated
    union
    {
        DWORD               dwVertexSize;           // in: Size of each vertex in bytes
        HRESULT             ddrval;                 // out: return value
    };
    DWORD                   dwErrorOffset;          // out: offset in LPDDVBCOMMAND to
                                                    //      first failed D3DNTHAL_VBCOMMAND
} D3DNTHAL_DRAWPRIMITIVES2DATA;
typedef D3DNTHAL_DRAWPRIMITIVES2DATA  FAR *LPD3DNTHAL_DRAWPRIMITIVES2DATA;

// Indicates that the lpVertices field in the DrawPrimitives2 data is
// valid, i.e. user allocated memory.
#define D3DNTHALDP2_USERMEMVERTICES   0x00000001L
// Indicates that the command buffer and vertex buffer are a system memory execute buffer
// resulting from the use of the Execute buffer API.
#define D3DNTHALDP2_EXECUTEBUFFER     0x00000002L

// The swap flags indicate if it is OK for the driver to swap the submitted buffers with new
// buffers and asyncronously work on the submitted buffers.
#define D3DNTHALDP2_SWAPVERTEXBUFFER  0x00000004L
#define D3DNTHALDP2_SWAPCOMMANDBUFFER 0x00000008L
// The requested flags are present if the new buffers which the driver can allocate need to be
// of atleast a given size. If any of these flags are set, the corresponding dwReq* field in
// D3DNTHAL_DRAWPRIMITIVES2DATA will also be set with the requested size in bytes.
#define D3DNTHALDP2_REQVERTEXBUFSIZE  0x00000010L
#define D3DNTHALDP2_REQCOMMANDBUFSIZE 0x00000020L
// These flags are set by the driver upon return from DrawPrimitives2 indicating if the new
// buffers are not in system memory.
#define D3DNTHALDP2_VIDMEMVERTEXBUF   0x00000040L
#define D3DNTHALDP2_VIDMEMCOMMANDBUF  0x00000080L


// Return values for the driver callback used in DP2 implementations
// Used by the driver to ask runtime to parse the execute buffer
#define D3DNTERR_COMMAND_UNPARSED         MAKE_DDHRESULT(3000)


typedef DWORD (APIENTRY *LPD3DNTHAL_CLEAR2CB) (LPD3DNTHAL_CLEAR2DATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB) (LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (APIENTRY *LPD3DNTHAL_DRAWPRIMITIVES2CB) (LPD3DNTHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DNTHAL_CALLBACKS3
{
    DWORD                                   dwSize;                 // Size of struct
    DWORD                                   dwFlags;                // Flags for callbacks

    LPD3DNTHAL_CLEAR2CB                     Clear2;
    LPVOID                                  lpvReserved;
    LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB  ValidateTextureStageState;
    LPD3DNTHAL_DRAWPRIMITIVES2CB            DrawPrimitives2;
} D3DNTHAL_CALLBACKS3;
typedef D3DNTHAL_CALLBACKS3 *LPD3DNTHAL_CALLBACKS3;

#define D3DNTHAL3_CB32_CLEAR2                       0x00000001L
#define D3DNTHAL3_CB32_RESERVED                     0x00000002L
#define D3DNTHAL3_CB32_VALIDATETEXTURESTAGESTATE    0x00000004L
#define D3DNTHAL3_CB32_DRAWPRIMITIVES2              0x00000008L

// typedef for the Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
typedef HRESULT (CALLBACK *PFND3DNTPARSEUNKNOWNCOMMAND) (LPVOID lpvCommands,
                                                         LPVOID *lplpvReturnedCommand);

/* --------------------------------------------------------------
 * Texture stage renderstate mapping definitions.
 *
 * 256 renderstate slots [256, 511] are reserved for texture processing
 * stage controls, which provides for 8 texture processing stages each
 * with 32 DWORD controls.
 *
 * The renderstates within each stage are indexed by the
 * D3DTEXTURESTAGESTATETYPE enumerants by adding the appropriate
 * enumerant to the base for a given texture stage.
 *
 * Note, "state overrides" bias the renderstate by 256, so the two
 * ranges overlap.  Overrides are enabled for exebufs only, so all
 * this means is that Texture3 cannot be used with exebufs.
 */

/*
 * Base of all texture stage state values in renderstate array.
 */
#define D3DNTHAL_TSS_RENDERSTATEBASE 256UL

/*
 * Maximum number of stages allowed.
 */
#define D3DNTHAL_TSS_MAXSTAGES 8

/*
 * Number of state DWORDS per stage.
 */
#define D3DNTHAL_TSS_STATESPERSTAGE 64

/*
 * Texture handle's offset into the 32-DWORD cascade state vector
 */
#ifndef D3DTSS_TEXTUREMAP
#define D3DTSS_TEXTUREMAP 0
#endif

#define D3DRENDERSTATE_EVICTMANAGEDTEXTURES 61  // DDI render state only to Evict textures
#define D3DRENDERSTATE_SCENECAPTURE         62  // DDI only to replace SceneCapture


#if(DIRECT3D_VERSION >= 0x0800 )

// New values for dwOperations in the D3DHAL_DP2STATESET
#define D3DNTHAL_STATESETCREATE    5

// This bit is the same as D3DCLEAR_RESERVED0 in d3d8types.h
// When set it means that driver has to cull rects against current viewport.
// The bit is set only for pure devices
//
#define D3DNTCLEAR_COMPUTERECTS   0x00000008l  


typedef struct _D3DNTHAL_DP2MULTIPLYTRANSFORM
{
    D3DTRANSFORMSTATETYPE   xfrmType;
    D3DMATRIX               matrix;
} D3DNTHAL_DP2MULTIPLYTRANSFORM;
typedef D3DNTHAL_DP2MULTIPLYTRANSFORM  *LPD3DNTHAL_DP2MULTIPLYTRANSFORM;


// Used by SetVertexShader and DeleteVertexShader
typedef struct _D3DNTHAL_DP2VERTEXSHADER
{
    // Vertex shader handle.
    // The handle could be 0, meaning that the current vertex shader is invalid
    // (not set). When driver recieves handle 0, it should invalidate all
    // streams pointer
    DWORD dwHandle;
} D3DNTHAL_DP2VERTEXSHADER;
typedef D3DNTHAL_DP2VERTEXSHADER  *LPD3DNTHAL_DP2VERTEXSHADER;

typedef struct _D3DNTHAL_DP2CREATEVERTEXSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwDeclSize;   // Shader declaration size in bytes
    DWORD dwCodeSize;   // Shader code size in bytes
    // Declaration follows
    // Shader code follows
} D3DNTHAL_DP2CREATEVERTEXSHADER;
typedef D3DNTHAL_DP2CREATEVERTEXSHADER  *LPD3DNTHAL_DP2CREATEVERTEXSHADER;

typedef struct _D3DNTHAL_DP2SETVERTEXSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DNTHAL_DP2SETVERTEXSHADERCONST;
typedef D3DNTHAL_DP2SETVERTEXSHADERCONST  *LPD3DNTHAL_DP2SETVERTEXSHADERCONST;

typedef struct _D3DNTHAL_DP2SETSTREAMSOURCE
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwVBHandle;   // Vertex buffer handle
    DWORD dwStride;     // Vertex size in bytes
} D3DNTHAL_DP2SETSTREAMSOURCE;
typedef D3DNTHAL_DP2SETSTREAMSOURCE  *LPD3DNTHAL_DP2SETSTREAMSOURCE;

typedef struct _D3DNTHAL_DP2SETSTREAMSOURCEUM
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwStride;     // Vertex size in bytes
} D3DNTHAL_DP2SETSTREAMSOURCEUM;
typedef D3DNTHAL_DP2SETSTREAMSOURCEUM  *LPD3DNTHAL_DP2SETSTREAMSOURCEUM;

typedef struct _D3DNTHAL_DP2SETINDICES
{
    DWORD dwVBHandle;           // Index buffer handle
    DWORD dwStride;             // Index size in bytes (2 or 4)
} D3DNTHAL_DP2SETINDICES;
typedef D3DNTHAL_DP2SETINDICES  *LPD3DNTHAL_DP2SETINDICES;

typedef struct _D3DNTHAL_DP2DRAWPRIMITIVE
{
    D3DPRIMITIVETYPE    primType;
    DWORD               VStart;
    DWORD               PrimitiveCount;
} D3DNTHAL_DP2DRAWPRIMITIVE;
typedef D3DNTHAL_DP2DRAWPRIMITIVE  *LPD3DNTHAL_DP2DRAWPRIMITIVE;

typedef struct _D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE
{
    D3DPRIMITIVETYPE    primType;
    INT                 BaseVertexIndex;    // Vertex which corresponds to index 0
    DWORD               MinIndex;           // Min vertex index in the vertex buffer
    DWORD               NumVertices;        // Number of vertices starting from MinIndex
    DWORD               StartIndex;         // Start index in the index buffer
    DWORD               PrimitiveCount;
} D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE  *LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE;

typedef struct _D3DNTHAL_CLIPPEDTRIANGLEFAN
{
    DWORD FirstVertexOffset;                // Offset in bytes in the current stream 0
    DWORD dwEdgeFlags;
    DWORD PrimitiveCount;
} D3DNTHAL_CLIPPEDTRIANGLEFAN;
typedef D3DNTHAL_CLIPPEDTRIANGLEFAN  *LPD3DNTHAL_CLIPPEDTRIANGLEFAN;

typedef struct _D3DNTHAL_DP2DRAWPRIMITIVE2
{
    D3DPRIMITIVETYPE    primType;
    DWORD               FirstVertexOffset;  // Offset in bytes in the stream 0
    DWORD               PrimitiveCount;
} D3DNTHAL_DP2DRAWPRIMITIVE2;
typedef D3DNTHAL_DP2DRAWPRIMITIVE2  *LPD3DNTHAL_DP2DRAWPRIMITIVE2;

typedef struct _D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2
{
    D3DPRIMITIVETYPE    primType;
    INT                 BaseVertexOffset;   // Stream 0 offset of the vertex which
                                            // corresponds to index 0. This offset could be
                                            // negative, but when an index is added to the
                                            // offset the result is positive
    DWORD               MinIndex;           // Min vertex index in the vertex buffer
    DWORD               NumVertices;        // Number of vertices starting from MinIndex
    DWORD               StartIndexOffset;   // Offset of the start index in the index buffer
    DWORD               PrimitiveCount;     // Number of triangles (points, lines)
} D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef D3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2  *LPD3DNTHAL_DP2DRAWINDEXEDPRIMITIVE2;

// Used by SetPixelShader and DeletePixelShader
typedef struct _D3DNTHAL_DP2PIXELSHADER
{
    // Pixel shader handle.
    // The handle could be 0, meaning that the current pixel shader is invalid
    // (not set).
    DWORD dwHandle;
} D3DNTHAL_DP2PIXELSHADER;
typedef D3DNTHAL_DP2PIXELSHADER  *LPD3DNTHAL_DP2PIXELSHADER;

typedef struct _D3DNTHAL_DP2CREATEPIXELSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwCodeSize;   // Shader code size in bytes
    // Shader code follows
} D3DNTHAL_DP2CREATEPIXELSHADER;
typedef D3DNTHAL_DP2CREATEPIXELSHADER  *LPD3DNTHAL_DP2CREATEPIXELSHADER;

typedef struct _D3DNTHAL_DP2SETPIXELSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DNTHAL_DP2SETPIXELSHADERCONST;
typedef D3DNTHAL_DP2SETPIXELSHADERCONST  *LPD3DNTHAL_DP2SETPIXELSHADERCONST;

// Flags that can be supplied to DRAWRECTPATCH and DRAWTRIPATCH
#define _NT_RTPATCHFLAG_HASSEGS  0x00000001L
#define _NT_RTPATCHFLAG_HASINFO  0x00000002L

typedef struct _D3DNTHAL_DP2DRAWRECTPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[4] NumSegments and/or D3DRECTPATCH_INFO
} D3DNTHAL_DP2DRAWRECTPATCH;
typedef D3DNTHAL_DP2DRAWRECTPATCH  *LPD3DNTHAL_DP2DRAWRECTPATCH;

typedef struct _D3DNTHAL_DP2DRAWTRIPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[3] NumSegments and/or D3DTRIPATCH_INFO
} D3DNTHAL_DP2DRAWTRIPATCH;
typedef D3DNTHAL_DP2DRAWTRIPATCH  *LPD3DNTHAL_DP2DRAWTRIPATCH;

typedef struct _D3DNTHAL_DP2VOLUMEBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    DWORD   dwDestX;        // dest X (width)
    DWORD   dwDestY;        // dest Y (height)
    DWORD   dwDestZ;        // dest Z (depth)
    D3DBOX  srcBox;         // src box
    DWORD   dwFlags;        // blt flags
} D3DNTHAL_DP2VOLUMEBLT;
typedef D3DNTHAL_DP2VOLUMEBLT  *LPD3DNTHAL_DP2VOLUMEBLT;

typedef struct _D3DNTHAL_DP2BUFFERBLT
{
    DWORD     dwDDDestSurface; // dest surface
    DWORD     dwDDSrcSurface;  // src surface
    DWORD     dwOffset;        // Offset in the dest surface (in BYTES)
    D3DRANGE  rSrc;            // src range
    DWORD     dwFlags;         // blt flags
} D3DNTHAL_DP2BUFFERBLT;
typedef D3DNTHAL_DP2BUFFERBLT  *LPD3DNTHAL_DP2BUFFERBLT;

typedef struct _D3DNTHAL_DP2ADDDIRTYRECT
{
    DWORD     dwSurface;      // Driver managed surface
    RECTL     rDirtyArea;     // Area marked dirty
} D3DNTHAL_DP2ADDDIRTYRECT;
typedef D3DNTHAL_DP2ADDDIRTYRECT  *LPD3DNTHAL_DP2ADDDIRTYRECT;

typedef struct _D3DNTHAL_DP2ADDDIRTYBOX
{
    DWORD     dwSurface;      // Driver managed volume
    D3DBOX    DirtyBox;       // Box marked dirty
} D3DNTHAL_DP2ADDDIRTYBOX;
typedef D3DNTHAL_DP2ADDDIRTYBOX  *LPD3DNTHAL_DP2ADDDIRTYBOX;


// Macros to access vertex shader binary code

#define _NT_D3DSI_GETREGTYPE(token) (token & D3DSP_REGTYPE_MASK)
#define _NT_D3DSI_GETREGNUM(token)  (token & D3DSP_REGNUM_MASK)
#define _NT_D3DSI_GETOPCODE(command) (command & D3DSI_OPCODE_MASK)
#define _NT_D3DSI_GETWRITEMASK(token) (token & D3DSP_WRITEMASK_ALL)
#define _NT_D3DVS_GETSWIZZLECOMP(source, component)  (source >> ((component << 1) + 16) & 0x3)
#define _NT_D3DVS_GETSWIZZLE(token)  (token & D3DVS_SWIZZLE_MASK)
#define _NT_D3DVS_GETSRCMODIFIER(token) (token & D3DSP_SRCMOD_MASK)
#define _NT_D3DVS_GETADDRESSMODE(token) (token & D3DVS_ADDRESSMODE_MASK)

#define _NT_D3DRS_DELETERTPATCH       169     // DDI only to delete high order patch

//-----------------------------------------------------------------------------
//
// DirectX 8.0's new driver info querying mechanism.
//
// How to handle the new driver info query mechanism.
//
// DirectX 8.0 utilizes an extension to GetDriverInfo() to query for
// additional information from the driver. Currently this mechanism is only
// used for querying for DX8 style D3D caps but it may be used for other
// information over time.
//
// This extension to GetDriverInfo takes the form of a GetDriverInfo call
// with the GUID GUID_GetDriverInfo2. When a GetDriverInfo call with this
// GUID is received by the driver the driver must check the data passed
// in the lpvData field of the DD_GETDRIVERINFODATA data structure to see
// what information is being requested.
//
// It is important to note that the GUID GUID_GetDriverInfo2 is, in fact,
// the same as the GUID_DDStereoMode. If you driver doesn't handle
// GUID_DDStereoMode this is not an issue. However, if you wish your driver
// to handle GUID_DDStereoMode as well as GUID_GetDriverInfo2 special action
// must be taken. When a call tp GetDriverInfo with the GUID
// GUID_GetDriverInfo2/GUID_DDStereoMode is made the runtime sets the
// dwHeight field of the DD_STEREOMODE structure to the special value
// D3DGDI2_MAGIC. In this way you can determine when the request is a
// stereo mode call or a GetDriverInfo2 call. The dwHeight field of
// DD_STEREOMODE corresponds to the dwMagic field of the
// DD_GETDRIVERINFO2DATA structure.
//
// The dwExpectedSize field of the DD_GETDRIVERINFODATA structure is not
// used by when a GetDriverInfo2 request is being made and should be
// ignored. The actual expected size of the data is found in the
// dwExpectedSize of the DD_GETDRIVERINFO2DATA structure.
//
// Once the driver has determined that this is a call to
// GetDriverInfo2 it must then determine the type of information being
// requested by the runtime. This type is contained in the dwType field
// of the DD_GETDRIVERINFO2DATA data structure.
//
// Finally, once the driver knows this is a GetDriverInfo2 request of a
// particular type it can copy the requested data into the data buffer.
// It is important to note that the lpvData field of the DD_GETDRIVERINFODATA
// data structure points to data buffer in which to copy your data. lpvData
// also points to the DD_GETDRIVERINFO2DATA structure. This means that the
// data returned by the driver will overwrite the DD_GETDRIVERINFO2DATA
// structure and, hence, the DD_GETDRIVERINFO2DATA structure occupies the
// first few DWORDs of the buffer.
//
// The following code fragment demonstrates how to handle GetDriverInfo2.
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (((DD_GETDRIVERINFO2DATA*)(lpData->lpvData))->dwMagic == D3DGDI2_MAGIC)
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = lpData->lpvData;
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = lpData->lpvData;
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// The data structure which is passed to the driver when GetDriverInfo is
// called with a GUID of GUID_GetDriverInfo2.
//
// NOTE: Although the fields listed below are all read only this data
// structure is actually the first four DWORDs of the data buffer into
// which the driver writes the requested infomation. As such, these fields
// (and the entire data structure) are overwritten by the data returned by
// the driver.
//
typedef struct _DDNT_GETDRIVERINFO2DATA
{
    DWORD       dwReserved;     // Reserved Field.
                                // Driver should not read or write this field.

    DWORD       dwMagic;        // Magic Number. Has the value D3DGDI2_MAGIC if
                                // this is a GetDriverInfo2 call. Otherwise
                                // this structure is, in fact, a DD_STEREOMODE
                                // call.
                                // Driver should only read this field.

    DWORD       dwType;         // Type of information requested. This field
                                // contains one of the DDGDI2_TYPE_ #defines
                                // listed below.
                                // Driver should only read (not write) this
                                // field.

    DWORD       dwExpectedSize; // Expected size of the information requested.
                                // Driver should only read (not write) this
                                // field.

    // The remainder of the data buffer (beyond the first four DWORDs)
    // follows here.
} DDNT_GETDRIVERINFO2DATA;

//
// IMPORTANT NOTE: This GUID has exactly the same value as GUID_DDStereoMode
// and as such you must be very careful when using it. If your driver needs
// to handle both GetDriverInfo2 and DDStereoMode it must have a single
// check for the shared GUID and then distinguish between which use of that
// GUID is being requested.
//
#define _NT_GUID_GetDriverInfo2 (GUID_DDStereoMode)

//
// Magic value used to determine whether a GetDriverInfo call with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode is a GetDriverInfo2 request
// or a query about stereo capabilities. This magic number is stored in
// the dwHeight field of the DD_STEREOMODE data structure.
//
#define _NT_D3DGDI2_MAGIC       (0xFFFFFFFFul)

//
// The types of information which can be requested from the driver via
// GetDriverInfo2.
//

#define _NT_D3DGDI2_TYPE_GETD3DCAPS8          (0x00000001ul)  // Return the D3DCAPS8 data
#define _NT_D3DGDI2_TYPE_GETFORMATCOUNT       (0x00000002ul)  // Return the number of supported formats
#define _NT_D3DGDI2_TYPE_GETFORMAT            (0x00000003ul)  // Return a particular format
#define _NT_D3DGDI2_TYPE_DXVERSION            (0x00000004ul)  // Notify driver of current DX Version
#define _NT_D3DGDI2_TYPE_DEFERRED_AGP_AWARE   (0x00000018ul)  // Runtime is aware of deferred AGP frees, and will send following
#define _NT_D3DGDI2_TYPE_FREE_DEFERRED_AGP    (0x00000019ul)  // Free any deferred-freed AGP allocations for this process
#define _NT_D3DGDI2_TYPE_DEFER_AGP_FREES      (0x00000020ul)  // Start Deferring AGP frees for this process

//
// This data structure is returned by the driver in response to a
// GetDriverInfo2 query with the type D3DGDI2_TYPE_GETFORMATCOUNT. It simply
// gives the number of surface formats supported by the driver. Currently this
// structure consists of a single member giving the number of supported
// surface formats.
//
typedef struct _DDNT_GETFORMATCOUNTDATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                   dwFormatCount; // [out]    Number of supported surface formats
    DWORD                   dwReserved;    // Reserved
} DDNT_GETFORMATCOUNTDATA;

//
// This data structure is used to request a specific surface format from the
// driver. It is guaranteed that the requested format will be greater than or
// equal to zero and less that the format count reported by the driver from
// the preceeding D3DGDI2_TYPE_GETFORMATCOUNT request.
//
typedef struct _DDNT_GETFORMATDATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                   dwFormatIndex;    // [in]     The format to return
    DDPIXELFORMAT           format;           // [out]    The actual format
} DDNT_GETFORMATDATA;

//
// This data structure is used to notify drivers about the DirectX version
// number. This is the value that is denoted as DD_RUNTIME_VERSION in the
// DDK headers.
//
typedef struct _DDNT_DXVERSION
{
    DDNT_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                   dwDXVersion;      // [in]     The Version of DX
    DWORD                   dwReserved;       // Reserved
} DDNT_DXVERSION;

// Informs driver that runtime will send a notification after last outstanding AGP
// lock has been released. 
typedef struct _DDNT_DEFERRED_AGP_AWARE_DATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
} DDNT_DEFERRED_AGP_AWARE_DATA;

// Notification that the last AGP lock has been released. Driver can free all deferred AGP 
// allocations for this process.
typedef struct _DDNT_FREE_DEFERRED_AGP_DATA
{
    DDNT_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
    DWORD dwProcessId;                   // [in] Process ID for whom to free deferred AGP
} DDNT_FREE_DEFERRED_AGP_DATA;


// New Caps that are not API visible that the driver exposes.
#define _NT_D3DDEVCAPS_HWVERTEXBUFFER       0x02000000L /* Device supports Driver Allocated Vertex Buffers*/
#define _NT_D3DDEVCAPS_HWINDEXBUFFER        0x04000000L /* Device supports Driver Allocated Index Buffers*/
#define _NT_D3DDEVCAPS_SUBVOLUMELOCK        0x08000000L /* Device supports locking a part of volume texture */ 
#define _NT_D3DPMISCCAPS_FOGINFVF           0x00002000L // Device supports separate fog value in the FVF

// New FVF flags that are not API visible but accessed by the driver
// Note, that D3DFVF_RESERVED2 includes this flag and should not be used for validation

#define _NT_D3DFVF_FOG                      0x00002000L // There is a separate fog value in the FVF vertex 

//
// This stuff is not API visible but should be DDI visible.
// Should be in Sync with d3d8types.h
//
#define _NT_D3DFMT_D32     (D3DFORMAT)71
#define _NT_D3DFMT_S1D15   (D3DFORMAT)72
#define _NT_D3DFMT_D15S1   (D3DFORMAT)73
#define _NT_D3DFMT_S8D24   (D3DFORMAT)74
#define _NT_D3DFMT_D24S8   (D3DFORMAT)75
#define _NT_D3DFMT_X8D24   (D3DFORMAT)76
#define _NT_D3DFMT_D24X8   (D3DFORMAT)77
#define _NT_D3DFMT_X4S4D24 (D3DFORMAT)78
#define _NT_D3DFMT_D24X4S4 (D3DFORMAT)79

// Vertex Shader 1.1 register limits. D3D device must provide at least
// specified number of registers
//
#define _NT_D3DVS_INPUTREG_MAX_V1_1         16
#define _NT_D3DVS_TEMPREG_MAX_V1_1          12
// This max required number. Device could have more registers. Check caps.
#define _NT_D3DVS_CONSTREG_MAX_V1_1         96
#define _NT_D3DVS_TCRDOUTREG_MAX_V1_1       8
#define _NT_D3DVS_ADDRREG_MAX_V1_1          1
#define _NT_D3DVS_ATTROUTREG_MAX_V1_1       2
#define _NT_D3DVS_MAXINSTRUCTIONCOUNT_V1_1  128

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define _NT_D3DPS_INPUTREG_MAX_DX8         8
#define _NT_D3DPS_TEMPREG_MAX_DX8          8
#define _NT_D3DPS_CONSTREG_MAX_DX8         8
#define _NT_D3DPS_TEXTUREREG_MAX_DX8       8

#endif // (DIRECT3D_VERSION >= 0x0800 )

#endif /* _D3DNTHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\oak\inc\compstui.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation


Module Name:

    compstui.h


Abstract:

    This module contains global header definition for the COMMON DRIVER UI


Author:

    19-Jun-1995 Mon 11:52:01 created  -by-  Daniel Chou (danielc)

    17-Aug-1995 Thu 14:59:28 updated  -by-  Daniel Chou (danielc)
        Updated for the first draft.

    23-Aug-1995 Wed 15:13:27 updated  -by-  Daniel Chou (danielc)
        Updated for second draft

    29-Aug-1995 Tue 11:33:24 updated  -by-  Daniel Chou (danielc)
        Adding ExtChkBox for some TVOT_xxx type

    31-Aug-1995 Thu 04:04:23 updated  -by-  Daniel Chou (danielc)
        Making UNICODE type

    01-Sep-1995 Fri 17:29:18 updated  -by-  Daniel Chou (danielc)
        Change the API interface type, so that it can be dynamically called
        and generate the property pages to be merge with the shell

    05-Sep-1995 Tue 11:52:43 updated  -by-  Daniel Chou (danielc)
        Rename to compspui.h and update the API entry structure

    07-Sep-1995 Thu 14:46:55 updated  -by-  Daniel Chou (danielc)
        rename to compstui.h and update comments

    07-Sep-1995 Thu 16:07:31 updated  -by-  Daniel Chou (danielc)
        Adding UNION type for pSel/Sel, pOldSel/OldSel

    08-Sep-1995 Fri 09:23:38 updated  -by-  Daniel Chou (danielc)
        Remove TypeIdx from OPTITEM and use pOptType, and remove all
        pOptType passed in the CPSUICBPARAM and COMPROPSHEETUI structures

    25-Sep-1995 Mon 19:39:45 updated  -by-  Daniel Chou (danielc)
        add other related stuff.

    26-Sep-1995 Tue 11:02:26 updated  -by-  Daniel Chou (danielc)
        Add error codes for GETLASTERROR

    27-Sep-1995 Wed 16:32:37 updated  -by-  Daniel Chou (danielc)
        Move hWndParent, pTitle, hInst and TitleIconID out from
        COMPROPSHEETUI to COMPROPSHEETUIHEADER.

    28-Sep-1995 Thu 17:06:46 updated  -by-  Daniel Chou (danielc)
        Add hInstCaller to COMPROPSHEETUI and add _COMPSTUI_ and cplusplus
        stuff

    28-Sep-1995 Thu 23:16:34 updated  -by-  Daniel Chou (danielc)
        change tick count for trackbar/scrollbar to multiply factor. and
        add the push button flag which can overwrite the update permission so
        it can let user view the current setting from push button's dialog
        display

    07-Feb-1996 Wed 17:45:31 updated  -by-  Daniel Chou (danielc)
        Change the API CommonPropSheetUI to CommonPropertySheetUI so that it
        not using stack but message base, this way any caller can add/delete
        pages as they want without worry about how many pages been added from
        its children.

    7:15 AM 2/14/2001 updated -by- Lazar Ivanov (LazarI)
        Making compstui fusion aware. Attaching a fusion activation context
        to the compstui handles and adding a new message for setting it called 
        CPSFUNC_SET_FUSION_CONTEXT. when a page is about to be created/inserted and 
        it doesn't specify an activation context in its PROPSHEETPAGE structure it 
        will be created into the parent's page activation context. if the parent's 
        activation context is not set then we look up the next parent and so on until 
        the top level parent is reached or until we find a parent with an activation 
        context properly set. if none of the parents have an activation context set, 
        then we force the default (NULL) activation context prior creating the page.

[Environment:]

    NT Windows - Common Property Sheet UI DLL.


[Notes:]


Revision History:


--*/

#ifndef _COMPSTUI_
#define _COMPSTUI_

#ifdef __cplusplus
extern "C" {
#endif


#if (!defined(RC_INVOKED))


//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif

//
// Predefined ID for the TreeView Option Type
//
//


#define TVOT_2STATES        0
#define TVOT_3STATES        1
#define TVOT_UDARROW        2
#define TVOT_TRACKBAR       3
#define TVOT_SCROLLBAR      4
#define TVOT_LISTBOX        5
#define TVOT_COMBOBOX       6
#define TVOT_EDITBOX        7
#define TVOT_PUSHBUTTON     8
#define TVOT_CHKBOX         9
#define TVOT_LAST           TVOT_CHKBOX
#define TVOT_NONE           (TVOT_LAST + 1)

//
// Predefined ID for the TreeView Option Type
//
//
// TVOT_2STATES:
//      Count       = 2
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//
//      BegCtrlID  = 2 States Group Box ID
//      BegCtrlID+1= 2 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_3STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//
// TVOT_3STATES:
//      Count       = 3
//      pOptParam[0]=pointer to the State 1 OPTPARAM
//      pOptParam[1]=pointer to the State 2 OPTPARAM
//      pOptParam[2]=pointer to the State 3 OPTPARAM
//
//      BegCtrlID  = 3 States Group Box ID
//      BegCtrlID+1= 3 States static Text
//      BegCtrlID+2= state 1 Radio button ID
//      BegCtrlID+3= state 1 icon control ID
//      BegCtrlID+4= state 2 Radio button ID
//      BegCtrlID+5= state 2 icon control ID
//      BegCtrlID+6= state 3 Radio button ID
//      BegCtrlID+7= state 3 icon control ID
//      BegCtrlID+8= Extended Check Box/Push Button control ID
//      BegCtrlID+9= Extended Check Box/Push Button Icon control ID
//
//  * For TVOT_2STATES, TVOT_3STATES, each of OPTPARAM consisted
//
//      Style =Ignored
//      pData =Pointer to the string to describe the state
//      IconID=Icons resource ID, or common UI standard icon ID
//      lParam=Ignored
//
//  * OPTITEM's 'Sel' is the selection index range from 0 to 1
//  * On the non-treeview page, this must be a auto radio button
//
//  ** For TVOT_2STATES, TVOT_3STSATES the 'Sel' field in the OPTITEM has
//     following definitions
//
//      State 1, Sel = 0
//      State 2, Sel = 1
//      State 3, Sel = 2
//
//      for any selection which based on false/true, no/yes, off/ontrue/false,
//      none/select then state 1 (sel=0) must always be the NO, FALSE, OFF or
//      NONE type.
//
//
// TVOT_UDARROW:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = (SHORT)Low range of the up-down control
//                      lParam = (SHORT)High range of the up-down control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//          if pData pointed to no help text then common UI automatically
//          set the (# - #) as help line
//
//      BegCtrlID  = udarrow Group Box ID
//      BegCtrlID+1= udarrow title static title ID
//      BegCtrlID+2= udarrow's editbox ID
//      BegCtrlID+3= udarrow icon control ID
//      BegCtrlID+4= udarrow postfix static text ID
//      BegCtrlID+5= udarrow help static text ID
//      BegCtrlID+6= udarrow arrow ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_TRACKBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the trackbar control
//                      lParam = (SHORT)High range of the trackbar control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//      BegCtrlID  = trackbar Group Box ID
//      BegCtrlID+1= trackbar static title ID
//      BegCtrlID+2= trackbar(horizontal) ID (static FRAME to define size)
//      BegCtrlID+3= trackbar icon control ID
//      BegCtrlID+4= trackbar low range text control ID
//      BegCtrlID+5= trackbar high range text control ID
//      BegCtrlID+6= trackbar postfix ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * the tick frequency is automatically to set to PageSize increment
//      * Style field in the OPTPARAM is ignored
//
//
// TVOT_SCROLLBAR:
//      Count       = 3
//      pOptParam[0]=Pointer to the text for the selection postfix and ICONS
//      pOptParam[1]=Pointer to the <Low Range Text> and
//                      IconID = (SHORT)Low range of the scrollbar control
//                      lParam = (SHORT)High range of the scroll control
//
//                          * Low/High must in range of a 16-bit sign integer
//
//      pOptParam[2]=Pointer to the <High Range Text> and
//                      IconID = 'Sel' multiply factor for display
//                      lParam = Page Size (increment)
//
//          if pData pointed to NULLt then common UI automatically
//          set the Low/High range.
//
//
//      BegCtrlID  = scrollbar(horizontal) group box ID
//      BegCtrlID+1= scrollbar(horizontal) static text ID
//      BegCtrlID+2= scrollbar(horizontal) ID
//      BegCtrlID+3= scrollbar icon control ID
//      BegCtrlID+4= scrollbar low range text control ID
//      BegCtrlID+5= scrollbar high range text control ID
//      BegCtrlID+6= scrollbar postfix control ID
//      BegCtrlID+7= Extended Check Box/Push Button control ID
//      BegCtrlID+8= Extended Check Box/Push Button Icon control ID
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//      * The multiply factor is used to multiply the current select with
//        this factor and display it. typically this is one
//      * Style field in the OPTPARAM is ignored
//
//
//
// TVOT_LISTBOX:
// TVOT_COMBOBOX:
//      Count       = N
//      pOptParam[0]=pointer to the first OPTPARAM (pData=string pointer)
//      pOptParam[1]=pointer to the second OPTPARAM (pData=string pointer)
//          .
//          .
//      pOptParam[N-1]=pointer to the N item string
//
//      BegCtrlID  = Listbox/ComboBox group box ID
//      BegCtrlID+1= Listbox/ComboBox static title ID
//      BegCtrlID+2= Listbox/Combobox ID
//      BegCtrlID+3= Listbox/Combobox icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, the field used as
//
//          Style =Ignored by the common UI
//          pData =Pointer to the name of item
//          IconID=Icon resource ID for the item
//          lParam=ignored by the common UI
//
//      * Only SINGLE selection is supported, to do a multiple selction use
//        multiple OPTITEM and create a header for it
//
//      * an OTLBCBS_SORT style can be specified in the OPTTYPE's LBCBStyle
//        field, and the listbox or combobox will be sorted according to the
//        item's string.
//
//      * OPTITEM's 'Sel' is the selection index between Low/High range
//
//      * for TVOT_LISTBOX, TVOT_COMBOBOX, when it get received the keyboard
//        focus then common UI will call callback function (only if
//        OPTIF_CALLBACK bit set) with reason of CPSUICB_REASON_LBCB_ACTIVE,
//        this give caller a chance to modify following structure flags/pdata
//        which associate with the current OPTITEM.   The caller's callback
//        function can ONLY modify the flags/data specified here.
//
//          OPTTYPE pointed by the pOptType from OPTITEM
//
//              Style: OTS_LBCB_SORT
//                     OTS_LBCB_INCL_ITEM_NONE
//
//          OPTPARAMs pointed by the pOptParam from the OPTTYPE
//
//              Flags: OPTPF_HIDE
//                     OPTPF_DISABLED
//
//              pData: change string name
//
//
//      * The TVOT_COMBOBOX typically only used in the tree-view if there is
//        only one selection available for that item, when there is only one
//        item then dropdown list will not enabled by the common UI
//
//
//
// TVOT_EDITBOX:
//      Count       = 2
//      pOptParam[0]=Pointer to the text of postfix and ICONS
//      pOptParam[1]=Pointer to the help line text above the control and
//                      IconID = Edit buffer sie in character pointed by pSel
//                                 this is including the NULL terminator.
//                      lParam = ignored.
//
//      BegCtrlID  = editBox group Box ID
//      BegCtrlID+1= editBox static title ID
//      BegCtrlID+2= editbox ID
//      BegCtrlID+3= editbox icon control ID
//      BegCtrlID+4= editbox postfix ID
//      BegCtrlID+5= editbox help ID
//      BegCtrlID+6= Extended Check Box/Push Button control ID
//      BegCtrlID+7= Extended Check Box/Push Button Icon control ID
//
//      * Style field is ignored
//
//      * pSel in the OPTITEM is the pointer to the editing string, the pSel
//        must pointed to a buffer eqaul or larger than the count of the buffer
//        (pOptParam[1]->IconID) size
//
//
// TVOT_PUSHBUTTON:
//      Count       = 1
//
//      BegCtrlID  = push button group box ID
//      BegCtrlID+1= push button static text ID (Not used by common UI)
//      BegCtrlID+2= push button ID
//      BegCtrlID+3= push button icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//      PUSHBUTTON_TYPE_xxx specified the action and content of pData in the
//      pOptParam[0] as describe in the following
//
//          PUSHBUTTON_TYPE_DLGPROC
//
//              This push button is designed to bring up caller's dialog box
//
//                  pOptParam[0].pData  = Caller's DLGPROC
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_DLGPROC
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Caller's DIALOG resource template ID
//                                        or handle to the DLGTEMPLATE depends
//                                        on the OPTPF_USE_HDLGTEMPLATE flag
//
//
//              The 'lParam' passed to the DLGPROC's WM_INITDIALOG is the
//              CPSUICBPARAM structure pointer, and the reason field is set
//              to CPSUICB_REASON_DLGPROC.
//
//
//          PUSHBUTTON_TYPE_CALLBACK
//
//              This push button is designed to have caller process the item
//              which cannot accomplished with the dialog box along.
//
//                  pOptParam[0].pData  = CPSUICALLBACK function pointer
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_CALLBACK
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//              Durning the callback the Reason field in CPSUICBPARAM will
//              set to CPSUICB_REASON_PUSHBUTTON.
//
//              ** If pOptParam[0].pData callback function is NULL then common
//                 UI will call the pfnCallBack pointer set in the
//                 COMPROPSHEETUI structure if it is not NULL
//
//              ** The callback function should put the result of the callback
//                 in the pSel/Sel of OPTITEM associate with the push button
//
//          PUSHBUTTON_TYPE_HTCLRADJ
//
//              This push button is designed to bring up halftone color
//              adjustment dialog box.
//
//                  pOptParam[0].pData  = pointer to COLORADJUSTMENT structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTCLRADJ
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam =  Not Used;
//
//
//          PUSHBUTTON_TYPE_HTSETUP
//
//              This push button is designed to bring up device halftone
//              setup dialog box.
//
//                  pOptParam[0].pData  = pointer to DEVHTADJDATA structure
//                  pOptParam[0].Style  = PUSHBUTTON_TYPE_HTSETUP
//                  pOptParam[0].IconID = Icon resource ID
//                  pOptParam[0].lParam = Not Used;
//
//
//      * 'Sel' field in the OPTITEM for the PUSHBUTTON is the last returned
//        LONG result from the called dialog box or funcitons.  The result
//        only valid if OPTIF_CHANGEONCE flag is set.  The common UI will set
//        OPTIF_CHANGEONCE if push button ever pushed.
//
//      * Since common UI donot know the meaning of the return value and
//        content of the called parameter, it is up to the caller to use
//        callback function to determine the returned result.
//
//      * When returned from the push button except push botton type
//        PUSHBUTTON_TYPE_CALLBACK common ui will call the callback function
//        if the OPTIF_CALLBACK flat is set.  The callback reason is set to
//        CPSUICB_REASON_SEL_CHANGED.
//
//      * If the passed in CPSUIF_UPDATE_PERMISSION Flags in the COMPROPSHEETUI
//        is clear then the callback function must ONLY display the dialog box
//        and not changed any OPTITEM data if OTS_PUSH_ENABLE_ALWAYS
//        flag is set in the OPTTYPE
//
//
// TVOT_CHKBOX:
//      Count               = 1
//
//      pOptparam[0].Style  = CHKBOXS_FALSE_TRUE    False/True
//                            CHKBOXS_NO_YES,       No/YES
//                            CHKBOXS_OFF_ON,       Off/ON
//                            CHKBOXS_FALSEPDATA    False/pData
//                            CHKBOXS_NO_PDATA      No/pData
//                            CHKBOXS_OFF_PDATA     Off/pData
//                            CHKBOXS_NONE_PDATA    None/pData
//      pOptParam[0].pData  = Only used if Style is CHKBOXS_NONE_PDATA
//      pOptParam[0].IconID = Icon resource ID
//      pOptParam[0].lParam = Ignored
//
//
//      BegCtrlID  = check box group ID
//      BegCtrlID+1= Check Box static text (not used by common UI)
//      BegCtrlID+2= check box button ID
//      BegCtrlID+3= check box icon control ID
//      BegCtrlID+4= Extended Check Box/Push Button control ID
//      BegCtrlID+5= Extended Check Box/Push Button Icon control ID
//
//
//  * BegCtrlID only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//    which has non-common UI dialog box template (DlgTemplateID in the DLGPAGE
//    is not standard DP_STD_xxx common ui dialog box template).    The common
//    UI used this ID to managed caller's dialog boxes item's selections and
//    initialization.
//
//  * for each item, it has group box ID (BegCtrlID) and static text ctronl ID
//    (BegCtrlID + 1).  The common UI will set the text in one of these two
//    control ID in followng seauence.
//
//      1) If group box control ID's window (BegCtrlID) is exist and the
//         OPTITEM's flag OPTIF_NO_GROUPBOX_NAME is not set then common UI will
//         set the pName from OPTITEM to the group box.
//
//      2) If the group box name is not set and static control ID's window
//         (BegCtrlID + 1) is exist then common UI will set the pName from
//         OPTITEM to the static text control.
//
//  * for TVOT_TRACKBAR and TVOT_SCROLLBAR, if pName in the OPTITEM is set to
//    either group box or static text control then common UI will also append
//    the current selection position of trackbar or scroll bar to the pName.
//
//  * If multiple OPTITEMs using the same POPTPARAM and need different
//    BegCtrlID for each control then then a separate OPTTYPE structure should
//    be generated but POPTPARAM pointed to the same OPTPARAM[]
//
//  * If a BegCtrlID+N is not used then skip that ID in your dialog box
//    template
//
//

#define CHKBOXS_FALSE_TRUE          0
#define CHKBOXS_NO_YES              1
#define CHKBOXS_OFF_ON              2
#define CHKBOXS_FALSE_PDATA         3
#define CHKBOXS_NO_PDATA            4
#define CHKBOXS_OFF_PDATA           5
#define CHKBOXS_NONE_PDATA          6


#define PUSHBUTTON_TYPE_DLGPROC     0
#define PUSHBUTTON_TYPE_CALLBACK    1
#define PUSHBUTTON_TYPE_HTCLRADJ    2
#define PUSHBUTTON_TYPE_HTSETUP     3


#define MAX_RES_STR_CHARS           160

//
// Common Printer UI's LPTSTR
//
// All string pointer in common printer UI structures can be either a real
// memory pointer or a string resource ID.  These are applied to LPTSTR type.
//
// The LPTSTR is defined to identify that the pointer can be a real string
// pointer or a resource ID (either common printer UI provided ID or caller's
// own resource ID).  common UI using following logic to get the final string.
//
//  LPTSTR  pData;
//
//      if ((pData & ~(ULONG_PTR)0xFFFF) != 0) then pData is a NULL terminated
//      string pointer
//
//          ELSE
//
//          (pData & (ULONG_PTR)0xFFFF) = Resource ID
//
//          if (Resource ID is within the common UI string resource ID range)
//          then it load the string from common UI DLL
//
//          ELSE
//
//              it load string from caller's resource
//
//
//  *  You can use MAKEINTRESOURCE(StrResID) to set this field
//
//  * The MAX characters loaded by the common UI from the resource is defined
//    as MAX_RES_STR_CHARS
//
//  * You cannot use LPTSTR as resource ID for the TVOT_EDITBOX style's
//    pSel in the OPTITEM, this pointer must be a real buffer pointer
//
//
//
// ICONs
//
//  Common UI using two types of Icons, One is 32x32 and the other is 16x16
//  plus if any monochrome icon with 32x32 and 16x16 sizes.
//
//  The 16x16 icon when displayed on the screen is using 16x17 pixel space,
//  this is ensure that downware adjacent icon is not crowded together.
//
//  In common UI, if you need to passed a ICON ID, it can either passed a
//  common UI's predefined ID or caller's own ICON resource ID.
//
//
//  * You can use to imagedit or any other Window icon editor to create the
//    icon, each icon file should have one unique icon resource ID which is
//    not overlay with the standard common UI IDI_CPSUI_xxx identifier.  For
//    each icon file, its should have both 32x32 and 16x16 size icon on
//    different display. (ie. monochrome).
//
//    Common UI will try to load the correct size of icon from the icon
//    resource, but it will stretch them if the size is not found.
//
//

//
// Flags for the OPTTYPE
//
//

#define OPTPF_HIDE                  0x01
#define OPTPF_DISABLED              0x02
#define OPTPF_ICONID_AS_HICON       0x04
#define OPTPF_OVERLAY_WARNING_ICON  0x08
#define OPTPF_OVERLAY_STOP_ICON     0x10
#define OPTPF_OVERLAY_NO_ICON       0x20
#define OPTPF_USE_HDLGTEMPLATE      0x40

typedef struct _OPTPARAM {
    WORD        cbSize;         // size of this structure
    BYTE        Flags;          // OPTPF_xxxx flags
    BYTE        Style;          // style use in this structure
    LPTSTR      pData;          // pointer to the data
    ULONG_PTR   IconID;         // iconID;
    LPARAM      lParam;         // parameter used
    ULONG_PTR   dwReserved[2];  // reserved dword, must be 0
    } OPTPARAM, *POPTPARAM;


//
// OPTPARAM
//
//  The OPTPARAM structure is used to describe each slectable item in the
//  common UI such as 'letter', 'legal' in the form slection list box
//
//  cbSize      - size of this structure
//
//  Flags       - defined as OPTPF_xxxx
//
//                  OPTPF_HIDE
//
//                      Specified hide this listed selection item and not
//                      availabe for user to select. This only available to
//                      following TVOT_xxx types
//
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//                      If all the seclection items are OPTPF_HIDE then the
//                      OPTITEM is automatically hided by the common UI, if
//                      TVOT_3STATES has 2 states hide then an error is
//                      returned
//
//
//                  OPTPF_DISABLED
//
//                      Specified this listed selection item is disabled and
//                      not availabe for user to select.   This only available
//                      to following TVOT_xxx types
//
//                          TVOT_2STATES
//                          TVOT_3STATES
//                          TVOT_LISTBOX
//                          TVOT_COMBOBOX
//
//
//                  OPTPF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  OPTPF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  OPTPF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  OPTPF_OVERLAY_NO_ICON
//
//                      If this bit is set then this OPTPARAM item's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  Style       - Style for the OPTPARAM, it depends on the TVOT_xxx type as
//                describe below
//
//                  TVOT_PUSBUTTON
//
//                      it can be one of PUSHBUTTON_TYPE_xxxx.
//
//                  other TVOT_xxxx
//
//                      this fields is not used.
//
//
//  pData       - Is either a pointer to the item name (string) or it is
//                used to describe other data.
//
//                   * If the pData in the OPTPARAM is supposed to be a static
//                     pointer to a string and the string is a common UI
//                     standard resource ID then common UI will check if pData
//                     is equal to IDS_CPSUI_NOTINSTALLED, if true then
//                     common UI will overaly a not installed icon on top of
//                     the OPTPARAM's Icon.   This will not applied to the
//                     TVOT_EDITBOX type since the pData is not a static text
//                     pointer or a string resource ID.
//
//                  ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if OPTPF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  lParam      - Extra data used by the OPTPARAM, it depends on the TVOT_xxx
//                type.
//
//  dwReserved[]- Reserved DWORDs, must be 0
//
//


#define OPTTF_TYPE_DISABLED             0x01
#define OPTTF_NOSPACE_BEFORE_POSTFIX    0x02


#define OTS_LBCB_SORT                   0x0001
#define OTS_LBCB_PROPPAGE_LBUSECB       0x0002
#define OTS_LBCB_PROPPAGE_CBUSELB       0x0004
#define OTS_LBCB_INCL_ITEM_NONE         0x0008
#define OTS_LBCB_NO_ICON16_IN_ITEM      0x0010
#define OTS_PUSH_INCL_SETUP_TITLE       0x0020
#define OTS_PUSH_NO_DOT_DOT_DOT         0x0040
#define OTS_PUSH_ENABLE_ALWAYS          0x0080


typedef struct _OPTTYPE {
    WORD        cbSize;
    BYTE        Type;           // TVOT_xxxx type of OPTIONS
    BYTE        Flags;          // OPTTF_xxx flags
    WORD        Count;          // Count of pOptParam passed
    WORD        BegCtrlID;      // start of item's group window ID
    POPTPARAM   pOptParam;      // pointer to the OPTPARAM
    WORD        Style;          // option type style as OTS_xxxx
    WORD        wReserved[3];   // wReserved, must be 0
    ULONG_PTR   dwReserved[3];  // DWORD reserved field (must be 0)
} OPTTYPE, *POPTTYPE;


//
// OPTTYPE
//
//  The OPTTYPE structure is used to describe a set of selection and its
//  select method,  such as Form/Tray assignment.  It has a pointer to a set
//  of selection item (OPTPARAM)
//
//
//  cbSize      - size of this structure
//
//  Type        - Specified the option type using predefined ID as TVOT_xxxx
//
//  Flags       - currently only one flag is defined
//
//
//                  OPTTF_TYPE_DISABLED
//
//                      The whole OPTTYPE's OPTPARAMs are disabled, and non of
//                      the selection in the OPTTYPE can be selected
//
//
//                  OPTTF_NOSPACE_BEFORE_POSTFIX
//
//                      This bit only valid if the OPTTYPE's pOptParam item
//                      specified a postfix string as describe in the above
//                      section.  If this flag is set then it asked common UI
//                      do not add a space character before the postfix string
//                      when it combine the pName in the OPTITEM and postfix
//                      string.   Typeically this bit is not set for the
//                      postfix string, but sometime it may be required not to
//                      add a space character in front of it, such as '%'
//                      postfix string.
//
//
//  Count       - Count of item pointed by pOptParam.  Some predefined number
//                must be set according to the TVOT_XXX description.
//
//  BegCtrlID   - Only used if the OPTITEM/OPTTYPE is belong to the the DLGPAGE
//                which has non-common UI dialog box template (DlgTemplateID
//                in the DLGPAGE is not standard DP_STD_xxx common ui dialog
//                box template).    The common UI used this ID to managed
//                caller's dialog boxes item's selections and initialization.
//
//                Each OPTITEM has predefined number of window ID which
//                associated with that item, the BegCtrlID specified the start
//                control window ID.  Each control window ID in the OPTITEM
//                must have the control ID sequence as describe in the TVOT_xxx
//                above.
//
//  pOptParam   - Pointer to array of OPTPARAM to describe each selectable item
//
//  Style       - Specified the style of type of control box, certain style
//                only apply to centain type of TVOT_xxxx.
//
//                OTS_LBCB_xxx only applied to TVOT_LISTBOX, TVOT_COMBOBOX
//                OTS_PUSH_xxx only applied to TVOT_PUSHBUTTON
//
//
//                  OTS_LBCB_SORT
//
//                      Specified that the listbox or combobox item is sorted
//                      in ascending order based on the pData string
//
//
//                  OTS_LBCB_PROPAGE_LBUSECB
//
//                      Used when Type is TVOT_LISTBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is comobobox instead of listbox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_PROPAGE_CBUSELB
//
//                      Used when Type is TVOT_COMBOBOX, if it specified and
//                      this OPTTYPE also on the non-treeview user defined
//                      property sheet page dialog then common UI assume
//                      control is listbox instead of combobox on the non-
//                      treeview page
//
//
//                  OTS_LBCB_INCL_ITEM_NONE
//
//                      when this flag is specified, the common ui will
//                      automatically add a 'None' selection to the listbox or
//                      combobox.   The 'Sel' will set to -1 if 'none' is
//                      selection is selected by the user.  It will also
//                      validate the 'Sel' durning the initialization,  any
//                      out of range value will be set to -1 (None).
//
//
//                  OTS_LBCB_NO_ICON16_IN_ITEM
//
//                      By default, each listbox, combox will have a small
//                      icon (16x16) in front of item text. by specified this
//                      bit, the listbox/combobox will not includes icons
//                      in the listbox/combobox.
//
//                      If clear then it specified that in the listbox/combobox
//                      to have 16x16 Icon added to the front of each item
//
//
//                  OTS_PUSH_INCL_SETUP_TITLE
//
//                      If specified for the push button then it automatically
//                      add the 'Setup' to the end of push botton text.
//
//
//                  OTS_PUSH_NO_DOT_DOT_DOT
//
//                      If specified then common UI will not add '...' to the
//                      end of the pName in the OPTITEM and push button name
//
//
//                  OTS_PUSH_ENABLE_ALWAYS
//
//                      This flag specified that even update permissio is not
//                      allowed, it still let user push the push button, if
//                      this flag is set then callback function or dialog box
//                      proc must disable all the control which let user
//                      modified the content, but just let user view the
//                      current setting.
//
//
//  wReserved[] - Reserved fields, must be 0
//
//  dwReserved[]- Reserved fields, must be 0
//
//


//
// Following are flags for the EXTPUSH
//


#define EPF_PUSH_TYPE_DLGPROC       0x0001
#define EPF_INCL_SETUP_TITLE        0x0002
#define EPF_NO_DOT_DOT_DOT          0x0004
#define EPF_ICONID_AS_HICON         0x0008
#define EPF_OVERLAY_WARNING_ICON    0x0010
#define EPF_OVERLAY_STOP_ICON       0x0020
#define EPF_OVERLAY_NO_ICON         0x0040
#define EPF_USE_HDLGTEMPLATE        0x0080


typedef struct _EXTPUSH {
    WORD                cbSize;         // size of the structure
    WORD                Flags;          // EPCBF_xxx flags
    LPTSTR              pTitle;         // extended push botton title
    union {
        DLGPROC         DlgProc;        // pointer to the dialog box proc
        FARPROC         pfnCallBack;    // callback function pointer
        } DUMMYUNIONNAME;
    ULONG_PTR           IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;          // dialog box template ID
        HANDLE  hDlgTemplate;           // handle to the dialog template
        } DUMMYUNIONNAME;
    ULONG_PTR   dwReserved[3];          // reserved field, must be 0
    } EXTPUSH, *PEXTPUSH;

//
// EXTPUSH structure is used to describe the extened push button available
// on OPTITEM/OPTITEM, each OPTTYPE can optional have either one extended check
// box or one extended push button callback.
//
//
//  cbSize          - size of this structure
//
//  Flags           - flags for the EXTPUSH as EPF_xxxx
//
//                      EPF_PUSH_TYPE_DLGPROC
//
//                          If this bit is set then it specified the extended
//                          push button is type of DLGPROC and DlgProc and
//                          DlgTemplateID is valid for common UI to call.
//
//                          If this bit is clear then it specfied the extended
//                          push button is the callback style and pfnCallBack
//                          should be called by the common UI
//
//
//                      EPF_INCL_SETUP_TITLE
//
//                          If specified for the extended push button then it
//                          automatically add the 'Setup' to the end of
//                          extended push button's title
//
//
//                      EPF_NO_DOT_DOT_DOT
//
//                          If specified then common UI will not add '...' to
//                          the end of the pTitle in the EXTPUSH.
//
//
//                      EPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID.
//
//
//                      EPF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                      EPF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                      EPF_OVERLAY_NO_ICON
//
//                          If this bit is set then this EXTPUSH's icon will be
//                          overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle          - Pointed to extended push botton title
//
//                      ** See LPTSTR description above
//
//  DlgProc         - Pointer to the DLGPROC function supplied by the caller.
//                    When user push the button the common UI will call
//                    DialogBoxParam() with this fucction pointer and passed
//                    CPSUICBPARAM structure pointer to the WM_INITDIALOG with
//                    the Reason set to CPSUICB_REASON_EXTPUSH.  If this
//                    filed is NULL then common UI assumed that EXTPUSH is
//                    disabled (OPTIF_EXT_DISABLED | OPTIF_EXT_HIDE), this
//                    fields only used if EPF_PUSH_TYPE_DLGPROC flag is set
//
//  pfnCallBack     - Pointer to CPSUICALLBACK function, this only used if
//                    EPF_PUSH_TYPE_DLGPROC bit is clear, duringing callback
//                    it passed the CPSUICBPARAM pointer as parameter
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    EPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - Specified the ressource ID for the dilaog box. If the
//                    DlgTemplateID = 0 then common UI will call the DlgProc
//                    with following parameter.
//
//                      DlgProc(hDlg, WM_USER, NULL, (LPARAM)pCPSUICBPaam);
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//  wReserved[]     - WORD reserved field, must be 0
//
//  dwReserved[]    - DWORD reserved field, must be 0
//
//
//


//
// Following are flags for the EXTCHKBOX
//

#define ECBF_CHECKNAME_AT_FRONT         0x0001
#define ECBF_CHECKNAME_ONLY_ENABLED     0x0002
#define ECBF_ICONID_AS_HICON            0x0004
#define ECBF_OVERLAY_WARNING_ICON       0x0008
#define ECBF_OVERLAY_ECBICON_IF_CHECKED 0x0010
#define ECBF_OVERLAY_STOP_ICON          0x0020
#define ECBF_OVERLAY_NO_ICON            0x0040
#define ECBF_CHECKNAME_ONLY             0x0080


typedef struct _EXTCHKBOX {
    WORD        cbSize;         // size of the structure
    WORD        Flags;          // ECBF_xxx flags
    LPTSTR      pTitle;         // extended checkbox title
    LPTSTR      pSeparator;     // pointer to separator string for treeview
    LPTSTR      pCheckedName;   // string to be displayed when checked
    ULONG_PTR   IconID;         // icon to be used
    WORD        wReserved[4];   // reserved word, must be 0
    ULONG_PTR   dwReserved[2];  // reserved field, must be 0
    } EXTCHKBOX, *PEXTCHKBOX;


//
// EXTCHKBOX structure is used to describe the extened check box available on
// OPTITEM/OPTITEM, each OPTTYPE can optional have one extended check box.
// When using EXTCHKBOX the selection item can be checked or not checked
// based on user input.
//
//
//  cbSize      - size of this structure
//
//  Flags       - flags for the EXTCHKBOX as ECBF_xxxx
//
//                  ECBF_CHECKNAME_AT_FRONT
//
//                      This flag specified how to display item's name and its
//                      checked name in the treeview display.   If this flag is
//                      set then the checked name is display in front of
//                      separator name, otherwise the checked name is displayed
//                      after the separator.  For Example.
//
//                      Flag Set:   pCheckedName pSeparator SelectName
//                      Flag Clear: SelectName pSeparator pCheckedName
//
//
//                  ECBF_CHECKNAME_ONLY_ENABLED
//
//                      If set then it specified that in the treeview display,
//                      it will only show the pCheckedName if this extended
//                      check box is visible and enabled.  Some items may not
//                      desired to display the pCheckedName if the extended
//                      check box is disabled, such as Copy/Collate checkbox.
//
//
//                  ECBF_ICONID_AS_HICON
//
//                      If this flag is set then IconID DWORD field is treated
//                      as a handle to the icon rather then the resource ID
//
//
//                  ECBF_OVERLAY_WARNING_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_WARNING icon.
//
//
//                  ECBF_OVERLAY_ECBICON_IF_CHECKED
//
//                      This bit specified to overlay the ExtChkBox's Icon to
//                      the OPTITEM's icon (or OPTPARAM) if the the extended
//                      checked box is checked
//
//
//                  ECBF_OVERLAY_STOP_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_STOP icon.
//
//
//                  ECBF_OVERLAY_NO_ICON
//
//                      If this bit is set then this EXTCHKBOX's icon will
//                      be overlaied by a common UI's IDI_CPSUI_NO icon.
//
//
//  pTitle      - Pointed to extended check box title
//
//                  ** See LPTSTR description above
//
//  pSeparator  - Pointer to the separator to be used in the treeview
//                display or the static title control in the non-treeview
//                page,
//
//  pCheckedName- Pointed to the name to be displayed in the treeview if item
//                is checked.  pCheckedName is added according to the
//                pSeparator and the ECBF_CHECKNAME_AT_FRONT flags.
//
//                  * If the pCheckedName is equal to IDS_CPSUI_NOTINSTALLED
//                    then common UI will automatically overaly a not installed
//                    icon on top of the extended check box Icon.
//
//                      ** See LPTSTR description above
//
//  IconID      - This is the icon identifier, which can be a common strandard
//                IDI_CPSUI_xxx icon ID, caller's own icon resource ID, or a
//                handle to the caller defined icon if ECBF_ICONID_AS_HICON
//                flag is set, in any case if the IconID is zero then it
//                indicated no icon.
//
//  wReserved[] - WORD reserved field, must be 0
//
//  dwReserved[]- DWORD reserved field, must be 0
//


//
// Following the the Flags for the OPTITEM
//

#define OPTIF_COLLAPSE              0x00000001L
#define OPTIF_HIDE                  0x00000002L
#define OPTIF_CALLBACK              0x00000004L
#define OPTIF_CHANGED               0x00000008L
#define OPTIF_CHANGEONCE            0x00000010L
#define OPTIF_DISABLED              0x00000020L
#define OPTIF_ECB_CHECKED           0x00000040L
#define OPTIF_EXT_HIDE              0x00000080L
#define OPTIF_EXT_DISABLED          0x00000100L
#define OPTIF_SEL_AS_HICON          0x00000200L
#define OPTIF_EXT_IS_EXTPUSH        0x00000400L
#define OPTIF_NO_GROUPBOX_NAME      0x00000800L
#define OPTIF_OVERLAY_WARNING_ICON  0x00001000L
#define OPTIF_OVERLAY_STOP_ICON     0x00002000L
#define OPTIF_OVERLAY_NO_ICON       0x00004000L
#define OPTIF_INITIAL_TVITEM        0x00008000L
#define OPTIF_HAS_POIEXT            0x00010000L

#define OPTIF_MASK                  0x0001ffffL


#define DMPUB_NONE                  0
#define DMPUB_FIRST                 1

#define DMPUB_ORIENTATION           1
#define DMPUB_SCALE                 2
#define DMPUB_COPIES_COLLATE        3
#define DMPUB_DEFSOURCE             4
#define DMPUB_PRINTQUALITY          5
#define DMPUB_COLOR                 6
#define DMPUB_DUPLEX                7
#define DMPUB_TTOPTION              8
#define DMPUB_FORMNAME              9
#define DMPUB_ICMMETHOD             10
#define DMPUB_ICMINTENT             11
#define DMPUB_MEDIATYPE             12
#define DMPUB_DITHERTYPE            13
#define DMPUB_OUTPUTBIN             14
#define DMPUB_QUALITY               15
#define DMPUB_NUP                   16
#define DMPUB_PAGEORDER             17

#define DMPUB_LAST                  17

#define DMPUB_OEM_PAPER_ITEM        97
#define DMPUB_OEM_GRAPHIC_ITEM      98
#define DMPUB_OEM_ROOT_ITEM         99
#define DMPUB_USER                  100

#define MAKE_DMPUB_HIDEBIT(DMPub)   (DWORD)(((DWORD)0x01 << ((DMPub) - 1)))
#define IS_DMPUB_HIDDEN(dw, DMPub)  (BOOL)((DWORD)(dw) &                    \
                                           MAKE_DMPUB_HIDEBIT(DMPub))

//
// DMPUB_xxxx is used in OPTITEM to identify if the item is a DEVMODE public
// field. Following it identify which field correspond to the DMPUB_xxxx
//
//
//  DMPUB_ORIENTATION   - dmOrientation
//
//  DMPUB_SCALE         - dmScale
//
//  DMPUB_COPIES_COLLATE- dmCopies/dmCollate
//
//  DMPUB_DEFSOURCE     - dmDefSource    (Should only used form by caller)
//
//  DMPUB_PRINTQUALITY  - dmPrintQuality
//
//  DMPUB_COLOR         - dmColor
//
//  DMPUB_DUPLEX        - dmDuplex
//
//  DMPUB_TTOPTION      - dmTTOption
//
//  DMPUB_FORMNAME      - dmFormName
//
//  DMPUB_ICMMETHOD     - dmICMMethod
//
//  DMPUB_ICMINTENT     - dmICMIntent
//
//  DMPUB_MEDIATYPE     - dmMediaType
//
//  DMPUB_DITHERTYPE    - dmDitherType
//
//  DMPUB_USER          - Anything greater than or equal to DMPUB_USER can be
//                        used by the caller.
//
//  DMPUB_OUTPUTBIN     - Private
//
//  DMPUB_QUALITY       - Private
//
//  DMPUB_NUP           - Private
//
//  DMPUB_PAGEORDER     - Private
//
// When common UI is called for the 'Document Properties' (DEVMODE), it will
// group some of public items together simillar to the following in the
// treeview. How it group is common UI version dependent and caller should not
// concern its placement
//
//      Paper/Output                (Add in by the common UI)
//        Document Form             (DMPUB_FORMNAME)
//        Output Bin                (DMPUB_OUTPUTBIN)
//        Orientation               (DMPUB_ORIENTATION)
//        Source                    (DMPUB_DEFSOURCE)
//        Media                     (DMPUB_MEDIATYPE)
//        Number of Copies          (DMPUB_COPIES_COLLATE)
//        Page Order                (DMPUB_PAGEORDER)
//        Page Per Sheet            (DMPUB_NUP)
//        Duplex                    (DMPUB_DUPLEX)
//
//      Graphic                     (Add in by the common UI)
//        Print Quality             (DMPUB_PRINTQUALITY)
//        Quality Settings          (DMPUB_QUALITY)
//        Color                     (DMPUB_COLOR)
//          Image Color Matching    (Add in by the common UI)
//              ICM Method          (DMPUB_ICMMETHOD)
//              ICM Intent          (DMPUB_ICMINTENT)
//        Scaling                   (DMPUB_SCALE)
//        Dithering                 (DMPUB_DITHERTYPE)
//        TrueType Option           (DMPUB_TTOPTION)
//
//      Options
//        Halftone Color Adjustment...
//        ALL Other Caller's Document sticky options
//
//
//  For 'Document Properties' the standard page 1 (user friendly page) will
//  consist following items if it appear in the OPTITEM array passed by the
//  caller.   These items must have following predefined TVOT_xxx type
//  defined here and specified in the OPTTYPE's Type field.
//
//  All DMPUB_xxx (except >= DMPUB_USER) public ID must have following
//  TVOT_xxxx type specified, else a CPDU_INVALID_DMPUB_TVOT error is returned
//
//      DMPUB_ORIENTATION       - TVOT_2STATES/TVOT_3STATES
//      DMPUB_SCALE             - TVOT_UDARROW
//      DMPUB_COPIES_COLLATE    - TVOT_UDARROW + EXTCHKBOX (Collate)
//      DMPUB_DEFSOURCE         - TVOT_LISTBOX
//      DMPUB_PRINTQUALITY      - TVOT_LISTBOX
//      DMPUB_COLOR             - TVOT_2STATES
//      DMPUB_DUPLEX            - TVOT_2STATES/TVOT_3STATES
//      DMPUB_TTOPTION          - TVOT_LISTBOX
//      DMPUB_FORMNAME          - TVOT_LISTBOX
//      DMPUB_ICMMETHOD         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_ICMINTENT         - TVOT_2STATES/TVOT_3STATES
//      DMPUB_MEDIATYPE         - TVOT_LISTBOX
//      DMPUB_DITHERTYPE        - TVOT_LISTBOX
//
//


#define OIEXTF_ANSI_STRING      0x0001

typedef struct _OIEXT {
    WORD        cbSize;
    WORD        Flags;
    HINSTANCE   hInstCaller;
    LPTSTR      pHelpFile;
    ULONG_PTR   dwReserved[4];
    } OIEXT, *POIEXT;

//
// OIEXT is a data structure used as extension to the OPTITEM data structure
//
//
//  cbSize      - sizeof this structure
//
//  Flags       - One or more of OIEXTF_xxxx may be specified.
//
//                  OIEXTF_ANSI_STRING
//
//                      Specified that LPTSTR in this data structure is a ansi
//                      string (not UNICODE).  This bit only checked if the
//                      LPTSTR is not the resource string ID
//
//  hInstCaller - DLL instance handle, when this hInst is not NULL then all
//                resource string and icon loading for this OPTITEM and its
//                OPTTYPE, OPTPARAM are loaded from this hInstCaller Handle.
//                If this filed is NULL then it will use the hInstCaller handle
//                specified in the COMPROPSHEETUI data structure
//
//  pHelpFile   - Resource string ID or pointer to the help file for this
//                OPTITEM.  If this pointer is NULL then help file for the
//                help index is assume specified in the pHelpFile field in the
//                COMPROPSHEETUI data structure.
//
//  dwReserved  - These fields are not used now, and must 0
//


typedef struct _OPTITEM {
    WORD        cbSize;                 // size of this structure
    BYTE        Level;                  // level in the tree view
    BYTE        DlgPageIdx;             // Index to the pDlgPage
    DWORD       Flags;                  // OPTIF_xxxx flags
    ULONG_PTR   UserData;               // caller's own data
    LPTSTR      pName;                  // name of the item
    union {
        LONG    Sel;                    // current selection (index)
        LPTSTR  pSel;                   // current selection (pStr)
        } DUMMYUNIONNAME;
    union {
        PEXTCHKBOX  pExtChkBox;         // Pointer to EXTCHKBOX structure
        PEXTPUSH    pExtPush;           // Pointer to EXTPUSH
        } DUMMYUNIONNAME2;
    POPTTYPE    pOptType;               // pointer to OPTTYPE structure
    DWORD       HelpIndex;              // Help file index
    BYTE        DMPubID;                // Devmode public filed ID
    BYTE        UserItemID;             // caller's own item ID
    WORD        wReserved;              // reserved WORD field, must be 0
    POIEXT      pOIExt;                 // Optitem extension pointer
    ULONG_PTR   dwReserved[3];          // reserved DWORD fields (must be 0)
    } OPTITEM, *POPTITEM;

//
// OPTITEM is to describe each treeview item's name, selection type and
// possible selection
//
//  cbSize          - sizeof this structure
//
//  Level           - The level in the treeview, the root should have lowest
//                    number and number should start with level 0.  the maximum
//                    number of levels are 256.
//
//  DlgPageIdx      - Zero-based index to the DLGPAGE araay pointee by
//                    pDlgPage. The Maximum index is MAX_DLGPPAGE_COUNT, if
//                    pDlgPage is a standard CPSUI_PDLGPAGE_xxxx then this
//                    field is automatically set the common UI
//
//  Flags           - OPTIF_xxxx flags as describe above
//
//                      OPTIF_COLLAPSE
//
//                          Collaspe treeview item and its children so it is
//                          not expanded initially.
//
//
//                      OPTIF_HIDE
//
//                          Hide this item from the treeview
//
//
//                      OPTIF_CALLBACK
//
//                          Callback to the caller when user making some
//                          changes a pointer (pfnCallBack) must provided and
//                          process as defined by the common UI.
//
//
//                      OPTIF_CHANGED
//
//                          This item was changed and need to re-display. this
//                          flag only used when caller returned from callback
//                          funciton.
//
//
//                      OPTIF_CHANGEONCE
//
//                          This item has been changed at least once.
//
//
//                      OPTIF_DISABLED
//
//                          Disable this item so it become not selectable.
//
//
//                      OPTIF_ECB_CHECKED
//
//                          Specified the associated extended check box is
//                          in checked state.
//
//
//                      OPTIF_EXT_HIDE
//
//                          Hide the extended check box/extended push botton.
//
//
//                      OPTIF_EXT_DISABLED
//
//                          The Extended check box/push botton is disabled and
//                          not selectable
//
//
//                      OPTIF_SEL_AS_HICON
//
//                          This flag only used if this item has no type,
//                          pOptType=NULL that is, when pOptType is NULL then
//                          'Sel' field is the IconID. if flag is set then it
//                          indicate 'pSel' is the Icon handle rather
//                          than the icon resource ID specified in Sel.
//
//
//                      OPTIF_EXT_IS_EXTPUSH
//
//                          Specified that pExtPush should be used when this
//                          pointer is not NULL, if this pointer is not NULL
//                          and this flag is clear then pExtChkBox is assumed.
//
//
//                      OPTIF_NO_GROUPBOX_NAME
//
//                          Specified that do not overwrite the group box title
//                          text, if group box ID is defined. See the TVOT_xx
//                          description above.
//
//
//                      OPTIF_OVERLAY_WARNING_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's
//                          IDI_CPSUI_WARNING icon.  This bit only used if this
//                          item has no type, pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_STOP_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_STOP
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_OVERLAY_NO_ICON
//
//                          If this bit is set then this header OPTITEM's icon
//                          will be overlaied by a common UI's IDI_CPSUI_NO
//                          icon.  This bit only used if this item has no type,
//                          pOptType is NULL that is.
//
//
//                      OPTIF_INITIAL_TVITEM
//
//                          Specified that this item will be the initial item
//                          to be selected and display on the treeview page.
//                          If the selected item is currently a child or
//                          collapse then common UI will expand the selection
//                          then scroll it into view.
//
//                          If this flag is clear or the set item is in hide
//                          status common UI will pick the initial item to
//                          display.
//
//                      OPTIF_HAS_POIEXT
//
//                          Specified that pOIExt field is a valid pointer that
//                          points to OIEXT data structure.  The pOIExt only
//                          used by the common UI if this bit is set.
//
//
//  UserData        - a 32-bit number used by the caller and common UI will not
//                    modify it.
//
//  pName           - Pointer to the item's name, such as 'Upper Tray',
//                    'Memory' or it is used as data as describe in
//                    OPTPARAM/OPTTYPE structure
//
//                      ** See LPTSTR description above
//
//  pSel
//  Sel             - Current selection for this item. This is a union field
//                    which can be a pointer to a string or a LONG index
//                    selection.
//
//                      ** If pOptType field is NULL then 'Sel' is the icon ID
//                         to be used for the header.
//
//  pExtPush
//  pExtChkBox      - Pointer to either EXTPUSH or EXTCHKBOX data structure,
//                    if this pointer is NULL then this item does not have
//                    ectended check box/push botton associate with it.
//
//                    When an extended check box is associate with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH must not set, the
//                    OPTIF_ECB_CHECKED flag specified if the extended check
//                    box is checked or not checked.
//
//                    When an Extended push botton is associated with the
//                    OPTTYPE, the OPTIF_EXT_IS_EXTPUSH flag must set.
//
//                    The following flags are used in both EXTCHKBOX or
//                    EXTPUSH
//
//                      OPTIF_EXT_HIDE,
//                      OPTIF_EXT_DISABLED
//                      OPTIF_EXT_CHANGEONCE
//
//
//  pOptType        - Pointer to the OPTTYPE structure to describe the display
//                    and selections of the item.   If this pointer is NULL
//                    then this this item does not have any selection. and it
//                    is used as sub-items' header.
//
//                      * When pOptType is NULL then the 'Sel' is the Icon ID.
//
//
//  HelpIndex       - a index to the help file for context sensitive help
//                    if HelpInex=0 then there is no help for this item
//
//  DMPubID         - specified if this item is one of the public fields in the
//                    DEVMODE structure and supported by the common UI.
//
//                      DMPUB_NONE              - Not DEVMODE public fields
//                      DMPUB_ORIENTATION       - dmOrientation
//                      DMPUB_SCALE             - dmScale
//                      DMPUB_COPIES_COLLATE    - dmCopies/dmCollate
//                      DMPUB_DEFSOURCE         - dmDefSource
//                      DMPUB_PRINTQUALITY      - dmPrintQuality
//                      DMPUB_COLOR             - dmColor
//                      DMPUB_DUPLEX            - dmDuplex
//                      DMPUB_TTOPTION          - dmTTOption
//                      DMPUB_FORMNAME          - dmFormName
//                      DMPUB_ICMMETHOD         - dmICMMethod
//                      DMPUB_ICMINTENT         - dmICMIntent
//                      DMPUB_MEDIATYPE         - dmMediaType
//                      DMPUB_DITHERTYPE        - dmDitherType
//
//                      ** for most of DMPUB_FIRST to DMPUB_LAST each OPTITEM's
//                         pName is automatically set to the standard
//                         IDS_CPSUI_xxx for the consistancy reason, the
//                         standard pName is set according to following table.
//
//                          DMPUB_ORIENTATION    - IDS_CPSUI_ORIENTATION
//                          DMPUB_SCALE          - IDS_CPSUI_SCALING
//                          DMPUB_COPIES_COLLATE - IDS_CPSUI_COPIES
//                          DMPUB_DEFSOURCE      - IDS_CPSUI_SOURCE
//                          DMPUB_PRINTQUALITY   - IDS_CPSUI_PRINTQUALITY
//                                                 IDS_CPSUI_RESOLUTION
//                          DMPUB_COLOR          - IDS_CPSUI_COLOR_APPERANCE
//                          DMPUB_DUPLEX         - IDS_CPSUI_DUPLEX
//                          DMPUB_TTOPTION       - IDS_CPSUI_TTOPTION
//                          DMPUB_FORMNAME       - IDS_CPSUI_FORMNAME
//                          DMPUB_ICMMETHOD      - IDS_CPSUI_ICMMETHOD
//                          DMPUB_ICMINTENT      - IDS_CPSUI_ICMINTENT
//                          DMPUB_MEDIATYPE      - IDS_CPSUI_MEDIA
//                          DMPUB_DITHERTYPE     - IDS_CPSUI_DITHERING
//
//                          for DMPUB_PRINTQUALITY, if the pName is not one of
//                          IDS_CPSUI_PRINTQUALITY or IDS_CPSUI_RESOLUTION then
//                          common UI will automatically default the pName to
//                          IDS_CPSUI_RESOLUTION.
//
//                          Each pData (OPTPARAM) selection in OPTPARAM which
//                          OPTITEM's pOptType pointed to should use as much
//                          as IDS_CPSUI_xxx standard name as possible.
//
//
//                      ** for DMPUB_COPIES_COLLATE the common UI automatically
//                         doing the following before the callback
//
//                          1) Enable/Disable the collate extended check box if
//                             OPTIF_EXT_HIDE is not specified and pExtChkBox
//                             is not NULL in the OPTITEM.
//
//                          2) Automatically change the postfix for this item
//                             to be 'Copy' if selection is one, and 'Copies'
//                             if selection is greater than one in the treeview
//                             page, and it will also set the postfix in
//                             standard document property page if the postfix
//                             ID is provided (BegCtrlID + 4)
//
//
//                      ** for DMPUB_COLOR the common UI automatically doing
//                         the following before the callback, the gray
//                         selection must be Sel=0 and Color slection must be
//                         Sel=1
//
//                          1) Calling halftone color adjustment with current
//                             color/mono selection
//
//                          2) Disable ICM when color is not selected
//
//
//                      ** Please see above DMPUB_xx description for details.
//
//  UserItemID      - This is a byte ID intented to be used by the caller to
//                    identify the item
//
//  wReserved       - WORD reserved. Must be zero
//
//  pOIExt          - Pointer to the OIEXT data structure to specified that
//                    it has a OPTITEM extenstion structure.
//
//  dwReserved[]    - DWORD reserved and must be 0
//
//

//
// predefined ID for call back reason
//

#define CPSUICB_REASON_SEL_CHANGED      0
#define CPSUICB_REASON_PUSHBUTTON       1
#define CPSUICB_REASON_ECB_CHANGED      2
#define CPSUICB_REASON_DLGPROC          3
#define CPSUICB_REASON_UNDO_CHANGES     4
#define CPSUICB_REASON_EXTPUSH          5
#define CPSUICB_REASON_APPLYNOW         6
#define CPSUICB_REASON_OPTITEM_SETFOCUS 7
#define CPSUICB_REASON_ITEMS_REVERTED   8
#define CPSUICB_REASON_ABOUT            9
#define CPSUICB_REASON_SETACTIVE        10
#define CPSUICB_REASON_KILLACTIVE       11


//
// predefined ID for call back action
//

#define CPSUICB_ACTION_NONE             0
#define CPSUICB_ACTION_OPTIF_CHANGED    1
#define CPSUICB_ACTION_REINIT_ITEMS     2
#define CPSUICB_ACTION_NO_APPLY_EXIT    3
#define CPSUICB_ACTION_ITEMS_APPLIED    4


typedef struct _CPSUICBPARAM {
    WORD        cbSize;             // size of this structure
    WORD        Reason;             // CPSUICB_REASON_XXXXX callback reason
    HWND        hDlg;               // handle of the dialog box
    POPTITEM    pOptItem;           // pOptItem field from COMPROPSHEETUI
    WORD        cOptItem;           // cOptItem field from COMPROPSHEETUI
    WORD        Flags;              // flags field from COMPROPSHEETUI
    POPTITEM    pCurItem;           // current selected item of callback
    union {
        LONG    OldSel;             // Last selection (index)
        LPTSTR  pOldSel;            // Last selection (pStr)
        } DUMMYUNIONNAME;
    ULONG_PTR   UserData;           // UserData in the COMPROPSHEETUI struct.
    ULONG_PTR   Result;             // OUT parameter for the APPLYNOW
    } CPSUICBPARAM, *PCPSUICBPARAM;


typedef LONG (APIENTRY *_CPSUICALLBACK)(PCPSUICBPARAM pCPSUICBParam);
#define CPSUICALLBACK   LONG APIENTRY


//
// CPSUICBPARAM is used when commom UI callback to the caller, this structure
// describe the nature of callback and passed all necessary parameter for the
// caller to make changes in the pOptItem and passed an action back to the
// commom UI to redisplay the tree or page 1 data
//
//
//  cbSize      - must be CPSUICBPARAM
//
//  Reason      - defined the nature of the callback
//
//                  CPSUICB_REASON_SEL_CHANGED
//
//                      User make change to the pCurItem.  if the item is
//                      DMPUB_COPIES_COLLATE then common UI automatically
//                      change the collate extended check box without callback
//                      to the caller of the extended check box changes
//
//
//                  CPSUICB_REASON_PUSHBUTTON
//
//                      User push the push button and push button item is set
//                      to PUSHBUTTON_TYPE_CALLBACK.
//
//
//                  CPSUICB_REASON_ECB_CHANGED
//
//                      User make change to the extended checked box (i.e. it
//                      eiterh checked or not checked) EXTCHKBOX in the
//                      pCurItem passed in the call back parameter.
//
//
//                  CPSUICB_REASON_DLGPROC
//
//                      The callback reason is PUSHBUTTON_TYPE_DLGPROC
//
//
//                  CPSUICB_REASON_UNDO_CHANGES
//
//                      This callback currently is not implmented.
//
//
//                  CPSUICB_REASON_EXTPUSH
//
//                      The callback is result of user push the extend push
//                      button.
//
//
//                  CPSUICB_REASON_APPLYNOW
//
//                      The user press the apply now button. Durning callback
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the active DlgPageIdx
//                      (compare to the OPTITEM's DlgPageIdx) which the page
//                      user hitting the apply now button if the page is
//                      non-treeview page, otherwise the 'OldSel' is set to -1
//                      (for treeview page) to indicate all valid item should
//                      be apply now, if the callback return
//                      CPSUICB_ACTION_NONE then the common UI will exit the
//                      property sheet and returned CPSUI_OK back to the
//                      caller, and if the callback function returned
//                      CPSUICB_ACTION_NO_APPLY_EXIT then common UI will not
//                      exit the property sheet and callback function must
//                      pop-up messages dialog box to tell user why it cannot
//                      exist the property sheet until certain action is take
//                      by the user.
//
//
//                  CPSUICB_REASON_OPTITEM_SETFOCUS
//
//                      This callback reason is used when an OPTITEM is getting
//                      the keyboard focus. and give the callback function a
//                      chance to examine the item.
//
//
//                  CPSUICB_REASON_ITEMS_REVERTED
//
//                      This callback reason is used when user changed items
//                      and decided to revert changes from the parent item in
//                      the treeview.  The callback funciton is called after
//                      all revertable items are reverted to its original.
//
//                      The CPSUICBPARAM's pCurItem is same as pOptItem and
//                      'OldSel' field is same as cOptItem field.  for each of
//                      reverted item, the OPTIF_CHANGED bit will be set in the
//                      OPTITEM by the common UI to indicate the item is revert
//                      by the common UI.   The callback function MUST NOT
//                      reset this bit if it is set.
//
//
//                  CPSUICB_REASON_ABOUT
//
//                      This callback reason is used when user hit 'About...'
//                      push button in the treeview page, and the flag
//                      CPSUIF_ABOUT_CALLBACK is set.  The pCurItem is set to
//                      same as pOptItem and 'pOldSel' is a pointer pointed to
//                      original copy of COMPROPSHEETUI data structure which
//                      passed to the common UI.
//
//
//                  CPSUICB_REASON_SETACTIVE
//                  CPSUICB_REASON_KILLACTIVE
//
//                      The current property sheet is gaining or loosing focus,
//                      the pCurItem is set to equal to pOptItem in this
//                      structure and 'OldSel' is set to the current active
//                      DlgPageIdx (compare to the OPTITEM's DlgPageIdx).
//                      if the page is non-treeview page, otherwise the
//                      'OldSel' is set to -1 (for treeview page).
//
//  hDlg        - The handle to the dialog box (Properties page TAB) current
//                active for the callback.
//
//                Durning the callback the caller must not change the
//                DWLP_USERDATA on hDlg, otherwise the common UI will be crash.
//                If callback function need to get/set DWLP_USERDATA it should
//                call common UI's SetCPSUIUserData() and GetCPSUIUserData()
//                functions instead.
//
//  pCurItem    - Pointed to POPTITEM which the callback is generated for.
//
//  pOldSel
//  OldSel      - The last OPTITEM's pSel/Sel field before the change was made
//                by the user.  The pOldSel/OldSel only valid if the callback
//                reason is CPSUICB_REASON_SEL_CHANGED, this give the callback
//                function a chance to check against the previous item
//                selection.  This is a union field which can be a pointer to
//                a string or a LONG index selection.
//
//  UserData    - a 32-bit user defined data in the COMPROPSHEETUI structure,
//                commom UI will not changed it.
//
//  Result      - When the reason is CPSUICB_REASON_APPLYNOW, the callback
//                function MUST set the requested result for the caller into
//                'Result' field when it returned a value other than the
//                CPSUICB_ACTION_NO_APPLY_EXIT and common UI will send the
//                'Result' field value to this page's parent.
//
//                The called function should save the current result of
//                pOptItem.  The default 'Result' is set to CPSUI_OK (1) from
//                common UI.  This function can alter this result before it
//                return back to to the common UI.
//
//
//  Return Values:
//
//      CPSUICB_ACTION_NONE             - No action need to be take by the
//                                        common UI.
//
//      CPSUICB_ACTION_OPTIF_CHANGED    - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-display because of OPTITEM's Flags
//                                        field changed or item's selection
//                                        changed.   This is different from
//                                        CPSUICB_ACTION_REINIT_ITEMS which
//                                        it assume OPTTYPE or OPTPARAM data
//                                        also changed.
//
//
//      CPSUICB_ACTION_REINIT_ITEMS     - Ask the common UI to examine the
//                                        OPTIF_CHANGED flag in the OPTITEM
//                                        data structure.  if the flag is set
//                                        then that item is assume need to be
//                                        re-initialized in the dilaog box
//                                        control.  This happened if item's
//                                        OPTTYPE or OPTPARAMs flag/pdata
//                                        changed.
//
//
//      CPSUICB_ACTION_NO_APPLY_EXIT    - This return value only valid durning
//                                        CPSUICB_REASON_APPLYNOW callback
//                                        reason, it tell common UI it has
//                                        some constraints in its OPTITEM which
//                                        must correct or confirm by the user
//                                        before exit.  The callback function
//                                        must display and/or have user taking
//                                        some actions before return this
//                                        action to the common UI
//
//      CPSUICB_ACTION_ITEMS_APPLIED    - When responsed to the
//                                        CPSUICB_REASON_APPLYNOW, if the
//                                        returned action is
//                                        CPSUICB_ACTION_ITEMS_APPLIED then
//                                        common UI will reset OPTIF_CHANGEONCE
//                                        bit and save the new default for the
//                                        future undo operations.
//
//

#define DP_STD_TREEVIEWPAGE             0xFFFF
#define DP_STD_DOCPROPPAGE2             0xFFFE
#define DP_STD_DOCPROPPAGE1             0XFFFD
#define DP_STD_RESERVED_START           0xFFF0

#define MAX_DLGPAGE_COUNT               64

#define DPF_ICONID_AS_HICON             0x0001
#define DPF_USE_HDLGTEMPLATE            0x0002

typedef struct _DLGPAGE {
    WORD        cbSize;         // size of this structure
    WORD        Flags;          // DPF_xxxx flags
    DLGPROC     DlgProc;        // caller's dialog box subclass procedue
    LPTSTR      pTabName;       // pointer to the tab name
    ULONG_PTR   IconID;         // icon to be used
    union {
        WORD    DlgTemplateID;  // dialog box template ID
        HANDLE  hDlgTemplate;   // handle to the dialog template
        } DUMMYUNIONNAME;
    } DLGPAGE, *PDLGPAGE;


//
// DLGPAGE structure describe non-treeview page characteristics
//
//
//  cbSize          - size of this structure
//
//  Flags           - DPF_xxxx flags
//
//                      DPF_ICONID_AS_HICON
//
//                          If this flag is set then IconID DWORD field is
//                          treated as a handle to the icon rather then the
//                          resource ID
//
//
//  DlgProc         - caller's supplied DLGPROC for sub-class the page
//                    dialog box processing,
//
//                    if DlgProc is not NULL then common UI do the following
//                    according the the message received except for the
//                    DP_STD_xxx pages
//
//
//                      WM_INITDIALOG
//
//                          Common UI initialize the dialog box and then call
//                          DlgProc(WM_INITDIALOG) the DlgProc should return
//                          exactly the behavior for the WM_INITDIALOG
//
//                          The lParam in the WM_INITDIALOG data structure is
//                          a pointer to the PROPSHEETPAGE data structure.
//
//                          the lParam field in the PROPSHEETPAGE (lParam
//                          passed to the WM_INITDIALOG) is the UserData
//                          defined in COMPROPSHEETUI data structure
//
//                          To access to the PSPINFO data structure which
//                          associate with this page, use the common UI macro
//                          PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) where
//                          lParam is the parameter passed to the
//                          WM_INITDIALOG message.
//
//                          The subclass function should save these pointers
//                          for its later use, but it MUST NOT modified the
//                          content of the PSPINFO data structure or system
//                          may crashed.
//
//
//                      OTHER DIALOG MESSAGES
//
//                          Iit call DlgProc() and if it returned the value is
//                          non-zero then common UI assume DlgProc() processed
//                          the message and will not process this message.
//
//                          If the returned vlaue from DlgProc() is zero then
//                          common UI will process this message.
//
//
//                      * Durning the DlgProc the caller must not change the
//                        DWLP_USERDATA on hDlg, otherwise the common UI will
//                        be crash.  If caller need to get/set DWLP_USERDATA it
//                        should call common UI's SetCPSUIUserData() and
//                        GetCPSUIUserData() instead.
//
//  pTabName        - Pointer to a string to describe the TAB title
//
//  IconID          - This is the icon identifier, which can be a common
//                    strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                    resource ID, or a handle to the caller defined icon if
//                    DPF_ICONID_AS_HICON flag is set, in any case if the
//                    IconID is zero then it indicated no icon.
//
//  DlgTemplateID   - The template id to be use for the ProPage, it can be
//                    one of DP_STD_xxxx, the DP_STD_xxx has 240 x 240 dialog
//                    box units.
//
//
//                      DP_STD_TREEVIEWPAGE
//
//                          Specified that this page is a standard treeview
//                          page provided by the common ui.  The treeview page
//                          is a page using treeview display all valid OPTITEM
//                          passed to the common UI.  User can modify every
//                          valid selectable OPTITEM from the treeview page.
//
//                      DP_STD_DOCPROPPAGE
//
//                          Specified that this page is a standard document
//                          property page provided by the common UI
//
//  hDlgTemplate    - Handle to the DLGTEMPLATE which will be use for pop up
//                    dialog box
//
//
//  wReserved[]
//  dwReserved[]    - Reserved fields, must be 0
//
//
//  ** Tips of designing the dialog box controls
//
//      When designing the dialog box controls, each OPTITEM is correspoonds
//      to one input control plus one extended check box or extended push
//      button.  Since common UI will automatically disable and remove
//      OPTIF_HIDE items item from the property sheet and dynamically move
//      other controls, the following tips of designing the dialog box controls
//      should follow.
//
//      * Each item should have one input control plus optional of extended
//        check box/push botton, one icon control and other static controls
//
//      * Each item should occupied whole horizontal spaces of the property
//        sheet, items must not overlay in vertical direction.
//
//      * for TVOT_2STATES, TVOT_3STATES, if it araange radio buttons from
//        left to right in state order (ie. from first state's OPTPARAM to
//        last state's OPTPARAM) then the radio buttons and icons should
//        aligned in the Y coordinate.    If it arrange radio buttons from top
//        to bottom (ie. from first state's OPTPARAM to last state's OPTPARAM)
//        then the radio buttons and icons should aligned in the X coordinate.
//
//        common UI will automatically hide/move the radio buttons to compact
//        the dialog box controls.  If radio buttons/icons are arranged in
//        top/down order and there is other controls obscure in Y direction
//        then radio buttons will only be re-arranged but not remove any white
//        spaces in Y direction.
//
//      * If multiple items shared one group box, then the group box must
//        belongs to the first item (topmost in the dialog box group) in the
//        group, the group box must large enough to cover all the items in
//        side the group box.
//
//


#define CPSUIF_UPDATE_PERMISSION        0x0001
#define CPSUIF_ICONID_AS_HICON          0x0002
#define CPSUIF_ABOUT_CALLBACK           0x0004

#define CPSUI_PDLGPAGE_DOCPROP          (PDLGPAGE)1
#define CPSUI_PDLGPAGE_ADVDOCPROP       (PDLGPAGE)2
#define CPSUI_PDLGPAGE_PRINTERPROP      (PDLGPAGE)3
#define CPSUI_PDLGPAGE_TREEVIEWONLY     (PDLGPAGE)4

//
// For compatible misspelling #define
//

#define CPSUI_PDLGPAGE_TREEVIWONLY      CPSUI_PDLGPAGE_TREEVIEWONLY

typedef struct _COMPROPSHEETUI {
    WORD            cbSize;             // size of this structure
    WORD            Flags;              // CPSUIF_xxxx flags
    HINSTANCE       hInstCaller;        // caller's hInstance
    LPTSTR          pCallerName;        // pointer to the caller's name
    ULONG_PTR       UserData;           // caller's own data
    LPTSTR          pHelpFile;          // pointer to the help file
    _CPSUICALLBACK  pfnCallBack;        // callback function pointer
    POPTITEM        pOptItem;           // pointer to POPTITEM array
    PDLGPAGE        pDlgPage;           // pointer to the DLGPAGE array
    WORD            cOptItem;           // count of pOptItem array
    WORD            cDlgPage;           // count of pDlgPage array
    ULONG_PTR       IconID;             // icon to be used
    LPTSTR          pOptItemName;       // pointer to the optitem's data name
    WORD            CallerVersion;      // version for the caller apps
    WORD            OptItemVersion;     // version for the optitem name
    ULONG_PTR       dwReserved[4];      // reserved, must be 0
    } COMPROPSHEETUI, *PCOMPROPSHEETUI;


//
// COMPROPSHEETUI data structure is used when calling common UI to display dialog
// box of properties pages.
//
//
//  Size                - Must be sizeof (COMPROPSHEETUI)
//
//  Flags               - can be one or more of following
//
//                          CPSUIF_UPDATE_PERMISSION
//
//                              Specified the any valid pOptItem items are
//                              changeable by the user.
//
//
//                          CPSUIF_ICONID_AS_HICON
//
//                              If this flag is set then IconID DWORD field is
//                              treated as a handle to the icon rather then the
//                              resource ID
//
//
//                          CPSUIF_ABOUT_CALLBACK
//
//                              If this flag bit is set, then when user hit
//                              'About...' button in the treeview tab, it will
//                              call the callback function with a reason of
//                              CPSUICB_REASON_ABOUT, and callback MUST handle
//                              the about which pop-up dialog box to show user
//                              the information about the caller and OPTITEMs.
//
//                              If this bit is not set then common UI will call
//                              the ShellAbout() with formatted caller Name and
//                              pOptItemName with version numbers.
//
//
//  hInstCaller         - the caller's handle to its instance.  Commom UI use
//                        this handle to load caller's icon and other resources.
//
//  pCallerName         - Pointer to the caller's NULL terminated caller's
//                        name, most time this is driver's name,
//                        such as 'Postscript Driver'
//
//  UserData            - a 32-bit number used by the caller and common UI will
//                        not modify it.  this 32-bit number is passed back to
//                        the caller durning the callback function
//
//  pHelpFile           - specified a standard microsoft help file (path/file)
//                        for using in the common UI.  in OPTITEM specified
//                        HelpIndex for help in each item.
//
//  pfnCallBack         - Pointer to _CPSUICALLBACK callback function.  Common
//                        UI only callback to the caller if an OPTIF_CALLBACK
//                        is set OPTITEM data structure's flag fields and the
//                        item selection is changed by the user.
//
//  pOptItem            - Pointer to array of OPTITEM structure to be displayed
//                        by the common UI
//
//  pDlgPage            - Pointer to array of DLGPAGE structure to describe
//                        each property sheet page infomation, the following
//                        are the standard common ui DLGPAGEs.  When specified
//                        CPSUI_PDLGPAGE_xxxx, the common UI will automatically
//                        modify DlgPageIdx field in the OPTITEM, caller must
//                        set the iStartPage correctly.
//
//                          CPSUI_PDLGPAGE_DOCPROP
//
//                              specified this a common ui standard document
//                              property sheets. This includes two property
//                              sheets, 1) Page Setup 2) Advance (TreeView)
//
//
//                          CPSUI_PDLGPAGE_ADVDOCPROP
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page with tab of 'Advance'
//
//
//                          CPSUI_PDLGPAGE_PRINTERPROP
//
//                              Specified this is a common UI standard printer
//                              property sheet.  This only has one treeview
//                              page with tab of 'Device Options'
//
//
//                          CPSUI_PDLGPAGE_TREEVIEWONLY
//
//                              Specified this is a treeview page only UI
//                              provided by the common UI, this only has one
//                              treeview page
//
//
//
//  cOptItem            - Count of OPTITEM pointed by the pOptItem above
//
//  cDlgPage            - Count of DLGPAGE pointed by the pDlgPage.  If
//                        pDlgPage is one of the CPSUI_PDLGPAGE_xxxx then this
//                        field is ignored by the common UI.
//
//  IconID              - This is the icon identifier, which can be a common
//                        strandard IDI_CPSUI_xxx icon ID, caller's own icon
//                        resource ID, or a handle to the caller defined icon
//                        if CPSUIF_ICONID_AS_HICON flag is set, in any case
//                        if the IconID is zero then it indicated no icon.
//
//  pOptItemName        - Pointer to the pOptItem data NULL terminated name,
//                        most time this is device name, such as 'HP 4si'
//
//  CallerVersion       - Version for the caller, the HIBYTE(CallerVersion) is
//                        the major version, and LOBYTE(CallerVersion) is the
//                        minor version, such as 0x310 display as 3.16, 0x3ff
//                        display as 3.255 and 0x30a display as 3.10
//
//  OptItemVersion      - Version for the OPTITEM's data, the
//                        HIBYTE(OptItemVersion) is the major version, and
//                        LOBYTE(OptItemVersion) is the minor version, such as
//                        0x310 display as 3.16, 0x3ff display as 3.255 and
//                        0x30a display as 3.10.
//
//  dwReserved[4]       - reserved fields, must be 0
//
//
//  ** pTitlee and TitleBarIcon only used if CommonPrinterPropSheetUI()
//     is the last one the Property sheet UI chain and call the PropertySheet()
//
//


#define CPSFUNC_ADD_HPROPSHEETPAGE          0
#define CPSFUNC_ADD_PROPSHEETPAGEW          1
#define CPSFUNC_ADD_PCOMPROPSHEETUIA        2
#define CPSFUNC_ADD_PCOMPROPSHEETUIW        3
#define CPSFUNC_ADD_PFNPROPSHEETUIA         4
#define CPSFUNC_ADD_PFNPROPSHEETUIW         5
#define CPSFUNC_DELETE_HCOMPROPSHEET        6
#define CPSFUNC_SET_HSTARTPAGE              7
#define CPSFUNC_GET_PAGECOUNT               8
#define CPSFUNC_SET_RESULT                  9
#define CPSFUNC_GET_HPSUIPAGES              10
#define CPSFUNC_LOAD_CPSUI_STRINGA          11
#define CPSFUNC_LOAD_CPSUI_STRINGW          12
#define CPSFUNC_LOAD_CPSUI_ICON             13
#define CPSFUNC_GET_PFNPROPSHEETUI_ICON     14
#define CPSFUNC_ADD_PROPSHEETPAGEA          15
#define CPSFUNC_INSERT_PSUIPAGEA            16
#define CPSFUNC_INSERT_PSUIPAGEW            17
#define CPSFUNC_SET_PSUIPAGE_TITLEA         18
#define CPSFUNC_SET_PSUIPAGE_TITLEW         19
#define CPSFUNC_SET_PSUIPAGE_ICON           20
#define CPSFUNC_SET_DATABLOCK               21
#define CPSFUNC_QUERY_DATABLOCK             22
#define CPSFUNC_SET_DMPUB_HIDEBITS          23
#define CPSFUNC_IGNORE_CPSUI_PSN_APPLY      24
#define CPSFUNC_DO_APPLY_CPSUI              25
#define CPSFUNC_SET_FUSION_CONTEXT          26
#define MAX_CPSFUNC_INDEX                   26

#ifdef UNICODE
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIW
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIW
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGW
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEW
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEW
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEW

#else
#define CPSFUNC_ADD_PCOMPROPSHEETUI         CPSFUNC_ADD_PCOMPROPSHEETUIA
#define CPSFUNC_ADD_PFNPROPSHEETUI          CPSFUNC_ADD_PFNPROPSHEETUIA
#define CPSFUNC_LOAD_CPSUI_STRING           CPSFUNC_LOAD_CPSUI_STRINGA
#define CPSFUNC_ADD_PROPSHEETPAGE           CPSFUNC_ADD_PROPSHEETPAGEA
#define CPSFUNC_INSERT_PSUIPAGE             CPSFUNC_INSERT_PSUIPAGEA
#define CPSFUNC_SET_PSUIPAGE_TITLE          CPSFUNC_SET_PSUIPAGE_TITLEA

#endif

//
// for the CPSFUNC_SET_RESULT
//

#define SR_OWNER            0
#define SR_OWNER_PARENT     1

typedef struct _SETRESULT_INFO {
    WORD        cbSize;
    WORD        wReserved;
    HANDLE      hSetResult;
    LRESULT     Result;
    } SETRESULT_INFO, *PSETRESULT_INFO;

//
// This is for CPSFUNC_INSERT_PSUIPAGE
//

#define HINSPSUIPAGE_FIRST              (HANDLE)0xFFFFFFFE
#define HINSPSUIPAGE_LAST               (HANDLE)0xFFFFFFFF
#define HINSPSUIPAGE_INDEX(i)           (HANDLE)MAKELONG(i, 0);

#define PSUIPAGEINSERT_GROUP_PARENT     0
#define PSUIPAGEINSERT_PCOMPROPSHEETUI  1
#define PSUIPAGEINSERT_PFNPROPSHEETUI   2
#define PSUIPAGEINSERT_PROPSHEETPAGE    3
#define PSUIPAGEINSERT_HPROPSHEETPAGE   4
#define PSUIPAGEINSERT_DLL              5
#define MAX_PSUIPAGEINSERT_INDEX        5


#define INSPSUIPAGE_MODE_BEFORE         0
#define INSPSUIPAGE_MODE_AFTER          1
#define INSPSUIPAGE_MODE_FIRST_CHILD    2
#define INSPSUIPAGE_MODE_LAST_CHILD     3
#define INSPSUIPAGE_MODE_INDEX          4


typedef struct _INSERTPSUIPAGE_INFO {
    WORD        cbSize;
    BYTE        Type;
    BYTE        Mode;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    ULONG_PTR   dwData3;
    } INSERTPSUIPAGE_INFO, *PINSERTPSUIPAGE_INFO;


//
// for the CPSFUNC_SET_HSTARTPAGE
//

#define SSP_TVPAGE          10000
#define SSP_STDPAGE1        10001
#define SSP_STDPAGE2        10002

typedef LONG_PTR (CALLBACK *PFNCOMPROPSHEET)(HANDLE hComPropSheet,
                                             UINT   Function,
                                             LPARAM lParam1,
                                             LPARAM lParam2);


typedef struct _PSPINFO {
    WORD            cbSize;
    WORD            wReserved;
    HANDLE          hComPropSheet;
    HANDLE          hCPSUIPage;
    PFNCOMPROPSHEET pfnComPropSheet;
    } PSPINFO, *PPSPINFO;

//
// PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam) macro retrieve a pointer to the
// PSPINFO data structure. the lParam must be the lParam passed to the
// WM_INITDIALOG, otherwise the system can failed
//

#define PPSPINFO_FROM_WM_INITDIALOG_LPARAM(lParam)  \
                (PPSPINFO)((LPBYTE)lParam + ((LPPROPSHEETPAGE)lParam)->dwSize)

//
// PSPINFO
//
//  This structure is used durning property sheet page's WM_INITDIALOG message.
//  At WM_INITDIALOG, the lParam is a pointer to the PROPSHEETPAGE, and
//  lParam field in the PROPSHEETPAGE is a pointer to the PSPINFO.  the
//  original lParam in the PROPSHEETPAGE is saved in the lParam field in the
//  PSPINFO data structure.
//
//  When process WM_INITDIALOG message, it should save the lParam (PSPINFO
//  structure pointer) for later to call common UI callback functions.
//
//
//  cbSize          - Size of this structure in bytes
//
//  wReserved       - Reserved, must be set to zero
//
//  hComPropSheet   - Handle to the parent page which is the hComPropSheet
//                    passed to the CPSFUNC_ADD_PROPSHEETPAGE
//
//  hCPSUIPage      - Handle to the this added common UI property sheet page.
//
//  pfnComPropSheet - Pointer to the common UI callback function, using this
//                    function pointer to do CPSFUNC_xxxx
//
//

typedef struct _CPSUIDATABLOCK {
    DWORD   cbData;
    LPBYTE  pbData;
    } CPSUIDATABLOCK, *PCPSUIDATABLOCK;


#d