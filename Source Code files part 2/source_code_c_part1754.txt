1\NT\sdktools\mep\browser\bscdump\bscdump.h ===
/*** bscdump.h
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*	28-Jul-1989 dw	Removed extraneous defs of TRUE, FALSE
*       05-Jul-1989 mt  Added the option to list redundant symbols
*
*************************************************************************/
#define BUFLEN		251
#define EXTERNAL	near

typedef char	flagType;
typedef char	buffer[BUFLEN];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bsc\wild.c ===
// wild.c
//
// wildcard file matching
//
//
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"

BOOL BSC_API
FWildMatch(LSZ pchPat, LSZ pchText)
// return TRUE if pchText matchs pchPat in the dos wildcard sense
//
// REVIEW for 1.2 file name support
//
{
    for (;;) {
	switch (*pchPat) {
	case '\0':
	    return *pchText == '\0';

	case '.':
	    pchPat++;
	    switch (*pchText) {
	    case '.':
		pchText++;
		break;

	    case '\0':
		break;

	    default:
		return FALSE;
	    }
	    break;

	case '*':
	    pchPat++;
	    while (*pchText != '\0' && *pchText != '.')
		pchText++;
	    while (*pchPat != '\0' && *pchPat != '.')
		pchPat++;
	    break;

	case '?':
	    pchPat++;
	    if (*pchText != '\0' && *pchText != '.')
		pchText++;
	    break;

	default:
	    if (*pchText != *pchPat)
		return FALSE;
	    pchPat++;
	    pchText++;
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\inc\bsc.h ===
// bsc.h
//

#include <stdarg.h>

#define BSC_API far

#if defined (OS2)
typedef int FILEHANDLE;
typedef int FILEMODE;
#else
typedef HANDLE FILEHANDLE;
typedef DWORD  FILEMODE;
#endif

//////////////////////////////////////////////////////////////////////
// you must define the following callbacks for the library to use
// to avoid dependancy on the C standard io library.  If you don't
// define these then you accept the defaults which call C runtime
//

// malloc and free workalikes

LPV  BSC_API LpvAllocCb(WORD cb);
VOID BSC_API FreeLpv(LPV lpv);

// open, read, close, seek workalikes

FILEHANDLE  BSC_API BSCOpen(LSZ lszFileName, FILEMODE mode);
int         BSC_API BSCRead(FILEHANDLE handle, LPCH lpchBuf, WORD cb);
int         BSC_API BSCSeek(FILEHANDLE handle, long lPos, FILEMODE mode);
int         BSC_API BSCClose(FILEHANDLE handle);


// ascii text output routine

VOID BSC_API BSCOutput(LSZ lsz);

#ifdef DEBUG
VOID BSC_API BSCDebugOut(LSZ lsz);
VOID BSC_API BSCDebug(LSZ lszFormat, ...);
#endif

// error handling routines
//
VOID BSC_API SeekError(LSZ lszFileName);	// (may choose to not return)
VOID BSC_API ReadError(LSZ lszFileName);	// (may choose to not return)
VOID BSC_API BadBSCVer(LSZ lszFileName);	// (may choose to not return)

// end of callbacks
//
///////////////////////////////////////////////////////////////////////

// an IDX is guaranteed to be big enough to hold any of the 
// database index types, i.e. it is a generic index

typedef DWORD IDX;

#define  idxNil 0xffffffffL
#define isymNil 0xffffL
#define imodNil 0xffffL

// definition and prototypes for use with the bsc library
//
typedef WORD IMOD;
typedef WORD IMS;
typedef WORD ISYM;
typedef WORD IINST;
typedef DWORD IREF;
typedef WORD IDEF;
typedef WORD IUSE;
typedef WORD IUBY;
typedef WORD TYP;
typedef WORD ATR;

//  Open the specified data base.
//  Return TRUE iff successful, FALSE if database can't be read
//
BOOL BSC_API FOpenBSC (LSZ lszName);

// close database and free as much memory as possible
//
VOID BSC_API CloseBSC(VOID);

// return the length of the largest symbol in the database
//
WORD BSC_API BSCMaxSymLen(VOID);

// is this database built with a case sensitive language?
//
BOOL BSC_API FCaseBSC(VOID);

// override the case sensitivity of the database, symbol lookups become
// case (in)sensistive as specified
//
VOID BSC_API SetCaseBSC(BOOL fCaseSensitive);

// do a case insenstive compare qualified by a case sensitive compare
// if fCase is true -- this is the order of symbols in the symbol list
int BSC_API CaseCmp(LSZ lsz1, LSZ lsz2);

// return the name of the given symbol
//
LSZ BSC_API LszNameFrSym (ISYM isym);

// return the name of the given module
//
LSZ BSC_API LszNameFrMod (IMOD imod);

// return the imod with the given name -- imodNil if none
//
IMOD BSC_API ImodFrLsz(LSZ lszModName);

// return the isym with the given name -- isymNil if none
//
ISYM BSC_API IsymFrLsz(LSZ lszSymName);

// return the biggest isym in this database, isyms run from 0 to this value - 1
//
ISYM BSC_API IsymMac(VOID);

// return the biggest imod in this database, imods run from 0 to this value - 1
//
IMOD BSC_API ImodMac(VOID);

// return the biggest iinst in this database, iinsts run from 0 to the value -1
IINST BSC_API IinstMac(VOID);

// fill in the range of MS items valid for this module
//
VOID BSC_API MsRangeOfMod(IMOD imod, IMS far *pimsFirst, IMS far *pimsLast);

// give the instance index of the module symbol (MS)
//
IINST BSC_API IinstOfIms(IMS ims);

// fill in the range of inst values for this symbol
//
VOID BSC_API InstRangeOfSym(ISYM isym, IINST far *piinstFirst, IINST far *piinstLast);

// get the information that qualifies this instance
//
VOID BSC_API InstInfo(IINST iinst, ISYM far *pisymInst, TYP far *typ, ATR far *atr);

// fill in the reference ranges from the inst
//
VOID BSC_API RefRangeOfInst(IINST iinst, IREF far *pirefFirst, IREF far *pirefLast);

// fill in the definition ranges from the inst
//
VOID BSC_API DefRangeOfInst(IINST iinst, IDEF far *pidefFirst, IDEF far *pidefLast);

// fill in the use ranges from the inst
//
VOID BSC_API UseRangeOfInst(IINST iinst, IUSE far *piuseFirst, IUSE far *piuseLast);

// fill in the used by ranges from the inst
//
VOID BSC_API UbyRangeOfInst(IINST iinst, IUBY far *piubyFirst, IUBY far *piubyLast);

// fill in the information about this things which an inst uses
//
VOID BSC_API UseInfo(IUSE iuse, IINST far *piinst, WORD far *pcnt);

// fill in the information about this things which an inst is used by
//
VOID BSC_API UbyInfo(IUBY iuby, IINST far *piinst, WORD far *pcnt);

// fill in the information about this reference
//
VOID BSC_API RefInfo(IREF iref, LSZ far *plszName, WORD far *pline);

// fill in the information about this definition
//
VOID BSC_API DefInfo(IDEF idef, LSZ far *plszName, WORD far *pline);

// these are the bit values for the InstInfo() TYP and ATR types
//
//

// this is the type part of the field, it describes what sort of object
// we are talking about.  Note the values are sequential -- the item will
// be exactly one of these things
//
        
#define INST_TYP_FUNCTION    0x01
#define INST_TYP_LABEL       0x02
#define INST_TYP_PARAMETER   0x03
#define INST_TYP_VARIABLE    0x04
#define INST_TYP_CONSTANT    0x05
#define INST_TYP_MACRO       0x06
#define INST_TYP_TYPEDEF     0x07
#define INST_TYP_STRUCNAM    0x08
#define INST_TYP_ENUMNAM     0x09
#define INST_TYP_ENUMMEM     0x0A
#define INST_TYP_UNIONNAM    0x0B
#define INST_TYP_SEGMENT     0x0C
#define INST_TYP_GROUP       0x0D

// this is the attribute part of the field, it describes the storage
// class and/or scope of the instance.  Any combination of the bits
// might be set by some language compiler, but there are some combinations
// that done make sense.

#define INST_ATR_LOCAL       0x001
#define INST_ATR_STATIC      0x002
#define INST_ATR_SHARED      0x004
#define INST_ATR_NEAR        0x008
#define INST_ATR_COMMON      0x010
#define INST_ATR_DECL_ONLY   0x020
#define INST_ATR_PUBLIC      0x040
#define INST_ATR_NAMED       0x080
#define INST_ATR_MODULE      0x100

// simple minded printf replacements, only %d, %s supported -- SMALL

VOID BSC_API BSCFormat(LPCH lpchOut, LSZ lszFormat, va_list va);
VOID BSC_API BSCSprintf(LPCH lpchOut, LSZ lszFormat, ...);
VOID BSC_API BSCPrintf(LSZ lszFormat, ...);


//  rjsa 10/22/90
//  Some runtime library functions are broken, so intrinsics have
//  to be used.
//	BUGBUG
//#pragma intrinsic (memset, memcpy, memcmp)
//#pragma intrinsic (strset, strcpy, strcmp, strcat, strlen)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\inc\bscsup.h ===
// bscsup.h
//
// BSC high level support functions
//

VOID BSC_API StatsBSC(VOID);	// ascii dump of bsc statistics
VOID BSC_API DumpBSC(VOID);		// ascii dump of the .bsc file
VOID BSC_API DumpInst(IINST iinst);	// ascii dump of single inst (name + flags)
LSZ  BSC_API LszTypInst(IINST iinst); // ascii version of iinst type

VOID BSC_API CallTreeInst (IINST iinst);	// call tree from given inst
BOOL BSC_API FCallTreeLsz(LSZ lszName);	// call tree from given name

VOID BSC_API RevTreeInst (IINST iinst);	// reverse call tree from given inst
BOOL BSC_API FRevTreeLsz(LSZ lszName);	// reverse call tree from given name

// Browse OBject

typedef DWORD BOB;

#define bobNil 0L

typedef WORD CLS;

#define clsMod  1
#define clsInst 2
#define clsRef  3
#define clsDef  4
#define clsUse  5
#define clsUby  6 
#define clsSym	7

#define BobFrClsIdx(cls, idx)  ((((long)(cls)) << 24) | (idx))
#define ClsOfBob(bob)   (CLS)((bob) >> 24)

#define ImodFrBob(bob)	((IMOD)(bob))
#define IinstFrBob(bob)	((IINST)(bob))
#define IrefFrBob(bob)	((IREF)((bob) & 0xffffffL))
#define IdefFrBob(bob)	((IDEF)(bob))
#define IuseFrBob(bob)	((IUSE)(bob))
#define IubyFrBob(bob)	((IUBY)(bob))
#define IsymFrBob(bob)	((ISYM)(bob))

#define BobFrMod(x)  (BobFrClsIdx(clsMod,  (x)))
#define BobFrSym(x)  (BobFrClsIdx(clsSym,  (x)))
#define BobFrInst(x) (BobFrClsIdx(clsInst, (x)))
#define BobFrRef(x)  (BobFrClsIdx(clsDef,  (x)))
#define BobFrDef(x)  (BobFrClsIdx(clsRef,  (x)))
#define BobFrUse(x)  (BobFrClsIdx(clsUse,  (x)))
#define BobFrUby(x)  (BobFrClsIdx(clsUby,  (x)))

// these are the query types
//
typedef enum _qy_ {
    qyFiles, qySymbols, qyContains,
    qyCalls, qyCalledBy, qyUses, qyUsedBy,
    qyUsedIn, qyDefinedIn,
    qyDefs, qyRefs
} QY;

// these are visible so that you can see how the query is progressing
// you may not write on these -- these values may or may not have anything
// to do with any database indices
//

extern IDX far idxQyStart;
extern IDX far idxQyCur;
extern IDX far idxQyMac;

BOOL BSC_API InitBSCQuery (QY qy, BOB bob);
BOB  BSC_API BobNext(VOID);

LSZ  BSC_API LszNameFrBob(BOB bob);
BOB  BSC_API BobFrName(LSZ lsz);

// these are the instance types you can filter on
// they are called MBF's for historical reasons which are not clear to me
//

typedef WORD MBF;

// these may be or'd together

#define mbfNil    0
#define mbfVars   1
#define mbfFuncs  2
#define mbfMacros 4
#define mbfTypes  8
#define mbfAll    15

BOOL BSC_API FInstFilter (IINST iinst, MBF mbf);

// show outline for the given files (by imod, or by Pattern)
//
VOID BSC_API OutlineMod(IMOD imod, MBF mbfReqd);
BOOL BSC_API FOutlineModuleLsz (LSZ lszPattern, MBF mbfReqd);
LSZ  BSC_API LszBaseName(LSZ lsz);

// list references for all symbols meeting the mbf requirement
//
BOOL BSC_API ListRefs (MBF mbfReqd);

// DOS style wildcard matching
//
BOOL BSC_API FWildMatch(LSZ lszPat, LSZ lszText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\bscdump\thunk.c ===
// calback.c
//
// these are the default callbacks for the library
//
#include <string.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <io.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif

#include <dos.h>

#include "hungary.h"
#include "bsc.h"

typedef char bscbuf[2048];

// you must define the following callbacks for the library to use

LPV BSC_API LpvAllocCb(WORD cb)
// allocate a block of memory
//
{
    return malloc(cb);
}

VOID BSC_API FreeLpv(LPV lpv)
// free a block of memory
//
{
    free(lpv);
}

VOID BSC_API SeekError(LSZ lszFileName)	// do not return!
// error handling
//
{
    BSCPrintf("BSC Library: Error seeking in file '%s'\n", lszFileName);
    exit(1);
}

VOID BSC_API ReadError(LSZ lszFileName)	// do not return!
// error handling 
//
{
    BSCPrintf("BSC Library: Error reading in file '%s'\n", lszFileName);
    exit(1);
}

VOID BSC_API BadBSCVer(LSZ lszFileName)	// do not return!
// error handling 
//
{
    BSCPrintf("BSC Library: '%s' not in current .bsc format\n", lszFileName);
    exit(1);
}

FILEHANDLE BSC_API
BSCOpen(LSZ lszFileName, FILEMODE mode)
// open the specified file
//
{
#if defined (OS2)
    bscbuf b;
    strcpy(b, lszFileName);
    return open(b, mode);
#else
    return OpenFile( lszFileName, mode, FALSE, FILE_SHARE_READ);
#endif

}

int BSC_API
BSCRead(FILEHANDLE handle, LPCH lpchBuf, WORD cb)
// read in the specified number of bytes
//
{
#if defined (OS2)
	bscbuf b;

	while (cb > sizeof(b)) {
		if (read(handle, b, sizeof(b)) == -1) return -1;
                memcpy(lpchBuf, b, sizeof(b));
		cb -= sizeof(b);
		lpchBuf += sizeof(b);
	}

	if (read(handle, b, cb) == -1) return -1;
        memcpy(lpchBuf, b, cb);
    return cb;
#else
    return ReadFile(handle, lpchBuf, cb);
#endif

}

int BSC_API
BSCClose(FILEHANDLE handle)
// close the specified handle
//
{
#if defined (OS2)
    return close(handle);
#else
    return !CloseHandle( handle );
#endif

}

int BSC_API
BSCSeek(FILEHANDLE handle, long lPos, FILEMODE mode)
//  seek on the specified handle
//
{
#if defined (OS2)
    if (lseek(handle, lPos, mode) == -1)
		return -1;
	else
                return 0;
#else
    if (SetFilePointer( handle, lPos, 0L, mode) == -1) {
        return -1;
    } else {
        return 0;
    }
#endif

}

VOID BSC_API
BSCOutput(LSZ lsz)
// write the given string to the standard output
//
{
    bscbuf b;
	int cb;

    cb = strlen(lsz);

	while (cb > sizeof(b)) {
        memcpy(b, lsz, sizeof(b));

    	if (write(1, b, sizeof(b)) == -1) return;
		
		cb -= sizeof(b);
		lsz += sizeof(b);
	}
    
    memcpy(b, lsz, cb);
    write(1, b, cb);
	return;
}

#ifdef DEBUG
VOID BSC_API
BSCDebugOut(LSZ lsz)
// ignore debug output by default
//
{
    // unreferenced lsz
    lsz = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\inc\hungary.h ===
// instant hungarian

// base types
//

// #define FAR far
// #define NEAR near

// #define TRUE  1
// #define FALSE 0

// typedef void            VOID;
// typedef unsigned char   BYTE;
// typedef unsigned short  WORD;
// typedef int             INT;
// typedef unsigned long   DWORD;
// typedef long            LONG;
// typedef unsigned short  BOOL;

//typedef USHORT  WORD;
//typedef ULONG   DWORD;

// pointer types
//
typedef char NEAR *	SZ;
typedef char FAR  *	LSZ;
typedef void FAR  *	LPV;
typedef BYTE FAR  *	LPB;
//typedef char FAR  * LPCH;

#define API NEAR pascal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\inc\mbrcache.h ===
#define MAXATOMPAGETBL	32		/* # of Cache Pages	*/
#define ATOMALLOC	512		/* Atom Cache page size */

typedef struct pgetlb {
	unsigned	uPage;		/* Cache page		*/
	char far *	pfAtomCache;	/* Atom Cache loc	*/
	} CACHEPAGE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\inc\sbrbsc.h ===
#define BSC_MAJ  1
#define BSC_MIN  0
#define BSC_UPD  4

#pragma pack(1)

typedef struct {
	WORD ModName;			// module name symbol index */
	WORD mSymEnd;			// last  ModSym index */
} MODLIST;

typedef struct {
	WORD ModSymProp;		// sym 1st property index */
} MODSYMLIST;

typedef struct {
	WORD PropEnd;			// last  Property index */
	WORD Atom;			// Atom cache sym idx	*/
	WORD Page;			// Atom cache sym page	*/
} SYMLIST;

typedef struct {
	WORD	PropName;		// owner name symbol index
	WORD	PropAttr;		// Property attribute
	WORD	DefEnd; 		// last	Definition index
	DWORD	RefEnd; 		// last  Reference  index
	WORD	CalEnd; 		// last  Calls/uses index
	WORD	CbyEnd; 		// last  Calld/used index
} PROPLIST;

typedef struct {
	WORD RefNam;			// file name symbol index
	WORD RefLin;			// reference line number
	WORD isbr;			// sbr file this item is found in
} REFLIST;

typedef struct {
	WORD UseProp;			// symbol called/used (by)
	BYTE UseCnt;			// symbol called/used (by) cnt
	WORD isbr;			// sbr file this item is found in
} USELIST;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\casts.h ===
/*  casts.h - define useful casts for calling DOS 5 API routines
**
*/

#define     FALSE   0
#define     TRUE    1

typedef unsigned char	    byte;
typedef unsigned int	    word;
typedef unsigned long	    dword;

typedef char *		    NPC;
typedef int  *		    NPI;
typedef long *		    NPL;
typedef unsigned int *	    NPU;
typedef unsigned long *     NPUL;

typedef char far *	    FPC;
typedef int  far *	    FPI;
typedef long far *	    FPL;
typedef unsigned int far *  FPU;
typedef unsigned long far * FPUL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\inc\sbrvers.h ===
/*
 * use double macro level to force rup to be turned into string representation
 */
#define VERS(x,y,z)  VERS2(x,y,z)
#define VERS2(x,y,z) " Version " #x "." #y "." #z

#define CPYRIGHT "\nCopyright (c) Microsoft Corp 1990. All rights reserved.\n\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\errors.h ===
#define WARN_UNKNOWN_WARNING	0
#define WARN_OPTION_IGNORED	1
#define WARN_SBR_TRUNC		2

#define ERR_UNKNOWN_ERROR	0
#define ERR_UNKNOWN_OPTION	1
#define ERR_MISSING_OPTION	2
#define ERR_WRITE_FAILED	3
#define ERR_SEEK_FAILED		4
#define ERR_READ_FAILED		5
#define ERR_OPEN_FAILED		6
#define ERR_TEMP_FAILED		7
#define ERR_DELETE_FAILED	8
#define ERR_OUT_OF_MEMORY	9
#define ERR_SBR_CORRUPT		10
#define ERR_BAD_RESPONSE	11
#define ERR_CAPACITY_EXCEEDED	12
#define ERR_NO_INCREMENTAL	13
#define ERR_ALL_SBR_TRUNC	14
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\dcodesbr.c ===
//
//
// DCODESBR.C -	dumps a human readable version of the current .sbr file
//		record from the r_... variables
//		
//

#include "sbrfdef.h"
#include "mbrmake.h"

char	* near prectab[] = {
		"HEADER",		// SBR_REC_HEADER
		"MODULE",		// SBR_REC_MODULE
		"LINDEF",		// SBR_REC_LINDEF
		"SYMDEF",		// SBR_REC_SYMDEF
		"SYMREFUSE",		// SBR_REC_SYMREFUSE
		"SYMREFSET",		// SBR_REC_SYMREFSET
		"MACROBEG",		// SBR_REC_MACROBEG
		"MACROEND",		// SBR_REC_MACROEND
		"BLKBEG",		// SBR_REC_BLKBEG
		"BLKEND",		// SBR_REC_BLDEND
		"MODEND",		// SBR_REC_MODEND
		"OWNER"			// SBR_REC_OWNER
};

char	* near plangtab[] = {
		"UNDEF",		// SBR_L_UNDEF
		"BASIC",		// SBR_L_BASIC
		"C",			// SBR_L_C
		"FORTRAN",		// SBR_L_FORTRAN
		"MASM",			// SBR_L_MASM
		"PASCAL",		// SBR_L_PASCAL
		"COBOL"			// SBR_L_COBOL
};

char	* near ptyptab[] = {
		"UNDEF",		// SBR_TYP_UNKNOWN
		"FUNCTION",		// SBR_TYP_FUNCTION
		"LABEL",		// SBR_TYP_LABEL
		"PARAMETER",		// SBR_TYP_PARAMETER
		"VARIABLE",		// SBR_TYP_VARIABLE
		"CONSTANT",		// SBR_TYP_CONSTANT
		"MACRO",		// SBR_TYP_MACRO
		"TYPEDEF",		// SBR_TYP_TYPEDEF
		"STRUCNAM",		// SBR_TYP_STRUCNAM
		"ENUMNAM",		// SBR_TYP_ENUMNAM
		"ENUMMEM",		// SBR_TYP_ENUMMEM
		"UNIONNAM",		// SBR_TYP_UNIONNAM
		"SEGMENT",		// SBR_TYP_SEGMENT
		"GROUP",		// SBR_TYP_GROUP
		"PROGRAM"		// SBR_TYP_PROGRAM
};

char	* near patrtab[] = {
		"LOCAL",		// SBR_ATR_LOCAL
		"STATIC",		// SBR_ATR_STATIC
		"SHARED",		// SBR_ATR_SHARED
		"NEAR", 		// SBR_ATR_NEAR
		"COMMON",		// SBR_ATR_COMMON
		"DECL_ONLY",		// SBR_ATR_DECL_ONLY
		"PUBLIC",		// SBR_ATR_PUBLIC
		"NAMED",		// SBR_ATR_NAMED
		"MODULE",		// SBR_ATR_MODULE
		"?", "?"		// reserved for expansion
};

VOID
DecodeSBR ()
{
    int     i;
    static indent;

    switch(r_rectyp) {
	case SBR_REC_MACROEND:
	case SBR_REC_BLKEND:
	case SBR_REC_MODEND:
	    indent--;
	    break;

	case SBR_REC_HEADER:
	case SBR_REC_MODULE:
	case SBR_REC_LINDEF:
	case SBR_REC_SYMDEF:
	case SBR_REC_SYMREFUSE:
	case SBR_REC_SYMREFSET:
	case SBR_REC_MACROBEG:
	case SBR_REC_BLKBEG:
	case SBR_REC_OWNER:
	    break;

	default:
	    fprintf(streamOut, "invalid record type %0xh", r_rectyp);
	    SBRCorrupt("");
	    return;
    }

    for (i = indent; i; i--)
	fprintf (streamOut, " ");

    fprintf (streamOut, "%s: (", prectab[r_rectyp]);

    switch(r_rectyp) {

    case SBR_REC_HEADER:
	fprintf (streamOut, "%1d:%1d (%s) %1d)",
		r_majv, r_minv, plangtab[r_lang], r_fcol);
	fprintf (streamOut, " in %s", r_cwd);
	break;

    case SBR_REC_MODULE:
	fprintf (streamOut, "%s", r_bname);
	indent++;
	break;

    case SBR_REC_LINDEF:
	fprintf (streamOut, "%d", r_lineno);
	break;

    case SBR_REC_SYMDEF:
	{
	WORD attr, type;

	type = (r_attrib & SBR_TYPMASK) >> SBR_TYPSHIFT;
	attr = (r_attrib & SBR_ATRMASK) >> SBR_ATRSHIFT;

	fprintf (streamOut, "%s", ptyptab[type]);

	for (i = 0 ; i < SBR_ATRBITS; i++)
	    if (attr & (1 << i))
		fprintf (streamOut, "|%s", patrtab[i]);

	fprintf (streamOut, " o:%d %s", r_ordinal, r_bname);
	}
	break;

    case SBR_REC_SYMREFUSE:
    case SBR_REC_SYMREFSET:
    case SBR_REC_OWNER:
	fprintf (streamOut, "o:%d", r_ordinal);
	break;

    case SBR_REC_MACROBEG:
    case SBR_REC_BLKBEG:
	indent++;
	break;
    }
    fprintf (streamOut, ")\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\inc\sbrfdef.h ===
// sdbfdef.h    Source Browser .SBR file definitions

#define S_EOF		    255

#define SBR_L_UNDEF         0       	// Undefined
#define SBR_L_BASIC         1       	// Basic
#define SBR_L_C             2       	// C
#define SBR_L_FORTRAN       3       	// Fortran
#define SBR_L_MASM          4       	// MASM
#define SBR_L_PASCAL        5       	// Pascal
#define SBR_L_COBOL         6       	// Cobol 

#define SBR_REC_HEADER      0x00	// Header            
#define SBR_REC_MODULE      0x01	// Module definition 
#define SBR_REC_LINDEF      0x02	// Line Number       
#define SBR_REC_SYMDEF      0x03	// Symbol Definition 
#define SBR_REC_SYMREFUSE   0x04	// Symbol Reference  
#define SBR_REC_SYMREFSET   0x05	// Symbol Ref and assign
#define SBR_REC_MACROBEG    0x06	// Macro Start 
#define SBR_REC_MACROEND    0x07	// Macro End
#define SBR_REC_BLKBEG      0x08	// Block Start
#define SBR_REC_BLKEND      0x09	// Block End
#define SBR_REC_MODEND      0x0A	// Module End
#define SBR_REC_OWNER	    0x0B	// Set owner of current block


// Column information is no longer supported in PWB 1.00 (ignored if present)

#define SBR_REC_NOCOLUMN    1       	// Missing column default 1

#define SBR_TYPBITS	    5
#define SBR_TYPSHIFT        11
#define SBR_TYPMASK         (0x1f << SBR_TYPSHIFT)
        
#define SBR_TYP_FUNCTION    (0x01 << SBR_TYPSHIFT)
#define SBR_TYP_LABEL       (0x02 << SBR_TYPSHIFT)
#define SBR_TYP_PARAMETER   (0x03 << SBR_TYPSHIFT)
#define SBR_TYP_VARIABLE    (0x04 << SBR_TYPSHIFT)
#define SBR_TYP_CONSTANT    (0x05 << SBR_TYPSHIFT)
#define SBR_TYP_MACRO       (0x06 << SBR_TYPSHIFT)
#define SBR_TYP_TYPEDEF     (0x07 << SBR_TYPSHIFT)
#define SBR_TYP_STRUCNAM    (0x08 << SBR_TYPSHIFT)
#define SBR_TYP_ENUMNAM     (0x09 << SBR_TYPSHIFT)
#define SBR_TYP_ENUMMEM     (0x0A << SBR_TYPSHIFT)
#define SBR_TYP_UNIONNAM    (0x0B << SBR_TYPSHIFT)
#define SBR_TYP_SEGMENT     (0x0C << SBR_TYPSHIFT)
#define SBR_TYP_GROUP       (0x0D << SBR_TYPSHIFT)
#define SBR_TYP_PROGRAM	    (0x0E << SBR_TYPSHIFT)

#define SBR_ATRBITS	    11
#define SBR_ATRSHIFT        0
#define SBR_ATRMASK         (0x3ff << SBR_ATRSHIFT)

#define SBR_ATR_LOCAL       (0x001 << SBR_ATRSHIFT)
#define SBR_ATR_STATIC      (0x002 << SBR_ATRSHIFT)
#define SBR_ATR_SHARED      (0x004 << SBR_ATRSHIFT)
#define SBR_ATR_NEAR        (0x008 << SBR_ATRSHIFT)
#define SBR_ATR_COMMON      (0x010 << SBR_ATRSHIFT)
#define SBR_ATR_DECL_ONLY   (0x020 << SBR_ATRSHIFT)
#define SBR_ATR_PUBLIC      (0x040 << SBR_ATRSHIFT)
#define SBR_ATR_NAMED       (0x080 << SBR_ATRSHIFT)
#define SBR_ATR_MODULE      (0x100 << SBR_ATRSHIFT)

#define SBR_VER_MAJOR       1       /* Major version */
#define SBR_VER_MINOR       1       /* Minor version */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\convert.c ===
// filename conversion/canonicalization facility
//

#include "mbrmake.h"
#include <string.h>
#include <ctype.h>

LSZ ToCanonPath(LSZ lszPath, LSZ lszCwd, LSZ lszCanon);
VOID ToRelativePath(LSZ lszPath, LSZ lszCwd);
VOID ToBackSlashes(LSZ lsz);

#ifdef STANDALONE

#include <stdio.h>
main()
{
    static char s[PATH_BUF];
    static char canon[PATH_BUF];
    static char cwd[PATH_BUF];

    getcwd(cwd, PATH_BUF);
    printf("Current Dir is %s\n", cwd);
    printf("Canonical path?\n");
    gets(canon);
    while (gets(s)) {
	    printf("%s\n", ToCanonPath(s, cwd, canon));
    }
}

#endif

LSZ
ToCanonPath(LSZ lszPath, LSZ lszCwd, LSZ lszCanon)
// canonicalize the given path
//
{
    LSZ p;
    static char buf[PATH_BUF];

    strcpy(buf, lszPath);

    ToBackSlashes(buf);

    if (buf[0] == 0 || buf[0] == '\\' || buf[0] == '<')
	    return buf;

    if (buf[1] == ':') {
	    // different drive is assumed invariant
	    if (buf[0] != lszCwd[0] || '\\' == buf[2])
		    return buf;

	    strcpy(buf, lszCwd);
	    strcat(buf, "/");
	    strcat(buf, lszPath+2);
    }
    else {
	    strcpy(buf, lszCwd);
	    strcat(buf, "/");
	    strcat(buf, lszPath);
    }

    ToBackSlashes(buf);

    p = buf;
    for (;;) {
	p = strchr(p, '\\');
	if (!p) {
		ToRelativePath(buf, lszCanon);
		return buf;
	}

	switch (p[1]) {

	case '\0':
	    *p = 0;
	    ToRelativePath(buf, lszCanon);
	    return buf;

	case '\\':
	    strcpy(p, p+1);
	    break;

	case '.':

	    if (p[2] == '\\' || p[2] == 0) {
		strcpy(p, p+2);
		break;
	    }
	    if (p[2] == '.' && (p[3] == '\\' || p[3] == 0)) {
		LSZ s;

		s = p;

		while (--s >= buf) {
		    if (*s == '\\') {
			strcpy(s+1,p+3);
			p = s;
			break;
		    }
		}

		if (s < buf)
			p++;
	    }
	    break;

	default:
	    p++;
	}
    }
}

VOID
ToRelativePath(LSZ lszPath, LSZ lszCwd)
// convert absolute path to relative
//
{
    WORD ich, ichOK;
    int c1, c2;
    char buf[PATH_BUF];

    ich = ichOK = 0;

    for (ich = 0; lszPath[ich] && lszCwd[ich]; ich++) {

	c1 = lszPath[ich];
	c2 = lszCwd[ich];

	if (c1 == c2)  {
	    if (c1 == '\\') ichOK = ich+1;
	    continue;
	}

	if (isupper(c1) && islower(c2) && tolower(c1) == c2)
	    continue;

	if (isupper(c2) && islower(c1) && tolower(c2) == c1)
	    continue;

	break;
    }

    if (ich == 0)	// not on the same drive, we can't do the conversion
	return;

    if (lszCwd[ich] == 0 && lszPath[ich] == '\\') {
	ichOK = ich+1;
	c2 = 0;
    }
    else {
	c2 = 1;
	c1 = ichOK;
	for (c1 = ichOK; lszCwd[c1]; c1++)
	    if (lszCwd[c1] == '\\') 
		c2++;
    }

    buf[0] = 0;
    for (c1 = 0; c1 < c2; c1++)
	strcat(buf, "..\\");

    strcat(buf, lszPath+ichOK);
    strcpy(lszPath, buf);
}

LSZ
ToAbsPath(LSZ lszPath, LSZ lszCwd)
// canonicalize the given path
//
{
    LSZ p;
    static char buf[PATH_BUF];

    strcpy(buf, lszPath);

    ToBackSlashes(buf);

    if (buf[0] == '<')
	    return buf;

    if (buf[0] == 0) {
	strcpy(buf, lszCwd);
	ToBackSlashes(lszCwd);
	return buf;
    }

    if (buf[0] == '\\') {
	buf[0] = lszCwd[0];
	buf[1] = ':';
	strcpy(buf+2, lszPath);
	ToBackSlashes(buf);
	return buf;
    }

    if (buf[1] == ':') {
	// different drive is assumed invariant
	if (buf[0] != lszCwd[0] || buf[2] == '\\')
	    return buf;

	strcpy(buf, lszCwd);
	strcat(buf, "/");
	strcat(buf, lszPath+2);
    }
    else {
	strcpy(buf, lszCwd);
	strcat(buf, "/");
	strcat(buf, lszPath);
    }

    ToBackSlashes(buf);

    p = buf;
    for (;;) {
	p = strchr(p, '\\');
	if (!p) return buf;

	switch (p[1]) {

	case '\0':
	    *p = 0;
	    return buf;

	case '\\':
	    strcpy(p, p+1);
	    break;

	case '.':

	    if (p[2] == '\\' || p[2] == 0) {
		strcpy(p, p+2);
		break;
	    }
	    if (p[2] == '.' && (p[3] == '\\' || p[3] == 0)) {
		LSZ s;

		s = p;

		while (--s >= buf) {
		    if (*s == '\\') {
			strcpy(s+1,p+3);
			p = s;
			break;
		    }
		}

		if (s < buf)
		    p++;
	    }
	    break;

	default:
	    p++;
	}
    }
}

VOID
ToBackSlashes(LSZ lsz)
// convert forward slashes to backslashes
//
{
    while (*lsz) {
	if (*lsz == '/') *lsz = '\\';
	lsz ++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\addtolst.c ===
//
// ADDTOLST.C - Add each record from the .SBR file to the approprate list.
//

#define LINT_ARGS

#include "sbrfdef.h"
#include "mbrmake.h"
#include <ctype.h>

// local types

typedef struct _mstk {
	struct  _mstk FAR *pmstkPrev;		// next module stack entry	
	VA	vaCurMod;			// saved current module 
	BOOL	fDupMod;			// saved dup module flag
	BOOL	fExclMod;			// saved exclude module flag
} MSTK, FAR * PMSTK;

typedef struct _bstk {
	struct _bstk FAR *pbstkPrev;		// next block stack entry
	VA 	vaOwnerProp;			// saved current owner
} BSTK, FAR * PBSTK;

// static variables

BOOL	near fDupSym	 = FALSE;		// TRUE if adding duplicate atom
BOOL	near cMacroDepth = 0;			// depth of MACROBEG records
WORD	near ModCnt;				// count of modules
WORD	near isbrCur;				// current SBR file index

VA	near vaUnknownSym = vaNil;		// Unknown symbol
VA	near vaUnknownMod = vaNil;		// Unknown module

static VA   near vaOwnerProp = vaNil;		// ptr to current procedure 
static BOOL near fDupMod   = FALSE;		// duplicate module
static BOOL near fExclMod  = FALSE;		// exclude this module
static BOOL near fFirstMod = TRUE;		// this is 1st module of file

static PMSTK pmstkRoot;				// root of module stack
static PBSTK pbstkRoot;				// root of block stack

// forward references

static BOOL FSkipMacro(void);
static VOID PushMstk(VOID);
static VOID PushBstk(VOID);
static VOID PopMstk(VOID);
static VOID PopBstk(VOID);
static VOID CheckStacksEmpty(VOID);

VOID
SBRCorrupt (char *psz)
// sbr file corrupt -- print message
//
{

#ifdef DEBUG
    printf("Info = %s\n", psz);
#else
    // to make /W3 happy
    psz;
#endif

    Error(ERR_SBR_CORRUPT, lszFName);
}

static VOID
PushMstk (VOID)
// stack the current module context -- occurs before SBR_REC_MODULE 
//
{
    PMSTK pmstk;

    pmstk = LpvAllocCb(sizeof(*pmstk));

    pmstk->vaCurMod	 = vaCurMod;		// current module
    pmstk->fDupMod	 = fDupMod;		// dup	   module
    pmstk->fExclMod	 = fExclMod;		// exclude module
    pmstk->pmstkPrev     = pmstkRoot;		// make stack links
    pmstkRoot            = pmstk;		// root <- new
}

static VOID
PushBstk (VOID)
// stack the current block context -- occurs before SBR_REC_BLKBEG
//
{
    PBSTK pbstk;

    pbstk = LpvAllocCb(sizeof(*pbstk));

    pbstk->vaOwnerProp	 = vaOwnerProp;		// current owner
    pbstk->pbstkPrev     = pbstkRoot;		// make stack links
    pbstkRoot            = pbstk;		// root <- new
}

static VOID
PopMstk (VOID)
// restore previous module context -- occurs on SBR_REC_MODEND
//
{
    PMSTK pmstk;

    if (pmstkRoot == NULL) {
#ifdef DEBUG
	SBRCorrupt("Module stack empty but MODEND was found");
#else
	SBRCorrupt("");
#endif
    }

    vaCurMod	  = pmstkRoot->vaCurMod;      // get previous current module
    fDupMod	  = pmstkRoot->fDupMod;       // get previous dup mod flag
    fExclMod	  = pmstkRoot->fExclMod;      // get previous excl mod flag

    pmstk         = pmstkRoot;
    pmstkRoot     = pmstkRoot->pmstkPrev;

    FreeLpv(pmstk);
}

static VOID
PopBstk (VOID)
// restore previous block context -- occurs on SBR_REC_BLKEND
//
{
    PBSTK pbstk;

    if (pbstkRoot == NULL) {
#ifdef DEBUG
	SBRCorrupt("Block stack empty but BLKEND was found");
#else
	SBRCorrupt("");
#endif
    }

    vaOwnerProp   = pbstkRoot->vaOwnerProp;    // get previous current proc

    pbstk         = pbstkRoot;
    pbstkRoot     = pbstkRoot->pbstkPrev;

    FreeLpv(pbstk);
}

static VOID
CheckStacksEmpty(VOID)
// check to make sure that both stacks are empty at the .sbr file EOF
//
{
    if (pmstkRoot != NULL) {
#ifdef DEBUG
	SBRCorrupt("Module stack not empty at EOF");
#else
	SBRCorrupt("");
#endif
    }

    if (pbstkRoot != NULL) {
#ifdef DEBUG
	SBRCorrupt("Block stack not empty at EOF");
#else
	SBRCorrupt("");
#endif
    }
}

BOOL
FInExcList (LSZ lszName)
// Is the module name in the exclude file list?
//	
{
    EXCLINK FAR * px;
    LSZ lszAbs;

    if (OptEs && !fFirstMod) {
	if (lszName[0] == '\0') return FALSE;

	if (lszName[0] == '/' || lszName[0] == '\\') return TRUE;
	if (lszName[1] == ':' && lszName[2] == '/') return TRUE;
	if (lszName[1] == ':' && lszName[2] == '\\') return TRUE;
    }

    px = pExcludeFileList;

    // this name is relative to the path given in the header file
    lszAbs = ToAbsPath(lszName, r_cwd);

    while (px) {
	if ((FWildMatch (px->pxfname, lszAbs)))
	    return TRUE;
	px = px->xnext;
    }
    return FALSE;
}

static BOOL
FSkipMacro()
// return TRUE if this record should be skipped given that we are inside
// of a macro definition  (i.e cMacroDepth is known to be non-zero)
//
{
    if (!OptEm)
	return FALSE;

    if ((r_rectyp == SBR_REC_BLKBEG) ||
	(r_rectyp == SBR_REC_BLKEND) ||
	(r_rectyp == SBR_REC_MACROEND))
	    return FALSE;

    return TRUE;
}

VOID
InstallSBR()
//  Read the next .sbr file and add all the defs/refs/cals/cbys etc to
//  the various lists
//
{
    WORD   nlen;

    VA vaCurSym;		// current   symbol
    VA vaProp;			// current property
    VA vaOrd;			// current property temp   

    BOOL fSymSet = FALSE;	// TRUE if symbol set reference 

    r_lineno = 0;

    fExclMod = FALSE;
    fFirstMod = TRUE;		// we haven't seen the first MODULE record yet

    vaUnknownSym = MbrAddAtom ("<Unknown>", TRUE);  // unknown module name

    if (vaUnknownMod == vaNil) {

	vaUnknownMod = VaAllocGrpCb(grpMod, sizeof(MOD));

	vaCurMod = vaUnknownMod;

	gMOD(vaCurMod).csyms = 0;
	cMOD.vaNameSym	= vaUnknownSym;
	pMOD(vaCurMod);

	gSYM(vaUnknownSym).vaFirstProp = vaCurMod; // store pointer back to MOD
	pSYM(vaUnknownSym);
	ModCnt++;
    }
    else
	fDupMod = (vaUnknownMod != 0);

    vaCurMod = vaUnknownMod;

    if (vaRootMod == vaNil)
	vaRootMod = vaCurMod;

    while (GetSBRRec() != S_EOF) {

	#ifdef DEBUG
	if (OptD & 1) DecodeSBR ();
	#endif

	if (cMacroDepth != 0) 	// skip SYMBOLS in macros if true
	    if (FSkipMacro ())
		continue;

	if (fExclMod) {
	    if ((r_rectyp == SBR_REC_MODULE) ||
		(r_rectyp == SBR_REC_SYMDEF) ||
		(r_rectyp == SBR_REC_MODEND)) {
			;
	    }
	    else
		continue;
	}

	switch(r_rectyp) {

	case SBR_REC_MODULE:
	    PushMstk ();		// save state

	    r_lineno = 0;		// reset line no.

	    fDupMod  = FALSE;		// go to a known state
	    fExclMod = FALSE;

	    if (fExclMod = FInExcList (r_bname)) {
		#ifdef DEBUG
		  if (OptD & 256)
			printf ("  module excluded = %s\n", r_bname);
		#endif
		vaCurMod = vaUnknownMod;
	    }
	    else if ((vaCurMod = VaSearchModule (r_bname)) != vaNil) {
		if (gMOD(vaCurMod).csyms == 0) {
		    fDupMod = TRUE;
		    #ifdef DEBUG
		    if (OptD & 256)
		        printf ("  module redef = %s\n", r_bname);
		    #endif
		}
		else {
		    cMOD.csyms = 0;
		    pMOD(vaCurMod);

		    #ifdef DEBUG
		    if (OptD & 256)
		        printf ("  module subst = %s\n", r_bname);
		    #endif
		}
	    }
	    else {
		SetVMClient(VM_ADD_MOD);
		ModCnt++;
		vaCurMod	   = VaAllocGrpCb(grpMod, sizeof(MOD));
		gMOD(vaCurMod);
		cMOD.vaFirstModSym = vaNil;
		cMOD.csyms	   = 0;
		cMOD.vaNameSym	   =
                        MbrAddAtom (ToCanonPath(r_bname, r_cwd, c_cwd), TRUE);
		cMOD.vaNextMod	   = vaRootMod;
		pMOD(vaCurMod);

		vaRootMod	   = vaCurMod;

		gSYM(cMOD.vaNameSym).vaFirstProp = vaCurMod; // ptr to MOD
		pSYM(cMOD.vaNameSym);

		SetVMClient(VM_MISC);
	    }

	    fFirstMod = FALSE;
	    break;

	case SBR_REC_LINDEF:
	    break;

	case SBR_REC_SYMDEF:

	    // if module is being excluded then just make the ord and prop entry
	    // in case it is referred to later.

	    // REVIEW  For FORTRAN if ordinal is already defined
	    // REVIEW  then this is a refined definition -- we
	    // REVIEW  override the old definition with the new
	    // REVIEW  one at this time	-Rico

	    nlen = strlen (r_bname);
	    if (nlen > MaxSymLen) MaxSymLen = (BYTE)nlen;

            vaCurSym = MbrAddAtom (r_bname, FALSE);
	    vaOrd    = VaOrdAdd ();	// add sym ord to ord list
	    gORD(vaOrd).vaOrdProp = VaPropAddToSym(vaCurSym);
	    pORD(vaOrd);

	    break;

	case SBR_REC_OWNER:
	    if (!(vaProp = VaOrdFind(r_ordinal))) {
		// emit error message in case of forward reference
		// try to continue
		//
		#ifdef DEBUG
		if (OptD & 4)
                    printf ("mbrmake: Owner Forward Reference(%d)\n",
				r_ordinal); 
		#endif
		break;
	    }
	    vaOwnerProp = vaProp;
	    break;

	case SBR_REC_SYMREFSET:
	    fSymSet = TRUE;
	    // fall through

	case SBR_REC_SYMREFUSE:

	    if (!(vaProp = VaOrdFind(r_ordinal))) {
		// emit error message in case of forward reference
		// try to continue
		//
		#ifdef DEBUG
		if (OptD & 4)
                    printf ("mbrmake: Forward Reference(%d)\n", r_ordinal);
		#endif
		break;
	    }

	    AddRefProp (vaProp);
	    break;

	case SBR_REC_BLKBEG:
	    PushBstk();			// save state
	    break;

	case SBR_REC_MACROBEG:
	    cMacroDepth++;
	    break;

	case SBR_REC_MACROEND:
	    cMacroDepth--;
	    break;

	case SBR_REC_BLKEND:
	    PopBstk();
	    break;

	case SBR_REC_MODEND:
	    PopMstk();
	    break;

	default:
	    SBRCorrupt ("unknown rec type");
	    Fatal ();
	    break;

	}
    }

    CheckStacksEmpty();
}

VOID
AddCalProp(VA vaCurProp)
// Add a symbol reference to the calling procedure's Calls/Uses list.
//
{
    CAL cal;

    SetVMClient(VM_SEARCH_CAL);

    ENM_LIST (gPROP(vaOwnerProp).vaCalList, CAL)	// proc call list

	if (cCAL.vaCalProp == vaCurProp) {
	    cCAL.isbr = isbrCur;
	    cCAL.calcnt++;			// multiple calls
	    ENM_PUT(CAL);
	    return;
	}

    ENM_END

    cal.isbr	  = isbrCur;
    cal.vaCalProp = vaCurProp;			// symbol called or used
    cal.calcnt    = 1;

    SetVMClient(VM_ADD_CAL);

    VaAddList(&cPROP.vaCalList, &cal, sizeof(cal), grpCal);
	
    pPROP(vaOwnerProp);

    SetVMClient(VM_MISC);

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New CAL for: ");
	DebugDumpProp(vaOwnerProp);
    }
#endif
}

VOID
AddCbyProp(VA vaCurProp)
// Add a symbol reference to it's property Called/Used by list.
//
{
    CBY cby;

    SetVMClient(VM_SEARCH_CBY);

    ENM_LIST (gPROP(vaCurProp).vaCbyList, CBY)  // prop called/used by list 

	if (cCBY.vaCbyProp == vaOwnerProp) {
	    cCBY.isbr = isbrCur;
	    cCBY.cbycnt++;
	    ENM_PUT(CBY);
	    return;
	}

    ENM_END

    cby.isbr	  = isbrCur;
    cby.vaCbyProp = vaOwnerProp;   	// symbol we are called or used by 
    cby.cbycnt    = 1;

    SetVMClient(VM_ADD_CBY);

    VaAddList(&cPROP.vaCbyList, &cby, sizeof(cby), grpCby);

    pPROP(vaCurProp);

    SetVMClient(VM_MISC);

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New CBY for: ");
	DebugDumpProp(vaCurProp);
    }
#endif
}

VOID
AddRefProp(VA vaCurProp)
// Add a symbol reference to it's property reference list.
//
{
    VA vaRef, vaFileSym;

    SetVMClient(VM_SEARCH_REF);

    vaFileSym = gMOD(vaCurMod).vaNameSym;

    gPROP(vaCurProp);

    if (fDupMod) {
	// try looking at the hint for this PROP if there is one, if there
	// isn't then we're stuck -- we must search the whole REF list
	//

	if (vaRef = cPROP.vaHintRef) {
	    gREF(vaRef);

	    if (cREF.reflin == r_lineno) {
		cREF.isbr = isbrCur;
		pREF(vaRef);
		SetVMClient(VM_MISC);
		return;
	    }

	    vaRef = VaFrVp(cREF.vpNextRef);
	    if (vaRef) {
		gREF(vaRef);
		if (cREF.reflin == r_lineno) {
		    cREF.isbr = isbrCur;
		    pREF(vaRef);
		    cPROP.vaHintRef = vaRef;
		    pPROP(vaCurProp);
		    SetVMClient(VM_MISC);
		    return;
		}
	    }
	}

	vaRef = VaFrVp(cPROP.vpFirstRef);

	while (vaRef) {
	    gREF(vaRef);
	    if ((VaFrVp(cREF.vpFileSym) == vaFileSym) && // ignore multiple
		(cREF.reflin == r_lineno)) {  // references to same file & line
		    cREF.isbr = isbrCur;
		    pREF(vaRef);
		    cPROP.vaHintRef = vaRef;
		    pPROP(vaCurProp);
		    SetVMClient(VM_MISC);
		    return;
	    }
	    vaRef = VaFrVp(cREF.vpNextRef);
	}
    }
    else {
	if (vaRef = VaFrVp(cPROP.vpLastRef)) {
	    gREF(vaRef);
	    if (cREF.reflin == r_lineno &&
		vaFileSym   == VaFrVp(cREF.vpFileSym)) {
		    SetVMClient(VM_MISC);
		    return;
		}
	}
    }

    SetVMClient(VM_ADD_REF);

    vaRef = VaAllocGrpCb(grpRef, sizeof(REF));

    gREF(vaRef);
    cREF.isbr		= isbrCur;
    cREF.reflin 	= r_lineno;

    MkVpVa(cREF.vpFileSym, vaFileSym);

    pREF(vaRef);

    gPROP(vaCurProp);

    AddTail (Ref, REF);

    cPROP.cref++;			// count references 
    cPROP.vaHintRef = vaRef;

    pPROP(vaCurProp);	

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New REF for: ");
	DebugDumpProp(vaCurProp);
    }
#endif

    SetVMClient(VM_MISC);

    if (vaOwnerProp) {
	AddCbyProp (vaCurProp);		// add to called/used by 
	AddCalProp (vaCurProp);		// add to call/uses	 
    }
}

VOID
AddDefProp(VA vaCurProp)
// Add a symbol definition to it's property definition list.
// 	-Set vaOwnerProp if symbol is an internal function.
{
    DEF def;
    VA  vaFileSym;

#if 0

    // if current symbol is FUNCTION and formally declared
    // (block stack not empty), then remember it.
    // Subsequent symbols are called by or used by this function.
    //
    // this is going away when all compilers support SBR_REC_OWNER

    if ((r_attrib & SBR_TYPMASK) == SBR_TYP_FUNCTION)
	if (pfblkstack != NULL && !(r_attrib & SBR_ATR_DECL_ONLY))
	    vaOwnerProp = vaCurProp;
#endif

    vaFileSym = gMOD(vaCurMod).vaNameSym;

    ENM_LIST (gPROP(vaCurProp).vaDefList, DEF)	// proc def list

	if ((cDEF.vaFileSym == vaFileSym) && // ignore multiple
	    (cDEF.deflin    == r_lineno)) {  // references to same file & line
		cDEF.isbr = isbrCur;
		ENM_PUT(DEF);
		SetVMClient(VM_MISC);
		return;
	}

    ENM_END

    def.isbr		= isbrCur;
    def.deflin 		= r_lineno;
    def.vaFileSym 	= vaFileSym;

    SetVMClient(VM_ADD_DEF);

    gPROP(vaCurProp);

    VaAddList(&cPROP.vaDefList, &def, sizeof(def), grpDef);

    pPROP(vaCurProp);

    SetVMClient(VM_MISC);

#ifdef DEBUG
    if (OptD & 8) {
    	printf("New DEF for: ");
	DebugDumpProp(vaCurProp);
    }
#endif

    // don't count the definitions of the current proc as uses

    if (vaOwnerProp && vaCurProp != vaOwnerProp) {
	AddCbyProp (vaCurProp);		// add to called/used by 
	AddCalProp (vaCurProp);		// add to call/uses	 
    }
}


VA
VaPropBestOfSym(VA vaSym)
//
// Returns property pointer if:
//	1). symbol is already defined,
//	2). attributes match (except for possibly ATR_DECL_ONLY)
//
// Idea is to recognize the definition of an external.
//
{
    VA vaProp;
    WORD sattr;

    SetVMClient(VM_SEARCH_PROP);

    vaProp = gSYM(vaSym).vaFirstProp;

    while (vaProp) {
	sattr = gPROP(vaProp).sattr;

	if ((r_attrib & (~SBR_ATR_DECL_ONLY))
			== (sattr & (~SBR_ATR_DECL_ONLY))) {
    	    SetVMClient(VM_MISC);
	    return (vaProp);
	}

	vaProp = cPROP.vaNextProp;
    }

    SetVMClient(VM_MISC);

    return vaNil;
}

VA
VaPropAddToSym(VA vaCurSym)
// Add a property node for the given symbol.
//
{
    char fDupProp = FALSE;
    VA vaCurProp;

    if (vaCurProp = VaPropBestOfSym (vaCurSym)) {
	if ( (cPROP.sattr & SBR_ATR_DECL_ONLY) &&
	    !(r_attrib    & SBR_ATR_DECL_ONLY)) {
		cPROP.sattr = r_attrib;
		pPROP(vaCurProp);
	}
	fDupProp = TRUE;
    }
    else {
	SetVMClient(VM_ADD_PROP);

	vaCurProp = VaAllocGrpCb(grpProp, sizeof(PROP));
	gPROP(vaCurProp);
	cPROP.vaNameSym = vaCurSym;
	cPROP.sattr 	= r_attrib;

	if (gSYM(vaCurSym).vaFirstProp)
	    cPROP.vaNextProp = cSYM.vaFirstProp;

	pPROP(vaCurProp);

	cSYM.vaFirstProp = vaCurProp;
	cSYM.cprop++;
	pSYM(vaCurSym);

	SetVMClient(VM_MISC);
    }

    if (!fExclMod) {
	if (r_attrib & SBR_ATR_DECL_ONLY) 
	    AddRefProp (vaCurProp);		// treat extern as ref 
	else
	    AddDefProp (vaCurProp);		// define others
    }

    return (vaCurProp);
}

VOID
BldModSymList ()
// Build each module's symbol list
//
{
   WORD i;
   VA vaMod, vaModSym, vaSym, vaProp;

   SetVMClient(VM_BUILD_MODSYM);

   // zero out module symbol counts
   vaMod = vaRootMod;
   while (vaMod) {
      gMOD(vaMod);
      cMOD.csyms = 0;
      pMOD(vaMod);
      vaMod = cMOD.vaNextMod;
   }

   for (i=0; i < cSymbolsMac; i++) {
      vaSym = rgvaSymSorted[i];

      if (!vaSym) continue;

      vaProp = gSYM(vaSym).vaFirstProp;

      while (vaProp) {
	 ENM_LIST(gPROP(vaProp).vaDefList, DEF)

	    vaMod = vaRootMod;	   // look at defs for each mod */
	    while (vaMod) {
	       if (cDEF.vaFileSym == gMOD(vaMod).vaNameSym) {

		  if (cMOD.vaLastModSym  &&
		      gMODSYM(cMOD.vaLastModSym).vaFirstProp == vaProp)
			goto break2;  // duplicate

		  // belongs to this mod 
		  cMOD.csyms++;
		  
		  vaModSym = VaAllocGrpCb(grpModSym, sizeof(MODSYM));
		  gMODSYM(vaModSym);
		  cMODSYM.vaFirstProp = vaProp;
		  cMODSYM.vaNextModSym = 0;
		  pMODSYM(vaModSym);

		  if (!cMOD.vaFirstModSym)
		     cMOD.vaFirstModSym = cMOD.vaLastModSym = vaModSym;
		  else {
		     gMODSYM(cMOD.vaLastModSym).vaNextModSym = vaModSym;
		     pMODSYM(cMOD.vaLastModSym);
		     cMOD.vaLastModSym = vaModSym;
		  }
		  pMOD(vaMod);
		  break;
	       }
	       vaMod = cMOD.vaNextMod;
	    }
	    break2: ;  // duplicate Modsyms will cause goto here
	 ENM_END

	 vaProp = cPROP.vaNextProp;
      }
   }

   SetVMClient(VM_MISC);
}

VOID
CleanUp()
//	1. Remove symbols that have no references.
//	2. Remove symbols that have only references
//	3. Connect used symbols with no definition to <Unknown>
//
{
    WORD i;
    VA vaSym, vaProp, vaPropNext, vaPropPrev = vaNil;
    DEF def;
    BOOL fDelete;

    #define FExternAttr(attr) (!!(attr & SBR_ATR_DECL_ONLY))
    #define FFunctionAttr(attr) ((attr & SBR_TYPMASK) == SBR_TYP_FUNCTION)

    def.vaFileSym = vaUnknownSym;
    def.deflin    = 0;
    def.isbr      = 0xffff;

    SetVMClient(VM_CLEAN_REFS);

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];

	vaPropPrev = vaNil;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    vaPropNext = gPROP(vaProp).vaNextProp;
	    fDelete = FALSE;

	    // figure out what to delete here

	    // if the symbol is used by anyone or uses anyone we must keep it
	    // regardless of all other considerations
	    //
	    if (((!cPROP.vaCalList) && (!cPROP.vaCbyList))  && (
		// at this point we know there are only refs & defs

		   // if it is totally unreferenced & undefined it can go
		   (cPROP.cref == 0 && (!cPROP.vaDefList))
		 ||
		   // if we're allowed to remove "useless" symbols then we try
	    	   ((!OptIu) && 
			// if there are only prototypes we can delete it
			(((!cPROP.vaDefList) && FExternAttr(cPROP.sattr))
		      ||
			// or if it is unreferenced and is not a function 
			(cPROP.cref == 0 && (!FFunctionAttr(cPROP.sattr))))))) {
				fDelete = TRUE;	// nuke it
	    }
	    else if (!cPROP.vaDefList) {

		// if we couldn't get rid of the thing, and there are no
		// definitions for it then we must make a fake definition
		// in the <Unknown> file.  This will happen (in particular)
		// for library functions that are called by someone
		//
		// library functions that are not called would fall under
		// the case of a symbol with only prototypes above

		VaAddList(&cPROP.vaDefList, &def, sizeof(def), grpDef);
		pPROP(vaProp);

		#ifdef DEBUG
		if (OptD & 32)
		    printf ("PROP unknown: %s\n", GetAtomStr (vaSym));
		#endif
	    }

	    if (fDelete) {
		#ifdef DEBUG
		if (OptD & 32)
		    printf ("PROP deleted: %s\n", GetAtomStr (vaSym));
		#endif

		cSYM.cprop--;

		if (vaPropPrev == vaNil) {
		    cSYM.vaFirstProp = vaPropNext;
		}
		else {
	  	    gPROP(vaPropPrev);
		    cPROP.vaNextProp = vaPropNext;
		    pPROP(vaPropPrev);
		}

		pSYM(vaSym);
	    }
	    else
		vaPropPrev = vaProp;	// prev = current 

	    vaProp = vaPropNext;
	}

	if (!cSYM.cprop) {
	    #ifdef DEBUG
	    if (OptD & 32)
		printf ("SYM deleted: %s\n", GetAtomStr (vaSym));
	    #endif
	    rgvaSymSorted[i] = vaNil;
	}
    }

    SetVMClient(VM_MISC);
}

BOOL
FWildMatch(char *pchPat, char *pchText)
// return TRUE if pchText matchs pchPat in the dos wildcard sense
//
// REVIEW FWildMatch for 1.2 file name support
//
{
    char chText, chPat;

    for (;;) {
	switch (*pchPat) {

	case '\0':
	    return *pchText == '\0';

	case '/':
	case '\\':
	    if (*pchText != '/' && *pchText != '\\')
		return FALSE;

	    pchText++;
	    pchPat++;
	    break;
	
	case '.':
	    pchPat++;
	    switch (*pchText) {

	    case '.':
		pchText++;
		break;

	    case '\0': case '/': case '\\':
		break;

	    default:
		return FALSE;
	    }
	    break;

	case '*':
	    pchText += strcspn(pchText, ":./\\");
	    pchPat  += strcspn(pchPat,  ":./\\");
	    break;

	case '?':
	    pchPat++;
	    switch (*pchText) {

	    case '\0': case '.': case '/': case '\\':
		break;

	    default:
		pchText++;
		break;
	    }
		
	    break;

	default:
	    chText = *pchText;
	    chPat  = *pchPat;

	    if (islower(chText)) chText = (char)toupper(chText);
	    if (islower(chPat))  chPat	= (char)toupper(chPat);

	    if (chText != chPat)
		return FALSE;
	   
	    pchPat++;
	    pchText++;
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\getsbrec.c ===
//
//
// GETSBREC.C -	Reads records from the .SBR file and stores the fields
//		in the appropriate r_.. buffers.
//

#include "sbrfdef.h"
#include "..\mbrmake\mbrmake.h"

// globals for communicating with clients

BYTE	near r_rectyp;			// current record type
BYTE	near r_majv;			// major version num
BYTE	near r_minv;			// minor version num
BYTE	near r_lang;			// source language
BYTE	near r_fcol;			// read column #'s
WORD	near r_lineno;			// current line number
BYTE	near r_column = 0;		// def/ref column num
WORD	near r_ordinal;			// symbol ordinal
WORD	near r_attrib;			// symbol attribute
char	near r_bname[PATH_BUF];		// symbol or filename
char	near r_cwd[PATH_BUF];		// .sbr file working directory

int	near fhCur;			// Current input handle

#pragma intrinsic(memcpy)
#pragma intrinsic(strcpy)
#pragma intrinsic(strlen)

#define MY_BUF_SIZE 16384

static char sbrBuf[MY_BUF_SIZE + 1];
static char *pchBuf;
static int cchBuf;

#define GetByte(X)					\
{							\
    if (!cchBuf) {					\
	cchBuf = read(fhCur, sbrBuf, MY_BUF_SIZE);	\
	sbrBuf[cchBuf] = 0;				\
	pchBuf = sbrBuf;				\
							\
	if (cchBuf == 0)				\
	    SBRCorrupt("premature EOF");		\
    }							\
							\
    cchBuf--;						\
    (X) = (unsigned char)*pchBuf++;			\
}

#define GetWord(X)					\
{							\
							\
    GetByte(((char *)&(X))[0]);				\
    GetByte(((char *)&(X))[1]);				\
}

void
GetStr(char *buf)
// get null terminated string from current .sbr file
//
{
    register int l;

    for (;;) {
	// there is always a NULL after the real buffer
	l = strlen(pchBuf);

	if (l++ < cchBuf) {
	    strcpy(buf, pchBuf);
	    cchBuf -= l;
	    pchBuf += l;
	    return;
	}

	memcpy(buf, pchBuf, cchBuf);
	buf += cchBuf;

	cchBuf = read(fhCur, sbrBuf, MY_BUF_SIZE);
	sbrBuf[cchBuf] = 0;
	pchBuf = sbrBuf;

	if (cchBuf == 0)
	    SBRCorrupt("premature EOF");
    }
}
	
BYTE
GetSBRRec()
// read the next record from the current .sbr file
//
{
    static fFoundHeader;
    BYTE   col;

    // read rectype, check for EOF as we go
	

    if (!cchBuf) {
	cchBuf = read(fhCur, sbrBuf, MY_BUF_SIZE);
	sbrBuf[cchBuf] = 0;
	pchBuf = sbrBuf;

	if (cchBuf == 0) {
	    fFoundHeader = 0;	// this is in case we are reinitialized
	    return S_EOF;
	}
    }
    
    cchBuf--;
    r_rectyp = (unsigned char)*pchBuf++;

    switch(r_rectyp) {
	case SBR_REC_HEADER:
	    if (fFoundHeader)
		SBRCorrupt("Multiple Headers");

	    fFoundHeader = 1;
	    GetByte(r_majv);
	    GetByte(r_minv);
	    GetByte(r_lang);
	    GetByte(r_fcol);

	    if (r_majv != 1 || r_minv != 1)
		break;

	    GetStr (r_cwd);
	    break;

	case SBR_REC_MODULE:
	    GetStr (r_bname);
	    break;

	case SBR_REC_LINDEF:
	    GetWord (r_lineno);
	    if (r_lineno)
		r_lineno--;
	    break;

	case SBR_REC_SYMDEF:
	    GetWord (r_attrib);
	    GetWord (r_ordinal);
	    if (r_fcol) GetByte (col);
	    GetStr (r_bname);
	    break;

	case SBR_REC_OWNER:
	    GetWord (r_ordinal);
	    break;

	case SBR_REC_SYMREFUSE:
	case SBR_REC_SYMREFSET:
	    GetWord (r_ordinal);
	    if (r_fcol) GetByte (col);
	    break;

	case SBR_REC_MACROBEG:
	case SBR_REC_MACROEND:
	case SBR_REC_BLKBEG:
	case SBR_REC_BLKEND:
	case SBR_REC_MODEND:
	    break;
    }
    return (r_rectyp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\list.c ===
// list.c
//
// a VM growable array package

#include "mbrmake.h"

typedef struct _list {
	WORD cItems;
} SLIST;

typedef struct _biglist {
	WORD cItems;
	VA vaNext;
} BLIST;

typedef union _mixlist {
	SLIST 	sml;
	BLIST	big;
} GLIST;

// this are the two VM lock numbers for the list package
//
#define LIST_LOCK  10
#define LIST_LOCK2 11

// Beware!  For the system to work properly this number must
// be small enough that the VM free lists won't overflow
// i.e. C_ITEMS_MAX * sizeof(biggest_thing_stored) <= C_FREE_LIST_MAX 
//
#define C_ITEMS_MAX 16	

#pragma intrinsic(memcpy)

#define cBlock 1

VA
VaAddList(VA far *pvaList, LPV lpvData, WORD cbData, WORD grp)
// add the given item to the list; create if necessary
// return the virtual address of the most recently added item
//
{
    VA vaListNew;
    VA vaDirtyOnExit = vaNil;

    WORD cbBlock, cItems, cAlloc;

    GLIST far *lpList, *lpListNew;

#ifdef SWAP_INFO
    iVMGrp = grp;
#endif

#if cBlock != 1
    if (cBlock == 0) cBlock = C_ITEMS_MAX;
#endif

top:  // for tail recursion...

    // current list is empty -- create a new list with one thing in it

    if (*pvaList == vaNil) {
	if (cBlock == C_ITEMS_MAX) {
            *pvaList = VaAllocGrpCb(grp, cbData*cBlock + sizeof(BLIST));
            lpList = LpvFromVa(*pvaList, LIST_LOCK);
	    lpList->big.vaNext = vaNil;
	    lpList->big.cItems = 1;
	    memcpy(((LPCH)lpList) + sizeof(BLIST), lpvData, cbData);
	    if (vaDirtyOnExit) {
		DirtyVa(vaDirtyOnExit);
		UnlockW(LIST_LOCK+1);
	    }
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + sizeof(BLIST);
	}
	else {
            *pvaList = VaAllocGrpCb(grp, cbData*cBlock + sizeof(SLIST));
            lpList = LpvFromVa(*pvaList, LIST_LOCK);
	    lpList->sml.cItems = 1;
	    memcpy(((LPCH)lpList) + sizeof(SLIST), lpvData, cbData);
	    if (vaDirtyOnExit) {
		DirtyVa(vaDirtyOnExit);
		UnlockW(LIST_LOCK+1);
	    }
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + sizeof(SLIST);
        }
    }

    lpList = LpvFromVa(*pvaList, LIST_LOCK);
    cItems = lpList->sml.cItems;

    // if current list has extension blocks, recursively add to the
    // tail of this list

    if (cItems >= C_ITEMS_MAX) {
	vaDirtyOnExit = *pvaList;
	lpList->big.cItems++;
	DirtyVa(*pvaList);
	LpvFromVa(*pvaList, LIST_LOCK+1);  // lock in mem so address stays good
	pvaList = &lpList->big.vaNext;
	UnlockW(LIST_LOCK);
	goto top;
    }

    cbBlock = cItems * cbData;
    cAlloc  = cItems % cBlock;
    cAlloc  = cItems - cAlloc + ( cAlloc ? cBlock : 0 );

    // do we need to reallocate?  If not do a fast insert
    //
    if (cItems < cAlloc) {
	if (cAlloc >= C_ITEMS_MAX) {
	    memcpy(((LPCH)lpList) + cbBlock + sizeof(BLIST), lpvData, cbData);
	    lpList->big.cItems++;
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + cbBlock + sizeof(BLIST);
	}
	else {
	    memcpy(((LPCH)lpList) + cbBlock + sizeof(SLIST), lpvData, cbData);
	    lpList->sml.cItems++;
	    DirtyVa(*pvaList);
	    UnlockW(LIST_LOCK);
            return (PBYTE)*pvaList + cbBlock + sizeof(SLIST);
	}
    }

    // test if the next block will fit without turning the current list into
    // a chained list... allocate a new block & copy the old data

    if (cItems + cBlock < C_ITEMS_MAX) {
        vaListNew = VaAllocGrpCb(grp, cbBlock + cbData*cBlock + sizeof(SLIST));
	lpListNew = LpvFromVa(vaListNew, 0);
	memcpy((LPCH)lpListNew, lpList, cbBlock + sizeof(SLIST));
	memcpy((LPCH)lpListNew + cbBlock + sizeof(SLIST), lpvData, cbData);
	lpListNew->sml.cItems++;
	DirtyVa(vaListNew);
        FreeGrpVa(grp, *pvaList, cbBlock + sizeof(SLIST));
        *pvaList = vaListNew;
	if (vaDirtyOnExit) {
	    DirtyVa(vaDirtyOnExit);
	    UnlockW(LIST_LOCK+1);
	}
	UnlockW(LIST_LOCK);
        return (PBYTE)vaListNew + cbBlock + sizeof(SLIST);
    }

    // this is the last item that will go into this block, 
    // allocate a new block c/w link field & copy the old data
    // set the link field to 0 for now

#if cBlock != 1
    cBlock = C_ITEMS_MAX - cItems;
#endif

    vaListNew = VaAllocGrpCb(grp, cbBlock + cbData*cBlock + sizeof(BLIST));
    lpListNew = LpvFromVa(vaListNew, 0);
    memcpy(lpListNew + 1 , ((SLIST FAR *)lpList) + 1, cbBlock);
    memcpy(((LPCH)lpListNew) + cbBlock + sizeof(BLIST), lpvData, cbData);
    lpListNew->big.cItems = lpList->sml.cItems + 1;
    lpListNew->big.vaNext = vaNil;
    DirtyVa(vaListNew);
    FreeGrpVa(grp, *pvaList, cbBlock + sizeof(SLIST));
    *pvaList = vaListNew;
    if (vaDirtyOnExit) {
	DirtyVa(vaDirtyOnExit);
	UnlockW(LIST_LOCK+1);
    }
    UnlockW(LIST_LOCK);
    return (PBYTE)vaListNew + cbBlock + sizeof(BLIST);
}

WORD
CItemsList(VA vaList)
// return total number of items in array
//
{
    if (vaList == vaNil)
	return 0;

#ifdef SWAP_INFO
    iVMGrp = grpList;
#endif

    return ((SLIST FAR *)LpvFromVa(vaList, 0))->cItems;
}

// to use the following iterator say something like
//
// vaPropList = cSYM.vaPropList;
// while (cprop = CItemsIterate(&vaProps, &vaPropList, cBlock)) {
//	gPROP(vaProps);
//	for (;--cprop >= 0; cPROP++) {
//	    cPROP.etc = ;
//
//	}
// }
//
//
// The ENM_LIST, ENM_END, ENM_BREAK macros "do the right thing" with 
// these lists.
//

WORD
CItemsIterate(VA FAR *vaData, VA FAR *vaNext)
// give number of elements in current block and pointer to next block
//
{
    GLIST FAR *lpgList;
    WORD cItems, cAlloc;

    if (*vaNext == vaNil)
	return 0;

#ifdef SWAP_INFO
    iVMGrp = grpList;
#endif

#if cBlock != 1
    if (cBlock == 0) cBlock = C_ITEMS_MAX;
#endif

    lpgList = LpvFromVa(*vaNext, 0);

    cItems = lpgList->sml.cItems;

    if (cItems >= C_ITEMS_MAX) {
        *vaData  = (PBYTE)*vaNext + sizeof(BLIST);
	*vaNext  = lpgList->big.vaNext;
	return C_ITEMS_MAX;
    }

    if (cBlock == 0)
	cAlloc = C_ITEMS_MAX;
    else {
	cAlloc = cItems % cBlock;
	cAlloc = cItems - cAlloc + ( cAlloc ? cBlock : 0 );
    }

    if (cAlloc >= C_ITEMS_MAX)
        *vaData  = (PBYTE)*vaNext + sizeof(BLIST);
    else
        *vaData  = (PBYTE)*vaNext + sizeof(SLIST);

    *vaNext  = 0;
    return cItems;
}

VOID
FreeList(VA vaList, WORD cbData)
// free up all the memory associated with this list
//
{
    (PBYTE)vaList + cbData;
    printf("FreeList is currently not working\n");

#if 0

    GLIST FAR * lpgList;
    VA vaNextList;


    if (vaList == vaNil)
	return;

top:	// tail recursion

    lpgList = LpvFromVa(vaList, 0);

    if (lpgList->sml.cItems >= C_ITEMS_MAX) {

	vaNextList = lpgList->big.vaNext;
	FreeVa(vaList, C_ITEMS_MAX * cbData + sizeof(BLIST));

	vaList = vaNextList;
	goto top;		// tail recursion
    }

    FreeVa(vaList, lpgList->sml.cItems * cbData + sizeof(SLIST));
    return;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\list.h ===
// list.h
//
// a VM growable array package

VA   VaAddList(VA far *vaList, LPV lpvData, WORD cbData, WORD grp);
WORD CItemsList(VA vaList);
WORD CItemsIterate(VA FAR *vaData, VA FAR *vaNext);


#define ENM_LIST(start, type)						  \
{									  \
  VA va##type##list = (start);						  \
  VA va##type##s;							  \
  int cnt##type, idx##type;						  \
  while (cnt##type = CItemsIterate(&va##type##s, &va##type##list)) 	 {\
    g##type(va##type##s);						  \
    for (idx##type = 0; idx##type < cnt##type; idx##type++, (&c##type)++) {

#define ENM_END } } }

#define ENM_PUT(type) DirtyVa(va##type##s)

#define ENM_VA(type) (va##type##s + sizeof(c##type)*idx##type)

#define ENM_BREAK(type) va##type##list = 0; break;


//
// example use of ENM_LIST
//
//

// ENM_LIST (vaPropList, PROP) {
//
//	... some things using CPROP  (like below) ..
//
//	printf("%s\n", GetAtomStr(cPROP.vaNameSym));
//
//	... other things using cPROP...
//	
// } ENM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\extern.h ===
// pointers to resident pages of virtual memory of the given object type

extern MOD      FAR * near    modRes;
extern MODSYM   FAR * near    modsymRes;
extern SYM      FAR * near    symRes;
extern PROP     FAR * near    propRes;
extern DEF      FAR * near    defRes;
extern REF      FAR * near    refRes;
extern CAL      FAR * near    calRes;
extern CBY      FAR * near    cbyRes;
extern ORD      FAR * near    ordRes;
extern SBR      FAR * near    sbrRes;
extern char     FAR * near    textRes;
extern OCR      FAR * near    ocrRes;

// global variables for communication with getsbrec.c

extern BYTE           near    r_rectyp;         // current record type
extern BYTE           near    r_fcol;           // read column #'s
extern BYTE           near    r_majv;           // major version #
extern BYTE           near    r_minv;           // minor version #
extern BYTE           near    r_lang;           // current language
extern WORD           near    r_lineno;         // current line number
extern WORD           near    r_ordinal;        // symbol ordinal
extern WORD           near    r_attrib;         // symbol attribute
extern char           near    r_bname[];        // symbol or filename
extern char           near    r_cwd[];          // current working directory
extern BYTE           near    r_rectyp;         // current record type
extern BYTE           near    r_fcol;           // read column #'s
extern WORD           near    r_lineno;         // current line number
extern WORD           near    r_ordinal;        // symbol ordinal
extern WORD           near    r_attrib;         // symbol attribute
extern char           near    r_bname[];        // symbol or filename
extern char           near    r_cwd[];          // this .sbr files current dir
extern char           near    c_cwd[];          // pwbrmake's actual current dir

// option variables

extern BOOL           near    OptEm;            // TRUE = exclude macro bodies
extern BOOL           near    OptEs;            // TRUE = exclude system files
extern BOOL           near    OptIu;            // TRUE = exclude unused syms
extern BOOL           near    OptV;             // Verbose switch
#if DEBUG
extern WORD           near    OptD;             // debug bits
#endif

// others that I haven't classified yet

extern BYTE           near    MaxSymLen;        // longest symbol len
extern VA             near    vaSymHash[];      // symbol list
extern LPEXCL         near    pExcludeFileList; // exclude file list
extern LSZ            near    lszFName;         // name of current .sbr file
extern FILE *         near    streamOut;        // .bsc output stream
extern int            near    fhCur;            // file handle for the current .sbr file
extern LSZ            near    prectab[];        // record types table
extern LSZ            near    plangtab[];       // language types table
extern LSZ            near    ptyptab[];        // prop types table
extern LSZ            near    patrtab[];        // prop attributes table
extern WORD           near    isbrCur;          // current SBR file index
extern FILE *         near    OutFile;          // .BSC file handle
extern WORD           near    ModCnt;           // count of modules
extern WORD           near    SbrCnt;           // count of sbr files
extern BYTE           near    fCase;            // TRUE for case compare
extern BYTE           near    MaxSymLen;        // longest symbol len
extern BOOL           near    fOutputBroken;    // TRUE while database is incomplete
extern VA             near    vaUnknownSym;     // ptr to 'UNKNOWN' Symbol
extern VA             near    vaUnknownMod;     // unknown module
extern BOOL           near    fDupSym;          // TRUE if adding duplicate atom
extern VA             near    vaRootMod;        // Module list
extern VA             near    rgVaSym[];        // Symbol list
extern FILE *         near    streamCur;        // Current .sbr handle
extern LSZ            near    OutputFileName;   // Output file name
extern VA       FAR * near    rgvaSymSorted;
extern VA             near    vaRootMod;
extern VA             near    vaCurMod;
extern VA             near    vaCurSym;
extern VA             near    vaRootOrd;
extern VA             near    vaRootSbr;
extern WORD           near    cAtomsMac;
extern WORD           near    cModulesMac;
extern WORD           near    cSymbolsMac;
extern LSZ            near    lszFName;         // current .sbr file name
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\mbrhash.c ===
#include "mbrmake.h"
WORD HashAtomStr (char *pStr) {

   WORD hash = 0;
   while (*pStr)
       hash += (hash << 5) + *pStr++;

   return (hash % (MAXSYMPTRTBLSIZ-1));
}

#if rjsa
HashAtomStr PROC NEAR USES DS SI, npsz:DWORD
	xor	ax,ax			; (ax) = byte-extended-to-word
	mov	cx,ax			; (cx) = hash
	mov	dx,ax			; (dx) = high part for later div
	cld
	lds	si,npsz 		; (si) = pointer to string
	align	4
hfs1:	lodsb				; get next byte
	or	al,al			; are we at end of string?
	jz	hfs2			; yes, compute div and we're done
	mov	bx,cx
	shl	bx,1
	shl	bx,1
	shl	bx,1
	shl	bx,1
	shl	bx,1
	add	cx,bx			; (newcx) = (oldcx) + (oldcx) << 5
	add	cx,ax			; (cx) += (cx) << 5 + (ax)
	jmp	hfs1

hfs2:	mov	ax,4094			; magic divider
	xchg	ax,cx			; (dx:ax) = number, (cx) = dividend
	div	cx
	mov	ax,dx
	ret
HashAtomStr ENDP

end

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\mbrmake.c ===
//
//  mbrmake - Source Browser Source Data Base builder
//            (C) 1988 By Microsoft
//
//  29-Aug-1989 dw      Minor fixes to aid in C 6 conversion
//
//

#define LINT_ARGS

// rjsa #include <signal.h>
#include <process.h>
#include <direct.h>
#include <stdlib.h>

// get version.h from mb

#include "..\..\inc\version.h"

#include "sbrvers.h"
#include "sbrfdef.h"
#include "mbrmake.h"

#include <sys\types.h>
#include <sys\stat.h>
#include <tools.h>

// this fixes the bogosity in config.h that gets included by tools.h
// it will set DEBUG = 0 for a non-debug version...
//
//              -rm

#ifdef DEBUG
#if DEBUG == 0
#undef DEBUG
#endif
#endif

static VOID TruncateSBR(char *lszName);
static VOID ProcessSBR(char *lszName);
static VOID MarkNewSBR(char *lszName);

#ifdef DEBUG
WORD    near OptD = 0;
#endif

FILE *  near streamOut = stdout;

BOOL    near OptEs      = FALSE;        // exclude system files
BOOL    near OptEm      = FALSE;        // exclude macro expansions
BOOL    near OptIu      = FALSE;        // include unreference symbols
BOOL    near OptV       = FALSE;        // verbose output
BOOL    near OptN       = FALSE;        // no incremental behaviour

char    near c_cwd[PATH_BUF];           // current working directory
char    near patbuf[PATH_BUF];

MOD     FAR * near modRes;              // VM cache
MODSYM  FAR * near modsymRes;
SYM     FAR * near symRes;
PROP    FAR * near propRes;
DEF     FAR * near defRes;
REF     FAR * near refRes;
CAL     FAR * near calRes;
CBY     FAR * near cbyRes;
ORD     FAR * near ordRes;
SBR     FAR * near sbrRes;
char    FAR * near textRes;
OCR     FAR * near ocrRes;

BYTE    near fCase = FALSE;             // TRUE for case compare
BYTE    near MaxSymLen = 0;             // longest symbol len

LSZ     near lszFName;                  // Current input file

LSZ     near OutputFileName = NULL;     // output file name
FILE *  near OutFile;                   // output file handle
BOOL    near fOutputBroken = FALSE;     // we have dirtied the database

VA      near vaRootMod = vaNil;         // module list
VA      near vaCurMod  = vaNil;         // current module

VA      near rgVaSym[MAXSYMPTRTBLSIZ];  // symbol list array

EXCLINK FAR * near pExcludeFileList = NULL;     // exclude file list

struct mlist {
    int  erno;
    char *text;
};

struct mlist WarnMsg[] = {
    4500, "UNKNOWN WARNING\n\tContact Microsoft Product Support Services",
    4501, "ignoring unknown option '%s'",
    4502, "truncated .SBR file '%s' not in database",
};

struct mlist ErrorMsg[] = {
    1500, "UNKNOWN ERROR\n\tContact Microsoft Product Support Services",
    1501, "unknown character '%c' in option '%s'",
    1502, "incomplete specification for option '%s'",
    1503, "cannot write to file '%s'",
    1504, "cannot position in file '%s'",
    1505, "cannot read from file '%s'",
    1506, "cannot open file '%s'",
    1507, "cannot open temporary file '%s'",
    1508, "cannot delete temporary file '%s'",
    1509, "out of heap space",
    1510, "corrupt .SBR file '%s'",
    1511, "invalid response file specification",
    1512, "database capacity exceeded",
    1513, "nonincremental update requires all .SBR files",
    1514, "all .SBR files truncated and not in database",
};

VOID
Error (int imsg, char *parg)
// print error number and message
//
{
    printf ("mbrmake: error U%d : ",ErrorMsg[imsg].erno);
    printf (ErrorMsg[imsg].text, parg);
    printf ("\n");
    Fatal();
}

VOID
Error2 (int imsg, char achar, char *parg)
// print error number and message with argument
//
{
    printf ("mbrmake: error U%d : ",ErrorMsg[imsg].erno);
    printf (ErrorMsg[imsg].text, achar, parg);
    printf ("\n");
    Fatal();
}

VOID
Warning (int imsg, char *parg)
// print warning number and message
//
{
    printf ("mbrmake: warning U%d : ",WarnMsg[imsg].erno);
    printf (WarnMsg[imsg].text, parg);
    printf ("\n");
}

VOID
Fatal ()
// fatal error, attempt to shut down and exit
// if we already tried to shut down -- just abort without doing anything
{
    static BOOL fTwice;
    if (!fTwice) {
        fTwice = TRUE;
        if (fOutputBroken) {
            if (OutFile) fclose(OutFile);
            if (OutputFileName != NULL) unlink(OutputFileName);
        }
        CloseVM();
    }
    exit(4);
}

VOID
sigint ()
{
    // signal(SIGBREAK, sigint);
    // signal(SIGINT, sigint);
    Fatal ();
}

LSZ
LszDup(LSZ lsz)
// like strdup only using LpvAllocCb to get the memory
//
{
    LSZ lszDup;

    lszDup = LpvAllocCb(strlen(lsz)+1);
    strcpy(lszDup, lsz);
    return lszDup;
}

LSZ
LszDupNewExt(LSZ pname, LSZ pext)
//  duplicate the given filename changing the extension to be the given
//
{
    int i, len, elen;
    LSZ lsz;

    len = strlen(pname);
    elen = strlen(pext);

    // I know this looks like I should be doing a runtime call but nothing
    // does quite what I want here and I know that C6 will make great
    // code for this loop [rm]

    // find the first '.' starting from the back

    for (i=len; --i >= 0; )
        if (pname[i] == '.')
            break;


    // check to make sure we've got a real base name and not just all extension
    //

    if (i > 0) {
        // replace the extension with what's in pext

        lsz = LpvAllocCb(i + 1 + elen + 1); // base + dot + ext + nul
        memcpy(lsz, pname, i+1);
        strcpy(lsz+i+1, pext);
    }
    else {
        // just stick the extension on the end...

        lsz = LpvAllocCb(len + 1 + elen + 1);   // fullname + dot + ext + nul
        strcpy(lsz, pname);
        strcat(lsz, ".");
        strcat(lsz, pext);
    }

    return lsz;
}

VOID
AddExcludeFileList(LSZ pname)
// add the specifed filename to the exclusion list
//
{
    EXCLINK FAR *pexc;

    pexc = (EXCLINK FAR *)LpvAllocCb(sizeof(EXCLINK));
    pexc->pxfname = LszDup(ToAbsPath(pname, c_cwd));

    if (pExcludeFileList == NULL)
        pexc->xnext = NULL;
    else
        pexc->xnext = pExcludeFileList;

    pExcludeFileList = pexc;
}

BOOL
FValidHeader()
// Read in the header of a .sbr file -- return TRUE if it is valid
//
{
    // test if this is a truncated (i.e. already installed) .sbr file
    //
    if (GetSBRRec() == S_EOF)
        return FALSE;

    if (r_rectyp != SBR_REC_HEADER)
        SBRCorrupt("header not correct record type");

    if (r_lang == SBR_L_C)
        fCase = TRUE;

    if (r_majv != 1 || r_minv != 1)
        SBRCorrupt("incompatible .sbr format\n");

    #ifdef DEBUG
    if (OptD & 1) DecodeSBR();
    #endif

    return TRUE;
}

#ifdef PROFILE

// profile prototypes and typedefs

#include "casts.h"
#include "profile.h"

#endif

VOID __cdecl
main (argc, argv)
int argc;
char *argv[];
{
    int i;
    char *parg;
    long lArgPosn;

#ifdef PROFILE
    PROFINIT(PT_USER|PT_USEKP, (FPC)NULL);
    PROFCLEAR(PT_USER);
    PROFON(PT_USER);
#endif

    // signal(SIGBREAK, sigint);
    // signal(SIGINT, sigint);

    printf("Microsoft (R) mbrmake Utility ");
    printf(VERS(rmj, rmm, rup));
    printf(CPYRIGHT);

    if (argc == 1) Usage();

    getcwd(c_cwd, sizeof(c_cwd));
    ToBackSlashes(c_cwd);

    parg = ParseArgs(argc, argv);

    if (!parg)
        Usage();

    InitVM();

    for (i=0; i < MAXSYMPTRTBLSIZ; i++)         // init symbol lists
        rgVaSym[i] = vaNil;

    lArgPosn = GetArgPosn();

    do {
        ToBackSlashes(parg);

        if (forfile(parg, A_ALL, MarkNewSBR, NULL) == 0)
            Error(ERR_OPEN_FAILED, parg);
    }
    while (parg = NextArg());

    if (!OptN && FOpenBSC(OutputFileName)) {
        InstallBSC();
        CloseBSC();
    }
    else
        NumberSBR();

    SetArgPosn(lArgPosn);
    parg = NextArg();

    do {
        if (forfile(parg, A_ALL, ProcessSBR, NULL) == 0)
            Error(ERR_OPEN_FAILED, parg);
    }
    while (parg = NextArg());

    // this sort must happen before all the other calls below as they
    // use the sorted version of the list and not the raw symbols

    SortAtoms();        // create a sorted version of the atoms

#ifdef DEBUG
    if (OptD & 128) DebugDump();
#endif

    CleanUp   ();       // General cleaning

#ifdef DEBUG
    if (OptD & 16) DebugDump();
#endif

    WriteBSC (OutputFileName);    // write .bsc Source Data Base

#ifdef PROFILE
    PROFOFF(PT_USER);
    PROFDUMP(PT_USER, (FPC)"mbrmake.pro");
    PROFFREE(PT_USER);
#endif

    if (!OptN) {
        // truncate the .sbr files now
        SetArgPosn(lArgPosn);
        parg = NextArg();

        do {
            if (forfile(parg, A_ALL, TruncateSBR, NULL) == 0)
                Error(ERR_OPEN_FAILED, parg);
        }
        while (parg = NextArg());

        // touch the .bsc file so it has a date later than all the .sbrs

        {
            FILE *fh;
            int buf = 0;

            if (!(fh = fopen(OutputFileName, "ab"))) {
                Error(ERR_OPEN_FAILED, OutputFileName);
            }
            if (fwrite(&buf, 1, 1, fh)==0) {
                Error(ERR_WRITE_FAILED, OutputFileName);
            }

            fclose(fh);
        }
    }

    CloseVM();
    exit (0);
}

static VOID
ProcessSBR(char *lszName)
// process one .sbr file with the given name
//
{

    lszFName = LszDup(lszName);
    if ((fhCur = open(lszFName, O_BINARY|O_RDONLY)) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    isbrCur = gSBR(VaSbrFrName(lszFName)).isbr;

    if (OptV)
        printf("Processing: %s ..\n", lszFName);

    if (!FValidHeader()) {
        FreeLpv (lszFName);
        close(fhCur);
        return;
    }

    // Add .SBR data to lists
    InstallSBR ();

    FreeOrdList ();            // free ordinal aliases
    close(fhCur);

    FreeLpv (lszFName);
}

static VOID
TruncateSBR(char *lszName)
// once the .sbr file is used -- truncate it
//
{
    int fh;

    if (unlink(lszName) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    if ((fh = open(lszName, O_CREAT|O_BINARY, S_IREAD|S_IWRITE)) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    close(fh);
}

VOID
Usage()
{
#ifdef DEBUG
    printf("usage: mbrmake [-Emu] [-Ei ...] [-vd] [-help] [-o <.BSC>] [@<file>] <.sbr>...\n\n");
#else
    printf("usage: mbrmake [-Emu] [-Ei ...] [-v] [-help] [-o <.BSC>] [@<file>] <.sbr>...\n\n");
#endif
    printf("  @<file>   Get arguments from specified file\n");
    printf("  /E...     Exclude:\n");
    printf("     s              system files\n");
    printf("     i <file>       named include file <file>\n");
    printf("     i ( <files> )  named include file list <files>\n");
    printf("     m              macro expanded symbols\n");
    printf("  /I...     Include:\n");
    printf("     u              unreferenced   symbols\n");
    printf("  /o <file> output source database name\n");
    printf("  /n        no incremental (full builds, .sbr's preserved)\n");
    printf("  /v        verbose output\n");
    printf("  /help     Quick Help\n");
#ifdef DEBUG
    printf("  /d        show debugging information\n");
    printf("     1      sbrdump .sbr files as they come in\n");
    printf("     2      show every duplicate MbrAddAtom\n");
    printf("     4      emit warning on forward referenced ordinal\n");
    printf("     8      show prop data as new items are added\n");
    printf("     16     bscdump database after cleanup\n");
    printf("     32     emit information about what cleanup is doing\n");
    printf("     64     emit list of sorted modules after sorting\n");
    printf("     128    bscdump database before cleanup\n");
    printf("     256    give info about duplicate/excluded modules\n");
#endif
    exit(1);
}

FILE *fileResp;
int cargs;
char ** vargs;
int iarg = 1;
long lFilePosnLast;

LONG
GetArgPosn()
// save the current position on the command line
//
{
    if (fileResp)
        return lFilePosnLast;
    else
        return (LONG)iarg - 1;
}

VOID
SetArgPosn(LONG lArgPosn)
// restore the command line parsing position
//
{
    if (fileResp) {
        fseek(fileResp, lArgPosn, SEEK_SET);
        iarg = 0;
        }
    else
        iarg = (int)lArgPosn;
}

char *
NextArg()
// get the next argument from the response file or the command line
//
{
    static char buf[PATH_BUF];
    char *pch;
    int c;
    BOOL fQuote = FALSE;

    if (iarg >= cargs)
        return NULL;

    if (fileResp) {
        pch = buf;

        lFilePosnLast = ftell(fileResp);

        for (;;) {
            c = getc(fileResp);
            switch (c) {

            case '"':
                if (fQuote) {
                    *pch = '\0';
                    return buf;
                }
                else  {
                    fQuote = TRUE;
                    continue;
                }

            case EOF:
                iarg = cargs;
                if (pch == buf)
                    return NULL;

                *pch = '\0';
                return buf;

            case  ' ':
            case '\t':
            case '\r':
            case '\f':
            case '\n':
                if (fQuote)
                     goto quoted;

                if (pch == buf)
                    continue;

                *pch = '\0';
                return buf;

            default:
            quoted:
                if (pch < buf + sizeof(buf) - 1)
                    *pch++ = (char)c;
                break;
            }
        }
    }
    else
        return vargs[iarg++];
}

char *
ParseArgs(int argc, char **argv)
// parse the command line or response file
//
{
    char *respName;
    char *pchWord;
    int len;

    cargs = argc;
    vargs = argv;

    for (;;) {
        pchWord = NextArg();

        if (pchWord == NULL)
            return pchWord;

        if (pchWord[0] == '@') {

            if (fileResp)
                Error(ERR_BAD_RESPONSE, "");
            else if (pchWord[1])
                respName = pchWord+1;
            else if (!(respName = NextArg()))
                Error(ERR_BAD_RESPONSE, "");

            fileResp = fopen(respName, "r");

            if (!fileResp)
                Error(ERR_OPEN_FAILED, respName);

            cargs++;

            continue;
        }

        if (pchWord[0] != '-' && pchWord[0] != '/')
            return pchWord;

        switch (pchWord[1]) {

        case 'n':
                OptN = TRUE;
                break;

        case 'o':
            if (pchWord[2])
                pchWord += 2;
            else if (!(pchWord = NextArg()))
                Usage();

            OutputFileName = LszDupNewExt (pchWord, "bsc");
            break;

        #ifdef DEBUG
        case 'd':
            OptD = 1;
            if (pchWord[2]) OptD = atoi(pchWord+2);
            break;
        #endif

        case 'E':
            switch (pchWord[2]) {

            case 0:
                Error (ERR_MISSING_OPTION, pchWord);
                break;

            case 'm':
                OptEm = TRUE;
                break;

            case 's':
                OptEs = TRUE;
                break;

            default:
                Error2 (ERR_UNKNOWN_OPTION, pchWord[2], pchWord);
                break;

            case 'i':
                if (pchWord[3])
                    pchWord += 3;
                else
                    pchWord = NextArg();

                if (!pchWord)
                    Error (ERR_MISSING_OPTION, "-Ei");

                if (pchWord[0] != '(') {
                    AddExcludeFileList(pchWord);
                    break;
                }

                if (pchWord[1])
                    pchWord++;
                else
                    pchWord = NextArg();

                for ( ;pchWord != NULL; pchWord = NextArg()) {
                    len = strlen(pchWord);
                    if (pchWord[len-1] != ')') {
                        AddExcludeFileList(pchWord);
                    }
                    else if (len > 1) {
                        pchWord[len-1] = 0;
                        AddExcludeFileList(pchWord);
                        break;
                    }
                    else
                        break;
                }
                if (pchWord == NULL)
                    Error (ERR_MISSING_OPTION, "-Ei (...");
            }
            break;

        case 'I':
            switch (pchWord[2]) {
            case 'u':
                OptIu = TRUE;
                break;

            default:
                Error2 (ERR_UNKNOWN_OPTION, pchWord[2], pchWord);
                break;
            }
            break;

        case 'H':
        case 'h':
            if ((strcmpi (pchWord+1, "help")) == 0) {
                if (spawnlp (P_WAIT, "qh", "-u", "mbrmake.exe", NULL))
                    Usage();
                exit (0);
            }
            break;

        case 'v':
            OptV = TRUE;
            break;

        default:
            Warning (WARN_OPTION_IGNORED, pchWord);
            break;
        }
    }
}


static VOID
MarkNewSBR(char *lszName)
// mark the specified SBR file as requiring update
//
{
    int fh;
    char ch;

    if (!OutputFileName)
        OutputFileName = LszDupNewExt (lszName, "bsc");

    if ((fh = open(lszName, O_BINARY|O_RDONLY)) == -1) {
        Error(ERR_OPEN_FAILED, lszFName);
    }

    // if the file has non zero length then it is being updated -- else
    // it is just a stub that will not affect the database this time around
    //
    if (read(fh, &ch, 1) != 1)
        VaSbrAdd(SBR_NEW, lszName);             // to remain in .bsc
    else
        VaSbrAdd(SBR_NEW|SBR_UPDATE, lszName);  // to be re-installed in .bsc

    close (fh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\mbrwbsc.c ===
//
//
// mbRWBSC.C - Write .BSC Source Data Base file from various lists.
//
//

#define LINT_ARGS

#include <stdlib.h>
#include <search.h>
#include <ctype.h>

#include "sbrfdef.h"
#include "mbrmake.h"
#include "sbrbsc.h"
#include "mbrcache.h"

// prototypes
//

static void pascal WriteBSCHeader (void);
static void pascal WriteAtoms     (void);
static void pascal WriteMods      (void);
static void pascal WriteModSyms   (void);
static void pascal WriteSyms      (void);
static void pascal WriteProps     (void);
static void pascal WriteRefs      (void);
static void pascal WriteDefs      (void);
static void pascal WriteCals      (void);
static void pascal WriteCbys      (void);
static void pascal WriteSbrInfo   (void);
static void pascal IndexTree	  (void);
static void pascal BSCWrite	  (LPV lpv, WORD cch);
static void pascal BSCWriteLsz	  (LSZ lsz);

//

#define BSCOut(v) BSCWrite(&(v), sizeof(v))

static WORD	CntAtomPage;		// count of Atom pages
static WORD	AtomCnt = 0;

static WORD	unknownModName; 	// UNKNOWN module idx

static WORD	ModSymCnt   = 0;	// count of modsyms
static WORD	SymCnt	    = 0;	// count of symbols
static WORD	PropCnt     = 0;	// count of props
static DWORD	RefCnt	    = 0;	// count of refs
static WORD	DefCnt	    = 0;	// count of defs
static WORD	CbyCnt	    = 0;	// count of use half of above
static WORD	CalCnt	    = 0;	// count of used by half of above

static DWORD	lbModList;		// offset to Module	list
static DWORD	lbModSymList;		// offset to ModSym	list
static DWORD	lbSymList;		// offset to Symbol	list
static DWORD	lbPropList;		// offset to Property	list
static DWORD	lbRefList;		// offset to Reference	list
static DWORD	lbDefList;		// offset to Definition list
static DWORD	lbCalList;		// offset to Call/used	list
static DWORD	lbCbyList;		// offset to Call/used	list
static DWORD	lbAtomCache;		// offset to Sym Atom cache
static DWORD	lbSbrList;		// offset to Sbr file names

extern char far *GetAtomCache (WORD);

void
WriteBSC (char *OutputFileName)
// Write .BSC Source Data Base
//
{
    OutFile = fopen(OutputFileName, "wb");
    if (OutFile == NULL) {
	Error(ERR_OPEN_FAILED, OutputFileName);
    }

    //
    // no backing out from here --  if we fail we must delete the database
    //

    fOutputBroken = TRUE;

    WriteBSCHeader();				// save space for header

    WriteAtoms();				// sort and write atom cache

    IndexTree();				// xlate pointers to indices 

    BldModSymList();				// Build module symbol list

    SetVMClient(VM_EMIT_TREE);

    unknownModName = gSYM(vaUnknownSym).isym;	// record UNKNOWN index 

    WriteMods();				// output modules
    WriteModSyms();				// output module symbol lists
    WriteSyms();				// output all symbols
    WriteProps();				// output all prop headers
    WriteRefs();				// output all refs
    WriteDefs();				// output all defs
    WriteCals();				// output all uses/calls
    WriteCbys();				// output all UBY/CBY
    WriteSbrInfo();				// output the SBR file names

    if (fseek(OutFile, 0L, SEEK_SET))		// Beginning of file
	SeekError (OutputFileName);

    WriteBSCHeader ();				// output .BSC header

    fclose(OutFile);

    //
    // we're all done --- it's a keeper!
    //

    fOutputBroken = FALSE;
				
    SetVMClient(VM_MISC);

    if (OptV) {
	printf ("%u\tModules\n",	    ModCnt);
	printf ("%u\tSymbols\n",	    SymCnt);
	printf ("%u\tDefinitions\n",	    DefCnt);
	printf ("%u\tReferences\n",	    RefCnt);
	printf ("%u\tCalls/Uses\n",	    CalCnt);
	printf ("%u\tCalled by/Used by\n",  CbyCnt);
#ifdef DEBUG
	printf ("\n");
	printf ("%u\tTotal ModSyms\n",		ModSymCnt);
	printf ("%u\tTotal Properties\n",	PropCnt);
	printf ("%u\tLast Atom page  \n",	AtomCnt);
	printf ("\n");
	printf ("%lu\tBase of AtomCache\n",	lbAtomCache);
	printf ("%lu\tBase of ModList\n",	lbModList);
	printf ("%lu\tBase of ModSymList\n",	lbModSymList);
	printf ("%lu\tBase of SymList\n",	lbSymList);
	printf ("%lu\tBase of PropList\n",	lbPropList);
	printf ("%lu\tBase of RefList\n",	lbRefList);
	printf ("%lu\tBase of DefList\n",	lbDefList);
	printf ("%lu\tBase of CalList\n",	lbCalList);
	printf ("%lu\tBase of CbyList\n",	lbCbyList);
#endif
    }
}

static void pascal
WriteBSCHeader ()
// Write .BSC header, counts, and table offsets.
//
{
    BYTE   ver;					// version num

    // output BSC version (major and minor) 

    ver = BSC_MAJ;
    BSCOut(ver);	// major ver

    ver = BSC_MIN;
    BSCOut(ver);	// minor ver

    ver = BSC_UPD;
    BSCOut(ver);	// update ver

    BSCOut(fCase);      // case sensitive
    BSCOut(MaxSymLen);	// biggest symbol allowed

    BSCOut(unknownModName);	// UNKNOWN idx

    // output counts (sizes) of each data area 

    BSCOut(ModCnt);
    BSCOut(ModSymCnt);	
    BSCOut(SymCnt);	
    BSCOut(PropCnt);	
    BSCOut(RefCnt);	
    BSCOut(DefCnt);
    BSCOut(CalCnt);	
    BSCOut(CbyCnt);	

    // last page #

    BSCOut(CntAtomPage);

    // last page size

    BSCOut(AtomCnt);

    // output BSC  data area offsets

    BSCOut(lbModList);
    BSCOut(lbModSymList);
    BSCOut(lbSymList);
    BSCOut(lbPropList);
    BSCOut(lbRefList);
    BSCOut(lbDefList);
    BSCOut(lbCalList);
    BSCOut(lbCbyList);
    BSCOut(lbAtomCache);
    BSCOut(lbSbrList);
}

static void pascal
WriteAtoms ()
// Write a sorted version of the symbol Atom Cache to the .BSC file by walking
// the sorted symbol subscript array
//
{
    WORD	i;
    int 	Atomlen;
    LPCH	lpchAtoms;
    LSZ		lszAtom;

    VA vaSym;

    SetVMClient(VM_EMIT_ATOMS);

    lpchAtoms = LpvAllocCb(ATOMALLOC);

    lbAtomCache = ftell(OutFile);		// offset to text of symbols

    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);
	lszAtom = gTEXT(cSYM.vaNameText);

	Atomlen = strlen(lszAtom);

 	// write Atom page if not enough room
	//
	if (Atomlen + AtomCnt + 1 > ATOMALLOC) {
	    if (AtomCnt < ATOMALLOC)
	        memset(lpchAtoms + AtomCnt, 0, ATOMALLOC - AtomCnt);

	    if ((fwrite (lpchAtoms, ATOMALLOC, 1, OutFile)) != 1)
		WriteError (OutputFileName);

	    CntAtomPage++;
	    AtomCnt = 0;
	}

	strcpy(lpchAtoms + AtomCnt, lszAtom); // copy Atom

        cSYM.vaNameText = (PVOID)(((long)CntAtomPage << 16) | (AtomCnt));

	pSYM(vaSym);

	AtomCnt += Atomlen + 1;

	// force to even value
	if (AtomCnt & 1) lpchAtoms[AtomCnt++] = 0;
    }

    // write last Atom page
    //
    if (AtomCnt) 
	if ((fwrite (lpchAtoms, AtomCnt, 1, OutFile)) != 1)
	    WriteError (OutputFileName);

    // free all the memory for the atom cache, we no longer need it

    fflush (OutFile);

    FreeLpv(lpchAtoms);

    SetVMClient(VM_MISC);
}

static void pascal
WriteMods()
// write out the list of modules
//
// compute the MODSYM indices as we do this
//
{
    MODLIST bmod;
    VA vaMod;
    WORD i;

    ModSymCnt = 0;
    lbModList = ftell(OutFile); 	// offset to Module list

    for (i = cSymbolsMac; i < cAtomsMac; i++) {
	gSYM(rgvaSymSorted[i]);
	vaMod = cSYM.vaFirstProp;  	// points back to module, honest!
	gMOD(vaMod);

	bmod.ModName = gSYM(cMOD.vaNameSym).isym;	// module name	idx 
	ModSymCnt   += cMOD.csyms;
	bmod.mSymEnd = ModSymCnt;			// last ModSym idx +1 
	BSCOut(bmod);
    }
}

static void pascal
WriteModSyms()
// write out the list of modsyms
//
{
    MODSYMLIST	bmodsym;
    VA vaMod, vaModSym;
    WORD i;

    lbModSymList = ftell(OutFile);		// offset to ModSym list

    for (i = cSymbolsMac; i < cAtomsMac; i++) {
	gSYM(rgvaSymSorted[i]);
	vaMod = cSYM.vaFirstProp;  	// points back to module, honest!
	gMOD(vaMod);

	vaModSym = cMOD.vaFirstModSym;
	while (vaModSym) {
	    gMODSYM(vaModSym);

	    // Symbol Property idx
	    bmodsym.ModSymProp = gPROP(cMODSYM.vaFirstProp).iprp; 

	    BSCOut(bmodsym);

	    vaModSym = cMODSYM.vaNextModSym;
	}
    }
}

static void pascal
WriteSyms()
// write out the list of SYMs
//
{
    SYMLIST bsym;
    VA vaSym;
    WORD i;

    lbSymList = ftell(OutFile); 	    // offset to Symbol list

    PropCnt = 0;
    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);

	PropCnt	+= cSYM.cprop;

	bsym.PropEnd = PropCnt;			 	 // last Prop idx +1 
        bsym.Atom    = (WORD)((long)cSYM.vaNameText & 0xffff); // Atom cache offset
        bsym.Page    = (WORD)((long)cSYM.vaNameText >> 16);    // Atom cache page

	BSCOut(bsym);
    }
}

static void pascal
WriteProps ()
// write out the list of PROPS to the database
//
// the number of definitions (DefCnt), references (RefCnt),
// calls (CalCnt) and called-by (CbyCnt) items are computed at this time
//
// Each PROP is assigned numbers for its associated objects
//
{
    PROPLIST	bprop;
    VA vaSym, vaProp;
    WORD i;

    lbPropList = ftell(OutFile);	   // offset to Property list

    DefCnt  = 0;
    RefCnt  = 0L;
    CalCnt  = 0;
    CbyCnt  = 0;

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    gPROP(vaProp);
	    gSYM(cPROP.vaNameSym);

	    bprop.PropName = cSYM.isym;     // Symbol idx	     
	    bprop.PropAttr = cPROP.sattr;   // Property Attribute

	    DefCnt += CItemsList(cPROP.vaDefList);

	    bprop.DefEnd   = DefCnt;	    // last Definition idx +1 
					   
	    RefCnt += cPROP.cref;

	    bprop.RefEnd   = RefCnt;	    // last Reference idx +1  

	    CalCnt += CItemsList(cPROP.vaCalList);

	    bprop.CalEnd   = CalCnt;	    // last Calls/uses idx +1 

	    CbyCnt += CItemsList(cPROP.vaCbyList);

	    bprop.CbyEnd   = CbyCnt;	    // last Called by/used by idx +1 

	    BSCOut(bprop);

	    vaProp = cPROP.vaNextProp;
	}
    }
}

static void pascal
WriteRefs()
// write out the list of references
//
{
    REFLIST bref;
    VA vaSym, vaProp, vaRef;
    WORD i;

    lbRefList = ftell(OutFile); 		// offset to Reference list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    gPROP(vaProp);

	    vaRef = VaFrVp(cPROP.vpFirstRef);
	    while (vaRef) {
	        gREF(vaRef);

		gSYM(VaFrVp(cREF.vpFileSym));

		bref.RefNam = cSYM.isym; 	  // Symbol idx
		bref.RefLin = cREF.reflin; 	  // Symbol lin
	        bref.isbr   = cREF.isbr;	  // owner

		BSCOut(bref);

		vaRef = VaFrVp(cREF.vpNextRef);
	    }

	    vaProp = cPROP.vaNextProp;
	}
    }
}

static void pascal
WriteDefs()
// write out the list of defintions
//
{
    REFLIST	bdef;
    WORD i;
    VA vaProp, vaSym;

    lbDefList = ftell(OutFile);	 // offset to Definition list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    gPROP(vaProp);

	    ENM_LIST (cPROP.vaDefList, DEF)

		gSYM(cDEF.vaFileSym);

		bdef.RefNam = cSYM.isym;	 // Symbol idx
		bdef.RefLin = cDEF.deflin; 	 // Symbol lin 
	        bdef.isbr   = cDEF.isbr;	 // owner

		BSCOut(bdef);

	    ENM_END

	    vaProp = cPROP.vaNextProp;
	}
    }
}

static void pascal
WriteCals()
// write out the list of uses (CALs) items
//
{
    USELIST buse;
    PROP prop;
    VA   vaSym, vaProp;
    WORD i;

    lbCalList = ftell(OutFile);		    // offset to CAL list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    prop = gPROP(vaProp);

	    ENM_LIST(prop.vaCalList, CAL)

		gPROP(cCAL.vaCalProp);

		buse.UseProp = cPROP.iprp;	    // property idx
		buse.UseCnt  = (BYTE) cCAL.calcnt;  // use count  
	        buse.isbr    = cCAL.isbr;	    // owner

		BSCOut(buse);

	    ENM_END

	    vaProp = prop.vaNextProp;
	}
    }
    BSCOut(buse);				    // Pad
}

static void pascal
WriteCbys()
// write out the list of used-by (CBY) items
//
{
    USELIST buse;
    PROP prop;
    VA   vaSym, vaProp;
    WORD i;

    lbCbyList = ftell(OutFile);		    // offset to CBY list

    for (i=0; i < cSymbolsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	vaProp = gSYM(vaSym).vaFirstProp;

	while (vaProp) {
	    prop = gPROP(vaProp);

	    ENM_LIST(prop.vaCbyList, CBY)

		gPROP(cCBY.vaCbyProp);

		buse.UseProp = cPROP.iprp;	    // property idx
		buse.UseCnt  = (BYTE) cCBY.cbycnt;  // use count  
	        buse.isbr    = cCBY.isbr;	    // owner

		BSCOut(buse);

	    ENM_END

	    vaProp = prop.vaNextProp;
	}
    }
    BSCOut(buse);				    // Pad
}

static void pascal
WriteSbrInfo()
// write out the names of the .sbr files in the correct order
//
{
    VA   vaSbr;
    WORD isbr;
    VA   *rgVaSbr;

    lbSbrList = ftell(OutFile);

    rgVaSbr = (VA *)LpvAllocCb(SbrCnt * (WORD)sizeof(VA));

    for (isbr = 0; isbr < SbrCnt; isbr++)
	rgVaSbr[isbr] = vaNil;

    vaSbr = vaRootSbr;
    while (vaSbr) {
	gSBR(vaSbr);
	if (cSBR.isbr != -1)
	    rgVaSbr[cSBR.isbr] = vaSbr;

	vaSbr = cSBR.vaNextSbr;
    }

    for (isbr = 0; isbr < SbrCnt; isbr++) {
	if (rgVaSbr[isbr] != vaNil) {
	    gSBR(rgVaSbr[isbr]);
	    BSCWriteLsz(cSBR.szName);
	}
    }
    BSCWriteLsz("");
}

static void pascal
IndexTree ()
//  Walk all the list of all symbols and index each prop as we find it
//  at this point we also count the total number of defs + refs to
//  make sure that we can actually create this database
//
{
    VA vaSym, vaProp;
    DWORD cdefs = 0;
    DWORD crefs = 0;
    DWORD ccals = 0;
    DWORD ccbys = 0;
    WORD i;

    SetVMClient(VM_INDEX_TREE);

    SymCnt  = 0;
    PropCnt = 0;

    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);
	cSYM.isym = SymCnt++;	    // Symbol index
	pSYM(vaSym);

	// the vaFirstProp field is used for something else in module symbols
	if (cSYM.cprop)
	    vaProp = cSYM.vaFirstProp;
	else
	    vaProp = vaNil;

	while (vaProp) {
	    gPROP(vaProp);

	    cPROP.iprp 	= PropCnt++; 	    // Property index

	    cdefs += CItemsList(cPROP.vaDefList);
	    crefs += cPROP.cref;
	    ccals += CItemsList(cPROP.vaCalList);
	    ccbys += CItemsList(cPROP.vaCbyList);

	    pPROP(vaProp);

	    vaProp = cPROP.vaNextProp;
	}
    }
    SymCnt -= ModCnt;	// Subtract module names

    if (cdefs > 0xffffL   ||
	crefs > 0xffffffL ||
	ccals > 0xffffL   ||
	ccbys > 0xffffL) {
	    if (OptV) {
		printf ("%u\tModules\n",		ModCnt);
		printf ("%u\tSymbols\n",		SymCnt);
		printf ("%lu\tDefinitions\n",		cdefs);
		printf ("%lu\tReferences\n",		crefs);
		printf ("%lu\tCalls/Uses\n",		ccals);
		printf ("%lu\tCalled by/Used by\n",	ccbys);
	    }
	    Error(ERR_CAPACITY_EXCEEDED, "");
    }

    SetVMClient(VM_MISC);
}

static void pascal
BSCWrite(LPV lpv, WORD cch)
// write block to the .bsc file
//
{
    if (fwrite(lpv, cch, 1, OutFile) != 1)
	WriteError (OutputFileName);
}

static void pascal
BSCWriteLsz(LSZ lsz)
// write a null terminated string to the BSC file
//
{
    BSCWrite(lsz, (WORD)(strlen(lsz)+1));
}


#ifdef DEBUG

void
DebugDump()
{
    VA vaMod, vaProp, vaSym;
    WORD i;

    vaMod = vaRootMod;
    printf("Modules:\n");
    while (vaMod) {
	gMOD(vaMod);
	printf ("\t%s\n", GetAtomStr (cMOD.vaNameSym));
	vaMod = cMOD.vaNextMod;
    }
    printf ("\nAll Symbols:\n");

    for (i=0; i < cAtomsMac; i++) {
	vaSym = rgvaSymSorted[i];
    	if (vaSym == vaNil) continue;

	gSYM(vaSym);

	// the vaFirstProp field is used for something else in module symbols
	if (cSYM.cprop)
	    vaProp = cSYM.vaFirstProp;
	else
	    vaProp = vaNil;

	while (vaProp) {
	    gPROP(vaProp);

	    DebugDumpProp(vaProp);

	    vaProp = gPROP(vaProp).vaNextProp;
	}
    }
}

void
DebugDumpProp(VA vaProp)
{
    PROP prop;
    VA vaRef;

    gPROP(vaProp);
    prop = cPROP;

    printf ("%s    ", GetAtomStr (prop.vaNameSym));
    printf ("\t\t[%d %d %d %d]\n",
		CItemsList(prop.vaDefList),
		prop.cref,
		CItemsList(prop.vaCalList),
		CItemsList(prop.vaCbyList)
	   );

    ENM_LIST(prop.vaDefList, DEF)

	printf ("\tdefined in %s(%d)  <%d>\n",
		GetAtomStr (cDEF.vaFileSym),
		cDEF.deflin,
		cDEF.isbr
	       );
    ENM_END

    vaRef = VaFrVp(prop.vpFirstRef);
    while (vaRef) {
	gREF(vaRef);

	printf ("\trefer'd in %s(%d)  <%d>\n",
		GetAtomStr ( VaFrVp(cREF.vpFileSym) ),
		cREF.reflin,
		cREF.isbr
	       );

	vaRef = VaFrVp(cREF.vpNextRef);
    }

    ENM_LIST(prop.vaCalList, CAL)

	printf ("\tcalls/uses %s[%d]  <%d>\n",
		GetAtomStr (gPROP(cCAL.vaCalProp).vaNameSym), 
		cCAL.calcnt,
		cCAL.isbr
	       );
    ENM_END

    ENM_LIST(prop.vaCbyList, CBY)

	printf ("\tc-by/u-by %s[%d]  <%d>\n",
		GetAtomStr (gPROP(cCBY.vaCbyProp).vaNameSym), 
		cCBY.cbycnt,
		cCBY.isbr
	       );
    ENM_END

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\ord.c ===
//
// ORD.C - Keep track of ordinals in the current .sbr file
//
//

#include "mbrmake.h"

static WORD near cOrdFree;	// number of free ords in this block
static VA   near vaOrdNext;	// the next free ord
static VA   near vaOrdBase;	// the first ord in this block
static VA   near vaOrdRoot;	// the first ord block

// ordinals may be sparse so they are hashed
//
// number of hash buckets

#define PORD_MAX 512
#define HASH_ORD(ord) ((ord)&511)

static VA   near rgvaOrd[PORD_MAX];		// array of linked-lists

// allocation blocking (ORD_BLOCK objects per alloc)
#define ORD_BLOCK 128

VOID
FreeOrdList()
// free the ordinal alias list
//
{
    int i;

    // clean the hash table
    for (i=0; i<PORD_MAX; i++) 
	rgvaOrd[i] = vaNil;

    vaOrdBase = vaOrdRoot;
    vaOrdNext = (PBYTE)vaOrdRoot + sizeof(ORD);
    cOrdFree  = ORD_BLOCK - 1;
}


VA
VaOrdFind (WORD ord)
// search for the specified ord, return the corresponding PROP entry
// return vaNil if not found
//
{
    VA vaOrd;

    SetVMClient(VM_SEARCH_ORD);

    vaOrd = rgvaOrd[HASH_ORD(ord)];

    while (vaOrd) {
	if (ord == gORD(vaOrd).aliasord) {
	    SetVMClient(VM_MISC);
	    return(cORD.vaOrdProp);
	}
	else
	    vaOrd = cORD.vaNextOrd;
    }

    SetVMClient(VM_MISC);
    return(vaNil);
}

VA
VaOrdAdd()
//  Add the symbol ordinal to the alias list.
//
{
    VA	vaOrdNew;

    SetVMClient(VM_ADD_ORD);

    if (cOrdFree--) {
	vaOrdNew   = vaOrdNext;
        vaOrdNext  = (PBYTE)vaOrdNext + sizeof(ORD);
    }
    else if (vaOrdBase && gORD(vaOrdBase).vaNextOrd) { 
	// if there is an old allocated block that we can re-use, then do so
	vaOrdBase  = cORD.vaNextOrd;
        vaOrdNew   = (PBYTE)vaOrdBase + sizeof(ORD);
        vaOrdNext  = (PBYTE)vaOrdNew  + sizeof(ORD);
	cOrdFree   = ORD_BLOCK - 2;
    }
    else {

	// allocate a new block -- keep a backwards pointer in this block

	vaOrdNew   = VaAllocGrpCb(grpOrd, sizeof(ORD) * ORD_BLOCK);

	if (!vaOrdRoot)
	    vaOrdRoot = vaOrdNew;

	if (vaOrdBase) {
	    gORD(vaOrdBase);
	    cORD.vaNextOrd = vaOrdNew;
	    pORD(vaOrdBase);
	}

	vaOrdBase   = vaOrdNew;
        (PBYTE)vaOrdNew   += sizeof(ORD);
        vaOrdNext   = (PBYTE)vaOrdNew  + sizeof(ORD);
	cOrdFree    = ORD_BLOCK - 2;
    }

    gORD(vaOrdNew).aliasord = r_ordinal;
    cORD.vaNextOrd = rgvaOrd[HASH_ORD(r_ordinal)];
    rgvaOrd[HASH_ORD(r_ordinal)] = vaOrdNew;
    pORD(vaOrdNew);

    SetVMClient(VM_MISC);

    return(vaOrdNew);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\owner.c ===
//
// owner.c :  this code manipulates the SBR records for keeping track of
//	      what SBR file owns a particular DEF/REF
//

#include "mbrmake.h"

VA    near vaRootSbr;	// head of SBR list
VA    near vaTailSbr;	// tail of SBR list
WORD  near SbrCnt;	// count of sbr files

VA
VaSbrAdd(WORD fUpdate, LSZ lszName)
// add a new sbr entry to the list -- we promise that cSBR will be the
// setup for the newly added vaSbr
//
{
    WORD cb;
    VA vaSbr;

    vaSbr = vaRootSbr;
    
    while (vaSbr) {
	gSBR(vaSbr);
	if (strcmpi(cSBR.szName, lszName) == 0) {
    	    cSBR.fUpdate   |= fUpdate;
    	    pSBR(vaSbr);
	    return vaSbr;
	}
        vaSbr = cSBR.vaNextSbr;
    }

    cb = strlen(lszName);

    vaSbr = VaAllocGrpCb(grpSbr, sizeof(SBR) + cb);

    gSBR(vaSbr);
    cSBR.vaNextSbr  = vaNil;
    cSBR.fUpdate   |= fUpdate;
    cSBR.isbr       = -1;
    strcpy(cSBR.szName, lszName);
    pSBR(vaSbr);


    if (vaTailSbr) {
	gSBR(vaTailSbr);
	cSBR.vaNextSbr = vaSbr;
	pSBR(vaTailSbr);
    }
    else
        vaRootSbr = vaSbr;
    vaTailSbr = vaSbr;

    gSBR(vaSbr);

    SbrCnt++;
    return vaSbr;
}

VA
VaSbrFrName(LSZ lszName)
// find the .sbr entry matching the given name
//
{
    VA vaSbr;

    vaSbr = vaRootSbr;
    
    while (vaSbr) {
	gSBR(vaSbr);
	if (strcmp(cSBR.szName, lszName) == 0)
	    return vaSbr;
        vaSbr = cSBR.vaNextSbr;
    }
    return vaNil;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\mbrmake.h ===
#define MAXSYMPTRTBLSIZ 4095		// max symbol pointer table size
#define PATH_BUF	512		// path buffer size


#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <stdio.h>
#include <string.h>

#if defined (OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif


#include "hungary.h"
#include "vm.h"
#include "list.h"
#include "errors.h"



//  rjsa 10/22/90
//  Some runtime library functions are broken, so intrinsics have
//  to be used.
//	BUGBUG
//#pragma intrinsic (memset, memcpy, memcmp)
//#pragma intrinsic (strset, strcpy, strcmp, strcat, strlen)

#ifndef LINT_PROTO
#include "sbrproto.h"
#endif

#pragma pack(1)

#if rjsa
extern void far * cdecl _fmalloc(unsigned int);
extern void 	  cdecl	_ffree(void far *);
extern char *	  cdecl	getenv(const char *);
extern char *	  cdecl	mktemp(char *);
extern char *     cdecl strdup(const char *);
#endif

// typedef char flagType;

typedef struct {
	VA	vaNextMod;		// next module		   
	VA	vaNameSym;		// name Symbol 
	VA	vaFirstModSym;		// first ModSym for this file
	VA	vaLastModSym;		// last ModSym for this file
	WORD	csyms; 			// symbol count
} MOD;

typedef struct {
	VA	vaNextModSym;		// next symbol
	VA	vaFirstProp;		// first prop entry for this symbol
} MODSYM;

typedef struct {
	VA	vaNextSym;		// next symbol
	VA	vaFirstProp;		// first prop entry for this symbol
	VA	vaNameText;		// the text of this symbol
	WORD	cprop;			// Property count
	WORD	isym;			// this symbol index
} SYM;

typedef struct {
	VA	vaNextProp;		// next property
	WORD	iprp;			// this property index
	WORD	sattr;			// attribute
	WORD	cref;
	VA	vaNameSym;		// symbol name ptr
	VA	vaDefList;		// def chain
	VP	vpFirstRef;		// ref head
	VP	vpLastRef;		// ref tail
	VA	vaCalList;		// cal chain
	VA	vaCbyList;		// cby chain
	VA	vaHintRef;		// last ref we found by searching
} PROP;

typedef struct {
	VA	vaFileSym;		// file name Symbol ptr
	WORD	deflin;		 	// def line #
	WORD	isbr;			// sbr file owning this DEF
} DEF;

typedef struct {
	VP	vpNextRef;		// next ref in list
	VP	vpFileSym;		// file name Symbol ptr
	WORD	reflin; 		// ref line #
	WORD	isbr;			// sbr file owning this REF
} REF;

typedef struct {
	VA	vaCalProp; 		// prop called/used
	WORD	calcnt; 		// times called
	WORD	isbr;			// sbr file owning this CAL
} CAL;

typedef struct {
	VA	vaCbyProp; 		// prop calling/using
	WORD	cbycnt; 		// times  calling/using
	WORD	isbr;			// sbr file owning this CBY
} CBY;

typedef struct {
	VA	vaNextOrd; 		// next ord
	VA	vaOrdProp;		// prop item alias goes to
	WORD	aliasord;		// ordinal
} ORD;

typedef struct {
	VA	vaNextSbr;		// next sbr
	WORD	isbr;			// index for this SBR file
	BOOL	fUpdate;		// is this SBR file being updated?
	char	szName[1];		// name
} SBR;

typedef struct {
	VA	vaOcrProp;		// prop occurring
	WORD	isbr;			// SBR file it occurs in
} OCR;

typedef struct exclink {
	struct exclink FAR *xnext;	// next exclusion
	LPCH   pxfname;			// exclude file name
} EXCLINK, FAR *LPEXCL;

#include "extern.h"

// macros to 'g'et an item of the specified type from VM space

#ifdef SWAP_INFO

#define gMOD(va)    (*(iVMGrp = grpMod,    modRes    = LpvFromVa(va,1)))
#define gMODSYM(va) (*(iVMGrp = grpModSym, modsymRes = LpvFromVa(va,2)))
#define gSYM(va)    (*(iVMGrp = grpSym,    symRes    = LpvFromVa(va,3)))
#define gPROP(va)   (*(iVMGrp = grpProp,   propRes   = LpvFromVa(va,4)))
#define gDEF(va)    (*(iVMGrp = grpDef,    defRes    = LpvFromVa(va,5)))
#define gREF(va)    (*(iVMGrp = grpRef,    refRes    = LpvFromVa(va,6)))
#define gCAL(va)    (*(iVMGrp = grpCal,    calRes    = LpvFromVa(va,7)))
#define gCBY(va)    (*(iVMGrp = grpCby,    cbyRes    = LpvFromVa(va,8)))
#define gORD(va)    (*(iVMGrp = grpOrd,    ordRes    = LpvFromVa(va,9)))
#define gSBR(va)    (*(iVMGrp = grpSbr,    sbrRes    = LpvFromVa(va,13)))
#define gTEXT(va)   ((iVMGrp = grpText,    textRes   = LpvFromVa(va,12)))
#define gOCR(va)    (*(iVMGrp = grpOcr,    ocrRes    = LpvFromVa(va,14)))

#else

#define gMOD(va)    (*(modRes    = LpvFromVa(va,1)))
#define gMODSYM(va) (*(modsymRes = LpvFromVa(va,2)))
#define gSYM(va)    (*(symRes    = LpvFromVa(va,3)))
#define gPROP(va)   (*(propRes   = LpvFromVa(va,4)))
#define gDEF(va)    (*(defRes    = LpvFromVa(va,5)))
#define gREF(va)    (*(refRes    = LpvFromVa(va,6)))
#define gCAL(va)    (*(calRes    = LpvFromVa(va,7)))
#define gCBY(va)    (*(cbyRes    = LpvFromVa(va,8)))
#define gORD(va)    (*(ordRes    = LpvFromVa(va,9)))
#define gSBR(va)    (*(sbrRes    = LpvFromVa(va,13)))
#define gTEXT(va)   ((textRes    = LpvFromVa(va,12)))
#define gOCR(va)    (*(ocrRes	 = LpvFromVa(va,14)))

#endif

// macros to 'p'ut an item of the specified type to VM space

#define pMOD(va)    DirtyVa(va)
#define pMODSYM(va) DirtyVa(va)
#define pSYM(va)    DirtyVa(va)
#define pPROP(va)   DirtyVa(va)
#define pDEF(va)    DirtyVa(va)
#define pREF(va)    DirtyVa(va)
#define pCAL(va)    DirtyVa(va)
#define pCBY(va)    DirtyVa(va)
#define pORD(va)    DirtyVa(va)
#define pSBR(va)    DirtyVa(va)
#define pTEXT(va)   DirtyVa(va)
#define pOCR(va)    DirtyVa(va)

// these macros allow access to the 'c'urrent visible item

#define cMOD	    (*modRes)
#define cMODSYM     (*modsymRes)
#define cSYM	    (*symRes)
#define cPROP	    (*propRes)
#define cDEF	    (*defRes)
#define cREF	    (*refRes)
#define cCAL	    (*calRes)
#define cCBY	    (*cbyRes)
#define cORD	    (*ordRes)
#define cSBR	    (*sbrRes)
#define cTEXT	    (textRes)
#define cOCR	    (*ocrRes)

#define grpSym		0
#define grpMod		1
#define grpOrd		2
#define grpProp		3
#define grpModSym	4
#define grpDef		5
#define grpRef		6
#define grpCal		7
#define grpCby		8
#define grpList		9
#define grpText		10
#define grpSbr		11
#define grpOcr		12

#define SBR_OLD		(1<<0)		// this .sbr file used to exist
#define SBR_NEW		(1<<1)		// this .sbr file currently exists
#define SBR_UPDATE	(1<<2)		// this .sbr file is to be updated

// 
// this is used to add items to the tail of the lists in a property group
//
// things being added 	type    m
// ------------------	----	---
// Refs			Ref	REF
// Defs			Def	DEF
// Calls/Uses		Cal	CAL
// Called by/Used By	Cby	CBY
//

#define AddTail(type, m)		 \
{					 \
    VP vpT;				 \
    VA vaT;				 \
    MkVpVa(vpT, va##type);		 \
    vaT = VaFrVp(cPROP.vpLast##type);	 \
    if (vaT) {				 \
	g##m(vaT).vpNext##type = vpT;	 \
	p##m(vaT);			 \
    }					 \
    else {				 \
	cPROP.vpFirst##type = vpT;	 \
    }					 \
    cPROP.vpLast##type = vpT;		 \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\profile.h ===
/*  profile.h - definitions for profile.dll */

extern	word far pascal PROFCLEAR (int);
extern	word far pascal PROFDUMP (int,FPC);
extern	word far pascal PROFFREE (int);
extern	word far pascal PROFINIT (int,FPC);
extern	word far pascal PROFOFF (int);
extern	word far pascal PROFON (int);

#define     PROF_SHIFT	    2	    /* Power of 2 profile granularity */

#define     MOD_NAME_SIZE  10	    /* size of module name */

/*  Profile flags */
#define     PT_SYSTEM	    0	/* select system profiling */
#define     PT_USER	    1	/* select user profiling */

#define	    PT_USEDD	    2	/* tell PROFON to call profile DD */
#define	    PT_USEKP	    4	/* Do kernel-support profiling */
#define	    PT_VERBOSE	    8	/* Also collect detail kernel tics */
#define	    PT_NODD	    0	/* tell PROFON not to call profile DD */


/*  Profiling SCOPE
*   ---------------
*	PT_SYSTEM
*	    Profile the ENTIRE system;
*	    Exists for the use of tools like PSET, which gather data on
*	    system behavior.  Avoids need to write/modify test programs.
*
*	PT_USER (i.e., PT_SYSTEM not specified)
*	    Profile ONLY in the context of the calling process;
*	    Exists to gather data on an individual program and those parts of
*	    the system exercised by that program.
*
*   Profiling Configuration
*   -----------------------
*	PT_USEDD
*	    Call PROFILE device driver, if installed, on every timer tick.
*	    Used by Presentation Manager "attributed" profiling, in
*	    particular.  Allows for arbitrary actions at "profile" time.
*
*	PT_USEKP
*	    Cause kernel to record profiling information;
*	    These are the 4-byte granularity tick counts kept for each
*	    code segment of interest.  Making this optional allows one to
*	    do PT_USEDD profiling without taking the memory hit of Kernel
*	    Profiling.
*
*	PT_VERBOSE
*	    Collect detailed tick counts on KERNEL code segments;
*	    Works only if PT_USEKP also specified.  Generally useful
*	    only for kernel programmers tuning the kernel.
*
*
*	The above flags can be used in any combination, with the exception
*	that PT_VERBOSE is allowed only if PT_USEKP is also specified.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\readbsc.c ===
//
// readbsc.c -- read in a .BSC file and install in mbrmake's vm space
//
//	Copyright <C> 1988, Microsoft Corporation
//
// Revision History:
//
//	13-Aug-1989 rm	Extracted from mbrapi.c
//

#define LINT_ARGS

#include "mbrmake.h"

#include <stddef.h>

#include "mbrcache.h"

#include "sbrfdef.h"		// sbr attributes
#include "sbrbsc.h"

typedef struct _sbrinfo {
    WORD fUpdate;
    WORD isbr;
} SI, far *LPSI;			// sbr info

#define LISTALLOC 50		// Browser max list size

typedef WORD IDX;

// these will be initialized by the reading of the .bsc file
//
//	fCase;			TRUE for case compare
//	MaxSymLen;		longest symbol length
//	ModCnt; 		count of modules
//	SbrCnt;			count of sbr files
//	vaUnknownSym;		unknown symbol
//	vaUnknownMod;		unknown module
//

// static data

static BOOL		fIncremental;		// update will be incremental
static BOOL		fFoundSBR;		// at least .sbr file matched

static int		fhBSC = 0;		// .BSC file handle

static IDX 		Unknown;		// UNKNOWN symbol index

static WORD	 	ModSymCnt;		// count of modsyms
static WORD 		SymCnt; 		// count of symbols
static WORD 		PropCnt;		// count of properties
static DWORD		RefCnt; 		// count of references
static WORD 		DefCnt; 		// count of definitions
static WORD 		CalCnt; 		// count of calls
static WORD 		CbyCnt; 		// count of called bys
static WORD 		lastAtomPage;		// last atom page #
static WORD 		lastAtomCnt;		// last atom page size

static WORD 		cbModSymCnt;		// size of list of modsyms
static WORD 		cbSymCnt;		// size of list of symbols
static WORD 		cbPropCnt;		// size of list of properties
static WORD 		cbRefCnt;		// size of list of references
static WORD 		cbDefCnt;		// size of list of definitions
static WORD 		cbCalCnt;		// size of list of calls
static WORD 		cbCbyCnt;		// size of list of called bys

static WORD 		MaxModSymCnt;		// max list of modsyms
static WORD 		MaxSymCnt;		// max list of symbols
static WORD 		MaxPropCnt;		// max list of properties
static WORD 		MaxRefCnt;		// max list of references
static WORD 		MaxDefCnt;		// max list of definitions
static WORD 		MaxCalCnt;		// max list of calls
static WORD 		MaxCbyCnt;		// max list of called bys

static DWORD		lbModSymList;		// modsym    list file start
static DWORD		lbSymList;		// symbol    list file start
static DWORD		lbPropList;		// property  list file start
static DWORD		lbRefList;		// reference list file start
static DWORD		lbDefList;		// defintion list file start
static DWORD		lbCalList;		// call      list file start
static DWORD		lbCbyList;		// called by list file start
static DWORD		lbSbrList;		// sbr       list file start
static DWORD		lbAtomCache;		// atom     cache file start

static WORD 		CurModSymPage = 0;	// Current page of modsyms
static WORD 		CurSymPage    = 0;	// Current page of symbols
static WORD 		CurPropPage   = 0;	// Current page of properties
static WORD 		CurRefPage    = 0;	// Current page of references
static WORD 		CurDefPage    = 0;	// Current page of defintions
static WORD 		CurCalPage    = 0;	// Current page of calls
static WORD 		CurCbyPage    = 0;	// Current page of called bys

static LSZ		lszBSCName    = NULL;	// name of .bsc file

static MODLIST     far 	*pfModList;		// module    list cache start
static MODSYMLIST  far 	*pfModSymList;		// modsym    list cache start
static SYMLIST     far 	*pfSymList;		// symbol    list cache start
static PROPLIST    far 	*pfPropList;		// property  list cache start
static REFLIST     far 	*pfRefList;		// reference list cache start
static REFLIST     far 	*pfDefList;		// def'n     list cache start
static USELIST     far 	*pfCalList;		// calls     list cache start
static USELIST     far 	*pfCbyList;		// call bys  list cache start

static WORD 		AtomPageTblMac; 		// last cache page used
static CACHEPAGE	AtomPageTbl[MAXATOMPAGETBL];	// Atom Cache table

#define bMOD(imod)	(pfModList[imod])
#define bMODSYM(isym)	(pfModSymList[ModSymPAGE(isym)])
#define bSYM(isym)	(pfSymList[SymPAGE(isym)])
#define bPROP(iprop)	(pfPropList[PropPAGE(iprop)])

#define bREF(iref)	(pfRefList[RefPAGE(iref)])
#define bDEF(idef)	(pfDefList[DefPAGE(idef)])

#define bCAL(iuse)	(pfCalList[CalPAGE(iuse)])
#define bCBY(iuse)	(pfCbyList[CbyPAGE(iuse)])
#define bUSE(iuse)	(pfCalList[CalPAGE(iuse)])
#define bUBY(iuse)	(pfCbyList[CbyPAGE(iuse)])

#define BSCIn(v) ReadBSC(&v, sizeof(v))

// prototypes
//

static VOID	GetBSCLsz(LSZ lsz);
static VOID	GetBSC (DWORD lpos, LPV lpv, WORD cb);
static VOID	ReadBSC(LPV lpv, WORD cb);
static IDX	SwapPAGE (DWORD, LPV, WORD, WORD, WORD *, DWORD);
static LPCH	GetAtomCache (WORD);
static WORD   	ModSymPAGE(WORD idx);
static WORD   	SymPAGE(WORD  idx);
static WORD   	PropPAGE(WORD idx);
static WORD   	RefPAGE(DWORD idx);
static WORD   	DefPAGE(WORD idx);
static WORD   	CalPAGE(WORD idx);
static WORD   	CbyPAGE(WORD idx);
static LSZ	LszNameFrIsym(WORD isym);
static LPSI	LpsiCreate(VOID);

static VOID
GetBSCLsz(LSZ lsz)
// read a null terminated string from the current position in the BSC file
//
{
    for (;;) {
    	if (read(fhBSC, lsz, 1) != 1)
	    ReadError(lszBSCName);
	if (*lsz++ == 0) return;
    }
}

static VOID
ReadBSC(LPV lpv, WORD cb)
// read a block of data from the BSC file
//
// the requested number of bytes MUST be present
//
{
    if (read(fhBSC, lpv, cb) != (int)cb)
	ReadError(lszBSCName);
}

static VOID
GetBSC(DWORD lpos, LPV lpv, WORD cb)
// Read a block of the specified size from the specified position
//
// we have to be tolerant of EOF here because the swapper might ask
// for a whole block when only block when only part of a block is actually 
// is actually present
//
{
    if (lseek(fhBSC, lpos, SEEK_SET) == -1)
	SeekError(lszBSCName);

    if (read(fhBSC, lpv, cb) == -1)
	ReadError(lszBSCName);
}

static IDX
SwapPAGE (DWORD lbuflist, LPV pfTABLE, WORD tblsiz,
/* */      WORD lstsiz, WORD * pcurpage, DWORD idx)
// SwapPAGE -	Swap in the table page for the table pfTABLE[idx]
//		and return the table's new index in the page.
{
    WORD page;
    IDX	 newidx;

    page   = (WORD)(idx / lstsiz);
    newidx = (WORD)(idx % lstsiz);

    if (page == *pcurpage)
	return newidx;

    GetBSC(lbuflist+((long)tblsiz*(long)page), pfTABLE, tblsiz);

    *pcurpage = page;
    return newidx;
}

static IDX
ModSymPAGE (IDX idx)
// Swap in the ModSym page for ModSym[idx]
// return the ModSym's index in the page.
//
{
	return SwapPAGE (lbModSymList, pfModSymList,
		cbModSymCnt, MaxModSymCnt, &CurModSymPage, (DWORD)idx);
}

static IDX
SymPAGE (IDX idx)
// Swap in the Symbol page for symbol[idx]
// return the Symbol's index in the page.
//
{
	return SwapPAGE (lbSymList, pfSymList,
		cbSymCnt, MaxSymCnt, &CurSymPage, (DWORD)idx);
}

static IDX
PropPAGE (IDX idx)
// Swap in the Property page for Property[idx]
// return the Property's index in the page.
//
{
	return SwapPAGE (lbPropList, pfPropList,
		cbPropCnt, MaxPropCnt, &CurPropPage, (DWORD)idx);
}

static IDX
RefPAGE (DWORD idx)
// Swap in the Reference page for Reference[idx]  (ref/def)
// return the Reference's index in the page.
//
{
    return SwapPAGE (lbRefList, pfRefList,
		cbRefCnt, MaxRefCnt, &CurRefPage, idx);
}

static IDX
DefPAGE (IDX idx)
// Swap in the Reference page for Defintions[idx]  (ref/def)
// return the Reference's index in the page.
//
{
    return SwapPAGE (lbDefList, pfDefList,
		cbDefCnt, MaxDefCnt, &CurDefPage, (DWORD)idx);
}

static IDX
CalPAGE (IDX idx)
// Swap in the Usage page for Usage[idx]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCalList, pfCalList,
		cbCalCnt, MaxCalCnt, &CurCalPage, (DWORD)idx);
}

static IDX
CbyPAGE (IDX idx)
// Swap in the Usage page for Usage[idx]  (cal/cby)
// and return the Usage's index in the page.
//
{
    return SwapPAGE (lbCbyList, pfCbyList,
		cbCbyCnt, MaxCbyCnt, &CurCbyPage, (DWORD)idx);
}

static LPCH
GetAtomCache (WORD Page)
// load the requested page into the cache
//
{
    WORD ipg;
    WORD pagesize;
    LPCH pfAtomCsave;

    for (ipg = 0; ipg < AtomPageTblMac; ipg++) {
	if (AtomPageTbl[ipg].uPage == Page)
	    return AtomPageTbl[ipg].pfAtomCache;
    }
    if (ipg == AtomPageTblMac && ipg != MAXATOMPAGETBL)
	AtomPageTblMac++;

    pfAtomCsave = AtomPageTbl[MAXATOMPAGETBL-1].pfAtomCache;
    for (ipg = MAXATOMPAGETBL-1; ipg; ipg--)
	AtomPageTbl[ipg] = AtomPageTbl[ipg-1];		// move up

    AtomPageTbl[0].pfAtomCache = pfAtomCsave;
    AtomPageTbl[0].uPage = Page;

    if (Page == lastAtomPage)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    GetBSC(lbAtomCache+ATOMALLOC*(long)Page,
		AtomPageTbl[0].pfAtomCache, pagesize);

    return AtomPageTbl[0].pfAtomCache;
}

static LSZ
LszNameFrIsym (IDX isym)
// Swap in the Atom page for the symbol isym
// return the atom's address in the page.
//
{
    SYMLIST sym;

    sym = bSYM(isym);
    return GetAtomCache (sym.Page) + sym.Atom;
}

VOID
CloseBSC()
// close database and free as much memory as possible
// return TRUE iff successful.
//
{
    int i;

    if (fhBSC) {		// if open then close, & free memory

	FreeLpv (pfModList);	// module     table
	FreeLpv (pfModSymList);	// modsym     table
	FreeLpv (pfSymList);	// symbol     table
	FreeLpv (pfPropList);	// property   table
	FreeLpv (pfRefList);	// reference  table
	FreeLpv (pfDefList);	// definition table
	FreeLpv (pfCalList);	// call       table
	FreeLpv (pfCbyList);	// called by  table

	for (i=0; i < MAXATOMPAGETBL; i++)
	    FreeLpv (AtomPageTbl[i].pfAtomCache);  // dispose Atom Cache

	close (fhBSC);
    }
}


BOOL
FOpenBSC (LSZ lszName)
//  Open the specified data base.
//  Allocate buffers for cache areas
//  Initialize the data cache from the data base.
//
//  Return TRUE iff successful, FALSE if database can't be read
//
{
    int 	i;
    WORD	pagesize;

    BYTE	MajorVer;		// .bsc version (major)
    BYTE	MinorVer;		// .bsc version (minor)
    BYTE	UpdatVer;		// .bsc version (updat)

    WORD	MaxModCnt;		// max list of modules
    WORD	cbModCnt;		// size of list of modules
    DWORD	lbModList;		// module  list file start

    lszBSCName = lszName;

    fhBSC = open(lszBSCName, O_BINARY|O_RDONLY);

    // if the .bsc file doesn't exist then we don't do any work
    // this is the cold compile case
    //

    if (fhBSC == -1)
	return FALSE;

    // read and check BSC version (major, minor and update)

    BSCIn(MajorVer);
    BSCIn(MinorVer);
    BSCIn(UpdatVer);

#ifdef DEBUG
    printf("Browser Data Base: %s ver %d.%d.%d\n\n",
	 lszBSCName, MajorVer, MinorVer, UpdatVer);
#endif

    if ((MajorVer !=  BSC_MAJ) ||
	(MinorVer !=  BSC_MIN) ||
	(UpdatVer !=  BSC_UPD))
	    return FALSE;


    // we will be attempting an incremental update

    fIncremental = TRUE;

    // read Case sense switch, max symbol length and Unknown module id

    BSCIn(fCase);
    BSCIn(MaxSymLen);
    BSCIn(Unknown);

    // read counts (sizes) of each data area

    BSCIn(ModCnt);
    BSCIn(ModSymCnt);
    BSCIn(SymCnt);
    BSCIn(PropCnt);
    BSCIn(RefCnt);
    BSCIn(DefCnt);
    BSCIn(CalCnt);
    BSCIn(CbyCnt);
    BSCIn(lastAtomPage);
    BSCIn(lastAtomCnt);

    // read BSC data area offsets

    BSCIn(lbModList);
    BSCIn(lbModSymList);
    BSCIn(lbSymList);
    BSCIn(lbPropList);
    BSCIn(lbRefList);
    BSCIn(lbDefList);
    BSCIn(lbCalList);
    BSCIn(lbCbyList);
    BSCIn(lbAtomCache);
    BSCIn(lbSbrList);

    // determine data cache area sizes

    #define MIN(a,b) ((a)>(b) ? (b) : (a))

    MaxModCnt	 = ModCnt;				// max list of modules
    MaxModSymCnt = MIN(ModSymCnt , LISTALLOC);		// max list of modsyms
    MaxSymCnt	 = MIN(SymCnt+ModCnt, LISTALLOC);	// max list of symbols
    MaxPropCnt   = MIN(PropCnt   , LISTALLOC);		// max list of props
    MaxRefCnt    = (WORD)MIN(RefCnt, (long)LISTALLOC);	// max list of refs
    MaxDefCnt    = MIN(DefCnt    , LISTALLOC);		// max list of defs
    MaxCalCnt    = MIN(CalCnt    , LISTALLOC);		// max list of cals
    MaxCbyCnt    = MIN(CbyCnt    , LISTALLOC);		// max list of cbys

    cbModCnt	 = sizeof (MODLIST)    * MaxModCnt;	// size of mods list
    cbModSymCnt  = sizeof (MODSYMLIST) * MaxModSymCnt;	// size of modsyms list
    cbSymCnt	 = sizeof (SYMLIST)    * MaxSymCnt;	// size of syms list
    cbPropCnt	 = sizeof (PROPLIST)   * MaxPropCnt;	// size of props list
    cbRefCnt	 = sizeof (REFLIST)    * MaxRefCnt;	// size of refs list
    cbDefCnt	 = sizeof (REFLIST)    * MaxDefCnt;	// size of defs list
    cbCalCnt	 = sizeof (USELIST)    * MaxCalCnt;	// size of cals list
    cbCbyCnt	 = sizeof (USELIST)    * MaxCbyCnt;	// size of cbys list

    // Allocate data cache

    pfModList    = LpvAllocCb(cbModCnt);
    pfModSymList = LpvAllocCb(cbModSymCnt);
    pfSymList    = LpvAllocCb(cbSymCnt);
    pfPropList   = LpvAllocCb(cbPropCnt);
    pfRefList    = LpvAllocCb(cbRefCnt);
    pfDefList    = LpvAllocCb(cbDefCnt);
    pfCalList    = LpvAllocCb(cbCalCnt);
    pfCbyList    = LpvAllocCb(cbCbyCnt);

    for (i=0; i < MAXATOMPAGETBL; i++) {
	AtomPageTbl[i].uPage = 0;
	AtomPageTbl[i].pfAtomCache = LpvAllocCb(ATOMALLOC);
    }
    AtomPageTblMac = 0;		  	// last cache page used 
    AtomPageTbl[0].uPage = 65535;

    // read data areas

    if (lastAtomPage == 0)
	pagesize = lastAtomCnt;
    else
	pagesize = ATOMALLOC;

    GetBSC(lbModList,    pfModList,    cbModCnt);    // Init Mod    cache
    GetBSC(lbModSymList, pfModSymList, cbModSymCnt); // Init ModSym cache
    GetBSC(lbSymList,    pfSymList,    cbSymCnt);    // Init Sym    cache
    GetBSC(lbPropList,   pfPropList,   cbPropCnt);   // Init Prop   cache
    GetBSC(lbRefList,    pfRefList,    cbRefCnt);    // Init Ref    cache
    GetBSC(lbDefList,    pfDefList,    cbDefCnt);    // Init Def    cache
    GetBSC(lbCalList,    pfCalList,    cbCalCnt);    // Init Cal    cache
    GetBSC(lbCbyList,    pfCbyList,    cbCbyCnt);    // Init Cby    cache

    GetAtomCache (0);  // Init Atom cache

    return TRUE;
}

VOID 
InstallBSC()
//  Install the currently open BSC into the mbrmake lists
//
{
    IDX iprop, imod, isym, idef, ical, icby, isbr, iFirstFileSym;
    VA vaSym, vaProp, vaRef, vaFileSym, vaMod;
    DWORD iref;

    PROPLIST prop, prop0;
    MODLIST  mod;

    DEF def;
    CAL cal;
    CBY cby;
    VA	*rgVaProp;	// preallocated array of PROPs
    VA  *rgVaFileSym;	// cached SYMs for the filenames
    BYTE *rgFModUsed;	// is this module used?

    SI  *mpIsbrSi;

    rgVaProp      = (VA *)LpvAllocCb(PropCnt * sizeof(VA));
    rgVaFileSym   = (VA *)LpvAllocCb(ModCnt  * sizeof(VA));
    rgFModUsed    = (BYTE *)LpvAllocCb(ModCnt  * sizeof(BYTE));

    // make the SBR info for this BSC file
    mpIsbrSi = LpsiCreate();

    // this relies on the fact that all the SYMs for the files are together
    // (they're after all the SYMs for the variables)
    iFirstFileSym = bMOD(0).ModName;

    for (iprop = 0; iprop < PropCnt; iprop++)
	rgVaProp[iprop] = VaAllocGrpCb(grpProp, sizeof(PROP));

    for (imod = 0; imod < ModCnt; imod++) {
	mod = bMOD(imod);

	vaCurMod	   = VaAllocGrpCb(grpMod, sizeof(MOD));

	gMOD(vaCurMod);
	cMOD.vaFirstModSym = vaNil;
	cMOD.csyms	   = 0;
        cMOD.vaNameSym     = MbrAddAtom (LszNameFrIsym (mod.ModName), TRUE);
	cMOD.vaNextMod	   = vaRootMod;
	pMOD(vaCurMod);

	rgVaFileSym[imod]  = cMOD.vaNameSym;
	rgFModUsed[imod]   = 0;

	vaRootMod	   = vaCurMod;

	if (Unknown == mod.ModName) {
	    vaUnknownSym   = cMOD.vaNameSym;
	    vaUnknownMod   = vaCurMod;
	}

	gSYM(cMOD.vaNameSym).vaFirstProp = vaCurMod; // store ptr to MOD
	pSYM(cMOD.vaNameSym);
    }

    for (isym = 0; isym < SymCnt; isym++) {

        vaSym  = MbrAddAtom(LszNameFrIsym(isym), FALSE);

        iprop = isym ? bSYM((IDX)(isym-1)).PropEnd : 0;
	for (; iprop < bSYM(isym).PropEnd; iprop++) {

	    prop = bPROP(iprop);

	    if (iprop)
                prop0 = bPROP((IDX)(iprop-1));
	    else {
		prop0.DefEnd = 0L;
		prop0.RefEnd = 0;
		prop0.CalEnd = 0;
		prop0.CbyEnd = 0;
	    }

	    // the properties were preallocated
	    vaProp = rgVaProp[iprop];

	    gSYM(vaSym);
	    if (cSYM.vaFirstProp == vaNil)
		cSYM.vaFirstProp = vaProp;
	    else
		cPROP.vaNextProp = vaProp;

	    cSYM.cprop++;
	    pSYM(vaSym);

	    gPROP(vaProp);
	    cPROP.vaNameSym = vaSym;
	    cPROP.sattr     = prop.PropAttr;


#ifdef DEBUG
if (isym != prop.PropName)
    printf("\t  ERROR property points back to wrong symbol!\n");  // DEBUG
#endif

	    for (idef = prop0.DefEnd; idef < prop.DefEnd; idef++) {
		isbr = bDEF(idef).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (isbr == 0xffff || mpIsbrSi[isbr].fUpdate) continue;

		imod = bDEF(idef).RefNam - iFirstFileSym;
		def.isbr      = mpIsbrSi[isbr].isbr;
		def.deflin    = bDEF(idef).RefLin;
		def.vaFileSym = rgVaFileSym[imod];

		rgFModUsed[imod] = 1;

		VaAddList(&cPROP.vaDefList, &def, sizeof(def), grpDef);
	    }

	    for (iref =  prop0.RefEnd; iref < prop.RefEnd; iref++) {
		isbr = bREF(iref).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (mpIsbrSi[isbr].fUpdate) continue;

		vaRef = VaAllocGrpCb(grpRef, sizeof(REF));

		gREF(vaRef);
		imod 	      = bREF(iref).RefNam - iFirstFileSym;
		cREF.isbr     = mpIsbrSi[isbr].isbr;
		cREF.reflin   = bREF(iref).RefLin;
		vaFileSym     = rgVaFileSym[imod];

		rgFModUsed[imod] = 1;

		MkVpVa(cREF.vpFileSym, vaFileSym);

		pREF(vaRef);

		AddTail (Ref, REF);

		cPROP.cref++;	// count references
	    }

	    for (ical = prop0.CalEnd; ical < prop.CalEnd; ical++) {
		isbr = bCAL(ical).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (mpIsbrSi[isbr].fUpdate) continue;

		cal.isbr      = mpIsbrSi[isbr].isbr;
		cal.vaCalProp = rgVaProp[bCAL(ical).UseProp];
		cal.calcnt    = bCAL(ical).UseCnt;

		VaAddList(&cPROP.vaCalList, &cal, sizeof(cal), grpCal);
	    }

	    for (icby =	prop0.CbyEnd; icby < prop.CbyEnd; icby++)  {
		isbr = bCBY(icby).isbr;

		// this SBR file is being updated -- ignore incoming info
		if (mpIsbrSi[isbr].fUpdate) continue;

		cby.isbr      = mpIsbrSi[isbr].isbr;
		cby.vaCbyProp = rgVaProp[bCBY(icby).UseProp];
		cby.cbycnt    = bCBY(icby).UseCnt;

		VaAddList(&cPROP.vaCbyList, &cby, sizeof(cby), grpCby);
	    }

	    pPROP(vaProp);
	}
    }

    for (imod = 0; imod < ModCnt; imod++) {
	vaMod = gSYM(rgVaFileSym[imod]).vaFirstProp; 
	gMOD(vaMod);
	if (rgFModUsed[imod] == 0) {
  	    cMOD.csyms = 1;	// mark this MOD as empty
	    pMOD(vaMod);
	}
    }

    FreeLpv(mpIsbrSi);
    FreeLpv(rgFModUsed);
    FreeLpv(rgVaFileSym);
    FreeLpv(rgVaProp);
}

static LPSI
LpsiCreate()
// create the SBR info records for this .BSC file
//
{
    SI  FAR *mpIsbrSi;
    LSZ lszSbrName;
    VA  vaSbr;
    WORD isbr, isbr2;
    WORD fUpdate;

    // add the files that are current in the database to the list of .SBR files
    //
    lszSbrName    = LpvAllocCb(PATH_BUF);
    lseek(fhBSC, lbSbrList, SEEK_SET);
    for (isbr = 0;;isbr++) {
	GetBSCLsz(lszSbrName);
	if (*lszSbrName == '\0')
	    break;

	vaSbr = VaSbrAdd(SBR_OLD, lszSbrName);

	cSBR.isbr = isbr;
	pSBR(vaSbr);
    }
    FreeLpv(lszSbrName);

    mpIsbrSi = LpvAllocCb(SbrCnt * sizeof(SI));

    // allocate and fill in the new table with the base numbers
    // mark files that are staying and those that are going away
    // number any new sbr files that we find while doing this.

    vaSbr = vaRootSbr;
    while (vaSbr) {
	gSBR(vaSbr);

        if (cSBR.isbr == (WORD)-1) {
	    cSBR.isbr = isbr++;
	    pSBR(vaSbr);
	}

	if (cSBR.fUpdate == SBR_NEW)
	    Warning(WARN_SBR_TRUNC, cSBR.szName);
	else if (cSBR.fUpdate & SBR_NEW)
	    fFoundSBR = TRUE;

	mpIsbrSi[cSBR.isbr].fUpdate =  cSBR.fUpdate;

        vaSbr = cSBR.vaNextSbr;
    }

    if (!fFoundSBR) {
	// all SBR files were not in the database and were truncated. ERROR!
	Error(ERR_ALL_SBR_TRUNC, "");
    }

    isbr2 = 0;
    for (isbr = 0; isbr < SbrCnt; isbr++) {
	fUpdate = mpIsbrSi[isbr].fUpdate;

	if (fUpdate & SBR_NEW)
	    mpIsbrSi[isbr].isbr = isbr2++;
	else
            mpIsbrSi[isbr].isbr = (WORD)-1;

	if ((fUpdate & SBR_UPDATE) ||
	    (fUpdate & SBR_OLD) && (~fUpdate & SBR_NEW))
		mpIsbrSi[isbr].fUpdate = TRUE;
	else
		mpIsbrSi[isbr].fUpdate = FALSE;

    }

    return mpIsbrSi;
}

VOID
NumberSBR()
// stub version of LpsiCreate --- call this if FOpenBSC fails to just
// assign new numbers to all the .sbr files that are in the list
//
{
    VA  vaSbr;
    WORD isbr;

    // number new sbr files 

    vaSbr = vaRootSbr;
    isbr  = 0;
    while (vaSbr) {
	gSBR(vaSbr);

	#ifdef DEBUG
        if (cSBR.isbr != (WORD)-1) {
	    printf("Non initialized SBR file encountered\n");   //DEBUG
	}
	#endif

	// if this file is truncated then and there is no
	// old version of the file then emit a warning about the file
	// and then an error stating that we are not in incremental mode

	if (cSBR.fUpdate == SBR_NEW) {
	    Warning(WARN_SBR_TRUNC, cSBR.szName);
	    Error(ERR_NO_INCREMENTAL, "");
	}

	cSBR.isbr = isbr++;

	pSBR(vaSbr);

	vaSbr = cSBR.vaNextSbr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\sbrproto.h ===
void  SBRCorrupt(char  *psz);
void  FreeOrdList(void);
PVOID  VaOrdFind(unsigned short ord);
PVOID  VaOrdAdd(void);
BOOL   FInExcList (LSZ lszName);
void  InstallSBR(void);
void  AddCalProp(VA  vaCurProp);
void  AddCbyProp(VA  vaCurProp);
void  AddRefProp(VA  vaCurProp);
void  AddDefProp(VA  vaCurProp);
VA  VaPropBestOfSym(VA  vaSym);
VA  VaPropAddToSym(VA  vaCurSym);
void  BldModSymList(void);
void  CleanUp(void);
BOOL    FWildMatch(char *pchPat, char *pchText);
void  Error(int  imsg,char  *parg);
void  Error2(int  imsg,char  achar,char  *parg);
void  Warning(int  imsg,char  *parg);
void  Fatal(void);
void  sigint(void);
char  far *LszDup(char  far *lsz);
char  far *LszDupNewExt(char  far *pname,char  far *pext);
void  AddExcludeFileList(char  far *pname);
BOOL  FValidHeader(void);
void  __cdecl main(int  argc,char  * *argv);
void  Usage(void);
long  GetArgPosn(void);
void  SetArgPosn(long  lArgPosn);
char  *NextArg(void);
char  *ParseArgs(int  argc,char  * *argv);
void  WriteBSC(char  *OutputFileName);
void  DebugDump(void);
void  DebugDumpProp(VA  vaProp);
void  SeekError(char  *pfilenm);
void  ReadError(char  *pfilenm);
void  WriteError(char  *pfilenm);
void  FindTmp(char  *pbuf);
char  *MakTmpFileName(char  *pext);
char  far *LszBaseName(char  far *lsz);
VA  VaSearchModule(char  *p);
VA  VaSearchModuleExact(char  *p);
VA  VaSearchSymbol(char  *pStr);
char  far *GetAtomStr(VA  vaSym);
PVOID  MbrAddAtom(char  *pStr,char  fFILENM);
void  SortAtoms(void);
int  __cdecl CmpSym(VA   *sym1, VA *sym2);
void  CloseBSC(void);
BOOL   FOpenBSC (LSZ lszName);
void  InstallBSC(void);
void  NumberSBR(void);
VA  VaSbrAdd(unsigned short  fUpdate,char  far *lszName);
VA  VaSbrFrName(char  far *lszName);
char  far *ToCanonPath(char  far *lszPath,char  far *lszCwd,char  far *lszCanon);
void  ToRelativePath(char  far *lszPath,char  far *lszCwd);
char  far *ToAbsPath(char  far *lszPath,char  far *lszCwd);
void  ToBackSlashes(char  far *lsz);
void  GetStr(char  *buf);
unsigned char  GetSBRRec(void);
void  DecodeSBR(void);
// rjsa forfile (char far * pat, void (*rtn)(char far *));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\exthdr\exthdr.c ===
#include    <ext.h>
#include    <stddef.h>

int __acrtused = 1;



/***

	The data below must match the structure in ..\ext.h

	Think VERY carefully before you ever change any of this.  We
	currently support using extensions written for previous versions
	of the editor without recompiling.  This means that just about
	ANY change to this data, or it's initialization will break that.

	When adding a new import, consider appending to the table rather
	than replacing one currently in the table.
***/

extern struct cmdDesc     cmdTable;
extern struct swiDesc     swiTable;

EXTTAB ModInfo =
    {	VERSION,
	sizeof (struct CallBack),
	&cmdTable,
	&swiTable,
	{   NULL    }};

void
EntryPoint (
    ) {

    WhenLoaded( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\vm.h ===
//
// simple minded virtual memory system headers
//

typedef PVOID VA;

#define vaNil		0

#define VM_API pascal


#define InitVM()
#define CloseVM()
#define FreeVa(va,cb)           (free((LPV)va))
#define VaAllocCb(cb) 		((VA)LpvAllocCb(cb))
#define LpvFromVa(va, wLock) 	(LPV)(va)
#define DirtyVa(va)
#define UnlockW(w)
#define FreeLpv(lpv)            (free(lpv))

typedef VA VP;

#define MkVpVa(vp, va)	((vp) = (VP)va)
#define VaFrVp(vp) 	((VA)(vp))


LPV  VM_API LpvAllocCb(ULONG cb);
VA   VM_API VaAllocGrpCb(WORD grp, ULONG cb);
VOID VM_API FreeGrpVa(WORD grp, VA va, ULONG cb);

#ifdef SWAP_INFO

#define VM_MISC		0
#define VM_SEARCH_DEF	1
#define VM_ADD_DEF	2
#define VM_SEARCH_REF	3
#define VM_ADD_REF	4
#define VM_SEARCH_CAL	5
#define VM_ADD_CAL	6
#define VM_SEARCH_CBY	7
#define VM_ADD_CBY	8
#define VM_SEARCH_ORD	9
#define VM_ADD_ORD	10
#define VM_SEARCH_PROP	11
#define VM_ADD_PROP	12
#define VM_SEARCH_SYM	13
#define VM_ADD_SYM	14
#define VM_SEARCH_MOD	15
#define VM_ADD_MOD	16
#define VM_SORT_ATOMS	17
#define VM_FIX_UNDEFS	18
#define VM_CLEAN_REFS	19
#define VM_INDEX_TREE	20
#define VM_BUILD_MODSYM 21
#define VM_EMIT_ATOMS	22
#define VM_EMIT_TREE	23

extern WORD near iVMClient;
extern WORD near iVMGrp;

#define SetVMClient(x) (iVMClient = (x))

#else

#define SetVMClient(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\sbrx.c ===
#define LINT_ARGS

#include <stdlib.h>
#include <ctype.h>
#include <search.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "mbrmake.h"

#define LONGESTPATH 128

#define SLASH     "\\"
#define SLASHCHAR '\\'
#define XSLASHCHAR '/'

WORD near cAtomsMac;                    // total number of atoms
WORD near cModulesMac;                  // total number of modules
WORD near cSymbolsMac;                  // total number of symbols

static char *tmpl =     "XXXXXX";

extern WORD HashAtomStr (char *);

// rjsa LPCH GetAtomStr (VA vaSym);

void
SeekError (char *pfilenm)
// couldn't seek to position ... emit error message
//
{
    Error(ERR_SEEK_FAILED, pfilenm);
}

void
ReadError (char *pfilenm)
// couldn't read from file... emit error message
//
{
    Error(ERR_READ_FAILED, pfilenm);
}

void
WriteError (char *pfilenm)
// couldn't write to file ... emit error message
//
{
    Error(ERR_WRITE_FAILED, pfilenm);
}

void
FindTmp (char *pbuf)  /* copy TMP path to pbuf if exists */
//
//
{
    char ebuf[LONGESTPATH];
    char *env = ebuf;

    *pbuf = '\0';
    *env  = '\0';

//    if (!(env = getenv("TMP")))
    if (!(env = getenvOem("TMP")))
        return;      /* no path, return */

//    env = strncpy(ebuf, env, LONGESTPATH-1);
    strncpy(ebuf, env, LONGESTPATH-1);
    free( env );
    env = ebuf;
    ebuf[LONGESTPATH-1] = '\0';

    if (!( env = ebuf ) )
        return;

    env = ebuf + strcspn(ebuf, ";");
    if (*env == ';')
        *env = '\0';

    if (env != ebuf) {
        env--;
        if (*env != SLASHCHAR
         && *env != XSLASHCHAR)
                strcat(ebuf, SLASH);
    }
    strcpy (pbuf, ebuf);
}


char *
MakTmpFileName (char *pext)
// Create a temporary file with the extension supplied.
// returns a pointer to the file name on the heap.
//
{
    char ptmpnam[96];
    char btmpl[7];
    char *p;

    strcpy (btmpl, tmpl);
    p = mktemp(btmpl);
    FindTmp (ptmpnam);
    strcat (ptmpnam, p);
    free (p);
    strcat (ptmpnam, pext);             /* /tmp/xxxxxx.ext file */
    return (LszDup(ptmpnam));
}

LSZ
LszBaseName (LSZ lsz)
// return the base name part of a path
//
{
    LPCH lpch;

    lpch = strrchr(lsz, '\\');
    if (lpch) return lpch+1;
    if (lsz[1] == ':')
        return lsz+2;

    return lsz;
}

VA
VaSearchModule (char *p)
// search for the named module in the module list
//
{
    VA vaMod;
    LSZ lsz, lszBase;
    char buf[PATH_BUF];

    strcpy(buf, ToAbsPath(p, r_cwd));
    lszBase = LszBaseName(buf);

    SetVMClient(VM_SEARCH_MOD);

    vaMod = vaRootMod;

    while (vaMod) {
        gMOD(vaMod);

        lsz = GetAtomStr(cMOD.vaNameSym);

        if (strcmpi(LszBaseName(lsz), lszBase) == 0 &&
               strcmpi(buf,ToAbsPath(lsz, c_cwd)) == 0) {
            SetVMClient(VM_MISC);
            return (vaMod);
        }
        vaMod = cMOD.vaNextMod;
    }
    SetVMClient(VM_MISC);
    return vaNil;
}

VA
VaSearchModuleExact (char *p)
// search for the named module in the module list -- EXACT match only
//
{
    VA vaMod;

    SetVMClient(VM_SEARCH_MOD);

    vaMod = vaRootMod;

    while (vaMod) {
        gMOD(vaMod);

        if (strcmp(p,GetAtomStr(cMOD.vaNameSym)) == 0) {
            SetVMClient(VM_MISC);
            return (vaMod);
        }
        vaMod = cMOD.vaNextMod;
    }
    SetVMClient(VM_MISC);
    return vaNil;
}

VA
VaSearchSymbol (char *pStr)
// search for the named symbol (not a module!)
//
{
    WORD hashid;
    VA   vaRootSym, vaSym;
    LSZ  lszAtom;

    SetVMClient(VM_SEARCH_SYM);

    vaRootSym = rgVaSym[hashid = HashAtomStr (pStr)];

    if (vaRootSym) {
        vaSym = vaRootSym;
        while (vaSym) {

            gSYM(vaSym);
            lszAtom = gTEXT(cSYM.vaNameText);

            if (strcmp (pStr, lszAtom) == 0) {
                SetVMClient(VM_MISC);
                return (vaSym);         // Duplicate entry
            }

            vaSym = cSYM.vaNextSym;             // current = next
        }
    }

    SetVMClient(VM_MISC);
    return vaNil;
}

LPCH
GetAtomStr (VA vaSym)
//  Swap in the Atom page for the symbol chain entry pSym
//  Return the atom's address in the page.
//
{
    gSYM(vaSym);
    return gTEXT(cSYM.vaNameText);
}

VA
MbrAddAtom (char *pStr, char fFILENM)
// create a new symbol with the given name
//
{
    WORD  hashid;
    VA    vaSym, vaSymRoot, vaText;

    if (!fFILENM)
            vaSymRoot = rgVaSym[hashid = HashAtomStr (pStr)];
    else
            vaSymRoot = rgVaSym[hashid = MAXSYMPTRTBLSIZ - 1];

    SetVMClient(VM_SEARCH_SYM);

    if (vaSymRoot) {
        vaSym = vaSymRoot;
        while (vaSym) {
            gSYM(vaSym);

            if (!strcmp (pStr, GetAtomStr(vaSym))) {
                #if defined (DEBUG)
                if (OptD & 2)
                    printf("MbrAddAtom: duplicate (%s)\n", pStr);
                #endif
                SetVMClient(VM_SEARCH_SYM);
                return (vaSym);   // Duplicate entry
            }

            vaSym = cSYM.vaNextSym;     // current = next
        }
    }

    // we are now going to have to add the symbol


    if (fFILENM) {
        SetVMClient(VM_ADD_MOD);
        cModulesMac++;
    }
    else {
        SetVMClient(VM_ADD_SYM);
        cSymbolsMac++;
    }

    cAtomsMac++;

    vaSym  = VaAllocGrpCb(grpSym, sizeof(SYM));
    vaText = VaAllocGrpCb(grpText, strlen(pStr) + 1);

    gSYM(vaSym);
    cSYM.vaNameText = vaText;
    cSYM.vaNextSym  = rgVaSym[hashid];
    pSYM(vaSym);

    rgVaSym[hashid] = vaSym;

    strcpy(gTEXT(vaText), pStr);

    pTEXT(vaText);

    SetVMClient(VM_MISC);

    return (vaSym);
}

VA FAR * near rgvaSymSorted;

// rjsa int CmpSym(VA FAR *lhsym1, VA FAR *lhsym2);

void
SortAtoms ()
// create the "subscript sort" array pointers rgvaSymSorted
//
{
    VA vaSym;
    char buf[PATH_BUF];
    WORD i, iSym;

    SetVMClient(VM_SORT_ATOMS);

    rgvaSymSorted = (VA FAR *)LpvAllocCb(cAtomsMac * sizeof(VA));

    iSym = 0;
    for (i=0; i < MAXSYMPTRTBLSIZ; i++) {
        vaSym = rgVaSym[i];
        while (vaSym) {
            gSYM(vaSym);
            rgvaSymSorted[iSym] = cSYM.vaNameText;
            vaSym = cSYM.vaNextSym;
            iSym++;
        }
    }

    // sort symbols
    qsort(rgvaSymSorted, cSymbolsMac, sizeof(VA), CmpSym);

    // the files are in the last hash bucket so they went to the
    // end of this array we just made -- we sort them separately

    // sort files
    qsort(rgvaSymSorted + cSymbolsMac, cModulesMac, sizeof(VA), CmpSym);

    // convert the Page/Atom values back to virtual symbol addresses
    for (i=0; i < cSymbolsMac; i++) {
        strcpy(buf, gTEXT(rgvaSymSorted[i]));
        rgvaSymSorted[i] = VaSearchSymbol(buf);
    }

    for (; i < cAtomsMac; i++) {
        strcpy(buf, gTEXT(rgvaSymSorted[i]));
#ifdef DEBUG
        if (OptD & 64) printf("Module: %s\n", buf);
#endif
        rgvaSymSorted[i] = (VaSearchModuleExact(buf), cMOD.vaNameSym);
    }
}

int __cdecl
CmpSym (VA FAR *sym1, VA FAR *sym2)
// compare two symbols given their pointers
//
{
    register char far *lpch1, *lpch2;
    register int cmp;

    lpch1 = gTEXT(*sym1);       // LRU will not page out lpch1
    lpch2 = gTEXT(*sym2);

    cmp = strcmpi(lpch1, lpch2);

    if (cmp) return cmp;

    return strcmp(lpch1, lpch2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\browser\mbrmake\vm.c ===
// vm.c
//
// simple minded virtual memory implemenation

// there is no code to do the OS2 version...

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <string.h>
#if defined(OS2)
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_DOSMISC
#include <os2.h>
#else
#include <windows.h>
#endif


#include "hungary.h"
#include "vm.h"
#include "sbrproto.h"
#include "errors.h"

#define CB_PAGE_SIZE	2048	// 4k pages
#define C_LOCKS_MAX	16	// up to 16 pages may be locked in ram
#define C_PAGES_MAX	8192	// up to 4k pages resident
#define C_FREE_LIST_MAX 256	// keep free lists for items up to 256 bytes
#define GRP_MAX		16	// max number of memory groups

typedef WORD VPG;		// virtual page number
typedef VA far *LPVA;		// far pointer to VA

// virtual address arithmetic
//
// #define VpgOfVa(va) 	 ((WORD)((va>>12)))

// this is really the same as the above but it assumes that the high byte
// of the long is all zero's and it is optimized for our C compiler

#define VpgOfVa(va) 	 ((((WORD)((BYTE)(va>>16)))<<4)|\
  			  (((BYTE)(((WORD)va)>>8))>>4))

#define OfsOfVa(va) 	 ((WORD)((va) & 0x07ff))
#define VaBaseOfVpg(vpg) (((DWORD)(vpg)) << 12)

// phsyical page header
typedef struct _pg {
    BYTE	fDirty;		// needs to be written out
    BYTE	cLocks;		// this page is locked
    VPG		vpg;		// what is the virtual page number of this page
    struct _pg  FAR *lppgNext;	// LRU ordering next
    struct _pg  FAR *lppgPrev;	// and prev
} PG;

typedef PG FAR * LPPG;

typedef struct _mem {
    VA    vaFree;
    WORD  cbFree;
    VA	  mpCbVa[C_FREE_LIST_MAX];
#ifdef SWAP_INFO
    WORD  cPages;
#endif
} MGI;	// Memory Group Info

static MGI mpGrpMgi[GRP_MAX];

// translation table -- map virtual page number to physical page address
static LPPG mpVpgLppg[C_PAGES_MAX];

// head and tail pointers for LRU
//
static LPPG near lppgHead;
static LPPG near lppgTail;

// nil page pointer
//
#define lppgNil 0

// points to the start of linked lists of free blocks
//
static VA mpCbVa[C_FREE_LIST_MAX];	

// these pages are locked in memory
//
static LPPG near rgLppgLocked[C_LOCKS_MAX];

// number of pages we have given out
static VPG near vpgMac;

// number of physical pages we have resident
static WORD near cPages;

// should we keep trying to allocate memory
static BOOL near fTryMemory = TRUE;

// the file handle for the backing store
static int near fhVM;

// the name of the file for the backing store
static LSZ near lszVM;

#ifdef ASSERT

#define Assert(x, sz) { if (!(x)) AssertionFailed(sz); }

VOID
AssertionFailed(LSZ lsz)
// something went wrong...
//
{
    printf("assertion failure:%s\n", lsz);
    Fatal();
}

#else

#define Assert(x, y)

#endif


LPV VM_API
LpvAllocCb(ULONG cb)
// allocate a block of far memory, if _fmalloc fails, the free some of
// the memory we were using for the VM cache
//
{
     LPV lpv;

     if (!(lpv = calloc(cb,1))) {
	    Error(ERR_OUT_OF_MEMORY, "");
     }
     return lpv;
}


VA VM_API
VaAllocGrpCb(WORD grp, ULONG cb)
// allocate cb bytes from the requested memory group
//
{
    VA vaNew;
    MGI FAR *lpMgi;
    LPV lpv;

    lpMgi = &mpGrpMgi[grp];

    Assert(grp < GRP_MAX, "Memory Group out of range");

    if (cb < C_FREE_LIST_MAX && (vaNew = lpMgi->mpCbVa[cb])) {
	lpv = LpvFromVa(vaNew, 0);
	lpMgi->mpCbVa[cb] = *(LPVA)lpv;
	memset(lpv, 0, cb);
	DirtyVa(vaNew);
	return vaNew;
    }

    if (cb < mpGrpMgi[grp].cbFree) {
	vaNew = mpGrpMgi[grp].vaFree;
        (PBYTE)mpGrpMgi[grp].vaFree += cb;
	mpGrpMgi[grp].cbFree -= cb;
    }
    else {
	vaNew = VaAllocCb(CB_PAGE_SIZE - sizeof(PG));
        mpGrpMgi[grp].vaFree = (PBYTE)vaNew + cb;
	mpGrpMgi[grp].cbFree = CB_PAGE_SIZE - cb - sizeof(PG);
    }

    return vaNew;
}

VOID VM_API
FreeGrpVa(WORD grp, VA va, ULONG cb)
// put this block on the free list for blocks of that size
// we don't remember how big the blocks were so the caller has
// provide that info
//
{
    MGI FAR *lpMgi;

    lpMgi = &mpGrpMgi[grp];

    if (cb < C_FREE_LIST_MAX && cb >= 4 ) {
	*(LPVA)LpvFromVa(va, 0) = lpMgi->mpCbVa[cb];
	DirtyVa(va);
	lpMgi->mpCbVa[cb] = va;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\exthdr\makefile.inc ===
$(SDK_INC_PATH)\ext.h: ..\..\inc\ext.h
	copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\justify\justify.c ===
#define EXT_ID	"justify ver 2.02 "##__DATE__##" "##__TIME__
/*
** Justify Z extension
**
** History:
**	12-Sep-1988 mz	Made WhenLoaded match declaration
**	01-Sep-1988	Corrected hang when flush-justifying a line with no
**			spaces.
**	14-Aug-1988	Corrected right-justification on non-column-1 based
**			lines. Corrected justification over multiple
**			paragraphs.
**	30-Mar-1988	Extracted from "myext".
**
*/
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "ext.h"

#ifndef TRUE
#define TRUE	-1
#define FALSE	0
#endif

void		pascal near	DumpLine (char far *, PFILE, COL, COL, LINE, char far *, int);
int		pascal near	NextLine (char far *, PFILE, LINE, LINE far *, int far *);
flagType	pascal near	isterm (char);
void		pascal near	_stat (char *);

#ifdef DEBUG
void		pascal near	debend (flagType);
void		pascal near	debhex (long);
void		pascal near	debmsg (char far *);
#else
#define debend(x)
#define debhex(x)
#define debmsg(x)
#endif

flagType just2space	= TRUE;
int	justwidth	= 79;

/*************************************************************************
**
** justify
** justify paragraph(s)
**
** NOARG:	Justify between columns 0 and 78, from the current line to
**		blank line.
** NULLARG:	Justify between current column and 78, from the current line to
**		blank line.
** LINEARG:	Justify between current column and 78, the specified lines.
** "STREAMARG": Justify between specified columns from current line to blank.
**		(handled by boxarg)
** BOXARG:	justify between specified columns the specified rows
** TEXTARG:	Justify between columns 0 and 78, from the current line to
**		blank line, prepending each resulting line with the textarg.
*/
flagType pascal EXTERNAL
justify (
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
int	cbLine; 			/* length of line just read	*/
char	inbuf[512];			/* input buffer 		*/
PFILE	pFile;				/* file handle			*/
char far *pText;			/* pointer to prepending text	*/
COL	x1;				/* justify to left column	*/
COL	x2;				/* justify to right columne	*/
LINE	y1;				/* start line			*/
LINE	y2;				/* end line			*/
LINE	yOut;				/* output line			*/

	//
	//	Unreferenced parameters
	//
	(void)argData;

_stat(EXT_ID);
switch (pArg->argType) {

    case NOARG: 				/* justify paragraph	*/
	x1 = 0; 				/* between cols 0...	*/
	x2 = justwidth; 			/*	...and 79	*/
	y1 = pArg->arg.noarg.y; 		/* current line...	*/
	y2 = -1;				/*	...to blank line*/
	pText = 0;				/* there is no text	*/
	break;

    case NULLARG:				/* justify indented	*/
	x1 = pArg->arg.nullarg.x;		/* between cur col...	*/
	x2 = justwidth; 			/*	...and 79	*/
	y1 = pArg->arg.nullarg.y;		/* current line...	*/
	y2 = -1;				/*	...to blank line*/
	pText = 0;				/* there is no text	*/
	break;

    case LINEARG:				/* justify line range	*/
	x1 = 0; 				/* between cols 0...	*/
	x2 = justwidth; 			/*	...and 79	*/
	y1 = pArg->arg.linearg.yStart;		/* and range of lines	*/
	y2 = pArg->arg.linearg.yEnd;
	pText = 0;				/* there is no text	*/
	break;

    case BOXARG:				/* justify box		*/
	x1 = pArg->arg.boxarg.xLeft;		/* from left corner...	*/
	x2 = pArg->arg.boxarg.xRight;		/*	    ...to right */
	y1 = pArg->arg.boxarg.yTop;		/* from top...		*/
	y2 = pArg->arg.boxarg.yBottom;		/*	   ...to bottom */
	pText = 0;				/* there is no text	*/
	break;

    case TEXTARG:				/* justify & prepend	*/
	x1 = 0; 				/* between 0... 	*/
	x2 = justwidth; 			/*	  ...and 79	*/
	y1 = pArg->arg.textarg.y;		/* current line...	*/
	y2 = -1;				/*     ...to blank line */
	pText = pArg->arg.textarg.pText;	/* there IS text	*/
	break;
    }
pFile = FileNameToHandle ("", "");

if (y1 == y2)					/* if same line, then	*/
    y2 = -1;					/* just to blank line	*/
if (x1 == x2)					/* if same column	*/
    x2 = justwidth;				/* then just to default */
if (x2 < x1) {					/* if bas-ackwards	*/
    x1 = 0;					/* revert to default	*/
    x2 = justwidth;
    }

/*
** while we can get data within the specified limits, format each new line
** and output back to the file.
*/
inbuf[0] = 0;
yOut = y1;
while (NextLine(inbuf,pFile,y1,&y2,&cbLine)) {
/*
** if the line was blank, NextLine returned TRUE becase we're formating a
** range of text. This means we've reached the end of one paragraph. We dump
** the text collected so far (if any), and then a blank line.
*/
    if (cbLine == 0) {
	if (inbuf[0]) {
	    DumpLine(inbuf,pFile,x1,x2,yOut++,pText,0);
	    y1++;
	    if (y2 != (LINE)-1)
		y2++;
	    }
	DumpLine("",pFile,x1,x2,yOut++,pText,0);/* dump blank line	*/
	y1++;
	if (y2 != (LINE)-1)
	    y2++;
	}
    else
/*
** inbuf contains the data collected so far for output. Output one newly
** formated line at a time until the contents of inbuf are narrower than
** our output columns.
*/
	while ((COL)strlen(inbuf) > (x2-x1)) {	/* while data to output */
	    DumpLine(inbuf,pFile,x1,x2,yOut++,pText,fMeta);
	    y1++;				/* line moves with insert*/
	    if (y2 != (LINE)-1)
		y2++;
	    }
    }
/*
** Dump any partial last line. Then if we were formatting to a blank line,
** dump out one of those too.;
*/
if (inbuf[0])
    DumpLine (inbuf,pFile,x1,x2,yOut++,pText,0); /* dump last line	 */
if (y2 == -1)
    DumpLine (NULL,pFile,x1,x2,yOut++,pText,0);  /* dump blank line	 */

return TRUE;

/* end justify */}

/*** NextLine - Get next line from file
*
*  Get next line from file, remove leading and trailing spaces, and append
*  it to the input buffer. Each line is deleted from the file as it is
*  read in. This means that the target terminator, (*py2), is decremented
*  by one for each line read in.
*
* Input:
*  pBuf 	= pointer to input buffer
*  pFile	= file pointer
*  y1		= line # to read
*  py2		= pointer to line # to stop at (updated)
*  pcbLine	= pointer to place to put the count of bytes read
*
* Output:
*  Returns TRUE on a line being read & more reformatting should occurr.
*
*************************************************************************/
int pascal near NextLine (
char far *pBuf, 				/* input buffer 	*/
PFILE	pFile,					/* file pointer 	*/
LINE	y1,					/* line # to read	*/
LINE far *py2,					/* line # to stop at	*/
int far *pcbLine				/* loc to place bytes read*/
) {
flagType fRet	    = TRUE;
char far *pT;					/* working pointer	*/
char	workbuf[512];				/* working buffer	*/


*pcbLine = 0;
workbuf[0] = 0;
/*
** If asked for line that is not in file, we're done.
*/
if (y1 >= FileLength(pFile))
    return FALSE;
/*
** if current line past range, (and range is not "-1"), then we're done.
*/
if ((*py2 != (LINE)-1) && (y1 > *py2))
    return FALSE;
/*
** Get the next line in the file & remove it.
*/
*pcbLine = GetLine(y1, workbuf, pFile);
DelLine(pFile, y1, y1);
if (*py2 == 0)
    fRet = FALSE;
else if (*py2 != (LINE)-1)
    (*py2)--;
/*
** If the line is blank, and the range is "-1", we're done.
*/
if (!*pcbLine && (*py2 == -1))
    return FALSE;

/*
** strip leading spaces in newly input line
*/
pT = workbuf;					/* point into line	*/
while (*pT == ' ')
    pT++;					/* skip leading spaces	*/
/*
** If existing buffer is non-empty, append a space & set pointer to end
*/
if (strlen(pBuf)) {				/* if non-null string	*/
    pBuf += strlen(pBuf);			/* point to null	*/
    *pBuf++ = ' ';				/* append space 	*/
    if (isterm(*(pBuf-2)))			/* if sentence term...	*/
	*pBuf++ = ' ';				/* append another	*/
    }
/*
** append new line, but compress multiple spaces into one
*/
while (*pT) {					/* copy line over	*/
    if (isterm(*pT))				/* if sentence term...	*/
	if (*(pT+1) == ' ') {			/*   ...space		*/
	    *pBuf++ = *pT++;			/* copy period		*/
	    *pBuf++ = *pT;			/* copy space		*/
	    }
    if ((*pBuf++ = *pT++) == ' '    )		/* copy a char		*/
	while (*pT == ' ') pT++;		/* skip multiple spaces */
    }
if (*(pBuf-1) == ' ')				/* if a trailing space	*/
    pBuf--;					/* remove it		*/
*pBuf = 0;

return fRet;
/* end NextLine */}

/*** DumpLine - Dump one line of text to the file
*
*  Dump one line of text to the file. Prepend any required text or spaces,
*  and perform word break/cut at right hand column.
*
* Input:
*  pBuf     = Pointer to the buffer containing data to output. If NULL, pText
*	      will not be prepended to output text.
*  pFile
*  x1
*  x2
*  yOut
*  pText
*  fFlush
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void pascal near DumpLine (
char far *pBuf, 				/* data to output	*/
PFILE	pFile,					/* file to output to	*/
COL	x1,					/* left-hand column	*/
COL	x2,					/* right-hand column	*/
LINE	yOut,					/* line to output to	*/
char far *pText,				/* text to prepend	*/
int	fFlush					/* flush both sides	*/
) {
int	i;
char far *pT;
char far *pT2;
char	workbuf[512];				/* working buffer	*/
char	flushbuf[512];				/* working buffer	*/
char	fSpace; 				/* space seen flag	*/

/*
** Start by prepending any text, and then filling out to the left hand column
** to justify to.
*/
workbuf[0] = 0; 				/* start with null	*/
if (pText && pBuf)
    strcpy(workbuf,pText);			/* if starting with text*/
i = strlen(workbuf);				/* length of line-so-far*/
while (i++ < x1)
    strcat(workbuf," ");			/* fill out with spaces */

/*
** Append the data to be output, and then starting at the right column, scan
** back for a space to break at. If one is not found before the left hand
** column, then break at the right hand column. Copy any line left over back
** to the passed in buffer
*/
if (pBuf) {
    strcat(workbuf,pBuf);			/* get total line	*/
    *pBuf = 0;					/* empty input buffer	*/
    }
if ((COL)strlen(workbuf) > x2) {			/* if we need to cut	*/
    pT = &workbuf[x2];				/* point at potential cut*/
    while ((pT > (char far *)&workbuf[0]) && (*pT != ' ')) pT--; /* back up to space*/
    if (pT <= (char far *)&workbuf[x1]) {	/* if none found in range*/
	if (pBuf)
	    strcpy(pBuf,&workbuf[x2]);		/* copy remainder of line*/
	workbuf[x2] = 0;			/* and terminate this one*/
	}
    else {
	while (*++pT == ' ');			/* Skip leading spaces	 */
	if (pBuf)
	    strcpy(pBuf,pT);			/* copy remainder of line*/
	*pT = 0;				/* and terminate this one*/
	}
    }
/*
** This code is invoked when the user wants to justify both right and left
** sides of his text. We determine how many spaces we need to add, and scan
** through and add one space to each run of spaces until we've added enough
*/
if (fFlush) {					/* right & left justify?*/
    if ((LONG_PTR) (pT = workbuf + strlen(workbuf) - 1) > 0)
	while (*pT == ' ')
	    *pT-- = 0;
    if (strchr(workbuf,' ')) {
	while ((i = x2 - strlen(workbuf)) > 0) {/* count of spaces to add */
	    strcpy(flushbuf,workbuf);		/* start with unmodified*/
	    pT = workbuf + x1;
	    pT2 = flushbuf + x1;		/* skip fixed part	*/
	    fSpace = FALSE;			/* assume no spaces	*/
	    while (*pT) {			/* while data to copy	*/
		if ((*pT == ' ') && i) {	/* time to insert a space*/
		    fSpace = TRUE;		/* we've seen a space   */
		    *pT2++ = ' ';
		    i--;
		    while (*pT == ' ')
			*pT2++ = *pT++; 	/* copy run of spaces	*/
		    }
		if (*pT)
		    *pT2++ = *pT++;		/* copy line		*/
		else if (!fSpace)
		    break;			/* no embedded spaces	*/
		}
	    *pT2 = 0;
	    strcpy(workbuf,flushbuf);		/* copy back		*/
	    if (!fSpace)
		break;
	    }
	}
    }

CopyLine ((PFILE) NULL, pFile, yOut, yOut, yOut); /* create new line	*/
PutLine (yOut, workbuf, pFile); 		/* output line		*/

/* end DumpLine */}

/*************************************************************************
**
** isterm
** returns true/false based on the character being a sentence terminator:
** one of '.', '?', '!'. Also, always returns false if just2space is off.
*/
flagType pascal near isterm(
char	c				/* character to test		*/
)
{
return (flagType)(just2space && ((c == '.') || (c == '!') || (c == '?')));
/* end isterm */}


/*
** switch communication table to Z
*/
struct swiDesc	swiTable[] = {
    {  "just2space", toPIF(just2space), SWI_BOOLEAN },
    {  "justwidth",  toPIF(justwidth),	SWI_NUMERIC | RADIX10 },
    {0, 0, 0}
    };

/*
** command communication table to Z
*/
struct cmdDesc	cmdTable[] = {
    {	"justify",	justify, 0, MODIFIES | NOARG | NULLARG | LINEARG | BOXARG | TEXTARG },
    {0, 0, 0}
    };

/*
** WhenLoaded
** Executed when these extensions get loaded. Identify self & assign keys.
*/
void EXTERNAL WhenLoaded () {
PSWI	pwidth;

_stat(EXT_ID);
SetKey ("justify","alt+b");

if (pwidth = FindSwitch("rmargin"))
    justwidth = *pwidth->act.ival;
}

/*************************************************************************
**
** stat - display status line message
**
** Purpose:
**  Places extension name and message on the status line
**
** Entry:
**  pszFcn	- Pointer to string to be prepended.
**
** Exit:
**  none
**
** Exceptions:
**  none
**
*/
void pascal near _stat (
char *pszFcn					/* function name	*/
) {
buffer	buf;					/* message buffer	*/

strcpy(buf,"justify: ");			/* start with name	*/
#ifdef DEBUG
if (strlen(pszFcn) > 71) {
    pszFcn+= strlen(pszFcn) - 68;
    strcat (buf, "...");
    }
#endif
strcat(buf,pszFcn);				/* append message	*/
DoMessage (buf);				/* display		*/
/* end stat */}

#ifdef DEBUG
buffer	debstring   = {0};
extern	int	delay;			/* message delay		*/

/*** debhex - output long in hex
*
*  Display the value of a long in hex
*
* Input:
*  lval 	= long value
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debhex (
long	lval
) {
char lbuf[10];

_ultoa (lval, lbuf, 16);
debmsg (lbuf);
/* end debhex */}

/*** debmsg - piece together debug message
*
*  Outputs a the cummulative message formed by successive calls.
*
* Input:
*  psz		= pointer to message part
*
* Output:
*  Returns nothing
*************************************************************************/
void pascal near debmsg (
char far *psz
) {
_stat (strcat (debstring, psz));
/* end debmsg */}

/*** debend - terminates message accumulation & pauses
*
*  Terminates the message accumulation, displays the final message, and
*  pauses, either for the pause time, or for a keystroke.
*
* Input:
*  fWait	= TRUE => wait for a keystroke
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debend (
flagType fWait
) {
if (fWait) {
    _stat (strcat (debstring, " Press a key..."));
    ReadChar ();
    }
debstring[0] = 0;
/* end debend */}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\filter\filter.c ===
/*** filter.c - Microsoft Editor Filter Extension
*
* Purpose:
*  Provides a new editting function, filter, which replaces its argument with
*  the the argument run through an arbitrary operating system filter program.
*
*   Modifications
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/
#define EXT_ID	" filter ver 1.01 "##__DATE__##" "##__TIME__

#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>			/* prototypes for string fcns	*/
#include "ext.h"


//
//  Prototypes
//
flagType pascal 	 DoSpawn    (char *);
void	 pascal 	 id	    (char *);
void	 pascal EXTERNAL SetFilter  (char far *);


//
//  Global data
//
PFILE	pFileFilt	= 0;			/* handle for filterfile*/
char	*szNameFilt	= "<filter-file>";	/* name of filter file	*/
char	*szTemp1	= "filter1.tmp";	/* name of 1st temp file*/
char	*szTemp2	= "filter2.tmp";	/* name of 2nd temp file*/
char    filtcmd[BUFLEN] = "";                   /* filter command itself*/




/*** filter - Editor filter extension function
*
* Purpose:
*  Replace seleted text with that text run through an arbitrary filter
*
*  NOARG       - Filter entire current line
*  NULLARG     - Filter current line, from cursor to end of line
*  LINEARG     - Filter range of lines
*  BOXARG      - Filter characters with the selected box
*
*  NUMARG      - Converted to LINEARG before extension is called.
*  MARKARG     - Converted to Appropriate ARG form above before extension is
*		 called.
*
*  STREAMARG   - Treated as BOXARG
*
*  TEXTARG     - Set new filter command
*
* Input:
*  Editor Standard Function Parameters
*
* Output:
*  Returns TRUE on success, file updated, else FALSE.
*
*************************************************************************/
flagType pascal EXTERNAL
filter (
    unsigned int argData,                   /* keystroke invoked with       */
    ARG far      *pArg,                     /* argument data                */
    flagType     fMeta                      /* indicates preceded by meta   */
    )
{
    char    buf[BUFLEN];                    /* buffer for lines             */
    int     cbLineMax;                      /* max lein length in filtered  */
    LINE    cLines;                         /* count of lines in file       */
    LINE    iLineCur;                       /* line being read              */
    PFILE   pFile;                          /* file handle of current file  */

	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)fMeta;

    //
    //  Identify ourselves, get a handle to the current file and discard the
    //  contents of the filter file.
    //
    id ("");
    pFile = FileNameToHandle ("", "");
    DelFile (pFileFilt);

    //
    // Step 1, based on the argument type, copy the selected region into the
    // (upper left most position of) filter-file.
    //
    // Note that TEXTARG is a special case that allows the user to change the name
    // of the filter command to be used.
    //
    switch (pArg->argType) {
        case NOARG:                         /* filter entire line           */
            CopyLine (pFile,
                      pFileFilt,
                      pArg->arg.noarg.y,
                      pArg->arg.noarg.y,
                      (LINE) 0);
            break;

        case NULLARG:                       /* filter to EOL                */
            CopyStream (pFile,
                        pFileFilt,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y,
                        255,
                        pArg->arg.nullarg.y,
                        (COL) 0,
                        (LINE) 0);
            break;

        case LINEARG:                       /* filter line range            */
            CopyLine (pFile,
                      pFileFilt,
                      pArg->arg.linearg.yStart,
                      pArg->arg.linearg.yEnd,
                      (LINE) 0);
            break;

        case BOXARG:                        /* filter box                   */
            CopyBox (pFile,
                     pFileFilt,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop,
                     pArg->arg.boxarg.xRight,
                     pArg->arg.boxarg.yBottom,
                     (COL) 0,
                     (LINE) 0);
            break;

        case TEXTARG:
            SetFilter (pArg->arg.textarg.pText);
            return 1;
        }

    //
    // Step 2, write the selected text to disk
    //
    if (!FileWrite (szTemp1, pFileFilt)) {
        id ("** Error writing temporary file **");
        return 0;
    }

    //
    // Step 3, create the command to be executed:
    //   user specified filter command + " " + tempname 1 + " >" + tempname 2
    // Then perform the filter operation on that file, creating a second temp file.
    //
    strcpy (buf,filtcmd);
    strcat (buf," ");
    strcat (buf,szTemp1);
    strcat (buf," >");
    strcat (buf,szTemp2);

    if (!DoSpawn (buf)) {
        id ("** Error executing filter **");
        return 0;
    }

    //
    // Step 4, delete the contents of the filter-file, and replace it by reading
    // in the contents of that second temp file.
    //
    DelFile (pFileFilt);

    if (!FileRead (szTemp2, pFileFilt)) {
        id ("Error reading temporary file **");
        return 0;
    }

    //
    // Step 5, calculate the maximum width of the data we got back from the
    // filter. Then, based again on the type of region selected by the user,
    // DISCARD the users select region, and copy in the contents of the filter
    // file in an equivelant type.
    //
    cLines = FileLength (pFileFilt);
    cbLineMax = 0;
    for (iLineCur = 0; iLineCur < cLines; iLineCur++) {
        cbLineMax = max (cbLineMax, GetLine (iLineCur, buf, pFileFilt));
    }

    switch (pArg->argType) {
        case NOARG:                         /* filter entire line           */
            DelLine  (pFile,
                      pArg->arg.noarg.y,
                      pArg->arg.noarg.y);
            CopyLine (pFileFilt,
                      pFile,
                      (LINE) 0,
                      (LINE) 0,
                      pArg->arg.noarg.y);
            break;

        case NULLARG:                       /* filter to EOL                */
            DelStream  (pFile,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y,
                        255,
                        pArg->arg.nullarg.y);
            CopyStream (pFileFilt,
                        pFile,
                        (COL) 0,
                        (LINE) 0,
                        cbLineMax,
                        (LINE) 0,
                        pArg->arg.nullarg.x,
                        pArg->arg.nullarg.y);
            break;

        case LINEARG:                       /* filter line range            */
            DelLine  (pFile,
                      pArg->arg.linearg.yStart,
                      pArg->arg.linearg.yEnd);
            CopyLine (pFileFilt,
                      pFile,
                      (LINE) 0,
                      cLines-1,
                      pArg->arg.linearg.yStart);
            break;

        case BOXARG:                        /* filter box                   */
            DelBox  (pFile,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop,
                     pArg->arg.boxarg.xRight,
                     pArg->arg.boxarg.yBottom);
            CopyBox (pFileFilt,
                     pFile,
                     (COL) 0,
                     (LINE) 0,
                     cbLineMax-1,
                     cLines-1,
                     pArg->arg.boxarg.xLeft,
                     pArg->arg.boxarg.yTop);
            break;
    }

    //
    // Clean-up: delete the temporary files we've created
    //
    strcpy (buf, "DEL ");
    strcat (buf, szTemp1);
    DoSpawn (buf);
    strcpy (buf+4, szTemp2);
    DoSpawn (buf);

    return 1;
}



/*** DoSpawn - Execute an OS/2 or DOS command
*
* Purpose:
*  Send the passed strign to OS/2 or DOS for execution.
*
* Input:
*  szCmd	= Command to be executed
*
* Output:
*  Returns TRUE if successfull, else FALSE.
*
*************************************************************************/
flagType pascal
DoSpawn (
    char    *szCmd
    )
{
    char   cmd[BUFLEN];

    strcpy (cmd, "arg \"");
    strcat (cmd, szCmd);
    strcat (cmd, "\" shell");
    return fExecute (cmd);

}





/*** SetFilter - Set filter command to be used
*
* Purpose:
*  Save the passed string paramater as the filter command to be used by the
*  filter function. Called either because the "filtcmd:" switch has been
*  set, or because the filter command recieved a TEXTARG.
*
* Input:
*  szCmd	= Pointer to asciiz filter command
*
* Output:
*  Returns nothing. Command saved
*
*************************************************************************/
void pascal EXTERNAL
SetFilter (
    char far *szCmd
    )
{
    strcpy (filtcmd,szCmd);
}




/*** WhenLoaded - Extension Initialization
*
* Purpose:
*  Executed when extension gets loaded. Identify self, create <filter-file>,
*  and assign default keystroke.
*
* Input:
*  none
*
* Output:
*  Returns nothing. Initializes various data.
*
*************************************************************************/
void EXTERNAL
WhenLoaded (
    void
    )
{

    pFileFilt = FileNameToHandle (szNameFilt,szNameFilt);
    if (!pFileFilt) {
        pFileFilt = AddFile(szNameFilt);
        FileRead (szNameFilt, pFileFilt);
    }
    SetKey ("filter", "alt+f");
    id ("text filter extension:");

}



/*** id - identify extension
*
* Purpose:
*  identify ourselves, along with any passed informative message.
*
* Input:
*  pszMsg	= Pointer to asciiz message, to which the extension name
*		  and version are appended prior to display.
*
* Output:
*  Returns nothing. Message displayed.
*
*************************************************************************/
void pascal id (
    char *pszFcn                                    /* function name        */
    )
{
    char    buf[BUFLEN];                            /* message buffer       */

    strcpy (buf,pszFcn);
    strcat (buf,EXT_ID);
    DoMessage (buf);
}





//
//  Switch communication table to the editor
//
struct swiDesc	swiTable[] = {
    {"filtcmd",     (PIF)(LONG_PTR)(void far *)SetFilter,	SWI_SPECIAL},
    {0, 0, 0}
    };


//
//  Command communiation table to the editor
//
struct cmdDesc	cmdTable[] = {
    {"filter",(funcCmd) filter,0, KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG | MARKARG | NUMARG | TEXTARG | MODIFIES},
    {0, 0, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbrevt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrevt.c

Abstract:

    Event handling code for the MS Editor browser extension.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Notes:

    Currently there is no event handler in this extension.

Revision History:


--*/





#include "mbr.h"



void
pascal
near
mbrevtinit (
    void
    )
/*++

Routine Description:

    Initialization of event handling code.

Arguments:

    None.

Return Value:

    None.

--*/

{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbrdlg.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrdlg.c

Abstract:

    Top-level functions that implement the commands supported by the
    MS Editor browser extension.

Author:

    Ramon Juan San Andres   (ramonsa)   06-Nov-1990


Revision History:


--*/


#include "mbr.h"



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoSetBsc (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Opens a browser database.

Arguments:

    Standard arguments for MEP Editing functions

Return Value:

    FALSE if error, TRUE otherwise

--*/

{
    PBYTE   pName;
    procArgs(pArg);
    pName = pArgText ? pArgText : BscName;

    if (pName) {
        if (! OpenDataBase(pName)) {
            return errstat(MBRERR_CANNOT_OPEN_BSC, pName);
        }
        strcpy(BscName, pName);
        BscArg[0] = '\0';
        BscCmnd   = CMND_NONE;
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoNext (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays next reference or definition.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    NextDefRef();
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoPrev (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays previous reference or definition.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    PrevDefRef();
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoDef (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays first definition of a symbol.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    procArgs(pArg);

    if (BscInUse && pArgText) {
        InitDefRef(Q_DEFINITION, pArgText);
        NextDefRef();
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoRef (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays first reference of a symbol.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/

{
    procArgs(pArg);

    if (BscInUse && pArgText) {
        InitDefRef(Q_REFERENCE, pArgText);
        NextDefRef();
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoLstRef (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    List all references in database matching an MBF criteria.

Arguments:

    Standard arguments for MEP editing functions

Return Value:

    TRUE

--*/
{
    MBF mbfReqd;

    //  The matching criteria may be specified as an argument.
    //
    procArgs(pArg);
    if (procArgs(pArg) != NOARG) {
        mbfReqd = GetMbf(pArgText);
    }

    if (BscInUse) {
        if ((BscCmnd == CMND_LISTREF) && (mbfReqd == mbfNil)) {
            //
            //  Pseudofile already has the information we want
            //
            ShowBrowse();
        } else {
            //
            //  Generate list
            //
            OpenBrowse();
            if (mbfReqd == mbfNil) {
                mbfReqd = BscMbf;
            } else {
                BscMbf = mbfReqd;     // Matching criteria becomes default
            }
            ListRefs(mbfReqd);
            BscCmnd = CMND_LISTREF;
            BscArg[0] = '\0';
        }
        MoveCur(0,0);
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoOutlin (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Generate outline of a module.

Arguments:

    Standard arguments for MEP editing functions.

Return Value:

    FALSE if symbol is not a module,
    TRUE otherwise.

--*/

{

    PFILE   pCurFile;

    procArgs(pArg);

    if (BscInUse) {
        if ((BscCmnd == CMND_OUTLINE) && (!strcmp(pArgText, BscArg))) {
            //
            //  pseudofile already has the information we want
            //
            ShowBrowse();
            MoveCur(0,0);
        } else if (pArgText) {
            //
            //  Make sure that the the symbol is a valid module
            //
            if (ImodFrLsz(pArgText) == imodNil) {
                return errstat(MBRERR_NOT_MODULE, pArgText);
            } else {
                pCurFile = FileNameToHandle("", NULL);
                OpenBrowse();
                if (FOutlineModuleLsz(pArgText,BscMbf)) {
                    //
                    //  Function worked, set command state.
                    //
                    BscCmnd = CMND_OUTLINE;
                    strcpy(BscArg, pArgText);
                    MoveCur(0,0);
                } else {
                    //
                    //  Function failed, restore previous file and reset
                    //  command state.
                    //
                    pFileToTop(pCurFile);
                    BscCmnd     = CMND_NONE;
                    BscArg[0]   = '\0';
                }
            }
        }
    }
    return TRUE;
}



/**************************************************************************/

flagType
pascal
EXTERNAL
mBRdoCalTre (
    IN USHORT      argData,
    IN ARG far     *pArg,
    IN flagType    fMeta
    )
/*++

Routine Description:

    Displays calltree of a symbol.

Arguments:

    Standard arguments for MEP editing functions.

Return Value:

    TRUE

--*/

{

    PFILE   pCurFile;
    BOOL    FunctionWorked;

    procArgs(pArg);

    if (BscInUse) {
        if ((BscCmnd == CMND_CALLTREE) && (!strcmp(pArgText, BscArg))) {
            //
            //  pseudofile already has the information we want.
            //
            ShowBrowse();
            MoveCur(0,0);
        } else if (pArgText) {
            pCurFile = FileNameToHandle("", NULL);
            OpenBrowse();
            //
            //  Generate the tree forward or backward depending on
            //  the value of the direction switch.
            //
            if (BscCalltreeDir == CALLTREE_FORWARD) {
                FunctionWorked = FCallTreeLsz(pArgText);
            } else {
                FunctionWorked = FRevTreeLsz(pArgText);
            }

            if (FunctionWorked) {
                //
                //  Function worked, set command state.
                //
                BscCmnd = CMND_CALLTREE;
                strcpy(BscArg, pArgText);
                MoveCur(0,0);
            } else {
                //
                //  Function failed, restore previous file and
                //  reset command state.
                //
                pFileToTop(pCurFile);
                BscCmnd     = CMND_NONE;
                BscArg[0]   = '\00';
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbr.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbr.h

Abstract:

    Common include file for the MS Editor browser extension.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/


#ifndef EXTINT
#include "ext.h"                        /* mep extension include file     */
#include <string.h>

#if defined (OS2)
#define INCL_DOSPROCESS
#define INCL_DOSMODULEMGR
#define INCL_DOSFILEMGR
#define INCL_DOSMISC
#include <os2.h>                              /* os2 system calls             */
#else
#include <windows.h>
#endif
#endif

#include <hungary.h>
#include <bsc.h>
#include <bscsup.h>
#include <stdlib.h>
#include <stdio.h>
#include <tools.h>



//  rjsa 10/22/90
//  Some runtime library functions are broken, so intrinsics have
//  to be used.
//
#pragma intrinsic (memset, memcpy, memcmp)
//#pragma intrinsic (strset, strcpy, strcmp, strcat, strlen)


// typedef char buffer[BUFLEN];
typedef int  DEFREF;


#define Q_DEFINITION        1
#define Q_REFERENCE         2

#define CMND_NONE           0
#define CMND_LISTREF        1
#define CMND_OUTLINE        2
#define CMND_CALLTREE       3

#define CALLTREE_FORWARD    0
#define CALLTREE_BACKWARD   1



/////////////////////////////////////////////////////////////////////////
//
// Global Data
//

//  Bsc info.
//
flagType    BscInUse;                   /* BSC database selected flag   */
buffer      BscName;                    /* BSC database name            */
MBF         BscMbf;                     /* Last BSC MBF switch          */
int         BscCalltreeDir;             /* Calltree direction switch    */
int         BscCmnd;                    /* Last command performed       */
buffer      BscArg;                     /* Last argument used           */

//  Windows
//
PFILE   pBrowse;                        /* Browse PFILE                 */
LINE    BrowseLine;                     /* Current line within file     */

// results of procArgs.
//
int     cArg;                           /* number of <args> hit         */
rn      rnArg;                          /* range of argument            */
char    *pArgText;                      /* ptr to any single line text  */
char    *pArgWord;                      /* ptr to context-sens word     */
PFILE   pFileCur;                       /* file handle of user file     */


// colors
//
int     hlColor;                        /* normal: white on black       */
int     blColor;                        /* bold: high white on black    */
int     itColor;                        /* italics: high green on black */
int     ulColor;                        /* underline: high red on black */
int     wrColor;                        /* warning: black on white      */

//  misc.
//
buffer  buf;                            /* utility buffer               */



/////////////////////////////////////////////////////////////////////////
//
//  Prototypes of global functions
//


//  mbrdlg.c
//
flagType pascal EXTERNAL mBRdoSetBsc (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoNext   (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoPrev   (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoDef    (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoRef    (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoLstRef (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoOutlin (USHORT argData, ARG far *pArg,  flagType fMeta);
flagType pascal EXTERNAL mBRdoCalTre (USHORT argData, ARG far *pArg,  flagType fMeta);


//  mbrevt.c
//
void pascal mbrevtinit (void);



//  mbrutil.c
//
int         pascal  procArgs    (ARG far * pArg);
void        pascal  GrabWord    (void);
flagType    pascal  wordSepar   (CHAR c);
flagType    pascal  errstat     (char    *sz1,char    *sz2  );
void        pascal  stat        (char * pszFcn);
int far     pascal  SetMatchCriteria (char far *pTxt );
int far     pascal  SetCalltreeDirection (char far *pTxt );
MBF         pascal  GetMbf      (PBYTE   pTxt);


//  mbrfile.c
//
flagType    pascal  OpenDataBase    (char * Path);
void        pascal  CloseDataBase   (void);


//  mbrwin.c
//
void        pascal  OpenBrowse (void );

//  mbrqry.c
//
void        pascal InitDefRef(DEFREF QueryType, char   *Symbol );
void               GotoDefRef(void );
void        pascal MoveToSymbol(LINE Line, char *Buf, char *Symbol);
void               NextDefRef(void );
void               PrevDefRef(void );
BOOL               InstanceTypeMatches(IINST Iinst);


/////////////////////////////////////////////////////////////////////////
//
//  Messages
//
#define MBRERR_CANNOT_OPEN_BSC  "Cannot open bsc database"
#define MBRERR_BAD_BSC_VERSION  "Bad version database"
#define MBRERR_BSC_SEEK_ERROR   "BSC Library: Error seeking in file"
#define MBRERR_BSC_READ_ERROR   "BSC Library: Error reading in file"
#define MBRERR_NOSUCHFILE       "Cannot find file"
#define MBRERR_LAST_DEF         "That is the last definition"
#define MBRERR_LAST_REF         "That is the last reference"
#define MBRERR_FIRST_DEF        "No previous definition"
#define MBRERR_FIRST_REF        "No previous reference"
#define MBRERR_NOT_MODULE       "Not a module name:"
// #define MBRERR_CTDIR_INV        "Valid switch values are: F(orward) B(ackward)"
// #define MBRERR_MATCH_INV        "Valid switch values are combinations of:  T F M V"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbrcore.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrcore.c

Abstract:

    Initialization for the MS Editor browser extension.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/

#include "mbr.h"                        /* help extension include file  */
#include "version.h"                    /* version file                 */



//
//  Use double macro level to force rup to be turned into string
//  representation.
//
#define VER(x,y,z)  VER2(x,y,z)
#define VER2(x,y,z) "Microsoft Editor Browser Version v1.02."###z##" - "##__DATE__" "##__TIME__
#define ID          VER(rmj,rmm,rup)



//
//  Initialization of Global data in mbr.h that needs it.
//
buffer      BscName         = {'\00'};
MBF         BscMbf          = mbfAll;
int         BscCmnd         = CMND_NONE;
buffer      BscArg          = {'\00'};
int         BscCalltreeDir  = CALLTREE_FORWARD;
flagType    BscInUse        = FALSE;




//
//  Initial macro assignments
//
char    *assignments[]  = {
                            "mbrowsesetbsc:alt+b"   ,
                            "mbrowselistref:alt+l"  ,
                            "mbrowsecalltree:alt+t" ,
                            "mbrowseoutline:alt+o"  ,
                            "mbrowsegotodef:alt+d"  ,
                            "mbrowsegotoref:alt+r"  ,
                            "mbrowsenext:ctrl+num+" ,
                            "mbrowseprev:ctrl+num-" ,
                            NULL
                          };


//
//  Switch communication table to MEP
//
//      Switch      Description
//      ------      -----------
//
//      mbrmatch    Set match criteria for references.
//
//                  Values accepted:
//                  String combination of: 'T' (Type)
//                                         'F' (Function)
//                                         'V' (Variable)
//                                         'M' (Macro)
//
//      mbrdir      Set Calltree direction.
//
//                  Values accepted:
//                  One of: 'F' (Forward)
//                          'B' (Backward)
//
struct swiDesc  swiTable[] = {
    {"mbrmatch", SetMatchCriteria,      SWI_SPECIAL},
    {"mbrdir",   SetCalltreeDirection,  SWI_SPECIAL},
    {0, 0, 0}
};



//
//  Command communication table to MEP
//
//
//      Command         Description
//      -------         -----------
//
//     mbrowsenext      Display next Definition/Reference
//     mbrowseprev      Display previous Definition/Reference
//     mbrowsesetbsc    Open BSC database
//     mbrowsegotodef   Display first Definition
//     mbrowsegotoref   Display first reference
//     mbrowselistref   List all references in database
//     mbrowseoutline   Display outline
//     mbrowsecalltree  Display calltree
//
//
struct cmdDesc	cmdTable[] = {
    { "mbrowsenext",    mBRdoNext,      0, NOARG },
    { "mbrowseprev",    mBRdoPrev,      0, NOARG },
    { "mbrowsesetbsc",  mBRdoSetBsc,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowsegotodef", mBRdoDef,       0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowsegotoref", mBRdoRef,       0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowselistref", mBRdoLstRef,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowseoutline", mBRdoOutlin,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    { "mbrowsecalltree",mBRdoCalTre,    0, NOARG | BOXARG | STREAMARG | TEXTARG },
    {0, 0, 0, 0}
};





void
EXTERNAL
WhenLoaded (
    void
    )
/*++

Routine Description:

    Called by MEP when extension is loaded.

Arguments:

    None.

Return Value:

    None.

--*/

    {
    char        **pAsg;
    static char *szBrowseName = "<mbrowse>";
    PSWI        fgcolor;
    int         ref;

    DoMessage (ID);                         /* display signon               */

    // Make default key assignments, & create default macros.
    //
    strcpy (buf, "arg \"");
    for (pAsg = assignments; *pAsg; pAsg++) {
        strcpy (buf+5, *pAsg);
        strcat (buf, "\" assign");
        fExecute (buf);
    }

    // Set up the colors that we will use.
    //
    if (fgcolor = FindSwitch("fgcolor")) {
        hlColor = *fgcolor->act.ival;
        blColor |= hlColor & 0xf0;
        itColor |= hlColor & 0xf0;
        ulColor |= hlColor & 0xf0;
        wrColor |= (hlColor & 0x70) >> 8;
    }

    //
    //  create the pseudo file we'll be using for browser.
    //
    if (pBrowse = FileNameToHandle(szBrowseName,NULL))
        DelFile (pBrowse);
    else {
        pBrowse = AddFile (szBrowseName);
        FileRead (szBrowseName, pBrowse);
    }

    //
    // Increment the file's reference count so it can't be discarded
    //
    GetEditorObject (RQ_FILE_REFCNT | 0xff, pBrowse, &ref);
    ref++;
    SetEditorObject (RQ_FILE_REFCNT | 0xff, pBrowse, &ref);

    //
    //  Initialize event stuff
    //
    mbrevtinit ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\calbak.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    calbak.c

Abstract:

    Callback functions needed by the bsc library.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/

/**************************************************************************/

#include "stdlib.h"
#include "mbr.h"


typedef char bscbuf[2048];

/**************************************************************************/

LPV
BSC_API
LpvAllocCb (
    IN WORD cb
    )
/*++

Routine Description:

    Allocates block of memory.

Arguments:

    cb - Supplies size of block.

Return Value:

    Pointer to block of memory of size cb, or NULL

--*/

{
    return (LPV)malloc(cb);
}



/**************************************************************************/

VOID
BSC_API
FreeLpv (
    IN LPV lpv
    )
/*++

Routine Description:

    Frees a block of memory.

Arguments:

    lpv -   Suplies a pointer to the block of memory to free.

Return Value:

    None.

--*/

{
    free(lpv);
}



/**************************************************************************/

VOID
BSC_API
SeekError (
    IN LSZ lszFileName
    )
/*++

Routine Description:

    Error handling for seek operations.

Arguments:

    lszFileName - Supplies the name of the file.

Return Value:

    None.

--*/

{
    errstat(MBRERR_BSC_SEEK_ERROR, lszFileName);
}



/**************************************************************************/

VOID
BSC_API
ReadError (
    IN LSZ lszFileName
    )
/*++

Routine Description:

    Error handling for read operations.

Arguments:

    lszFileName - Supplies the name of the file.

Return Value:

    None.

--*/

{
    errstat(MBRERR_BSC_READ_ERROR, lszFileName);
}



/**************************************************************************/

VOID
BSC_API
BadBSCVer (
    IN LSZ lszFileName
    )
/*++

Routine Description:

    Error handling for bad version number.

Arguments:

    lszFileName - Supplies the name of the file.
    .
    .

Return Value:

    None.

--*/

{
    errstat(MBRERR_BAD_BSC_VERSION, lszFileName);
}



/**************************************************************************/

FILEHANDLE
BSC_API
BSCOpen (
    IN LSZ lszFileName,
    IN FILEMODE mode
    )
/*++

Routine Description:

    Opens a file.

Arguments:

    lszFileName -   Supplies the name of the file.
    mode        -   Supplies the mode with which to open the file.

Return Value:

    File handle for the opened file. -1 if error.

--*/

{
#if defined (OS2)
    bscbuf b;

    strcpy(b, lszFileName);
    return open(b, mode);
#else
    return CreateFile( lszFileName, mode, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
#endif
}



/**************************************************************************/

int
BSC_API
BSCRead (
    IN  FILEHANDLE  handle,
    OUT LPCH        lpchBuf,
    IN  WORD        cb
    )
/*++

Routine Description:

    Reads in the specified number of bytes.

Arguments:

    handle  -   Supplies the file handle.
    lpchBuf -   Supplies pointer to buffer.
    cb      -   Supplies number of bytes to read.

Return Value:

    Number of bytes read

--*/

{
#if defined (OS2)
    bscbuf b;

    while (cb > sizeof(b)) {
        if (read(handle, b, sizeof(b)) == -1) {
            return -1;
        }
        memcpy(lpchBuf, b, sizeof(b));
        cb -= sizeof(b);
        lpchBuf += sizeof(b);
    }

    if (read(handle, b, cb) == -1) {
        return -1;
    }
    memcpy(lpchBuf, b, cb);
    return cb;
#else
    DWORD BytesRead;
    if ( !ReadFile(handle, lpchBuf, cb, &BytesRead, NULL) ) {
        return -1;
    } else {
        return BytesRead;
    }
#endif
}



/**************************************************************************/

int
BSC_API
BSCClose (
    IN FILEHANDLE handle
    )
/*++

Routine Description:

    Closes a handle.

Arguments:

    handle - Supplies the handle to be closed.

Return Value:

    0 if the file was successfully closed, -! if error.

--*/

{
#if defined (OS2)
    return close(handle);
#else
    return !CloseHandle( handle );
#endif
}



/**************************************************************************/

int
BSC_API
BSCSeek (
    FILEHANDLE  handle,
    long        lPos,
    FILEMODE    mode
    )
/*++

Routine Description:

    Seek (change file pointer).

Arguments:

    handle  -   Supplies the file handle.
    lPos    -   Supplies the offset from the position specified by mode.
    mode    -   Supplies the initial position. Must be one of the SEEK_*
                values of the lseek C library function.


Return Value:

    0 if successful, -1 if error.

--*/

{
#if defined (OS2)
    if (lseek(handle, lPos, mode) == -1) {
        return -1;
    } else {
        return 0;
    }
#else
    if (SetFilePointer( handle, lPos, 0L, mode) == -1) {
        return -1;
    } else {
        return 0;
    }
#endif
}




/**************************************************************************/

VOID
BSC_API
BSCOutput (
    IN LSZ lsz
    )
/*++

Routine Description:

    Outputs a given string.

Arguments:

    lsz - Supplies the string to be output.

Return Value:

    None.

--*/

{
    // PWND        pWinCur;
    // winContents wc;
    USHORT      len;             // Length of string
    PBYTE       p;
    PFILE       pFile;           // Current file


    pFile = FileNameToHandle("", NULL);

    //GetEditorObject (RQ_WIN_HANDLE, 0, &pWinCur);
    //GetEditorObject (RQ_WIN_CONTENTS | 0xff, pWinCur, &wc);

    len = strlen(lsz);

    while (len) {
        //
        //  We output the string one line at a time.
        //
        p = lsz;

        while (len--) {
            if (*lsz != '\n') {
                lsz++;
            } else {
                *lsz++ = '\00';
                break;
            }
        }

        // if ((wc.pFile == pBrowse) && BscInUse) {
        if ((pFile == pBrowse) && BscInUse) {
            //
            //  Display in Browser window
            //
            PutLine(BrowseLine++, p, pBrowse);
        } else {
            //
            //  Display in status line
            //
            errstat(p,NULL);
        }
    }
}



/**************************************************************************/

#ifdef DEBUG
VOID BSC_API
BSCDebugOut(LSZ lsz)
// ignore debug output by default
//
{
    // unreferenced lsz
    lsz = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbrutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrutil.c

Abstract:

    This file contains miscelaneous functions used in the browser extension.
    These functions include argument processing, message displaying,
    setting of switches, etc.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/


#include "mbr.h"




/**************************************************************************/

int
pascal
procArgs (
    IN ARG far * pArg
    )
/*++

Routine Description:

    Decodes arguments passed into extension into commonly used
    variables.

Arguments:

    pArg    -   Supplies a pointer to the arguments.

Return Value:

    The type of the argument.

--*/

{

    buf[0]   = 0;
    cArg     = 0;
    pArgWord = 0;
    pArgText = 0;
    rnArg.flFirst.col = rnArg.flLast.col = 0;
    rnArg.flFirst.lin = rnArg.flLast.lin = 0;

    pFileCur = FileNameToHandle ("", "");   /* get current file handle      */

    switch (pArg->argType) {
        case NOARG:                         /* <function> only, no arg      */
            cArg = pArg->arg.nullarg.cArg;  /* get <arg> count              */
            GrabWord ();                    /* get argtext and argword      */
            break;

        case NULLARG:                       /* <arg><function>              */
            cArg = pArg->arg.nullarg.cArg;  /* get <arg> count              */
            GrabWord ();                    /* get argtext and argword      */
            break;

        case STREAMARG:                     /* <arg>line movement<function> */
            cArg = pArg->arg.streamarg.cArg;/* get <arg> count              */
            rnArg.flFirst.col = pArg->arg.streamarg.xStart;
            rnArg.flLast.col  = pArg->arg.streamarg.xEnd;
            rnArg.flFirst.lin = pArg->arg.streamarg.yStart;
            if (GetLine(rnArg.flFirst.lin, buf, pFileCur) > rnArg.flFirst.col) {
                pArgText = &buf[rnArg.flFirst.col];  /* point at word                */
                buf[rnArg.flLast.col] = 0;           /* terminate string             */
                }
            break;

        case TEXTARG:                       /* <arg> text <function>        */
            cArg = pArg->arg.textarg.cArg;  /* get <arg> count              */
            pArgText = pArg->arg.textarg.pText;
            break;
        }
    return pArg->argType;
}



/**************************************************************************/

void
pascal
GrabWord (
    void
    )
/*++

Routine Description:

    Grabs the word underneath the cursor.
    Upon exit, pArgText points to the word

Arguments:

    None

Return Value:

    None.

--*/

{

    pArgText = pArgWord = 0;
    pFileCur = FileNameToHandle ("", "");               // get current file handle
    GetTextCursor (&rnArg.flFirst.col, &rnArg.flFirst.lin);
    if (GetLine(rnArg.flFirst.lin, buf, pFileCur)) {
        //
        //  get line
        //
        pArgText = &buf[rnArg.flFirst.col];             //  point at word
        while (!wordSepar((int)*pArgText)) {
            //
            //  Search for end
            //
            pArgText++;
        }
        *pArgText = 0;      // and terminate

        pArgWord = pArgText = &buf[rnArg.flFirst.col];  // point at word
        while ((pArgWord > &buf[0]) && !wordSepar ((int)*(pArgWord-1))) {
            pArgWord--;
        }
    }
}



/**************************************************************************/

flagType
pascal
wordSepar (
    IN CHAR c
)
/*++

Routine Description:

    Find out if character is a word separator.

    A word separator is anything not in the [a-z, A-Z, 0-9] set.

Arguments:

    c   -   Supplies the character.

Return Value:

    TRUE if c is a word separator, FALSE otherwise

--*/

{

    if (((c >= 'a') && (c <= 'z')) ||
        ((c >= 'A') && (c <= 'Z')) ||
        ((c >= '0') && (c <= '9'))) {
        return FALSE;
    } else {
        return TRUE;
    }
}



/**************************************************************************/

flagType
pascal
errstat (
    IN char    *sz1,
    IN char    *sz2
    )
/*++

Routine Description:

    Concatenates two strings and displays them on the status line.

Arguments:

    sz1 -   Supplies a pointer to the first string
    sz2 -   Supplies a pointer to the second string.

Return Value:

    FALSE

--*/

{

    buffer buf;
    strcpy (buf, sz1);
    if (sz2) {
        strcat (buf, " ");
        strcat (buf, sz2);
        }
    _stat (buf);
    return FALSE;
}



/**************************************************************************/

void
pascal
_stat (
    IN char * pszFcn
    )
/*++

Routine Description:

    Displays extension name and message on the status line

Arguments:

    pszFcn  -   Message to display

Return Value:

    None.

--*/

{
    buffer  buf;                                    /* message buffer       */

    strcpy(buf,"mbrowse: ");                        /* start with name      */
    if (strlen(pszFcn) > 72) {
        pszFcn+= strlen(pszFcn) - 69;
        strcat (buf, "...");
    }
    strcat(buf,pszFcn);                             /* append message       */
    DoMessage (buf);                                /* display              */
}



/**************************************************************************/

int
far
pascal
SetMatchCriteria (
    IN char far *pTxt
    )
/*++

Routine Description:

    Sets the mbrmatch switch.
    Creates an MBF mask from the given string and sets the BscMbf variable.

Arguments:

    pTxt    -   Supplies the string containing the new default
                match criteria.

Return Value:

    TRUE if string contains a valid value.
    FALSE otherwise

--*/

{
    MBF mbfReqd;

    mbfReqd = GetMbf(pTxt);

    if (mbfReqd != mbfNil) {
        BscMbf = mbfReqd;
    } else {
        return FALSE;
    }
    BscCmnd = CMND_NONE;  // reset command state
    return TRUE;
}



/**************************************************************************/

int
far
pascal
SetCalltreeDirection (
    IN char far *pTxt
    )
/*++

Routine Description:

    Sets the mbrdir switch.
    Sets the BscCalltreeDir variable to CALLTREE_FORWARD or
        CALLTREE_BACKWARD, depending on the first character of the
        string supplied.

    The given string must start with either 'F' or 'B'.

Arguments:

    pTxt    -   Supplies the string containing the new default
                direction.

Return Value:

    TRUE if the string contains a valid value,
    FALSE otherwise.

--*/

{
    switch(*pTxt) {

    case 'f':
    case 'F':
        BscCalltreeDir = CALLTREE_FORWARD;
        break;

    case 'b':
    case 'B':
        BscCalltreeDir = CALLTREE_BACKWARD;
        break;

    default:
        return FALSE;
        break;
    }
    BscCmnd = CMND_NONE;  // Reset command state
    return TRUE;
}



/**************************************************************************/

MBF
pascal
GetMbf(
    IN PBYTE   pTxt
    )
/*++

Routine Description:

    Creates an MBF mask from a given string.
    The string is parsed for the characters 'T', 'V', 'F', and 'M'.

Arguments:

    pTxt    -   Supplies a pointer to string

Return Value:

    MBF mask generated from string

--*/

{

    MBF mbfReqd = mbfNil;

    if (pTxt) {
        while (*pTxt) {
            switch(*pTxt++) {
            case 'f':
            case 'F':
                mbfReqd |= mbfFuncs;
                break;

            case 'v':
            case 'V':
                mbfReqd |= mbfVars;
                break;

            case 'm':
            case 'M':
                mbfReqd |= mbfMacros;
                break;

            case 't':
            case 'T':
                mbfReqd |= mbfTypes;
                break;

            default:
                break;
            }
        }
    }
    return mbfReqd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbrfile.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrfile.c

Abstract:

    BSC database file Opening and closing code for the MS Editor
    browser extension.

Author:

    Ramon Juan San Andres   (ramonsa)   06-Nov-1990


Revision History:


--*/



#include "mbr.h"
#include <fcntl.h>



/**************************************************************************/

flagType
pascal
OpenDataBase (
    IN char * Path
    )
/*++

Routine Description:

    Opens a BSC database.

Arguments:

    Path    -   Name of file containing database

Return Value:

    TRUE if database opened successfully, FALSE otherwise.

--*/

{

    if (BscInUse) {
        CloseBSC();
    }
    if (!FOpenBSC(Path)) {
        BscInUse  = FALSE;
    } else {
        BscInUse = TRUE;
    }

    return BscInUse;
}



/**************************************************************************/

void
pascal
CloseDataBase (
    void
    )
/*++

Routine Description:

    Closes current BSC database.

Arguments:

    None

Return Value:

    None.

--*/

{
    CloseBSC();
    BscInUse = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbrqry.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrqry.c

Abstract:

    This file contains the functions that perform the queries to the
    database. These functions are called by the top-level functions
    which implement the browser commands (see mbrdlg.c).

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1990


Revision History:


--*/


#include "mbr.h"


//  INST_MATCHES_CRITERIA
//
//  This macro is used to find out if an instance matches the
//  current MBF criteria.
//
#define INST_MATCHES_CRITERIA(Iinst)  FInstFilter(Iinst, BscMbf)



//
//  Static variables reflect the current state of
//  Definition/Reference queries.
//
static IREF    LastiRef;            //  Last reference index
static IREF    iRefMin, iRefMax;    //  Current reference index range

static IDEF    LastiDef;            //  Last definition index
static IDEF    iDefMin, iDefMax;    //  Current definition index range

static IINST   LastIinst;           //  Last instance index
static IINST   IinstMin, IinstMax;  //  Current instance index range

static DEFREF  LastQueryType;       //  last query type:
                                    //      Q_DEFINITION or
                                    //      Q_REFERENCE

static buffer  LastSymbol;          //  Last symbol queried.




/**************************************************************************/

void
pascal
InitDefRef(
    IN DEFREF QueryType,
    IN char   *Symbol
    )
/*++

Routine Description:

    Initializes the query state, this must be done before querying for
    the first definition/reference of a symbol.

    After calling this function, the first definition/reference must be
    obtained by calling the NextDefRef function.

Arguments:

    QueryType   -   Type of query (Q_DEFINITION or Q_REFERENCE).
    Symbol      -   Symbol name.

Return Value:

    None.

--*/

{

    ISYM Isym;

    LastQueryType = QueryType;
    strcpy(LastSymbol, Symbol);

    Isym = IsymFrLsz(Symbol);

    InstRangeOfSym(Isym, &IinstMin, &IinstMax);

    LastIinst = IinstMin;

    if (QueryType == Q_DEFINITION) {
        DefRangeOfInst(LastIinst, &iDefMin, &iDefMax);
        LastiDef = iDefMin - 1;
    } else {
        RefRangeOfInst(LastIinst, &iRefMin, &iRefMax);
        LastiRef = iRefMin - 1;
    }
}



/**************************************************************************/

void
GotoDefRef (
    void
    )
/*++

Routine Description:

    Makes the file containing the current definition/reference the
    current file and positions the cursor in the line where the
    definition/reference takes place.

    The state of the query (current instance and definition/reference
    indexes) must be set before calling this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

    char    *pName = NULL;
    WORD    Line   = 0;
    PFILE   pFile;
    char    szFullName[MAX_PATH];


    szFullName[0] = '\0';
    if (LastQueryType == Q_DEFINITION) {
        DefInfo(LastiDef, &pName, &Line);
    } else {
        RefInfo(LastiRef, &pName, &Line);
    }

    if (BscInUse && pName) {

        if (rootpath(pName, szFullName)) {
            strcpy(szFullName, pName);
        }

        pFile = FileNameToHandle(szFullName,NULL);

        if (!pFile) {
            pFile = AddFile(szFullName);
            if (!FileRead(szFullName, pFile)) {
                RemoveFile(pFile);
                pFile = NULL;
            }
        }

        if (!pFile) {
            errstat(MBRERR_NOSUCHFILE, szFullName);
            return;
        }
        pFileToTop(pFile);
        MoveCur(0,Line);
        GetLine(Line, buf, pFile);
        MoveToSymbol(Line, buf, LastSymbol);
    }
}



/**************************************************************************/

void
pascal
MoveToSymbol(
    IN LINE Line,
    IN char *Buf,
    IN char *Symbol
    )
/*++

Routine Description:

    Moves the cursor to the first occurance of a symbol within
    a line.  It is case-sensitive.

Arguments:

    Line    -   Line number
    Buf     -   Contents of the line
    Symbol  -   Symbol to look for.

Return Value:

    None.

--*/

{

    //  First Symbol within Buf
    //
    char *p = Buf;
    char *q = Symbol;
    char *Mark;

    while (*p) {
        //
        // Look for first character
        //
        if (*p == *q) {
            Mark = p;
            //
            //  compare rest
            //
            while (*p && *q && *p == *q) {
                p++;
                q++;
            }
            if (*q) {
                q = Symbol;
                p = Mark+1;
            } else {
                break;
            }
        } else {
            p++;
        }
    }

    if (!*q) {
        MoveCur((COL)(Mark-Buf), Line);
    }
}



/**************************************************************************/

void
NextDefRef (
    void
    )
/*++

Routine Description:

    Displays next definition or reference of a symbol.

Arguments:

    None

Return Value:

    None.

--*/

{

    IINST   Iinst;


    //  For locating the next def/ref we do the following:
    //
    //  1.- If the def/ref index is within the current range, we just
    //      increment it.
    //  2.- Otherwise we look for the next instance that matches the
    //      MBF criteria, and set the def/ref index to the min value of
    //      the def/ref range for that instance.
    //  3.- If no next instance is found, we display an error message
    //

    if (LastQueryType == Q_DEFINITION) {
        if (LastiDef == iDefMax-1) {

            Iinst = LastIinst;

            do {
                LastIinst++;
            } while ((LastIinst < IinstMax) &&
                     (!INST_MATCHES_CRITERIA(LastIinst)));

            if (LastIinst == IinstMax ) {
                LastIinst = Iinst;
                errstat(MBRERR_LAST_DEF, "");
                return;
            } else {
                DefRangeOfInst(LastIinst, &iDefMin, &iDefMax);
                LastiDef = iDefMin;
            }

        } else {
            LastiDef++;
        }
    } else {
        if (LastiRef == iRefMax-1) {

            Iinst = LastIinst;

            do {
                LastIinst++;
            } while ((LastIinst < IinstMax) &&
                     (!INST_MATCHES_CRITERIA(LastIinst)));

            if (LastIinst == IinstMax) {
                LastIinst = Iinst;
                errstat(MBRERR_LAST_REF, "");
                return;
            } else {
                RefRangeOfInst(LastIinst, &iRefMin, &iRefMax);
                LastiRef = iRefMin;
            }
        } else {
            LastiRef++;
        }
    }
    GotoDefRef();
}



/**************************************************************************/

void
PrevDefRef (
    void
    )
/*++

Routine Description:

    Displays the previous definition or reference of a symbol.

Arguments:

    None

Return Value:

    None.

--*/

{

    IINST   Iinst;
    BOOL    Match;

    //  For locating the previous def/ref we do the following:
    //
    //  1.- if the def/ref index is within the current range, we
    //      just decrement it.
    //  2.- Otherwise we look for the most previous instance that
    //      matches the MBF criteria, and set the def/ref index to
    //      the maximum value within the def/ref range for that
    //      instance.
    //  3.- If not such instance exist, we display an error message.
    //

    if (LastQueryType == Q_DEFINITION) {
        if (LastiDef == iDefMin) {

            if (LastIinst == IinstMin) {
                errstat(MBRERR_FIRST_DEF, "");
                return;
            }

            Iinst = LastIinst;

            do {
                Iinst--;
            } while ((LastIinst > IinstMin) &&
                     (!(Match = INST_MATCHES_CRITERIA(LastIinst))));

            if (!Match) {
                LastIinst = Iinst;
                errstat(MBRERR_FIRST_DEF, "");
                return;
            } else {
                DefRangeOfInst(LastIinst, &iDefMin, &iDefMax);
                LastiDef = iDefMax - 1;
            }

        } else {
            LastiDef--;
        }
    } else {
        if (LastiRef == iRefMin) {

            if (LastIinst == IinstMin) {
                errstat(MBRERR_FIRST_REF, "");
                return;
            }

            Iinst = LastIinst;

            do {
                Iinst--;
            } while ((LastIinst > IinstMin) &&
                     (!(Match = INST_MATCHES_CRITERIA(LastIinst))));

            if (!Match) {
                LastIinst = Iinst;
                errstat(MBRERR_FIRST_REF, "");
                return;
            } else {
                RefRangeOfInst(LastIinst, &iRefMin, &iRefMax);
                LastiRef = iRefMax - 1;
            }

        } else {
            LastiRef--;
        }
    }
    GotoDefRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mbrowse\mbrwin.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mbrwin.c

Abstract:

    Functions dealing with opening and displaying the browse window.

Author:

    Ramon Juan San Andres (ramonsa) 06-Nov-1990


Revision History:


--*/

#include "mbr.h"



/**************************************************************************/

void
pascal
OpenBrowse (
    void
    )
/*++

Routine Description:

    Opens a window on the browser file, empties it and makes it current

Arguments:

    None

Return Value:

    None.

--*/

{

    DelFile (pBrowse);
    pFileToTop (pBrowse);
    BrowseLine = 0;
}



/**************************************************************************/

void
pascal
ShowBrowse (
    void
    )
/*++

Routine Description:

    Makes the browser file current.

Arguments:

    None

Return Value:

    None.

--*/

{

    pFileToTop (pBrowse);
    BrowseLine = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mepparty\mepparty.c ===
/*
** MEP Party extension
**
** History:
**	17-Oct-1991	Ported to NT
**
*/

#define _CTYPE_DISABLE_MACROS
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "ext.h"
#include <winuserp.h>

#ifndef TRUE
#define TRUE	-1
#define FALSE	0
#endif

flagType iconizeOnExit = TRUE;

flagType pascal DoCaseLine(
    PFILE CurFile,
    LINE y,
    COL x,
    COL maxX,
    flagType LowerCase
    )
{
    flagType Modified;
    int cb;
    char buf[ BUFLEN ], *s;

    cb = GetLine( y, buf, CurFile );
    s = &buf[ x ];
    if (maxX != 0) {
        if (maxX - x < cb) {
            cb = maxX - x + 1;
            }
        }
    else {
        cb -= x;
        }

    Modified = FALSE;
    while (cb--) {
        if (LowerCase) {
            if (*s >= 'A' && *s <= 'Z') {
                *s -= 'A' - 'a';
                Modified = TRUE;
                }
            }
        else {
            if (*s >= 'a' && *s <= 'z') {
                *s += 'A' - 'a';
                Modified = TRUE;
                }
            }

        s++;
        }

    if (Modified) {
        PutLine( y, buf, CurFile );
        }

    return( TRUE );
}


flagType pascal EXTERNAL
Case(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    int i;
    PFILE CurFile;

    CurFile = FileNameToHandle("",NULL);
    switch( pArg->argType ) {
        case NOARG:
            return( DoCaseLine( CurFile, pArg->arg.noarg.y, 0, 0, fMeta ) );
            break;

        case NULLARG:
            return( DoCaseLine( CurFile,
                                pArg->arg.nullarg.y,
                                pArg->arg.nullarg.x,
                                0,
                                fMeta
                              )
                  );
            break;

        case LINEARG:
            for (i=pArg->arg.linearg.yStart; i<=pArg->arg.linearg.yEnd; i++) {
                if (!DoCaseLine( CurFile, (LINE)i, 0, 0, fMeta )) {
                    return( FALSE );
                    }
                }

            return( TRUE );
            break;

        case BOXARG:
            for (i=pArg->arg.boxarg.yTop; i<=pArg->arg.boxarg.yBottom; i++) {
                if (!DoCaseLine( CurFile,
                                 (LINE)i,
                                 pArg->arg.boxarg.xLeft,
                                 pArg->arg.boxarg.xRight,
                                 fMeta
                               )
                   ) {
                    return( FALSE );
                    }
                }

            return( TRUE );
            break;

        default:
            BadArg();
            return( FALSE );
        }

    argData;
}

int CountMsgFiles;
int MsgFileIndex;
HANDLE MsgFiles[ 2 ];
int MsgFileOffsetIndex;
LONG MsgFileOffsets[ 3 ];

char
GetHexDigit(
    ULONG value,
    int index
    )
{
    int digit;

    if (index < 4) {
        index <<= 2;
        digit = (int)((value >> index) & 0xF);
        }
    else {
        digit = 0;
        }
    if (digit <= 9) {
        return( (char)(digit+'0') );
        }
    else {
        return( (char)((digit-10)+'A') );
        }
}

void
MyFormatMessage(
    char *buf,
    char *msg,
    long value1,
    long value2
    );

void
MyFormatMessage(
    char *buf,
    char *msg,
    long value1,
    long value2
    )
{
    char c, *src, *dst;
    long value;

    src = msg;
    dst = buf;
    while (c = *src++) {
        if (c == '%' && src[1] == 'x') {
            if (*src == '1') {
                value = value1;
                }
            else {
                value = value2;
                }

            *dst++ = GetHexDigit( value, 3 );
            *dst++ = GetHexDigit( value, 2 );
            *dst++ = GetHexDigit( value, 1 );
            *dst++ = GetHexDigit( value, 0 );
            src++;
            src++;
            }
        else {
            *dst++ = c;
            }
        }

    *dst = '\0';
    DoMessage( buf );
}

flagType pascal EXTERNAL
ShowBuildMessage(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    int i, BytesRead, BytesScanned, linenum;
    ULONG NewOffset;
    char LineBuffer[ 256 ], *s, *s1;

    if (!fMeta && CountMsgFiles == 0) {
        MsgFileIndex = 0;
        MsgFiles[ MsgFileIndex ] = CreateFile( "build.wrn",
                                               GENERIC_READ,
                                               FILE_SHARE_READ,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL
                                             );
        if (MsgFiles[ MsgFileIndex ] != INVALID_HANDLE_VALUE) {
            CountMsgFiles++;
            MsgFileIndex++;
            }

        MsgFiles[ MsgFileIndex ] = CreateFile( "build.err",
                                               GENERIC_READ,
                                               FILE_SHARE_READ,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL
                                             );
        if (MsgFiles[ MsgFileIndex ] != INVALID_HANDLE_VALUE) {
            CountMsgFiles++;
            MsgFileIndex++;
            }

        MsgFileIndex = 0;
        MsgFileOffsetIndex = 0;
        MsgFileOffsets[ 0 ] = 0L;
        MsgFileOffsets[ 1 ] = 0L;
        MsgFileOffsets[ 2 ] = 0L;
        }
    else
    if (fMeta && CountMsgFiles != 0) {
        for (i=0; i<CountMsgFiles; i++) {
            CloseHandle( MsgFiles[ i ] );
            }

        CountMsgFiles = 0;
        return( TRUE );
        }

    if (CountMsgFiles == 0) {
        DoMessage( "No BUILD.WRN or BUILD.ERR message file." );
        return( FALSE );
        }

    switch( pArg->argType ) {
        case NULLARG:
            if (MsgFileOffsetIndex-- == 0) {
                MsgFileOffsetIndex = 2;
                }
            //
            // fall through
            //

        case NOARG:
retrymsgfile:
            NewOffset = SetFilePointer( MsgFiles[ MsgFileIndex ],
                                        MsgFileOffsets[ MsgFileOffsetIndex ],
                                        NULL,
                                        FILE_BEGIN
                                      );
            if (NewOffset == -1) {
                MyFormatMessage( LineBuffer,
                                 "SetFilePointer( %1x ) failed - rc == %2x",
                                 MsgFileOffsets[ MsgFileOffsetIndex ],
                                 GetLastError()
                               );
                DoMessage( LineBuffer );
                return( FALSE );
                }

            if (!ReadFile( MsgFiles[ MsgFileIndex ],
                           LineBuffer,
                           sizeof( LineBuffer ),
			   ( LPDWORD )&BytesRead,
                           NULL
                         )
               ) {
                MyFormatMessage( LineBuffer,
                                 "ReadFile( %1x ) failed - rc == %2x",
                                 (ULONG)BytesRead,
                                 GetLastError()
                               );
                DoMessage( LineBuffer );
                return( FALSE );
                }

            s = LineBuffer;
            BytesScanned = 0;
            while (BytesScanned < BytesRead) {
                BytesScanned++;
                if (*s == '\n') {
                    *s = '\0';
                    break;
                    }
                else
                if (*s == '\r' && s[1] == '\n') {
                    *s = '\0';
                    BytesScanned++;
                    break;
                    }
                else {
                    s++;
                    }
                }

            if (BytesScanned == 0) {
                if (++MsgFileIndex == CountMsgFiles) {
                    for (i=0; i<CountMsgFiles; i++) {
                        CloseHandle( MsgFiles[ i ] );
                        }

                    CountMsgFiles = 0;
                    DoMessage( "no more BUILD messages" );
                    return( FALSE );
                    }
                else {
                    MsgFileOffsetIndex = 0;
                    MsgFileOffsets[ 0 ] = 0L;
                    MsgFileOffsets[ 1 ] = 0L;
                    MsgFileOffsets[ 2 ] = 0L;
                    goto retrymsgfile;
                    }
                }
            else {
                NewOffset = MsgFileOffsets[ MsgFileOffsetIndex ];

                if (++MsgFileOffsetIndex == 3) {
                    MsgFileOffsetIndex = 0;
                    }

                MsgFileOffsets[ MsgFileOffsetIndex ] = NewOffset + BytesScanned;
                }

            s = LineBuffer;
            while (*s) {
                if (*s == '(') {
                    *s++ = '\0';
                    s1 = s;
                    while (*s && isdigit( *s )) {
                        s++;
                        }
                    *s++ = '\0';
                    linenum = atoi( s1 );
                    while (*s) {
                        if (*s++ == ':') {
                            fChangeFile( FALSE, LineBuffer );
                            MoveCur( 0, (LINE)(linenum-1) );
                            fExecute( "begline" );
                            DoMessage( s+1 );
                            return( TRUE );
                            }
                        }
                    }
                else {
                    s++;
                    }
                }
            goto retrymsgfile;

        default:
            BadArg();
            return( FALSE );
        }

    return( TRUE );

    argData;
}

char ErrorText[ 64 ],
     Arguments[ 64 + MAX_PATH ],
     PathName[ MAX_PATH ];

flagType pascal EXTERNAL
SlmOut(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    PFILE CurFile;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    DWORD ExitCode;
    char *FileName;
    DWORD FileFlags;

    CurFile = FileNameToHandle( (char far *)"", (char far *)NULL );
    FileFlags = 0;
    GetEditorObject( 0xFF | RQ_FILE_FLAGS,  CurFile, (PVOID)&FileFlags );
    GetEditorObject( 0xFF | RQ_FILE_NAME, CurFile, (PVOID)PathName );

    FileName = PathName + strlen( PathName );
    while (FileName > PathName) {
        if (*--FileName == '\\') {
            *FileName++ = '\0';
            break;
            }
        }

    if (FileName > PathName) {
        if (fMeta) {
            strcpy( Arguments, "in -i " );
            }
        else {
            strcpy( Arguments, "out -z " );
            }

        strcat( Arguments, FileName );
        DoMessage( Arguments );

        memset( &StartupInfo, 0, sizeof( StartupInfo ) );
        StartupInfo.cb = sizeof(StartupInfo);

        if (CreateProcess( NULL,
                           Arguments,
                           NULL,
                           NULL,
                           FALSE,
                           0,
                           NULL,
                           PathName,
                           &StartupInfo,
                           &ProcessInformation
                         )
           ) {
            WaitForSingleObject( ProcessInformation.hProcess, (DWORD)-1 );
            if (!GetExitCodeProcess( ProcessInformation.hProcess, &ExitCode )) {
                ExitCode = 1;
                }
            CloseHandle( ProcessInformation.hProcess );
            CloseHandle( ProcessInformation.hThread );
            }
        else {
            ExitCode = 1;
            }

        if (ExitCode == 0) {
            if (!fMeta && FileFlags & DIRTY) {
                FileFlags &= ~(REFRESH|READONLY);
                SetEditorObject( 0xFF | RQ_FILE_FLAGS,  CurFile, (PVOID)&FileFlags );
                GetEditorObject( 0xFF | RQ_FILE_NAME, CurFile, (PVOID)PathName );
                fChangeFile( FALSE, PathName );
                FileFlags = 0;
                GetEditorObject( 0xFF | RQ_FILE_FLAGS,  CurFile, (PVOID)&FileFlags );
                if (FileFlags & DIRTY) {
                    DoMessage( "Modified file has been checked out." );
                    }
                else {
                    DoMessage( "Current file has been checked out." );
                    }
                }
            else {
                fExecute( "refresh" );
                if (fMeta) {
                    DoMessage( "Changes to current file discarded.  No longer checked out." );
                    }
                else {
                    DoMessage( "Current file has been checked out." );
                    }
                }

            return( TRUE );
            }
        else {
            return( FALSE );
            }
        }
    else {
        DoMessage( "Unable to change current directory" );
        return( FALSE );
        }

    argData;
    pArg;
    fMeta;
}


EVT evtIdle;
HANDLE Thread;
DWORD ThreadId;

HANDLE EditorStartEvent;
HANDLE EditorStopEvent;
HANDLE EditorSharedMemory;
LPSTR EditorMemoryPointer;
HWND hPrevWindow = (HWND)-1;
PFILE pMailFile;
LPSTR lpCmdLine = NULL;
char CommandLineBuffer[ 256 ];


flagType
CheckForCmdLine( VOID )
{
    LPSTR s;
    PFILE pCurFile;
    int fFileFlags;
    flagType fMailFile;

    if (lpCmdLine) {
        s = lpCmdLine;
        lpCmdLine = NULL;

        while (*s == ' ')
            s++;

        fMailFile = FALSE;
        if (*s) {
            if (*s == '/' || *s == '-')
                if (*++s == 't' || *s == 'T')
                    if (*++s == ' ') {
                        s++;
                        fMailFile = TRUE;
                        }

            if (fChangeFile( TRUE, s ) && fMailFile) {
                pCurFile = FileNameToHandle( "", NULL );
                fFileFlags = 0;
                GetEditorObject( 0xFF | RQ_FILE_FLAGS, pCurFile,
                                 (PVOID)&fFileFlags );
                fFileFlags |= TEMP;
                SetEditorObject( 0xFF | RQ_FILE_FLAGS, pCurFile,
                                 (PVOID)&fFileFlags );
                fExecute( "entermail" );
                pMailFile = pCurFile;
                }
            }
        }

    return( FALSE );        // We never handle a character
}


HWND
GetWindowHandleOfEditor( void );

void
WaitForStartEvent( void );

void SwitchToProgram( HWND hwnd );

void
SwitchToTaskManager( void );

flagType pascal EXTERNAL
StartExt(
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{
    PFILE pCurFile;
    int fFileFlags;
    CHAR szFileName[ 256 ];

    if (!fMeta || pMailFile) {
        pCurFile = FileNameToHandle( "", NULL );
        fFileFlags = 0;
        GetEditorObject( 0xFF | RQ_FILE_FLAGS,  pCurFile, (PVOID)&fFileFlags );
        if (fFileFlags & DIRTY)
            FileWrite( "", pCurFile );

        if (pMailFile) {
            RemoveFile( pMailFile );
            pMailFile = NULL;
            }
        }

    if (hPrevWindow) {
        if (hPrevWindow != (HWND)-1) {
            SetEvent( EditorStopEvent );
            SwitchToProgram( hPrevWindow );
            }

        hPrevWindow = NULL;
        }
    else {
        SwitchToTaskManager();
        }

#if 0
    //
    // Wait for this window to enter foreground again.
    //

    WaitForSingleObject( EditorStartEvent, (DWORD)-1 );

    fExecute( "cancel" );
    fExecute( "setwindow" );
    pCurFile = FileNameToHandle( "", NULL );
    pFileToTop( pCurFile );
    szFileName[ 0 ] = '\0';
    GetEditorObject( 0xFF | RQ_FILE_NAME, pCurFile, (PVOID)szFileName );
    if (szFileName[ 0 ] != '\0') {
        fChangeFile( TRUE, szFileName );
        }

    return( CheckForCmdLine() );

#else
    fExecute( "savetmpfile" );

    return TRUE;

#endif

    argData;
    pArg;
}


HWND
GetWindowHandleOfEditor( void )
{
    HWND hwnd;

    hwnd = GetWindow( GetDesktopWindow(), GW_CHILD );
    while (hwnd) {
        /*
         * Only look at visible, non-owned, Top Level Windows.
         */
        if (IsWindowVisible( hwnd ) && !GetWindow( hwnd, GW_OWNER )) {
            break;
            }

        hwnd = GetWindow( hwnd, GW_HWNDNEXT );
        }


    return hwnd;
}


void
SwitchToProgram(
    HWND hwnd
    )
{
    HWND hwndSelf;
    HWND hwndFoo;

    hwndSelf = GetWindowHandleOfEditor();
    if (hwndSelf && iconizeOnExit) {
        ShowWindow( hwndSelf, SW_MINIMIZE );
        }

    //
    // Temporary hack to make SetForegroundWindow work from a console
    // window - create an invisible window, make it the foreground
    // window and then make the window we want the foreground window.
    // After that destroy the temporary window.
    //

    hwndFoo = CreateWindow( "button", "baz", 0, 0, 0, 0, 0,
                            NULL, NULL, NULL, NULL
                          );

    SetForegroundWindow( hwndFoo );

    SetForegroundWindow( hwnd );
    ShowWindow( hwnd, SW_RESTORE);

    DestroyWindow( hwndFoo );
}

void
SwitchToTaskManager( void )
{
    HWND hwnd;
    wchar_t szTitle[ 256 ];

    /*
     * Search the window list for task manager window.
     */
    hwnd = GetWindow( GetDesktopWindow(), GW_CHILD );
    while (hwnd) {
        /*
         * Only look at non-visible, non-owned, Top Level Windows.
         */
        if (!IsWindowVisible( hwnd ) && !GetWindow( hwnd, GW_OWNER )) {
            //
            // Use internal call to get current Window title that does NOT
            // use SendMessage to query the title from the window procedure
            // but instead returns the most recent title displayed.
            //

            InternalGetWindowText( hwnd,
                                   (LPWSTR)szTitle,
                                   sizeof( szTitle )
                                 );
            if (!_wcsicmp( L"Task List", szTitle )) {
                SwitchToProgram( hwnd );
                break;
                }
            }

        hwnd = GetWindow( hwnd, GW_HWNDNEXT );
        }

    return;
}


void
WaitForStartEvent( void )
{
    LPSTR lpName, lpValue, lpNewCmdLine, lpEditorMem;

    WaitForSingleObject( EditorStartEvent, (DWORD)-1 );

    lpEditorMem = EditorMemoryPointer;

    hPrevWindow = *(HWND *)lpEditorMem;
    lpEditorMem += sizeof( hPrevWindow );

    pMailFile = NULL;

    SetCurrentDirectory( lpEditorMem );
    while( *lpEditorMem++ ) {
        }

    lpNewCmdLine = CommandLineBuffer;
    while( *lpNewCmdLine++ = *lpEditorMem++ ) {
        }

    while (*lpEditorMem) {
        lpName = lpEditorMem;
        while (*lpEditorMem) {
            if (*lpEditorMem++ == '=') {
                lpValue = lpEditorMem;
                lpValue[ -1 ] = '\0';
                while (*lpEditorMem++) {
                    }
                SetEnvironmentVariableA( lpName, lpValue );
                lpValue[ -1 ] = '=';
                break;
                }
            }
        }

    lpCmdLine = CommandLineBuffer;

    return;
}


flagType pascal EXPORT MyIdleEvent( EVTargs far *pArgs )
{
    return( CheckForCmdLine() );

    pArgs;
}


DWORD
EnvThread(
    PVOID Parameter
    );

flagType
StartExtLoaded( void );

flagType
StartExtLoaded ()
{
    EditorStartEvent = CreateEvent( NULL, FALSE, FALSE, "EditorStartEvent" );
    if (EditorStartEvent == NULL) {
        DoMessage( "Create of EditorStartEvent failed" );
        return FALSE;
        }

    EditorStopEvent = CreateEvent( NULL, FALSE, FALSE, "EditorStopEvent" );
    if (EditorStopEvent == NULL) {
        DoMessage( "Create of EditorStopEvent failed" );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    EditorSharedMemory = CreateFileMapping( INVALID_HANDLE_VALUE,
                                            NULL,
                                            PAGE_READWRITE,
                                            0,
                                            8192,
                                            "EditorSharedMemory"
                                          );
    if (EditorSharedMemory == NULL) {
        DoMessage( "Create of EditorStartMemory failed" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    EditorMemoryPointer = MapViewOfFile( EditorSharedMemory,
                                         FILE_MAP_READ | FILE_MAP_WRITE,
                                         0,
                                         0,
                                         8192
                                       );
    if (EditorMemoryPointer == NULL) {
        DoMessage( "MapView of EditorStartMemory failed" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        CloseHandle( EditorSharedMemory );
        return FALSE;
        }

    hPrevWindow = (HWND)-1;

    evtIdle.evtType = EVT_RAWKEY;
    evtIdle.func = MyIdleEvent;
    evtIdle.focus = NULL;
    RegisterEvent( (EVT far *)&evtIdle );

    Thread = CreateThread( NULL,
                           8192,
                           (LPTHREAD_START_ROUTINE)EnvThread,
                           0,
                           0,
                           &ThreadId
                         );

    if (Thread == NULL) {
        DoMessage( "Can't start environment thread" );
        UnmapViewOfFile( EditorMemoryPointer );
        CloseHandle( EditorSharedMemory );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        return FALSE;
        }

    if (!SetThreadPriority( Thread, THREAD_PRIORITY_ABOVE_NORMAL )) {
        DoMessage( "Can't set priority of environment thread" );
        }

    return TRUE;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD
EnvThread(
    PVOID Parameter
    )
{
    while( TRUE ) {
        WaitForStartEvent();
        }

    Parameter;
    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


struct swiDesc swiTable[] = {
    {  "iconizeonexit", toPIF(iconizeOnExit), SWI_BOOLEAN },
    {0, 0, 0},
    {0, 0, 0},
    {0, 0, 0}
};

struct cmdDesc cmdTable[] = {
    {"startext",    StartExt,   0,      NOARG   },
    { "MapCase", Case, 0, NOARG | NULLARG | LINEARG | BOXARG | NUMARG },
    { "BuildMessage", ShowBuildMessage, 0, NOARG | NULLARG | TEXTARG },
    { "SlmOut", SlmOut, 0, NOARG | NULLARG | TEXTARG },
    { NULL, (funcCmd)NULL, 0, 0 }
};

void EXTERNAL WhenLoaded(void)
{
    if (StartExtLoaded()) {
        CountMsgFiles = 0;
        DoMessage("MEPPARTY extensions loaded.");
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\helphck.c ===
#if defined(HELP_HACK)

//
//	This file is used instead of exthdr.c for the hacked version of
//	the help extension that is linked directly to MEP instead of being
//	a DLL.
//
//	This file defines the 2 extension entry points (ModInfo and EntryPoint)
//	but does not define the editor function wrappers.  Since the hacked help
//	extension is linked directly to MEP, having the wrappers would mean
//	re-defining the existing functions, besides, we can call the editor
//	functions directly.
//

#include    <ext.h>
#include    <stddef.h>  

#define offsetof(s,m)   (size_t)&(((s *)0)->m)

extern struct cmdDesc	  HelpcmdTable;
extern struct swiDesc	  HelpswiTable;

EXTTAB ModInfo =
    {	VERSION,
	sizeof (struct CallBack),
	&HelpcmdTable,
	&HelpswiTable,
	{   NULL    }};


void
EntryPoint (
    ) {
        
    WhenLoaded( );
}    



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mhdisp.c ===
/*** mhdisp - help extension display code
*
*   Copyright <C> 1988, Microsoft Corporation
*
* This module contains routines dealing with the display of help information.
*
* Revision History (most recent first):
*
*	12-Mar-1989 ln	Moved some to mhlook
*	15-Feb-1989 ln	Restore to correct current window on close of a
*			split window.
*	26-Jan-1989 ln	Turn help in dialog back on. (M200 #295)
*	13-Jan-1989 ln	PWIN->PWND
*	09-Jan-1989 ln	Popup boxes only in CW
*	01-Dec-1988 ln	Cleanup & dialog help
*	28-Sep-1988 ln	Update for CW
*	22-Sep-1988 ln	MessageBox ==> DoMessageBox
*	02-Sep-1988 ln	Make all data inited. Remove GP fault in debug vers.
*	05-Aug-1988 ln	Rewrote process keys.
*   []	16-May-1988 LN	Split off of mehelp.c
*
*************************************************************************/
#include <stdlib.h>			/* min macro			*/
#include <string.h>			/* string functions		*/

#include "mh.h" 			/* help extension include file	*/

/*** fDisplayNc - Display topic text for the context number passed in
*
* Input:
*  ncCur       = context number
*  frecord,    = TRUE => record for backtrace
*  fStay       = TRUE => keep focus in current window, else move focus to
*		 newly opened help window.
*  fWantPopUp  = TRUE => display as popup window. (Ignored in non-CW)
*
* Exit:
*  returns TRUE on success.
*
*************************************************************************/
flagType pascal near fDisplayNc (
	nc	ncCur,
	flagType frecord,
	flagType fStay,
	flagType fWantPopUp
) {
	ushort		cLines		= 0;		/* # of lines in window 	*/
	EVTargs 	dummy;
	int			fFile;					/* file's flags                 */
	hotspot 	hsCur;					/* hot spot definition		*/
	LINE		iHelpLine	= 0;		/* next help line to read/disp	*/
	PSWI		pHeight;				/* ptr to heigth switch 	*/
	winContents wc; 					/* description of win contents	*/
	BOOL		fDisp		= FALSE;	/* True when Displayed			*/


	UNREFERENCED_PARAMETER( fWantPopUp );

	if (fReadNc(ncCur)) {
		debmsg ("Displaying nc:[");
		debhex (ncCur.cn);
		debmsg ("]");
		/*
		** Set up some data....
		**
		**	- Invalidate the most recent cursor position for highlighting
		**	- Get pointer to editor's height switch
		**	- Set up current colors
		*/
		flIdle.lin = -1;
		pHeight = FindSwitch ("height");
#if defined(PWB)
		rgsa[C_NORM*2 + 1]		= (uchar)hlColor;
		rgsa[C_BOLD*2 + 1]		= (uchar)blColor;
		rgsa[C_ITALICS*2 + 1]	= (uchar)itColor;
		rgsa[C_UNDERLINE*2 + 1] = (uchar)ulColor;
		rgsa[C_WARNING*2 + 1]	= (uchar)wrColor;
#else
		SetEditorObject (RQ_COLOR | C_NORM, 	0, &hlColor);
		SetEditorObject (RQ_COLOR | C_BOLD, 	0, &blColor);
		SetEditorObject (RQ_COLOR | C_ITALICS,	0, &itColor);
		SetEditorObject (RQ_COLOR | C_UNDERLINE,0, &ulColor);
		SetEditorObject (RQ_COLOR | C_WARNING,	0, &wrColor);
		/*
		** If help window was found, close it, so that we can create it with the
		** correct new size.
		*/
		fInOpen = TRUE;
		CloseWin (&dummy);
		fInOpen = FALSE;
#endif
		/*
		** Set the ncLast, the most recently viewed context, to what we are about to
		** bring up. If recording, save it in the backtrace as well.
		*/
		ncLast = ncCur;
		if (frecord) {
			HelpNcRecord(ncLast);
		}
		if (!HelpGetInfo (ncLast, &hInfoCur, sizeof(hInfoCur))) {
			ncInitLast = NCINIT(&hInfoCur);
		} else {
			ncInitLast.mh = (mh)0;
			ncInitLast.cn = 0;
		}
		/*
		** Read through the text, looking for any control lines that we want to
		** respond to. Stop as soon as we discover a non-control line. We currently
		** respond to:
		**
		**	:lnn	where nn is the suggested size of the window.
		*/
		((topichdr *)pTopic)->linChar = 0xff;
        while (HelpGetLine((ushort)++iHelpLine, BUFLEN, buf, pTopic)) {
			if (buf[0] != ':') {
				break;
			}
			switch (buf[1]) {
			case 'l':
				cLines = (USHORT)(atoi (&buf[2]));
			default:
				break;
			}
		}
		((topichdr *)pTopic)->linChar = ((topichdr *)pTopic)->appChar;
		/*
		** Open the window on the help psuedo file. Read the lines one at a time
		** from the help text, update any embedded key assignements, and put the
		** line and color into the pseudo file.
		*/
#if defined(PWB)
		if (!(fInPopUp || fWantPopUp))
#endif
		OpenWin (cLines);
#if defined(PWB)
		else
		DelFile (pHelp);
#endif
		debend (TRUE);
		iHelpLine = 0;
        while (HelpGetLine((ushort)(iHelpLine+1), (ushort)BUFLEN, (uchar far *)buf, pTopic)) {
			if ( buf[0] == ':' ) {

				switch (buf[1]) {

				case 'x':
					return FALSE;

				case 'c':
				case 'y':
				case 'f':
				case 'z':
				case 'm':
				case 'i':
				case 'p':
				case 'e':
				case 'g':
				case 'r':
				case 'n':
					iHelpLine++;
					continue;

				default:
					break;

				}
			}

			ProcessKeys();
			PutLine(iHelpLine,buf,pHelp);
			PlaceColor ((int)iHelpLine++, 0, 0);
			/*
			** This is a speed hack to display help as soon as we get a screen full.
			** "Looks" faster.
			*/
			if (pHeight) {
				if (iHelpLine == *(pHeight->act.ival)) {
					Display ();
					fDisp = TRUE;
				}
			}
		}
		if (!fDisp) {
			Display();
			fDisp = TRUE;
		}

		/*
		** Ensure that the help psuedo file is marked readonly, and clean
		*/
		GetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);
		fFile |= READONLY;
		fFile &= ~DIRTY;
		SetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);
		/*
		** Search for the first hotspot in the text which lies within the current
		** window, and place the cursor there.
		*/
		GetEditorObject (RQ_WIN_CONTENTS, 0, &wc);
		hsCur.line = 1;
		hsCur.col = 1;
		MoveCur((COL)0,(LINE)0);
		if (HelpHlNext(0,pTopic,&hsCur)) {
			if (hsCur.line <= wc.arcWin.ayBottom - wc.arcWin.ayTop) {
				MoveCur((COL)hsCur.col-1,(LINE)hsCur.line-1);
			}
		}
		/*
		** If we're supposed to stay in the previous window, then change currancy
		** to there. Clear the status line, and we're done!
		*/
#if defined(PWB)
		if (fWantPopUp) {
			if (!fInPopUp) {
				fInPopUp = TRUE;
				PopUpBox (pHelp,"Help");
				fInPopUp = FALSE;
			}
		}
		else
#endif
		SetEditorObject (RQ_WIN_CUR | 0xff, fStay ? pWinUser : pWinHelp, 0);
		DoMessage (NULL);
		Display();
		return TRUE;
	}

	return errstat("Error Displaying Help",NULL);

}

/*** fReadNc - Read and decompress help topic
*
*  Reads and decompresses the help topic associated with the given nc.
*  Allocaets memory as appropriate to read it in.
*
* Input:
*  ncCur	- nc of help topic to read in
*
* Output:
*  Returns TRUE on successfull read in
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType pascal near fReadNc (
nc	ncCur
) {
int	cbExp;				/* size of compressed topic	*/
flagType fRet		= FALSE;	/* return value 		*/
uchar far *pTopicC;			/* mem for compressed topic	*/

if (ncCur.mh && ncCur.cn) {
/*
** Determine the memory required for the compressed topic text, and allocate
** that. Read in the compressed topic, and get the uncompressed size.
** Allocate that memory, and decompress. Once decompressed, discard the
** compressed topic.
*/
    if (cbExp = HelpNcCb(ncCur)) {
		debmsg (" sized,");
        if (pTopicC = malloc((long)cbExp)) {
			if (cbExp = HelpLook(ncCur,pTopicC)) {
				debmsg ("read,");
				if (pTopic) {
					free (pTopic);
					pTopic = NULL;
				}
				if (pTopic = malloc((long)cbExp)) {
					if (!HelpDecomp(pTopicC,pTopic,ncCur)) {
						fRet = TRUE;
						debmsg ("decomped");
					}
				}
			}
			free(pTopicC);
			pTopicC = NULL;
	    }
	}
    }
return fRet;

/* end fReadNc */}

/*** PlaceColor - Put color into help screen line
*
* Purpose:
*
* Input:
*   i		= line number to be worked on
*   xStart,xEnd = Column range to be highlighted (one based, inclusive)
*
* Globals:
*   pTopic	= Pointer to topic buffer
*
* Output:
*  Returns nothing
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void pascal near PlaceColor (
	int	line,				/* line number to do		*/
	COL	xStart, 			/* starting highlight column	*/
	COL	xEnd				/* ending highlight column	*/
) {

	buffer	bufL;				/* local buffer 		*/
    ushort  cbExp;              /* size of color info       */
	COL		column		= 1;
	struct	lineAttr *pbT;			/* byte lineattr pointer	*/
	lineattr *pwT;				/* word lineattr pointer	*/

	/*
	** Convert our internal color indecies into editor color indecies.
	*/
    cbExp = HelpGetLineAttr ((ushort)(line+1), (ushort)BUFLEN, (lineattr far *)buf, pTopic) / sizeof(lineattr);
	pbT = (struct lineAttr *)bufL;
	pwT = (lineattr *)buf;
	while (cbExp-- > 0) {
		pbT->attr = atrmap (pwT->attr);
		column += (pbT->len = (uchar)pwT->cb);
		pbT++;
		pwT++;
	}

	PutColor ((LINE)line, (struct lineAttr far *)bufL, pHelp);
	if (xEnd != xStart) {
		SetColor (pHelp, line, xStart-1, xEnd-xStart+1, C_WARNING);
	}
}

/*** atrmap - map attributes in file to editor attributes
*
* Purpose:
*
* Input:
*  fileAtr	= attribute word from the help file
*
* Output:
*  Returns attribute byte for editor.
*
*************************************************************************/
uchar pascal near atrmap (
ushort	fileAtr
) {
if (fileAtr == 0x7)
    return C_WARNING;
else if (fileAtr & A_BOLD)
    return C_BOLD;
else if (fileAtr & A_ITALICS)
    return C_ITALICS;
else if (fileAtr & A_UNDERLINE)
    return C_UNDERLINE;
else
    return C_NORM;
/* end atrmap */}

/*** ProcessKeys - replace embedded function names with current keys.
*
* Replaces ocurrances of <<function name>> in the text with the most recent
* keystroke currently assigned to that function. ("<<" and ">>" here are
* actually single graphic characters 174 and 175).
*
* If there is a space preceding the trailing ">>", the field is space filled
* to that width. Else, the length of the keystroke text is used.
*
* Input:
*  None.
*
* Global:
*  Operates on buf.
*
* Output:
*  Returns nothing. Updates buf.
*
*************************************************************************/
void pascal near ProcessKeys() {
char *pKeyBuf;
char *pKeyCur;
char *pKeyEnd;				/* ptr to end of magic field	*/
char *pKeyFill; 			/* position to fill to		*/
char *pKeyStart;			/* ptr to start of magic field	*/
buffer	keybuf;

pKeyStart = &buf[0];
/*
** look for magic character to signal replacement. If found, begin replacement
** process.
*/
while (pKeyStart = strchr (pKeyStart,174)) {
/*
** Search for the terminating magic character. If found, examine the character
** immediate prior to see if it was a space, and record the "fill to this
** position" place. Copy the remainder of the line to a holding buffer.
*/
    if (pKeyFill = pKeyEnd = strchr(pKeyStart,175)) {
	if (*(pKeyEnd-1) != ' ')
	    pKeyFill = 0;
	strcpy (keybuf, pKeyEnd+1);
	do
	    *pKeyEnd-- = 0;
	while ((*pKeyEnd == ' ') && (pKeyEnd > pKeyStart));
	}
/*
** replace the function name in the line with a list of the keys assigned to
** it. Search the string placed there for the last keystroke in the space
** seperated "and" list (which represents the most recent assignment), and
** then copy that down to the begining of the string.
*/
    NameToKeys(pKeyStart+1,pKeyStart);
    pKeyCur = pKeyStart-1;
    do pKeyBuf = pKeyCur+1;
    while (pKeyCur = strchr (pKeyBuf,' '));
    if (pKeyBuf != pKeyStart)
	strcpy (pKeyStart, pKeyBuf);
    pKeyStart = strchr(pKeyStart,0);
/*
** If we are requested to space fill out the field, and our current position
** is prior to the fill position, then add spaces. Finally, append the
** remainder of the line back on.
*/
    if (pKeyFill) {
	while (pKeyStart <= pKeyFill)
	    *pKeyStart++ = ' ';
	pKeyStart = pKeyFill + 1;
	}
    strcpy (pKeyStart, keybuf);
    }
/* End ProcessKeys */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mhcore.c ===
/*** mhcore - help extension for the Microsoft Editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*  This file contains the core, top-level entrypoints for the help extension.
*
* Revision History (most recent first):
*
*   16-Apr-1989 ln  Increment ref count for psuedo file.
*   12-Mar-1989 ln  Various modifications for multiple context lookup.
*   21-Feb-1989 ln  Ensure that fPopUp initialized.
*   14-Feb-1989 ln  Enable BOXSTR
*   26-Jan-1989 ln  Correct key assignments
*   13-Jan-1989 ln  PWIN->PWND
*   01-Dec-1988 ln  Cleanup & dialog help
*   03-Oct-1988 ln  Change xref lookup to call HelpNc first (for xref in same
*		    file), then SearchHelp (possibly in other files).
*   28-Sep-1988 ln  Changes for CW color and event support
*   14-Sep-1988 ln  Change event arg definition.
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*   31-Aug-1988     Added additional checks for null pointers
*   01-Aug-1988     Add editor exit event, and detection of hot-keys which
*		    aren't.
*   28-Jul-1988     Change to "h." conventions.
*   12-Jul-1988     Reverse SHIFT+F1 and F1.
*   16-May-1988     Split out from mehelp.c
*   18-Feb-1988     Made to work, in protect mode
*   15-Dec-1987     Created, as test harness for the help engine.
*
*************************************************************************/
#include <string.h>                     /* string functions             */
#include <malloc.h>
#ifdef DEBUG
#include <stdlib.h>			/* for ltoa def 		*/
#endif

#include "mh.h" 			/* help extension include file	*/
#include "version.h"                    /* version file                 */


/*
 * use double macro level to force rup to be turned into string representation
 */
#define VER(x,y,z)  VER2(x,y,z)
#if defined(PWB)
#define VER2(x,y,z)  "Microsoft Editor Help Version v"###x##"."###y##"."###z##" - "##__DATE__" "##__TIME__
#else
#define VER2(x,y,z)  "Microsoft Editor Help Version v1.02."###z##" - "##__DATE__" "##__TIME__
#endif

#define EXT_ID	VER(rmj,rmm,rup)


/*************************************************************************
**
** Initialization of Global data in MH.H that needs it.
*/
helpfile files[MAXFILES] = {{{0}}};	/* help file structs		*/
flagType fInOpen	= FALSE;	/* TRUE=> currently opening win */
#if defined(PWB)
flagType fList		= TRUE;		/* TRUE=> search for and list dups*/
#else
flagType fList		= FALSE;	/* TRUE=> search for and list dups*/
#endif
flagType fPopUp 	= FALSE;	/* current item is popup	*/
flagType fCreateWindow	= TRUE; 	/* create window?		*/
int	ifileCur	= 0;		/* Current index into files	*/
nc      ncCur           = {0,0};            /* most recently accessed       */
nc      ncLast          = {0,0};            /* last topic displayed         */
PWND	pWinHelp	= 0;		/* handle to window w/ help in	*/
uchar far *pTopic	= 0;		/* mem for topic		*/
uchar far *pTopicC	= 0;		/* mem for compressed topic	*/
fl	flIdle		= {-1, -1};	/* last position of idle check	*/

int	hlColor 	= 0x07; 	/* normal: white on black	*/
int	blColor 	= 0x0f; 	/* bold: high white on black	*/
int	itColor 	= 0x0a; 	/* italics: high green on black */
int	ulColor 	= 0x0c; 	/* underline: high red on black */
int	wrColor 	= 0x70; 	/* warning: black on white	*/

#ifdef DEBUG
int	delay		= 0;		/* message delay		*/
#endif

int			cArg;				/* number of <args> hit 	*/
flagType	fInPopUp;			/* TRUE=> currently in popup	*/
flagType	fSplit;			/* TRUE=> window was split open */
buffer      fnCur;              /* Current file being editted   */
char    *   fnExtCur;           /* ptr to it's extension        */
buffer      buf;
nc			ncInitLast;			/* ncInit of most recent topic	*/
nc			ncInitLastFile; 		/* ncInit of most recent, our files*/
char	*	pArgText;			/* ptr to any single line text	*/
char	*	pArgWord;			/* ptr to context-sens word	*/
PFILE		pFileCur;			/* file handle of user file	*/
rn			rnArg;				/* range of argument		*/
PFILE		pHelp;				/* help PFILE			*/
PWND		pWinUser;			/* User's most recent window    */
buffer		szLastFound;			/* last context string found	*/

flagType ExtensionLoaded = TRUE;

/*
** assignments
** table of strings of macro definitions & key assignments
*/
char	*assignments[]	= {

#if !defined(PWB)
			    "mhcontext:=arg mhelp.mhelp",
			       "mhback:=meta mhelp.mhelpnext",

			    "mhcontext:F1",
			  "mhelp.mhelp:shift+F1",
		      "mhelp.mhelpnext:ctrl+F1",
			       "mhback:alt+F1",
			"mhelp.sethelp:alt+s",
#else
		       "pwbhelpcontext:=arg pwbhelp.pwbhelp",
			  "pwbhelpback:=meta pwbhelp.pwbhelpnext",
			 "pwbhelpindex:=arg \\\"h.index\\\" pwbhelp.pwbhelp",
		      "pwbhelpcontents:=arg \\\"h.contents\\\" pwbhelp.pwbhelp",
			 "pwbhelpagain:=arg pwbhelp.pwbhelpnext",

		       "pwbhelpcontext:F1",
		      "pwbhelp.pwbhelp:shift+F1",
		  "pwbhelp.pwbhelpnext:ctrl+F1",
			  "pwbhelpback:alt+F1",
		      "pwbhelp.sethelp:shift+ctrl+s",
#endif
			    NULL
                            };

#if defined (OS2)
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "_HelpcLines",
                    "_HelpClose",
                    "_HelpCtl",
                    "_HelpDecomp",
                    "_HelpGetCells",
                    "_HelpGetInfo",
                    "_HelpGetLine",
                    "_HelpGetLineAttr",
                    "_HelpHlNext",
                    "_HelpLook",
                    "_HelpNc",
                    "_HelpNcBack",
                    "_HelpNcCb",
                    "_HelpNcCmp",
                    "_HelpNcNext",
                    "_HelpNcPrev",
                    "_HelpNcRecord",
                    "_HelpNcUniq",
                    "_HelpOpen",
                    "_HelpShrink",
                    "_HelpSzContext",
                    "_HelpXRef",
                    "_LoadFdb",
                    "_LoadPortion",
                    };
#else
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "HelpcLines",
                    "HelpClose",
                    "HelpCtl",
                    "HelpDecomp",
                    "HelpGetCells",
                    "HelpGetInfo",
                    "HelpGetLine",
                    "HelpGetLineAttr",
                    "HelpHlNext",
                    "HelpLook",
                    "HelpNc",
                    "HelpNcBack",
                    "HelpNcCb",
                    "HelpNcCmp",
                    "HelpNcNext",
                    "HelpNcPrev",
                    "HelpNcRecord",
                    "HelpNcUniq",
                    "HelpOpen",
                    "HelpShrink",
                    "HelpSzContext",
                    "HelpXRef",
                    "LoadFdb",
                    "LoadPortion",
                    };
#endif

flagType LoadEngineDll(void);
flagType pascal EXTERNAL mhelp (unsigned int argData, ARG far *pArg, flagType fMeta );
flagType pascal EXTERNAL mhelpnext (unsigned int argData, ARG far *pArg, flagType fMeta );
flagType pascal EXTERNAL sethelp (unsigned int argData, ARG far *pArg, flagType fMeta );




/*** WhenLoaded - Routine called by Z when the extension is loaded
*
*  This routine is called when Z loads the extension. We identify ourselves
*  and assign the default keystroke.
*
* Entry:
*  None
*
* Exit:
*  None
*
* Exceptions:
*  None
*
*************************************************************************/
void EXTERNAL WhenLoaded () {
	char	**pAsg;
	static char *szHelpName = "<mhelp>";
#if !defined(PWB)
	PSWI	fgcolor;
#endif
	int	ref;				// reference count

#if 0
	//
	//	BUGBUG Delete when proved superfluous.
	//
	//	Initialize global variables
	//

	cArg			=	0;
	pArgText		=	NULL;
	pArgWord		=	NULL;
	pFileCur		=	NULL;
	fInOpen			=	FALSE;
	fInPopUp		=	FALSE;
	fSplit			=	FALSE;
	fCreateWindow	=	FALSE;
	fnExtCur		=	NULL;
	ifileCur		=	0;
	pHelp			=	NULL;
	pWinHelp		=	NULL;
	pWinUser		=	NULL;
	pTopic			=	NULL;
	fList			=	FALSE;
#endif

    if (!LoadEngineDll() ) {
        DoMessage( "mhelp: Cannot load help engine" );
        ExtensionLoaded = FALSE;
        return;
    }

	DoMessage (EXT_ID);			/* display signon		*/
	/*
	** Make default key assignments, & create default macros.
	*/
	strcpy (buf, "arg \"");
	for (pAsg = assignments; *pAsg; pAsg++) {
		strcpy (buf+5, *pAsg);
		strcat (buf, "\" assign");
		fExecute (buf);
    }
	/*
	** CW: Init CW specifics & set up the colors that we will use.
	*/
#if defined(PWB)
	mhcwinit ();

	hlColor = rgsa[FGCOLOR*2 +1];
	blColor |= hlColor & 0xf0;
	itColor |= hlColor & 0xf0;
	ulColor |= hlColor & 0xf0;
	wrColor |= (hlColor & 0x70) >> 8;

	fInPopUp = FALSE;
#else
	/*
	* make semi-intellgent guesses on users colors.
	*/
	if (fgcolor = FindSwitch("fgcolor")) {
		hlColor = *fgcolor->act.ival;
		blColor |= hlColor & 0xf0;
		itColor |= hlColor & 0xf0;
		ulColor |= hlColor & 0xf0;
		wrColor |= (hlColor & 0x70) >> 8;
    }
#endif
	/*
	* create the psuedo file we'll be using for on-line help.
	*/
	if (pHelp = FileNameToHandle(szHelpName,NULL)) {
		DelFile (pHelp);
	} else {
		pHelp = AddFile (szHelpName);
		FileRead (szHelpName, pHelp);
    }
	//
	// Increment the file's reference count so it can't be discarded
	//
	GetEditorObject (RQ_FILE_REFCNT | 0xff, pHelp, &ref);
	ref++;
	SetEditorObject (RQ_FILE_REFCNT | 0xff, pHelp, &ref);

	mhevtinit ();

}


/*****************************************************************
 *
 *  LoadEngineDll
 *
 *  Loads the help engine and initialize the table of function
 *  pointers to the engine's entry points (pHelpEntry).
 *
 *  Entry:
 *      none
 *
 *  Exit:
 *      none
 *
 *******************************************************************/

flagType
LoadEngineDll (
    void
    ) {

#if defined (OS2)
    USHORT  rc;
#endif
    CHAR    szFullName[256];
    CHAR    szErrorName[256];
    USHORT  i;



    // Initialize pointers to NULL in case something goes wrong.

    for (i=0; i<LASTENTRYPOINT; i++) {
        pHelpEntry[i] = 0;
    }

    strcpy(szFullName, HELPDLL_BASE);
    strcpy(szErrorName, HELPDLL_NAME);

#if defined (OS2)
    rc = DosLoadModule(szErrorName,
                       256,
                       szFullName,
                       &hModule);

    for (i=0; i<LASTENTRYPOINT; i++) {
        rc = DosQueryProcAddr(hModule,
                              0,
                              szEntryName[i],
                              (PFN *)&(pHelpEntry[i]));
    }
#else


    hModule = LoadLibrary(szFullName);
    if ( !hModule ) {
        return FALSE;
    }
    for (i=0; i<LASTENTRYPOINT; i++) {
        pHelpEntry[i] = (PHF)GetProcAddress(hModule, szEntryName[i]);
    }

    return TRUE;

#endif // OS2

}




/*** mhelp - editor help function
*
*  main entry point for editor help functions.
*
*  NOARG:      - Get help on "Default"; change focus to help window.
*  META NOARG  - prompt for keystroke and get help on that function; change
*		 focus to help window.
*  NULLARG:    - Get help on word at cursor position; change focus to help
*		 window.
*  STREAMARG:  - Get help on text argument; change focus to help window.
*  TEXTARG:    - Get help on typed in word; change focus to help window.
*
* Entry:
*  Standard Z extension
*
* Exit:
*  Returns TRUE on successfull ability to get help on selected topic.
*
* Exceptions:
*  None
*
*************************************************************************/
flagType pascal EXTERNAL mhelp (
	unsigned int argData,			/* keystroke invoked with	*/
	ARG far 	 *pArg,				/* argument data		*/
	flagType	 fMeta				/* indicates preceded by meta	*/
	) {

	buffer	tbuf;				/* buf to put ctxt string into	*/
	char	*pText	= NULL; 	/* pointer to the lookup text	*/
	COL 	Col;				/* Current cursor position		*/
	LINE	Line;
	flagType RetVal;			/* Return Value 				*/

	UNREFERENCED_PARAMETER( argData );

    if ( !ExtensionLoaded ) {
        return FALSE;
    }

	GetTextCursor(&Col, &Line);

	switch (procArgs (pArg)) {

	//
	// null arg: context sensitive help. First, is we're looking at a help
	// topic, check for any cross references that apply to the current location.
	// If none do, then if a word was found when processing args, look that up.
	//
	case NULLARG:
		//
		// context-sensitive
		//
		if ((pFileCur == pHelp) && (pTopic)) {
			//
			//	hot spot definition
			//
			hotspot hsCur;

			hsCur.line = (ushort)(rnArg.flFirst.lin+1);
			hsCur.col  = (ushort)rnArg.flFirst.col+(ushort)1;
			if (pText = HelpXRef(pTopic, &hsCur)) {
				debmsg ("Xref=>");
				debmsg (pText);
				break;
			}
		}

		if (pArgText) {
			if (*pArgText && (pText = pArgWord)) {
				debmsg ("Ctxt=>");
				debmsg (pText);
				break;
			}
		}

	//
	// for stream and textarg types, the argument, if any, is that entered of
	// highlighted by the user.
	//
	case STREAMARG:				/* context sensitive	*/
	case TEXTARG:				/* user entered context */
		if (pArgText) {
			if (*pArgText) {
				pText = pArgText;
			}
		}

    case NOARG: 				/* default context	*/
		//
		// meta: prompt user for keystroke, get the name of the function assigned
		// to whatever he presses, and display help on that.
		//
		if (fMeta) {
			stat("Press Keystroke:");
			pText = ReadCmd()->name;
	    }
		break;
	}

	//
	// If after everything above we still have no text, then use the default
	// context.
	//
	if (pText == NULL)	{
		//
		//	Default context
		//
		pText = "h.default";
	}

	debmsg (" Looking up:");
	debmsg (pText);
	debend (TRUE);

	RetVal = fHelpCmd ( xrefCopy(tbuf,pText)					/* command	  */
						, (flagType)(pArg->argType != NOARG)	/* change focus?*/
						, FALSE 								/* not pop-up	*/
						);



	return RetVal;
}





/*** mhelpnext - editor help traversal function
*
*  Handles next and previous help access.
*
*   mhelpnext	    - next physical
*   arg mhelpnext   - next ocurrance
*   meta mhelpnext  - previous viewed
*
* Entry:
*  Standard Z extension
*
* Exit:
*  Returns TRUE on successfull ability to get help on selected topic.
*
* Exceptions:
*  None
*
*************************************************************************/
flagType pascal EXTERNAL mhelpnext (
	unsigned int argData,			/* keystroke invoked with	*/
	ARG far 	 *pArg,				/* argument data		*/
	flagType	 fMeta				/* indicates preceded by meta	*/
	) {


	UNREFERENCED_PARAMETER( argData );

	//
	// Ensure that help files are open, and then process the arguments and a few
	// other init type things
	//
	procArgs (pArg);

	//
	// if there was no help context to start with, then we can't go either way,
	// so inform the user
	//
	if (!ncLast.mh && !ncLast.cn) {
		return errstat("No previously viewed help", NULL);
	}

	if (fMeta) {
		//
		// meta: attempt to get the most recently viewed help context. If a help
		// window is currently up, then if the one we just found is the same as that
		// in the window, go back once more. If no back trace, then say so.
		//
		ncCur = HelpNcBack();
		if (FindHelpWin(FALSE)) {
			if ((ncCur.mh == ncLast.mh)  &&
				(ncCur.cn == ncLast.cn)) {
				ncCur = HelpNcBack();
			}
		}

		if ((ncCur.mh == 0) && (ncCur.cn == 0)) {
			return errstat ("No more backtrace", NULL);
		}

	} else if (pArg->arg.nullarg.cArg) {
		//
		// not meta, and args. Try to look again
		//
		ncCur = ncSearch ( szLastFound			/* search for last string again */
							, NULL				/* no extension restriction	*/
							, ncInitLastFile	/* file where we found it last	*/
							, TRUE				/* skip all until then		*/
							, FALSE				/* don;t look at all files	*/
							);
	} else {
		//
		//	not meta, no args, Just get the next help context.
		//
		ncCur = HelpNcNext(ncLast);
	}

	if (!ncCur.mh && !ncCur.cn) {
		return FALSE;
	}

	return fDisplayNc ( ncCur		/* nc to display		*/
						, TRUE		/* add to backtrace list	*/
						, TRUE		/* keep focus in current win	*/
						, FALSE);	/* Not as a pop-up, though	*/

}





/*** sethelp - editor help file list manipulation
*
*  Function which allows the user to add to, delete from or examine the
*  list of help files used by the extension
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if file succefully added or deleted, or the list displayed.
*
*************************************************************************/
flagType pascal EXTERNAL sethelp (
	unsigned int argData,			/* keystroke invoked with	*/
	ARG far 	 *pArg,				/* argument data		*/
	flagType	 fMeta				/* indicates preceded by meta	*/
) {

	int 	i = 0;
	int 	j;
	int 	iHelpNew;	/* file table index 	*/
	nc		ncNext;		/* nc for next file 	*/
	char	*pT;		/* temp pointer 		*/
	EVTargs dummy;
	int		fFile;		/* file's flags         */


	UNREFERENCED_PARAMETER( argData );

	procArgs(pArg);

    if ( !pArgText ) {
        return FALSE;
    }


	//
	// The special request to <sethelp> to "?" displays a list of all open
	// help files.
	//
	// We do this by first clearing the help psudeo file and ensuring that the
	// topic text is also gone. Then for each file we output the help engine's
	// physical filename, along with any extensions that the user associated
	// with it. We also walk the list of appended files, and print the original
	// filename and helpfile title for each.
	//
	// We walk the list in the same way that it is searched, so that the
	// displayed list also reflects the default search order.
	//
    if ( pArgText && (*(ushort UNALIGNED *)pArgText == (ushort)'?') ) {

		fInOpen = TRUE;
		CloseWin (&dummy);
		fInOpen = FALSE;

		OpenWin (0);

		//
		// Ensure that the help pseudo file is marked readonly, and clean
		//
		GetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);
		fFile |= READONLY;
		fFile &= ~DIRTY;
		SetEditorObject (RQ_FILE_FLAGS | 0xff, pHelp, &fFile);

		SetEditorObject (RQ_WIN_CUR | 0xff, pWinHelp, 0);

		// asserte(pFileToTop (pHelp));		/* display psuedo file	*/
		MoveCur((COL)0,(LINE)0);			/* and go to upper left */

		DelFile (pHelp);
		if (pTopic) {
			free(pTopic);
			pTopic = NULL;
		}
		iHelpNew = ifileCur;

		do {

			ncNext = files[iHelpNew].ncInit;

			while (ncNext.mh && ncNext.cn && !HelpGetInfo (ncNext, &hInfoCur, sizeof(hInfoCur))) {

				if ((ncNext.mh == files[iHelpNew].ncInit.mh) &&
					(ncNext.cn == files[iHelpNew].ncInit.cn)) {

					memset (buf, ' ', 20);
					buf[20] = 0;
					strncpy (buf, FNAME(&hInfoCur), strlen(FNAME(&hInfoCur)));
					pT = &buf[20];

					for (j=0; j<MAXEXT; j++) {
						if (files[iHelpNew].exts[j][0]) {
							buf[19] = '>';
							strcat (pT," .");
							strcat (pT,files[iHelpNew].exts[j]);
						}
					}

					PutLine((LINE)i++,buf,pHelp);
				}

				memset (buf, ' ', 15);
				strncpy (&buf[2], HFNAME(&hInfoCur), strlen(HFNAME(&hInfoCur)));
				strcpy (&buf[15], ": ");
				appTitle (buf, ncNext);
				PutLine((LINE)i++,buf,pHelp);
				ncNext = NCLINK(&hInfoCur);
			}

			iHelpNew += iHelpNew ? -1 : MAXFILES-1;

		} while (iHelpNew != ifileCur);

#ifdef DEBUG
		PutLine((LINE)i++," ",pHelp);
		strcpy(buf,"ncLast: 0x");
		strcat(buf,_ltoa(ncLast,&buf[128],16));
		PutLine((LINE)i++,buf,pHelp);
		strcpy(buf,"ncCur:  0x");
		strcat(buf,_ltoa(ncCur,&buf[128],16));
		PutLine((LINE)i++,buf,pHelp);
#endif

		DoMessage (NULL);

		return TRUE;
	}


	//
	// Not a special request, just the user adding or removing a file from the
	// list of files to search.
	//
    if (fMeta)
        return closehelp(pArgText);
    {
		flagType Status;
		openhelp(pArgText, NULL, &Status);
		return Status;
	}

}





/*************************************************************************
**
** Z communication tables
**
** switch communication table to Z
*/
struct swiDesc  swiTable[] = {
    {"helpfiles",	prochelpfiles,	SWI_SPECIAL },
	{"helpwindow",	toPIF(fCreateWindow), SWI_BOOLEAN },
#if defined(PWB)
    {"helplist",	toPIF(fList),	SWI_BOOLEAN },
#endif
    {"helpcolor",	toPIF(hlColor), SWI_NUMERIC | RADIX16 },
    {"helpboldcolor",	toPIF(blColor), SWI_NUMERIC | RADIX16 },
    {"helpitalcolor",	toPIF(itColor), SWI_NUMERIC | RADIX16 },
    {"helpundrcolor",	toPIF(ulColor), SWI_NUMERIC | RADIX16 },
    {"helpwarncolor",	toPIF(wrColor), SWI_NUMERIC | RADIX16 },
#ifdef DEBUG
    {"helpdelay",	toPIF(delay),	SWI_NUMERIC | RADIX10 },
#endif
    {0, 0, 0}
    };

/*
** command communication table to Z
*/
struct cmdDesc  cmdTable[] = {
#if defined(PWB)
    {	"pwbhelpnext", mhelpnext,  0,  NOARG | NULLARG },
    {	"pwbhelp",     mhelp,	   0,  NOARG | NULLARG | STREAMARG | TEXTARG | BOXSTR},
#else
	{	"mhelpnext",   (funcCmd)mhelpnext,	0,	NOARG | NULLARG },
	{	"mhelp",	   (funcCmd)mhelp,	   0,  NOARG | NULLARG | STREAMARG | TEXTARG | BOXSTR},
#endif
	{	"sethelp",	   (funcCmd)sethelp,	0,	NULLARG | STREAMARG | TEXTARG | BOXSTR},
    {0, 0, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mh.h ===
/*** mh.h - common include file for the MS Editor help extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*	24-Feb-1989 ln	Increase max open help files to 20
*	13-Jan-1989 ln	PWIN->PWND
*	09-Dec-1988 ln	Changes for Dialog help
*	28-Sep-1988 ln	Correct GrabWord return value
*	13-Sep-1988	Make EVTargs param a pointer
*   []	17-May-1988	Created
*
*************************************************************************/

#ifndef EXTINT


#include "ext.h"			/* z extension include file	*/
#include <stdio.h>
#include <windows.h>

#if defined (DEBUG )
 #define ORGDBG DEBUG
#else
 #undef ORGDBG
#endif

#if defined (_INCLUDE_TOOLS_ )
 #define _FLAGTYPE_DEFINED_ 1
 #include "tools.h"
 #if defined (ORGDBG)
  #define DEBUG ORGDBG
 #else
  #undef DEBUG
 #endif
#else
	struct findType {
		unsigned		type;		/* type of object being searched	*/
		HANDLE			dir_handle;	/* Dir search handle for FindNext	*/
		WIN32_FIND_DATA	fbuf;		/* Aligned structure for Cruiser and NT */
	};
#endif

#endif // EXTINT

#include "help.h"			/* help system include file	*/


#ifndef TRUE
#define TRUE	1
#define FALSE   0
#endif


#define MAXFILES	20		/* max open helpfiles		*/
#define MAXEXT		10		/* max default search extensions*/

#if defined(PWB)
#define CLISTMAX	20		/* max number of duplicates	*/
#endif

#define WIN_MIN 	5		/* min number of lines in window*/

//
//	Editor color indexes
//
#define C_BOLD		USERCOLORMIN
#define C_ITALICS	(1 + C_BOLD)
#define C_UNDERLINE	(1 + C_ITALICS)
#define C_WARNING	(1 + C_UNDERLINE)
#define C_NORM		(1 + C_WARNING)


//
// Info we keep for every helpfile
//
typedef struct {
    nc		ncInit; 		/* initial context		*/
    uchar	exts[MAXEXT][4];	/* extensions			*/
    } helpfile;


//
// Forward Declarations of help extension routines
//
void		pascal near	appTitle (char far *, nc);
uchar		pascal near	atrmap (ushort);
flagType	pascal EXTERNAL CloseWin (EVTargs far *);
flagType	pascal near	closehelp (char *);
flagType	pascal near	errstat (char *, char *);
flagType	pascal near	fContextCommand (char *);
flagType	pascal near	fDisplayNc (nc, flagType, flagType, flagType);
flagType	pascal near	fReadNc (nc);
flagType	pascal near	fHelpCmd (char *, flagType, flagType);
PWND		pascal near	FindHelpWin (flagType);
void		pascal near	GrabWord (void);
flagType	pascal EXTERNAL IdleProc (EVTargs far *);
flagType	pascal EXTERNAL keyevent (EVTargs far *);
flagType	pascal EXTERNAL LooseFocus (EVTargs far *);
void		pascal near	mhcwinit (void);
void		pascal near	mhevtinit (void);
nc			pascal near	ncSearch (uchar far *, uchar far *, nc, flagType, flagType);
void		pascal near	opendefault (void);
void		pascal near	openhelp (char *, struct findType*, void*);
PWND		pascal near	OpenWin (ushort);
void		pascal near	PlaceColor (int, COL, COL);
int			pascal near	procArgs (ARG far *);
void		pascal near	ProcessKeys (void);
void		pascal near	procExt(int, char *);
flagType	pascal EXTERNAL prochelpfiles (char *);
void		pascal near	stat (char *);
flagType	pascal near	wordSepar (int);
char far *  pascal near     xrefCopy (char far *, char far *);


#if defined(PWB)
nc		pascal near	ncChoose (char far *);
#endif

#ifdef DEBUG
void		pascal near	debend (flagType);
void		pascal near	debhex (long);
void		pascal near	debmsg (char far *);
/*
 * assertion support
 *
 * assert  - assertion macro. We define our own, because if we abort we need
 *	     to be able to shut down cleanly (or at least die trying). This
 *	     version also saves us some code over the C library one.
 *
 * asserte - version of assert that always executes the expression, regardless
 *	     of debug state.
 */
void		pascal near	_mhassertexit (char *, char *, int);
#define assert(exp) { \
    if (!(exp))  \
	_mhassertexit (#exp, __FILE__, __LINE__); \
    }
#define asserte(exp)	    assert(exp)
#else
#define debend(x)
#define debhex(x)
#define debmsg(x)
#define assert(exp)
#define asserte(exp)	    ((exp) != 0)
#endif


//
// Global Data
//
// results of procArgs.
//
extern int	cArg;				/* number of <args> hit 	*/
extern rn	rnArg;				/* range of argument		*/
extern char	*pArgText;			/* ptr to any single line text	*/
extern char	*pArgWord;			/* ptr to context-sens word	*/
extern PFILE	pFileCur;		/* file handle of user file	*/
//
// Global State
//
extern flagType fInOpen;		/* TRUE=> currently opening win */
extern flagType fInPopUp;		/* TRUE=> currently in popup	*/
extern flagType fSplit;			/* TRUE=> window was split open */
extern flagType fCreateWindow;	/* TRUE=> create window 	*/

extern buffer	fnCur;			/* Current file being editted	*/
extern char	*fnExtCur;			/* ptr to it's extension        */

extern int	ifileCur;			/* Current index into files	*/
extern nc	ncCur;				/* most recently accessed	*/
extern nc	ncInitLast;			/* ncInit of most recent topic	*/
extern nc	ncInitLastFile; 	/* ncInit of most recent, our files*/
extern nc	ncLast; 			/* most recently displayed topic*/
extern PFILE	pHelp;			/* help PFILE			*/
extern PWND	pWinHelp;			/* handle to window w/ help in	*/
extern PWND	pWinUser;			/* User's most recent window    */
extern buffer	szLastFound;	/* last context string found	*/
//
// Global Misc
//
extern buffer	buf;				/* utility buffer		*/
extern helpfile files[MAXFILES];	/* help file structs		*/
helpinfo		hInfoCur;			/* information on the help file */
extern uchar far *pTopic;			/* mem for topic		*/
extern fl		flIdle; 			/* last position of idle check	*/
//
// Multiple search list
//
extern flagType fList;			/* TRUE=> search for and list dups*/
#if defined(PWB)
extern nc	rgncList[CLISTMAX];		/* list of found nc's           */
extern int	cList;				/* number of entries		*/
#endif


extern flagType ExtensionLoaded;


//
// colors
//
extern int	hlColor;			/* normal: white on black	*/
extern int	blColor;			/* bold: high white on black	*/
extern int	itColor;			/* italics: high green on black */
extern int	ulColor;			/* underline: high red on black */
extern int	wrColor;			/* warning: black on white	*/
#if defined(PWB)
extern uchar far *rgsa;			/* pointer to color table	*/
#endif
//
// Debugging
//
#ifdef DEBUG
extern int	delay;				/* message delay		*/
#endif

//
//  The extension accesses the entry points in the engine thru a table
//  which is initialize by DosGetProcAddr.
//
typedef void    pascal (*void_F)    (void);
typedef int     pascal (*int_F)     (void);
typedef ushort  pascal (*ushort_F)  (void);
typedef f       pascal (*f_F)       (void);
typedef char *  pascal (*pchar_F)   (void);
typedef nc      pascal (*nc_F)      (void);
typedef mh      pascal (*mh_F)      (void);



#if defined( HELP_HACK )

#else

#define HelpcLines		((int pascal (*)(PB))		(pHelpEntry[P_HelpcLines	 ]))
#define HelpClose		((void pascal (*)(nc))		(pHelpEntry[P_HelpClose 	 ]))
#define HelpCtl         ((void pascal (*)(PB, f))   (pHelpEntry[P_HelpCtl        ]))
#define HelpDecomp		((f pascal (*)(PB, PB, nc)) (pHelpEntry[P_HelpDecomp	 ]))
#define HelpGetCells    ((int pascal (*)(int, int, char *, pb, uchar *))    (pHelpEntry[P_HelpGetCells   ]))
#define HelpGetInfo     ((int pascal (*)(nc, helpinfo *, int))    (pHelpEntry[P_HelpGetInfo    ]))
#define HelpGetLine     ((ushort pascal (*)(ushort, ushort, uchar *, PB)) (pHelpEntry[P_HelpGetLine    ]))
#define HelpGetLineAttr ((ushort pascal (*)(ushort, int, lineattr *, PB)) (pHelpEntry[P_HelpGetLineAttr]))
#define HelpHlNext      ((f pascal (*)(int, PB, hotspot *))      (pHelpEntry[P_HelpHlNext     ]))
#define HelpLook        ((ushort pascal (*)(nc, PB)) (pHelpEntry[P_HelpLook       ]))
#define HelpNc          ((nc pascal (*)(char *, nc))     (pHelpEntry[P_HelpNc         ]))
#define HelpNcBack		((nc pascal (*)(void))		(pHelpEntry[P_HelpNcBack	 ]))
#define HelpNcCb		((ushort pascal (*)(nc))	(pHelpEntry[P_HelpNcCb		 ]))
#define HelpNcCmp       ((nc pascal (*)(char *, nc, f (pascal *)(uchar *, uchar *, ushort, f, f) )     (pHelpEntry[P_HelpNcCmp      ]))
#define HelpNcNext		((nc pascal (*)(nc))		(pHelpEntry[P_HelpNcNext	 ]))
#define HelpNcPrev		((nc pascal (*)(nc))		(pHelpEntry[P_HelpNcPrev	 ]))
#define HelpNcRecord	((void pascal (*)(nc))		(pHelpEntry[P_HelpNcRecord	 ]))
#define HelpNcUniq		((nc pascal (*)(nc))		(pHelpEntry[P_HelpNcUniq	 ]))
#define HelpOpen		((nc pascal (*)(char *))	(pHelpEntry[P_HelpOpen		 ]))
#define HelpShrink		((void pascal (*)(void))	(pHelpEntry[P_HelpShrink	 ]))
#define HelpSzContext	((f pascal (*)(uchar *, nc))(pHelpEntry[P_HelpSzContext  ]))
#define HelpXRef        ((char * pascal (*)(PB, hotspot *))  (pHelpEntry[P_HelpXRef       ]))
//#define LoadFdb         ((f_F)      (pHelpEntry[P_LoadFdb        ]))
//#define LoadPortion     ((mh_F)     (pHelpEntry[P_LoadPortion    ]))

#endif // HELP_HACK


//  Some functions return an error code in the nc structure
//  (yuck!)
//
#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))


enum {
    P_HelpcLines,
    P_HelpClose,
    P_HelpCtl,
    P_HelpDecomp,
    P_HelpGetCells,
    P_HelpGetInfo,
    P_HelpGetLine,
    P_HelpGetLineAttr,
    P_HelpHlNext,
    P_HelpLook,
    P_HelpNc,
    P_HelpNcBack,
    P_HelpNcCb,
    P_HelpNcCmp,
    P_HelpNcNext,
    P_HelpNcPrev,
    P_HelpNcRecord,
    P_HelpNcUniq,
    P_HelpOpen,
    P_HelpShrink,
    P_HelpSzContext,
    P_HelpXRef,
    P_LoadFdb,
    P_LoadPortion,
    LASTENTRYPOINT
    } ENTRYPOINTS;

#define NUM_ENTRYPOINTS (LASTENTRYPOINT - P_HelpcLines)

//
//	Name of the help engine
//
#define HELPDLL_NAME	"MSHELP.DLL"
#define HELPDLL_BASE    "mshelp"

typedef nc pascal (*PHF) (void);

HANDLE          hModule;
PHF             pHelpEntry[NUM_ENTRYPOINTS];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mhfile.c ===
/*************************************************************************
**
** mhfile - file manipulation for the help extension for the Microsoft Editor
**
**	Copyright <C> 1988, Microsoft Corporation
**
** Revision History:
**
**	09-Dec-1988 ln	Changes for Dialog help
**	02-Sep-1988 ln	Make all data inited. Add info in debug vers.
**	15-Aug-1988 ln	New HelpOpen return values
**  []	16-May-1988	Created, extracted from mehelp.c
*/
#include <stdlib.h>			/* ultoa			*/
#include <string.h>			/* string functions		*/
#define _INCLUDE_TOOLS_
#include "mh.h"                         /* help extension include file  */

/*************************************************************************
**
** static data
*/
static	uchar	envvar[]= "HELPFILES";	/* help file list env var	*/
static flagType fOpen		= FALSE;/* file open attempted		*/
static uchar szfiles[BUFLEN]	= "";	/* string for open help files	*/




/************************************************************************
**
** closehelp - close an open help file
**
** Purpose:
**
** Entry:
**  pfn 	= pointer to filename.
**
** Exit:
**
** Exceptions:
**
*/
flagType pascal near closehelp(pfn)
char	*pfn;
{
int	iHelpNew;			/* index into file table	*/
nc	ncNew;				/* new file's initial nc        */

/*
** attempt to open the file first, to get the initial context. If we cannot
** open the file, we stop here, since it wasn't open to begin with.
*/
ncNew = HelpOpen(pfn);
if (ISERROR(ncNew)) {
/*
** Scan the current file list for the same handle. If the handle returned
** by HelpOpen above is already in the table, then the file was already open,
** and we zero out that table entry.
*/
    for (iHelpNew=MAXFILES-1; iHelpNew>=0; iHelpNew--) {
        if ((files[iHelpNew].ncInit.mh == ncNew.mh) &&
            (files[iHelpNew].ncInit.cn == ncNew.cn)) {   /* if already open      */
            files[iHelpNew].ncInit.mh = 0;
            files[iHelpNew].ncInit.cn = 0;         /* remove from list     */
        }
    }
/*
** We destory all traces of back-trace and currency, since these contexts may
** reference the now closed helpfile, close it and return.
*/
    HelpClose(ncNew);			/* close the file		*/
    while (HelpNcBack().cn);               /* destroy back-trace           */
    ncCur.mh = ncLast.mh = 0;           /* and clear currancy           */
    ncCur.cn = ncLast.cn = 0;
    }
return TRUE;				/* and we're done               */

/* end closehelp */}

/************************************************************************
**
** openhelp - open a help file & add to list of files
**
** Purpose:
**
** Entry:
**  pfn 	= pointer to filename.
**
** Exit:
**
** Exceptions:
**
*/
void pascal near openhelp(char *pfn, struct findType *dummy1, void *ReturnValue)
{
int	iHelpNew;			/* index into file table	*/
nc	ncNew;				/* new file's initial nc        */
char	*pExt		= 0;		/* pointer to extension string	*/
flagType	RetVal;
buffer pfnbuf;
assert (pfn);


fOpen = TRUE;				/* we HAVE openned something	*/
/*
** preserve any prepended extensions.
*/
if (*pfn == '.') {
    pExt = pfn;
    while (*pfn && (*pfn != ':'))
	pfn++;				/* point to actual filename	*/
    if (*pfn) *pfn++ = 0;		/* terminate ext string 	*/
    }

/*
** attempt to open the file. If we cannot open the file, we stop here.
*/
ncNew = HelpOpen(pfn);
if (ISERROR(ncNew)) {
    strcpy (pfnbuf, pfn);
    strcpy(buf,"Can't open [");
    strcat(buf,pfnbuf);

    switch (ncNew.cn) {
	case HELPERR_FNF:
	    pfn = "]: Not Found";
	    break;
	case HELPERR_READ:
	    pfn = "]: Read Error";
	    break;
	case HELPERR_LIMIT:
	    pfn = "]: Too many help files";
	    break;
	case HELPERR_BADAPPEND:
	    pfn = "]: Bad appended help file";
	    break;
	case HELPERR_NOTHELP:
	    pfn = "]: Not a help file";
	    break;
	case HELPERR_BADVERS:
	    pfn = "]: Bad help file version";
	    break;
	case HELPERR_MEMORY:
	    pfn = "]: Out of Memory";
	    break;
	default:
	    pfn = "]: Unkown error 0x         ";
            _ultoa (ncNew.cn, &pfn[18], 16);
	}

    strcat(buf,pfn);
    errstat(buf,NULL);
    debmsg (buf);
    debend (TRUE);

	if ( ReturnValue ) {
		*((flagType *)ReturnValue) = FALSE;
	}
	return;
    }
/*
** Scan the current file list for the same handle. If the handle returned
** by HelpOpen above is already in the table, then the file was already open,
** and we don't need to add it.
*/
for (iHelpNew=MAXFILES-1; iHelpNew>=0; iHelpNew--)
    if ((files[iHelpNew].ncInit.mh == ncNew.mh) &&
        (files[iHelpNew].ncInit.cn == ncNew.cn)) {      /* if already open      */
	ifileCur = iHelpNew;			/* set currency 	*/
	procExt(iHelpNew,pExt); 		/* process extensions	*/
	if ( ReturnValue ) {
		*((flagType *)ReturnValue) = TRUE;
	}
	return;
	}
/*
** Scan the file list again for an unused slot. Once found, save the initial
** context for that help file, and finally set it up as the first help file
** to be searched.
*/
for (iHelpNew=MAXFILES-1; iHelpNew>=0; iHelpNew--)
    if ((files[iHelpNew].ncInit.mh == 0) &&
        (files[iHelpNew].ncInit.cn == 0)) {          /* if available slot    */
	files[iHelpNew].ncInit = ncNew; 	/* save initial context */
	ifileCur = iHelpNew;			/* and set currency	*/
	procExt(iHelpNew,pExt); 		/* process extensions	*/
	if ( ReturnValue ) {
		*((flagType *)ReturnValue) = TRUE;
	}
	return;
	}
/*
** If we got here, it's because the loop above didn't find any open slots in
** our file table. Complain, close and exit.
*/
errstat ("Too many help files",NULL);
HelpClose(ncNew);
if ( ReturnValue ) {
	*((flagType *)ReturnValue) = FALSE;
}
dummy1;
/* end openhelp */}

/************************************************************************
**
** procExt - process default extensions for file
**
** Purpose:
**  fill in extension table for an openned file
**
** Entry:
**  ifileCur	= filetable index
**  pExt	= pointer to extension string
**
** Exit:
**  filetable entry updated
*/
void pascal near procExt(ifileCur, pExt)
int	ifileCur;
char	*pExt;
{
int	i,j;
char	*pExtDst;			/* place to put it		*/

if (pExt) {				/* if there is one		*/
    pExt++;				/* skip leading period		*/
    for (i=0; i<MAXEXT; i++) {		/* for all possible ext slots	*/
	pExtDst = files[ifileCur].exts[i];  /* point to destination	 */
	j = 0;
	while (*pExt && (*pExt != '.') && (j++ < 3))
	    *pExtDst++ = *pExt++;
	if (*pExt == '.')
	    pExt++;			/* skip period separator	*/
	*pExtDst = 0;			/* always terminate		*/
	}
    }

/* end procExt */}

/*** opendefault - if no files open yet, open the default set
*
*  We delay this operation, in the case that the user will have a helpfiles:
*  switch which will locate the helpfiles explicitly. In those cases this
*  routine does nothing, and we don;t waste time up front openning files
*  only to close them later.
*
*  On the other hand, if he has not set a helpfiles switch by his first
*  request for help, we want to try either the environment variable, if it
*  exists, or when all else fails, default to mep.hlp.
*
* Input:
*  none
*
* Output:
*  Returns nothing. Helpfiles open, we hope.
*
*************************************************************************/
void pascal near opendefault ( void ) {

char *tmp;

if (!fOpen) {
    if (getenv (envvar)) {
//    prochelpfiles (getenv (envvar));   /* Process user-spec'd files    */
    prochelpfiles (tmp=getenvOem (envvar));   /* Process user-spec'd files    */
    free( tmp );
    }
    else
        openhelp ("mep.hlp", NULL, NULL);                 /* else use default             */
    }
/* end opendefault */}

/************************************************************************
**
** prochelpfiles - process helpfiles: switch
**
** Purpose:
**  called by the editor each time the helpfiles switch is changed.
**
** Entry:
**  pszfiles	= pointer to new switch value
**
** Exit:
**
** Exceptions:
**
*/
flagType pascal EXTERNAL prochelpfiles (pszfiles)
char	*pszfiles;
{
char	cTerm;				/* terminating character	*/
int	iHelp;
char    *pEnd;                          /* pointer to end of current fn */

if ( !ExtensionLoaded ) {
    return FALSE;
}
strncpy(szfiles,pszfiles,BUFLEN);	/* save specified string	*/
/*
** begin by closing all open help files and loosing curency
*/
for (iHelp=MAXFILES-1; iHelp>=0; iHelp--)
    if ((files[iHelp].ncInit.mh) &&
        (files[iHelp].ncInit.cn)) {          /* if open file                 */
	HelpClose(files[iHelp].ncInit); /* close it			*/
        files[iHelp].ncInit.mh = 0;
        files[iHelp].ncInit.cn = 0;
	}
while (HelpNcBack().cn);                   /* destroy back-trace           */
ncCur.mh = ncLast.mh = 0;               /* and clear currancy           */
ncCur.cn = ncLast.cn = 0;

while (*pszfiles) {			/* while files to proc		*/
    if (*pszfiles == ' ')		/* strip leading spaces 	*/
	pszfiles++;
    else {
	pEnd = pszfiles;
	while (*pEnd && (*pEnd != ' ') && (*pEnd != ';')) pEnd++; /* move to end of fn	   */
	cTerm = *pEnd;			/* save terminator		*/
        *pEnd = 0;


		forfile(pszfiles, A_ALL, openhelp, NULL);

#if rjsa
        //  Since pszfiles may contain wild characters, we use
        //  ffirst/fnext to open all of them
        //
        rc = ffirst(pszfiles, A_ALL, &buffer);
        while (!rc) {
            buffer.fbuf.achName[buffer.fbuf.cchName] = '\0';
            openhelp(buffer.fbuf.achName, NULL, NULL);
            rc = fnext(&buffer);
        }
#endif
	pszfiles = pEnd;		/* point to end 		*/
	if (cTerm) pszfiles++;		/* if more, move to next	*/
	}
    }
ifileCur = MAXFILES-1;

return TRUE;
/* end prochelpfiles */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mhevt.c ===
/*** mhevt - help extension event handling code
*
*   Copyright <C> 1988, Microsoft Corporation
*
*  This file contains the code called by the edit in response to events
*
* Revision History (most recent first):
*
*   30-Mar-1989 ln  Fudge with keyevent to react corectly to what we want.
*   23-Mar-1989 ln  Created. Extracted from mhcore & others
*
*************************************************************************/
#include <string.h>                     /* string functions             */
#include <malloc.h>
#include "mh.h"                         /* help extension include file  */

/*************************************************************************
*
* static data
*/
static	EVT EVThlp	= {		/* keyboard event definition	*/
			   EVT_KEY,
			   keyevent,
			   0,
			   0,
			   0		/* ALL keys			*/
			  };
static	EVT EVTcan	= {		/* cancel event definition	*/
			   EVT_CANCEL,
			   CloseWin,
			   0,
			   0,
			   0
			  };
static	EVT EVTxit	= {		/* exit event definition	*/
			   EVT_EXIT,
			   CloseWin,
			   0,
			   0,
			   0
			  };
static	EVT EVTidl	= {		/* idle event definition	*/
			   EVT_IDLE,
			   IdleProc,
			   0,
			   0,
			   0
			  };
static	EVT EVTfcs	= {		/* focus loss event definition	*/
			   EVT_LOSEFOCUS,
			   LooseFocus,
			   0,
			   0,
			   0
			  };

/*** mhevtinit - init editor event handling
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near mhevtinit (void) {

EVTidl.focus = EVThlp.focus = pHelp;
RegisterEvent(&EVThlp); 	    /* register help key event	    */
RegisterEvent(&EVTcan); 	    /* register help cancel event   */
RegisterEvent(&EVTidl); 	    /* register help idle event     */
RegisterEvent(&EVTxit); 	    /* register help exit event     */
RegisterEvent(&EVTfcs); 	    /* register help focus event    */

/* end mhevtinit */}

/*** keyevent - called by editor whenever a key is pressed in a help window
*
*  When called we know that pHelp is being displayed, and was current.
*  Process the key pressed by the user. Keys handled:
*
*   TAB 	- move forward to next hot spot
*   BACK-TAB	- move backward to next hot spot
*   lc Alpha	- move forward to next hot spot whose text begins with alpha
*   uc Alpha	- move backward to next hot spot whose text begins with alpha
*   Enter	- execute cross reference, if we're on one
*   Space	- execute cross reference, if we're on one
*
* Input:
*  parg		= pointer to event arguments
*
* Output:
*  If the key pressed is one we recognize return TRUE, else we return FALSE
*  and let the editor process the key.
*
*************************************************************************/
flagType pascal EXTERNAL keyevent (
	EVTargs far *parg
	) {

	uchar	c;						/* character hit		*/
	int 	fDir;					/* direction flag		*/
	f		fWrapped	= FALSE;	/* wrapped arounf flag	*/
	hotspot hsCur;					/* hot spot definition	*/
	char	*pText		= NULL;
	COL 	x;
	LINE	y;

	c = parg->arg.key.KeyData.Ascii;

	//
	// if there is no topic, no sense doing anything
	//
	if (pTopic == 0) {
		if ( ((c <= 'z') && (c >= 'a')) ||
			 ((c <= 'Z') && (c >= 'A')) ||
			 (c == 0x09) ) {
			return TRUE;
		}
		return FALSE;
	}

	//
	// start by getting this info, in case it is used later.
	//
	GetTextCursor(&x, &y);
	hsCur.line = (ushort)++y;
	hsCur.col = (ushort)++x;

	//
	// If he hit return or space, look for a cross reference at the current loc.
	// If there is one, process it.
	//
	if ((c == 0x0d) || (c == ' ')) {
		if (pText = HelpXRef (pTopic, &hsCur)) {
#ifdef DEBUG
			debmsg ("Xref: ");
			if (*pText) {
				debmsg (pText);
			} else {
				debmsg ("@Local 0x");
				debhex ((long)*(ushort far *)(pText+1));
			}
			debend (TRUE);
#endif
			if (!fHelpCmd (  pText		/* command/help to look up	*/
							, FALSE		/* change focus to help window	*/
							, FALSE		/* not pop-up			*/
							)) {
				errstat ("Cannot Process Cross Reference", NULL);
			}
		}
		Display();		// Show CUrsor Position
		return TRUE;
	}

    if ( parg->arg.key.KeyData.Flags & (FLAG_CTRL  | FLAG_ALT) ) {
        return FALSE;
    }

    //
	// Maneuvering keys:
	//	TAB:		Move to next hot spot
	//	SHIFT+TAB	Move to previous hot spot
	//	lcase alpha Move to next hot spot beginning with alpha
	//	ucase alpha Move to previous hot spot beginning with alpha
	//
	if ((c <= 'z') && (c >= 'a')) {
		fDir = (int)c-0x20;
	} else if ((c <= 'Z') && (c >= 'A')) {
		fDir = -(int)c;
	} else if (c == 0x09) {
		if (parg->arg.key.KeyData.Flags & FLAG_SHIFT) {
			fDir = -1;
		} else {
			fDir = 0;
		}
	} else {
		return FALSE;
	}

	//
	// loop looking for the next cross reference that either follows or precedes
	// the current cursor position. Ensure that we do NOT end up on the same xref
	// we are currently on. If we've reached the end/beginning of the topic, wrap
	// around to the begining/end. Ensure we do this only ONCE, in case there are
	// NO cross references at all.
	//
	while (TRUE) {

		if (HelpHlNext(fDir,pTopic,&hsCur)) {

			MoveCur((COL)hsCur.col-1,(LINE)hsCur.line-1);
			IdleProc(parg);
			Display();

			if (fWrapped || ((LINE)hsCur.line != y)) {
				break;
			}

			if ((fDir < 0) && ((COL)hsCur.ecol >= x)) {
				hsCur.col--;
			} else if ((fDir >= 0) && ((COL)hsCur.col <= x)) {
				hsCur.col = (ushort)(hsCur.ecol+1);
			} else {
				break;
			}
		} else {
			if (fWrapped++) {
				break;
			}
			hsCur.col = 1;
			hsCur.line = (fDir < 0) ? (ushort)FileLength(pHelp) : (ushort)1;
		}
	}

	return TRUE;
}

/*** IdleProc - Idle event processor
*
* Purpose:
*
* Input:
*  Editor event args passed, but ignored.
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType pascal EXTERNAL IdleProc (
	EVTargs far *arg
	) {

	hotspot hsCur;				/* hot spot definition		*/
	fl		flCur;				/* current cursor location	*/

	UNREFERENCED_PARAMETER( arg );

	/*
	** if there is no topic, no sense doing anything
	*/
	if (pTopic) {
		/*
		** If the cursor position has changed since the last idle call...
		*/
		GetTextCursor(&flCur.col, &flCur.lin);
		if ((flCur.col != flIdle.col) || (flCur.lin != flIdle.lin)) {
			/*
			** restore the color to the previous line, and check for a cross reference at
			** the current position. If there is one, change it's colors.
			*/
			if (flIdle.lin != -1)
				PlaceColor (flIdle.lin, 0, 0);

			hsCur.line = (ushort)(flCur.lin+1);
			hsCur.col  = (ushort)(flCur.col+1);

			if (HelpXRef (pTopic, &hsCur))
				SetColor (pHelp, flCur.lin, hsCur.col-1, hsCur.ecol-hsCur.col+1, C_WARNING);

			flIdle = flCur;
		}
	}
	Display();
	return FALSE;
}

/*** LooseFocus - called when help file looses focus
*
*  This is called each time a file looses focus. If the help file is no
*  longer displayed, we clear it from memory and deallocate any associated
*  help text.
*
* Input:
*  e		- ignored
*
* Output:
*  Returns TRUE.
*
*************************************************************************/
flagType pascal EXTERNAL LooseFocus (
EVTargs far *e
) {

UNREFERENCED_PARAMETER( e );

if (!fInPopUp && pTopic && !fInOpen) {
/*
** Look for a window that has the help file in it. If found, we're done.
*/
    if (FindHelpWin (FALSE))
	return FALSE;
/*
** There is no help window currently displayed, deallocate any topic text
** we have lying around.
*/
    if (pTopic) {
        free (pTopic);
		pTopic = NULL;
	}
/*
** If there is a help pFile, discard it's contents
*/
    if (pHelp)
	DelFile (pHelp);
    }
return TRUE;
/* end LooseFocus */}

/*** CloseWin - Close a window on the help file
*
*  Closes the help window, if it is up. Maintains window currancy after the
*  close. Relies on an eventual call to LooseFocus (above) to deallocate the
*  topic text, if it is there, and discard the help pFile.
*
*  Can be called by editor event processor, in response to CANCEL or EXIT
*  event.
*
* Input:
*  dummy	- EVTargs ignored.
*
* Output:
*  Returns TRUE.
*
*************************************************************************/
flagType pascal EXTERNAL CloseWin (
	EVTargs far *dummy
	) {


#if defined(PWB)
	/*
	** Look for the window that has the help file in it. If found, close it.
	*/
	if (pWinHelp) {
		if (!CloseWnd (pWinHelp)) {
			return TRUE;
		}

#else

	PWND	pWinCur;			/* window on entry		*/

	UNREFERENCED_PARAMETER( dummy );
	/*
	** Look for the window that has the help file in it. If found, close it.
	*/
	if (pWinHelp) {
		SetEditorObject (RQ_WIN_CUR | 0xff, pWinHelp, 0);
		if (fSplit) {
			fExecute ("meta window");
		} else {
			fExecute ("setfile");
		}
		GetEditorObject (RQ_WIN_HANDLE, 0, &pWinCur);

#endif

		pWinHelp = 0;
		if (pWinUser) {
			SetEditorObject (RQ_WIN_CUR | 0xff, pWinUser, 0);
		}
    }
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mhwin.c ===
/*** mhwin - Help Windowing Code
*
*   Copyright <C> 1988, Microsoft Corporation
*
* This module contains routines dealing with opening and closing the help
* display window.
*
* Revision History (most recent first):
*
*   []	12-Mar-1989 LN	Split off of mhdisp.c
*
*************************************************************************/
#include <string.h>			/* string functions		*/

#include "mh.h" 			/* help extension include file	*/

/*** OpenWin - Open a window on the help file, empty & make current.
*
* Entry:
*  cLines	= Desired size of window.
*
* Exit:
*  Returns help file PWND
*
*************************************************************************/
PWND pascal near OpenWin (
ushort	cLines
) {
PWND	pWinCur;			/* win handle for current win	*/
winContents wc; 			/* description of win contents	*/
int	winSize;			/* size of current window	*/

fInOpen = TRUE;
/*
** Get a handle to the current window, and a handle to the help window if up.
** If they are NOT the same, then save the "current" handle as the one the
** user had active prior to asking for help.
*/
GetEditorObject (RQ_WIN_HANDLE, 0, &pWinCur);
pWinHelp = FindHelpWin (FALSE);
if (pWinHelp != pWinCur)
    pWinUser = pWinCur;
/*
** If no help window was found. Attempt to split the current window, if
** it's big enough, and that's requested
*/
if (!pWinHelp) {
    GetEditorObject (RQ_WIN_CONTENTS | 0xff, pWinUser, &wc);
#if defined(PWB)
/*
** In PWB we just ask the editor to split the current window in half.
*/
    fSplit = FALSE;
	if ((wc.arcWin.ayBottom - wc.arcWin.ayTop >= 12) && fCreateWindow) {
	fSplit = SplitWnd (pWinUser, FALSE, (wc.arcWin.ayBottom - wc.arcWin.ayTop)/2);
	GetEditorObject (RQ_WIN_HANDLE, 0, &pWinHelp);
	}
    }
/*
** We have a window, of some sort, attempt to resize the window to the
** requested size.
*/
if (cLines) {
    cLines += 2;
    GetEditorObject (RQ_WIN_CONTENTS | 0xff, pWinHelp, &wc);
    wc.arcWin.ayBottom = wc.arcWin.ayTop + cLines;
    Resize (pWinHelp, wc.arcWin);
    }
#else
/*
** Non PWB: Attempt to split the resulting current window to the desired size.
** by moving the cursor there, and executing arg window. Note that if the
** window had already existed, we won't even try to resize.
*/
    winSize = wc.arcWin.ayBottom - wc.arcWin.ayTop;
    if (   (cLines < 6)
        || (cLines > (ushort)(winSize - 6)))
        cLines = (ushort)(winSize / 2);
	if ((cLines > 6) && fCreateWindow) {
        fSplit = SplitWnd(pWinUser, FALSE, (LINE)cLines);
        //fSplit = SplitWnd(pWinUser, FALSE, wc.flPos.lin + (long)cLines);
        // rjsa MoveCur (wc.flPos.col, wc.flPos.lin + (long)cLines);
        // rjsa fSplit = fExecute ("arg window");
	GetEditorObject (RQ_WIN_HANDLE, 0, &pWinHelp);
	}
    else
	pWinHelp = pWinUser;
    }
#endif
/*
** Set the window to be the current window, and move the help file to the
** top of that window's file list.
*/
SetEditorObject (RQ_WIN_CUR | 0xff, pWinHelp, 0);
DelFile (pHelp);
asserte (pFileToTop (pHelp));
fInOpen = FALSE;
return pWinHelp;

/* end OpenWin */}

/*** FindHelpWin - Locate window containing help & make current
*
*  For all windows in the system, look for a window that has the help file
*  in it. If found, set focus there.
*
* Entry:
*  fSetCur	= TRUE=> set help window current when found
*
* Globals:
*  cWinSystem	= returned number of windows in system
*
* Returns:
*  pWin of help file
*
*************************************************************************/
PWND pascal near FindHelpWin (
flagType fSetCur
) {
int	cWinSystem;			/* number of windows in system	*/
winContents wc; 			/* description of win contents	*/

pWinHelp = 0;
for (cWinSystem=1; cWinSystem<=8; cWinSystem++) {
    if (GetEditorObject (RQ_WIN_CONTENTS | cWinSystem, 0, &wc)) {
	if (wc.pFile == pHelp) {
	    if (fSetCur) {
		SetEditorObject (RQ_WIN_CUR | cWinSystem, 0, 0);
		GetEditorObject (RQ_WIN_HANDLE, 0, &pWinHelp);
		}
	    else
		GetEditorObject (RQ_WIN_HANDLE | cWinSystem, 0, &pWinHelp);
	    break;
	    }
	}
    else
	break;
    }
return pWinHelp;
/* end FindHelpWin */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\pmatch\pmatch.c ===
#define EXT_ID	"pmatch ver 1.02 "##__DATE__##" "##__TIME__
#include "ext.h"

/*
 *  Modifications
 *  12-Sep-1988 mz  Made WhenLoaded match declaration
 *
 */

#define fLeftSide(ch) ((ch) == '[' || (ch) == '{' || (ch) == '(' || (ch) == '<' )
#define EOF (int)0xFFFFFFFF
#define BOF (int)0xFFFFFFFE
#define EOL (int)0xFFFFFFFD

#ifndef TRUE
#define FALSE	0
#define TRUE	(!FALSE)
#endif

#ifndef NULL
#define NULL	((void *) 0)
#endif

#define SQ  '\''
#define DQ  '\"'
#define ANYCHAR '\0'
#define BACKSLASH '\\'

/****************************************************************************
 *									    *
 *  Handle apostrophes ( which look like single quotes, but don't come in   *
 *  pairs ) by defining a maximum number of chars that can come between     *
 *  single quotes. 4 will handle '\000' and '\x00'			    *
 *									    *
 ****************************************************************************/

#define SQTHRESH 4

flagType pascal EXTERNAL PMatch (unsigned, ARG far *, flagType);
char MatChar (char);
void openZFile (void);
void lopen (PFILE, int, int) ;
int rgetc (void);
int ngetc (void);
int lgetc (void);
void pos (COL far *, LINE far *);
flagType ParenMatch (int, flagType);


/****************************************************************************
 *									    *
 *  PMatch(argData, pArg, fMeta)					    *
 *									    *
 *	argData - ignored						    *
 *	pArg	- ignored						    *
 *	fMeta	- TRUE means search for first matchable character	    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if matching character was found.				    *
 *	FALSE if not.							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes location of cursor.					    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	     <pmatch>: If the cursor is on a "match" character, find the    *
 *		       match and move the cursor there.  If not, do	    *
 *		       nothing. 					    *
 *									    *
 *	<arg><pmatch>: Same as <pmatch>, but search forward for a "match"   *
 *		       character if we're not on one.                       *
 *									    *
 *	Always ignore characters between quotes.			    *
 *									    *
 *	Match characters currently supported are:			    *
 *									    *
 *		'{'  and  '}'						    *
 *		'['  and  ']'						    *
 *		'('  and  ')'						    *
 *		'<'  and  '>'						    *
 *									    *
 *  NOTES:								    *
 *									    *
 *	This is defined as a CURSORFUNC, and therefore can be used to	    *
 *	select text as part of an argument.  For example, to grab the body  *
 *	of a function, go to the opening brace of the body and do	    *
 *	<arg><pmatch><pick>.						    *
 *									    *
 ****************************************************************************/

flagType pascal EXTERNAL PMatch (
unsigned int argData,
ARG far * pArg,
flagType fMeta
)
{
    COL x;
    LINE y;
    char ch;


	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)pArg;

	/* Set up file functions */
	openZFile ();

	/* If current character has no match ... */
	if (!MatChar (ch = (char)ngetc()))
	{
	    if (fMeta)
	    {	/* Move forward looking for first matchable character */

		if (!ParenMatch (ANYCHAR, TRUE))  return FALSE;

		pos ((COL far *)&x, (LINE far *)&y);
		MoveCur (x, y);
		return TRUE;
	    }
	    else  return FALSE;
	}

	if (ParenMatch ((int)ch, (flagType)fLeftSide(ch)))
	{				       /*  We got one		    */
	    pos ((COL far *)&x, (LINE far *)&y);

	    MoveCur (x, y);

	    return TRUE;
	}

	return FALSE;				/* No match found	     */
}


/****************************************************************************
 *									    *
 *  ParenMatch (chOrig, fForward)					    *
 *									    *
 *	chOrig	 - character we are trying to match.			    *
 *	fForward - TRUE means search forward, FALSE search backwards	    *
 *	Returns TRUE if match found, false otherwise			    *
 *									    *
 *  RETURNS:								    *	    *
 *									    *
 *	TRUE if matching character found, FALSE if not. 		    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes internal cursor location				    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Search for the next character that "pairs" with 'ch'.  Account for  *	*
 *	nesting.  Ignore all characters between double quotes and single    *
 *	quotes.  Recognize escaped quotes.  Account for apostrophes.	    *
 *									    *
 ****************************************************************************/

flagType ParenMatch (
    int chOrig,
    flagType fForward
    )
{
    int lvl = 0, state	 = 0, sqcnt = 0;
    int (*nextch)(void)  = (int (*)(void))(fForward ? rgetc : lgetc);
    int (*_ungetch)(void) = (int (*)(void))(fForward ? lgetc : rgetc);
    int ch, chMatch;


	if (chOrig) chMatch = (int)MatChar ((char)chOrig);

    while ((ch = (*nextch)()) >= 0)
	    switch (state)
	    {
		case 0: /* Regular text */
		    if (ch == SQ)
			if (fForward)	state = 1;
			else		state = 5;
		    else if (ch == DQ)
			if (fForward)	state = 3;
			else		state = 7;
		    else
			if (chOrig != ANYCHAR)
			    if (ch == chOrig) lvl++;	   /* Nest in one    */
			    else
			    {
				if (ch == chMatch)	   /* Nest out or ...*/
				    if (!lvl--) goto found;/* Found it!      */
			    }
			else
			    if ((flagType)MatChar ((char)ch)) goto found;  /* Found one!     */

		    break;

		case 1: /* Single quote moving forwards */
		    sqcnt++;
		    if (ch == BACKSLASH)    state = 2;
		    else if (ch == SQ ||	/* We matched the ', or ...  */
			     sqcnt > SQTHRESH ) /* ... we gave up trying     */
					    {
					    sqcnt = 0;
					    state = 0;
					    }
		    break;

		case 2: /* Escaped character inside single quotes */
		    sqcnt++;
		    state = 1;
		    break; 

		case 3: /* Double quote moving forwards */
		    if (ch == BACKSLASH)    state = 4;
		    else if (ch == DQ)	    state = 0;
		    break;

		case 4: /* Escaped character inside double quotes */
		    state = 3;
		    break;

		case 5: /* Single quote moving backwards */
		    sqcnt++;
		    if (ch == SQ)	state = 6;
		    else if (sqcnt > SQTHRESH)
					{
					sqcnt = 0;
					state = 0;
					}
		    break;		

		case 6: /* Check for escaped single quote moving backwards  */
		    sqcnt++;
		    if (ch == BACKSLASH)    state = 5;
		    else
		    {
			sqcnt = 0;
			(*_ungetch)();
			state = 0;
		    }
		    break;

		case 7: /* Double quote moving backwards */
		    if (ch == DQ)   state = 8;
		    break;		

		case 8: /* Check for escaped double quote moving backwards  */
		    if (ch == BACKSLASH)    state = 7;
		    else
		    {
			(*_ungetch)();
			state = 0;
		    }
		    break;
	    }

	return FALSE;

	found:	return TRUE;
}


/****************************************************************************
 *									    *
 *  MatChar(ch) 							    *
 *									    *
 *	ch - Character to match 					    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Character that matches the argument				    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	None.								    *
 *									    *
 *  DESCRIPTION 							    *
 *									    *
 *	Given one character out of one of the pairs {}, [], (), <>, return  *
 *	the other one.							    *
 *									    *
 ****************************************************************************/

char MatChar (
    char ch
    )
{
    switch (ch)
    {
	case '{': return '}';
	case '}': return '{';
	case '[': return ']';
	case ']': return '[';
	case '(': return ')';
	case ')': return '(';
	case '<': return '>';
	case '>': return '<';
	default : return '\0';
    }
}


/****************************************************************************
 *									    *
 *  Extension specific file reading state.				    *
 *									    *
 *  The static globals record the current state of file reading.  The	    *
 *  pmatch extension reads through the file either forwards or backwards.   *
 *  The state is kept as the current column and row, the contents of the    *
 *  current line, the length of the current line and the file, and some     *
 *  flags.								    *
 *									    *
 ****************************************************************************/

static char	LineBuf[BUFLEN];    /* Text of current line in file	    */
static COL	col	;   /* Current column in file (0-based) 	    */
static LINE	line	;   /* Current line in file   (0-based) 	    */
static int	numCols ;   /* Columns of text on curent line		    */
static LINE	numLines;   /* Number of lines in the file		    */
static PFILE	pFile	;   /* File to be reading from			    */
static flagType fEof	;   /* TRUE ==> end-of-file reached last time	    */
static flagType fBof	;   /* TRUE ==> begin-of-file reached last time     */
char   CurFile[] = ""	;   /* Current file to Z			    */


/****************************************************************************
 *									    *
 *  openZFile() 							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals pFile, fEof, fBof, col, line, numCols, numLines     *
 *	and LineBuf							    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Opens the current file.  This must be called before trying to read  *
 *	the file.  This is not a true "open" because it need not be closed  *
 *									    *
 ****************************************************************************/

void openZFile ()
{
    COL x;
    LINE y;

	GetTextCursor ((COL far *)&x, (LINE far *)&y);

				/* Get Z handle for current file	    */
	pFile	 = FileNameToHandle (CurFile, CurFile);
	fEof	 = FALSE;	/* We haven't read the end of file          */
	fBof	 = FALSE;	/* We haven't read the beginning of file    */
	col	 = x;		/* We start where Z is now in the file	    */
	line	 = y;		/* We start where Z is now in the file	    */
				/* We pre-read the current line 	    */
	numCols  = GetLine (line, (char far *)LineBuf, pFile);
				/* We find the length of file (in lines)    */
	numLines = FileLength (pFile);
}


/****************************************************************************
 *									    *
 *  rgetc ()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Next character in file, not including line terminators.  EOF if     *
 *	there are no more.						    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals col, numCols, numLines, LineBuf, fEof, fBof and     *
 *	line.								    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Advances current file position to the right, then returns the	    *
 *	character found there.	Reads through blank lines if necessary	    *
 *									    *
 ****************************************************************************/

int
rgetc ()
{

    if (fEof)  return (int)EOF; /* We already hit EOF last time 	    */

    if (++col >= numCols)   /* If next character is on the next line ...    */
    {
			    /* ... get next non-blank line (or EOF)	    */
	while ( ++line < numLines  &&
		!(numCols = GetLine (line, (char far *)LineBuf, pFile)));

	if (line >= numLines)
	{		    /* Oh, no more lines			    */
	    fEof = TRUE;
	    return (int)EOF;
	}

	col = 0;	    /* We got a line, so start in column 0	    */
    }

    fBof = FALSE;	    /* We got something, so we can't be at BOF      */
    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  ngetc()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Character at current position.	EOF or BOF if we are at end or top  *
 *	of file.							    *
 *									    *
 ****************************************************************************/

int
ngetc()
{
    if (fEof) return (int)EOF;
    if (fBof) return (int)BOF;

    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  lgetc ()								    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Previous character in file, not including line terminators.  EOF    *
 *	if there are no more.						    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Changes globals col, numCols, numLines, LineBuf, fEof, fBof and     *
 *	line.								    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Decrements current file position to the right, then returns the     *
 *	character found there.	Reads through blank lines if necessary	    *
 *									    *
 ****************************************************************************/

int
lgetc ()
{
    if (fBof)  return (int)BOF;  /* We already it BOF last time 		  */

    if (--col < 0)
    {			    /* If prev character is on prev line ...	     */
			    /* ... get prev non-blank line (or BOF)	     */
	while ( --line >= 0  &&
		!(numCols = GetLine (line, (char far *)LineBuf, pFile)));

	if (line < 0)
	{		    /* We're at the top of the file                  */
	    fBof = TRUE;
	    return (int)BOF;
	}

	col = numCols - 1;   /* We got a line, so start at last character    */
    }

    fEof = (int)FALSE;
    return LineBuf[col];
}


/****************************************************************************
 *									    *
 *  pos (&x, &y)							    *
 *									    *
 *  SIDE EFFECTS:							    *
 *									    *
 *	Fills memory at *x and *y with current file position.		    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Gets the current file position.  Far pointers are needed because    *
 *	SS != DS.							    *
 *									    *
 ****************************************************************************/

void pos (fpx, fpy)
COL far *fpx;
LINE far *fpy;
{
    *fpx = col;
    *fpy = line;
}


/****************************************************************************
 *									    *
 *  No special switches.						    *
 *									    *
 ****************************************************************************/

struct swiDesc	swiTable[] =
{
    {  NULL, NULL, (INT_PTR)NULL }
};


/****************************************************************************
 *									    *
 *  <pmatch> is a cursor func, takes no arguments.			    *
 *									    *
 ****************************************************************************/

struct cmdDesc	cmdTable[] =
{
    {	"pmatch",	 (funcCmd) PMatch,   0, CURSORFUNC },
    {	NULL,		    NULL,   (UINT_PTR)NULL, (UINT_PTR)NULL	}
};


/****************************************************************************
 *									    *
 *  WhenLoaded ()							    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Attach to ALT+P and issue sign-on message.			    *
 *									    *
 ****************************************************************************/

void EXTERNAL WhenLoaded ()
{
    DoMessage (EXT_ID);
    SetKey ("pmatch",	"alt+p");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mhlook.c ===
/*** mhlook - Help Look-Up code.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* This module contains routines dealing with searching for and (hopefully)
* finding help information
*
* Revision History (most recent first):
*
*	30-Mar-1989 ln	pass popup flag around correctly.
*   []	12-Mar-1989 LN	Split off of mhdisp.c
*
*************************************************************************/
#include <string.h>			/* string functions		*/

#include "mh.h" 			/* help extension include file	*/


/*** fHelpCmd - Display topic text or execute command.
*
* Input:
*  szCur	= context string
*  fStay	= TRUE => keep focus in current window, else move focus to
*		  newly opened help window.
*  fWantPopUp	= TRUE => display as popup window. (Ignored in non-CW)
*
* Exit:
*  returns TRUE on success.
*
*************************************************************************/
flagType pascal near fHelpCmd (
	char	*szCur,
	flagType fStay,
	flagType fWantPopUp
	) {

	int     i;				/* index while checking for helpfiles*/
	nc		ncCur		= {0,0};				/* nc found 					*/


	//
	// If a command to display a context (!C), just remove the command
	//
	if (*(ushort UNALIGNED *)szCur == 0x4321) {
		szCur += 2;
	}

	//
	// If the command starts with an exclamation point, then go execute it.
	//
	if (*szCur == '!') {
		return fContextCommand (szCur+1);
	}

	stat(szCur);

	debmsg ("Searching:");

	//
	// search algorithm:
	//	1) if help is not up, or we're looking for a different string than the
	//	   last string we found, or it's a local context, try the same help file
	//	   as the last look-up, if there was a last lookup.
	//	2) If that fails, and it's not a local context, and we're not to present
	//	   a list, then look in the help file(s) that are associated with the
	//	   current file extension.
	//	3) If that fails, and it's not a local context, then search all the help
	//	   files.
	//	4) If THAT fails, then check to see if there are any help files open
	//	   at all, and return an appropriate error message on that.
	//
	if (ncInitLast.mh && ncInitLast.cn && (strcmp (szCur, szLastFound) || !(*szCur))) {
		ncCur = ncSearch (szCur, NULL, ncInitLast, FALSE, FALSE);
	}

	if (!ncCur.mh && !ncCur.cn && *szCur && fnExtCur && !fList) {
		nc ncTmp = {0,0};
		ncCur = ncSearch (szCur, fnExtCur, ncTmp, FALSE, FALSE);
	}

	if (!ncCur.mh && !ncCur.cn && *szCur) {
		nc ncTmp = {0,0};
		ncCur = ncSearch (szCur, NULL, ncTmp, FALSE, fList);
	}

	if (!ncCur.mh && !ncCur.cn) {
		for (i=MAXFILES-1; i; i--) {
			if ((files[i].ncInit.mh || files[i].ncInit.cn)) {
				return errstat ("Help on topic not found:",szCur);
			}
		}
		return errstat ("No Open Help Files", NULL);
	}

	//
	// Save this as the last context string actually found
	//
	xrefCopy (szLastFound, szCur);

	debend (TRUE);
	return fDisplayNc ( ncCur			/* nc to display		*/
						, TRUE			/* add to backtrace list	*/
						, fStay			/* keep focus in current win?	*/
						, fWantPopUp);	/* as a pop-up? 		*/

}

/*** fContextCommand - execute context command
*
* Input:
*  szCur	= pointer to context command
*
* Output:
*  Returns TRUE if it was executed
*
*************************************************************************/
flagType pascal near fContextCommand (
char	*szCur
) {
switch (*szCur++) {

case ' ':				    /* exeute DOS command   */
case '!':				    /* exeute DOS command   */
    strcpy(buf,"arg \"");
    strcat(buf,szCur);
    strcat(buf,"\" shell");
    fExecute(buf);			    /* execute as shell cmd */
    break;

case 'm':				    /* execute editor macro */
    fExecute(szCur);
    break;

default:
    return FALSE;
    }

Display ();
return TRUE;

/* end fContextCommand */}

/** ncSearch - find help on context string
*
*  search all the currently active help files for help on a particular
*  topic. If desired, restricts the search to those files which are
*  associated with a particular extension.
*
* Entry:
*  pText	= text to get help on
*  pExt 	= If non-null, the extension to restrict the search to.
*  ncInit	= if non-null, ncInit of the only help file to look in
*  fAgain	= If non-null, skip helpfiles until ncInit found, then
*		  pick up the search.
*  fList	= if true, present a list box of the posibilities.
*
* Exit:
*  returns nc found, or NULL
*
*************************************************************************/
nc pascal near ncSearch (
uchar far *pText,
uchar far *pExt,
nc	ncInit,
flagType fAgain,
flagType fList
) {
int	iHelp;				/* index into helpfile table	*/
int	j;
nc      ncRet   = {0,0};                    /* nc found                     */

UNREFERENCED_PARAMETER( fList );

debmsg (" [");
debmsg (pText);
debmsg ("]:");
/*
 * If this is just a single search (ncInit specified, and not a search
 * "again"), then JUST look in the single file.
 */
if ((ncInit.mh || ncInit.cn) && !fAgain)
    ncRet = HelpNc(pText,ncInit);
/*
 * If fList is specified, then search ALL the databases for ALL ocurrances
 * of the string, and make a list of the nc's we find.
 */
#if defined(PWB)
else if (fList) {
    iHelp = ifileCur;
    cList = 0;
    do {
	if (files[iHelp].ncInit) {
	    ncRet = files[iHelp].ncInit;
	    while (   (cList < CLISTMAX)
                   && (rgncList[cList] = HelpNc(pText,ncRet))) {
                ncRet = rgncList[cList++];
                ncRet.cn++;
            }
        }
	iHelp += iHelp ? -1 : MAXFILES-1;
	}
    while ((iHelp != ifileCur) && (cList < CLISTMAX));

    if (cList == 0) {
        ncRet.mh = ncRet.cn = 0;
        return ncRet;
    }
    if (cList == 1)
	return rgncList[0];
    return ncChoose(pText);
    }
#endif

else {
    iHelp = ifileCur;			    /* start with current file	    */
    do {
        if ((files[iHelp].ncInit.mh) &&
            (files[iHelp].ncInit.cn)) {          /* if helpfile open             */
	    if (pExt) { 		    /* if an extension was specified*/
		for (j=0; j<MAXEXT; j++) {  /* for all listed defaults	    */
		    if (fAgain) {
                        if ((ncInit.mh == files[iHelp].ncInit.mh) &&
                            (ncInit.cn == files[iHelp].ncInit.cn)) {
                            fAgain = FALSE;
                        }
                     }
			else if (strcmp(files[iHelp].exts[j],pExt) == 0) {
			debmsg (":");
			ncRet = HelpNc(pText,files[iHelp].ncInit);
			break;
			}
		    }
		}

	    else {			    /* no extension specified	    */
                if (fAgain && ((ncInit.mh == files[iHelp].ncInit.mh) &&
                               (ncInit.cn == files[iHelp].ncInit.cn)))
		    fAgain = FALSE;
		else {
		    ncRet = HelpNc(pText,files[iHelp].ncInit);
		    debmsg (":");
		    }
		}
	    }
        if (ncRet.mh || ncRet.cn)
	    ncInitLastFile = files[iHelp].ncInit;
	iHelp += iHelp ? -1 : MAXFILES-1;
	}
    while ((iHelp != ifileCur) && ((ncRet.mh == 0) && (ncRet.cn == 0)));
    }

debmsg ((ncRet.mh && ncRet.cn) ? "Y" : "N");

return ncRet;
/* end ncSearch */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\mhelp\mhutil.c ===
/*** mhutil - utilities for the help extension for the Microsoft Editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History (most recent first):
*
*	01-Dec-1988 ln	Cleanup & dislog help
*	28-Sep-1988 ln	Correct GrabWord return value
*	02-Sep-1988 ln	Make all data inited. Add info in debug vers.
*   []	16-May-1988	Extracted from mehelp.c
*
*************************************************************************/
#include <string.h>			/* string functions		*/
#include <malloc.h>
#include "mh.h" 			/* help extension include file	*/



/************************************************************************
**
** procArgs
**
** Purpose:
**  decode arguments passed into extension into commonly used variables.
**
** Entry:
**  pArg	= pointer to arg structure, courtesy of Z
**
** Exit:
**  returns pArg->argType. Global variables updated.
*/
int pascal near procArgs (pArg)
ARG far *pArg;				/* argument data		*/
{
buf[0] = 0;
pArgWord = pArgText = 0;
rnArg.flFirst.col = rnArg.flLast.col = 0;
rnArg.flFirst.lin = rnArg.flLast.lin = 0;
cArg = 0;

opendefault ();
pFileCur = FileNameToHandle ("", "");	/* get current file handle	*/
fnCur[0] = 0;
GetEditorObject(RQ_FILE_NAME,0,fnCur);	/* get filename 		*/
fnExtCur = strchr (fnCur, '.'); 	/* and pointer to extension	*/

switch (pArg->argType) {
    case NOARG:             /* <function> only, no arg  */
    cArg     = 0;
    pArgText = NULL;
	break;

    case NULLARG:			/* <arg><function>		*/
	cArg = pArg->arg.nullarg.cArg;	/* get <arg> count		*/
	GrabWord ();			/* get argtext and argword	*/
	break;

    case STREAMARG:			/* <arg>line movement<function> */
	cArg = pArg->arg.streamarg.cArg;/* get <arg> count		*/
	rnArg.flFirst.col = pArg->arg.streamarg.xStart;
	rnArg.flLast.col  = pArg->arg.streamarg.xEnd;
	rnArg.flFirst.lin = pArg->arg.streamarg.yStart;
	if (GetLine(rnArg.flFirst.lin, buf, pFileCur) > rnArg.flFirst.col) {
	    pArgText = &buf[rnArg.flFirst.col];  /* point at word		 */
	    buf[rnArg.flLast.col] = 0;		 /* terminate string		 */
	    }
	break;

    case TEXTARG:			/* <arg> text <function>	*/
	cArg = pArg->arg.textarg.cArg;	/* get <arg> count		*/
	pArgText = pArg->arg.textarg.pText;
	break;
    }
return pArg->argType;
/* end procArgs */}

/************************************************************************
**
** GrabWord - Grab the word under the editor cursor
**
** Purpose:
**  grabs the word underneath the cursor for context sensitive help look-up.
**
** Entry:
**  none
**
** Returns:
**  nothing. pArgWord points to word, if it was parsed.
*/
void pascal near GrabWord () {

pArgText = pArgWord = 0;
pFileCur = FileNameToHandle ("", "");	   /* get current file handle	   */
GetTextCursor (&rnArg.flFirst.col, &rnArg.flFirst.lin);
if (GetLine(rnArg.flFirst.lin, buf, pFileCur)) {	   /* get line			   */
    pArgText = &buf[rnArg.flFirst.col]; 		/* point at word	*/
    while (!wordSepar((int)*pArgText))
	pArgText++;			/* search for end		*/
    *pArgText = 0;			/* and terminate		*/
    pArgWord = pArgText = &buf[rnArg.flFirst.col];	/* point at word		*/
    while ((pArgWord > &buf[0]) && !wordSepar ((int)*(pArgWord-1)))
	pArgWord--;
    }
/* end GrabWord */}

/*** appTitle - Append help file title to buffer
*
*  Read in the title of a help file and append it to a buffer.
*
* Input:
*  fpDest	- far pointer to destination of string
*  ncInit	- Any nc of file to get title for
*
* Output:
*  Returns
*
*************************************************************************/
void pascal near appTitle (
char far *pDest,
nc	ncInit
) {
/*
** first, point to end of string to append to
*/
while (*pDest)
    pDest++;
/*
** Start by getting the info on the file referenced, so that we can get the
** ncInit for that file.
*/
if (!HelpGetInfo (ncInit, &hInfoCur, sizeof(hInfoCur))) {
    ncInit = NCINIT(&hInfoCur);
/*
** Find the context string, and read the topic. Then just read the first
** line into the destination
*/
    ncInit = HelpNc ("h.title",ncInit);
    if (ncInit.cn && (fReadNc(ncInit))) {
    pDest += HelpGetLine (1, BUFLEN, pDest, pTopic);
	*pDest = 0;
	free (pTopic);
	pTopic = NULL;
	}
/*
** If no title was found, then just place the help file name there.
*/
    else
	strcpy (pDest, HFNAME(&hInfoCur));
    }
/*
** If we couldn't even get the info, then punt...
*/
else
    strcpy (pDest, "** unknown **");
/* end appTitle */}


/*** errstat - display error status message
*
*  In non cw, just display the strings on the status line. In CW, bring up
*  a message box.
*
* Input:
*  sz1		= first error message line
*  sz2		= second. May be NULL.
*
* Output:
*  Returns FALSE
*************************************************************************/
flagType pascal near errstat (
char	*sz1,
char	*sz2
) {
#if defined(PWB)
DoMessageBox (sz1, sz2, NULL, MBOX_OK);
#else
buffer	buf;

strcpy (buf, sz1);
if (sz2) {
    strcat (buf, " ");
    strcat (buf, sz2);
    }
stat (buf);
#endif
return FALSE;
/* end errstat */}

/*** stat - display status line message
*
*  Places extension name and message on the status line
*
* Entry:
*  pszFcn      - Pointer to string to be prepended.
*
* Exit:
*  none
*
*************************************************************************/
void pascal near stat(pszFcn)
char *pszFcn;					/* function name	*/
{
buffer	buf;					/* message buffer	*/

strcpy(buf,"mhelp: ");				/* start with name	*/
if (strlen(pszFcn) > 72) {
    pszFcn+= strlen(pszFcn) - 69;
    strcat (buf, "...");
    }
strcat(buf,pszFcn);				/* append message	*/
DoMessage (buf);				/* display		*/
/* end stat */}

#ifdef DEBUG
buffer	debstring   = {0};
extern	int	delay;			/* message delay		*/

/*** debhex - output long in hex
*
*  Display the value of a long in hex
*
* Input:
*  lval 	= long value
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debhex (
long	lval
) {
char lbuf[10];

_ultoa (lval, lbuf, 16);
debmsg (lbuf);
/* end debhex */}

/*** debmsg - piece together debug message
*
*  Outputs a the cummulative message formed by successive calls.
*
* Input:
*  psz		= pointer to message part
*
* Output:
*  Returns nothing
*************************************************************************/
void pascal near debmsg (
char far *psz
) {
_stat (strcat (debstring, psz ? psz : "<NULL>" ));
/* end debmsg */}

/*** debend - terminates message accumulation & pauses
*
*  Terminates the message accumulation, displays the final message, and
*  pauses, either for the pause time, or for a keystroke.
*
* Input:
*  fWait	= TRUE => wait for a keystroke
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near debend (
flagType fWait
) {
if (fWait && delay) {
#if defined(PWB)
    DoMessageBox (debstring, NULL, NULL, MBOX_OK);
#else
    _stat (strcat (debstring, " Press a key..."));
    ReadChar ();
#endif
    }
#ifdef OS2
else if (delay)
    DosSleep ((long)delay);
#endif
debstring[0] = 0;
/* end debend */}

/*** _mhassertexit - display assertion message and exit
*
* Input:
*  pszExp	- expression which failed
*  pszFn	- filename containing failure
*  line 	- line number failed at
*
* Output:
*  Doesn't return
*
*************************************************************************/
void pascal near _mhassertexit (
char	*pszExp,
char	*pszFn,
int	line
) {
char lbuf[10];

_ultoa (line, lbuf, 10);
strcpy (buf, pszExp);
strcat (buf, " in ");
strcat (buf, pszFn);
strcat (buf, ": line ");
strcat (buf, lbuf);
errstat ("Help assertion failed", buf);

fExecute ("exit");

/* end _mhassertexit */}

#endif


flagType  pascal  wordSepar (int i) {
    CHAR c = (CHAR)i;
    if (((c >= 'a') && (c <= 'z')) ||
        ((c >= 'A') && (c <= 'Z')) ||
        ((c >= '0') && (c <= '9')) ||
         ( c == '_' )              ||
         ( c == '$' ) ) {
        return FALSE;
    } else {
        return TRUE;
    }
}


char far *  pascal near     xrefCopy (char far *dst, char far *src)
{
    if ( *src ) {
        strcpy( dst, src );
    } else {
        dst[0] = src[0];
        dst[1] = src[1];
        dst[2] = src[2];
    }

    return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\skel\skel.c ===
/*** skel.c - skeleton for editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Example source code for a loadable C editor extension.
*
*  NOTE: This code is shipped with the product! This note and the revision
*  history should be removed before shipping.
*
* Revision History:
*	24-Sep-1991 rs	Ported to Windows NT
*   16-Jan-1987 mz  Add pascal typing. Export switch set
*   21-May-1987 bw  Add return from WhenLoaded for OS/2
*   22-Oct-1987 mz  Correct definitions as headers
*   22-Jun-1988 ln  Updated and documented
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/

#include "ext.h"


/** Skel - Sample Editing Function
*
* Purpose:
*  Sample editing function entry point.
*
*  Editor functions are commands that can be attached to keys and are invoked
*  when those keys are struck.
*
* Input:
*  argData	= Value of the keystroke used to invoke the function
*  pArg	= Far pointer to a structure which defines the type of argument
*	  passed by the invoker of the function
*  fMeta	= Flag indicating whether the meta modifier was on at the time
*	  the function was executed.
*
* Output:
*  Editor functions are expected to return a boolean value indicating success
*  or failure. Typically, TRUE is returned in the normal case. These values
*  can be tested inside of macros.
*
************************************************************************/
flagType
pascal
EXTERNAL
Skel (
	unsigned int argData,
	ARG far *	 pArg,
	flagType	 fMeta
	)
{
	return TRUE;
}


/*** WhenLoaded - Extension Initialization
*
* Purpose:
*  This function is called whenever the extension is loaded into memory.
*  Extension initialization may occur here.
*
* Input:
*  none
*
* Output:
*  none
*
*************************************************************************/
void
EXTERNAL
WhenLoaded (
	void
	)
{
}


//
// Command description table. This is a vector of command descriptions that
// contain the textual name of the function (for user assignment), a pointer
// to the function to be called, and some data describing the type of
// arguments that the function can take.
//
struct cmdDesc	cmdTable[] = {
	{ "skel",	Skel,	0,	NOARG		},
	{ NULL,		NULL,	NULL,	NULL	}
};


//
// Switch description table. This is a vector of switch descriptions that
// contain the textual name of the switch (for user assignment), a pointer to
// the switch itself or a function to be called, and some data describing the
// type of switch.
//
struct swiDesc	swiTable[] =
{
    {NULL,	NULL,	NULL	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\tglcase\tglcase.c ===
/*** tglcase.c - case toggling editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Contains the tglcase function.
*
* Revision History:
*
*   28-Jun-1988 LN  Created
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/
#define EXT_ID	" tglcase ver 1.00 "##__DATE__##" "##__TIME__

#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>			/* prototypes for string fcns	*/
#include "ext.h"
/*
** Internal function prototypes
*/
void	 pascal 	 id	    (char *);
void		EXTERNAL WhenLoaded (void);
flagType pascal EXTERNAL tglcase    (unsigned int, ARG far *, flagType);

/*************************************************************************
**
** tglcase
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType pascal EXTERNAL tglcase (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    )
{
PFILE	pFile;				/* file handle of current file	*/
COL	xStart; 			/* left border of arg area	*/
LINE	yStart; 			/* starting line of arg area	*/
COL	xEnd;				/* right border of arg area	*/
LINE	yEnd;				/* ending line of arg area	*/
int	cbLine; 			/* byte count of current line	*/
COL	xCur;				/* current column being toggled */
char	buf[BUFLEN];			/* buffer for line being toggled*/
register char c;			/* character being analyzed	*/

	//
	//	Unreferenced parameters
	//
	(void)argData;
	(void)fMeta;

id ("");
pFile = FileNameToHandle ("", "");

switch (pArg->argType) {
/*
** For the various argument types, set up a box (xStart, yStart) - (xEnd, yEnd)
** over which the case conversion code below can operate.
*/
    case NOARG: 			/* case switch entire line	*/
	xStart = 0;
	xEnd = 256;
	yStart = yEnd = pArg->arg.noarg.y;
	break;

    case NULLARG:			/* case switch to EOL		*/
	xStart = pArg->arg.nullarg.x;
	xEnd = 32765;
	yStart = yEnd = pArg->arg.nullarg.y;
	break;

    case LINEARG:			/* case switch line range	*/
	xStart = 0;
	xEnd = 32765;
	yStart = pArg->arg.linearg.yStart;
	yEnd = pArg->arg.linearg.yEnd;
	break;

    case BOXARG:			/* case switch box		*/
	xStart = pArg->arg.boxarg.xLeft;
	xEnd   = pArg->arg.boxarg.xRight;
	yStart = pArg->arg.boxarg.yTop;
	yEnd   = pArg->arg.boxarg.yBottom;
	break;
    }
/*
** Within the range of lines yStart to yEnd, get each line, and if non-null,
** check each character. If alphabetic, replace with it's case-converted
** value. After all characters have been checked, replace line in file.
*/
while (yStart <= yEnd) {
    if (cbLine = GetLine (yStart, buf, pFile)) {
	for (xCur = xStart; (xCur <= min(cbLine, xEnd)); xCur++) {
	    c = buf[xCur];
	    if ((c >= 'A') && (c <= 'Z'))
		c += 'a'-'A';
	    else if ((c >= 'a') && (c <= 'z'))
		c += 'A'-'a';
	    buf[xCur] = c;
	    }
	PutLine (yStart++, buf, pFile);
	}
    }
return 1;
}

/*************************************************************************
**
** WhenLoaded
** Executed when extension gets loaded. Identify self & assign default
** keystroke.
**
** Entry:
**  none
*/
void EXTERNAL WhenLoaded () {

id("case conversion extension:");
SetKey ("tglcase",  "alt+c");
/* end WhenLoaded */}

/*************************************************************************
**
** id
** identify ourselves, along with any passed informative message.
**
** Entry:
**  pszMsg	= Pointer to asciiz message, to which the extension name
**		  and version are appended prior to display.
*/
void pascal id (pszFcn)
char *pszFcn;					/* function name	*/
{
char	buf[80];				/* message buffer	*/

strcpy (buf,pszFcn);				/* start with message	*/
strcat (buf,EXT_ID);				/* append version	*/
DoMessage (buf);
/* end id */}


/*************************************************************************
**
** Switch communication table to the editor.
** This extension defines no switches.
*/
struct swiDesc	swiTable[] = {
    {0, 0, 0}
    };

/*************************************************************************
**
** Command communication table to the editor.
** Defines the name, location and acceptable argument types.
*/
struct cmdDesc	cmdTable[] = {
    {"tglcase", (funcCmd) tglcase,0, KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG | MARKARG | NUMARG | MODIFIES},
    {0, 0, 0}
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\winclip\winclip.c ===
/*** winclip.c - windows clipboard editor extension
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  Contains the tglcase function.
*
* Revision History:
*
*   28-Jun-1988 LN  Created
*   12-Sep-1988 mz  Made WhenLoaded match declaration
*
*************************************************************************/
#define EXT_ID  " winclip ver 1.00 "##__DATE__

#include <windows.h>
#include <stdlib.h>			/* min macro definition 	*/
#include <string.h>                     /* prototypes for string fcns   */

#undef  pascal
#include "../../inc/ext.h"

#define M_FALSE     ((flagType)0)
#define M_TRUE      ((flagType)(-1))

#define BUFLEN_MAX  (BUFLEN-1)

/*
** Internal function prototypes
*/
void	 pascal 	 id	    (char *);
void		EXTERNAL WhenLoaded (void);
flagType pascal EXTERNAL wincopy   (unsigned int, ARG far *, flagType);
flagType pascal EXTERNAL wincut    (unsigned int, ARG far *, flagType);
flagType pascal EXTERNAL winpaste  (unsigned int, ARG far *, flagType);

#ifdef DEBUG
#   define DPRINT(p) DoMessage(p)
#else
#   define DPRINT(p)
#endif

HWND ghwndClip;
HINSTANCE ghmod;
int gfmtArgType;

void DeleteArg( PFILE pFile, int argType, COL xStart, LINE yStart,
        COL xEnd, COL yEnd );

void InsertText( PFILE pFile, LPSTR pszText, DWORD dwInsMode,
        COL xStart, LINE yStart );
flagType pascal EXTERNAL WinCutCopy (ARG *pArg, flagType fCut, flagType fClip);
LPSTR EndOfLine( LPSTR psz );
LPSTR EndOfBreak( LPSTR psz );
int ExtendLine( LPSTR psz, int cchSZ, char ch, int cchNew );

/*************************************************************************
**
** wincopy
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType pascal EXTERNAL wincopy (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    ) {

    return WinCutCopy( pArg, M_FALSE, M_FALSE );
}

flagType pascal EXTERNAL wincut (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    ) {

    return WinCutCopy( pArg, M_TRUE, fMeta );
}

flagType pascal EXTERNAL WinCutCopy (ARG *pArg, flagType fCut, flagType fNoClip)
{
    PFILE   pFile;                          /* file handle of current file  */
    COL xStart, xEnd;
    LINE yStart, yEnd;
    char achLine[BUFLEN];
    HANDLE hText;
    LPSTR pszText;
    int     iLine, cchLine;
    flagType fRet = M_TRUE;
    int     argSave, argType;

    pFile = FileNameToHandle ("", "");


    argSave = argType = pArg->argType;

    switch( argType ) {
    case BOXARG:                        /* case switch box              */
	xStart = pArg->arg.boxarg.xLeft;
        xEnd   = pArg->arg.boxarg.xRight + 1;
	yStart = pArg->arg.boxarg.yTop;
        yEnd   = pArg->arg.boxarg.yBottom + 1;

        /* At this point...
         *  [xy]Start is Inclusive, [xy]End is EXCLUSIVE of the box arg
         */

#ifdef DEBUG
        wsprintf( achLine, " BoxDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
        DoMessage( achLine );
#endif
	break;

    case NOARG:
        /* convert NOARG to a STREAMARG on whole current line */
        argType = STREAMARG;
        argSave = LINEARG;
        xStart = 0;
        yStart = pArg->arg.noarg.y;
        xEnd = 0;
        yEnd = yStart + 1;
        break;

    case TEXTARG:
        /*
         * Text args are only for real text.  NumArgs and MarkArgs are
         * converted to stream or box args by the editor since we say
         * we accept NUMARG and MARKARG during initialization.
         */
        argType = STREAMARG;
        argSave = STREAMARG;
        xStart = pArg->arg.textarg.x;
        xEnd = lstrlen(pArg->arg.textarg.pText) + xStart;
        yStart = yEnd = pArg->arg.textarg.y;
        break;

    case LINEARG:                       /* case switch line range       */
        /* convert LINEARG to a STREAMARG so we don't get lots of white space*/
        argType = STREAMARG;
	xStart = 0;
        xEnd = 0;
	yStart = pArg->arg.linearg.yStart;
        yEnd = pArg->arg.linearg.yEnd + 1;
#ifdef DEBUG
        wsprintf( achLine, " LineDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
        DoMessage( achLine );
#endif

        /* At this point...
         *  [xy]Start is Inclusive, [xy]End is EXCLUSIVE of the line arg
         */

        break;

    case STREAMARG:
        /*
         * Set Start == first char pos in stream, End == first char pos
         * AFTER stream.
         */
        xStart = pArg->arg.streamarg.xStart;
        xEnd = pArg->arg.streamarg.xEnd;
        yStart = pArg->arg.streamarg.yStart;
        yEnd = pArg->arg.streamarg.yEnd;
#ifdef DEBUG
        wsprintf( achLine, " StreamDims : %d %d %d %d ", (int)xStart, (int)yStart, (int)xEnd, (int)yEnd);
        DoMessage( achLine );
#endif
        break;

    default:
#ifdef DEBUG
        wsprintf( achLine, " Unknown Arg: 0x%04x", argType );
        DoMessage( achLine );
        return M_TRUE;
#endif
        return M_FALSE;
    }

    if (!fNoClip) {
        if (argType == STREAMARG) {
            int cch = 0;
            int iChar;

            for( iLine = yStart; iLine <= yEnd; iLine++ )
                cch += GetLine (iLine, achLine, pFile) + 3;

            hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, cch);

            if (hText == NULL) {
                DoMessage( " winclip: Out of Memory" );
                return M_FALSE;
            }

            pszText = GlobalLock(hText);


            iChar = xStart;

            for( iLine = yStart; iLine < yEnd; iLine++ ) {
                cchLine = GetLine (iLine, achLine, pFile);

                /* Incase we start after the end of the line */
                if (cchLine < iChar)
                    cch = 0;
                else
                    cch = cchLine - iChar;

                CopyMemory(pszText, &achLine[iChar], cch);
                pszText += cch;
                strcpy( pszText, "\r\n" );
                pszText += 2;
                iChar = 0;

            }

            /* Get partial last line */
            if (xEnd != 0) {
                cchLine = GetLine (iLine, achLine, pFile);

                /* if line is short, then pad it out */
                cchLine = ExtendLine( achLine, cchLine, ' ', xEnd );

                if (cchLine < iChar)
                    cchLine = 0;
                else
                    cchLine = xEnd - iChar;

                CopyMemory(pszText, &achLine[iChar], cchLine);
                pszText += cchLine;
            }

        } else {
            LINE iLine;
            int cchBox = xEnd - xStart;

            hText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                (yEnd - yStart) * (cchBox + 3));

            if (hText == NULL) {
                DoMessage( " winclip: Out of Memory" );
                return M_FALSE;
            }

            pszText = GlobalLock(hText);

            for( iLine = yStart; iLine < yEnd; iLine++ ) {
                cchLine = GetLine (iLine, achLine, pFile);

                if (argType == BOXARG)
                    cchLine = ExtendLine( achLine, cchLine, ' ', xEnd );

                if (cchLine < xStart )
                    cchLine = 0;
                else
                    cchLine -= xStart;

                cchLine = min(cchLine, cchBox);

                CopyMemory(pszText, &achLine[xStart], cchLine);
                pszText += cchLine;
                strcpy( pszText, "\r\n" );
                pszText += 2;

            }
        }

        *pszText = '\0';

        GlobalUnlock(hText);

        if (OpenClipboard(ghwndClip)) {
            EmptyClipboard();

            /*
             * Set the text into the clipboard
             */
            if (SetClipboardData(CF_TEXT, hText) == hText) {
                /*
                 * Remember the Arg type for pasting back
                 */
                if (gfmtArgType != 0) {
                    DWORD *pdw;
                    HANDLE hArgType = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                            sizeof(DWORD));

                    if (hArgType != NULL && (pdw = GlobalLock(hArgType)) != NULL) {
                        *pdw = (DWORD)(argSave);

                        GlobalUnlock(hArgType);

                        SetClipboardData(gfmtArgType, hArgType);
                    }
                }
            } else {
                /* An error occured writing text to clipboard */

                wsprintf(achLine, " winclip: Error (%ld) setting data",
                    GetLastError());
                DoMessage( achLine );
                fRet = M_FALSE;
            }

            CloseClipboard();
        }
    }

    /*
     * No need to free the handle, USER32 will do it (yes it keeps
     * track of the client side handle) when we set the next clipboard
     * data.  (Love that Win3.1 compatibility!)
     */
    if (fRet && fCut)
        DeleteArg( pFile, argType, xStart, yStart, xEnd, yEnd );


    return fRet;
}

/*************************************************************************
**
** winpaste
** Toggle the case of alphabetics contaied within the selected argument:
**
**  NOARG	- Toggle case of entire current line
**  NULLARG	- Toggle case of current line, from cursor to end of line
**  LINEARG	- Toggle case of range of lines
**  BOXARG	- Toggle case of characters with the selected box
**  NUMARG	- Converted to LINEARG before extension is called.
**  MARKARG	- Converted to Appropriate ARG form above before extension is
**		  called.
**
**  STREAMARG	- Not Allowed. Treated as BOXARG
**  TEXTARG	- Not Allowed
**
*/
flagType pascal EXTERNAL winpaste (
    unsigned int argData,		/* keystroke invoked with	*/
    ARG *pArg,                          /* argument data                */
    flagType fMeta 		        /* indicates preceded by meta	*/
    )
{
    PFILE   pFile;                          /* file handle of current file  */
    COL xStart, xEnd;
    LINE yStart, yEnd;
    int argType;
    UINT fmtData = CF_TEXT;
    DWORD dwInsMode = STREAMARG;
    HANDLE hText;
    LPSTR pszText;

    /*
     * Get the clipboard text and insertion type
     */
    if (pArg->argType == TEXTARG) {
        int i, j;
        char achLine[3 + 1 + 3 + 1 + 1 + BUFLEN + 1 + 1 + 5 + 1];
        char *p;

        /*
         * Quick hack to make text arg pastes work like the do in MEP
         */
        j = pArg->arg.textarg.cArg;
        if (j > 2)
            j = 2;

        achLine[0] = '\0';
        for( i = 0; i < j; i++ )
            lstrcat(achLine, "arg ");

        p = achLine + lstrlen(achLine);
        wsprintf( p, "\"%s\" paste", pArg->arg.textarg.pText );
        return fExecute( achLine );
    }

    /* if no text then return FALSE */
    if (!IsClipboardFormatAvailable(fmtData)) {

        /* No text, try display text */
        fmtData = CF_DSPTEXT;

        if (!IsClipboardFormatAvailable(fmtData)) {
            /* bummer! no text at all, return FALSE */
            DoMessage( " winclip: invalid clipboard format" );
            return M_FALSE;
        }
    }

    if (!OpenClipboard(ghwndClip))
        return M_FALSE;

    hText = GetClipboardData(fmtData);
    if (hText == NULL || (pszText = GlobalLock(hText)) == NULL) {
        CloseClipboard();
        return M_FALSE;
    }


    /* Get insert mode */

    if (IsClipboardFormatAvailable(gfmtArgType)) {
        DWORD *pdw;
        HANDLE hInsMode;

        hInsMode = GetClipboardData(gfmtArgType);

        if (hInsMode != NULL && (pdw = GlobalLock(hInsMode)) != NULL) {
            dwInsMode = *pdw;

            GlobalUnlock(hInsMode);
        }
    }



    pFile = FileNameToHandle ("", "");

    argType = pArg->argType;

    switch( argType ) {
    case BOXARG:                        /* case switch box              */
        /*
         * Set [xy]Start inclusive of box arg,
         *     [xy]End   exclusive of box arg.
         */
	xStart = pArg->arg.boxarg.xLeft;
        xEnd   = pArg->arg.boxarg.xRight + 1;
	yStart = pArg->arg.boxarg.yTop;
        yEnd   = pArg->arg.boxarg.yBottom + 1;
	break;

    case LINEARG:			/* case switch line range	*/
        /*
         * Set [xy]Start inclusive of line arg,
         *     [xy]End   exclusive of line arg.
         */
	xStart = 0;
        xEnd = BUFLEN + 1;
	yStart = pArg->arg.linearg.yStart;
        yEnd = pArg->arg.linearg.yEnd + 1;
        break;

    case STREAMARG:
        /*
         * Set [xy]Start inclusive of stream
         *     xEnd is EXCLUSIVE of stream
         *     yEnd is INCLUSIVE of stream
         */
        xStart = pArg->arg.streamarg.xStart;
        xEnd = pArg->arg.streamarg.xEnd;
        yStart = pArg->arg.streamarg.yStart;
        yEnd = pArg->arg.streamarg.yEnd;
        break;

    case NOARG:
        xStart = pArg->arg.noarg.x;
        xEnd = xStart + 1;
        yStart = pArg->arg.noarg.y;
        yEnd = yStart + 1;
        break;

    default:
        GlobalUnlock(hText);
        CloseClipboard();
        return M_FALSE;
    }


    /*
     * Delete any selection
     */
    DeleteArg( pFile, argType, xStart, yStart, xEnd, yEnd );

    /*
     * Insert new text with correct mode
     */
    InsertText( pFile, pszText, dwInsMode, xStart, yStart );

    GlobalUnlock(hText);
    CloseClipboard();

    return M_TRUE;
}

/*************************************************************************
**
** windel
**
**
*/
flagType pascal EXTERNAL windel (
    unsigned int argData,               /* keystroke invoked with       */
    ARG *pArg,                          /* argument data                */
    flagType fMeta                      /* indicates preceded by meta   */
    )
{
    int argType = pArg->argType;

    if (argType == NOARG)
        return fExecute("delete");

    if (argType == NULLARG) {
        int c, x, y;
        c = pArg->arg.nullarg.cArg;
        x = pArg->arg.nullarg.x;
        y = pArg->arg.nullarg.y;

        pArg->argType = STREAMARG;
        pArg->arg.streamarg.xStart = x;
        pArg->arg.streamarg.xEnd = 0;
        pArg->arg.streamarg.yStart = y;
        pArg->arg.streamarg.yEnd = y + 1;
        pArg->arg.streamarg.cArg = c;
    }

    return WinCutCopy (pArg, M_TRUE, fMeta);
}

/*************************************************************************
**
** WhenLoaded
** Executed when extension gets loaded. Identify self & assign default
** keystroke.
**
** Entry:
**  none
*/
void EXTERNAL WhenLoaded () {

#if 0
    WNDCLASS wc;

    ghmod = GetModuleHandle(NULL);

    wc.style = 0;
    wc.lpfnWndProc = (WNDPROC)DefWindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ghmod;
    wc.hIcon = NULL;
    wc.hCursor =  NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;   /* Name of menu resource in .RC file. */
    wc.lpszClassName = "WinClipWClass"; /* Name used in call to CreateWindow. */

    if (RegisterClass(&wc) && (ghwndClip = CreateWindow( "WinClipWClass",
            "ClipWindow", WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, NULL, NULL,
            ghmod, NULL)) != NULL ) {
        id(" Windows Clipboard Extentions for MEP,");
    } else {
        DoMessage( " winclip: Initialization failed!" );
    }
#else
    ghwndClip = NULL; //assign clipboard to this thread instead
#endif

    gfmtArgType = RegisterClipboardFormat( "MEP Arg Type" );

#if 0
    //SetKey ("wincut",   "ctrl+x");
    SetKey ("wincopy",  "ctrl+c");
    SetKey ("winpaste", "ctrl+v");
#endif
}

/*************************************************************************
**
** id
** identify ourselves, along with any passed informative message.
**
** Entry:
**  pszMsg	= Pointer to asciiz message, to which the extension name
**		  and version are appended prior to display.
*/
void pascal id (char *pszFcn) {
    char    buf[80];

    strcpy (buf,pszFcn);
    strcat (buf,EXT_ID);
    DoMessage (buf);
}


/*************************************************************************
**
** Switch communication table to the editor.
** This extension defines no switches.
*/
struct swiDesc	swiTable[] = {
    {0, 0, 0}
};

/*************************************************************************
**
** Command communication table to the editor.
** Defines the name, location and acceptable argument types.
*/
struct cmdDesc	cmdTable[] = {
    {"wincopy",  (funcCmd) wincopy, 0, KEEPMETA | NOARG  | BOXARG | LINEARG | STREAMARG | MARKARG | NULLEOL | NUMARG },
    {"wincut",   (funcCmd) wincut,  0, NOARG  | BOXARG | LINEARG | STREAMARG | MARKARG | NULLEOL | NUMARG | MODIFIES},
    {"windel",   (funcCmd) windel,  0, NOARG  | BOXARG | LINEARG | STREAMARG | NULLARG | MODIFIES},
    {"winpaste", (funcCmd) winpaste,0, KEEPMETA | NOARG  | BOXARG | LINEARG | STREAMARG | TEXTARG | MODIFIES},
    {0, 0, 0}
};


void DeleteArg( PFILE pFile, int argType, COL xStart, LINE yStart,
        COL xEnd, COL yEnd ) {

    switch( argType ) {

    case STREAMARG:
        DelStream(pFile, xStart, yStart, xEnd, yEnd);
        break;

    case LINEARG:
        DelStream(pFile, 0, yStart, 0, yEnd);
        break;


    case BOXARG: {
        LINE iLine;

        for( iLine = yStart; iLine < yEnd; iLine++ ) {
            DelStream( pFile, xStart, iLine, xEnd, iLine );
        }

        break;
    }


    default:
        break;
    }
}




void InsertText( PFILE pFile, LPSTR pszText, DWORD dwInsMode, COL xStart,
        LINE yStart ) {
    char ch;
    int  cchLine, cchText, cchCopy;
    LPSTR pszNL;
    char achLine[BUFLEN];
    char achEnd[BUFLEN];

    switch( dwInsMode ) {
    case STREAMARG:
        /*
         * Split current line,
         * tack first line from buffer to end of new line
         * put the new lines in file
         * shove the last line to the beggining of the 2nd half of the line
         */
        DPRINT( "  Stream Paste" );
        if ( *pszText == '\0' )
            break;


        pszNL = EndOfLine(pszText);

        cchLine = GetLine( yStart, achLine, pFile );

        if (cchLine < xStart)
            cchLine = ExtendLine( achLine, cchLine, ' ', xStart );

        cchText = (int)(pszNL - pszText);
        if (xStart + cchText >= BUFLEN_MAX) {
            cchText = BUFLEN_MAX - xStart;
            pszNL = pszText + cchText;
        }

        strcpy( achEnd, &achLine[xStart] );
        cchLine -= xStart;

        CopyMemory( &achLine[xStart], pszText, cchText );
        cchText += xStart;
        achLine[cchText] = '\0';


        while( *pszNL ) {
            PutLine( yStart++, achLine, pFile );
            CopyLine( NULL, pFile, 0, 0, yStart );

            pszText = EndOfBreak(pszNL);
            pszNL = EndOfLine(pszText);

            cchText = (int)(pszNL - pszText);

            CopyMemory( achLine, pszText, cchText );
            achLine[cchText] = '\0';
        }

        cchCopy = 0;
        if (cchLine + cchText > BUFLEN_MAX) {
            cchCopy = (cchLine + cchText) - BUFLEN_MAX;
            cchLine = cchLine - cchCopy;
        }

        CopyMemory( &achLine[cchText], achEnd, cchLine );
        achLine[cchLine+cchText] = '\0';
        PutLine( yStart++, achLine, pFile );

        if (cchCopy != 0) {
            CopyLine( NULL, pFile, 0, 0, yStart );
            CopyMemory( achLine, &achEnd[cchLine], cchCopy );
            achLine[cchCopy] = '\0';
            PutLine( yStart++, achLine, pFile);
        }
        break;

    case BOXARG:
        /*
         * Insert the text as a block into the middle of each line.
         * This could be tricky since we need to pad all short lines
         * out with spaces to match the lenght of the longest line
         * in the text.
         */

        DPRINT( "  Box Paste" );
        while( *pszText ) {
            pszNL = EndOfLine(pszText);

            cchLine = GetLine( yStart, achLine, pFile );

            if (cchLine < xStart)
                cchLine = ExtendLine( achLine, cchLine, ' ', xStart );

            cchText = (int)(pszNL - pszText);
            if (cchLine + cchText > BUFLEN_MAX)
                cchText = BUFLEN_MAX - cchLine;

            /* insert text in middle of line */
            strcpy( achEnd, &achLine[xStart] );
            CopyMemory( &achLine[xStart], pszText, cchText );
            strcpy( &achLine[xStart + cchText], achEnd );

            /* put line in file */
            PutLine( yStart++, achLine, pFile );

            pszText = EndOfBreak(pszNL);
        }
        break;

    case LINEARG:
        /*
         * shove the lines in the buffer before the current line
         */
        DPRINT( "  Line Paste" );
        while( *pszText ) {
            pszNL = EndOfLine(pszText);
            ch = *pszNL;
            *pszNL = '\0';
            CopyLine( NULL, pFile, 0, 0, yStart );
            PutLine( yStart++, pszText, pFile);
            *pszNL = ch;
            pszText = EndOfBreak(pszNL);
        }
        break;

    default:
        break;
    }

}


LPSTR EndOfLine( LPSTR psz ) {
    int c;

    c = 0;
    while( *psz && *psz != '\r' && *psz != '\n' && c++ < BUFLEN_MAX )
        psz++;

    return psz;
}

LPSTR EndOfBreak( LPSTR psz ) {
    char chSkip;

    switch( *psz ) {
    case '\r':
        chSkip = '\n';
        break;

    case '\n':
        chSkip = '\r';
        break;

    default:
        return psz;

    }

    if (*(++psz) == chSkip)
        psz++;

    return psz;
}


int ExtendLine( LPSTR psz, int cchLine, char ch, int cchTotal ) {

    if ( cchLine >= cchTotal )
        return cchLine;

    if (cchTotal > BUFLEN_MAX)
        cchTotal = BUFLEN_MAX;

    psz = &psz[cchLine];

    while( cchLine++ < cchTotal )
        *psz++ = ch;

    *psz = '\0';

    return cchLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\hback.c ===
/*** hlback.c - help library historical back-trace routines & data
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   02-Aug-1988 ln  Correct HelpNcBack
*   19-May-1988 LN  Split off from help.c
*
*************************************************************************/
#include <assert.h>                     /* debugging assertions         */
#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif


#include "help.h"			/* global (help & user) decl	*/
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

/*************************************************************************
**
** cBack, iBackLast, rgncBack
** System context back-trace list.
**
** cBack	- Number of entries in back-trace list
** iBackLast	- Index to last back trace entry
** rgncBack	- Array of back-trace entries
*/
extern	ushort	cBack;			/* Number of Back-List entries	*/
static	ushort	iBackLast;		/* Back-List Last entry index	*/
static	nc	rgncBack[MAXBACK+1];	/* Back-List			*/

/************************************************************************
**
** HelpNcRecord - Remember context for back-trace
**
** Purpose:
**  records a context number for back-trace.
**
** Entry:
**  ncCur	= context number to record.
**
** Exit:
**  none
**
** Exceptions:
**  none
*/
void far pascal LOADDS HelpNcRecord(ncCur)
nc	ncCur;
{
ushort	*pcBack = &cBack;

if ((ncCur.mh || ncCur.cn) &&
    ((ncCur.mh != rgncBack[iBackLast].mh) ||
     (ncCur.cn != rgncBack[iBackLast].cn))) {
    iBackLast = (ushort)(((int)iBackLast + 1) % MAXBACK);
    rgncBack[iBackLast] = ncCur;
    if (*pcBack < MAXBACK)
	(*pcBack)++;
}
/* end HelpNcRecord */}

/******************************************************************************
**
** HelpNcBack - Return previously viewed context
**
** Purpose:
**  Returns the context number corresponding to the historically previously
**  viewed topic.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on backup list exhuasted
**
** Algorithm:
**
**  If backlist not empty
**	context is last entry in back list
**	remove last entry
**  else
**	return NULL
*/
nc far pascal LOADDS HelpNcBack(void) {
nc      ncLast          = {0,0};         /* return value                 */
ushort	*pcBack = &cBack;

if (*pcBack) {
    ncLast = rgncBack[iBackLast];
    iBackLast = iBackLast == 0 ? (ushort)MAXBACK-1 : (ushort)iBackLast-1;
    (*pcBack)--;
    }
return ncLast;
/* end HelpNcBack */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\extens\ulcase\ulcase.c ===
#define EXT_ID  " ulcase ver 2.01 "##__DATE__##" "##__TIME__
/*
** ULcase Z extension
**
** History:
**  30-Mar-1988     Broken out of "myext"
**  12-Sep-1988 mz  Made WhenLoaded match declaration
*/
#include <ctype.h>

#include "ext.h"

#ifndef TRUE
#define TRUE    -1
#define FALSE   0
#endif

#ifndef NULL
#define NULL    ((char *) 0)
#endif

flagType pascal ulcase (ARG *, int, int, int);

/*************************************************************************
**
** id
** identify the source of the operation being performed
*/
void id(char *pszFcn)
{
char    buf[80];                                /* message buffer       */

strcpy (buf,pszFcn);                            /* start with message   */
strcat (buf,EXT_ID);                            /* append version       */
DoMessage (buf);
}

/*************************************************************************
**
** ucase
** convert arg to upper case.
*/
flagType pascal EXTERNAL
ucase (
    CMDDATA  argData,
    ARG far  *pArg,
    flagType fMeta
    )
{

(void)argData;
(void)fMeta;
id("ucase:");
return ulcase (pArg, 'a', 'z', 'A'-'a');
}

/*************************************************************************
**
** lcase
** convert arg to lower case.
*/
flagType pascal EXTERNAL
lcase (
    CMDDATA  argData,
    ARG far *pArg,
    flagType fMeta
    )
{
(void)argData;
(void)fMeta;
id("lcase:");
return ulcase (pArg, 'A', 'Z', 'a'-'A');
}

/*
** ulcase
** convert arg case.
*/
flagType pascal ulcase (pArg, cLow, cHigh, cAdj)
ARG *pArg;                          /* argument data                */
int     cLow;                           /* low char of range to check for */
int     cHigh;                          /* high char of range to check for */
int     cAdj;                           /* adjustment to make           */
{
PFILE   pFile;
COL     xStart;
LINE    yStart;
COL     xEnd;
LINE    yEnd;
int     i;
COL     xT;
char    buf[BUFLEN];


pFile = FileNameToHandle ("", "");

switch (pArg->argType) {

    case NOARG:                                 /* case switch entire line */
        xStart = 0;
        xEnd = 32765;
        yStart = yEnd = pArg->arg.noarg.y;
        break;

    case NULLARG:                               /* case switch to EOL   */
        xStart = pArg->arg.nullarg.x;
        xEnd = 32765;
        yStart = yEnd = pArg->arg.nullarg.y;
        break;

    case LINEARG:                               /* case switch line range */
        xStart = 0;
        xEnd = 32765;
        yStart = pArg->arg.linearg.yStart;
        yEnd = pArg->arg.linearg.yEnd;
        break;

    case BOXARG:                                /* case switch box      */
        xStart = pArg->arg.boxarg.xLeft;
        xEnd   = pArg->arg.boxarg.xRight;
        yStart = pArg->arg.boxarg.yTop;
        yEnd   = pArg->arg.boxarg.yBottom;
        break;
    }

while (yStart <= yEnd) {
    i = GetLine (yStart, buf, pFile);
    xT = xStart;                                /* start at begin of box*/
    while ((xT <= i) && (xT <= xEnd)) {         /* while in box         */
        if ((int)buf[xT] >= cLow && (int)buf[xT] <= cHigh)
            buf[xT] += (char)cAdj;
        xT++;
        }
    PutLine (yStart++, buf, pFile);
    }

return TRUE;
}

/*
** switch communication table to Z
*/
struct swiDesc  swiTable[] = {
    {0, 0, 0}
    };

/*
** command communication table to Z
*/
struct cmdDesc  cmdTable[] = {
    {   "ucase",        ucase, 0, MODIFIES | KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG },
    {   "lcase",        lcase, 0, MODIFIES | KEEPMETA | NOARG | BOXARG | NULLARG | LINEARG },
    {0, 0, 0}
    };

/*
** WhenLoaded
** Executed when these extensions get loaded. Identify self & assign keys.
*/
void EXTERNAL  WhenLoaded () {

id("case conversion:");
SetKey ("ucase",  "alt+u");
SetKey ("lcase",  "alt+l");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\hdata.c ===
/*** hdata.c - global help engine data definitions.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   []	01-Mar-1989 LN	    Created
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"			/* global (help & user) decl	*/
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

/*************************************************************************
**
** Global data
** BEWARE. The effects of global data on reentrancy should be VERY carefully
** considered.
**
**************************************************************************
**
** tbmhFdb[]
** Table of FDB handles. Non-zero value indicates allocated to open help file.
** We make this table one larger than it needs to be to save code later on.
*/
mh	tbmhFdb[MAXFILES+1]	= {0};
/*
** szNil
** Null string.
*/
char	szNil[1]		= "";
/*
** cBack
** count of entries in the help back-trace list
*/
ushort	cBack			= 0;	/* Number of Back-List entries	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\hctl.c ===
/**************************************************************************
 *hctl - enable/disable retrieval of control lines
 *
 *       Copyright <C> 1989, Microsoft Corporation
 *
 * Purpose:
 *
 * Revision History:
 *
 *       10-Oct-1990     RJSA    Translated to C
 *       13-May-1990     LN      Unlock topic text when through with it.
 *  []   22-Feb-1989     LN      Created
 *
 **************************************************************************/

#include <stdio.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include <help.h>
#include <helpfile.h>
#include <helpsys.h>



/**** helpctl - enable/disable retrieval of control lines
 * void far pascal helpctl(
 * uchar far *pTopic,
 * f     fEnable
 * )
 *
 * Purpose:
 *  Enables or disables retrieval of embedded help control lines
 *
 * Entry:
 *  pTopic       = Topic text
 *  fEnable      = TRUE=> allow lookups of control lines, else disable
 *
 * Exit:
 *  returns nothing
 *
 **************************************************************************/

void pascal
HelpCtl (
    PB   pTopic,
    f    fEnable
    ) {

    struct topichdr UNALIGNED *pT;


    pT = PBLOCK(pTopic);

    if (pT) {

        pT->lnCur   = 1;
        pT->lnOff   = sizeof(struct topichdr);
        pT->linChar = pT->appChar;

        if (fEnable) {
            pT->linChar = 0xFF;
        }

        PBUNLOCK(pTopic);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\helpdec.c ===
/*************************************************************************
 * helpdec - HelpDecomp routine and Other ASM code
 *
 *       Copyright <C> 1988, Microsoft Corporation
 *
 * Purpose:
 *
 * Revision History:
 *
 *       08-Oct-1990     RJSA    Converted to C
 *       22-Dec-1988     LN      Removed MASM High Level Lang support (Need
 *                               to control segments better than that will
 *                               let me)
 *       08-Dec-1988     LN      CSEG
 *       16-Feb-1988     LN      Rewrite for (some) speed
 *  []   17-Jan-1988     LN      Created
 *
 **************************************************************************/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif


#include <help.h>
#include <helpfile.h>

#pragma function( memset, memcpy, memcmp, strcpy, strcmp, strcat )

//  In order to increase performance, and because of the functions
//  decomp and NextChar being tightly coupled, global variables are
//  used instead of passing parameters.
//

PBYTE	pHuffmanRoot;	//	Root of Huffman Tree
PBYTE	pCompTopic;			//	Current pointer to text (compressed)
BYTE    BitMask;        //  Rotating bit mask
BOOL    IsCompressed;   //  True if text is compressed


BYTE NextChar (void);
BOOL pascal HelpCmp (PCHAR   fpsz1, PCHAR   fpsz2, USHORT  cbCmp, BOOL  fCase, BOOL  fTerm);


/**************************************************************************
 *
 * Decomp - Decompress Topic Text
 * f near pascal Decomp(fpHuffmanRoot, fpKeyphrase, fpTopic, fpDest)
 * uchar far *fpHuffmanRoot
 * uchar far *fpKeyphrase
 * uchar far *fpTopic
 * uchar far *fpDest
 *
 * Purpose:
 *  Fully decompress topic text. Decompresses based on current file, from one
 *  buffer to another.
 *
 * Entry:
 *  fpHuffmanRoot - Pointer to root of huffman tree (or NULL if no huffman)
 *  fpKeyphrase - Pointer to keyphrase table (or NULL if no keyphrase)
 *  fpTopic     - Pointer to compressed topic text
 *  fpDest      - Pointer to destination buffer
 *
 * Exit:
 *  FALSE on successful completion
 *
 * Exceptions:
 *  Returns TRUE on any error.
 *
 **************************************************************************/
BOOL  pascal decomp (
        PCHAR  fpHuffmanRoot,
        PCHAR  fpKeyphrase,
        PCHAR  fpTopic,
        PCHAR  fpDest
        ){

	int		cDecomp;		/* count of totally decompressed	*/
	BYTE	c;				/* byte read						*/

#ifdef BIGDEBUG
	char	DbgB[128];
	char	*DbgP = fpDest;
#endif


    // Initialize global variables.

	pHuffmanRoot	=	(PBYTE)fpHuffmanRoot;
	pCompTopic		=	(PBYTE)fpTopic + sizeof(USHORT);
    BitMask         =   0x01;
    IsCompressed    =   fpHuffmanRoot
                          ?   ((*(USHORT UNALIGNED *)((PBYTE)fpHuffmanRoot + 2)) != 0xFFFF)
                          :   FALSE;

    cDecomp     = *((USHORT UNALIGNED *)fpTopic);

#ifdef BIGDEBUG
	sprintf(DbgB, "DECOMPRESSING: HuffmanRoot: %lx, Keyphrase: %lx\n", fpHuffmanRoot, fpKeyphrase );
	OutputDebugString(DbgB);
	sprintf(DbgB, "               Topic: %lx, Dest: %lx\n", fpTopic, fpDest );
	OutputDebugString(DbgB);
	if ( IsCompressed ) {
		OutputDebugString("               The Topic IS Compressed\n");
	}
#endif

	while ( cDecomp > 0 ) {

        c = NextChar();

        //
		// At this point a valid character has been found and huffman decoded. We must
        // now perform any other decoding on it that is required.
        //
        // Variables are:
        //    c          = character
        //    cDecomp    = Output count remaining
        //    BitMask    = bit mask for interpreting input stream
        //
        // "Magic Cookie" decompression.
        // The chararacter stream after huffman encoding is "cookie" encoded, in that
        // certain characters are flags which when encountered mean something other than
        // themselves. All characters which are NOT such flags (or cookies, as they seem
        // to be called), are simply copied to the output stream.
        //
        // We first check the character to see if it IS a cookie. If it is NOT, we just
        // store it, and get the next input byte
        //

        if ((c >= C_MIN) && (c <= C_MAX)) {

            BYTE    Cookie = c ;

#ifdef BIGDEBUG
			OutputDebugString("Cookie\n");
#endif
            // c is a cookie of some sort, jump to the appropriate
            // cookie eater.

            c = NextChar();

            switch (Cookie) {
                case C_KEYPHRASE0:
                case C_KEYPHRASE1:
                case C_KEYPHRASE2:
                case C_KEYPHRASE3:
                case C_KEYPHRASE_SPACE0:
                case C_KEYPHRASE_SPACE1:
                case C_KEYPHRASE_SPACE2:
                case C_KEYPHRASE_SPACE3:
                    {
						ULONG	Index;	/* Keyword index */
                        PBYTE   pKey;   /* Keyword       */
                        BYTE    Size;   /* Keyword size  */

                        if ((Cookie >= C_KEYPHRASE_SPACE0) && (Cookie <= C_KEYPHRASE_SPACE3)) {
							Index = (ULONG)((int)Cookie - C_MIN - 4);
                        } else {
							Index = (ULONG)((int)Cookie - C_MIN);
                        }
						Index = (ULONG)(((Index * 0x100) + c) * sizeof(PVOID));

						pKey = *(PBYTE *)(((PBYTE)fpKeyphrase) + Index);

						// pKey = *(PBYTE *)(fpKeyphrase + Index);

                        Size = *pKey++;

                        {
                            BYTE i = Size;

							while (i--) {
								*fpDest++ = *pKey++;
                            }
                            cDecomp -=Size;
                        }
                        if ((Cookie >= C_KEYPHRASE_SPACE0) && (Cookie <= C_KEYPHRASE_SPACE3)) {
							*fpDest++ = ' ';
                            cDecomp--;
                        }
                        break;
                    }

                case C_RUNSPACE:
                    {
                        BYTE  Count = c;

                        while (Count--) {
							*fpDest++ = ' ';
                        }
                        cDecomp -= c;
                        break;
                    }

                case C_RUN:
                    {
                        BYTE    b = c;
                        BYTE    Cnt;

                        Cnt = c = NextChar();

                        while (Cnt--) {
							*fpDest++ = b;
                        }
                        cDecomp -= c;
                        break;
                    }

                case C_QUOTE:
					*fpDest++ =  c;
                    cDecomp--;
                    break;

            }

        } else {

            // c is not a cookie

			*fpDest++ = c;
            cDecomp--;
        }
    }

	*fpDest++ = '\00';	// Null terminate string

#ifdef BIGDEBUG
	sprintf( DbgB, "Decompressed topic: [%s]\n", DbgP );
	OutputDebugString( DbgB );

	if ( cDecomp < 0 ) {
		sprintf( DbgB, "DECOMPRESSION ERROR: cDecomp = %d!\n", cDecomp );
		OutputDebugString(DbgB);
	}
#endif

    return FALSE;
}




/**************************************************************************
 *
 * NextChar - Return next character from input stream
 *
 * Purpose:
 *  Returns next character from input stream, performing huffman decompression
 *  if enabled.
 *
 * Entry:
 *      fpHuffmanRoot   = pointer to root of huffman tree
 *      pfpTopic        = pointer to pointer to Topic
 *      pBitmask        = pointer to bit mask of current bit
 *
 * Exit:
 *      Returns character
 *      *pfpTopic and *pBitMask updated.
 *
 **************************************************************************
 *
 * Format of Huffman decode tree:
 *  The Huffman decode tree is a binary tree used to decode a bitstream into a
 *  character stream. The tree consists of nodes (internal nodes and leaves).
 *  Each node is represented by a word. If the high bit in the word is set then
 *  the node is a leaf. If the node is an internal node, then the value of the
 *  node is the index of the right branch in the binary tree. The left branch is
 *  the node following the current node (in memory). If the node is a leaf, then
 *  the low byte of the node is a character.
 *
 *    e.g.
 *       0: 0004                      0
 *       1: 0003                     / \
 *       2: 8020                    /   \
 *       3: 8065                   1     \------4
 *       4: 0006                  / \          / \
 *       5: 806C                 /   \        /   \
 *       6: 8040                2     3      5     6
 *                             ' '   'e'     'l'  '@'
 *
 * Using the Huffman decode tree:
 *  The huffman decode tree is used to decode a bitstream into a character
 *  string. The bitstream is used to traverse the decode tree. Whenever a zero
 *  is detected in the bit stream we take the right branch, when one is detected
 *  we take the left branch. When a leaf is reached in the tree, the value of
 *  the leaf (a character) is output, and the current node is set back to the
 *
 ********************************************************************/

BYTE
NextChar (
    void
    ) {

    BYTE    b;              // current source byte

#ifdef BIGDEBUG
	char DbgB[128];
	OutputDebugString("NextChar:\n");
#endif

    if (IsCompressed) {

        USHORT              HuffmanNode;            // curent node in the huffman tree
        USHORT UNALIGNED *pHuffmanNext;           // next node in the huffman tree

        //
        // Huffman decoding.
        // This first part of the decode loop performs the actual huffman decode. This
        // code is very speed critical. We walk the tree, as defined by the bit pattern
        // coming in, and exit this portion of the code when we reach a leaf which
        // contains the character that the bit pattern represented.
        //

        pHuffmanNext = (USHORT UNALIGNED *)pHuffmanRoot;
        HuffmanNode  = *pHuffmanNext;

		b = *(pCompTopic - 1);		 // get last byte read

		while (!(HuffmanNode & 0x8000)) {  // while not leaf

			BitMask >>= 1;

			if (!(BitMask)) {
                //
                //  Get new byte from input
                //
				b = *pCompTopic++;
                BitMask = 0x80;
#ifdef BIGDEBUG
				sprintf(DbgB, "\tb=%02x Mask=%02x Node=%04x", b, BitMask, HuffmanNode );
				OutputDebugString(DbgB);
#endif
			} else {
#ifdef BIGDEBUG
				sprintf(DbgB, "\tb=%02x Mask=%02x Node=%04x", b, BitMask, HuffmanNode );
				OutputDebugString(DbgB);
#endif
			}

			if (b & BitMask) {
                //
                //  one: take left branch
                //
                pHuffmanNext++;
            } else {
                //
                //  zero: take right branch
				//
				pHuffmanNext = (PUSHORT)((PBYTE)pHuffmanRoot + HuffmanNode);
#ifdef BIGDEBUG
				sprintf(DbgB, " <%04x+%02x=%04x (%04x)>", pHuffmanRoot, HuffmanNode,
							pHuffmanNext, *pHuffmanNext );
				OutputDebugString( DbgB );
#endif
			}

			HuffmanNode = *pHuffmanNext;

#ifdef BIGDEBUG
			sprintf(DbgB, " Next=%04x\n", HuffmanNode );
			OutputDebugString(DbgB);
#endif

		}

		b = (BYTE)HuffmanNode;	// character is low byte of leaf node

    } else {
		b = *pCompTopic++;	// not compressed, simply return byte
    }

#ifdef BIGDEBUG
	sprintf(DbgB, "\t---->%2x [%c]\n", b,b);
	OutputDebugString(DbgB);
#endif

    return  b;
}


/**************************************************************************
 *
 * HelpCmpSz - help system string comparison routine.
 * f near pascal HelpCmpSz (fpsz1, fpsz2)
 * uchar far *fpsz1*
 * uchar far *fpsz2*
 *
 * Purpose:
 *  Perform string comparisons for help system look-up.
 *  Default case of HelpCmp below.
 *
 * Entry:
 *  fpsz1        = Far pointer to string 1. (Usually the constant string
 *                 being "looked-up".
 *  fpsz2        = Far pointer to string 2. This is usually the string table
 *                 being searched.
 *
 * Exit:
 *  TRUE on match
 *
 ********************************************************************/
BOOL pascal
HelpCmpSz (
    PCHAR fpsz1,
    PCHAR fpsz2
    ){
	return HelpCmp(fpsz1, fpsz2, (USHORT)0xFFFF, TRUE, FALSE);	// fcase, fTerm
}


/**************************************************************************
 *
 * HelpCmp - help system string comparison routine.
 * f near pascal HelpCmp (fpsz1, fpsz2, cbCmp, fCase, fTerm)
 * uchar far *fpsz1
 * uchar far *fpsz2
 * ushort    cbCmp
 * f         fCase
 * f         fTerm
 *
 * Purpose:
 *  Perform string comparisons for help system look-up.
 *
 * Entry:
 *  fpsz1        = Far pointer to string 1. (Usually the constant string being
 *                 "looked-up"). NOTE THAT IF THIS STRING IS NULL, WE RETURN
 *                 TRUE!
 *  fpsz2        = Far pointer to string 2. This is usually the string table
 *                 being searched.
 *  cbCmp        = Max number of bytes to compare.
 *  fCase        = TRUE if search is to be case sensitive.
 *  fTerm        = TRUE if we allow special termination processing.
 *
 * Exit:
 *  TRUE on match
 *
 ********************************************************************/

BOOL pascal
HelpCmp (
    PCHAR   fpsz1,
    PCHAR   fpsz2,
    USHORT  cbCmp,
    BOOL  fCase,
    BOOL  fTerm
    ){

	register PBYTE p1 = (PBYTE)fpsz1;
	register PBYTE p2 = (PBYTE)fpsz2;

    while (cbCmp--) {

		if ((!*p1) && (!*p2)) {
            //
            //  Got a match
            //
            return TRUE;
        }

        if (!fCase) {
			if (toupper((char)*p1) != toupper((char)*p2)) {
                break;
			}
			p1++;
			p2++;
        } else {
			if (*p1++ != *p2++) {
                break;
            }
        }
    }

    if (!cbCmp) {
        return TRUE;
    }


    // At this point, we have terminated the comparison. Termination conditions
    // were:
    //
    //   character count exausted:   CX == zero. (Complete match, return TRUE)
    //   Null terminator found:      CX != zero, & Zero flag set. (Complete match,
    //                                       return TRUE)
    //   non-match found             CX != zero, & Zero flag clear.
    //
    // In the later case, if special termination processing is NOT selected, we
    // return FALSE, having found a mis-match.
    //
    // If special termination processing is TRUE, then if the mismatched character
    // from string 1 is a null, and the mismatched character from string 2 is any
    // whitespace or CR, we declare a match. (This is used in minascii processing).
    //

    if (fTerm) {
		p1--; p2--;
		if ((! *p1) &&
			((*p2 == '\n') || (*p2 == '\t') || (*p2 == ' '))) {
            return TRUE;
        }
    }
    return FALSE;
}


/*************************************************************************
 *
 * hfstrlen - far string length
 *
 * Purpose:
 *  return length of null terminated string.
 *
 * Entry:
 *  fpszSrc     = pointer to source
 *
 * Exit:
 *  returns length
 *
 *************************************************************************/
USHORT
hfstrlen (
    PCHAR fpszSrc
    ){
	return (USHORT)strlen(fpszSrc);
}


/*************************************************************************
 *
 * hfstrcpy - far string copy
 *
 * Purpose:
 *  copy strings
 *
 * Entry:
 *  fpszDst     = pointer to destination
 *  fpszSrc     = pointer to source
 *
 * Exit:
 *  pointer to terminating null in destination
 *
 *************************************************************************/
PCHAR
hfstrcpy (
    PCHAR fpszDst,
    PCHAR fpszSrc
    ) {
    return (PCHAR)strcpy(fpszDst, fpszSrc);
}



/*************************************************************************
 *
 * hfstrchr - search for character in far string
 *
 * Purpose:
 *  a near, pascal routine (for size/speed) to search for a character in
 *  a far string.
 *
 * Entry:
 *  fpsz        = far pointer to string
 *  c           = character to locate
 *
 * Exit:
 *  returns far pointer into string
 *
 * Exceptions:
 *  returns NULL on character not in string
 *
 *************************************************************************/
PCHAR
hfstrchr (
    PCHAR   fpsz,
    char    c
    ){
    return (PCHAR)strchr(fpsz, c);
}



/*************************************************************************
 *
 * hfmemzer - zero out memory area.
 *
 * Purpose:
 *  a near, pascal routine (for size/speed) to fill an area with zero
 *
 * Entry:
 *  fpb         = far pointer to buffer
 *  cb          = count of zeros to store
 *
 * Exit:
 *
 *************************************************************************/
void
hfmemzer (
    PVOID   fpb,
    ULONG   cb
    ) {
    memset(fpb, '\00', cb);
}




/*************************************************************************
 *
 * NctoFo - extract file offset from NC
 *
 * Purpose:
 *  Extracts the file offset for a minascii file, and returns it as a long.
 *
 * Entry:
 *  nc          = context number
 *
 * Exit:
 *  returns file offset
 *
 *************************************************************************/
ULONG
NctoFo (
    ULONG nc
    ) {
    nc  = nc & 0x0000FFFF;   
    nc *= 4;
    return nc;
}



/*************************************************************************
 *
 * combineNc - combine a minascii file offset and fdb handle into nc.
 *
 * Purpose:
 *  Combines a minascii file offset and fdb memory handle into an NC. If the
 *  file offset is 0xffffffff, we return zero.
 *
 * Entry:
 *  offset      = long file offset
 *  mh          = fdb mem handle
 *
 * Exit:
 *  returns NC (DX = mem handle, AX = filepos/4), or 0L if offset==FFFFFFFF
 *
 *************************************************************************/
nc  pascal
combineNc (
    ULONG  offset,
    mh  mh
    ){
    nc     ncRet = {0,0};
    if (offset = 0xFFFFFFFF) {
        return ncRet;
    }
    ncRet.mh = mh;
    ncRet.cn = offset/4;
    return ncRet;
}


/*************************************************************************
 *
 * toupr - convert char to upper case
 *
 * Purpose:
 *
 * Entry:
 *  chr          = character
 *
 * Exit:
 *  returns upper case character
 *
 *************************************************************************/
char
toupr (
    char chr
    ){
	return (char)toupper(chr);
}



/*************************************************************************
 *kwPtrBuild - Build table of pointers to keywords.
 *void pascal near kwPtrBuild(uchar far *fpTable, ushort tsize)
 *
 *Purpose:
 * Builds a table of pointers to the keyword strings in the passed string array.
 * The table is built in the first 4k of the passed buffer. The strings are
 * assummed to start immediately thereafter.
 *
 *Entry:
 * fpTable       - pointer to string table
 * tsize         - size, in bytes, of strings
 *
 *Exit:
 * none
 *
 *******************************************************************************/
void
kwPtrBuild (
    PVOID  fpTable,
    USHORT tsize
    ) {
    PBYTE fpStr  = (PBYTE)fpTable + 1024 * sizeof (PVOID);
    PBYTE *fpTbl = fpTable;
    while (tsize > 0) {
		UCHAR  sSize = (UCHAR)(*fpStr) + (UCHAR)1;
        *fpTbl++ = fpStr;
        tsize   -= sSize;
        fpStr   += sSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\help.c ===
/*** help.c - help library main
*
*   Copyright <C> 1988-1990, Microsoft Corporation
*
* Definitions:
*
*  Context Map:             Mapping  of  context  number  to  topic  number.
*                           Allows multiple contexts to be associated with a
*                           single   topic.  Syncronized  with  the  context
*                           string  table,  each  entry  contains  the topic
*                           number associated with the corresponding context
*                           string.
*
*  Context String:          String on which help can be "looked up".
*
*  Context String Table:    Table   of   all  valid  context  strings  in  a
*                           particular help file.
*
*  Local Context:           A  type  of  context  which bypasses the context
*                           string and context numbers. In cross references,
*                           encoded  as  a  cross  reference string of NULL,
*                           followed by a topic number ored with 0x8000.
*
*  nc:                      (Context   Number)   A   long   which   uniquely
*                           identifies  a  help  file and context string, or
*                           for  local  contexts,  the  helpfile  and  topic
*                           number. Formatted as:
*
*                               +----------------+----------------+
*                               | Fdb Mem Handle | context number |
*                               +----------------+----------------+
*
*                           Where the upper word is the memory handle of the
*                           allocated  fdb for the help file. The lower word
*                           is  the  either  the "true" context  number (see
*                           below)  if <= 0x7fff, or the actual topic number
*                           or'ed with 0x8000.
*
*  Topic:                   Actual help textual entry. May be compressed.
*
*  Topic Index:             Table  of file positions of all topics contained
*                           in  a  help  file.  Indexed by the topic number,
*                           returns  that  topics  physical  position in the
*                           file.
*
*  Topic Number:            Index  to  a particular topic. Topic numbers are
*                           zero based, and reflect the physical ordering of
*                           the topics in the file.
*
*  "True" context number:   is  the zero based index or string number in the
*                           <context  string  table>. I.E. the "n'th" string
*                           has context number "n".
*
* The progression from string to true context number to topic number to file
* position is:
*
*       1) Context String ==> "True" Context Number
*
*           The  string  is  searched for in the <context string table>, and
*           it's number becomes the "true" context number.
*
*       2) "True" Context Number ==> Topic Number
*
*           The  context number is an index into the <context map>, returing
*           the topic number associated with the context number.
*
*       3) Topic Number ==> File Position
*
*           The  topic number is used as an index into the Topic Index, from
*           which the physical file position is retrieved.
*
* Notes:
*  QuickPascal requires NO initialized data. In this case, CLEAR is defined,
*  and the HelpInit routine is included. We also play some pointer games to
*  simple variables, because the C compiler can generate CONST segment
*  entries for the SEG of various vars. (This enables it to load the segment
*  register directly, rather than by using SEG varname and another
*  register). Q/P cannot support this action by the compiler.
*
*  QuickHelp for OS/2 is reentrant. This code should remain reentrant up to
*  but not including allocating and deallocating fdbs.
*
* Revision History:
*
*       17-Aug-1990 ln  Don't blindly request 64k of an ascii file. Query
*                       for size first, then read. Allocations based on
*                       previous topic size requests may cause the OS to
*                       GPFault for an out of range read.
*       16-Jul-1990 ln  Searching for "filename!" where filename is a QH
*                       file, will now fail, rather than GP fault. Searching
*                       for "!" will now succeed.
*       08-Jun-1990 ln  Remove HelpLock usage in HelpNcCmp
*       13-Apr-1990 ln  Try to get HelpSzContext to return strings in more
*                       cases where it can.
*       12-Mar-1990 ln  Rename CloseFile -> HelpCloseFile
*       08-Oct-1989 ln  Changes to improve the previous change to work (allow
*                       decompression) more often in low memory bases.
*                       Deallocate table in OpenCore to reduce fragmentation
*                       in non-moveable memory systems.
*       19-May-1989 ln  Correct bug in decompressing, where we would not
*                       decompress if the tables didn;t exist.
*       12-Apr-1989 ln  Ensure that we handle Locks failing correctly. Also
*                       remove TossPortion usage. Unlock handles directly.
*       10-Mar-1989 ln  Change MapTopicToContext to look forward. Changed
*                       HelpNc to look begining at passed context string.
*       17-Jan-1989 ln  Correct creation of basename in HelpOpen to account
*                       for environment syntax.
*       09-Dec-1988 ln  Add HelpNcUniq
*       25-Oct-1988 ln  Added minascii support to HelpNcPrev. Correct
*                       minascii bug in HelpSzContext.
*       14-Sep-1988 ln  Improve doc. Remove ambiguity in MapContextToTopic
*                       return value. Improve error checking in various
*                       places.
*       01-Sep-1988 ln  Check ReadHelpFile return value in LoadPortion
*       12-Aug-1988 ln  Add check for memory discarded in alloc durring
*                       HelpDecomp.
*       08-Aug-1988 ln  Ensure HelpClose closes ALL files. (Off by one error
*                       in loop).
*       14-Apr-1988 ln  Modified to conform to QC (CW?) restriction that
*                       prohibits any segments from being locked when an
*                       allocation is performed.
*   []  15-Dec-1987 ln  Created, for design.
*
*************************************************************************/

#include <assert.h>                     /* debugging assertions         */
#include <io.h>                         /* I/O function declarations    */
#include <stdlib.h>                     /* standard library             */

#include <stdio.h>                      /* standard I/O definitions     */

#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include "help.h"                       /* global (help & user) decl    */
#include "helpfile.h"                   /* help file format definition  */
#include "helpsys.h"                    /* internal (help sys only) decl*/

#define MASIZE          512             /* size of ma input buffer      */
#define MAOVER          64              /* size of ma search overlap    */

#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))
#define SETERROR(x,y)   { (x).mh = 0L; (x).cn = y; }

/*************************************************************************
**
** Forward definitions
*/
void        pascal near CloseShrink(nc, f);
f           pascal near LoadFdb (mh, fdb far *);
mh          pascal near LoadPortion (int, mh);
ushort      pascal near MapContexttoTopic (nc, fdb far *);
nc      pascal near MapTopictoContext(ushort, fdb far *, int);
nc          pascal near NextPrev(nc,int);
nc          pascal near OpenCore(FILE *, ulong, uchar far *, struct helpheader *, fdb far *);
f           pascal near PutFdb (mh, fdb far *);
f           pascal near SizePos (nc, ushort *,ulong *);

ushort      pascal near decomp  (uchar far *, uchar far *, uchar far *, uchar far *);
char far *  pascal near hfmemzer(void far *, ushort);
char far *  pascal near hfstrchr(char far *, char);
char far *  pascal near hfstrcpy(char far *, char far *);
ushort      pascal near hfstrlen(char far *);
f           pascal far  HelpCmp (uchar far *, uchar far *, ushort, f, f);
f           pascal near HelpCmpSz (uchar far *, uchar far *);
void        pascal near kwPtrBuild(uchar far *, ushort);

#if ASCII
long        pascal near maLocate (fdb far *, uchar far *, ulong,
                f (pascal far *)(uchar far *, uchar far *, ushort, f, f));

nc          pascal near combineNc (ulong, mh);
ulong       pascal near NctoFo (ulong);
#endif

/*************************************************************************
**
** External Global data
** BEWARE. The effects of global data on reentrancy should be VERY carefully
** considered.
**
*************************************************************************/
extern  mh      tbmhFdb[MAXFILES+1];
extern  char    szNil[1];
extern  ushort  cBack;

#ifdef CLEAR
/*************************************************************************
**
** HelpInit - One-time initialization
**
** Purpose:
**  Performs one-time initialization. Right now that's a zero fill of static
**  memory for those environments which don't support pre-inited static
**  memory.
**
** Entry:
**  none
**
** Exit:
**  none
**
*/
void far pascal LOADDS HelpInit () {

hfmemzer (tbmhFdb, sizeof(tbmhFdb));    /* zero entire fdb handle table */
hfmemzer (szNil,  sizeof(szNil));       /* zero null string             */
hfmemzer (&cBack,  sizeof(cBack));      /* zero back trace count        */

/* end HelpInit */}
#endif

/*************************************************************************
**
** HelpOpen - Open help file & return help handle.
**
** Purpose:
**  Given the file basename, locate the associated help file on the path, and
**  open it, initializing internal data structures as appropriate.
**
** Entry:
**  fpszName    - base filename to be openned.
**
** Exit:
**  nc initial context for openned file.
**
** Exceptions:
**  Returns error code on failure to open for any reason.
**
*/
nc far pascal LOADDS HelpOpen (
char far *fpszName
) {
FILE    *fhT;                            /* temp file handle             */
fdb     fdbLocal;                       /* local copy of fdb to use     */
uchar far *fpszBase;                    /* base filename                */
void far *fpT;
struct helpheader hdrLocal;             /* for use by opencore          */
nc      ncRet           = {0,0};        /* first context                */
mh      *ptbmhFdb;                      /* pointer into mh table        */

/*
** create basename by removing possible env variable, drive, and scanning
** for last path seperator
*/
fpszBase = fpszName;
if (fpT = hfstrchr(fpszBase,':'))
    fpszBase = (uchar far *)fpT+1;
while (fpT = hfstrchr(fpszBase,'\\'))
    fpszBase = (uchar far *)fpT+1;
/*
** Scan FDB's for an open file of the same base name. If we encounter the name,
** in either the true filename, or file header, just return that file's initial
** context. Otherwise fall below to try and open it.
*/
for (ptbmhFdb=&tbmhFdb[1]; ptbmhFdb<=&tbmhFdb[MAXFILES]; ptbmhFdb++) {
    if (LoadFdb (*ptbmhFdb,&fdbLocal)) {
        if (HelpCmpSz(fpszBase,fdbLocal.fname) ||
            HelpCmpSz(fpszBase,fdbLocal.hdr.fname))
            ncRet = fdbLocal.ncInit;
        if (ncRet.mh && ncRet.cn)
            return ncRet;
        }
    }
/*
** Open file. If we can, then call the core open routine to open the file (and
** any anything appended to it).
**
** Warning: the app may callback HelpClose at this point.
*/
if (fhT = OpenFileOnPath(fpszName,FALSE)) {
    ncRet = OpenCore (fhT,0L,fpszBase,&hdrLocal,&fdbLocal);
    if (ISERROR(ncRet))
        HelpCloseFile (fhT);
    return ncRet;
    }

SETERROR(ncRet, HELPERR_FNF);
return ncRet;
// rjsa return HELPERR_FNF;

/* end HelpOpen*/}

/*************************************************************************
**
** OpenCore - Recursive core of HelpOpen
**
** Purpose:
**  Given the open file handle, initialize internal data structures as
**  appropriate. Attempt to open any file that is appended.
**
** Entry:
**  fhT         - Open file handle
**  offset      - Offset from start of file of help file to open
**  fpszBase    - pointer to base filename
**
** Exit:
**  initial context, or NULL on failure.
**
** Exceptions:
**  Returns NULL on failure to open for any reason.
**
*/
nc pascal near OpenCore (
FILE *  fhHelp,
ulong   offset,
uchar far *fpszBase,                    /* base filename                */
struct helpheader *phdrLocal,
fdb far *pfdbLocal                      /* pointer to current FDB       */
) {
//void far *fpT;
int     ihFree;                         /* handle for free fdb (& index)*/
mh      mhCur;                          /* current memory handle        */
nc      ncFirst         = {0,0};        /* first context                */
nc      ncInit;                         /* first context                */
mh      *pmhT;                          /* pointer into mh table        */

/*
** Read in helpfile header
*/
if (ReadHelpFile(fhHelp,
    offset,
    (char far *)phdrLocal,
    (ushort)sizeof(struct helpheader))) {
/*
** search for available fdb
*/
    for (ihFree = MAXFILES, pmhT = &tbmhFdb[MAXFILES];
         ihFree && *pmhT;
         ihFree--, pmhT--);
/*
** if an offset is present, and this is NOT a compressed file, or there is no
** available fdb, ignore the operation.
*/
    if (   offset
        && (phdrLocal->wMagic != wMagicHELP)
        && (phdrLocal->wMagic != wMagicHELPOld)
        ) {
        SETERROR(ncInit, HELPERR_BADAPPEND);
        return ncInit;
        // rjsa return HELPERR_BADAPPEND;
    }
    if (ihFree == 0) {
        SETERROR(ncInit, HELPERR_LIMIT);
        return ncInit;
        // rjsa return HELPERR_LIMIT;
    }
/*
** allocate fdb. Again, if we can't, skip it all and return NULL.
*/
    if (mhCur = *pmhT = HelpAlloc((ushort)sizeof(fdb))) {
/*
** Fill in helpfile header & appropriate fdb fields
*/
        hfmemzer(pfdbLocal,sizeof(fdb));        /* zero entire fdb      */
        pfdbLocal->fhHelp = fhHelp;             /* file handle          */
        ncFirst.mh = pfdbLocal->ncInit.mh = mhCur;
        ncFirst.cn = pfdbLocal->ncInit.cn  = 0L;
        // rjsa ncFirst = pfdbLocal->ncInit = ((long)mhCur) << 16; /* initial context      */
        pfdbLocal->foff = offset;                /* appended offset      */
        hfstrcpy(pfdbLocal->fname,fpszBase);     /* include base filename*/
/*
** if this is a compressed file (signified by the first two bytes of the header
** we read in above), then note the file type in the fdb. We unlock the fdb, as
** MapTopicToContext and the recursion might cause memory allocation. We get a
** context number for the first topic, and recurse and attempt to open any
** appended file.
*/
        if (   (phdrLocal->wMagic == wMagicHELPOld)
            || (phdrLocal->wMagic == wMagicHELP)
           ) {
            if ((phdrLocal->wMagic == wMagicHELP)
                && (phdrLocal->wVersion > wHelpVers)) {
                SETERROR(ncInit, HELPERR_BADVERS);
                return ncInit;
                // rjsa return HELPERR_BADVERS;
            }
            pfdbLocal->hdr = *phdrLocal;
            pfdbLocal->ftype = FTCOMPRESSED | FTFORMATTED;
            if (PutFdb (mhCur, pfdbLocal)) {
        ncFirst = MapTopictoContext(0,pfdbLocal,0);

                // We free the context map (the only thing loaded by the
                // MapTopictoContext) in order to reduce fragmentation in
                // non-moveable memory based systems.
                //
                HelpDealloc (pfdbLocal->rgmhSections[HS_CONTEXTMAP]);
                pfdbLocal->rgmhSections[HS_CONTEXTMAP] = 0;

                ncInit = OpenCore(fhHelp,pfdbLocal->hdr.tbPos[HS_NEXT]+offset,szNil,phdrLocal,pfdbLocal);
                if (LoadFdb (mhCur, pfdbLocal)) {
                        //if (ncInit.cn > HELPERR_MAX) {
                        if ( !(ISERROR(ncInit)) ) {
                            pfdbLocal->ncLink = ncInit;
                        } else {
                            pfdbLocal->ncLink.mh = (mh)0;
                            pfdbLocal->ncLink.cn = 0L;
                        }
                        // rjsa pfdbLocal->ncLink = ncInit > HELPERR_MAX ? ncInit : 0;
                        pfdbLocal->ncInit = ncFirst;
                }
            }
        }
#if ASCII
/*
** In the case of a minascii formatted file (signified by the first two bytes
** of the header being ">>") we just set up the filetype and "applications
** specific character". The default "ncFirst" is the context for the first
** topic.
*/
        else if (phdrLocal->wMagic == 0x3e3e) { /* minascii formatted?  */
            pfdbLocal->ftype = FTFORMATTED;
            pfdbLocal->hdr.appChar = '>';       /* ignore lines with this*/
            }
#endif
        else if ((phdrLocal->wMagic & 0x8080) == 0) { /* ascii unformatted? */
            pfdbLocal->ftype = 0;
            pfdbLocal->hdr.appChar = 0xff;      /* ignore lines with this*/
            }
        else {
            SETERROR(ncInit, HELPERR_NOTHELP);
            return ncInit;
            // rjsa return HELPERR_NOTHELP;
        }

        if (!PutFdb (mhCur, pfdbLocal)) {
            ncFirst.mh = (mh)0;
            ncFirst.cn = 0L;
        }
    }
    else {
        SETERROR(ncFirst, HELPERR_MEMORY);
        // rjsa ncFirst = HELPERR_MEMORY;       /* error reading file           */
    }
}
else {
    SETERROR(ncFirst, HELPERR_READ);
    // rjsa ncFirst = HELPERR_READ;             /* error reading file           */
}

return ncFirst;                         /* return valid context         */

/* end OpenCore */}


/*************************************************************************
**
** HelpClose - Close Help file
**
** Purpose:
**  Close a help file, deallocate all memory associated with it, and free the
**  handle.
**
** Entry:
**  ncClose     - Context for file to be closed. If zero, close all.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void far pascal LOADDS HelpClose (
nc      ncClose
) {
CloseShrink(ncClose,TRUE);              /* close file(s)                */
/* end HelpClose */}

/*************************************************************************
**
** HelpShrink - Release all dynamic memory
**
** Purpose:
**  A call to this routines causes the help system to release all dynamic
**  memory it may have in use.
**
** Entry:
**  None.
**
** Exit:
**  None.
**
** Exceptions:
**  None.
**
*/
void far pascal LOADDS HelpShrink(void) {
    nc ncTmp = {0,0};
CloseShrink(ncTmp,0);
// rjsa CloseShrink(0,0);
/* end HelpShrink */}

/*************************************************************************
**
** CloseShrink - Deallocate memory and possibly Close Help file
**
** Purpose:
**  Deallocate all memory associated with a help file, and possibly close free
**  it.
**
** Entry:
**  ncClose     - Context for file. If zero, do all.
**  fClose      - TRUE if a close operation.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void pascal near CloseShrink (
nc      ncClose,
f       fClose
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
int     i;
mh      mhClose;                        /* fdb mem hdl to file to close */
mh      *pmhFdb;                        /* pointer to FDB's table entry */


mhClose = ncClose.mh;                    /* get index */
// rjsa mhClose = (mh)HIGH(ncClose);            /* get index                    */
for (pmhFdb = &tbmhFdb[0];              /* for each possible entry      */
     pmhFdb <= &tbmhFdb[MAXFILES];
     pmhFdb++
     ) {
    if ((mhClose == 0)                  /* if all selected              */
        || (mhClose == *pmhFdb)) {      /* or this one selected         */

        if (LoadFdb (*pmhFdb, &fdbLocal)) {     /* if open file         */
/*
 * Recurse to close/shrink any appended files
 */
            if ((fdbLocal.ncLink.mh || fdbLocal.ncLink.cn) && mhClose)
                CloseShrink (fdbLocal.ncLink, fClose);

            for (i=HS_count-2; i>=0; i--)       /* for dyn mem handles  */
                HelpDealloc(fdbLocal.rgmhSections[i]);  /* dealloc      */
            hfmemzer(fdbLocal.rgmhSections,sizeof(fdbLocal.rgmhSections));

            if (fClose) {
                HelpCloseFile(fdbLocal.fhHelp); /* close file           */
                HelpDealloc(*pmhFdb);           /* deallocate fdb       */
                *pmhFdb = 0;
                }
            else
                PutFdb (*pmhFdb, &fdbLocal);    /* update FDB           */
            }
        }
    }
/* end CloseShrink */}

/*** HelpNcCmp - Look up context string, provide comparison routine
*
*  Given an ascii string, determine the context number of that string. Uses
*  user-supplied comparison routine.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*  lpfnCmp      - far pointer to comparison routine to use.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNcCmp (
char far *fpszContext,
nc      ncInitial,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
f       fFound          = FALSE;        // TRUE -> found
f       fOpened         = FALSE;        // TRUE -> file was openned here
fdb     fdbLocal;                       // pointer to current FDB
char far *fpszT;                        // temp far pointer
long     i;
long     iStart;                         // nc to start looking at
mh      mhCur;                          // memory handle locked
nc      ncRet           = {0,0};        // The return value
char far *fpszContexts;                 // pointer to context strings


// if the context string includes a "filename!", then open that as a help
// file, and point to the context string which may follow.
//
if ((fpszT = hfstrchr(fpszContext,'!')) && (fpszT != fpszContext)) {
    *fpszT = 0;
    ncInitial = HelpOpen(fpszContext);
    *fpszT++ = '!';
    fpszContext = fpszT;
    fOpened = TRUE;
}

// if helpfile was not openned, just return the error
//
if (ISERROR(ncInitial)) {
    ncInitial.mh = (mh)0;
    ncInitial.cn = 0L;
    return ncInitial;
}

// For compressed files we scan the context strings in the file 
// (this turns out not to be that speed critical in
// comparision with decompression, so I haven't bothered), to get the
// context number.
//
// If not found, and there IS a linked (appended) file, we recurse to search
// that file as well.
//
// The context number for compressed files is just the zero based string
// number, plus the number of predefined contexts, with the fdb memory
// handle in the upper word.
//
if (LoadFdb (ncInitial.mh, &fdbLocal)) {
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // If not a local context look up, get the context strings, and
        // search
        //
        if (*fpszContext) {
            mhCur = LoadPortion (HS_CONTEXTSTRINGS, ncInitial.mh);
            if (   (mhCur == (mh)0)
                || (mhCur == (mh)(-1))
                || (!(fpszContexts = HelpLock(mhCur)))
               ) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
                return ncRet;
            }
            i=0;

            // iStart allows us to begin searching from the context string
            // passed, as opposed to from the begining each time. This
            // allows the application to "carry on" a search from othe last
            // place we found a match. This is usefull for multiple
            // duplicate context resolution, as well as inexact matching.
            //
            iStart = ncInitial.cn;
            if (iStart & 0x8000)
                iStart = 0;
            else
                iStart--;                   /* table index is 0 based */

            do {
                if (i >= iStart) {
                    fFound = lpfnCmp (  fpszContext
                                      , fpszContexts
                                      , 0xffff
                                      , (f)(fdbLocal.hdr.wFlags & wfCase)
                                      , (f)FALSE);
                }
                while (*fpszContexts++);    /* point to next string         */
                i++;
            }
                while ((i < (int)fdbLocal.hdr.cContexts) && !fFound);
            HelpUnlock (mhCur);

            if (fFound) {                    /* if a match found             */
                ncRet.mh = ncInitial.mh;
                ncRet.cn = i + fdbLocal.hdr.cPreDef;
                // rjsa ncRet = (i+fdbLocal.hdr.cPreDef)            /* string #     */
                //              | HIGHONLY(ncInitial);              /* & fdb handle */
            }
            else {
                ncInitial.mh = (mh)0;
                ncInitial.cn = 0L;
                ncRet = HelpNcCmp (fpszContext,fdbLocal.ncLink, lpfnCmp);
            }
        }
        else if (!fOpened) {
            ncRet.mh = ncInitial.mh;
            ncRet.cn = *(UNALIGNED ushort far *)(fpszContext + 1);
            // rjsa ncRet = *(ushort far *)(fpszContext + 1)        /* word following*/
            //                 | HIGHONLY(ncInitial);              /* & fdb handle */
        }
    }
#if ASCII
/*
** For minimally formatted ascii files, we sequentially scan the file itself
** for context string definitions until we find the string we care about.
**
** The context number for minascii files is the the byte position/4 of the
** beginning of the associated topic, with the fdb memory handle in the upper
** word.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        if (*fpszContext) {
            ncRet.cn = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            if (ncRet.cn == -1L) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
            } else {
                ncRet = combineNc(ncRet.cn, fdbLocal.ncInit.mh);
            }
            // rjsa ncRet = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            //      ncRet = (ncRet == -1L)
            //              ? 0
            //              : combineNc(ncRet,HIGH(fdbLocal.ncInit));
        }
    }
/*
** for unformatted ascii files, there must have been NO context string to be
** searched for. In that case, the context number is always 1, plus the fdb
** mem handle.
*/
    else if (*fpszContext == 0) {        /* if null context string       */
        ncRet.mh = ncInitial.mh;
        ncRet.cn = 1L;
        // rjsa ncRet = HIGHONLY(ncInitial) + 1;
    }
#endif
}

return ncRet;

/* end HelpNcCmp */}

/*** HelpNc - Look up context string
*
*  Given an ascii string, determine the context number of that string.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNc (
char far *fpszContext,
nc      ncInitial
) {
return HelpNcCmp (fpszContext, ncInitial, HelpCmp);
/* end HelpNc */}


/*************************************************************************
**
** HelpNcCb - Return count of bytes in compressed topic
**
** Purpose:
**  Returns the size in bytes of the compressed topic. Provided for
**  applications to determine how big a buffer to allocate.
**
** Entry:
**  ncCur       - Context number to return info on.
**
** Exit:
**  Count of bytes in the compressed topic
**
** Exceptions:
**  Returns 0 on error.
**
*/
ushort far pascal LOADDS HelpNcCb (
nc      ncCur
) {
ulong   position;
ushort  size;

return SizePos(ncCur,&size,&position) ? size+(ushort)4 : (ushort)0;

/* end HelpNcCb */}

/******************************************************************************
**
** HelpLook - Return compressed topic text
**
** Purpose:
**  Places the compressed topic text referenced by a passed context number into
**  a user supplied buffer.
**
** Entry:
**  ncCur       - Context number for which to return text
**  pbDest      - Pointer to buffer in which to place the result.
**
** Exit:
**  Count of bytes in >uncompressed< topic. This is encoded based on file type.
**
** Exceptions:
**  Returns NULL on any error
**
*/
ushort far pascal LOADDS HelpLook (
nc      ncCur,
PB      pbDest
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpszDest;
int     i;
ulong   position        = 0;
ushort  size            = 0;

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb down         */
/*
** for both kinds of formatted files, we determine the position of the topic,
** and read it in.
*/
    if (fdbLocal.ftype) {
        if (SizePos (ncCur,&size,&position)) {
                if (fpszDest = (char far *)PBLOCK(pbDest)) {

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "HELP: Reading Topic for Context %d at %lX, size %d\n", ncCur.cn, position + fdbLocal.foff, size );
                        OutputDebugString(DbgBuf);
                }
#endif

                size = (ushort)ReadHelpFile(fdbLocal.fhHelp
                                    ,position + fdbLocal.foff
                                    ,fpszDest
                                        ,size);

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "      Read %d bytes to address %lX\n", size, fpszDest );
                        OutputDebugString(DbgBuf);
                }
#endif
/*
** for compressed files, if the read was sucessfull, we then return the
** uncompressed size which is the first word of the topic.
*/
#if ASCII
                if (fdbLocal.ftype & FTCOMPRESSED) {
#endif
                    if (size)
                        size = *(ushort far *)fpszDest+(ushort)1;
#if ASCII
                    }
                else {
/*
** for minascii files, We also set up for the terminating NULL by scanning for
** the ">>" which begins the next topic, adjusting the size as well.
*/
                    size -= 4;
                    for (i=4; i; i--)
                        if (fpszDest[++size] == '>') break;
                    fpszDest[size++] = 0;
                    }
#endif
                }
            }
        }
#if ASCII
    else {                              /* unformatted ascii            */
/*
** for unformatted ascii, we just read in (first 64k of) the file.
*/
        if (fpszDest = PBLOCK (pbDest)) {
            if (SizePos (ncCur,&size,&position)) {
                size = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,fpszDest,size);
                fpszDest[size++] = 0;           /* terminate ascii text         */
                }
            }
        }
#endif
    PBUNLOCK (pbDest);
    }
if (size) size += sizeof(topichdr);     /* adjust for prepended topichdr*/
return size;
/* end HelpLook */}

/******************************************************************************
**
** HelpDecomp - Decompress Topic Text
**
** Purpose:
**  Fully decompress topic text. Decompresses based on current file, from one
**  buffer to another.
**
** Entry:
**  pbTopic     - Pointer to compressed topic text
**  pbDest      - Pointer to destination buffer
**
** Exit:
**  FALSE on successful completion
**
** Exceptions:
**  Returns TRUE on any error.
**
*/
f far pascal LOADDS HelpDecomp (
PB      pbTopic,
PB      pbDest,
nc      ncContext
) {
fdb     fdbLocal;                       // pointer to current FDB
uchar far *fpszDest;                    // pointer to destination
uchar far *fpTopic;                     // pointer to locked topic
f       fRv = TRUE;                     // return Value
mh      mhFdb;                          // handle to the fdb
mh      mhHuff;
mh      mhKey;

mhFdb = ncContext.mh;
if (LoadFdb (mhFdb, &fdbLocal)) {       /* lock fdb down        */
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // This funky sequence of code attempts to ensure that both the
        // huffman and keyword decompression tables are loaded simultaneously
        // since we cannot decompress without both.
        //
        // We do things three times to cover the following cases:
        //
        //  1)  huffman loaded ok
        //      keyword loaded ok
        //      huffman already loaded
        //
        //  2)  huffman loaded ok
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (HelpShrink freed enough for both)
        //
        //  3)  huffman loaded ok after HelpShrink
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (memory fragmentation allowed it)
        //
        // The other cases, where either the load fails immediatly after
        // any HelpShrink call, are the cases we cannot handle.
        //
        // Since handles can change due to the reallocation that can ocurr
        // in the HelpShrink-reload sequence, we simply do the three
        // loads, and then ensure that all the handles match what's in the
        // fdb. If they don't, we fail.
        //
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);
        mhKey  = LoadPortion (HS_KEYPHRASE,mhFdb);
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);

        if (   LoadFdb (mhFdb, &fdbLocal)
            && (mhKey  == fdbLocal.rgmhSections[HS_KEYPHRASE])
            && (mhHuff == fdbLocal.rgmhSections[HS_HUFFTREE])) {

            char far *fpHuff;
            char far *fpKey;

            // At this point we lock EVERYTHING and ensure that we have
            // valid pointers to it all. (Some swapped memory systems can
            // fail at this point, so we need to be sensitive).
            //
            fpHuff   = HelpLock (mhHuff);
            fpKey    = HelpLock (mhKey);
            fpTopic  = PBLOCK (pbTopic);
            fpszDest = PBLOCK (pbDest);

            if (   fpTopic
                && fpszDest
                && (fpHuff || (mhHuff == 0))
                && (fpKey  || (mhKey  == 0))
               ) {
                decomp (fpHuff, fpKey, fpTopic, fpszDest+sizeof(topichdr));
                fRv = FALSE;
                }
            }

        // Unlock the handles, if they were valid.
        //
        if (mhKey != (mh)(-1))
            HelpUnlock (mhKey);
        if (mhHuff != (mh)(-1))
            HelpUnlock (mhHuff);
        }
    else {
        fpszDest = PBLOCK (pbDest);
#if ASCII
/*
** ascii, just copy
*/
        fpTopic = PBLOCK(pbTopic);
        if (fpTopic && fpszDest) {
            hfstrcpy(fpszDest+sizeof(topichdr),fpTopic);
#else
            {
#endif
            fRv = FALSE;
            }
        }
    if (!fRv) {
        ((topichdr far *)fpszDest)->ftype   = fdbLocal.ftype;
        ((topichdr far *)fpszDest)->appChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->linChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->lnCur   = 1;
        ((topichdr far *)fpszDest)->lnOff   = sizeof(topichdr);
        }
    PBUNLOCK (pbTopic);
    PBUNLOCK (pbDest);
    }
return fRv;
/* end HelpDecomp */}

/******************************************************************************
**
** HelpNcNext - Return next context number
**
** Purpose:
**  Returns the context number corresponding to a physical "next" in the help
**  file.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcNext (
nc      ncCur
) {
return NextPrev(ncCur,1);       /* get next         */
/* end HelpNcNext */}

/******************************************************************************
**
** HelpNcPrev - Return phyiscally previous context
**
** Purpose:
**  Returns the context number corresponding to the physically previous topic.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcPrev (
nc      ncCur
) {
return NextPrev(ncCur,-1);      /* get previous         */
/* end HelpNcPrev */}

/******************************************************************************
**
** HelpNcUniq - Return nc guaranteed unique for a given topic
**
** Purpose:
**  Maps a context number to a local context number. This is provided such
**  that all context numbers which map to the same topic can be transformed
**  into the same nc which maps to that topic. The information on the
**  context string originally used is lost.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcUniq (
nc      ncCur
) {
fdb     fdbLocal;                       /* pointer to current FDB       */

if (LoadFdb (ncCur.mh, &fdbLocal))
    if (fdbLocal.ftype & FTCOMPRESSED) {
        nc ncTmp;

        ncTmp.mh = fdbLocal.ncInit.mh;
        ncTmp.cn = MapContexttoTopic(ncCur, &fdbLocal);
        ncTmp.cn |= 0x8000;

        ncCur = ncTmp;

        // rjsa return   MapContexttoTopic (ncCur,&fdbLocal)
        //               | (fdbLocal.ncInit & 0xffff0000)
        //               | 0x8000;

    }
return ncCur;
/* end HelpNcUniq */}

/******************************************************************************
**
** NextPrev - Return phyiscally next or previous context
**
** Purpose:
**  Returns the context number corresponding to the physically next or previous
**  topic.
**
** Entry:
**  ncCur       = Current Context
**  fNext       = 1 for next, -1 for previous.
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc pascal near NextPrev (
    nc  ncCur,
    int fNext
    ) {

    fdb fdbLocal;           /* pointer to current FDB   */
    REGISTER nc ncNext          = {0,0};

    if (LoadFdb (ncCur.mh, &fdbLocal)) {

        //
        // For a compressed file the next/previous physical is computed by taking the
        // context number, mapping it to its corresponding topic number, incrementing
        // or decrementing the topic number (remember, topic numbers are in physical
        // order), and then mapping that back to a context number.
        //
        // When nexting, we also support nexting into any appended file.
        //
        if (fdbLocal.ftype & FTCOMPRESSED) {
            unsigned short cn;

            cn = (ushort)(((ncCur.cn & 0x8000)
                  ? ncCur.cn & 0x7ffff
                  : MapContexttoTopic(ncCur, &fdbLocal))
                  + (ushort)fNext);

            ncNext = MapTopictoContext(cn, (fdb far *)&fdbLocal, fNext);

            // rjsa ncNext = MapTopictoContext((ushort)(((ncCur & 0x8000)
            //                             ? ncCur & 0x7fff
            //                             : MapContexttoTopic (ncCur,&fdbLocal))
            //                            + fNext)
            //                           ,(fdb far *)&fdbLocal);

            //
            // if we could not come up with a next, try to find a next using "local"
            // context numbers. Map the context number to a topic number, and if that is
            // not out of range, return it as a context.
            //
            if (!(ncNext.cn)) {

                // rjsa if ((ncNext = MapContexttoTopic (ncCur,&fdbLocal)) == 0xffff)
                //    ncNext = 0;
                ncNext.cn = MapContexttoTopic(ncCur, &fdbLocal);

                if (ncNext.cn == 0xffff) {

                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;

                } else {

                    ncNext.cn += fNext;

                    if (ncNext.cn >= fdbLocal.hdr.cTopics) {

                        ncNext.mh = (mh)0;
                        ncNext.cn = 0L;

                    } else {

                        // rjsa ncNext |= (fdbLocal.ncInit & 0xffff0000) | 0x8000;
                        ncNext.mh = fdbLocal.ncInit.mh;
                        ncNext.cn = 0x8000;
                    }
                }
            }

            if (!(ncNext.cn & 0x7fff) && (fNext>0)) {
                ncNext = fdbLocal.ncLink;
            }
        }

#if ASCII

            //
            //  minascii files:
            //  next'ing: we just sequentially search the file for the first context to
            //  come along after that pointed to by our current context number.
            //
          else if (fdbLocal.ftype & FTFORMATTED) {

            if (fNext > 0) {

                ncNext.cn = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)+4, HelpCmp);
                if (ncNext.cn == -1L) {
                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;
                } else {
                    ncNext = combineNc(ncNext.cn, ncCur.mh);
                }
                // rjsa ncNext = (ncNext == -1L)
                //         ? 0
                //         : combineNc(ncNext,HIGH(ncCur));

            }  else {

                nc  ncTemp;

                //
                //  prev'ing: start at the begining of the file, looking for the last context
                //  which is less than the current one.
                //

                ncNext = ncTemp = fdbLocal.ncInit;
                while (NctoFo(ncTemp.cn) < NctoFo(ncCur.cn)) {
                    ncNext = ncTemp;
                    ncTemp.cn = maLocate(&fdbLocal,szNil,NctoFo(ncTemp.cn)+4, HelpCmp);

                    if (ncTemp.cn == -1L) {
                        ncTemp.mh = (mh)0;
                        ncTemp.cn = 0L;
                    } else {
                        ncTemp = combineNc(ncTemp.cn,fdbLocal.ncInit.mh);
                    }
                    // rjsa ncTemp = (ncTemp == -1L)
                    //         ? 0
                    //         : combineNc(ncTemp,HIGH(fdbLocal.ncInit));
                }
            }
        }
#endif
    }
    return ncNext;
}

/*************************************************************************
**
** HelpSzContext - Return string mapping to context number
**
** Purpose:
**  Construct a string, which when looked-up, will return the passed context
**  number.
**
** Entry:
**  pBuf        = place to put the string
**  ncCur       = The context number desired
**
** Exit:
**  True on sucess.
**
*/
f pascal far LOADDS HelpSzContext (
uchar far *pBuf,
nc      ncCur
) {
f       fRet            = FALSE;        /* return value                 */
ulong   i;
fdb     fdbLocal;                       /* pointer to current FDB       */
mh      mhCur;                          /* handle we're dealing with    */
char far *fpszContexts;                 /* pointer to context strings   */

*pBuf = 0;
if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* lock fdb down        */
/*
** Everybody starts with a filename
*/
    if (*fdbLocal.hdr.fname)
        pBuf = hfstrcpy(pBuf,fdbLocal.hdr.fname);
    else
        pBuf = hfstrcpy(pBuf,fdbLocal.fname);
    *(ushort far *)pBuf = '!';                  /* includes null term   */
    pBuf++;
    fRet = TRUE;

    // if we've been given a local context number, see if we can synthesize
    // a context number from which we might get a string. If we can't get
    // one, then return just the filename.
    //
    if ((i = ncCur.cn) & 0x8000)  {           /* context #            */
        ncCur = MapTopictoContext ((ushort)(ncCur.cn & 0x7fff),&fdbLocal,0);
        if ((i = ncCur.cn) & 0x8000)          /* context #            */
            return fRet;
        }
/*
** For compressed files (signified by being able to load context strings) we
** just walk the context strings looking for string number "ncCur". Once found,
** the returned string is just the concatenated filename, "!" and context
** string.
*/
    mhCur = LoadPortion(HS_CONTEXTSTRINGS, ncCur.mh);
    if (mhCur && (mhCur != (mh)(-1)) && (fpszContexts = HelpLock(mhCur))) {
        if (i && (i <= fdbLocal.hdr.cContexts)) {
            while (--i)
                while (*fpszContexts++);/* point to next string         */
            hfstrcpy(pBuf,fpszContexts);/* copy over                    */
            }
        HelpUnlock (mhCur);
        }
    else if (fdbLocal.ftype & FTCOMPRESSED)
        return FALSE;
#if ASCII
/*
** for min ascii files, we search for the topic, and copy over the context
** string directly from the file.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        long fpos;

        if ((fpos = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)-1,HelpCmp)) != -1L) {
            fpos = ReadHelpFile(fdbLocal.fhHelp,fpos+2,pBuf,80);
            *(pBuf+fpos) = 0;           /* ensure terminated            */
            if (pBuf = hfstrchr(pBuf,'\r'))
                *pBuf = 0;              /* terminate at CR              */
            }
        }
#endif
    }
return fRet;
/* end HelpSzContext */}

/******************************************************************************
**
** LoadPortion - Load a section of the help file
**
** Purpose:
**  If not loaded, allocates memory for and loads a section (as defined in
**  helpfile.h) of the current help file. Once loaded, or if already loaded,
**  locks it, and returns the the memory handle and pointer.
**
**  This routine must be far, since it is an entry point for HelpMake
**
** Entry:
**  hsCur       = Help section to be loaded.
**  mhfdb       = memory handle for fdb
**
** Exit:
**  returns handle for memory
**
** Exceptions:
**  returns NULL on portion not existing, 0xffff on inability to allocate memory.
**
*/
mh pascal near LoadPortion (
int     hsCur,
mh      mhfdb
) {
fdb     fdbLocal;
char far *fpDest        = 0;
int     i;
mh      mhNew           = 0;            /* pointer to mh destination    */
ushort  osize;                          /* additional prepended size    */
ushort  size;

if (LoadFdb (mhfdb, &fdbLocal)) {
    if (((mhNew = fdbLocal.rgmhSections[hsCur]) == 0)
        && fdbLocal.hdr.tbPos[hsCur]) {

        for (i=hsCur+1; i<HS_count; i++)
            if (fdbLocal.hdr.tbPos[i]) {
                size = (ushort)(fdbLocal.hdr.tbPos[i]-fdbLocal.hdr.tbPos[hsCur]);
                break;
                }

        osize = (hsCur == HS_KEYPHRASE) ? 1024*sizeof(PVOID) : 0;
/*
** Alloc the memory required. Re-read the FDB, incase intervening calls to
** HelpShrink causes deallocs of other beasties.
*/
        if (   (mhNew = HelpAlloc((ushort)(size + osize)))
            && LoadFdb (mhfdb, &fdbLocal)) {
            fdbLocal.rgmhSections[hsCur] = mhNew;
            if (PutFdb (mhfdb, &fdbLocal)) {
                fpDest = (char far *)HelpLock(mhNew);
                if (fpDest && ReadHelpFile(fdbLocal.fhHelp
                                           ,(ulong)fdbLocal.hdr.tbPos[hsCur] + fdbLocal.foff
                                           ,fpDest + osize
                                           ,size)) {

                    if (hsCur == HS_KEYPHRASE)
                        kwPtrBuild(fpDest,size);/* build keyword pointers       */
                    HelpUnlock (mhNew);
                    }
                else {
                    fdbLocal.rgmhSections[hsCur] = 0;
                    HelpDealloc (mhNew);
                    PutFdb (mhfdb, &fdbLocal);
                    mhNew = (mh)(-1);
                    }
                }
            else
                mhNew = (mh)0;
            }
        else
            mhNew = (mh)(-1);
        }
    }

return mhNew;

/* end LoadPortion */}

/*************************************************************************
**
** SizePos - Return count of bytes in compressed topic, and position
**
** Purpose:
**  Returns the size in bytes of the compressed topic, and it's location in the
**  help file.
**
** Entry:
**  ncCur       - Context number to return info on.
**  psize       - Pointer to place to put the size
**  ppos        - Pointer to place to put the position
**
** Exit:
**  Returns TRUE on success.
**
** Exceptions:
**  Returns FALSE on all errors.
**
** Algorithm:
**
**  If current help handle valid
**      If filetype is compressed
**          If context map not loaded, load it
**          Lock context map
**          Map context to topic number
**          Unlock context map
**          If topic index not loaded, load it
**          Lock topic index
**          size is difference in file positions
**          Unlock topic index
**      else if filetype is formatted ascii
**          seek to context file position
**          scan for next context definition
**          size is difference in file positions
**      else if filetype is unformatted ascii
**          size is filesize
*/
f pascal near SizePos (
nc      ncCur,
ushort  *psize,
ulong   *ppos
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpT;                          /* temp pointer                 */
REGISTER f fRv      = FALSE;            /* return value                 */
ushort  iTopic;                         /* topic index                  */
mh      mhCur;                          /* handle being locked          */

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb copy         */
    if (fdbLocal.ftype & FTCOMPRESSED) {/* if a standard compressed file*/
        if ((iTopic = MapContexttoTopic (ncCur,&fdbLocal)) != 0xffff) {
            mhCur = LoadPortion(HS_INDEX,ncCur.mh);
            if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
                *ppos = ((long far *)fpT)[iTopic];
                *psize = (ushort)(((long far *)fpT)[iTopic+1] - *ppos);
                HelpUnlock (mhCur);
                fRv = TRUE;
                }
            }
        }

#if ASCII
    else if (fdbLocal.ftype & FTFORMATTED) {/* if a formatted ascii file*/
        if ((*psize = (ushort)(maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)+4, HelpCmp)))
            == 0xffff)
            *psize = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        else
            *psize -= (ushort)NctoFo(ncCur.cn);
        *ppos  = (ulong) maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)-1, HelpCmp);
        fRv = TRUE;
        }
    else {                              /* unformatted ascii            */
        *ppos = ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        *psize = (*ppos > (ulong)(65535-sizeof(topichdr)-4))
                 ? (ushort)(65535-sizeof(topichdr)-4)
                 : (ushort)*ppos;
        *ppos = 0L;                     /* position is always zero.     */
        fRv = TRUE;
        }
#endif
    }

return fRv;
/* end SizePos */}

/************************************************************************
**
** MapContexttoTopic
**
** Purpose:
**  Given a context number, return the topic number which it maps to. This
**  is just a direct index of the context number into the context map.
**
** Entry:
**  ncCur       = context number to be mapped
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns zero based topic number, or 0xffff on error.
*/
ushort pascal near MapContexttoTopic (
nc      ncCur,                          /* context number to map        */
fdb far *fpfdbCur                       /* pointer to current FDB       */
) {
REGISTER ushort topic = 0xffff;         /* value to return              */
ushort far *fpT;                        /* pointer to context map       */
mh      mhCur;                          /* handle being locked          */

if (ncCur.cn) {
/*
** Local contexts: the topic number is already encoded in the low word, if the
** high bit of that word is set.
*/
    if (ncCur.cn & 0x8000)
        topic = (ushort)(ncCur.cn & 0x7fff);
/*
** Normal Contexts: low word of nc is an index into the context map which
** returns the topic number
*/
    else {
        mhCur = LoadPortion(HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
        if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
            topic = fpT[ncCur.cn-1];
            HelpUnlock (mhCur);
            }
        }
    }
return topic;
/* end MapContexttoTopic */}

/************************************************************************
**
** MapTopictoContext
**
** Purpose:
**  Given a topic number, return a context which maps to it.
**
**  This involves searching the context map for the first context entry that
**  maps to the desired topic number.
**
** Entry:
**  iTopic      = topic number to map back to a context number
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns a valid nc into the file.
**
** Exceptions:
**  If the incoming iTopic is invalid, or a read error occurs, then the nc
**  returned refers to the topic number 0.
**
*/
nc pascal near MapTopictoContext(
ushort  iTopic,                         /* topic number to map          */
fdb far *fpfdbCur,           /* pointer to current FDB   */
int     Dir
) {
    ushort  cTopics;                /* number of topics to search   */
    ushort  far *fpContextMap;      /* pointer to the context map   */
    mh      mhPortion;              /* mem handle for the context map*/
    nc      ncMatch     = {0,0};    /* return value                 */

    mhPortion = LoadPortion (HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
    if (mhPortion && (mhPortion != (mh)(-1))) {
        if (fpContextMap = HelpLock(mhPortion)) {
            if (iTopic >= fpfdbCur->hdr.cTopics) {
                iTopic = 0;
            }
            ncMatch.mh = (mh)0L;
            ncMatch.cn = 0x8000 | iTopic;
            // rjsa ncMatch = 0x8000 | iTopic;
            cTopics = 0;
            while (cTopics < fpfdbCur->hdr.cContexts) {
                if ( Dir == 0 ) {
                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }
                } else if ( Dir > 0 ) {
                    if (iTopic <= fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }

                } else if ( Dir < 0 ) {

                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;
                        break;
                    } else if (iTopic < fpContextMap[cTopics-1]) {
                        ncMatch.cn = cTopics-1;
                        break;
                    }
                }
            }
            //if ( iTopic != fpContextMap[cTopics-1] ) {
            //    ncMatch.cn = 0;
            //}
            if ( cTopics >= fpfdbCur->hdr.cContexts) {
                ncMatch.cn = 0;
            }
            HelpUnlock (mhPortion);
        }
    }
    ncMatch.mh = (fpfdbCur->ncInit).mh;
    return ncMatch;
    // rjsa return ncMatch | HIGHONLY(fpfdbCur->ncInit);
}

/************************************************************************
**
** LoadFdb - make local copy of fdb.
**
** Purpose:
**  Used to create a local copy of an FDB, so that we don't have to keep a
**  locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpFdbDest   - Pointer to destination for FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near LoadFdb (
mh      mhfdb,
fdb far *fpfdbDest
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbDest = *fpfdbCur;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end LoadFdb */}

/************************************************************************
**
** PutFdb - make local copy of fdb permanent.
**
** Purpose:
**  Used to copy a local copy of an FDB to the "real" one, so that we don't
**  have to keep a locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpfdbSrc    - Pointer to source of FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near PutFdb (
mh      mhfdb,
fdb far *fpfdbSrc
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbCur = *fpfdbSrc;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end PutFdb */}

#if ASCII
/************************************************************************
**
** maLocate - Locate context in minimally formatted ascii file.
**
** Purpose:
**  Performs sequential searches on mimimally formatted ascii files to locate
**  lines beginning with ">>" and a context string.
**
** Entry:
**  fpfdbCur    = Pointer to current fdb
**  fpszSrc     = Pointer to context string to be found (or null for next
**                string)
**  offset      = offset at which to begin search.
**  lpfnCMp     = pointer to comparison routine to use
**
** Exit:
**  returns file offset of ">>" of context string.
**
** Exceptions:
**  returns -1 on error.
**
*/
long pascal near maLocate (
fdb far *fpfdbCur,
uchar far *fpszSrc,
ulong   offset,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
uchar   buffer[MASIZE+1];               /* input buffer                 */
ushort  cbBuf           = 0;            /* count of bytes in buffer     */
ushort  cbSrc;                          /* length of source string      */
uchar far *pBuf;                        /* pointer into buffer          */
uchar far *pBufT;                       /* temp pointer into buffer     */

cbSrc = hfstrlen(fpszSrc)+1;            /* get length of input          */
if (offset == 0xffffffff)               /* special case                 */
    offset = 0;
while (cbBuf += (ushort)ReadHelpFile(fpfdbCur->fhHelp
                             , offset+cbBuf
                             , buffer+cbBuf
                             , (ushort)(MASIZE-cbBuf))) {

    buffer[cbBuf] = 0;                  /* ensure strings terminated    */
    pBuf = &buffer[0];
    while (pBuf = hfstrchr(pBuf,'>')) { /* look for start of context    */
        if ((*(pBuf+1) == '>')          /* if >> found                  */
            && ((*(pBuf-1) == '\n')     /* at beginning of line         */
                || ((offset == 0)       /* or beginning of file         */
                    && (pBuf == (char far *)&buffer[0])))) {
            pBufT = pBuf +2;
            if (lpfnCmp (fpszSrc, pBufT, cbSrc, FALSE, TRUE))
                return offset + (ulong)(pBuf - (uchar far *)&buffer[0]);
            }
        pBuf += 2;
        }
    if (cbBuf == MASIZE) {              /* if buffer full               */
        hfstrcpy(buffer,buffer+MASIZE-MAOVER);  /* copy down overlap    */
        cbBuf = MAOVER;                         /* and leave that in    */
        offset += MASIZE-MAOVER;        /* file pos of buffer[0]        */
        }
    else {
        offset += cbBuf;
        cbBuf = 0;                      /* else we're empty             */
        }
    }
return -1;

/* end maLocate */}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\hinfo.c ===
/*** hinfo.c - helpgetinfo support
*
*   Copyright <C> 1989, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   []	09-Mar-1989 LN	    Created
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"			/* global (help & user) decl	*/
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

/*
** external definitions
*/
f	    pascal near LoadFdb (mh, fdb far *);

/*** HelpGetInfo - Return public info to caller
*
*  Returns a data structure to the caller which allows him into some of
*  our internal data.
*
* Input:
*  ncInfo	= nc requesting info on
*  fpDest	= pointer to location to place into
*  cbDest	= size of destination
*
* Output:
*  Returns NULL on success, count of bytes required if cbDest too small,
*  or -1 on any other error
*
*************************************************************************/
int far pascal LOADDS HelpGetInfo (
nc	ncInfo,
helpinfo far *fpDest,
int	cbDest
) {
if (cbDest < sizeof (helpinfo))
    return sizeof (helpinfo);
if (LoadFdb (ncInfo.mh, &(fpDest->fileinfo))) {
    fpDest->filename[0] = 0;
    return 0;
    }
return -1;

/* end HelpGetInfo */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\helpif.c ===
/*** helpif.c - help routines for user interface assistance.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*  These routines aid in the interpretation of help text by applications.
*  After decompression, the help text is encoded into a line oriented format
*  which includes text, highlighting and cross reference information.
*
*  Each line of text is formatted in the database as:
*
*  +--------+----------------+--------+---------------+------+---------------+
*  | cbText | - Ascii Text - | cbAttr | - Attr info - | 0xff | - Xref Info - |
*  +--------+----------------+--------+---------------+------+---------------+
*
*  Where:
*
*	cbText	    - a BYTE which contains the length of the ascii text plus
*		      one (for itself).
*	Ascii Text  - Just that, the ascii text to be displayed
*	cbAttr	    - a WORD which contains the length of the attribute
*		      information *plus* the cross reference information.
*	Attr info   - attribute/length pairs of highlighting information plus
*		      two (for itself).
*	0xff	    - Attr info terminator byte (present ONLY IF Xref
*		      information follows)
*	Xref Info   - Cross Referencing information.
*
* Notes:
*  If the LAST attributes on a line are "plain", then the attribute/length
*  pair is omitted, and the rest of the line is assumed plain.
*
*  Given a pointer to a line, a pointer to the next line is:
*
*	    Pointer + cbText + cbAttr
*
*  A line which has no cross-reference or highlighting will have a cbAttr of
*  2, and nothing else.
*
* Revision History:
*
*	25-Jan-1990 ln	locate -> hlp_locate
*	19-Aug-1988 ln	Move "locate" to assembly language hloc.asm
*   []	26-Jan-1988 LN	Created
*
*************************************************************************/
#include <stdlib.h>
#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"
#include "helpfile.h"
#include "helpsys.h"

/************************************************************************
**
** Foward Declarations
*/
uchar near pascal toupr(uchar);

/*** HelpGetLineAttr - Return attributes associated with a line of ascii text
*
*  Interprets the help files stored format and return a line at a time of
*  attribute information.
*
* Input:
*  ln		= 1 based line number to return
*  cbMax	= Max number of bytes to transfer
*  pbDst	= pointer to destination
*  pbTopic	= PB pointer to topic text
*
* Output:
*  Returns number of characters transfered (not including terminating 0xffff
*  attribute), or 0 if that line does not exist.
*
*************************************************************************/
ushort far pascal LOADDS HelpGetLineAttr(
ushort	ln,
int	cbMax,
lineattr far *pbDst,
PB	pbTopic
) {
lineattr far *pbDstBegin;
uchar far *pTopic;
/*
** Form valid (locked) pointer to topic text & working pointer to detination
*/
pTopic = PBLOCK (pbTopic);
pbDstBegin = pbDst;
/*
** Information is on present in compressed files. Locate the line in the text,
** and then point at the attribute information therein.
*/
#if ASCII
if (((topichdr far *)pTopic)->ftype & FTCOMPRESSED) {
#endif
    if (pTopic = hlp_locate(ln,pTopic)) {
	pTopic += *pTopic;
/*
** Start by giving ln the count of encoded bytes. Then while there are
** bytes, and we have enough room in the destination, AND we haven't reached
** the end of the attribute information, then for each cb/attr pair, copy
** them over, converting from our internal byte-per format to the external
** word-per format.
*/
	ln = *((ushort far UNALIGNED *)pTopic)++ - (ushort)2;
	while (   ln
	       && (cbMax >= sizeof(lineattr))
	       && (((intlineattr far *)pTopic)->attr != (uchar)0xff)
	       ) {
	    *(ushort UNALIGNED *)&(pbDst->cb)	= ((intlineattr far UNALIGNED *)pTopic)->cb;
	    *(ushort UNALIGNED *)&(pbDst->attr) = ((intlineattr far UNALIGNED *)pTopic)->attr;
	    pbDst++;
	    ((intlineattr *)pTopic)++;
	    cbMax -= sizeof(lineattr);
	    ln -= sizeof(intlineattr);
	    }
	}
#if ASCII
    }
#endif
PBUNLOCK (pbTopic);
/*
** Finally, if there is room in the destination buffer, terminate the
** attributes with "default attributes to the end of line", and then
** attribute ffff, signalling the end of the buffer.
*/
if (cbMax >= sizeof(lineattr)) {
    pbDst->cb = 0xffff;
    pbDst->attr = 0;
    cbMax -= sizeof(lineattr);
    pbDst++;
    }
if (cbMax >= sizeof(pbDst->attr))
    pbDst->attr = 0xffff;
/*
** return the number of bytes transferred, not including the terminating
** word.
*/
return (ushort)((uchar far *)pbDst - (uchar far *)pbDstBegin);

/* end HelpGetLineAttr */}

/************************************************************************
**
** HelpHlNext - Locate next cross reference
**
** Purpose:
**  Locates the next cross reference in the help topic. Locates either the
**  next physical cross reference, or the next referece beginning with a
**  particular character (case insensitive!). Locates either forward or
**  backward.
**
** Entry:
**  cLead	= leading character, or flag, indicating direction and type
**		  of search. May be:
**			NULL:	Get next sequential cross reference
**			-1:	Get previous sequential cross reference
**			char:	Get next cross reference beginning with 'char'
**			-char:	Get previous cross reference beginning with
**				'char'
**  pbTopic	= pointer to topic text.
**  photspot	= pointer to hotspot structure to recive info. (line and col
**		  indicate starting point)
**
** Exit:
**  returns TRUE if cross reference found, hotspot structure updated.
**
** Exceptions:
**  returns 0 if no such cross reference.
*/
f pascal far LOADDS HelpHlNext(cLead,pbTopic, photspot)
int	cLead;
PB	pbTopic;
hotspot far *photspot;
{
ushort	cbAttr;
ushort	col;
ushort	ln;
uchar far *pbEnd;			/* pointer to next line 	*/
uchar far *pbLineCur;			/* pointer to current line	*/
uchar far *pbFound	= 0;		/* found entry, perhaps 	*/
uchar far *pText;
uchar far *pTopic;

pTopic = PBLOCK (pbTopic);
col = photspot->col;			/* save these			*/
ln = photspot->line;
if (((topichdr far *)pTopic)->ftype & FTCOMPRESSED) {
    while (1) {
	if (ln == 0) break;			/* if not found, ret	*/
	pbLineCur = hlp_locate(ln,pTopic);	    /* find line	    */
	if (pbLineCur == 0) break;		/* if not found, ret	*/
	pText = pbLineCur;			/* point at topic text	*/
	pbLineCur += *pbLineCur;		/* skip the topic text	*/
	cbAttr = *((ushort far UNALIGNED *)pbLineCur)++ - (ushort)sizeof(ushort);
	pbEnd = pbLineCur + cbAttr;		/* next line		*/
	while (cbAttr && (((intlineattr far UNALIGNED *)pbLineCur)->attr != 0xff)) {
	    pbLineCur += sizeof(intlineattr);
	    cbAttr -=sizeof(intlineattr);
	    }
	if (cbAttr)
	    pbLineCur += sizeof(uchar); 	/* skip (0xff) attr	*/

	while (pbLineCur < pbEnd) {		/* scan rest for data	*/
/*
** in a forward scan, the first cross reference (with appropriate char) that is
** greater than our current position, is the correct one.
*/
	    if (cLead >= 0) {			/* forward scan 	*/
		if (col <= *(pbLineCur+1))	/* if found		*/
		    if ((cLead == 0)		/* and criteria met	*/
			|| (toupr(*(pText + *pbLineCur)) == (uchar)cLead)) {
		    pbFound = pbLineCur;
		    break;
		    }
		}
/*
** in a backward scan, we accept the LAST item we find which is less than
** the current position.
*/
	    else {
		if (col > *(pbLineCur))     /* if a candidate found */
		    if ((cLead == -1)	    /* and criteria met     */
			|| (toupr(*(pText + *pbLineCur)) == (uchar)-cLead))
			pbFound = pbLineCur;/* remember it	    */
		}
	    pbLineCur += 2;		    /* skip column spec     */
	    if (*pbLineCur)
		while (*pbLineCur++);	    /* skip string	    */
	    else
		pbLineCur += 3;
	    }

	if (pbFound) {			    /* if we found one	    */
	    *(ushort UNALIGNED *)&(photspot->line) = ln;
	    *(ushort UNALIGNED *)&(photspot->col)  = (ushort)*pbFound++;
	    *(ushort UNALIGNED *)&(photspot->ecol) = (ushort)*pbFound++;
	    *(uchar *UNALIGNED *)&(photspot->pXref) = pbFound;
	    PBUNLOCK (pbTopic);
	    return TRUE;
	    }
/*
** move on to next line.
*/
	if (cLead >= 0) {
	    ln++;
	    col = 0;
	    }
	else {
	    ln--;
	    col = 127;
	    }
	}
    }

PBUNLOCK (pbTopic);
return FALSE;
/* end HelpHlNext */}

/************************************************************************
**
** HelpXRef - Return pointer to Xref String
**
** Purpose:
**  Given a row, column (in a hotspot structure) and topic, return a pointer
**  to a cross reference string.
**
** Entry:
**  pbTopic	= Pointer to topic text
**  photspot	= Pointer to hotspot structure to update
**
** Exit:
**  returns far pointer into topic text of cross reference string & updates
**  hotspot structure.
**
** Exceptions:
**  returns NULL if no cross reference for that line.
**
*/
char far * pascal far LOADDS HelpXRef(pbTopic, photspot)
PB	pbTopic;
hotspot far *photspot;
{
uchar far *pTopic;
ushort	col;				/* column requested		*/
ushort	ln;				/* line requested		*/

pTopic = PBLOCK (pbTopic);
col = photspot->col;			/* save these			*/
ln = photspot->line;
if (((topichdr far *)pTopic)->ftype & FTCOMPRESSED)
    if (HelpHlNext(0,pbTopic,photspot)) 	/* if xref found	*/
	if (   (photspot->line == ln)		/* & our req. in range	*/
	    && (   (col >= photspot->col)
		&& (col <= photspot->ecol))) {
	    PBUNLOCK (pbTopic);
	    return photspot->pXref;		/* return ptr		*/
	    }

PBUNLOCK (pbTopic);
return 0;

/* end HelpXRef */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\helpdll.c ===
/*************************************************************************
**
** helpdll - stubs for call-back routines when used as dll.
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**	12-Mar-1990	ln	CloseFile -> HelpCloseFile
**  []	22-Jan-1988	LN	Created
**
*************************************************************************/

#include <stdio.h>
#include <malloc.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include "help.h"                       /* global (help & user) decl    */
#include "helpsys.h"			/* internal (help sys only) decl*/


#ifdef OS2
int	_acrtused;			/* define to disable crt0	*/
#endif

char far *  pascal near hfstrchr(char far *, char);

/************************************************************************
 *
 * OpenFileOnPath - Open a file located somewhere on the PATH
 *
 * Purpose:
 *
 * Entry:
 *  pszName     - far pointer to filename to open
 *  mode        - read/write mode
 *
 * Exit:
 *  returns file handle
 *
 * Exceptions:
 *  return 0 on error.
 *
 */
FILE *
pascal
far
OpenFileOnPath(
    char far *pszName,
    int     mode
    )
{
    FILE *fh;
	char szNameFull[260];
	char szNameFull1[260];

    fh = (FILE *)pathopen(pszName, szNameFull, "rb");

    if (!fh) {

        char *pszPath;
        char *pT;

        if (*pszName == '$') {
            if (pT = hfstrchr(pszName,':')) {   /* if properly terminated       */
                *pT = 0;                        /* terminate env variable       */
                pszPath = pszName+1;            /* get path name                */
                pszName = pT+1;                 /* and point to filename part   */
            }
        } else {
            pszPath = "PATH";
        }
        sprintf(szNameFull, "$%s:%s", pszPath, pszName);
		fh = (FILE *)pathopen(szNameFull, szNameFull1, "rb");

    }

    return fh;
}



/************************************************************************
 *
 * HelpCloseFile - Close a file
 *
 * Purpose:
 *
 * Entry:
 *  fh          = file handle
 *
 * Exit:
 *  none
 *
 */
void
pascal
far
HelpCloseFile(
    FILE*   fh
    )
{
    fclose(fh);
}




/************************************************************************
 *
 * ReadHelpFile - locate and read data from help file
 *
 * Purpose:
 *  reads cb bytes from the file fh, at file position fpos, placing them in
 *  pdest. Special case of pdest==0, returns file size of fh.
 *
 * Entry:
 *  fh          = File handle
 *  fpos        = position to seek to first
 *  pdest       = location to place it
 *  cb          = count of bytes to read
 *
 * Exit:
 *  returns length of data read
 *
 * Exceptions:
 *  returns 0 on errors.
 *
 */
unsigned long
pascal
far
ReadHelpFile (
    FILE     *fh,
    unsigned long fpos,
    char far *pdest,
    unsigned short cb
    )
{
    unsigned long cRet = 0;


    if (pdest) {
        //
        //  Read cb bytes
        //
        if (!fseek(fh, fpos, SEEK_SET)) {
            cRet = fread(pdest, 1, cb, fh);
        }

    } else {
        //
        //  Return size of file (yuck!)
        //
        if (!fseek(fh, 0, SEEK_END)) {
            fgetpos(fh, (fpos_t *) &cRet);
        }
    }

    return cRet;
}




/************************************************************************
**
** HelpAlloc - Allocate a segment of memory for help
**
** Purpose:
**
** Entry:
**  size	= size of memory segment desired
**
** Exit:
**  returns handle on success
**
** Exceptions:
**  returns NULL on failure
*/
mh pascal far HelpAlloc(ushort size)
{
    return (mh)malloc(size);
/* end HelpAlloc */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\helpcnt.c ===
/*** helpcnt.c - HelpcLines routine.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*	25-Jan-1990 ln	locate -> hlp_locate
*	19-Aug-1988 ln	Changed to use new locate routine.
*   []	10-Aug-1988 LN	Created
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"
#include "helpfile.h"
#include "helpsys.h"


/*** HelpcLines - Return number of lines in topic
*
* Purpose:
*  Interpret the help files stored format and return the number of lines
*  contained therein.
*
*  It *is* sensitive to the applications control character, again just like
*  HelpGetLine, and will return total number of lines if the header.linChar
*  is set to 0xff, or the number of lines that do NOT begin with
*  header.linChar.
*
* Input:
*  pbTopic	= pointer to topic text
*
* Output:
*  Returns number of lines in topic.
*
*************************************************************************/
int far pascal LOADDS HelpcLines(
PB	pbTopic
) {
REGISTER ushort cLines; 		/* count of lines		*/
uchar far *pTopic;			/* pointer to topic		*/

pTopic = PBLOCK (pbTopic);
cLines = (ushort)hlp_locate (-1,pTopic);
PBUNLOCK (pbTopic);

return cLines;
/* end HelpcLines */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\helpcell.c ===
/*** helpcell.c - HelpGetCells routine.
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*	25-Jan-1990 ln	locate -> hlp_locate
*   []	04-Aug-1988 LN	Created...split from helpif.c. Added auto-fill.
*
*************************************************************************/

#include <stdio.h>

#if defined (OS2)
#else
#include <windows.h>
#endif

#include "help.h"
#include "helpfile.h"
#include "helpsys.h"

/************************************************************************
**
** Foward Declarations
*/
uchar near pascal toupr(uchar);

/************************************************************************
**
** HelpGetCells - Return a string of character / attribute pairs from helpfile
**
** Purpose:
**  Interpret the help files stored format and return a line at a time of
**  character & attribute information.
**
** Entry:
**  ln		= 1 based line number to return
**  cbMax	= Max number of characters to transfer
**  pbDst	= pointer to destination
**  pbTopic	= pointer to topic text
**  prgAttr	= pointer to array of character attributes
**
** Exit:
**  returns number of bytes transfered, or -1 if that line does not exist.
**  DOES blank fill to the cbMax width.
**
** Exceptions:
**
*/
int far pascal LOADDS HelpGetCells(ln,cbMax,pbDst,pbTopic,prgAttr)
int	ln;
int	cbMax;
char far *pbDst;
PB	pbTopic;
uchar far *prgAttr;
{
ushort	cbAttr; 			/* length of current attribute	*/
ushort	cbAttrCur	= 0;		/* length of current attribute	*/
ushort	cbSrc;				/* count of source characters	*/
uchar	cAttrCur;			/* current attribute		*/
uchar	iAttrCur;			/* index to current attribute	*/
uchar far *pTopic;			/* pointer to topic		*/
uchar far *pchSrc;			/* pointer to source characters */
topichdr far *pHdr;			/* pointer to topic header	*/

pTopic = PBLOCK (pbTopic);
pHdr = (topichdr far *)pTopic;
if ((pTopic = hlp_locate((ushort)ln,pTopic)) == NULL)/* locate line                  */
    ln = -1;

else if (pHdr->ftype & FTCOMPRESSED) {
    ln=0;
    pchSrc = pTopic;			/* point to character data	*/
    pTopic += (*pTopic);		/* point to attribute data	*/
    cbAttr = *((ushort far UNALIGNED *)pTopic)++ - (ushort)sizeof(ushort);/* count of attribute bytes     */
    cbSrc = (ushort)((*pchSrc++) -1);             /* get count of characters      */

    while (cbSrc-- && cbMax--) {	/* while characters to get	*/
/*
 * Time for a new attribute. If there are attributes left (cbAttr > 0) then
 * just get the next one (length & index). If there weren't any left, or the
 * last one had an index of 0xff (indicating end), then we'll use the index
 * zero attribute byte, else pick up the current attribute byte and move on
 * in the attribute string.
 */
	if (cbAttrCur == 0) {
	    if (cbAttr > 0) {
		cbAttrCur = ((intlineattr far UNALIGNED *)pTopic)->cb;
		iAttrCur  = ((intlineattr far UNALIGNED *)pTopic)->attr;
		}
	    if ((cbAttr <= 0) || (iAttrCur == 0xff))
		cAttrCur  = prgAttr[0];
	    else {
		cAttrCur  = prgAttr[iAttrCur];
		((intlineattr far *)pTopic)++;
		cbAttr -= 2;
		}
	    }
        *((ushort far UNALIGNED *)pbDst)++ = (ushort)((cAttrCur << 8) | *pchSrc++); /* stuff char & attr*/
	cbAttrCur--;
	ln += 2;
	}
    }
#if ASCII
else {
/*
** For ascii files, just copy line over with attr[0]
*/
    ln=0;
    while (*pTopic && (*pTopic != '\r') && cbMax--) {
	if (*pTopic == '\t') {
	    pTopic++;
	    do {
                *((ushort far UNALIGNED *)pbDst)++ = (ushort)((prgAttr[0] << 8) | ' ');
		ln += 2;
		}
	    while ((ln % 16) && cbMax--);
	    }
	else {
            *((ushort far UNALIGNED *)pbDst)++ = (ushort)((prgAttr[0] << 8) | *pTopic++);
	    ln += 2;
	    }
	}
    }
#endif
#if 0
/*
 * blank fill the rest of the line
 */
while (cbMax--)
    *((ushort far UNALIGNED *)pbDst)++ = (prgAttr[0] << 8) | ' '; /* stuff char & attr*/
#endif
PBUNLOCK (pbTopic);
return ln;
/* end HelpGetCells */}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\farutil.h ===
/*************************************************************************
**
** farutil.h - procedure definitions for farutil package
**
**	Copyright <C> 1988, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**  []	08-May-1988	LN	Created
**
*************************************************************************/
typedef char	f;
typedef unsigned char	uchar;
typedef unsigned long	ulong;
typedef unsigned short	ushort;

char far *  pascal far	farAlloc(ulong);
void	    pascal far	farFree (char far *);
uchar far * pascal far	farMemset(uchar far *, uchar, ushort);
uchar far * pascal far	farMove (uchar far *, uchar far *, ushort);
uchar far * pascal far	farMoveDn (uchar far *, uchar far *, ushort);
uchar far * pascal far	farMoveUp (uchar far *, uchar far *, ushort);
int	    pascal far	farRead (int, uchar far *, int);
int	    pascal far	farStrcmp (uchar far *, uchar far *);
int	    pascal far	farStrncmp (uchar far *, uchar far *, int);
uchar far * pascal far	farStrcpy (uchar far *, uchar far *);
int	    pascal far	farStrlen (uchar far *);
int	    pascal far	farWrite (int, uchar far *, int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\hline.c ===
/**************************************************************************
 *HelpGetLine - Return a line of ascii text
 *
 *       Copyright <C> 1988, Microsoft Corporation
 *
 * Revision History:
 *
 *       25-Jan-1990     ln      LOCATE -> HLP_LOCATE
 *       22-Feb-1989     ln      Check correctly for end of topic while copying
 *                               line.
 *       22-Dec-1988     LN      Removed MASM High Level Lang support (Need
 *                               to control segments better than that will
 *                               let me)
 *       08-Dec-1988     LN      CSEG
 *       11-Nov-1988     ln      Adjust cbMax on entry
 *       03-Nov-1988     ln      Added GQ sensitivity
 *  []   22-Sep-1988     LN      Created
 *
 * Notes:
 *
 * Sensitive to the following switches:
 *
 *       HOFFSET - If defined, handle/offset version
 *       OS2     - If defined, OS/2 protect mode version
 *       DSLOAD  - If defined, causes DS to be reloaded, if needed
 *       ASCII   - If TRUE, includes ASCII support code
 *       GQ      - If defined, INC BP before saving & DEC before restore
 *
 **************************************************************************/

#include <stdio.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include <help.h>
#include <helpfile.h>
#include <helpsys.h>



/**** HelpGetLine - Return a line of ascii text
 *
 *  Interpret the help files stored format and return a line at a time of
 *  ascii text.
 *
 * ushort far pascal LOADDS HelpGetLine (
 * ushort  ln,           = 1 based line number to return
 * ushort  cbMax,        = Max number of bytes to transfer
 * uchar far *pszDst,    = pointer to destination
 * PB      pbTopic       = PB pointer to topic text
 *
 * Output:
 *  Returns number of characters transfered, or 0 if that line does not exist.
 *
 *************************************************************************/
USHORT pascal
HelpGetLine (
    USHORT ln,
    USHORT cbMax,
    PUCHAR pszDst,
    PB     pbTopic
    ) {

    struct topichdr *pT;
    USHORT          cbTransfered = 0;
    PUCHAR          pszDstOrg    = pszDst;

    cbMax--; //adjust to account for terminating zero

    pT = PBLOCK(pbTopic);

    if (pT) {

        PCHAR pLine = hlp_locate(ln, (PCHAR)pT);

        if (pLine) {

            *pszDst      = ' ';
            *(pszDst +1) = '\00';   // initialize dest.


            if (pT->ftype & FTCOMPRESSED) {

                //  For compressed files, get the length of the line from the
                //  first byte, and of course skip that byte. Form the
                //  maximum byte count ot be transfered as the lesser of the
                //  actual length of the line or caller cbMax.

                USHORT Len = (USHORT)*pLine++ - 1;

                if (Len) {
                    ULONG   LongLen;
                    Len = (Len > cbMax) ? cbMax : Len;

                    LongLen = Len/sizeof(ULONG);
                    Len     = (USHORT)(Len % sizeof(ULONG));


                    while (LongLen--) {
                        *((ULONG UNALIGNED*)pszDst)++ = *((ULONG UNALIGNED *)pLine)++;
                    }
                    while (Len--) {
                        *pszDst++ = *pLine++;
                    }
                    *pszDst++ = '\00';       // Null terminate it
                    cbTransfered = (USHORT)(pszDst - pszDstOrg);
                } else {
                    cbTransfered = 2;
                }

            } else {

                //  For non-compressed files, copy one line

                PCHAR pSrc = pLine;
                CHAR  c    = *pLine;

                if (c == '\n') {
                    cbTransfered = 2;
                } else {
                    while (c != '\00' && c != '\n') {
                        c = *pszDst++ = *pLine++;
                    }
                    *(pszDst-1) = '\00';    // null terminate it

                    cbTransfered = (USHORT)(pszDst - pszDstOrg);
                }
            }
        }

        PBUNLOCK(pbTopic);
    }

    return cbTransfered;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\helpfile.h ===
/*
** helpfile.h
**
** This file defines the help file format.
**
**
**	+---------------------+
**	| Header	      |
**	+---------------------+
**	| Topic index	      |
**	+---------------------+
**	| Context strings     |
**	+---------------------+
**	| Context map	      |
**	+---------------------+
**	| Keyphrase table     |
**	+---------------------+
**	| Huffman decode tree |
**	+---------------------+
**	| Filename Map	      |
**	+---------------------+
**	| Compressed topics   |
**	+---------------------+
**
** Header: described by the structure below.
**
** Topic index: an array of dwords indexed by topic number that gives the file
** position of the topic. Note: topic n+1 follows topic n so the index can be
** used to compute the size of a topic as well.
**
** Context Strings: An array of (null terminated) strings which map to context
** numbers in the following Context Map. These strings are used to for topic
** look-up when no predefined Context Number has been assigned.
**
** Context map: an array of words which maps a context to a topic. This allows
** the order of context numbers to differ from the order of topics in the help
** file, and allows more than one context to map to the same topic.
**
** Keyphrase table: table of strings used to compress the topic text.
**
** Huffman decode tree: tree representing the character mapping used in huffman
** copression of the help text.
**
** Filename Map: Table of filenames and Topic Index ranges used to redirect
** certain topics to other help files. Used in combined help files.
**
** Compressed Topics: The compressed text for all topics. When the help file is
** built, the topics are first keyphrase and runlength compressed, and are the
** Huffman encoded. So to decode a topic, it must first be Huffman decoded, and
** then keyphrase and runlength expanded. Keyphrase and runlength encoding
** cookies are described below. Huffman decoding is discussed in dehuff.asm.
*/

/*
** Numbers for each of the sections of the help file
*/
#define HS_INDEX	      0 	/* topic index			*/
#define HS_CONTEXTSTRINGS     1 	/* Context Strings		*/
#define HS_CONTEXTMAP	      2 	/* context to topic map 	*/
#define HS_KEYPHRASE	      3 	/* keyphrase table		*/
#define HS_HUFFTREE	      4 	/* huffman decode tree		*/
#define HS_TOPICS	      5 	/* compressed topic text	*/
#define HS_NEXT 	      8 	/* position of cat'ed helpfile  */

#define wMagicHELP	0x4e4c		/* New Help file magic word	*/
#define wMagicHELPOld	0x928b		/* Old Help file magic word	*/
#define wHelpVers	2		/* helpfile version		*/


#define wfCase		0x0001		/* set= Preserve case		*/
#define wfLock		0x0002		/* set= file locked		*/

/*
** Keyphrase and run length encoding cookies. Each compressed keyphrase or
** character run is replaced by one of these cookies with appropriate
** parameters.
**
** Keyphrase cookies are followed by a one byte keyphrase index.
** Runspace is followed by a one byte count of spaces.
** Run is followed by a character and a count of repititions.
** Quote is followed by a character.
*/
#define C_MIN		   0x10 	/* Bottom of cookie range	*/
#define C_KEYPHRASE0	   0x10 	/* 1st keyphrase cookie 	*/
#define C_KEYPHRASE1	   0x11 	/* 2nd keyphrase cookie 	*/
#define C_KEYPHRASE2	   0x12 	/* 3rd keyphrase cookie 	*/
#define C_KEYPHRASE3	   0x13 	/* 3rd keyphrase cookie 	*/
#define C_KEYPHRASE_SPACE0 0x14 	/* 1st keyphrase + space cookie */
#define C_KEYPHRASE_SPACE1 0x15 	/* 2nd keyphrase + space cookie */
#define C_KEYPHRASE_SPACE2 0x16 	/* 3rd keyphrase + space cookie */
#define C_KEYPHRASE_SPACE3 0x17 	/* 3rd keyphrase + space cookie */
#define C_RUNSPACE	   0x18 	/* Cookie for runs of spaces	*/
#define C_RUN		   0x19 	/* Cookie for runs of non-space */
#define C_QUOTE 	   0x1a 	/* Cookie to quote non-cookies	*/
#define C_MAX		   0x1a 	/* top of cookie range		*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\help.h ===
/*
** help.h
**
** typedefs & definitions used in the help system and by those who use it.
**
** define:
**  HOFFSET	- to define buffer pointers (PB's) as handle/offset, else
**		  they are defined as void far *.
*/
typedef char f;              /* boolean                      */
typedef unsigned char uchar;
typedef unsigned long ulong;
typedef unsigned short ushort;

/*
** lineattr
** external representation of line attributes, as returned by HelpGetLineAttr
*/
typedef struct lineattr {		/* LA */
    ushort attr;			/* attribute index		*/
    ushort cb;				/* count of bytes		*/
    } lineattr;
/*
** mh
** a memory handle is defined for use with systems that use dynamic, moveable
** memory. It is long, so that in simple cases where memory is NOT moveable,
** the handle can contain the far pointer to the base.
*/
typedef void * mh;                      /* dynamic memory handle        */
/*
** nc
** a context number is a unique id associated with each context string.
**
** fhnc     returns the file memory handle from the nc
** fLocal   returns TRUE if the context is a uniq context number (local, or
**		    result of explicit uniq call.
*/
typedef struct _nc {
        mh     mh;
        ulong  cn;
        } nc ;                       /* context number               */
// rjsa #define fmhnc(x)   ((unsigned)(((unsigned long)x & 0xffff0000L) >> 16))
#define fmhnc(x)   ((x).mh)
#define fUniq(x)   ((x).cn & 0x8000)

/*
** topichdr
** header placed (by HelpDecomp) at the begining of every decompressed topic
*/
typedef struct topichdr {		/* TH */
    uchar appChar;			/* app-specific character const */
    uchar linChar;			/* character for line removal	*/
    uchar ftype;			/* source file type		*/
    ushort lnCur;			/* line number last accessed	*/
    ushort lnOff;			/* offset into topic for that line*/
    } topichdr;

/*
** hotspot
** defines the position of an embedded cross reference, or "hotspot". Used by
** HelpHlNext and HelpXRef
*/
typedef struct hotspot {		/* HS */
    ushort line;			/* the topic line with an xref	*/
    ushort col; 			/* the starting column of xref	*/
    ushort ecol;			/* the ending columng of xref	*/
    uchar far *pXref;			/* pointer to xref string	*/
    } hotspot;
/*
** helpheader
** This defines the actual structure of a help file header. Provided here
** for HelpGetInfo
*/
#define HS_count	      9 	/* number-1 of sections defined */

#pragma pack(1)
typedef struct helpheader {		/* HH */
    ushort wMagic;			/* word indicating help file	*/
    ushort wVersion;			/* helpfile version		*/
    ushort wFlags;			/* flags			*/
    ushort appChar;			/* application specific char	*/
    ushort cTopics;			/* count of topics		*/
    ushort cContexts;			/* count of context strings	*/
    ushort cbWidth;			/* fixed width			*/
    ushort cPreDef;			/* count of pre-defined contexts*/
    uchar fname[14];			/* base file name		*/
    ushort reserved[2]; 		/* unused			*/
    ulong tbPos[HS_count];		/* positions for file sections	*/
    } helpheader;
#pragma pack()
/*
** fdb
** Dynamically allocated structure which is created for each open help file.
** Remains allocated for the life of the file.
**
** rgmhSections contains dynamic memory handles. Each open file has various
** dynamic memory buffers associated with it. Each can be present or discarded,
** as memory constrictions determine. If needed and not present, they are
** reloaded from the associated help file. All may be discarded when memory
** gets tight. An entry is defined for each help file section, except for the
** Topics themselves.
**
*/
typedef struct fdb {			/* FDB */
    FILE * fhHelp;                      /* OS file handle               */
    nc ncInit;				/* initial context (includes mh)*/
    mh rgmhSections[HS_count-1];	/* dynamic memory handles	*/
    uchar ftype;			/* file type			*/
    uchar fname[14];			/* base file name		*/
    ulong foff; 			/* our file offset, if appended */
    nc ncLink;				/* nc linking any appended file */
    helpheader hdr;			/* file header			*/
    } fdb;
/*
** helpinfo
** structure of information relating to a help file and/or context returned
** by HelpGetInfo
*/
typedef struct helpinfo {		/* HI */
    fdb     fileinfo;			/* entire fdb copied out	*/
    char    filename[1];		/* filename appended to data	*/
    } helpinfo;
/*
** Macros for accessing helpinfo data
*/
#define     FHHELP(x)	((x)->fileinfo.fhHelp)
#define     NCINIT(x)	((x)->fileinfo.ncInit)
#define     FTYPE(x)	((x)->fileinfo.ftype)
#define     FNAME(x)	((x)->fileinfo.fname)
#define     FOFF(x)	((x)->fileinfo.foff)
#define     NCLINK(x)	((x)->fileinfo.ncLink)
#define     WMAGIC(x)	((x)->fileinfo.hdr.wMagic)
#define     WVERSION(x)	((x)->fileinfo.hdr.wVersion)
#define     WFLAGS(x)	((x)->fileinfo.hdr.wFlags)
#define     APPCHAR(x)	((x)->fileinfo.hdr.appChar)
#define     CTOPICS(x)	((x)->fileinfo.hdr.cTopics)
#define     CCONTEXTS(x) ((x)->fileinfo.hdr.cContexts)
#define     CBWIDTH(x)	((x)->fileinfo.hdr.cbWidth)
#define     CPREDEF(x)	((x)->fileinfo.hdr.cPreDef)
#define     HFNAME(x)	((x)->fileinfo.hdr.fname)
#define     TBPOS(x)	((x)->fileinfo.hdr.tbPos)

/******************************************************************************
**
** Some versions of the help engine run with SS!=DS, and thus require the
** _loadds attribute on function calls.
*/
#ifdef DSLOAD
#define LOADDS _loadds
#else
#define LOADDS
#endif

/******************************************************************************
**
** PB
** pointer to a buffer. Based on the switch HOFFSET, it is either a
** handle-offset or a far pointer. In the handle/offset case, the high word
** contains a memory handle which must be locked, to get a "real" address, to
** which the offset is added.
*/
#ifdef HOFFSET
#define PB	ulong
#else
#define PB	void far *
#endif

typedef PB	pb;

/******************************************************************************
**
** Forward declarations
*/
void	far pascal LOADDS HelpInit (void);

void	far pascal LOADDS HelpClose(nc);
nc	far pascal LOADDS HelpOpen(char far *);

nc	far pascal LOADDS HelpNc(char far *, nc);
nc	far pascal LOADDS HelpNcCmp (char far *, nc,
			      f (pascal far *)(uchar far *, uchar far *, ushort, f, f));
ushort	far pascal LOADDS HelpNcCb(nc);
ushort	far pascal LOADDS HelpLook(nc, PB);
f	far pascal LOADDS HelpDecomp(PB, PB, nc);
void	far pascal LOADDS HelpCtl(PB, f);

nc	far pascal LOADDS HelpNcNext(nc);
nc	far pascal LOADDS HelpNcPrev(nc);
nc	far pascal LOADDS HelpNcUniq(nc);

void	far pascal LOADDS HelpNcRecord(nc);
nc	far pascal LOADDS HelpNcBack(void);

f	far pascal LOADDS HelpSzContext(uchar far *, nc);
int	far pascal LOADDS HelpGetInfo (nc, helpinfo far *, int);

void	far pascal LOADDS HelpShrink(void);

int	far pascal LOADDS HelpGetCells(int, int, char far *, PB, uchar far *);
ushort	far pascal LOADDS HelpGetLine(ushort, ushort, uchar far *, PB);
ushort	far pascal LOADDS HelpGetLineAttr(ushort, int, lineattr far *, PB);
int	far pascal LOADDS HelpcLines(PB);

f	far pascal LOADDS HelpHlNext(int, PB, hotspot far *);
char far * pascal far LOADDS HelpXRef(PB, hotspot far *);

/******************************************************************************
**
** constant declarations
**
** Character attribute bits. These bits are order together to form attribute
** indecies. Data in the help file has associated with it attribute information
** encoded in length/index pairs. Each index is simply a constant which
** indicates which of several attributes should be applied to the characters in
** that portion of the line.
*/
#define A_PLAIN 	0		/* plain, "normal" text 	*/
#define A_BOLD		1		/* emboldened text		*/
#define A_ITALICS	2		/* italicised text		*/
#define A_UNDERLINE	4		/* underlined text		*/

/******************************************************************************
**
** Help Error Codes.
**
** Return values greater than HELPERR_MAX are valid nc's.
*/
#define HELPERR_FNF	    1		/* OpenFileOnPath failed	*/
#define HELPERR_READ	    2		/* ReadHelpFile failed on header*/
#define HELPERR_LIMIT	    3		/* to many open helpfiles	*/
#define HELPERR_BADAPPEND   4		/* bad appeneded file		*/
#define HELPERR_NOTHELP     5		/* Not a help file		*/
#define HELPERR_BADVERS     6		/* newer or incompatible help file */
#define HELPERR_MEMORY	    7		/* memory allocation failed	*/
#define HELPERR_MAX	    10		/* max help error		*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\htest\htest.c ===
/*** htest - help engine test harness
*
*   Copyright <C> 1987, Microsoft Corporation
*
* Revision History:
*
*	15-Dec-1988 ln	Added dump command
*   []	21-Oct-1988 LN	New Version
*
*************************************************************************/

#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined (OS2)
#define INCL_SUB
#define INCL_DOSMODULEMGR
#define INCL_DOSFILEMGR
#define INCL_DOSMISC
#include <ctype.h>
#include <os2.h>
#else
#include <windows.h>
#endif

#include "cons.h"

#include "help.h"
#include "helpfile.h"			/* help file format definition	*/
#include "helpsys.h"			/* internal (help sys only) decl*/

#if defined (OS2)
#define HELPDLL_NAME    "mshelp1.dll"
#define HELPDLL_BASE    "mshelp1"
#else
#define HELPDLL_NAME    "mshelp.dll"
#define HELPDLL_BASE    "mshelp"
#endif
/*
 * text color values
 */
#define BLACK		0
#define BLUE		1
#define GREEN		2
#define CYAN		3
#define RED		4
#define MAGENTA 	5
#define BROWN		6
#define WHITE		7
#define GREY		8
#define LIGHTBLUE	9
#define LIGHTGREEN	10
#define LIGHTCYAN	11
#define LIGHTRED	12
#define LIGHTMAGENTA	13
#define YELLOW		14
#define BRIGHTWHITE	15

#define BUFSIZE 	128		/* text buffer size		*/

#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))
#define SETERROR(x,y)   { (x).mh = 0L; (x).cn = y;}

typedef void    pascal (*void_F)    (void);
typedef int     pascal (*int_F)     (void);
typedef ushort  pascal (*ushort_F)  (void);
typedef f       pascal (*f_F)       (void);
typedef char *  pascal (*pchar_F)   (void);
typedef nc      pascal (*nc_F)      (void);
typedef mh      pascal (*mh_F)      (void);

#if !defined (HELP_HACK)

#define HelpcLines      ((int_F)    (pEntry[P_HelpcLines     ]))
#define HelpClose       ((void_F)   (pEntry[P_HelpClose      ]))
#define HelpCtl         ((void_F)   (pEntry[P_HelpCtl        ]))
#define HelpDecomp      ((f_F)      (pEntry[P_HelpDecomp     ]))
#define HelpGetCells    ((int_F)    (pEntry[P_HelpGetCells   ]))
#define HelpGetInfo     ((inf_F)    (pEntry[P_HelpGetInfo    ]))
#define HelpGetLine     ((ushort_F) (pEntry[P_HelpGetLine    ]))
#define HelpGetLineAttr ((ushort_F) (pEntry[P_HelpGetLineAttr]))
#define HelpHlNext      ((f_F)      (pEntry[P_HelpHlNext     ]))
#define HelpLook        ((ushort_F) (pEntry[P_HelpLook       ]))
#define HelpNc          ((nc_F)     (pEntry[P_HelpNc         ]))
#define HelpNcBack      ((nc_F)     (pEntry[P_HelpNcBack     ]))
#define HelpNcCb        ((ushort_F) (pEntry[P_HelpNcCb       ]))
#define HelpNcCmp       ((nc_F)     (pEntry[P_HelpNcCmp      ]))
#define HelpNcNext      ((nc_F)     (pEntry[P_HelpNcNext     ]))
#define HelpNcPrev      ((nc_F)     (pEntry[P_HelpNcPrev     ]))
#define HelpNcRecord    ((void_F)   (pEntry[P_HelpNcRecord   ]))
#define HelpNcUniq      ((nc_F)     (pEntry[P_HelpNcUniq     ]))
#define HelpOpen        ((nc_F)     (pEntry[P_HelpOpen       ]))
#define HelpShrink      ((void_F)   (pEntry[P_HelpShrink     ]))
#define HelpSzContext   ((f_F)      (pEntry[P_HelpSzContext  ]))
#define HelpXRef        ((pchar_F)  (pEntry[P_HelpXRef       ]))
#define LoadFdb         ((f_F)      (pEntry[P_LoadFdb        ]))
#define LoadPortion     ((mh_F)     (pEntry[P_LoadPortion    ]))

#endif

enum {
    P_HelpcLines,
    P_HelpClose,
    P_HelpCtl,
    P_HelpDecomp,
    P_HelpGetCells,
    P_HelpGetInfo,
    P_HelpGetLine,
    P_HelpGetLineAttr,
    P_HelpHlNext,
    P_HelpLook,
    P_HelpNc,
    P_HelpNcBack,
    P_HelpNcCb,
    P_HelpNcCmp,
    P_HelpNcNext,
    P_HelpNcPrev,
    P_HelpNcRecord,
    P_HelpNcUniq,
    P_HelpOpen,
    P_HelpShrink,
    P_HelpSzContext,
    P_HelpXRef,
    P_LoadFdb,
    P_LoadPortion,
    LASTENTRYPOINT
    } ENTRYPOINTS;

#define NUM_ENTRYPOINTS (LASTENTRYPOINT - P_HelpcLines)


typedef nc pascal (*PHF) (void);


/*
 * Global Data
 */
char            buf[BUFSIZ];            /* text buffer                  */
char            cell[2] = {' ',0x1f};   /* background clearing cell     */
#define ColorByte cell[1]
int             curline;                /* current line output          */
char            *errTbl[] = {
                    "",
                    "help file not found",
                    "ReadHelpFile failed on header",
                    "to many open helpfiles",
                    "bad appeneded file",
                    "Not a help file",
                    "newer or incompatible help file",
                    "memory allocation failed"
                    };
f		fBoth	= FALSE; /* both stdout & screen	*/
f		fEnable = FALSE;	/* enable control lines in disp */
int             iNcCur;                 /* current index in ncTbl       */
int             lastline;
int             lLast;                  /* last starting line number disp*/
mh		mhTopicCur;		/* mem handle for most recent	*/
uchar		mpAttr[] = {		/* on-screen color map		*/
		   0x1f,		/* 0: normal text		*/
		   0x1c,		/* 1: bold			*/
		   0x1a,		/* 2: italics			*/
		   0x1e,		/* 3: bold italics		*/
		   0x7f,		/* 4: underline 		*/
		   0x7c,		/* 5: bold ul			*/
		   0x7a,		/* 6: italics ul		*/
		   0x7e 		/* 7: bold italics ul		*/
		    };
nc		ncCur;			/* most recently read in topic	*/
nc		ncTbl[MAXFILES];	/* table of open nc's           */
char far *	pTopicCur;		/* ptr to most recent topic	*/
char            *spaces  = "                                                                  \r\n";

#if defined (OS2)
HMODULE         hModule;
#else
HANDLE          hModule;
#endif

PHF             pEntry[NUM_ENTRYPOINTS] = {0};
#if defined (OS2)
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "_HelpcLines",
                    "_HelpClose",
                    "_HelpCtl",
                    "_HelpDecomp",
                    "_HelpGetCells",
                    "_HelpGetInfo",
                    "_HelpGetLine",
                    "_HelpGetLineAttr",
                    "_HelpHlNext",
                    "_HelpLook",
                    "_HelpNc",
                    "_HelpNcBack",
                    "_HelpNcCb",
                    "_HelpNcCmp",
                    "_HelpNcNext",
                    "_HelpNcPrev",
                    "_HelpNcRecord",
                    "_HelpNcUniq",
                    "_HelpOpen",
                    "_HelpShrink",
                    "_HelpSzContext",
                    "_HelpXRef",
                    "_LoadFdb",
                    "_LoadPortion",
                    };

#else
char *          szEntryName[NUM_ENTRYPOINTS] = {
                    "HelpcLines",
                    "HelpClose",
                    "HelpCtl",
                    "HelpDecomp",
                    "HelpGetCells",
                    "HelpGetInfo",
                    "HelpGetLine",
                    "HelpGetLineAttr",
                    "HelpHlNext",
                    "HelpLook",
                    "HelpNc",
                    "HelpNcBack",
                    "HelpNcCb",
                    "HelpNcCmp",
                    "HelpNcNext",
                    "HelpNcPrev",
                    "HelpNcRecord",
                    "HelpNcUniq",
                    "HelpOpen",
                    "HelpShrink",
                    "HelpSzContext",
                    "HelpXRef",
                    "LoadFdb",
                    "LoadPortion",
                    };

#endif

// rjsa VIOMODEINFO     screen;

/*
 * Forward declarations
 */
#define ASSERTDOS(x)   assertDos(x, __FILE__, __LINE__)
void        pascal near assertDos   (USHORT, CHAR *, USHORT);
void	    pascal near cls	    (void);
void        pascal near dispCmd     (int, int);
void		pascal near dumpCmd 	();
void		pascal near dumpfileCmd ( char *);
void	    pascal near fileCmd     (char *);
void	    pascal near helpCmd     (void);
void        pascal near lookupCmd   (char *, int);
void        pascal near outtext     (char *, BYTE);
void        pascal near outtextat   (char *, int, int, BYTE);
uchar far * pascal near phrasecopy  (uchar *, uchar far *);
void	    pascal near xrefCmd     (char *);

#undef HelpDealloc
#undef HelpLock
#undef HelpUnlock

void        pascal  far HelpDealloc (mh);
void far *  pascal  far HelpLock    (mh);
void	    pascal  far HelpUnlock  (mh);

f		 pascal near LoadFdb (mh, fdb far *);
mh		 pascal near LoadPortion (USHORT, mh);
//char far *  pascal near hfstrcpy(char far *, char far *);
//ushort      pascal near hfstrlen(char far *);


void   LoadTheDll(void);
USHORT WrtCellStr (PBYTE buf, int cb, int row, int col);
USHORT WrtLineAttr( PBYTE buf, lineattr* rgAttr, int cb, int row, int col );
USHORT WrtCharStrAtt (PBYTE pText, int cb, int row, int col, PBYTE pcolor);


PSCREEN     Scr;

/*** main - main program
*
* Input:
*  Standard C main, all ignored
*
* Output:
*  Returns via exit()
*
*************************************************************************/
void main(
USHORT     argc,
char	**argv
) {
char    c;
nc		ncNull = {0,0};
SCREEN_INFORMATION ScrInfo;
/*
 * parse any options
 */
if (argc > 1)
    while ((** ++argv) == '-') {
	c = *(++(*argv));
	switch (toupper(c)) {
	    case 'B':			    /* -b: both screen and stdout   */
		fBoth = TRUE;
		break;
	    default:
		fputs ("Unknown switch ignored", stderr);
		break;
	    }
        }

// InitializeGlobalState();
Scr = consoleGetCurrentScreen();

//  Load help engine DLL and initialize pointers to entry
//  points.
//
LoadTheDll();

#if defined(CLEAR)
HelpInit();
#endif

/*
 * Start by getting the current config & clearing screen.
 */
// rjsa screen.cb = sizeof(screen);
// rjsa assertDos (VioGetMode (&screen, 0));
// rjsa lastline = screen.row-1;
consoleGetScreenInformation( Scr, &ScrInfo );
lastline = ScrInfo.NumberOfRows-2;
// lastline = 22;
cls();
helpCmd();
/*
 * main loop. Position at bottom of screen, and accept one command at at time
 * from there. Interpret commands until done.
 */
do {
    outtextat ("\r\n", lastline, 0, BRIGHTWHITE);
    outtextat (spaces, lastline, 0, BRIGHTWHITE);
	outtextat ("HTEST Command> ", lastline, 0, BRIGHTWHITE);
    // rjsa VioSetCurPos (lastline, 15, 0);
    consoleSetCursor(Scr, lastline, 16);
    gets (buf);
    cls ();
    outtextat ("\r\n", lastline, 0, BRIGHTWHITE);
    outtextat ("Processing: ", lastline, 0, LIGHTRED);
    outtextat (buf, lastline, 12, BRIGHTWHITE);
    outtextat ("\r\n", lastline, 0, BRIGHTWHITE);
/*
 * ctrl on/off
 */
    if (!strcmp (buf,"ctrl on")) {
	fEnable = TRUE;
	cls ();
	outtextat ("Control Lines Displayed", 0, 0, BRIGHTWHITE);
	}
    else if (!strcmp (buf,"ctrl off")) {
	fEnable = FALSE;
	cls ();
	outtextat ("Control Lines NOT Displayed", 0, 0, BRIGHTWHITE);
	}
/*
 * disp
 */
    else if (!strcmp (buf,"disp"))
	dispCmd (1,lastline);
/*
 * down
 */
    else if (!strcmp (buf,"down"))
	dispCmd (lLast+1,lLast + lastline);
/*
 * dump
 */
	else if (!strncmp (buf, "dump ", 5))
	dumpfileCmd(buf+5);
	else if (!strcmp (buf,"dump"))
	dumpCmd ();
/*
 * file newhelpfilename
 */
    else if (!strncmp (buf,"file ", 5))
	fileCmd (buf+5);
/*
 * help
 */
    else if (!strcmp (buf,"help"))
	helpCmd ();
/*
 * look helpstring
 */
    else if (!strncmp (buf,"look ", 5))
	lookupCmd (buf+5,0);
/*
 * look
 */
    else if (!strcmp (buf,"look"))
	lookupCmd (NULL,0);
/*
 * next
 */
    else if (!strcmp (buf,"next"))
	lookupCmd (NULL,1);
/*
 * prev
 */
    else if (!strcmp (buf,"prev"))
	lookupCmd (NULL,-1);
/*
 * up
 */
    else if (!strcmp (buf,"up")) {
	lLast = max (1, lLast-1);
	dispCmd (lLast,lLast + lastline);
	}
/*
 * xref xrefnumber
 */
    else if (!strncmp (buf,"xref", 4))
	xrefCmd (buf+4);
/*
 * + page down
 */
    else if (!strcmp (buf,"+")) {
	lLast += lastline;
	dispCmd (lLast,lLast + lastline);
	}
/*
 * - page up
 */
    else if (!strcmp (buf,"-")) {
	lLast = max (1, lLast - (lastline));
	dispCmd (lLast,lLast + lastline);
	}
    }
/*
 * exit
 */
while (strncmp(buf,"exit",4));
outtextat (spaces, lastline, 0, BRIGHTWHITE);
HelpClose (ncNull);

/* end main */}






/*** dispCmd - display topic text
*
*  displays the topic text on the screen.
*
* Input:
*  lStart	- starting line
*   lEnd	- ending line
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near dispCmd (
int     lStart,
int     lEnd
) {
char	buf[BUFSIZ*2];
lineattr	rgAttr[BUFSIZ];
int     cb;
int     lineCur = 0;

	HelpCtl (pTopicCur, fEnable);
	cls ();
	lLast = lStart;
	while (lStart<lEnd) {
		if (!isatty(_fileno(stdout)) || fBoth) {
			cb = (int)HelpGetLine (lStart, BUFSIZ*2, (char far *)buf, pTopicCur);
			if (cb == 0)
				lStart = lEnd;
			buf[cb-1] = '\r';
			buf[cb] = '\n';
			buf[cb+1] = 0;
			outtext (buf, BLACK);
			buf[cb-1] = 0;
		}
		if (isatty(_fileno(stdout)) || fBoth) {
			cb = HelpGetLine(lStart, BUFSIZ*2, (char far*)buf, pTopicCur );
			HelpGetLineAttr( lStart, BUFSIZ*sizeof(lineattr), rgAttr, pTopicCur );
			WrtLineAttr(buf, rgAttr, cb, lineCur++, 0 );
		}

		//if (isatty(fileno(stdout)) || fBoth) {
		//	 cb = HelpGetCells (lStart, BUFSIZ*2, buf, pTopicCur, mpAttr);
		//	if (cb == -1)
		//		lStart = lEnd;
		//	else
		//		 ASSERTDOS (WrtCellStr (buf, cb, lineCur++, 0));
		//	}

		lStart++;
	}

/* end dispCmd */}

static char *szHS[] = { "HS_INDEX",
			"HS_CONTEXTSTRINGS",
			"HS_CONTEXTMAP",
			"HS_KEYPHRASE",
			"HS_HUFFTREE",
			"HS_TOPICS",
			"unused (6)",
			"unused (7)",
			"HS_NEXT" };

/*** dumpCmd - process dump command
*
*  Dumps the contents of the current help file
*
* NOTE:
*  This function uses all sorts of "internal" knowledge and calls to
*  do it's job.
*
* Input:
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near dumpCmd () {
char	buf[BUFSIZ];
int  cbKeyPhrase;
fdb	fdbLocal;			/* local copy of fdb to use	*/
uchar far *fpT;
ushort far *fpW;
int     i;
nc	ncNext; 			/* nc init of appended file	*/
//uchar	uc;

cls();
ncNext = ncCur;
while (ncNext.cn) {
    if (LoadFdb (ncNext.mh, &fdbLocal)) {
	sprintf (buf,"fhHelp            %u\r\n",    fdbLocal.fhHelp);
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"ncInit            %08lx\r\n", fdbLocal.ncInit);
	outtext (buf, BRIGHTWHITE);
	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"rgmhSections[%18s]    %04x\r\n", szHS[i], fdbLocal.rgmhSections[i]);
	    outtext (buf, BRIGHTWHITE);
	    }
	sprintf (buf,"ftype             %02x\r\n",  fdbLocal.ftype );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"fname             %14s\r\n",  fdbLocal.fname );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"foff              %08lx\r\n", fdbLocal.foff  );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"ncLink            %08lx\r\n", fdbLocal.ncLink);
	outtext (buf, BRIGHTWHITE);

	sprintf (buf,"hdr.wMagic        %04x\r\n",  fdbLocal.hdr.wMagic     );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.wVersion      %04x\r\n",  fdbLocal.hdr.wVersion   );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.wFlags        %04x\r\n",  fdbLocal.hdr.wFlags     );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.appChar       %04x\r\n",  fdbLocal.hdr.appChar    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cTopics       %04x\r\n",  fdbLocal.hdr.cTopics    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cContexts     %04x\r\n",  fdbLocal.hdr.cContexts  );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cbWidth       %04x\r\n",  fdbLocal.hdr.cbWidth    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.cPreDef       %04x\r\n",  fdbLocal.hdr.cPreDef    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.fname         %s\r\n",    fdbLocal.hdr.fname	    );
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.reserved[0]   %04x\r\n",  fdbLocal.hdr.reserved[0]);
	outtext (buf, BRIGHTWHITE);
	sprintf (buf,"hdr.reserved[1]   %04x\r\n",  fdbLocal.hdr.reserved[1]);

	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"hdr.tbPos[%18s]       %08lx\r\n", szHS[i], fdbLocal.hdr.tbPos[i]);
	    outtext (buf, BRIGHTWHITE);
	    }
	outtext ("----- ----- -----\r\n", LIGHTGREEN);
/*
 * Topic Index
 * This is just a table of (long) offsets within the current file. We just
 * report the values, and also calculate the size of each entry by looking
 * at the position of the entry following.
 */
        fpT = HelpLock (LoadPortion( HS_INDEX ,ncNext.mh));
	if (fpT) {
	    outtext ("Topic Index:\r\n", LIGHTRED);
		for (i = 0; i < (int)fdbLocal.hdr.cTopics; i++) {
		sprintf (buf, "  %2d: %08lx, %ld bytes\r\n", i, ((long far *)fpT)[i], ((long far *)fpT)[i+1]-((long far *)fpT)[i]);
		outtext (buf, BRIGHTWHITE);
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * context strings
 * This is just a table of null terminated strings, in no particular order.
 * We just list them out sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTSTRINGS ,ncNext.mh));
	if (fpT) {
	    outtext ("Context strings:\r\n", LIGHTRED);
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {

		sprintf (buf, "  %03d: ", i);
                // rjsa hfstrcpy ((char far *)buf+7, fpT);
                strcpy ((char far *)buf+7, fpT);
		strcat (buf, "\r\n");
		outtext (buf, BRIGHTWHITE);

                // rjsa fpT += hfstrlen(fpT) +1;
                fpT += strlen(fpT) +1;
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * Context Map
 * This is the mapping of context strings to actual topic numbers. The context
 * strings map one to one to the entries in this table, which in turn contains
 * indexes into the topic index at the head of the file. We just dump this
 * table sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTMAP ,ncNext.mh));
	if (fpT) {
	    outtext ("Context map:\r\n", LIGHTRED);
	    outtext ("  Ctx  Topic\r\n",BRIGHTWHITE);
	    outtext ("  ---  -----\r\n",BRIGHTWHITE);
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {
		sprintf (buf, "  %03d: %04d\r\n", i, ((ushort far *)fpT)[i]);
		outtext (buf, BRIGHTWHITE);
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * keyword table
 * This is a table of byte-prefixed strings, which we output in order,
 * synthesizing the tokens that they would be in the text as well.
 */
        fpT = HelpLock (LoadPortion( HS_KEYPHRASE, ncNext.mh));
	if (fpT) {
	    cbKeyPhrase = 0;
	    for (i=HS_HUFFTREE; i<HS_count; i++)
		if (fdbLocal.hdr.tbPos[i]) {
		    cbKeyPhrase = (ushort)(fdbLocal.hdr.tbPos[i] - fdbLocal.hdr.tbPos[HS_KEYPHRASE]);
		    break;
		    }

	    outtext ("Keyphrase Table:\r\n", LIGHTRED);
	    outtext ("  Token Phrase\r\n",BRIGHTWHITE);
	    outtext ("  ----- ------\r\n",BRIGHTWHITE);
	    i = 0;
            fpT += 1024 * sizeof (PVOID);
	    fpW = (ushort far *)(fpT + cbKeyPhrase);
	    while (fpT < (uchar far *)fpW) {
		sprintf (buf, "  %04x: ", i+(C_KEYPHRASE0 << 8));
		fpT = phrasecopy (buf+8, fpT);
		strcat (buf, "\r\n");
		outtext (buf, BRIGHTWHITE);
		i++;
		}
	    outtext ("----- ----- -----\r\n", LIGHTGREEN);
	    }
/*
 * huffman table
 * here we try to get fancy and output some information about the table format
 */
        fpW = HelpLock (LoadPortion( HS_HUFFTREE, ncNext.mh));
	if (fpW) {
	    outtext ("Huffman Tree:\r\n", LIGHTRED);
	    i = 0;
	    while (*fpW) {
		sprintf (buf, "  0x%03x: 0x%04x, %s\r\n", i++, *fpW, *fpW & 0x8000 ? "Leaf" : "Node");
		fpW++;
		outtext (buf, BRIGHTWHITE);
		}
	    }
	outtext ("===== ===== =====\r\n", YELLOW);
	ncNext = fdbLocal.ncLink;
	}
    else {
	sprintf(buf, "Cannot load fdb for %08lx\r\n",ncCur);
	outtext (buf, LIGHTRED);
	return;
	}
    }
/* end dumpCmd */}

/*** dumpfileCmd - process dump command
*
*  Dumps the contents of the current help file
*
* NOTE:
*  This function uses all sorts of "internal" knowledge and calls to
*  do it's job.
*
* Input:
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near dumpfileCmd (char *fname) {
char	buf[BUFSIZ];
int  cbKeyPhrase;
fdb	fdbLocal;			/* local copy of fdb to use	*/
uchar far *fpT;
ushort far *fpW;
int     i;
nc	ncNext; 			/* nc init of appended file	*/
//uchar	uc;

FILE* fh = fopen(fname, "w");
if (!fh) {
	return;
}
ncNext = ncCur;
while (ncNext.cn) {
    if (LoadFdb (ncNext.mh, &fdbLocal)) {
	sprintf (buf,"fhHelp            %u\r\n",	fdbLocal.fhHelp);
	fprintf( fh, buf );
	sprintf (buf,"ncInit            %08lx\r\n", fdbLocal.ncInit);
	fprintf( fh, buf );
	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"rgmhSections[%18s]    %04x\r\n", szHS[i], fdbLocal.rgmhSections[i]);
		fprintf( fh, buf );
	    }
	sprintf (buf,"ftype             %02x\r\n",  fdbLocal.ftype );
	fprintf( fh, buf );
	sprintf (buf,"fname             %14s\r\n",  fdbLocal.fname );
	fprintf( fh, buf );
	fprintf( fh, buf );
	sprintf (buf,"foff              %08lx\r\n", fdbLocal.foff  );
	fprintf( fh, buf );
	sprintf (buf,"ncLink            %08lx\r\n", fdbLocal.ncLink);
	fprintf( fh, buf );

	sprintf (buf,"hdr.wMagic        %04x\r\n",  fdbLocal.hdr.wMagic     );
	fprintf( fh, buf );
	sprintf (buf,"hdr.wVersion      %04x\r\n",  fdbLocal.hdr.wVersion   );
	fprintf( fh, buf );
	sprintf (buf,"hdr.wFlags        %04x\r\n",  fdbLocal.hdr.wFlags     );
	fprintf( fh, buf );
	sprintf (buf,"hdr.appChar       %04x\r\n",  fdbLocal.hdr.appChar    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cTopics       %04x\r\n",  fdbLocal.hdr.cTopics    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cContexts     %04x\r\n",  fdbLocal.hdr.cContexts  );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cbWidth       %04x\r\n",  fdbLocal.hdr.cbWidth    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.cPreDef       %04x\r\n",  fdbLocal.hdr.cPreDef    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.fname         %s\r\n",    fdbLocal.hdr.fname	    );
	fprintf( fh, buf );
	sprintf (buf,"hdr.reserved[0]   %04x\r\n",  fdbLocal.hdr.reserved[0]);
	fprintf( fh, buf );
	sprintf (buf,"hdr.reserved[1]   %04x\r\n",  fdbLocal.hdr.reserved[1]);

	for (i=0; i<HS_count; i++) {
	    sprintf (buf,"hdr.tbPos[%18s]       %08lx\r\n", szHS[i], fdbLocal.hdr.tbPos[i]);
		fprintf( fh, buf );
	    }
	fprintf( fh,"----- ----- -----\r\n"  );
/*
 * Topic Index
 * This is just a table of (long) offsets within the current file. We just
 * report the values, and also calculate the size of each entry by looking
 * at the position of the entry following.
 */
        fpT = HelpLock (LoadPortion( HS_INDEX ,ncNext.mh));
	if (fpT) {
		fprintf( fh,"Topic Index:\r\n"	);
		for (i = 0; i < (int)fdbLocal.hdr.cTopics; i++) {
		sprintf (buf, "  %2d: %08lx, %ld bytes\r\n", i, ((long far *)fpT)[i], ((long far *)fpT)[i+1]-((long far *)fpT)[i]);
		fprintf( fh, buf );
		}
		fprintf( fh,"----- ----- -----\r\n"  );
	    }
/*
 * context strings
 * This is just a table of null terminated strings, in no particular order.
 * We just list them out sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTSTRINGS ,ncNext.mh));
	if (fpT) {
	fprintf( fh, "Context strings:\r\n" );
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {

		sprintf (buf, "  %03d: ", i);
                // rjsa hfstrcpy ((char far *)buf+7, fpT);
                strcpy ((char far *)buf+7, fpT);
		strcat (buf, "\r\n");
		fprintf( fh, buf );

                // rjsa fpT += hfstrlen(fpT) +1;
                fpT += strlen(fpT) +1;
		}
		fprintf( fh,"----- ----- -----\r\n"  );
	    }
/*
 * Context Map
 * This is the mapping of context strings to actual topic numbers. The context
 * strings map one to one to the entries in this table, which in turn contains
 * indexes into the topic index at the head of the file. We just dump this
 * table sequentially.
 */
        fpT = HelpLock (LoadPortion( HS_CONTEXTMAP ,ncNext.mh));
	if (fpT) {
		fprintf( fh, "Context map:\r\n" );
		fprintf( fh, "  Ctx  Topic\r\n" );
		fprintf( fh, "  ---  -----\r\n" );
		for (i=0; i<(int)fdbLocal.hdr.cContexts; i++) {
		sprintf (buf, "  %03d: %04d\r\n", i, ((ushort far *)fpT)[i]);
		fprintf( fh, buf );
		}
		fprintf( fh, "----- ----- -----\r\n" );
	    }
/*
 * keyword table
 * This is a table of byte-prefixed strings, which we output in order,
 * synthesizing the tokens that they would be in the text as well.
 */
        fpT = HelpLock (LoadPortion( HS_KEYPHRASE, ncNext.mh));
	if (fpT) {
	    cbKeyPhrase = 0;
	    for (i=HS_HUFFTREE; i<HS_count; i++)
		if (fdbLocal.hdr.tbPos[i]) {
		    cbKeyPhrase = (ushort)(fdbLocal.hdr.tbPos[i] - fdbLocal.hdr.tbPos[HS_KEYPHRASE]);
		    break;
		    }

		fprintf( fh, "Keyphrase Table:\r\n" );
		fprintf( fh, "  Token Phrase\r\n" );
		fprintf( fh, "  ----- ------\r\n" );
	    i = 0;
            fpT += 1024 * sizeof (PVOID);
	    fpW = (ushort far *)(fpT + cbKeyPhrase);
	    while (fpT < (uchar far *)fpW) {
		sprintf (buf, "  %04x: ", i+(C_KEYPHRASE0 << 8));
		fpT = phrasecopy (buf+8, fpT);
		strcat (buf, "\r\n");
		fprintf( fh, buf );
		i++;
		}
		fprintf( fh,"----- ----- -----\r\n"  );
	    }
/*
 * huffman table
 * here we try to get fancy and output some information about the table format
 */
        fpW = HelpLock (LoadPortion( HS_HUFFTREE, ncNext.mh));
	if (fpW) {
		fprintf( fh, "Huffman Tree:\r\n" );
	    i = 0;
	    while (*fpW) {
		sprintf (buf, "  0x%03x: 0x%04x, %s\r\n", i++, *fpW, *fpW & 0x8000 ? "Leaf" : "Node");
		fpW++;
		fprintf( fh, buf );
		}
	    }
	fprintf( fh, "===== ===== =====\r\n" );
	ncNext = fdbLocal.ncLink;
	}
    else {
	sprintf(buf, "Cannot load fdb for %08lx\r\n",ncCur);
	fprintf( fh, buf );
	fclose(fh);
	return;
	}
    }
/* end dumpCmd */}


/*** fileCmd - process file command
*
*  Opens the help file specified.
*
* Input:
*  pName	= name of help file to be added
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near fileCmd (
char	*pName
) {
char	buf[BUFSIZ];
int     i;
nc	ncInit;

sprintf (buf,"Opening %s...\r\n",pName);
outtext (buf, BRIGHTWHITE);
/*
 * search file table for available slot
 */
for (i=0; i<MAXFILES; i++)
    if (!ncTbl[i].cn)
	break;
if (i >= MAXFILES) {
    sprintf(buf, "Cannot open %s: htest's open file limit exceeded\r\n",pName);
    outtext (buf, LIGHTRED);
    return;
    }

iNcCur = i;

ncInit = HelpOpen(pName);

for (i=0; i<MAXFILES; i++)
    if ((ncTbl[i].mh == ncInit.mh) && (ncTbl[i].cn == ncInit.cn)) {
	iNcCur = i;
	sprintf (buf, "File #%d; Initial Context: 0x%04lx (file already open)\r\n",iNcCur,ncInit);
	outtext (buf, BRIGHTWHITE);
	return;
	}

if (ISERROR(ncInit)) {
    sprintf(buf, "Cannot open %s: 0x%04lx, %s\r\n",pName,ncInit, errTbl[ncInit.cn]);
    outtext (buf, LIGHTRED);
    return;
    }
/*
 * output initial context, and the available memory
 */
ncCur = ncTbl[iNcCur] = ncInit;
sprintf (buf, "File #%d; Initial Context: 0x%04lx\r\n",iNcCur,ncInit.cn);
outtext (buf, BRIGHTWHITE);

lookupCmd(NULL, 0);
/* end fileCmd */}

/*** helpCmd - display help on commands
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near helpCmd () {

outtext ("HTEST - Help Engine Test Harness\r\n",			      BRIGHTWHITE);
outtext ("\r\n",							      BRIGHTWHITE);
outtext ("Comands:\r\n",						      BRIGHTWHITE);
outtext ("\r\n",							      BRIGHTWHITE);
outtext ("ctrl on/off - turn on/off display of control lines\r\n",	BRIGHTWHITE);
outtext ("disp      - display first screen of most recently read topic\r\n",  BRIGHTWHITE);
outtext ("down      - move ahead one line in topic and display\r\n",	      BRIGHTWHITE);
outtext ("dump      - dump file info (very large)\r\n", 		      BRIGHTWHITE);
outtext ("exit      - exit htest\r\n",					      BRIGHTWHITE);
outtext ("file x    - open new help file, or make help file current\r\n",     BRIGHTWHITE);
outtext ("help      - display this screen\r\n", 			      BRIGHTWHITE);
outtext ("look x    - loop up context string & fetch topic\r\n",	      BRIGHTWHITE);
outtext ("next      - fetch next physical topic\r\n",			      BRIGHTWHITE);
outtext ("prev      - fetch previous physical topic\r\n",		      BRIGHTWHITE);
outtext ("up        - move back one line in topic and display\r\n",	      BRIGHTWHITE);
outtext ("xref x    - display all xrefs in current topic, or look up #x\r\n", BRIGHTWHITE);
outtext ("+         - move & redisplay one page down\r\n",		      BRIGHTWHITE);
outtext ("-         - move & redisplay one page up\r\n",		      BRIGHTWHITE);
/* end helpCmd */}

/*** lookupCmd - process file command
*
*  Looks up the specified string in the current helpfile, or the next help
*  topic.
*
* Input:
*  pString	= help string to look up
*  dir		= direction: 0= look up string, 1=get next, -1= get previous
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near lookupCmd (
char	*pString,
int     dir
) {
char	    buf[BUFSIZ];
unsigned    cbCompressed;
unsigned    cbUncompressed;
char far    *pCompressed;
/*
 * Start with the simple look up of the conetxt to get an nc. Report on
 * failure.
 */
if (pString)
    ncCur = HelpNc(pString,ncTbl[iNcCur]);
else if (dir>0) {
    if (!ncCur.cn)
	ncCur = ncTbl[iNcCur];
    else
        ncCur = HelpNcNext(ncCur);
    }
else if (dir<0) {
    if (!ncCur.cn)
	ncCur = ncTbl[iNcCur];
    else if (ncCur.cn != ncTbl[iNcCur].cn)
        ncCur = HelpNcPrev(ncCur);
    }
else
    ncCur = ncTbl[iNcCur];

if (!ncCur.cn) {
    outtext ("Lookup Failed: HelpNc/HelpNcNext/HelpNcPrev returned 0", LIGHTRED);
    return;
    }
/*
 * It exists. Indicate what file we're looking in, what we found, and the
 * nc that was returned
 */
sprintf (buf, "File #%d; Looking up:%s\r\n",iNcCur,
	      pString ? (*pString ? pString : "local context")
		      : (dir ? ((dir>0) ? "**NEXT**" : "**PREV**")
			     : "current"));
outtext (buf, BRIGHTWHITE);
sprintf (buf, "nc returned = %08lx\r\n",ncCur.cn);
outtext (buf, BRIGHTWHITE);
/*
 * Free up memory for previously current topic
 */
if (mhTopicCur)
    free(mhTopicCur);
/*
 * Get the compressed memory size required, and report it. Alloc it.
 */
cbCompressed = HelpNcCb(ncCur);
sprintf (buf, "size of compressed topic = %d\r\n",cbCompressed);
outtext (buf, BRIGHTWHITE);
pCompressed = malloc(cbCompressed);
/*
 * read in the compressed topic, getting the size required for the
 * uncompressed results. Report that, and allocate it.
 */
cbUncompressed = HelpLook(ncCur,pCompressed);
sprintf (buf, "size of UNcompressed topic = %d\r\n",cbUncompressed);
outtext (buf, BRIGHTWHITE);
mhTopicCur = malloc(cbUncompressed);
//pTopicCur = MAKEP (mhTopicCur, 0);
pTopicCur  = mhTopicCur;
/*
 * Decompress the topic.
 */
HelpDecomp(pCompressed,pTopicCur,ncCur);
outtext ("Decompressed\r\n", BRIGHTWHITE);
/*
 * exercise SzContext and cLines routines, reporting results
 */
HelpSzContext(buf,ncCur);
strcat (buf, "\r\n");
outtext (buf, BRIGHTWHITE);
sprintf(buf,"%d lines\r\n", HelpcLines(pTopicCur));
outtext (buf, BRIGHTWHITE);
/*
 * Report the amount of available memory at this point, and then free up the
 * compressed text
 */
free(pCompressed);

/* end lookupCmd */}

/*** xrefCmd - process xref command
*
*  Display or execute cross reference
*
* Input:
*  pText    = pointer to ascii text which, if a non-zero number, indicates the
*	      xref to execute. If zero, display all
*
* Output:
*  Returns nothing
*
*************************************************************************/
void pascal near xrefCmd (
char	*pText
) {
hotspot hsCur;				/* hot spot definition		*/
int     i;                              /* working counter              */
int     iReq;                           /* request value                */
char	*pT;				/* temp pointer 		*/

iReq = atoi (pText);
hsCur.line = hsCur.col = 1;
i = 1;
while (HelpHlNext(0,pTopicCur,&hsCur)) {
/*
 * if not explicit request, then list as much as we can
 */
    if (!iReq) {
	sprintf (buf, "Xref [%d] @ line: %05d columns %02d to %02d = "
		    ,i
		    ,hsCur.line
		    ,hsCur.col
		    ,hsCur.ecol);
	pT = buf + strlen(buf);
	if (*hsCur.pXref)
	    while (*pT++ = *hsCur.pXref++);
	else
	    sprintf(pT, "Local >> topic # 0x%04x ",*(ushort far *)(hsCur.pXref+1));
	strcat (buf, "\r\n");
	outtext (buf, LIGHTGREEN);
	}
    else if (i == iReq) {
	pT = buf;
	if (*hsCur.pXref)
	    while (*pT++ = *hsCur.pXref++);
	else {
	    *pT++ = *hsCur.pXref++;
	    *pT++ = *hsCur.pXref++;
	    *pT++ = *hsCur.pXref++;
	    }
	lookupCmd (buf, 0);
	return;
	}
    ++i;
	hsCur.col = hsCur.ecol+(ushort)1;
    }
/* end xrefCmd */}

/*** outtext - output text with specific colors
*
*  sets the forground color and location as appropriate, and displays the
*  desired text. Checks for redirection, and if redirected, just outputs the
*  text to stdout.
*
* Input:
*  ptext	= pointer to text to output
*  color	= color to use
*
* Output:
*  Returns
*
*************************************************************************/
void pascal near outtext (
char	*pText,
BYTE     color
) {
outtextat (pText, curline++, 0, color);
if (curline >= lastline) {
    if (isatty(_fileno(stdout))
	&& !fBoth) {

	outtextat ("More...", lastline, 0, BRIGHTWHITE);
        // rjsa VioSetCurPos (lastline, 8, 0);
#if defined (OS2)
        consoleSetCursor(lastline,8);
#else
        consoleSetCursor(Scr,lastline,8);
#endif
	gets (buf);
	}
    curline = 0;
    cls ();
    }

/* end outtext */}

/*** outtextat - put text with specific colors at a specific place
*
*  sets the forground color and location as appropriate, and displays the
*  desired text. Checks for redirection, and if redirected, just outputs the
*  text to stdout.
*
* Input:
*  ptext	= pointer to text to output
*  col		= column to put into
*  color	= color to use
*
* Output:
*  Returns
*
*************************************************************************/
void pascal near outtextat (
char	*pText,
int     line,
int     col,
BYTE     color
) {
char    *pEol;                          /* ptr to nl, if present        */
int     len;

color |= (ColorByte & 0xf0);
if ((isatty(_fileno(stdout)) || fBoth) && (line <= lastline)) {
    len = strlen(pText);
    if (pEol = strchr (pText, '\r'))
	*pEol = 0;
    // rjsa VioWrtCharStrAtt (pText, strlen(pText), line, col, (PBYTE)&color, 0);
	WrtCharStrAtt (pText, strlen(pText), line, col, (PBYTE)&color);

    if (pEol)
	*pEol = '\r';
    }
if (!isatty(_fileno(stdout)) || fBoth)
    printf ("%s",pText);
/* end outtextat */}

/*** assertDos - asserts that a dos call returned a zero
*
*  Just prints the number passed it if non-zero, and quits
*
* Input:
*  Return code from a dos call
*
* Output:
*  Returns only if zero passed in
*
*************************************************************************/
void pascal near assertDos (
USHORT  rv,
CHAR *  pFile,
USHORT  LineNo
) {
if (rv) {
    printf ("assertDos: %u (0x%04x) File %s, line %u\n", rv, rv, pFile, LineNo);
    exit (1);
    }
/* end assertDos*/}

/*** cls - clear screen
*
*  Clear screen to current backround color
*
* Input:
*  none
*
* Output:
*  Returns screen clear
*
*************************************************************************/
void pascal near cls () {
curline = 0;
// rjsa VioScrollUp (0, 0, 0xffff, 0xffff, 0xffff, cell, 0);
consoleSetAttribute( Scr, 0x1f );
consoleClearScreen(Scr, TRUE);
/* end cls */}

/*** phrasecopy - copy a keyword phrase from the table
*
*  Copies a byte-length-prefixed string from far memory to a null terminated
*  string in near memory.
*
* Input:
*  dst		- near pointer to destination
*  src		- far pointer to source
*
* Output:
*  Returns far pointer to byte following source string
*
*************************************************************************/
uchar far * pascal near phrasecopy (
uchar	*dst,
uchar far *src
) {
register int    i;

if (i = (int)*src++)
    while (i--)
	*dst++ = *src++;
*dst = 0;
return src;
/* end phrasecopy */}



void far * pascal HelpLock(mhCur)
mh	mhCur;
{
//return MAKEP(mhCur,0);
return mhCur;
}

void pascal HelpUnlock(mhCur)
mh	mhCur;
{
	mhCur;
}

void pascal HelpDealloc(mhCur)
mh	mhCur;
{
if (mhCur)
    free(mhCur);
}




USHORT WrtCellStr (PBYTE buf, int cb, int row, int col) {
    int cl = col;
    //consoleSetCursor(Scr,row,col);
    while (cb) {
        UCHAR   c;
        UCHAR   attr;

        c = *buf++;
        attr = *buf++;

        //consoleSetAttribute(Scr,attr);
        //consoleWrite(Scr,&c,1);

        consoleWriteLine( Scr, &c, 1, row, cl, attr, FALSE );
        cl++;

		cb -= 2;
	}
    consoleShowScreen(Scr);
    return 0;
}


USHORT	WrtLineAttr ( PBYTE 	pText,
					  lineattr	*rgAttr,
					  int		cb,
					  int		row,
					  int		col
					  ) {

	lineattr *Attr	= rgAttr;
	char	 *p 	= pText;
	int 	 l = cb;
	int 	 len;

    consoleSetCursor(Scr, row, col );

	while (cb > 0) {

		if ( Attr->cb == 0xFFFF || Attr->attr == 0xFFFF ) {
			len = cb;
		} else {
			len = Attr->cb;
		}

		outtextat (p, row, col, mpAttr[Attr->attr] );
		col += len;
		p	+= len;
		cb	-= len;
		Attr++;

	}
	return (USHORT)l;
}



USHORT  WrtCharStrAtt (PBYTE pText, int cb, int row, int col, PBYTE pcolor) {
    //consoleSetCursor(Scr,row,col);
    //consoleSetAttribute(Scr,*pcolor);
    //consoleWrite( Scr,pText, cb );
    consoleWriteLine( Scr, pText, cb, row, col, *pcolor, FALSE );
    consoleShowScreen(Scr);
    return 0;
}

/**********************************************************************
 *
 *  LoadTheDll
 *
 *      Loads the help engine dll (mshelp.dll) and initializes the
 *      pointers to the dll's entry points.
 *
 **********************************************************************/

void
LoadTheDll (
    void) {


#if defined (OS2)
    USHORT  rc;
    CHAR    szFullName[256];
    CHAR    szErrorName[256];
    USHORT  i;


    strcpy(szFullName, HELPDLL_BASE);
    strcpy(szErrorName, HELPDLL_NAME);

    ASSERTDOS(rc = DosLoadModule(szErrorName,
                       256,
                       szFullName,
                       &hModule));


    for (i=0; i<LASTENTRYPOINT; i++) {
        ASSERTDOS (rc = DosQueryProcAddr(hModule,
                                         0L,
                                         szEntryName[i],
                                         (PFN*)&(pEntry[i])));
    }
#else

#if defined (HELP_HACK)

	//pEntry[0] =	(PHF)HelpcLines;
	//pEntry[1] =	(PHF)HelpClose;
	//pEntry[2] =	(PHF)HelpCtl;
	//pEntry[3] =	(PHF)HelpDecomp;
	//pEntry[4] =	(PHF)HelpGetCells;
	//pEntry[5] =	(PHF)HelpGetInfo;
	//pEntry[6] =	(PHF)HelpGetLine;
	//pEntry[7] =	(PHF)HelpGetLineAttr;
	//pEntry[8] =	(PHF)HelpHlNext;
	//pEntry[9] =	(PHF)HelpLook;
	//pEntry[10] =	(PHF)HelpNc;
	//pEntry[11] =	(PHF)HelpNcBack;
	//pEntry[12] =	(PHF)HelpNcCb;
	//pEntry[13] =	(PHF)HelpNcCmp;
	//pEntry[14] =	(PHF)HelpNcNext;
	//pEntry[15] =	(PHF)HelpNcPrev;
	//pEntry[16] =	(PHF)HelpNcRecord;
	//pEntry[17] =	(PHF)HelpNcUniq;
	//pEntry[18] =	(PHF)HelpOpen;
	//pEntry[19] =	(PHF)HelpShrink;
	//pEntry[20] =	(PHF)HelpSzContext;
	//pEntry[21] =	(PHF)HelpXRef;
	//pEntry[22] =	(PHF)LoadFdb;
	//pEntry[23] =	(PHF)LoadPortion;



#else
    USHORT  i;
    hModule = LoadLibrary(HELPDLL_NAME);
    for (i=0; i<LASTENTRYPOINT; i++) {
        pEntry[i] = (PHF)GetProcAddress(hModule, (LPSTR)szEntryName[i]);
	}
#endif

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\enginlib\hloc.c ===
/**************************************************************************
 *hlp_locate - locate line in help text
 *
 *       Copyright <C> 1988, Microsoft Corporation
 *
 * Purpose:
 *
 * Revision History:
 *
 *       17-OCt-1990     RJSA    translated to C
 *       25-Jan-1990     LN      renamed to hlp_locate
 *       22-Dec-1988     LN      Removed MASM High Level Lang support (Need
 *                               to control segments better than that will
 *                               let me)
 *       08-Dec-1988     LN      CSEG
 *  []   18-Aug-1988     LN      Created
 *
 *
 **************************************************************************/

#include <stdio.h>
#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include <help.h>
#include <helpfile.h>
#include <helpsys.h>



/**** hlp_locate - locate a line in the buffer
 * uchar far * near pascal hlp_locate(
 * ushort    ln,
 * uchar far *pTopic
 * )
 *
 * Purpose:
 *  commonly used routine to find a line in the topic text.
 *
 * Entry:
 *  ln            = 1 based line number to look for (-1 means return number
 *                  of lines in topic)
 *  pTopic        = Topic text to look for it in
 *
 * Exit:
 *  returns pointer to start of line
 *
 * Exceptions:
 *  returns NULL on not found
 *
 **************************************************************************/

PCHAR pascal
hlp_locate (
    SHORT  ln,
    PCHAR  pTopic
    ){

    struct topichdr UNALIGNED *pT     = (struct topichdr *)pTopic;
    PBYTE           pSrc    = (PBYTE)pTopic;
    SHORT           lnOrig  = ln;

    if (pT->lnCur <= (USHORT)ln) {

        // Use last past position calculated

        ln -= (pT->lnCur );
        pSrc += pT->lnOff;

    } else {

        // Start from beginning

        pSrc += sizeof(struct topichdr);
    }

    if (pT->ftype & FTCOMPRESSED) {

        //  Compressed file. Walk over each text\attribute pair
        //  until the desired line is found.

        while ( *pSrc  && ln) {

            pSrc += *pSrc;
            pSrc += *(USHORT UNALIGNED *)pSrc;

            if ( *pSrc && *(pSrc+1) != pT->linChar ) {
                ln--;
            }
        }

        //while (*pSrc && ln) {
        //
        //    if (*(pSrc + 1) != pT->linChar) {
        //        ln--;
        //    }
        //    pSrc += *pSrc;
        //    pSrc += *(PUSHORT)pSrc;
        //}

    } else {

        // ASCII file

        while (*pSrc && ln) {
            if (*pSrc != pT->linChar) {
                ln--;
            }

            while (*pSrc && *pSrc != 0x0A) {
                pSrc++;
            }
            if (*pSrc)
                pSrc++;
        }
    }

    if (*pSrc) {

        // Line found. Update the topic hdr with the pointers to the text
        // and line number that we just found, to help speed us up next time.

        pT->lnOff = (USHORT)((PBYTE)pSrc - (PBYTE)pT);
        pT->lnCur = lnOrig;

    } else {

        //
        //  Line not found. Update nothing and return NULL
        //  (Side Effect: line requested (ln) - line count left (ln) is the
        //  number of  lines in the topic! If original ln is -1, we'll return
        //  that instead!

        if (lnOrig == -1)
            pSrc = (PBYTE)IntToPtr(lnOrig - ln);
        else
            pSrc = (PBYTE)0L;
   }

    return pSrc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\htest\cons.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.c

Abstract:

    Interface to the console for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/

#include <string.h>
#include <malloc.h>
#include <assert.h>
#include <windows.h>

#define  FREE(x)        free(x)
#define  MALLOC(x)      malloc(x)
#define  REALLOC(x,y)   realloc(x,y)

#include "cons.h"



//
//  EVENT BUFFER
//
//   The event buffer is used to store event records from the input
//   queue.
//
#define     INITIAL_EVENTS	32
#define     MAX_EVENTS		64
#define     EVENT_INCREMENT	4

#define     ADVANCE		TRUE
#define     NOADVANCE		FALSE
#define     WAIT		TRUE
#define     NOWAIT		FALSE

//
//  For accessing fields of an event record
//
#define     EVENT_TYPE(p)   ((p)->EventType)
#define     EVENT_DATA(p)   ((p)->Event)

//
//  For casting event records
//
#define     PMOUSE_EVT(p)   (&(EVENT_DATA(p).MouseEvent))
#define     PWINDOW_EVT(p)  (&(EVENT_DATA(p).WindowBufferSizeEvent))
#define     PKEY_EVT(p)     (&(EVENT_DATA(p).KeyEvent))

//
//  The event buffer structure
//
typedef struct EVENT_BUFFER {
    DWORD		MaxEvents;		    //	Max number of events in buffer
    DWORD		NumberOfEvents; 	    //	Number of events in buffer
    DWORD		EventIndex;		    //	Event Index
    BOOL		BusyFlag;		    //	Busy flag
    CRITICAL_SECTION	CriticalSection;	    //	To maintain integrity
    CRITICAL_SECTION	PeekCriticalSection;	    //	While peeking
    PINPUT_RECORD	EventBuffer;		    //	Event Buffer
} EVENT_BUFFER, *PEVENT_BUFFER;





//
//  Screen attributes
//
#define     BLACK_FGD	    0
#define     BLUE_FGD	    FOREGROUND_BLUE
#define     GREEN_FGD	    FOREGROUND_GREEN
#define     CYAN_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN)
#define     RED_FGD	    FOREGROUND_RED
#define     MAGENTA_FGD     (FOREGROUND_BLUE | FOREGROUND_RED)
#define     YELLOW_FGD	    (FOREGROUND_GREEN | FOREGROUND_RED)
#define     WHITE_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)

#define     BLACK_BGD	    0
#define     BLUE_BGD	    BACKGROUND_BLUE
#define     GREEN_BGD	    BACKGROUND_GREEN
#define     CYAN_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN)
#define     RED_BGD	    BACKGROUND_RED
#define     MAGENTA_BGD     (BACKGROUND_BLUE | BACKGROUND_RED)
#define     YELLOW_BGD	    (BACKGROUND_GREEN | BACKGROUND_RED)
#define     WHITE_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED)



//
//  The AttrBg and AttrFg arrays are used for mapping DOS attributes
//  to the new attributes.
//
WORD AttrBg[ ] = {
    BLACK_BGD,				    // black
    BLUE_BGD,				    // blue
    GREEN_BGD,				    // green
    CYAN_BGD,				    // cyan
    RED_BGD,				    // red
    MAGENTA_BGD,			    // magenta
    YELLOW_BGD, 			    // brown
    WHITE_BGD,				    // light gray
    BACKGROUND_INTENSITY | BLACK_BGD,	    // dark gray
    BACKGROUND_INTENSITY | BLUE_BGD,	    // light blue
    BACKGROUND_INTENSITY | GREEN_BGD,	    // light green
    BACKGROUND_INTENSITY | CYAN_BGD,	    // light cyan
    BACKGROUND_INTENSITY | RED_BGD,	    // light red
    BACKGROUND_INTENSITY | MAGENTA_BGD,     // light magenta
    BACKGROUND_INTENSITY | YELLOW_BGD,	    // light yellow
    BACKGROUND_INTENSITY | WHITE_BGD	    // white
};

WORD AttrFg[  ] = {
    BLACK_FGD,				    // black
    BLUE_FGD,				    // blue
    GREEN_FGD,				    // green
    CYAN_FGD,				    // cyan
    RED_FGD,				    // red
    MAGENTA_FGD,			    // magenta
    YELLOW_FGD, 			    // brown
    WHITE_FGD,				    // light gray
    FOREGROUND_INTENSITY | BLACK_FGD,	    // dark gray
    FOREGROUND_INTENSITY | BLUE_FGD,	    // light blue
    FOREGROUND_INTENSITY | GREEN_FGD,	    // light green
    FOREGROUND_INTENSITY | CYAN_FGD,	    // light cyan
    FOREGROUND_INTENSITY | RED_FGD,	    // light red
    FOREGROUND_INTENSITY | MAGENTA_FGD,     // light magenta
    FOREGROUND_INTENSITY | YELLOW_FGD,	    // light yellow
    FOREGROUND_INTENSITY | WHITE_FGD	    // white
};

//
//  GET_ATTRIBUTE performs the mapping from old attributes to new attributes
//
#define GET_ATTRIBUTE(x)    (AttrFg[x & 0x000F ] | AttrBg[( x & 0x00F0 ) >> 4])


//
//  The LINE_INFO structure contains information about each line in the
//  screen buffer.
//
typedef struct _LINE_INFO {

    BOOL	Dirty;			    //	True if has not been displayed
    int 	colMinChanged;		    //	if dirty, smallest col changed
    int 	colMaxChanged;		    //	if dirty, biggest col changed
    PCHAR_INFO	Line;			    //	Pointer to the line.

} LINE_INFO, *PLINE_INFO;

#define ResetLineInfo(pli)		    \
	{   pli->Dirty = 0;		    \
	    pli->colMinChanged = 1000;	    \
	    pli->colMaxChanged = -1;	    \
	}

//
//  The SCREEN_DATA structure contains the information about individual
//  screens.
//
typedef struct SCREEN_DATA {
    HANDLE		ScreenHandle;	    //	Handle to screen
    PLINE_INFO		LineInfo;	    //	Array of line info.
    PCHAR_INFO		ScreenBuffer;	    //	Screen buffer
    ULONG		MaxBufferSize;	    //	Max. buffer size
    ATTRIBUTE		AttributeOld;	    //	Attribute - original
    WORD		AttributeNew;	    //	Attribute - converted
    ROW 		FirstRow;	    //	First row to update
    ROW 		LastRow;	    //	Last row to update
    CRITICAL_SECTION	CriticalSection;    //	To maintain integrity
    DWORD		CursorSize;	    //	Cursor Size
    SCREEN_INFORMATION	ScreenInformation;  //	Screen information
} SCREEN_DATA, *PSCREEN_DATA;


//
//  Static global data
//
static EVENT_BUFFER	EventBuffer;		    //	Event buffer
static HANDLE		hInput; 		    //	handle to stdin
static HANDLE		hOutput;		    //	handle to stdout
static HANDLE		hError; 		    //	handle to stderr
static PSCREEN_DATA	OutputScreenData;	    //	Screen data for hOutput
static PSCREEN_DATA	ActiveScreenData;	    //	Points to current screen data
static BOOL		Initialized = FALSE;	    //	Initialized flag


#if defined (DEBUG)
    static char DbgBuffer[128];
#endif


//
//  Local Prototypes
//
BOOL
InitializeGlobalState (
    void
    );


PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    );

BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    );

PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    );

void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    );

BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    );

BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    );


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    );


BOOL
InitializeGlobalState (
    void
    )
/*++

Routine Description:

    Initializes our global state data.

Arguments:

    None.

Return Value:

    TRUE if success
    FALSE otherwise.

--*/
{


    //
    //	Initialize the event buffer
    //
    InitializeCriticalSection( &(EventBuffer.CriticalSection) );
    InitializeCriticalSection( &(EventBuffer.PeekCriticalSection) );
    EventBuffer.NumberOfEvents	= 0;
    EventBuffer.EventIndex	= 0;
    EventBuffer.BusyFlag	= FALSE;
    EventBuffer.EventBuffer = MALLOC( INITIAL_EVENTS * sizeof(INPUT_RECORD) );

    if ( !EventBuffer.EventBuffer ) {
	return FALSE;
    }

    EventBuffer.MaxEvents = INITIAL_EVENTS;


    //
    //	Get handles to stdin, stdout and stderr
    //
    hInput  = GetStdHandle( STD_INPUT_HANDLE );
    hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    hError  = GetStdHandle( STD_ERROR_HANDLE );


    //
    //	Initialize the screen data for hOutput
    //
    if ( !(OutputScreenData = MakeScreenData( hOutput )) ) {
	return FALSE;
    }


    //
    //	Current screen is hOutput
    //
    ActiveScreenData = OutputScreenData;


    return (Initialized = TRUE);

}





PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    )
/*++

Routine Description:

    Allocates memory for a SCREEN_DATA information and initializes it.

Arguments:

    ScreenHandle    -	Supplies handle of screen.

Return Value:

    POINTER to allocated SCREEN_DATA structure

--*/
{
    PSCREEN_DATA		ScreenData;	//  Pointer to screen data
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.


    //
    //	Allocate space for the screen data.
    //
    if ( !(ScreenData = (PSCREEN_DATA)MALLOC(sizeof(SCREEN_DATA))) ) {
	return NULL;
    }

    //
    //	Allocate space for our copy of the screen buffer.
    //
    GetConsoleScreenBufferInfo( ScreenHandle,
				&ScrInfo );

    ScreenData->MaxBufferSize = ScrInfo.dwSize.Y    *
				ScrInfo.dwSize.X;

    ScreenData->ScreenBuffer = (PCHAR_INFO)MALLOC( ScreenData->MaxBufferSize *
						    sizeof(CHAR_INFO));

    if ( !ScreenData->ScreenBuffer ) {
	FREE( ScreenData );
	return NULL;
    }

    //
    //	Allocate space for the LineInfo array
    //
    ScreenData->LineInfo = (PLINE_INFO)MALLOC( ScrInfo.dwSize.Y * sizeof( LINE_INFO ) );
    if ( !ScreenData->LineInfo ) {
	FREE( ScreenData->ScreenBuffer );
	FREE( ScreenData );
	return NULL;
    }


    //
    //	Memory has been allocated, now initialize the structure
    //
    ScreenData->ScreenHandle = ScreenHandle;

    ScreenData->ScreenInformation.NumberOfRows = ScrInfo.dwSize.Y;
    ScreenData->ScreenInformation.NumberOfCols = ScrInfo.dwSize.X;

    ScreenData->ScreenInformation.CursorRow = ScrInfo.dwCursorPosition.Y;
    ScreenData->ScreenInformation.CursorCol = ScrInfo.dwCursorPosition.X;

    ScreenData->AttributeNew = ScrInfo.wAttributes;
    ScreenData->AttributeOld = 0x00;

    ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow  = 0;

    InitializeCriticalSection( &(ScreenData->CriticalSection) );

    InitLineInfo( ScreenData );

    return ScreenData;
}





BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    )
/*++

Routine Description:

    Initializes the LineInfo array.

Arguments:

    ScreenData	    -	Supplies pointer to screen data.

Return Value:

    TRUE if initialized, false otherwise.

--*/
{

    ROW 	Row;
    COLUMN	Cols;
    PLINE_INFO	LineInfo;
    PCHAR_INFO	CharInfo;


    LineInfo = ScreenData->LineInfo;
    CharInfo = ScreenData->ScreenBuffer;
    Row      = ScreenData->ScreenInformation.NumberOfRows;
    Cols     = ScreenData->ScreenInformation.NumberOfCols;

    while ( Row-- ) {

	//
	//  BUGBUG Temporary
	//
	// assert( LineInfo < (ScreenData->LineInfo + ScreenData->ScreenInformation.NumberOfRows));
	// assert( (CharInfo + Cols) <= (ScreenData->ScreenBuffer + ScreenData->MaxBufferSize) );

	ResetLineInfo (LineInfo);

	LineInfo->Line	    = CharInfo;

	LineInfo++;
	CharInfo += Cols;

    }

    return TRUE;
}





PSCREEN
consoleNewScreen (
    void
    )
/*++

Routine Description:

    Creates a new screen.

Arguments:

    None.

Return Value:

    Pointer to screen data.

--*/
{
    PSCREEN_DATA		ScreenData;	   //  Screen data
    HANDLE			NewScreenHandle;
    SMALL_RECT			NewSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.
    CONSOLE_CURSOR_INFO 	CursorInfo;

    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if ( !InitializeGlobalState() ) {
	    return NULL;
	}
    }

    //
    //	Create a new screen buffer
    //
    NewScreenHandle = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						CONSOLE_TEXTMODE_BUFFER,
						NULL );

    if (NewScreenHandle == INVALID_HANDLE_VALUE) {
	//
	//  No luck
	//
	return NULL;
    }

    //
    //	We want the new window to be the same size as the current one, so
    //	we resize it.
    //
    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    NewSize.Left    = 0;
    NewSize.Top     = 0;
    NewSize.Right   = ScrInfo.srWindow.Right - ScrInfo.srWindow.Left;
    NewSize.Bottom  = ScrInfo.srWindow.Bottom - ScrInfo.srWindow.Top;

    SetConsoleWindowInfo( NewScreenHandle, TRUE, &NewSize );

    //
    //	Now we create a screen data structure for it.
    //
    if ( !(ScreenData = MakeScreenData(NewScreenHandle)) ) {
	CloseHandle(NewScreenHandle);
	return NULL;
    }


    CursorInfo.bVisible = TRUE;
    ScreenData->CursorSize = CursorInfo.dwSize = 25;

    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
			   &CursorInfo );

    //
    //	We are all set. We return a pointer to the
    //	screen data.
    //
    return (PSCREEN)ScreenData;
}





BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Closes a screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if screen closed.
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    //
    //	We cannot close the active screen
    //
    if ( !ScreenData || (ScreenData == ActiveScreenData) ) {
	return FALSE;
    }

    if (ScreenData->ScreenHandle != INVALID_HANDLE_VALUE) {
	CloseHandle(ScreenData->ScreenHandle);
    }

    FREE( ScreenData->LineInfo );
    FREE( ScreenData->ScreenBuffer );
    FREE( ScreenData );

    return TRUE;
}





PSCREEN
consoleGetCurrentScreen (
    void
    )
/*++

Routine Description:

    Returns the current screen.

Arguments:

    none.

Return Value:

    Pointer to currently active screen data.

--*/
{
    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if (!InitializeGlobalState()) {
	    return NULL;
	}
    }

    return (PSCREEN)ActiveScreenData;
}





BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if the active screen set
    FALSE otherwise.

--*/
{
    BOOL	    ScreenSet	  = TRUE;
    PSCREEN_DATA    CurrentScreen = ActiveScreenData;


    EnterCriticalSection( &(CurrentScreen->CriticalSection) );

    ScreenSet = SetConsoleActiveScreenBuffer( ((PSCREEN_DATA)pScreen)->ScreenHandle);

    if (ScreenSet) {
	ActiveScreenData = (PSCREEN_DATA)pScreen;
    }

    LeaveCriticalSection( &(CurrentScreen->CriticalSection) );

    return ScreenSet;
}





BOOL
consoleGetScreenInformation (
    PSCREEN            pScreen,
    PSCREEN_INFORMATION    pScreenInfo
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen	-   Supplies pointer to screen data.
    pScreenInfo -   Supplies pointer to screen info buffer

Return Value:

    TRUE if the screen info returned
    FALSE otherwise.

--*/
{

    PSCREEN_DATA ScreenData = (PSCREEN_DATA)pScreen;

    if (!ScreenData) {
	return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    memcpy(pScreenInfo, &(ScreenData->ScreenInformation), sizeof(SCREEN_INFORMATION));

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}



BOOL
consoleSetScreenSize (
    PSCREEN pScreen,
    ROW Rows,
    COLUMN  Cols
    )
/*++

Routine Description:

    Sets the screen size

Arguments:

    pScreen	-   Supplies pointer to screen data.
    Rows	-   Number of rows
    Cols	-   Number of columns

Return Value:

    TRUE if screen size changed successfully
    FALSE otherwise.

--*/
{

    PSCREEN_DATA		ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_SCREEN_BUFFER_INFO	ScreenBufferInfo;
    SMALL_RECT			ScreenRect;
    COORD			ScreenSize;
    USHORT			MinRows;
    USHORT			MinCols;
    ULONG			NewBufferSize;
    BOOL			WindowSet   = FALSE;
    BOOL			Status	    = FALSE;

    //
    //	Won't attempt to resize larger than the largest window size
    //
    ScreenSize = GetLargestConsoleWindowSize( ScreenData->ScreenHandle );

    if ( (Rows > (ROW)ScreenSize.Y) || (Cols > (COLUMN)ScreenSize.X) ) {
	return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    //
    //	Obtain the current screen information.
    //
    if ( GetConsoleScreenBufferInfo( ScreenData->ScreenHandle, &ScreenBufferInfo ) ) {

	//
	//  If the desired buffer size is smaller than the current window
	//  size, we have to resize the current window first.
	//
	if ( ( Rows < (ROW)
		       (ScreenBufferInfo.srWindow.Bottom -
			ScreenBufferInfo.srWindow.Top + 1) ) ||
	     ( Cols < (COLUMN)
		       (ScreenBufferInfo.srWindow.Right -
			ScreenBufferInfo.srWindow.Left + 1) ) ) {

	    //
	    //	Set the window to a size that will fit in the current
	    //	screen buffer and that is no bigger than the size to
	    //	which we want to grow the screen buffer.
	    //
	    MinRows = (USHORT)min( (int)Rows, (int)(ScreenBufferInfo.dwSize.Y) );
	    MinCols = (USHORT)min( (int)Cols, (int)(ScreenBufferInfo.dwSize.X) );

	    ScreenRect.Top	= 0;
	    ScreenRect.Left	= 0;
	    ScreenRect.Right	= (SHORT)MinCols - (SHORT)1;
	    ScreenRect.Bottom	= (SHORT)MinRows - (SHORT)1;

	    WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

	    if ( !WindowSet ) {
		//
		//  ERROR
		//
		goto Done;
	    }
	}

	//
	//  Set the screen buffer size to the desired size.
	//
	ScreenSize.X = (WORD)Cols;
	ScreenSize.Y = (WORD)Rows;

	if ( !SetConsoleScreenBufferSize( ScreenData->ScreenHandle, ScreenSize ) ) {

	    //
	    //	ERROR
	    //
	    //
	    //	Return the window to its original size. We ignore the return
	    //	code because there is nothing we can do about it.
	    //
	    SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &(ScreenBufferInfo.srWindow) );

	    goto Done;
	}

	//
	//  resize the screen buffer. Note that the contents of the screen
	//  buffer are not valid anymore. Someone else will have to update
	//  them.
	//
	NewBufferSize = Rows * Cols;

	if (ScreenData->MaxBufferSize < NewBufferSize ) {
	    ScreenData->ScreenBuffer = REALLOC( ScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
	    ScreenData->MaxBufferSize = NewBufferSize;
	    ScreenData->LineInfo = REALLOC( ScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
	}

	//
	//  Set the Window Size. We know that we can grow the window to this size
	//  because we tested the size against the largest window size at the
	//  beginning of the function.
	//
	ScreenRect.Top	    = 0;
	ScreenRect.Left     = 0;
	ScreenRect.Right    = (SHORT)Cols - (SHORT)1;
	ScreenRect.Bottom   = (SHORT)Rows - (SHORT)1;

	WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

	if ( !WindowSet ) {
	    //
	    //	We could not resize the window. We will leave the
	    //	resized screen buffer.
	    //
	    //	ERROR
	    //
	    goto Done;
	}

	//
	//  Update the screen size
	//
	ScreenData->ScreenInformation.NumberOfRows = Rows;
	ScreenData->ScreenInformation.NumberOfCols = Cols;

	InitLineInfo( ScreenData );

	//
	//  Done
	//
	Status = TRUE;

    } else {

	//
	//  ERROR
	//
    }

Done:
    //
    //	Invalidate the entire screen buffer
    //
    ScreenData->FirstRow    = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow     = 0;

    LeaveCriticalSection( &(ScreenData->CriticalSection) );
    return Status;

}




BOOL
consoleSetCursor (
    PSCREEN pScreen,
    ROW Row,
    COLUMN  Col
    )
/*++

Routine Description:

    Moves the cursor to a certain position.

Arguments:

    pScreen -	Supplies pointer to screen data
    Row     -	Supplies row coordinate
    Col     -	Supplies column coordinate

Return Value:

    TRUE if moved
    FALSE otherwise.

--*/
{

    PSCREEN_DATA    ScreenData	= (PSCREEN_DATA)pScreen;
    COORD	    Position;
    BOOL	    Moved	= FALSE;


    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ((Row != ScreenData->ScreenInformation.CursorRow) ||
	(Col != ScreenData->ScreenInformation.CursorCol) ) {

	assert( Row < ScreenData->ScreenInformation.NumberOfRows);
	assert( Col < ScreenData->ScreenInformation.NumberOfCols);

	Position.Y = (SHORT)Row;
	Position.X = (SHORT)Col;

	if ( SetConsoleCursorPosition( ScreenData->ScreenHandle,
				       Position )) {
	    //
	    //	Cursor moved, update the data
	    //
	    ScreenData->ScreenInformation.CursorRow    =   Row;
	    ScreenData->ScreenInformation.CursorCol    =   Col;

	    Moved = TRUE;
	}
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Moved;
}




BOOL
consoleSetCursorStyle (
    PSCREEN pScreen,
    ULONG   Style
    )

/*++

Routine Description7:

    Sets the cursor style. The two available styles are: underscrore and
    box

Arguments:

    Style	-   New cursor style

Return Value:

    True if cursor style set

--*/

{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;

    CursorInfo.bVisible = TRUE;

    if ( Style == CURSOR_STYLE_UNDERSCORE ) {

	CursorInfo.dwSize = 25;

    } else if ( Style == CURSOR_STYLE_BOX ) {

	CursorInfo.dwSize = 100;

    } else {

	return FALSE;

    }

    ScreenData->CursorSize = CursorInfo.dwSize;

    return SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				  &CursorInfo );

}





ULONG
consoleWriteLine (
    PSCREEN     pScreen,
    PVOID       pBuffer,
    ULONG       BufferSize,
    ROW     Row,
    COLUMN      Col,
    ATTRIBUTE   Attribute,
    BOOL        Blank
    )
/*++

Routine Description7:

    Writes a buffer to the screen with the specified attribute and blanks
    to end of row.

Arguments:

    pScreen	-   Supplies pointer to screen data
    pBuffer	-   Supplies pointer to buffer
    BufferSize	-   Supplies the size of the buffer
    Row 	-   Supplies row coordinate
    Col 	-   Supplies column coordinate
    Attr	-   Supplies the attribute
    Blank	-   TRUE if we should blank to end of last row written.

Return Value:

    Number of bytes written

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    PLINE_INFO	    LineInfo;
    PCHAR_INFO	    CharInfo;
    CHAR_INFO	    Char;
    WORD	    Attr;

    char *	    p = (char *)pBuffer;

    COLUMN	    ColsLeft;	    //	Available columns
    COLUMN	    InfoCols;	    //	Columns taken from buffer
    COLUMN	    BlankCols;	    //	Columns to be blanked
    COLUMN	    Column;	    //	Counter;

    //
    //	We will ignore writes outside of the screen buffer
    //
    if ( ( Row >= ScreenData->ScreenInformation.NumberOfRows ) ||
	 ( Col >= ScreenData->ScreenInformation.NumberOfCols ) ) {
	return TRUE;
    }

    //
    //	Ignore trivial writes
    //

    if (BufferSize == 0 && !Blank)
	return TRUE;


    EnterCriticalSection( &(ScreenData->CriticalSection) );

    //
    //	We will truncate writes that are too long
    //
    if ( (Col + BufferSize) >= ScreenData->ScreenInformation.NumberOfCols ) {
	BufferSize = ScreenData->ScreenInformation.NumberOfCols - Col;
    }

    LineInfo = ScreenData->LineInfo + Row;
    CharInfo = LineInfo->Line + Col;

    ColsLeft  = ScreenData->ScreenInformation.NumberOfCols - Col;
    InfoCols  = min( BufferSize, ColsLeft );
    BlankCols = Blank ? (ColsLeft - InfoCols) : 0;

    //
    //	Set the attribute
    //
    if ( Attribute != ScreenData->AttributeOld ) {
	ScreenData->AttributeOld  = Attribute;
	ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }
    Attr = ScreenData->AttributeNew;

    //
    //	set up default attribute
    //

    Char.Attributes = Attr;

    //
    //	set up number of columns to draw
    //

    Column = InfoCols;

    //
    //	draw chars in all specified columns
    //

    while ( Column-- ) {

	//
	//  use character from input string
	//

	Char.Char.AsciiChar = *p++;

	//
	//  update change portions of line info
	//

	if (CharInfo->Attributes != Char.Attributes ||
	    CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

	    LineInfo->colMinChanged = min (LineInfo->colMinChanged, CharInfo - LineInfo->Line);
	    LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, CharInfo - LineInfo->Line);
	    LineInfo->Dirty = TRUE;
	    }

	//
	//  set up new character
	//

	*CharInfo++ = Char;
    }


    //
    //	Blank to end of line
    //
    Char.Attributes	= Attr;
    Char.Char.AsciiChar = ' ';
    Column = BlankCols;
    while ( Column-- ) {
	//
	//  update change portions of line info
	//

	if (CharInfo->Attributes != Char.Attributes ||
	    CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

	    LineInfo->colMinChanged = min (LineInfo->colMinChanged, CharInfo - LineInfo->Line);
	    LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, CharInfo - LineInfo->Line);
	    LineInfo->Dirty = TRUE;
	    }

	*CharInfo++ = Char;
    }

    //
    //	Update row information
    //
    if ( Row < ScreenData->FirstRow ) {
	ScreenData->FirstRow = Row;
    }
    if ( Row > ScreenData->LastRow ) {
	ScreenData->LastRow = Row;
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return (ULONG)(InfoCols + BlankCols);
}





BOOL
consoleShowScreen (
    PSCREEN     pScreen
    )
/*++

Routine Description:

    Moves data from our screen buffer to the console screen buffer.

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if done
    FALSE otherwise

--*/
{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;
    PLINE_INFO		LineInfo;
    BOOL		Shown	   = FALSE;
    ROW 		FirstRow;
    ROW 		LastRow;
    COLUMN		LastCol;

    COORD		Position;
    COORD		Size;
    SMALL_RECT		Rectangle;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ( ScreenData->FirstRow <= ScreenData->LastRow ) {

	Size.X = (SHORT)(ScreenData->ScreenInformation.NumberOfCols);
	Size.Y = (SHORT)(ScreenData->ScreenInformation.NumberOfRows);

	FirstRow = ScreenData->FirstRow;
	LineInfo = ScreenData->LineInfo + FirstRow;

	LastCol  = ScreenData->ScreenInformation.NumberOfCols-1;

	//
	//  Find next dirty block
	//
	while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
	    FirstRow++;
	    LineInfo++;
	}

	while ( FirstRow <= ScreenData->LastRow ) {

	    int colLeft, colRight;

	    //
	    //	Get the block
	    //

	    LastRow  = FirstRow;

	    //
	    //	set up for left/right boundary accrual
	    //

	    colLeft = LastCol + 1;
	    colRight = -1;

	    while ( (LastRow <= ScreenData->LastRow) && LineInfo->Dirty ) {

		//
		//  accrue smallest bounding right/left margins
		//

		colLeft = min (colLeft, LineInfo->colMinChanged);
		colRight = max (colRight, LineInfo->colMaxChanged);

		//
		//  reset line information
		//

		ResetLineInfo (LineInfo);

		//
		//  advance to next row
		//

		LastRow++;
		LineInfo++;
	    }
	    LastRow--;


	    //
	    //	Write the block
	    //
	    assert( FirstRow <= LastRow );

	    Position.X = (SHORT)colLeft;
	    Position.Y = (SHORT)FirstRow;

	    Rectangle.Top    = (SHORT)FirstRow;
	    Rectangle.Bottom = (SHORT)LastRow;
	    Rectangle.Left = (SHORT) colLeft;
	    Rectangle.Right = (SHORT) colRight;

	    //
	    //	Performance hack: making the cursor invisible speeds
	    //	screen updates.
	    //
	    CursorInfo.bVisible = FALSE;
	    CursorInfo.dwSize	= ScreenData->CursorSize;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    Shown = WriteConsoleOutput( ScreenData->ScreenHandle,
					ScreenData->ScreenBuffer,
					Size,
					Position,
					&Rectangle );

#if defined (DEBUG)
	    if ( !Shown ) {
		char DbgB[128];
		sprintf(DbgB, "MEP: WriteConsoleOutput Error %d\n", GetLastError() );
		OutputDebugString( DbgB );
	    }
#endif
	    assert( Shown );

	    CursorInfo.bVisible = TRUE;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    FirstRow = LastRow + 1;

	    //
	    //	Find next dirty block
	    //
	    while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
		FirstRow++;
		LineInfo++;
	    }
	}

	ScreenData->LastRow  = 0;
	ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;

    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Shown;

}





BOOL
consoleClearScreen (
    PSCREEN     pScreen,
    BOOL        ShowScreen
    )
/*++

Routine Description:

	Clears the screen

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if screen cleared
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    ROW 	    Rows;
    BOOL	    Status = TRUE;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    Rows = ScreenData->ScreenInformation.NumberOfRows;

    while ( Rows-- ) {
	consoleWriteLine( pScreen, NULL, 0, Rows, 0, ScreenData->AttributeOld, TRUE );
    }

    if (ShowScreen) {
	Status = consoleShowScreen( pScreen );
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Status;
}







BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    )
/*++

Routine Description:

    Sets the console attribute

Arguments:

    pScreen	-   Supplies pointer to screen data
    Attribute	-   Supplies the attribute

Return Value:

    TRUE if Attribute set
    FALSE otherwise

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if (Attribute != ScreenData->AttributeOld) {
	ScreenData->AttributeOld = Attribute;
	ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}









BOOL
consoleFlushInput (
    void
    )
/*++

Routine Description:

    Flushes input events.

Arguments:

    None.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    EventBuffer.NumberOfEvents = 0;

    return FlushConsoleInputBuffer( hInput );
}







BOOL
consoleGetMode (
    PKBDMODE pMode
    )
/*++

Routine Description:

    Get current console mode.

Arguments:

    pMode   -	Supplies a pointer to the mode flag variable

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    return GetConsoleMode( hInput,
			   pMode );
}






BOOL
consoleSetMode (
    KBDMODE Mode
    )
/*++

Routine Description:

    Sets the console mode.

Arguments:

    Mode    -	Supplies the mode flags.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    return SetConsoleMode( hInput,
			   Mode );
}


BOOL
consoleIsKeyAvailable (
    void
    )
/*++

Routine Description:

    Returns TRUE if a key is available in the event buffer.

Arguments:

    None.

Return Value:

    TRUE if a key is available in the event buffer
    FALSE otherwise

--*/

{
    BOOL	    IsKey = FALSE;
    PINPUT_RECORD   pEvent;
    DWORD	    Index;

    EnterCriticalSection( &(EventBuffer.CriticalSection) );

    for ( Index = EventBuffer.EventIndex; Index < EventBuffer.NumberOfEvents; Index++ ) {

	pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

	if ( ((EVENT_TYPE(pEvent)) == KEY_EVENT) &&
	     (PKEY_EVT(pEvent))->bKeyDown ) {
	    IsKey = TRUE;
	    break;
	}
    }

    LeaveCriticalSection( &(EventBuffer.CriticalSection) );

    return IsKey;
}




BOOL
consoleDoWindow (
    void
    )

/*++

Routine Description:

    Responds to a window event

Arguments:

    None.

Return Value:

    TRUE if window changed
    FALSE otherwise

--*/

{

    PINPUT_RECORD   pEvent;

    pEvent = NextEvent( NOADVANCE, NOWAIT );

    if (( EVENT_TYPE(pEvent) ) == WINDOW_BUFFER_SIZE_EVENT) {

	pEvent = NextEvent( ADVANCE, WAIT );
	WindowEvent(PWINDOW_EVT(pEvent));
    }

    return FALSE;

}





BOOL
consolePeekKey (
    PKBDKEY Key
    )

/*++

Routine Description:

    Gets the next key from the input buffer if the buffer is not empty.


Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/

{

    PINPUT_RECORD   pEvent;
    BOOL	    Done    = FALSE;
    BOOL	    IsKey   = FALSE;

    EnterCriticalSection(&(EventBuffer.PeekCriticalSection));

    do {

	pEvent = NextEvent( NOADVANCE, NOWAIT );

	if ( pEvent ) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)){
		    IsKey = TRUE;
		    Done  = TRUE;
		}
		break;

	    case MOUSE_EVENT:
		Done = TRUE;
		break;


	    case WINDOW_BUFFER_SIZE_EVENT:
		Done = TRUE;
		break;

	    default:
		assert( FALSE );
		break;
	    }

	    if ( !Done ) {
		NextEvent( ADVANCE, NOWAIT );
	    }

	} else {
	    Done = TRUE;
	}

    } while ( !Done );

    LeaveCriticalSection(&(EventBuffer.PeekCriticalSection));

    return IsKey;

}






BOOL
consoleGetKey (
    PKBDKEY        Key,
     BOOL           fWait
    )
/*++

Routine Description:

    Gets the next key from  the input buffer.

Arguments:

    Key     -	Supplies a pointer to a key structure
    fWait   -	Supplies a flag:
		if TRUE, the function blocks until a key is ready.
		if FALSE, the function returns immediately.

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/
{

    PINPUT_RECORD   pEvent;

    do {
	pEvent = NextEvent( ADVANCE, fWait );

	if (pEvent) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)) {
		    return TRUE;
		}
		break;

	    case MOUSE_EVENT:
		MouseEvent(PMOUSE_EVT(pEvent));
		break;

	    case WINDOW_BUFFER_SIZE_EVENT:
		WindowEvent(PWINDOW_EVT(pEvent));
		break;

	    default:
		break;
	    }
	}
    } while (fWait);

    return FALSE;
}


BOOL
consolePutKey (
    PKBDKEY     Key
    )
/*++

Routine Description:

    Puts a key in the console's input buffer

Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;

    InputRecord.EventType   =	KEY_EVENT;

    InputRecord.Event.KeyEvent.bKeyDown 	  =   FALSE;
    InputRecord.Event.KeyEvent.wRepeatCount	  =   0;
    InputRecord.Event.KeyEvent.wVirtualKeyCode	  =   Key->Scancode;
    InputRecord.Event.KeyEvent.wVirtualScanCode   =   0;
    InputRecord.Event.KeyEvent.uChar.UnicodeChar  =   Key->Unicode;
    InputRecord.Event.KeyEvent.dwControlKeyState  =   Key->Flags;

    if ( PutEvent( &InputRecord )) {
	InputRecord.Event.KeyEvent.bKeyDown	  =   TRUE;
	return PutEvent( &InputRecord );
    }
    return FALSE;
}


BOOL
consolePutMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Puts a mose event in the console's input buffer

Arguments:

    Row 	-   Supplies the row
    Col 	-   Supplies the column
    MouseFlags	-   Supplies the flags

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;
    COORD	    Position;
    DWORD	    Flags;

    InputRecord.EventType   =	MOUSE_EVENT;

    Position.Y = (WORD)(Row - 1);
    Position.X = (WORD)(Col - 1);

    Flags = 0;


    InputRecord.Event.MouseEvent.dwMousePosition    =	Position;
    InputRecord.Event.MouseEvent.dwButtonState	    =	Flags;
    InputRecord.Event.MouseEvent.dwControlKeyState  =	0;
    InputRecord.Event.MouseEvent.dwEventFlags	    =	0;

    return PutEvent( &InputRecord );
}



BOOL
consoleIsBusyReadingKeyboard (
    )
/*++

Routine Description:

    Determines if the console is busy reading the keyboard

Arguments:

    None

Return Value:

    TRUE if console is busy reading the keyboard.

--*/
{
    BOOL    Busy;

    EnterCriticalSection(&(EventBuffer.CriticalSection));
    Busy = EventBuffer.BusyFlag;
    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return Busy;
}



BOOL
consoleEnterCancelEvent (
    )
{

    INPUT_RECORD    Record;

    Record.EventType = KEY_EVENT;
    Record.Event.KeyEvent.bKeyDown	      = TRUE;
    Record.Event.KeyEvent.wRepeatCount	      = 0;
    Record.Event.KeyEvent.wVirtualKeyCode     = VK_CANCEL;
    Record.Event.KeyEvent.wVirtualScanCode    = 0;
    Record.Event.KeyEvent.uChar.AsciiChar     = 0;
    Record.Event.KeyEvent.dwControlKeyState   = 0;

    return PutEvent( &Record );
}


PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    )
/*++

Routine Description:

    Returns pointer to next event record.

Arguments:

    fAdvance	-   Supplies a flag:
		    if TRUE: Advance to next event record
		    if FALSE: Do not advance to next event record

    fWait	-   Supplies a flag:
		    if TRUE, the  blocks until an event is ready.
		    if FALSE, return immediately.

Return Value:

    Pointer to event record, or NULL.

--*/
{
    PINPUT_RECORD  pEvent;
    BOOL Success;

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If the busy flag is set, then the buffer is in the process of
    //	being read. Only one thread should want to wait, so it is
    //	safe to simply return.
    //
    if ( EventBuffer.BusyFlag ) {
	assert( !fWait );
	LeaveCriticalSection(&(EventBuffer.CriticalSection));
	return NULL;
    }

    if (EventBuffer.NumberOfEvents == 0) {

	//
	//  No events in buffer, read as many as we can
	//
	DWORD NumberOfEvents;

	//
	//  If the buffer is too big, resize it
	//
	if ( EventBuffer.MaxEvents > MAX_EVENTS ) {

	    EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					       MAX_EVENTS * sizeof( INPUT_RECORD ) );

	    EventBuffer.MaxEvents = MAX_EVENTS;
        assert( EventBuffer.EventBuffer );

        //CleanExit( 1, 0 );
	}

	Success = PeekConsoleInput( hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &NumberOfEvents);

	if ((!Success || (NumberOfEvents == 0)) && (!fWait)) {
	    //
	    //	No events available and don't want to wait,
	    //	return.
	    //
	    LeaveCriticalSection(&(EventBuffer.CriticalSection));
	    return NULL;
	}

	//
	//  Since we will block, we have to leave the critical section.
	//  We set the Busy flag to indicate that the buffer is being
	//  read.
	//
	EventBuffer.BusyFlag = TRUE;
	LeaveCriticalSection(&(EventBuffer.CriticalSection));

	Success = ReadConsoleInput (hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &EventBuffer.NumberOfEvents);

	EnterCriticalSection(&(EventBuffer.CriticalSection));

	EventBuffer.BusyFlag = FALSE;

	if (!Success) {
#if defined( DEBUG )
	    OutputDebugString(" Error: Cannot read console events\n");
	    assert( Success );
#endif
	    EventBuffer.NumberOfEvents = 0;
	}
	EventBuffer.EventIndex = 0;
    }

    pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

    //
    //	If Advance flag is set, we advance the pointer to the next
    //	record.
    //
    if (fAdvance) {
	if (--(EventBuffer.NumberOfEvents)) {

	    switch (EVENT_TYPE(pEvent)) {

	    case KEY_EVENT:
	    case MOUSE_EVENT:
	    case WINDOW_BUFFER_SIZE_EVENT:
		(EventBuffer.EventIndex)++;
		break;

	    default:
#if defined( DEBUG)
		sprintf(DbgBuffer, "WARNING: unknown event type %X\n", EVENT_TYPE(pEvent));
		OutputDebugString(DbgBuffer);
#endif
		(EventBuffer.EventIndex)++;
		break;
	    }
	}
    }


    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return pEvent;
}





void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes mouse events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None..

--*/
{

}





BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    )
/*++

Routine Description:

    Processes window size change events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{
    return TRUE;
}





BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    )
/*++

Routine Description:

    Processes key events.

Arguments:

    pEvent  -	Supplies pointer to event record
    pKey    -	Supplies pointer to key structure to fill out.

Return Value:

    TRUE if key structured filled out, FALSE otherwise.

--*/
{
    // static BOOL AltPressed = FALSE;

    if (pEvent->bKeyDown) {

	WORD  Scan = pEvent->wVirtualKeyCode;

	//
	//  Pressing the ALT key generates an event, but we filter this
	//  out.
	//
	if (Scan == VK_MENU) {
	    return FALSE;
	}


	if (Scan != VK_NUMLOCK &&   // NumLock
	    Scan != VK_CAPITAL &&   // Caps Lock
	    Scan != VK_SHIFT   &&   // Shift
	    Scan != VK_CONTROL ) {  // Ctrl

	    pKey->Unicode   = pEvent->uChar.UnicodeChar;
	    pKey->Scancode  = pEvent->wVirtualKeyCode;
	    pKey->Flags     = pEvent->dwControlKeyState;

//#if defined (DEBUG)
//	 sprintf(DbgBuffer, "  KEY: Scan %d '%c'\n", pKey->Scancode, pKey->Unicode );
//	 OutputDebugString(DbgBuffer);
//#endif
	    return TRUE;

	} else {

	    return FALSE;

	}

    } else {

	return FALSE;

    }
}


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    )
{

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If no space at beginning of buffer, resize and shift right
    //
    if ( EventBuffer.EventIndex == 0 ) {

	EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					   (EventBuffer.MaxEvents + EVENT_INCREMENT) * sizeof(INPUT_RECORD));

	if ( !EventBuffer.EventBuffer ) {
        //CleanExit(1, 0);
	}

	memmove( EventBuffer.EventBuffer + EVENT_INCREMENT,
		 EventBuffer.EventBuffer ,
		 EventBuffer.NumberOfEvents * sizeof(INPUT_RECORD) );

	EventBuffer.EventIndex = EVENT_INCREMENT;
    }

    //
    //	Add event
    //
    EventBuffer.EventIndex--;
    EventBuffer.NumberOfEvents++;

    memcpy( EventBuffer.EventBuffer + EventBuffer.EventIndex,
	    InputRecord,
	    sizeof(INPUT_RECORD ));

    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\htest\cons.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.h

Abstract:

    Interface to the console-management functions for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/




//
//  Some common typedefs...
//
typedef ULONG   ROW,            *PROW;              //  row
typedef ULONG   COLUMN,         *PCOLUMN;           //  column
typedef DWORD   KBDMODE,        *PKBDMODE;          //  Keyboard mode
typedef DWORD   ATTRIBUTE,      *PATTRIBUTE;        //  Screen Attribute
typedef PVOID   PSCREEN;                            //  The screen



//
//  Console Input Mode flags. They are the same as the NT flags
//
#define CONS_ENABLE_LINE_INPUT      ENABLE_LINE_INPUT
#define CONS_ENABLE_PROCESSED_INPUT ENABLE_PROCESSED_INPUT
#define CONS_ENABLE_ECHO_INPUT      ENABLE_ECHO_INPUT
#define CONS_ENABLE_WINDOW_INPUT    ENABLE_WINDOW_INPUT
#define CONS_ENABLE_MOUSE_INPUT     ENABLE_MOUSE_INPUT

//
//	Cursor styles
//
#define 	CURSOR_STYLE_UNDERSCORE 	0
#define 	CURSOR_STYLE_BOX			1


//
//  The information about a screen is retrieved in the following
//  structure:
//
typedef struct SCREEN_INFORMATION {
    ROW     NumberOfRows;       //  Number of rows
    COLUMN  NumberOfCols;       //  Number of columns
    ROW     CursorRow;          //  Cursor row position
    COLUMN  CursorCol;          //  Cursor column position
} SCREEN_INFORMATION, *PSCREEN_INFORMATION;




//
//  The information about each keystroke is returned in
//  the KBDKEY structure.
//
typedef struct KBDKEY {
    WORD    Unicode;        // character unicode
    WORD    Scancode;       // key scan code
    DWORD   Flags;          // keyboard state flags
} KBDKEY, *PKBDKEY;

//
//  The following macros access particular fields within the
//  KBDKEY structure. They exist to facilitate porting of OS/2
//  programs.
//
#define KBDKEY_ASCII(k)     (UCHAR)((k).Unicode)
#define KBDKEY_SCAN(k)      ((k).Scancode)
#define KBDKEY_FLAGS(k)     ((k).Flags)


#define NEXT_EVENT_NONE 	0
#define NEXT_EVENT_KEY		1
#define NEXT_EVENT_WINDOW	2

//
// ControlKeyState flags. They are the same as the NT status flags.
//
#define CONS_RIGHT_ALT_PRESSED     RIGHT_ALT_PRESSED
#define CONS_LEFT_ALT_PRESSED      LEFT_ALT_PRESSED
#define CONS_RIGHT_CTRL_PRESSED    RIGHT_CTRL_PRESSED
#define CONS_LEFT_CTRL_PRESSED     LEFT_CTRL_PRESSED
#define CONS_SHIFT_PRESSED         SHIFT_PRESSED
#define CONS_NUMLOCK_PRESSED       NUMLOCK_ON
#define CONS_SCROLLLOCK_PRESSED    SCROLLLOCK_ON
#define CONS_CAPSLOCK_PRESSED      CAPSLOCK_ON
#define CONS_ENHANCED_KEY          ENHANCED_KEY





//
//  Screen Management functions
//
PSCREEN
consoleNewScreen (
    void
    );

BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    );

PSCREEN
consoleGetCurrentScreen (
    void
    );

BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    );

BOOL
consoleGetScreenInformation (
    PSCREEN             pScreen,
    PSCREEN_INFORMATION pScreenInformation
    );

BOOL
consoleSetScreenSize (
     PSCREEN Screen,
     ROW     Rows,
     COLUMN  Cols
	);



//
//  Cursor management
//
BOOL
consoleSetCursor (
     PSCREEN pScreen,
     ROW     Row,
     COLUMN  Col
    );

//
//	Cursor style
//
BOOL
consoleSetCursorStyle (
     PSCREEN pScreen,
     ULONG   Style
	);



//
//  Screen output functions
//
ULONG
consoleWriteLine (
    PSCREEN     pScreen,
     PVOID       pBuffer,
     ULONG       BufferSize,
     ROW         Row,
     COLUMN      Col,
     ATTRIBUTE   Attribute,
     BOOL        Blank
    );

BOOL
consoleShowScreen (
     PSCREEN     pScreen
    );

BOOL
consoleClearScreen (
     PSCREEN     pScreen,
     BOOL        ShowScreen
    );

BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    );







//
//  Input functions
//
BOOL
consoleFlushInput (
    void
    );

BOOL
consoleIsKeyAvailable (
	void
	);

BOOL
consoleDoWindow (
	void
	);

BOOL
consoleGetKey (
    PKBDKEY        pKey,
     BOOL           fWait
    );

BOOL
consolePutKey (
     PKBDKEY     pKey
    );

BOOL
consolePutMouse (
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

BOOL
consolePeekKey (
    PKBDKEY     pKey
	);

BOOL
consoleGetMode (
    PKBDMODE   Mode
    );

BOOL
consoleSetMode (
     KBDMODE        Mode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\huffman.h ===
/***
 *
 * encode.h - header file for encode.c
 *
 * []	22-Jun-87  KHD Created
 *    01-Jul-87  LeeAc Modified.
 *
 *****************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\rtf.h ===
/*
** rtf.h - definitions for the character codes used by RTF.						  |
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**  []	17-Dec-1987	LN:	Stolen from Excel code
**
*/
#define	cRTFMinus	'-'
#define	cRTFPlus	'+'
#define cRTFTilda	'~'
#define cRTFDash	'-'
#define cRTFUnder	'_'
#define cRTFSemi	';'
#define cRTFq	'\''
#define cRTFlb	'{'
#define cRTFrb	'}'
#define cRTFbs	'\\'
#define cRTFv	'v'

/*
** defines for primary symbol type
*/
#define	SK_NORMAL	0		/* normal type, check token	*/
#define	SK_SKIPDEST	1		/* skip entire destination	*/
#define	SK_SKIPVALUE	2		/* skip the value		*/
#define SK_SPECIAL	4		/* special character		*/
#define SK_REPLACE	5		/* replace RTF token		*/
#define	SK_NIL		0xff		/* nil type			*/

/*
** defines for symbols we actually care about
*/
#define	TK_OFF		0x80	/* high bit is on/off flag		*/
#define	TK_NIL		0
#define	TK_ANSI		1
#define	TK_BITMAP	2	/* compressed bitmap filename follows?	*/
#define	TK_BLUE		3
#define	TK_BOLD		4
#define	TK_BORDERB	5
#define	TK_BORDERL	6
#define	TK_BORDERR	7
#define	TK_BORDERT	8
#define	TK_BOX		9
#define	TK_CENTERED	10
#define	TK_COLORBACK	11
#define	TK_COLORFORE	12
#define	TK_COLORTABLE	13
#define	TK_FIRSTLINE	14
#define	TK_FONTSIZE	15
#define	TK_FORMULA	16
#define	TK_GREEN	17
#define	TK_HEX		18
#define	TK_INVISIBLE	19	/* hidden text is filename: note/topic/bitmap */
#define	TK_ITALIC	20
#define	TK_JUSTIFY	21
#define	TK_LEFT		22
#define	TK_LEFTINDENT	23
#define	TK_LINE		24
#define	TK_MACCHARS	25
#define	TK_NEWLINE	26
#define	TK_NONBREAKINGDASH	27
#define	TK_NONBREAKINGSPACE	28
#define	TK_NONREQUIREDDASH	29
#define	TK_PARADEFAULT	30
#define	TK_PCCHARS	31
#define	TK_PLAIN	32
#define	TK_RED		33
#define	TK_RIGHT	34
#define	TK_RIGHTINDENT	35
#define	TK_RTAB		36
#define	TK_SIDEBYSIDE	37
#define	TK_SPACEAFTER	38
#define	TK_SPACEBEFORE	39
#define	TK_SPACELINE	40
#define	TK_STRIKEOUT	41	/* strikeout is hotspot for Topic	*/
#define	TK_TABCHAR	42
#define	TK_TABSTOP	43
#define	TK_UNDERLINE	44	/* underline is hotspot for Definition	*/

/*
** structure definition for parse table
*/
struct tsnPE
    {
    uchar	*pch;			// pointer to symbol string
    uchar	sk;			// primary symbol kind
    ushort	tk;			// token - one of the above TK_, or FM_
    };
typedef struct tsnPE	PE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\vm.h ===
/*************************************************************************
**
** vm.h - procedure definitions for VM package
**
**	Copyright <C> 1988, Microsoft Corporation
**
** Purpose:
**
** Revision History:
**
**  []	21-Apr-1988	LN	Created
**
*************************************************************************/
typedef char	f;			/* boolean			*/
typedef unsigned char	uchar;
typedef unsigned long	ulong;
typedef unsigned short	ushort;
typedef void far *  va;                     /* virtual address              */

#define VANIL	((va)0xffffffff)	/* NIL value			*/
#define VANULL	((va)0)			/* NULL value			*/

ulong	    pascal far	VMsize	(long);

uchar far * pascal far	FMalloc (ulong);
void	    pascal far	FMfree	(uchar far *);
uchar far * pascal far	LMalloc (ushort);

void	    pascal far	fpbToVA (char far *, va, ushort);
void	    pascal far	pbToVA	(char *, va, ushort);
void	    pascal far	VATofpb (va, char far *, ushort);
void	    pascal far	VATopb	(va, char *, ushort);
void	    pascal far	VAToVA	(va, va, ulong);
f	    pascal far	VMInit	(void);
ulong	    pascal far	VMreadlong (va);
void	    pascal far	VMwritelong (va, long);

void	    pascal far	VMFinish(void);
void	    pascal far	VMFlush (void);
void	    pascal far	VMShrink(f);

#ifdef DEBUG
void	    pascal far	_vmChk	(long, long);
#else
#define     _vmChk(x,y)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\zlib.h ===
char  *pathcat (char *pDst, char *pSrc);
char  *pname (char *pszName);
LPSTR strbscan (const LPSTR pszStr, const LPSTR pszSet );
char fPathChr( int c );
BOOLEAN forsemi (char *p, BOOLEAN (*proc)( char*, void * ), void *args);


#define strend(x)   ((x)+strlen(x))
#define PSEPSTR     "/"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\helpmake.h ===
/*************************************************************************
**
** helpmake.h - misc definitions common to helpmake
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Revision History:
**
**	31-Jul-1990 ln	csVal takes a param.
**      04-Jul-1990 JCK Add F_LOCALCONTEXT to allow escaped @
**	28-Oct-1988 ln	Add parameter to rlCompress
**	12-Aug-1988 ln	Add COLMAX, local context routines & pass1a
**  []	18-Dec-1987 LN	Created
**
*************************************************************************/

/************************************************************************
**
** Includes required for subsequent definitions in this file.
*/
#include "help.h"			// structires & constants
#include "helpfile.h"			// help file structure
#include "helpsys.h"			// misc commn defs
#include "hmmsg.h"			// error message numbers
#include "farutil.h"			// far memory utils
#include "vm.h" 			// virtual memory management

/*************************************************************************
**
** definitions
**
*/
#define	TRUE	1
#define	FALSE	0

#define ASTACKSIZE	50		// size of attribute stack
#define BUFSIZE 	512		// size of line buffers
#define CBFBUF		64000		// size of far buffer(s)
#define CBIOBUF 	16000		// file buffer size (60k)
#define CBRTFMAX	40		// max length of RTF keyword
#define CBSZCONTEXT	60000		// context string buffer size
#define CCONTEXTMAX	10000		// max number of contexts
#define CTOPICSMAX	10000		// max number of topics
#define COLMAX		250		// max column we can run into
#define FBUFSIZE	2048		// size of buffers used
#define MAXBACKC	128		// max number of back-up characters

#define F_RTF		1		// RTF file type
#define F_QH		2		// QuickHelp format
#define F_MINASCII	3		// minimal ascii
#define F_MAX		3		// maximum

#define F_LOCALCONTEXT  0xff            // marker for local context

#define CMP_RUNLENGTH	0x01		// runlength encoding
#define CMP_KEYWORD	0x02		// base keyword encoding
#define CMP_KEYWORD2	0x04		// "agressive" keyword
#define CMP_HUFFMAN	0x08		// huffman encoding
#define CMP_MAX 	0x0f		// maximum

/*
** formatting tokens. Embedded in non-rtf text, and converter from (longer)
** rtf equivalents by the RTF stripper.
*/
#define FM_ANCHOR	'a' | 0xff00	// anchor cross reference
#define FM_PLAIN	'p' | 0xff00	// plain text
#define FM_BOLD 	'b' | 0xff00	// bold text
#define FM_ITALIC	'i' | 0xff00	// italic
#define FM_HIDDEN	'v' | 0xff00	// hidden text
#define FM_UNDERLINE	'u' | 0xff00	// underline
#define FM_DEFAULT	'd' | 0xff00	// paragraph defaults
#define FM_FINDENT	'f' | 0xff00	// first line indent
#define FM_LINDENT	'l' | 0xff00	// paragraph left indent
#define FM_TAB		't' | 0xff00	// tab character
#define FM_LINE 	'n' | 0xff00	// exlicit line break
#define FM_BLOCKBEG	'{' | 0xff00	// block begin
#define FM_BLOCKEND	'}' | 0xff00	// block begin

typedef char    buffer[256];            // line buffer
typedef char	f;			// boolean

struct kwi {				// keyword info structure
    char far	*fpszKw;		// pointer to the actual keyword
    int 	cbKw;			// length of keyword
    ushort	cKwInst;		// count of keyword instances
    ushort	cKwSpInst;		// count of keyword-space instances
    int 	savings;		// computed savings for this word
    };

/*
** transitem
** dotcommand translation item
*/
struct transitem {
    char    *pdotcmd;			// original dot command
    int     cbdotcmd;			// length of said dot command
    char    *pnewcmd;			// replacement command
    char    cbnewcmd;			// length of said new cmd
    };

// context string
// context string item in a linked list
//
typedef struct _cshdr {
    va	    vaNext;			// next item in list or NULL
    va	    vaTopic;			// va of topic
    uchar   cbszCs;			// length of context string + null
    } cshdr;

typedef struct _cs {
    cshdr   cshdr;			// header info
    buffer  szCs;			// context string + terminating null
    } cs;

/*
** verbosity level definitions.
*/
#define V_BANNER	(verbose >= 1)	// (default) print banner
#define V_PASSES	(verbose >= 2)	// print pass names
#define V_CONTEXTS	(verbose >= 3)	// print contexts on 1st pass
#define V_CONTEXTS2	(verbose >= 4)	// print contexts on each pass
#define V_STEPS 	(verbose >= 5)	// print intermediate steps
#define V_STATS 	(verbose >= 6)	// print statistics
#define V_DSTATS	(verbose >= 10) // print debug statistics
#define V_ARGS		(verbose >= 20) // print prog arguments
#define V_KEYWORD	(verbose >= 30) // print keyword table
#define V_HUFFMAN	(verbose >= 40) // print huffman table

/************************************************************************
**
** HelpMake function forward definitions
*/
void	    pascal	AddContextString (char *);
va	    pascal	AddKw (uchar far *);
void	    pascal	addXref (uchar *, uchar *, ushort, ushort);
void	    pascal	BackUp (int);
void	    pascal	BackUpToken (int);
uchar *     pascal	basename (uchar *);
void	    pascal	ContextVA (va);
ushort	    pascal	counttab (struct hnode *, int, ulong);
void	    pascal	decode (int, char **, int, f);
int	    pascal	DofarWrite (int, uchar far *, int);
void	    pascal	DumpRtf (uchar far *, nc, int, f);
void	    pascal	encode (int, char **, int);
f	    pascal	fControlLine (void);
va	    pascal	FindKw	(uchar far *, f);
int	    pascal	getcProc (void);
int	    pascal	getcQH (void);
int	    pascal	getcRTF (void);
void	    pascal	help ();
void	    pascal	hmerror (ushort, uchar *, ulong);
f	    pascal	hmmsg (ushort);
int			hnodecomp (struct hnode **, struct hnode **);
void	    pascal	HuffBuild (void);
void	    pascal	HuffCompress (uchar far *, uchar far *);
ushort	    pascal	HuffDump (void);
void	    pascal	HuffInit (void);
void	    pascal	HuffFreq (uchar far *, ushort);
void	    pascal	HuffStats (void);
uchar *     pascal	getFarMsg (ushort, uchar *);
void	    pascal	InitOutput (int);
void	    pascal	kwAnal (uchar far *, int);
void	    pascal	kwCompress (uchar far *);
f	    pascal	kwSepar (char);
mh	    pascal	LoadPortion (int, mh);
ushort	    pascal	LocalContext (uchar *, ushort);
void	    pascal	LocalContextFix (uchar far *);
ushort	    pascal	MapLocalContext (ushort);
int	    pascal	NextChar (void);
char *	    pascal	NextContext (f);
uchar *     pascal	NextLine (void);
long	    pascal	NextNum (void);
void	    pascal	parserefs (uchar *, uchar *);
void	    pascal	pass1 (int, char **);
void	    pascal	pass1a (void);
void	    pascal	pass2 (void);
void	    pascal	pass3 (void);
void	    pascal	passfa (void);
void	    pascal	passfb (int);
uchar	    pascal	PopAttr (void);
f	    pascal	procRTF (char *, char *);
void	    pascal	PushAttr (uchar);
void	    pascal	rlCompress (uchar far *, ushort);
int	    pascal	SkipDest (int,char **);
void	    pascal	SkipSpace (void);
void	    pascal	SkipVal (char **);
void	    pascal	SortKw (void);
void	    pascal	split (int, char **);
uchar *     pascal	trim (uchar *, f);

#ifdef DEBUG
void	    pascal	csVal (va);
#else
#define csVal(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\inc\helpsys.h ===
/*
** helpsys.h - Help system internal definitions
**
**	Copyright <C> 1987, Microsoft Corporation
**
** Purpose:
**  Contains definitions used within the help system.
**
** Revision History:
**
**	12-Mar-1990	CloseFile -> HelpCloseFile
**	22-Jan-1990	MAXFILES from 50 to 100
**  []	14-Dec-1987	Created
**
*/

/*
** definitions
*/
#ifndef NULL
#define NULL		0
#endif
#ifndef TRUE
#define TRUE		1
#define FALSE           0
#endif

#define ASCII		1		/* build with ASCII support	*/

#define MAXBACK 	20		/* max number of back-up's      */
#define MAXFILES	100		/* max number of open helpfiles */

#define FTCOMPRESSED	0x01		/* 1=compressed, 0=ascii	*/
#define FTFORMATTED	0x02		/* 1=formatted, 0=unformatted	*/
#define FTMERGED	0x04		/* 1=merged index, 0=normal	*/

#define REGISTER	register

#define HIGHONLY(l)		((ulong)l & 0xffff0000)
#define HIGH(l) 		((ushort)(HIGHONLY(l) >> 16))
#define LOW(l)			((ushort)((ulong)l & 0xffff))

/*
** Forward declarations for client application call-back routines
*/

#if rjsa
#define HelpDealloc(sel)	DosFreeSeg(sel)
#define HelpLock(sel)           ((void *)((ulong)sel << 16))
#define HelpUnlock(sel)
#else
#define HelpDealloc(x)          free(x)
#define HelpLock(x)             (x)
#define HelpUnlock(x)
#endif




void        pascal  HelpCloseFile(FILE *);
mh          pascal  HelpAlloc(ushort);
FILE *      pascal  OpenFileOnPath(char *, int);
ulong       pascal  ReadHelpFile(FILE *, ulong, char *, ushort);

/*
** intlineattr
** internal representation of lineattributes
*/
typedef struct intlineattr {		/* ILA */
    uchar attr; 			/* attribute index		*/
    uchar cb;				/* count of bytes		*/
    } intlineattr;

/******************************************************************************
**
** PB maniputalors
** Macros for locking and unlocking handle:offsets, as appropriate.
*/
#ifdef HOFFSET
#define PBLOCK(ho)      (((char *)HelpLock(HIGH(ho))) + LOW(ho))
#define PBUNLOCK(ho)	HelpUnlock(HIGH(ho))
#else
#define PBLOCK(ho)      ((void *)ho)
#define PBUNLOCK(ho)
#endif



PCHAR pascal hlp_locate (SHORT  ln,  PCHAR  pTopic);


FILE *pathopen (char *name, char *buf, char *mode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\cmds.h ===
/***  CMDS.H
*
*       Copyright <C> 1988, Microsoft Corporation
*
* Purpose:
*
* Revision History:
*
*   18-Aug-1988 bw  Initial version, stripped from KEY.C and KEYCW.C
*   07-Sep-1988 bw  Add RECORD_PLAYBACK stuff
*   26-Sep-1988 bp  Add <topfile>, <endfile> and <message>
*   26-Sep-1988 bp  Modified syntax (1+x vs x+1)  to reduce nesting in macro expansion
*   11-Oct-1988 bw  Add <selcur> to CW version
*   17-Oct-1988 bw  Add <record>
*   14-Oct-1988 ln  Add <nextmsg>
*   18-Oct-1988 bw  Add <tell>
*   18-Oct-1988 ln  Add <debugmode>
*   24-Oct-1988 bw  Add <noedit>
*   24-Oct-1988 bw  Add <lastselect>
*   26-Oct-1988 bp  Add <print>
*   27-Oct-1988 bp  Change  <topfile> to <begfile>
*   21-Nov-1988 bp  Add <saveall>
*   01-Dec-1988 bw  Add <resize>
*   10-Dec-1988 bp  Add <repeat>
*   14-Dec-1988 ln  Add <mgrep>
*   16-Dec-1988 ln  Add <mreplace>
*   04-Jan-1989 bp  Add <menukey>
*   11-Jan-1989 ln  Zoom->maximize
*   17-Jan-1989 bw  Add <selmode> in CW version
*   30-Jan-1989 bw  Remove <dumpscreen> (replaced with ScrollLock Key)
*   15-Feb-1989 bp  Add <prompt>
*
*  WARNING -- it is important that the ordering here reflects EXACTLY the
*  ordering in the cmdDesc table in table.c
*
*************************************************************************/


#define CMD_doarg           (PCMD)&cmdTable[0]
#define CMD_assign          1 + CMD_doarg
#define CMD_backtab         2 + CMD_doarg
#define CMD_begfile         3 + CMD_doarg
#define CMD_begline         4 + CMD_doarg
#define CMD_boxstream       5 + CMD_doarg
#define CMD_cancel          6 + CMD_doarg
#define CMD_cdelete         7 + CMD_doarg
#define CMD_compile         8 + CMD_doarg
#define CMD_zpick           9 + CMD_doarg
#define CMD_curdate        10 + CMD_doarg
#define CMD_curday         11 + CMD_doarg
#define CMD_curtime        12 + CMD_doarg
#define CMD_delete         13 + CMD_doarg
#define CMD_down           14 + CMD_doarg
#define CMD_emacscdel      15 + CMD_doarg
#define CMD_emacsnewl      16 + CMD_doarg
#define CMD_endfile        17 + CMD_doarg
#define CMD_endline        18 + CMD_doarg
#define CMD_environment    19 + CMD_doarg
#define CMD_zexecute       20 + CMD_doarg
#define CMD_zexit          21 + CMD_doarg
#define CMD_graphic        22 + CMD_doarg
#define CMD_home           23 + CMD_doarg
#define CMD_information    24 + CMD_doarg
#define CMD_zinit          25 + CMD_doarg
#define CMD_insert         26 + CMD_doarg
#define CMD_insertmode     27 + CMD_doarg
#define CMD_lastselect     28 + CMD_doarg
#define CMD_textarg        29 + CMD_doarg
#define CMD_ldelete        30 + CMD_doarg
#define CMD_left           31 + CMD_doarg
#define CMD_linsert        32 + CMD_doarg
#define CMD_mark           33 + CMD_doarg
#define CMD_message        34 + CMD_doarg
#define CMD_meta           35 + CMD_doarg
#define CMD_mgrep          36 + CMD_doarg
#define CMD_mlines         37 + CMD_doarg
#define CMD_mpage          38 + CMD_doarg
#define CMD_mpara          39 + CMD_doarg
#define CMD_mreplace       40 + CMD_doarg
#define CMD_msearch        41 + CMD_doarg
#define CMD_mword          42 + CMD_doarg
#define CMD_newline        43 + CMD_doarg
#define CMD_nextmsg        44 + CMD_doarg
#define CMD_noedit         45 + CMD_doarg
#define CMD_noop           46 + CMD_doarg
#define CMD_put            47 + CMD_doarg
#define CMD_pbal           48 + CMD_doarg
#define CMD_plines         49 + CMD_doarg
#define CMD_ppage          50 + CMD_doarg
#define CMD_ppara          51 + CMD_doarg
#define CMD_zprint         52 + CMD_doarg
#define CMD_prompt         53 + CMD_doarg
#define CMD_psearch        54 + CMD_doarg
#define CMD_pword          55 + CMD_doarg
#define CMD_qreplace       56 + CMD_doarg
#define CMD_quote          57 + CMD_doarg
#define CMD_record         58 + CMD_doarg
#define CMD_refresh        59 + CMD_doarg
#define CMD_repeat         60 + CMD_doarg
#define CMD_replace        61 + CMD_doarg
#define CMD_restcur        62 + CMD_doarg
#define CMD_right          63 + CMD_doarg
#define CMD_saveall        64 + CMD_doarg
#define CMD_savecur        65 + CMD_doarg
#define CMD_savetmp        66 + CMD_doarg
#define CMD_sdelete        67 + CMD_doarg
#define CMD_searchall      68 + CMD_doarg
#define CMD_setfile        69 + CMD_doarg
#define CMD_setwindow      70 + CMD_doarg
#define CMD_zspawn         71 + CMD_doarg
#define CMD_sinsert        72 + CMD_doarg
#define CMD_tab            73 + CMD_doarg
#define CMD_tell           74 + CMD_doarg
#define CMD_unassigned     75 + CMD_doarg
#define CMD_undo           76 + CMD_doarg
#define CMD_up             77 + CMD_doarg
#define CMD_window         78 + CMD_doarg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\keyboard.h ===
void            mepInitKeyboard ( void );
BOOL            TypeAhead       ( void );
KBDKEY          ReadChar        ( void );

void		    KbHook	    ( void );
void		    KbUnHook	    ( void );
KBDMODE 	    KbGetMode	    ( void );
void		    KbSetMode	    ( KBDMODE Mode );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\keys.h ===
/* Virtual Keys, Standard Set  =*/


EDITOR_KEY    TranslateKey    (KBDKEY KbdKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\help\mshelp\help.c ===
/*** help.c - help library main
*
*   Copyright <C> 1988-1990, Microsoft Corporation
*
* Definitions:
*
*  Context Map:             Mapping  of  context  number  to  topic  number.
*                           Allows multiple contexts to be associated with a
*                           single   topic.  Syncronized  with  the  context
*                           string  table,  each  entry  contains  the topic
*                           number associated with the corresponding context
*                           string.
*
*  Context String:          String on which help can be "looked up".
*
*  Context String Table:    Table   of   all  valid  context  strings  in  a
*                           particular help file.
*
*  Local Context:           A  type  of  context  which bypasses the context
*                           string and context numbers. In cross references,
*                           encoded  as  a  cross  reference string of NULL,
*                           followed by a topic number ored with 0x8000.
*
*  nc:                      (Context   Number)   A   long   which   uniquely
*                           identifies  a  help  file and context string, or
*                           for  local  contexts,  the  helpfile  and  topic
*                           number. Formatted as:
*
*                               +----------------+----------------+
*                               | Fdb Mem Handle | context number |
*                               +----------------+----------------+
*
*                           Where the upper word is the memory handle of the
*                           allocated  fdb for the help file. The lower word
*                           is  the  either  the "true" context  number (see
*                           below)  if <= 0x7fff, or the actual topic number
*                           or'ed with 0x8000.
*
*  Topic:                   Actual help textual entry. May be compressed.
*
*  Topic Index:             Table  of file positions of all topics contained
*                           in  a  help  file.  Indexed by the topic number,
*                           returns  that  topics  physical  position in the
*                           file.
*
*  Topic Number:            Index  to  a particular topic. Topic numbers are
*                           zero based, and reflect the physical ordering of
*                           the topics in the file.
*
*  "True" context number:   is  the zero based index or string number in the
*                           <context  string  table>. I.E. the "n'th" string
*                           has context number "n".
*
* The progression from string to true context number to topic number to file
* position is:
*
*       1) Context String ==> "True" Context Number
*
*           The  string  is  searched for in the <context string table>, and
*           it's number becomes the "true" context number.
*
*       2) "True" Context Number ==> Topic Number
*
*           The  context number is an index into the <context map>, returing
*           the topic number associated with the context number.
*
*       3) Topic Number ==> File Position
*
*           The  topic number is used as an index into the Topic Index, from
*           which the physical file position is retrieved.
*
* Notes:
*  QuickPascal requires NO initialized data. In this case, CLEAR is defined,
*  and the HelpInit routine is included. We also play some pointer games to
*  simple variables, because the C compiler can generate CONST segment
*  entries for the SEG of various vars. (This enables it to load the segment
*  register directly, rather than by using SEG varname and another
*  register). Q/P cannot support this action by the compiler.
*
*  QuickHelp for OS/2 is reentrant. This code should remain reentrant up to
*  but not including allocating and deallocating fdbs.
*
* Revision History:
*
*       17-Aug-1990 ln  Don't blindly request 64k of an ascii file. Query
*                       for size first, then read. Allocations based on
*                       previous topic size requests may cause the OS to
*                       GPFault for an out of range read.
*       16-Jul-1990 ln  Searching for "filename!" where filename is a QH
*                       file, will now fail, rather than GP fault. Searching
*                       for "!" will now succeed.
*       08-Jun-1990 ln  Remove HelpLock usage in HelpNcCmp
*       13-Apr-1990 ln  Try to get HelpSzContext to return strings in more
*                       cases where it can.
*       12-Mar-1990 ln  Rename CloseFile -> HelpCloseFile
*       08-Oct-1989 ln  Changes to improve the previous change to work (allow
*                       decompression) more often in low memory bases.
*                       Deallocate table in OpenCore to reduce fragmentation
*                       in non-moveable memory systems.
*       19-May-1989 ln  Correct bug in decompressing, where we would not
*                       decompress if the tables didn;t exist.
*       12-Apr-1989 ln  Ensure that we handle Locks failing correctly. Also
*                       remove TossPortion usage. Unlock handles directly.
*       10-Mar-1989 ln  Change MapTopicToContext to look forward. Changed
*                       HelpNc to look begining at passed context string.
*       17-Jan-1989 ln  Correct creation of basename in HelpOpen to account
*                       for environment syntax.
*       09-Dec-1988 ln  Add HelpNcUniq
*       25-Oct-1988 ln  Added minascii support to HelpNcPrev. Correct
*                       minascii bug in HelpSzContext.
*       14-Sep-1988 ln  Improve doc. Remove ambiguity in MapContextToTopic
*                       return value. Improve error checking in various
*                       places.
*       01-Sep-1988 ln  Check ReadHelpFile return value in LoadPortion
*       12-Aug-1988 ln  Add check for memory discarded in alloc durring
*                       HelpDecomp.
*       08-Aug-1988 ln  Ensure HelpClose closes ALL files. (Off by one error
*                       in loop).
*       14-Apr-1988 ln  Modified to conform to QC (CW?) restriction that
*                       prohibits any segments from being locked when an
*                       allocation is performed.
*   []  15-Dec-1987 ln  Created, for design.
*
*************************************************************************/

#include <assert.h>                     /* debugging assertions         */
#include <io.h>                         /* I/O function declarations    */
#include <stdlib.h>                     /* standard library             */

#include <stdio.h>                      /* standard I/O definitions     */

#if defined (OS2)
#define INCL_BASE
#include <os2.h>
#else
#include <windows.h>
#endif

#include "help.h"                       /* global (help & user) decl    */
#include "helpfile.h"                   /* help file format definition  */
#include "helpsys.h"                    /* internal (help sys only) decl*/

#define MASIZE          512             /* size of ma input buffer      */
#define MAOVER          64              /* size of ma search overlap    */

#define ISERROR(x)      (((x).mh == 0L) && ((x).cn <= HELPERR_MAX))
#define SETERROR(x,y)   { (x).mh = 0L; (x).cn = y; }

/*************************************************************************
**
** Forward definitions
*/
void        pascal near CloseShrink(nc, f);
f           pascal near LoadFdb (mh, fdb far *);
mh          pascal near LoadPortion (int, mh);
ushort      pascal near MapContexttoTopic (nc, fdb far *);
nc      pascal near MapTopictoContext(ushort, fdb far *, int);
nc          pascal near NextPrev(nc,int);
nc          pascal near OpenCore(FILE *, ulong, uchar far *, struct helpheader *, fdb far *);
f           pascal near PutFdb (mh, fdb far *);
f           pascal near SizePos (nc, ushort *,ulong *);

ushort      pascal near decomp  (uchar far *, uchar far *, uchar far *, uchar far *);
char far *  pascal near hfmemzer(void far *, ushort);
char far *  pascal near hfstrchr(char far *, char);
char far *  pascal near hfstrcpy(char far *, char far *);
ushort      pascal near hfstrlen(char far *);
f           pascal far  HelpCmp (uchar far *, uchar far *, ushort, f, f);
f           pascal near HelpCmpSz (uchar far *, uchar far *);
void        pascal near kwPtrBuild(uchar far *, ushort);

#if ASCII
long        pascal near maLocate (fdb far *, uchar far *, ulong,
                f (pascal far *)(uchar far *, uchar far *, ushort, f, f));

nc          pascal near combineNc (ulong, mh);
ulong       pascal near NctoFo (ulong);
#endif

/*************************************************************************
**
** External Global data
** BEWARE. The effects of global data on reentrancy should be VERY carefully
** considered.
**
*************************************************************************/
extern  mh      tbmhFdb[MAXFILES+1];
extern  char    szNil[1];
extern  ushort  cBack;

#ifdef CLEAR
/*************************************************************************
**
** HelpInit - One-time initialization
**
** Purpose:
**  Performs one-time initialization. Right now that's a zero fill of static
**  memory for those environments which don't support pre-inited static
**  memory.
**
** Entry:
**  none
**
** Exit:
**  none
**
*/
void far pascal LOADDS HelpInit () {

hfmemzer (tbmhFdb, sizeof(tbmhFdb));    /* zero entire fdb handle table */
hfmemzer (szNil,  sizeof(szNil));       /* zero null string             */
hfmemzer (&cBack,  sizeof(cBack));      /* zero back trace count        */

/* end HelpInit */}
#endif

/*************************************************************************
**
** HelpOpen - Open help file & return help handle.
**
** Purpose:
**  Given the file basename, locate the associated help file on the path, and
**  open it, initializing internal data structures as appropriate.
**
** Entry:
**  fpszName    - base filename to be openned.
**
** Exit:
**  nc initial context for openned file.
**
** Exceptions:
**  Returns error code on failure to open for any reason.
**
*/
nc far pascal LOADDS HelpOpen (
char far *fpszName
) {
FILE    *fhT;                            /* temp file handle             */
fdb     fdbLocal;                       /* local copy of fdb to use     */
uchar far *fpszBase;                    /* base filename                */
void far *fpT;
struct helpheader hdrLocal;             /* for use by opencore          */
nc      ncRet           = {0,0};        /* first context                */
mh      *ptbmhFdb;                      /* pointer into mh table        */

/*
** create basename by removing possible env variable, drive, and scanning
** for last path seperator
*/
fpszBase = fpszName;
if (fpT = hfstrchr(fpszBase,':'))
    fpszBase = (uchar far *)fpT+1;
while (fpT = hfstrchr(fpszBase,'\\'))
    fpszBase = (uchar far *)fpT+1;
/*
** Scan FDB's for an open file of the same base name. If we encounter the name,
** in either the true filename, or file header, just return that file's initial
** context. Otherwise fall below to try and open it.
*/
for (ptbmhFdb=&tbmhFdb[1]; ptbmhFdb<=&tbmhFdb[MAXFILES]; ptbmhFdb++) {
    if (LoadFdb (*ptbmhFdb,&fdbLocal)) {
        if (HelpCmpSz(fpszBase,fdbLocal.fname) ||
            HelpCmpSz(fpszBase,fdbLocal.hdr.fname))
            ncRet = fdbLocal.ncInit;
        if (ncRet.mh && ncRet.cn)
            return ncRet;
        }
    }
/*
** Open file. If we can, then call the core open routine to open the file (and
** any anything appended to it).
**
** Warning: the app may callback HelpClose at this point.
*/
if (fhT = OpenFileOnPath(fpszName,FALSE)) {
    ncRet = OpenCore (fhT,0L,fpszBase,&hdrLocal,&fdbLocal);
    if (ISERROR(ncRet))
        HelpCloseFile (fhT);
    return ncRet;
    }

SETERROR(ncRet, HELPERR_FNF);
return ncRet;
// rjsa return HELPERR_FNF;

/* end HelpOpen*/}

/*************************************************************************
**
** OpenCore - Recursive core of HelpOpen
**
** Purpose:
**  Given the open file handle, initialize internal data structures as
**  appropriate. Attempt to open any file that is appended.
**
** Entry:
**  fhT         - Open file handle
**  offset      - Offset from start of file of help file to open
**  fpszBase    - pointer to base filename
**
** Exit:
**  initial context, or NULL on failure.
**
** Exceptions:
**  Returns NULL on failure to open for any reason.
**
*/
nc pascal near OpenCore (
FILE *  fhHelp,
ulong   offset,
uchar far *fpszBase,                    /* base filename                */
struct helpheader *phdrLocal,
fdb far *pfdbLocal                      /* pointer to current FDB       */
) {
//void far *fpT;
int     ihFree;                         /* handle for free fdb (& index)*/
mh      mhCur;                          /* current memory handle        */
nc      ncFirst         = {0,0};        /* first context                */
nc      ncInit;                         /* first context                */
mh      *pmhT;                          /* pointer into mh table        */

/*
** Read in helpfile header
*/
if (ReadHelpFile(fhHelp,
    offset,
    (char far *)phdrLocal,
    (ushort)sizeof(struct helpheader))) {
/*
** search for available fdb
*/
    for (ihFree = MAXFILES, pmhT = &tbmhFdb[MAXFILES];
         ihFree && *pmhT;
         ihFree--, pmhT--);
/*
** if an offset is present, and this is NOT a compressed file, or there is no
** available fdb, ignore the operation.
*/
    if (   offset
        && (phdrLocal->wMagic != wMagicHELP)
        && (phdrLocal->wMagic != wMagicHELPOld)
        ) {
        SETERROR(ncInit, HELPERR_BADAPPEND);
        return ncInit;
        // rjsa return HELPERR_BADAPPEND;
    }
    if (ihFree == 0) {
        SETERROR(ncInit, HELPERR_LIMIT);
        return ncInit;
        // rjsa return HELPERR_LIMIT;
    }
/*
** allocate fdb. Again, if we can't, skip it all and return NULL.
*/
    if (mhCur = *pmhT = HelpAlloc((ushort)sizeof(fdb))) {
/*
** Fill in helpfile header & appropriate fdb fields
*/
        hfmemzer(pfdbLocal,sizeof(fdb));        /* zero entire fdb      */
        pfdbLocal->fhHelp = fhHelp;             /* file handle          */
        ncFirst.mh = pfdbLocal->ncInit.mh = mhCur;
        ncFirst.cn = pfdbLocal->ncInit.cn  = 0L;
        // rjsa ncFirst = pfdbLocal->ncInit = ((long)mhCur) << 16; /* initial context      */
        pfdbLocal->foff = offset;                /* appended offset      */
        hfstrcpy(pfdbLocal->fname,fpszBase);     /* include base filename*/
/*
** if this is a compressed file (signified by the first two bytes of the header
** we read in above), then note the file type in the fdb. We unlock the fdb, as
** MapTopicToContext and the recursion might cause memory allocation. We get a
** context number for the first topic, and recurse and attempt to open any
** appended file.
*/
        if (   (phdrLocal->wMagic == wMagicHELPOld)
            || (phdrLocal->wMagic == wMagicHELP)
           ) {
            if ((phdrLocal->wMagic == wMagicHELP)
                && (phdrLocal->wVersion > wHelpVers)) {
                SETERROR(ncInit, HELPERR_BADVERS);
                return ncInit;
                // rjsa return HELPERR_BADVERS;
            }
            pfdbLocal->hdr = *phdrLocal;
            pfdbLocal->ftype = FTCOMPRESSED | FTFORMATTED;
            if (PutFdb (mhCur, pfdbLocal)) {
        ncFirst = MapTopictoContext(0,pfdbLocal,0);

                // We free the context map (the only thing loaded by the
                // MapTopictoContext) in order to reduce fragmentation in
                // non-moveable memory based systems.
                //
                HelpDealloc (pfdbLocal->rgmhSections[HS_CONTEXTMAP]);
                pfdbLocal->rgmhSections[HS_CONTEXTMAP] = 0;

                ncInit = OpenCore(fhHelp,pfdbLocal->hdr.tbPos[HS_NEXT]+offset,szNil,phdrLocal,pfdbLocal);
                if (LoadFdb (mhCur, pfdbLocal)) {
                        //if (ncInit.cn > HELPERR_MAX) {
                        if ( !(ISERROR(ncInit)) ) {
                            pfdbLocal->ncLink = ncInit;
                        } else {
                            pfdbLocal->ncLink.mh = (mh)0;
                            pfdbLocal->ncLink.cn = 0L;
                        }
                        // rjsa pfdbLocal->ncLink = ncInit > HELPERR_MAX ? ncInit : 0;
                        pfdbLocal->ncInit = ncFirst;
                }
            }
        }
#if ASCII
/*
** In the case of a minascii formatted file (signified by the first two bytes
** of the header being ">>") we just set up the filetype and "applications
** specific character". The default "ncFirst" is the context for the first
** topic.
*/
        else if (phdrLocal->wMagic == 0x3e3e) { /* minascii formatted?  */
            pfdbLocal->ftype = FTFORMATTED;
            pfdbLocal->hdr.appChar = '>';       /* ignore lines with this*/
            }
#endif
        else if ((phdrLocal->wMagic & 0x8080) == 0) { /* ascii unformatted? */
            pfdbLocal->ftype = 0;
            pfdbLocal->hdr.appChar = 0xff;      /* ignore lines with this*/
            }
        else {
            SETERROR(ncInit, HELPERR_NOTHELP);
            return ncInit;
            // rjsa return HELPERR_NOTHELP;
        }

        if (!PutFdb (mhCur, pfdbLocal)) {
            ncFirst.mh = (mh)0;
            ncFirst.cn = 0L;
        }
    }
    else {
        SETERROR(ncFirst, HELPERR_MEMORY);
        // rjsa ncFirst = HELPERR_MEMORY;       /* error reading file           */
    }
}
else {
    SETERROR(ncFirst, HELPERR_READ);
    // rjsa ncFirst = HELPERR_READ;             /* error reading file           */
}

return ncFirst;                         /* return valid context         */

/* end OpenCore */}


/*************************************************************************
**
** HelpClose - Close Help file
**
** Purpose:
**  Close a help file, deallocate all memory associated with it, and free the
**  handle.
**
** Entry:
**  ncClose     - Context for file to be closed. If zero, close all.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void far pascal LOADDS HelpClose (
nc      ncClose
) {
CloseShrink(ncClose,TRUE);              /* close file(s)                */
/* end HelpClose */}

/*************************************************************************
**
** HelpShrink - Release all dynamic memory
**
** Purpose:
**  A call to this routines causes the help system to release all dynamic
**  memory it may have in use.
**
** Entry:
**  None.
**
** Exit:
**  None.
**
** Exceptions:
**  None.
**
*/
void far pascal LOADDS HelpShrink(void) {
    nc ncTmp = {0,0};
CloseShrink(ncTmp,0);
// rjsa CloseShrink(0,0);
/* end HelpShrink */}

/*************************************************************************
**
** CloseShrink - Deallocate memory and possibly Close Help file
**
** Purpose:
**  Deallocate all memory associated with a help file, and possibly close free
**  it.
**
** Entry:
**  ncClose     - Context for file. If zero, do all.
**  fClose      - TRUE if a close operation.
**
** Exit:
**  None
**
** Exceptions:
**  All errors are ignored.
**
*/
void pascal near CloseShrink (
nc      ncClose,
f       fClose
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
int     i;
mh      mhClose;                        /* fdb mem hdl to file to close */
mh      *pmhFdb;                        /* pointer to FDB's table entry */


mhClose = ncClose.mh;                    /* get index */
// rjsa mhClose = (mh)HIGH(ncClose);            /* get index                    */
for (pmhFdb = &tbmhFdb[0];              /* for each possible entry      */
     pmhFdb <= &tbmhFdb[MAXFILES];
     pmhFdb++
     ) {
    if ((mhClose == 0)                  /* if all selected              */
        || (mhClose == *pmhFdb)) {      /* or this one selected         */

        if (LoadFdb (*pmhFdb, &fdbLocal)) {     /* if open file         */
/*
 * Recurse to close/shrink any appended files
 */
            if ((fdbLocal.ncLink.mh || fdbLocal.ncLink.cn) && mhClose)
                CloseShrink (fdbLocal.ncLink, fClose);

            for (i=HS_count-2; i>=0; i--)       /* for dyn mem handles  */
                HelpDealloc(fdbLocal.rgmhSections[i]);  /* dealloc      */
            hfmemzer(fdbLocal.rgmhSections,sizeof(fdbLocal.rgmhSections));

            if (fClose) {
                HelpCloseFile(fdbLocal.fhHelp); /* close file           */
                HelpDealloc(*pmhFdb);           /* deallocate fdb       */
                *pmhFdb = 0;
                }
            else
                PutFdb (*pmhFdb, &fdbLocal);    /* update FDB           */
            }
        }
    }
/* end CloseShrink */}

/*** HelpNcCmp - Look up context string, provide comparison routine
*
*  Given an ascii string, determine the context number of that string. Uses
*  user-supplied comparison routine.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*  lpfnCmp      - far pointer to comparison routine to use.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNcCmp (
char far *fpszContext,
nc      ncInitial,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
f       fFound          = FALSE;        // TRUE -> found
f       fOpened         = FALSE;        // TRUE -> file was openned here
fdb     fdbLocal;                       // pointer to current FDB
char far *fpszT;                        // temp far pointer
long     i;
long     iStart;                         // nc to start looking at
mh      mhCur;                          // memory handle locked
nc      ncRet           = {0,0};        // The return value
char far *fpszContexts;                 // pointer to context strings


// if the context string includes a "filename!", then open that as a help
// file, and point to the context string which may follow.
//
if ((fpszT = hfstrchr(fpszContext,'!')) && (fpszT != fpszContext)) {
    *fpszT = 0;
    ncInitial = HelpOpen(fpszContext);
    *fpszT++ = '!';
    fpszContext = fpszT;
    fOpened = TRUE;
}

// if helpfile was not openned, just return the error
//
if (ISERROR(ncInitial)) {
    ncInitial.mh = (mh)0;
    ncInitial.cn = 0L;
    return ncInitial;
}

// For compressed files we scan the context strings in the file 
// (this turns out not to be that speed critical in
// comparision with decompression, so I haven't bothered), to get the
// context number.
//
// If not found, and there IS a linked (appended) file, we recurse to search
// that file as well.
//
// The context number for compressed files is just the zero based string
// number, plus the number of predefined contexts, with the fdb memory
// handle in the upper word.
//
if (LoadFdb (ncInitial.mh, &fdbLocal)) {
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // If not a local context look up, get the context strings, and
        // search
        //
        if (*fpszContext) {
            mhCur = LoadPortion (HS_CONTEXTSTRINGS, ncInitial.mh);
            if (   (mhCur == (mh)0)
                || (mhCur == (mh)(-1))
                || (!(fpszContexts = HelpLock(mhCur)))
               ) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
                return ncRet;
            }
            i=0;

            // iStart allows us to begin searching from the context string
            // passed, as opposed to from the begining each time. This
            // allows the application to "carry on" a search from othe last
            // place we found a match. This is usefull for multiple
            // duplicate context resolution, as well as inexact matching.
            //
            iStart = ncInitial.cn;
            if (iStart & 0x8000)
                iStart = 0;
            else
                iStart--;                   /* table index is 0 based */

            do {
                if (i >= iStart) {
                    fFound = lpfnCmp (  fpszContext
                                      , fpszContexts
                                      , 0xffff
                                      , (f)(fdbLocal.hdr.wFlags & wfCase)
                                      , (f)FALSE);
                }
                while (*fpszContexts++);    /* point to next string         */
                i++;
            }
                while ((i < (int)fdbLocal.hdr.cContexts) && !fFound);
            HelpUnlock (mhCur);

            if (fFound) {                    /* if a match found             */
                ncRet.mh = ncInitial.mh;
                ncRet.cn = i + fdbLocal.hdr.cPreDef;
                // rjsa ncRet = (i+fdbLocal.hdr.cPreDef)            /* string #     */
                //              | HIGHONLY(ncInitial);              /* & fdb handle */
            }
            else {
                ncInitial.mh = (mh)0;
                ncInitial.cn = 0L;
                ncRet = HelpNcCmp (fpszContext,fdbLocal.ncLink, lpfnCmp);
            }
        }
        else if (!fOpened) {
            ncRet.mh = ncInitial.mh;
            ncRet.cn = *(UNALIGNED ushort far *)(fpszContext + 1);
            // rjsa ncRet = *(ushort far *)(fpszContext + 1)        /* word following*/
            //                 | HIGHONLY(ncInitial);              /* & fdb handle */
        }
    }
#if ASCII
/*
** For minimally formatted ascii files, we sequentially scan the file itself
** for context string definitions until we find the string we care about.
**
** The context number for minascii files is the the byte position/4 of the
** beginning of the associated topic, with the fdb memory handle in the upper
** word.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        if (*fpszContext) {
            ncRet.cn = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            if (ncRet.cn == -1L) {
                ncRet.mh = (mh)0;
                ncRet.cn = 0L;
            } else {
                ncRet = combineNc(ncRet.cn, fdbLocal.ncInit.mh);
            }
            // rjsa ncRet = maLocate(&fdbLocal, fpszContext, 0L, lpfnCmp);
            //      ncRet = (ncRet == -1L)
            //              ? 0
            //              : combineNc(ncRet,HIGH(fdbLocal.ncInit));
        }
    }
/*
** for unformatted ascii files, there must have been NO context string to be
** searched for. In that case, the context number is always 1, plus the fdb
** mem handle.
*/
    else if (*fpszContext == 0) {        /* if null context string       */
        ncRet.mh = ncInitial.mh;
        ncRet.cn = 1L;
        // rjsa ncRet = HIGHONLY(ncInitial) + 1;
    }
#endif
}

return ncRet;

/* end HelpNcCmp */}

/*** HelpNc - Look up context string
*
*  Given an ascii string, determine the context number of that string.
*
* Entry:
*  lpszContext  - Pointer to asciiz context string.
*  ncInital     - Starting Context, used to locate file.
*
* Exit:
*  Context number, if found.
*
* Exceptions:
*  Returns NULL if context string not found.
*
*************************************************************************/
nc far pascal LOADDS HelpNc (
char far *fpszContext,
nc      ncInitial
) {
return HelpNcCmp (fpszContext, ncInitial, HelpCmp);
/* end HelpNc */}


/*************************************************************************
**
** HelpNcCb - Return count of bytes in compressed topic
**
** Purpose:
**  Returns the size in bytes of the compressed topic. Provided for
**  applications to determine how big a buffer to allocate.
**
** Entry:
**  ncCur       - Context number to return info on.
**
** Exit:
**  Count of bytes in the compressed topic
**
** Exceptions:
**  Returns 0 on error.
**
*/
ushort far pascal LOADDS HelpNcCb (
nc      ncCur
) {
ulong   position;
ushort  size;

return SizePos(ncCur,&size,&position) ? size+(ushort)4 : (ushort)0;

/* end HelpNcCb */}

/******************************************************************************
**
** HelpLook - Return compressed topic text
**
** Purpose:
**  Places the compressed topic text referenced by a passed context number into
**  a user supplied buffer.
**
** Entry:
**  ncCur       - Context number for which to return text
**  pbDest      - Pointer to buffer in which to place the result.
**
** Exit:
**  Count of bytes in >uncompressed< topic. This is encoded based on file type.
**
** Exceptions:
**  Returns NULL on any error
**
*/
ushort far pascal LOADDS HelpLook (
nc      ncCur,
PB      pbDest
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpszDest;
int     i;
ulong   position        = 0;
ushort  size            = 0;

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb down         */
/*
** for both kinds of formatted files, we determine the position of the topic,
** and read it in.
*/
    if (fdbLocal.ftype) {
        if (SizePos (ncCur,&size,&position)) {
                if (fpszDest = (char far *)PBLOCK(pbDest)) {

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "HELP: Reading Topic for Context %d at %lX, size %d\n", ncCur.cn, position + fdbLocal.foff, size );
                        OutputDebugString(DbgBuf);
                }
#endif

                size = (ushort)ReadHelpFile(fdbLocal.fhHelp
                                    ,position + fdbLocal.foff
                                    ,fpszDest
                                        ,size);

#ifdef BIGDEBUG
                {
                        char DbgBuf[128];
                        sprintf(DbgBuf, "      Read %d bytes to address %lX\n", size, fpszDest );
                        OutputDebugString(DbgBuf);
                }
#endif
/*
** for compressed files, if the read was sucessfull, we then return the
** uncompressed size which is the first word of the topic.
*/
#if ASCII
                if (fdbLocal.ftype & FTCOMPRESSED) {
#endif
                    if (size)
                        size = *(ushort far *)fpszDest+(ushort)1;
#if ASCII
                    }
                else {
/*
** for minascii files, We also set up for the terminating NULL by scanning for
** the ">>" which begins the next topic, adjusting the size as well.
*/
                    size -= 4;
                    for (i=4; i; i--)
                        if (fpszDest[++size] == '>') break;
                    fpszDest[size++] = 0;
                    }
#endif
                }
            }
        }
#if ASCII
    else {                              /* unformatted ascii            */
/*
** for unformatted ascii, we just read in (first 64k of) the file.
*/
        if (fpszDest = PBLOCK (pbDest)) {
            if (SizePos (ncCur,&size,&position)) {
                size = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,fpszDest,size);
                fpszDest[size++] = 0;           /* terminate ascii text         */
                }
            }
        }
#endif
    PBUNLOCK (pbDest);
    }
if (size) size += sizeof(topichdr);     /* adjust for prepended topichdr*/
return size;
/* end HelpLook */}

/******************************************************************************
**
** HelpDecomp - Decompress Topic Text
**
** Purpose:
**  Fully decompress topic text. Decompresses based on current file, from one
**  buffer to another.
**
** Entry:
**  pbTopic     - Pointer to compressed topic text
**  pbDest      - Pointer to destination buffer
**
** Exit:
**  FALSE on successful completion
**
** Exceptions:
**  Returns TRUE on any error.
**
*/
f far pascal LOADDS HelpDecomp (
PB      pbTopic,
PB      pbDest,
nc      ncContext
) {
fdb     fdbLocal;                       // pointer to current FDB
uchar far *fpszDest;                    // pointer to destination
uchar far *fpTopic;                     // pointer to locked topic
f       fRv = TRUE;                     // return Value
mh      mhFdb;                          // handle to the fdb
mh      mhHuff;
mh      mhKey;

mhFdb = ncContext.mh;
if (LoadFdb (mhFdb, &fdbLocal)) {       /* lock fdb down        */
    if (fdbLocal.ftype & FTCOMPRESSED) {

        // This funky sequence of code attempts to ensure that both the
        // huffman and keyword decompression tables are loaded simultaneously
        // since we cannot decompress without both.
        //
        // We do things three times to cover the following cases:
        //
        //  1)  huffman loaded ok
        //      keyword loaded ok
        //      huffman already loaded
        //
        //  2)  huffman loaded ok
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (HelpShrink freed enough for both)
        //
        //  3)  huffman loaded ok after HelpShrink
        //      keyword loaded ok after HelpShrink (huffman discarded)
        //      huffman re-loaded ok (memory fragmentation allowed it)
        //
        // The other cases, where either the load fails immediatly after
        // any HelpShrink call, are the cases we cannot handle.
        //
        // Since handles can change due to the reallocation that can ocurr
        // in the HelpShrink-reload sequence, we simply do the three
        // loads, and then ensure that all the handles match what's in the
        // fdb. If they don't, we fail.
        //
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);
        mhKey  = LoadPortion (HS_KEYPHRASE,mhFdb);
        mhHuff = LoadPortion (HS_HUFFTREE,mhFdb);

        if (   LoadFdb (mhFdb, &fdbLocal)
            && (mhKey  == fdbLocal.rgmhSections[HS_KEYPHRASE])
            && (mhHuff == fdbLocal.rgmhSections[HS_HUFFTREE])) {

            char far *fpHuff;
            char far *fpKey;

            // At this point we lock EVERYTHING and ensure that we have
            // valid pointers to it all. (Some swapped memory systems can
            // fail at this point, so we need to be sensitive).
            //
            fpHuff   = HelpLock (mhHuff);
            fpKey    = HelpLock (mhKey);
            fpTopic  = PBLOCK (pbTopic);
            fpszDest = PBLOCK (pbDest);

            if (   fpTopic
                && fpszDest
                && (fpHuff || (mhHuff == 0))
                && (fpKey  || (mhKey  == 0))
               ) {
                decomp (fpHuff, fpKey, fpTopic, fpszDest+sizeof(topichdr));
                fRv = FALSE;
                }
            }

        // Unlock the handles, if they were valid.
        //
        if (mhKey != (mh)(-1))
            HelpUnlock (mhKey);
        if (mhHuff != (mh)(-1))
            HelpUnlock (mhHuff);
        }
    else {
        fpszDest = PBLOCK (pbDest);
#if ASCII
/*
** ascii, just copy
*/
        fpTopic = PBLOCK(pbTopic);
        if (fpTopic && fpszDest) {
            hfstrcpy(fpszDest+sizeof(topichdr),fpTopic);
#else
            {
#endif
            fRv = FALSE;
            }
        }
    if (!fRv) {
        ((topichdr far *)fpszDest)->ftype   = fdbLocal.ftype;
        ((topichdr far *)fpszDest)->appChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->linChar = (uchar)fdbLocal.hdr.appChar;
        ((topichdr far *)fpszDest)->lnCur   = 1;
        ((topichdr far *)fpszDest)->lnOff   = sizeof(topichdr);
        }
    PBUNLOCK (pbTopic);
    PBUNLOCK (pbDest);
    }
return fRv;
/* end HelpDecomp */}

/******************************************************************************
**
** HelpNcNext - Return next context number
**
** Purpose:
**  Returns the context number corresponding to a physical "next" in the help
**  file.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcNext (
nc      ncCur
) {
return NextPrev(ncCur,1);       /* get next         */
/* end HelpNcNext */}

/******************************************************************************
**
** HelpNcPrev - Return phyiscally previous context
**
** Purpose:
**  Returns the context number corresponding to the physically previous topic.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcPrev (
nc      ncCur
) {
return NextPrev(ncCur,-1);      /* get previous         */
/* end HelpNcPrev */}

/******************************************************************************
**
** HelpNcUniq - Return nc guaranteed unique for a given topic
**
** Purpose:
**  Maps a context number to a local context number. This is provided such
**  that all context numbers which map to the same topic can be transformed
**  into the same nc which maps to that topic. The information on the
**  context string originally used is lost.
**
** Entry:
**  None
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc far pascal LOADDS HelpNcUniq (
nc      ncCur
) {
fdb     fdbLocal;                       /* pointer to current FDB       */

if (LoadFdb (ncCur.mh, &fdbLocal))
    if (fdbLocal.ftype & FTCOMPRESSED) {
        nc ncTmp;

        ncTmp.mh = fdbLocal.ncInit.mh;
        ncTmp.cn = MapContexttoTopic(ncCur, &fdbLocal);
        ncTmp.cn |= 0x8000;

        ncCur = ncTmp;

        // rjsa return   MapContexttoTopic (ncCur,&fdbLocal)
        //               | (fdbLocal.ncInit & 0xffff0000)
        //               | 0x8000;

    }
return ncCur;
/* end HelpNcUniq */}

/******************************************************************************
**
** NextPrev - Return phyiscally next or previous context
**
** Purpose:
**  Returns the context number corresponding to the physically next or previous
**  topic.
**
** Entry:
**  ncCur       = Current Context
**  fNext       = 1 for next, -1 for previous.
**
** Exit:
**  Returns context number
**
** Exceptions:
**  Returns NULL on any error
**
*/
nc pascal near NextPrev (
    nc  ncCur,
    int fNext
    ) {

    fdb fdbLocal;           /* pointer to current FDB   */
    REGISTER nc ncNext          = {0,0};

    if (LoadFdb (ncCur.mh, &fdbLocal)) {

        //
        // For a compressed file the next/previous physical is computed by taking the
        // context number, mapping it to its corresponding topic number, incrementing
        // or decrementing the topic number (remember, topic numbers are in physical
        // order), and then mapping that back to a context number.
        //
        // When nexting, we also support nexting into any appended file.
        //
        if (fdbLocal.ftype & FTCOMPRESSED) {
            unsigned short cn;

            cn = (ushort)(((ncCur.cn & 0x8000)
                  ? ncCur.cn & 0x7ffff
                  : MapContexttoTopic(ncCur, &fdbLocal))
                  + (ushort)fNext);

            ncNext = MapTopictoContext(cn, (fdb far *)&fdbLocal, fNext);

            // rjsa ncNext = MapTopictoContext((ushort)(((ncCur & 0x8000)
            //                             ? ncCur & 0x7fff
            //                             : MapContexttoTopic (ncCur,&fdbLocal))
            //                            + fNext)
            //                           ,(fdb far *)&fdbLocal);

            //
            // if we could not come up with a next, try to find a next using "local"
            // context numbers. Map the context number to a topic number, and if that is
            // not out of range, return it as a context.
            //
            if (!(ncNext.cn)) {

                // rjsa if ((ncNext = MapContexttoTopic (ncCur,&fdbLocal)) == 0xffff)
                //    ncNext = 0;
                ncNext.cn = MapContexttoTopic(ncCur, &fdbLocal);

                if (ncNext.cn == 0xffff) {

                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;

                } else {

                    ncNext.cn += fNext;

                    if (ncNext.cn >= fdbLocal.hdr.cTopics) {

                        ncNext.mh = (mh)0;
                        ncNext.cn = 0L;

                    } else {

                        // rjsa ncNext |= (fdbLocal.ncInit & 0xffff0000) | 0x8000;
                        ncNext.mh = fdbLocal.ncInit.mh;
                        ncNext.cn = 0x8000;
                    }
                }
            }

            if (!(ncNext.cn & 0x7fff) && (fNext>0)) {
                ncNext = fdbLocal.ncLink;
            }
        }

#if ASCII

            //
            //  minascii files:
            //  next'ing: we just sequentially search the file for the first context to
            //  come along after that pointed to by our current context number.
            //
          else if (fdbLocal.ftype & FTFORMATTED) {

            if (fNext > 0) {

                ncNext.cn = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)+4, HelpCmp);
                if (ncNext.cn == -1L) {
                    ncNext.mh = (mh)0;
                    ncNext.cn = 0L;
                } else {
                    ncNext = combineNc(ncNext.cn, ncCur.mh);
                }
                // rjsa ncNext = (ncNext == -1L)
                //         ? 0
                //         : combineNc(ncNext,HIGH(ncCur));

            }  else {

                nc  ncTemp;

                //
                //  prev'ing: start at the begining of the file, looking for the last context
                //  which is less than the current one.
                //

                ncNext = ncTemp = fdbLocal.ncInit;
                while (NctoFo(ncTemp.cn) < NctoFo(ncCur.cn)) {
                    ncNext = ncTemp;
                    ncTemp.cn = maLocate(&fdbLocal,szNil,NctoFo(ncTemp.cn)+4, HelpCmp);

                    if (ncTemp.cn == -1L) {
                        ncTemp.mh = (mh)0;
                        ncTemp.cn = 0L;
                    } else {
                        ncTemp = combineNc(ncTemp.cn,fdbLocal.ncInit.mh);
                    }
                    // rjsa ncTemp = (ncTemp == -1L)
                    //         ? 0
                    //         : combineNc(ncTemp,HIGH(fdbLocal.ncInit));
                }
            }
        }
#endif
    }
    return ncNext;
}

/*************************************************************************
**
** HelpSzContext - Return string mapping to context number
**
** Purpose:
**  Construct a string, which when looked-up, will return the passed context
**  number.
**
** Entry:
**  pBuf        = place to put the string
**  ncCur       = The context number desired
**
** Exit:
**  True on sucess.
**
*/
f pascal far LOADDS HelpSzContext (
uchar far *pBuf,
nc      ncCur
) {
f       fRet            = FALSE;        /* return value                 */
ulong   i;
fdb     fdbLocal;                       /* pointer to current FDB       */
mh      mhCur;                          /* handle we're dealing with    */
char far *fpszContexts;                 /* pointer to context strings   */

*pBuf = 0;
if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* lock fdb down        */
/*
** Everybody starts with a filename
*/
    if (*fdbLocal.hdr.fname)
        pBuf = hfstrcpy(pBuf,fdbLocal.hdr.fname);
    else
        pBuf = hfstrcpy(pBuf,fdbLocal.fname);
    *(ushort far *)pBuf = '!';                  /* includes null term   */
    pBuf++;
    fRet = TRUE;

    // if we've been given a local context number, see if we can synthesize
    // a context number from which we might get a string. If we can't get
    // one, then return just the filename.
    //
    if ((i = ncCur.cn) & 0x8000)  {           /* context #            */
        ncCur = MapTopictoContext ((ushort)(ncCur.cn & 0x7fff),&fdbLocal,0);
        if ((i = ncCur.cn) & 0x8000)          /* context #            */
            return fRet;
        }
/*
** For compressed files (signified by being able to load context strings) we
** just walk the context strings looking for string number "ncCur". Once found,
** the returned string is just the concatenated filename, "!" and context
** string.
*/
    mhCur = LoadPortion(HS_CONTEXTSTRINGS, ncCur.mh);
    if (mhCur && (mhCur != (mh)(-1)) && (fpszContexts = HelpLock(mhCur))) {
        if (i && (i <= fdbLocal.hdr.cContexts)) {
            while (--i)
                while (*fpszContexts++);/* point to next string         */
            hfstrcpy(pBuf,fpszContexts);/* copy over                    */
            }
        HelpUnlock (mhCur);
        }
    else if (fdbLocal.ftype & FTCOMPRESSED)
        return FALSE;
#if ASCII
/*
** for min ascii files, we search for the topic, and copy over the context
** string directly from the file.
*/
    else if (fdbLocal.ftype & FTFORMATTED) {
        long fpos;

        if ((fpos = maLocate(&fdbLocal,szNil,NctoFo(ncCur.cn)-1,HelpCmp)) != -1L) {
            fpos = ReadHelpFile(fdbLocal.fhHelp,fpos+2,pBuf,80);
            *(pBuf+fpos) = 0;           /* ensure terminated            */
            if (pBuf = hfstrchr(pBuf,'\r'))
                *pBuf = 0;              /* terminate at CR              */
            }
        }
#endif
    }
return fRet;
/* end HelpSzContext */}

/******************************************************************************
**
** LoadPortion - Load a section of the help file
**
** Purpose:
**  If not loaded, allocates memory for and loads a section (as defined in
**  helpfile.h) of the current help file. Once loaded, or if already loaded,
**  locks it, and returns the the memory handle and pointer.
**
**  This routine must be far, since it is an entry point for HelpMake
**
** Entry:
**  hsCur       = Help section to be loaded.
**  mhfdb       = memory handle for fdb
**
** Exit:
**  returns handle for memory
**
** Exceptions:
**  returns NULL on portion not existing, 0xffff on inability to allocate memory.
**
*/
mh pascal near LoadPortion (
int     hsCur,
mh      mhfdb
) {
fdb     fdbLocal;
char far *fpDest        = 0;
int     i;
mh      mhNew           = 0;            /* pointer to mh destination    */
ushort  osize;                          /* additional prepended size    */
ushort  size;

if (LoadFdb (mhfdb, &fdbLocal)) {
    if (((mhNew = fdbLocal.rgmhSections[hsCur]) == 0)
        && fdbLocal.hdr.tbPos[hsCur]) {

        for (i=hsCur+1; i<HS_count; i++)
            if (fdbLocal.hdr.tbPos[i]) {
                size = (ushort)(fdbLocal.hdr.tbPos[i]-fdbLocal.hdr.tbPos[hsCur]);
                break;
                }

        osize = (hsCur == HS_KEYPHRASE) ? 1024*sizeof(PVOID) : 0;
/*
** Alloc the memory required. Re-read the FDB, incase intervening calls to
** HelpShrink causes deallocs of other beasties.
*/
        if (   (mhNew = HelpAlloc(size + osize))
            && LoadFdb (mhfdb, &fdbLocal)) {
            fdbLocal.rgmhSections[hsCur] = mhNew;
            if (PutFdb (mhfdb, &fdbLocal)) {
                fpDest = (char far *)HelpLock(mhNew);
                if (fpDest && ReadHelpFile(fdbLocal.fhHelp
                                           ,(ulong)fdbLocal.hdr.tbPos[hsCur] + fdbLocal.foff
                                           ,fpDest + osize
                                           ,size)) {

                    if (hsCur == HS_KEYPHRASE)
                        kwPtrBuild(fpDest,size);/* build keyword pointers       */
                    HelpUnlock (mhNew);
                    }
                else {
                    fdbLocal.rgmhSections[hsCur] = 0;
                    HelpDealloc (mhNew);
                    PutFdb (mhfdb, &fdbLocal);
                    mhNew = (mh)(-1);
                    }
                }
            else
                mhNew = (mh)0;
            }
        else
            mhNew = (mh)(-1);
        }
    }

return mhNew;

/* end LoadPortion */}

/*************************************************************************
**
** SizePos - Return count of bytes in compressed topic, and position
**
** Purpose:
**  Returns the size in bytes of the compressed topic, and it's location in the
**  help file.
**
** Entry:
**  ncCur       - Context number to return info on.
**  psize       - Pointer to place to put the size
**  ppos        - Pointer to place to put the position
**
** Exit:
**  Returns TRUE on success.
**
** Exceptions:
**  Returns FALSE on all errors.
**
** Algorithm:
**
**  If current help handle valid
**      If filetype is compressed
**          If context map not loaded, load it
**          Lock context map
**          Map context to topic number
**          Unlock context map
**          If topic index not loaded, load it
**          Lock topic index
**          size is difference in file positions
**          Unlock topic index
**      else if filetype is formatted ascii
**          seek to context file position
**          scan for next context definition
**          size is difference in file positions
**      else if filetype is unformatted ascii
**          size is filesize
*/
f pascal near SizePos (
nc      ncCur,
ushort  *psize,
ulong   *ppos
) {
fdb     fdbLocal;                       /* pointer to current FDB       */
char far *fpT;                          /* temp pointer                 */
REGISTER f fRv      = FALSE;            /* return value                 */
ushort  iTopic;                         /* topic index                  */
mh      mhCur;                          /* handle being locked          */

if (LoadFdb (ncCur.mh, &fdbLocal)) {     /* get fdb copy         */
    if (fdbLocal.ftype & FTCOMPRESSED) {/* if a standard compressed file*/
        if ((iTopic = MapContexttoTopic (ncCur,&fdbLocal)) != 0xffff) {
            mhCur = LoadPortion(HS_INDEX,ncCur.mh);
            if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
                *ppos = ((long far *)fpT)[iTopic];
                *psize = (ushort)(((long far *)fpT)[iTopic+1] - *ppos);
                HelpUnlock (mhCur);
                fRv = TRUE;
                }
            }
        }

#if ASCII
    else if (fdbLocal.ftype & FTFORMATTED) {/* if a formatted ascii file*/
        if ((*psize = (ushort)(maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)+4, HelpCmp)))
            == 0xffff)
            *psize = (ushort)ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        else
            *psize -= (ushort)NctoFo(ncCur.cn);
        *ppos  = (ulong) maLocate(&fdbLocal, szNil, NctoFo(ncCur.cn)-1, HelpCmp);
        fRv = TRUE;
        }
    else {                              /* unformatted ascii            */
        *ppos = ReadHelpFile(fdbLocal.fhHelp,0L,NULL,0);
        *psize = (*ppos > (ulong)(65535-sizeof(topichdr)-4))
                 ? (ushort)(65535-sizeof(topichdr)-4)
                 : (ushort)*ppos;
        *ppos = 0L;                     /* position is always zero.     */
        fRv = TRUE;
        }
#endif
    }

return fRv;
/* end SizePos */}

/************************************************************************
**
** MapContexttoTopic
**
** Purpose:
**  Given a context number, return the topic number which it maps to. This
**  is just a direct index of the context number into the context map.
**
** Entry:
**  ncCur       = context number to be mapped
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns zero based topic number, or 0xffff on error.
*/
ushort pascal near MapContexttoTopic (
nc      ncCur,                          /* context number to map        */
fdb far *fpfdbCur                       /* pointer to current FDB       */
) {
REGISTER ushort topic = 0xffff;         /* value to return              */
ushort far *fpT;                        /* pointer to context map       */
mh      mhCur;                          /* handle being locked          */

if (ncCur.cn) {
/*
** Local contexts: the topic number is already encoded in the low word, if the
** high bit of that word is set.
*/
    if (ncCur.cn & 0x8000)
        topic = (ushort)(ncCur.cn & 0x7fff);
/*
** Normal Contexts: low word of nc is an index into the context map which
** returns the topic number
*/
    else {
        mhCur = LoadPortion(HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
        if (mhCur && (mhCur != (mh)(-1)) && (fpT = HelpLock(mhCur))) {
            topic = fpT[ncCur.cn-1];
            HelpUnlock (mhCur);
            }
        }
    }
return topic;
/* end MapContexttoTopic */}

/************************************************************************
**
** MapTopictoContext
**
** Purpose:
**  Given a topic number, return a context which maps to it.
**
**  This involves searching the context map for the first context entry that
**  maps to the desired topic number.
**
** Entry:
**  iTopic      = topic number to map back to a context number
**  fpfdbCur    = pointer to associated fdb
**
** Exit:
**  Returns a valid nc into the file.
**
** Exceptions:
**  If the incoming iTopic is invalid, or a read error occurs, then the nc
**  returned refers to the topic number 0.
**
*/
nc pascal near MapTopictoContext(
ushort  iTopic,                         /* topic number to map          */
fdb far *fpfdbCur,           /* pointer to current FDB   */
int     Dir
) {
    ushort  cTopics;                /* number of topics to search   */
    ushort  far *fpContextMap;      /* pointer to the context map   */
    mh      mhPortion;              /* mem handle for the context map*/
    nc      ncMatch     = {0,0};    /* return value                 */

    mhPortion = LoadPortion (HS_CONTEXTMAP,fpfdbCur->ncInit.mh);
    if (mhPortion && (mhPortion != (mh)(-1))) {
        if (fpContextMap = HelpLock(mhPortion)) {
            if (iTopic >= fpfdbCur->hdr.cTopics) {
                iTopic = 0;
            }
            ncMatch.mh = (mh)0L;
            ncMatch.cn = 0x8000 | iTopic;
            // rjsa ncMatch = 0x8000 | iTopic;
            cTopics = 0;
            while (cTopics < fpfdbCur->hdr.cContexts) {
                if ( Dir == 0 ) {
                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }
                } else if ( Dir > 0 ) {
                    if (iTopic <= fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;      /* nc's are one based           */
                        break;
                    }

                } else if ( Dir < 0 ) {

                    if (iTopic == fpContextMap[cTopics++]) {
                        ncMatch.cn = cTopics;
                        break;
                    } else if (iTopic < fpContextMap[cTopics-1]) {
                        ncMatch.cn = cTopics-1;
                        break;
                    }
                }
            }
            //if ( iTopic != fpContextMap[cTopics-1] ) {
            //    ncMatch.cn = 0;
            //}
            if ( cTopics >= fpfdbCur->hdr.cContexts) {
                ncMatch.cn = 0;
            }
            HelpUnlock (mhPortion);
        }
    }
    ncMatch.mh = (fpfdbCur->ncInit).mh;
    return ncMatch;
    // rjsa return ncMatch | HIGHONLY(fpfdbCur->ncInit);
}

/************************************************************************
**
** LoadFdb - make local copy of fdb.
**
** Purpose:
**  Used to create a local copy of an FDB, so that we don't have to keep a
**  locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpFdbDest   - Pointer to destination for FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near LoadFdb (
mh      mhfdb,
fdb far *fpfdbDest
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbDest = *fpfdbCur;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end LoadFdb */}

/************************************************************************
**
** PutFdb - make local copy of fdb permanent.
**
** Purpose:
**  Used to copy a local copy of an FDB to the "real" one, so that we don't
**  have to keep a locked, far copy around.
**
** Entry:
**  mhFdb       - memory handle for the FDB
**  fpfdbSrc    - Pointer to source of FDB copy
**
** Exit:
**  returns TRUE if FDB copied.
*/
f pascal near PutFdb (
mh      mhfdb,
fdb far *fpfdbSrc
) {
fdb far *fpfdbCur;                      /* pointer to current FDB       */

if (fpfdbCur = HelpLock (mhfdb)) {
    *fpfdbCur = *fpfdbSrc;
    HelpUnlock (mhfdb);
    return TRUE;
    }
return FALSE;
/* end PutFdb */}

#if ASCII
/************************************************************************
**
** maLocate - Locate context in minimally formatted ascii file.
**
** Purpose:
**  Performs sequential searches on mimimally formatted ascii files to locate
**  lines beginning with ">>" and a context string.
**
** Entry:
**  fpfdbCur    = Pointer to current fdb
**  fpszSrc     = Pointer to context string to be found (or null for next
**                string)
**  offset      = offset at which to begin search.
**  lpfnCMp     = pointer to comparison routine to use
**
** Exit:
**  returns file offset of ">>" of context string.
**
** Exceptions:
**  returns -1 on error.
**
*/
long pascal near maLocate (
fdb far *fpfdbCur,
uchar far *fpszSrc,
ulong   offset,
f (pascal far *lpfnCmp)(uchar far *, uchar far *, ushort, f, f)
) {
uchar   buffer[MASIZE+1];               /* input buffer                 */
ushort  cbBuf           = 0;            /* count of bytes in buffer     */
ushort  cbSrc;                          /* length of source string      */
uchar far *pBuf;                        /* pointer into buffer          */
uchar far *pBufT;                       /* temp pointer into buffer     */

cbSrc = hfstrlen(fpszSrc)+1;            /* get length of input          */
if (offset == 0xffffffff)               /* special case                 */
    offset = 0;
while (cbBuf += (ushort)ReadHelpFile(fpfdbCur->fhHelp
                             , offset+cbBuf
                             , buffer+cbBuf
                             , MASIZE-cbBuf)) {

    buffer[cbBuf] = 0;                  /* ensure strings terminated    */
    pBuf = &buffer[0];
    while (pBuf = hfstrchr(pBuf,'>')) { /* look for start of context    */
        if ((*(pBuf+1) == '>')          /* if >> found                  */
            && ((*(pBuf-1) == '\n')     /* at beginning of line         */
                || ((offset == 0)       /* or beginning of file         */
                    && (pBuf == (char far *)&buffer[0])))) {
            pBufT = pBuf +2;
            if (lpfnCmp (fpszSrc, pBufT, cbSrc, FALSE, TRUE))
                return offset + (ulong)(pBuf - (uchar far *)&buffer[0]);
            }
        pBuf += 2;
        }
    if (cbBuf == MASIZE) {              /* if buffer full               */
        hfstrcpy(buffer,buffer+MASIZE-MAOVER);  /* copy down overlap    */
        cbBuf = MAOVER;                         /* and leave that in    */
        offset += MASIZE-MAOVER;        /* file pos of buffer[0]        */
        }
    else {
        offset += cbBuf;
        cbBuf = 0;                      /* else we're empty             */
        }
    }
return -1;

/* end maLocate */}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\console.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.h

Abstract:

    Interface to the console-management functions for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/




//
//  Some common typedefs...
//
typedef ULONG   ROW,            *PROW;              //  row
typedef ULONG   COLUMN,         *PCOLUMN;           //  column
typedef DWORD   KBDMODE,        *PKBDMODE;          //  Keyboard mode
typedef DWORD   ATTRIBUTE,      *PATTRIBUTE;        //  Screen Attribute
typedef PVOID   PSCREEN;                            //  The screen



//
//  Console Input Mode flags. They are the same as the NT flags
//
#define CONS_ENABLE_LINE_INPUT      ENABLE_LINE_INPUT
#define CONS_ENABLE_PROCESSED_INPUT ENABLE_PROCESSED_INPUT
#define CONS_ENABLE_ECHO_INPUT      ENABLE_ECHO_INPUT
#define CONS_ENABLE_WINDOW_INPUT    ENABLE_WINDOW_INPUT
#define CONS_ENABLE_MOUSE_INPUT     ENABLE_MOUSE_INPUT

//
//	Cursor styles
//
#define 	CURSOR_STYLE_UNDERSCORE 	0
#define 	CURSOR_STYLE_BOX			1


//
//  The information about a screen is retrieved in the following
//  structure:
//
typedef struct SCREEN_INFORMATION {
    ROW     NumberOfRows;       //  Number of rows
    COLUMN  NumberOfCols;       //  Number of columns
    ROW     CursorRow;          //  Cursor row position
    COLUMN  CursorCol;          //  Cursor column position
} SCREEN_INFORMATION, *PSCREEN_INFORMATION;




//
//  The information about each keystroke is returned in
//  the KBDKEY structure.
//
typedef struct KBDKEY {
    WORD    Unicode;        // character unicode
    WORD    Scancode;       // key scan code
    DWORD   Flags;          // keyboard state flags
} KBDKEY, *PKBDKEY;

//
//  The following macros access particular fields within the
//  KBDKEY structure. They exist to facilitate porting of OS/2
//  programs.
//
#define KBDKEY_ASCII(k)     (UCHAR)((k).Unicode)
#define KBDKEY_SCAN(k)      ((k).Scancode)
#define KBDKEY_FLAGS(k)     ((k).Flags)


#define NEXT_EVENT_NONE 	0
#define NEXT_EVENT_KEY		1
#define NEXT_EVENT_WINDOW	2

//
// ControlKeyState flags. They are the same as the NT status flags.
//
#define CONS_RIGHT_ALT_PRESSED     RIGHT_ALT_PRESSED
#define CONS_LEFT_ALT_PRESSED      LEFT_ALT_PRESSED
#define CONS_RIGHT_CTRL_PRESSED    RIGHT_CTRL_PRESSED
#define CONS_LEFT_CTRL_PRESSED     LEFT_CTRL_PRESSED
#define CONS_SHIFT_PRESSED         SHIFT_PRESSED
#define CONS_NUMLOCK_PRESSED       NUMLOCK_ON
#define CONS_SCROLLLOCK_PRESSED    SCROLLLOCK_ON
#define CONS_CAPSLOCK_PRESSED      CAPSLOCK_ON
#define CONS_ENHANCED_KEY          ENHANCED_KEY





//
//  Screen Management functions
//
PSCREEN
consoleNewScreen (
    void
    );

BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    );

PSCREEN
consoleGetCurrentScreen (
    void
    );

BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    );

BOOL
consoleGetScreenInformation (
    PSCREEN             pScreen,
    PSCREEN_INFORMATION pScreenInformation
    );

BOOL
consoleSetScreenSize (
     PSCREEN Screen,
     ROW     Rows,
     COLUMN  Cols
	);



//
//  Cursor management
//
BOOL
consoleSetCursor (
     PSCREEN pScreen,
     ROW     Row,
     COLUMN  Col
    );

//
//	Cursor style
//
BOOL
consoleSetCursorStyle (
     PSCREEN pScreen,
     ULONG   Style
	);



//
//  Screen output functions
//
ULONG
consoleWriteLine (
    PSCREEN     pScreen,
     PVOID       pBuffer,
     ULONG       BufferSize,
     ROW         Row,
     COLUMN      Col,
     ATTRIBUTE   Attribute,
     BOOL        Blank
    );

BOOL
consoleShowScreen (
     PSCREEN     pScreen
    );

BOOL
consoleClearScreen (
     PSCREEN     pScreen,
     BOOL        ShowScreen
    );

BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    );

BOOL
consoleScrollVert (
    PSCREEN      pScreen,
    ROW          Top,
    COLUMN       Left,
    ROW          Bottom,
    COLUMN       Right,
    INT          Rows
    );






//
//  Input functions
//
BOOL
consoleFlushInput (
    void
    );

BOOL
consoleIsKeyAvailable (
	void
	);

BOOL
consoleDoWindow (
	void
	);

BOOL
consoleGetKey (
    PKBDKEY        pKey,
     BOOL           fWait
    );

BOOL
consolePutKey (
     PKBDKEY     pKey
    );

BOOL
consolePutMouse (
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

BOOL
consolePeekKey (
    PKBDKEY     pKey
	);

BOOL
consoleGetMode (
    PKBDMODE   Mode
    );

BOOL
consoleSetMode (
     KBDMODE        Mode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\ext.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ext.h

Abstract:

	Microsoft Editor extension definitions.

#ifndef SHIP

    NOTES:
       THIS FILE IS SHIPPED WITH THE PRODUCT!!!!

       BE VERY carefull what gets put into this file. Technically, if it
       is NOT required for extension writers, it does NOT belong here.

    1) This note, the file history and all code within "#ifndef SHIP" and
       "#if defined EDITOR" conditionals should be REMOVED before shipping.

Author:

	Ramon Juan San Andres (ramonsa) 06-Nov-1990 ported from M 1.02

Revision History:

    26-Nov-1991 mz  Strip off near/far


#endif

--*/


#include <windows.h>


//
//  Macro Definitions
//
// BUFLEN is the maximum line length that can be passed or will be returned
// by the editor.
//
#define BUFLEN     251

//
//  NT versions of the editor no longer use 16-bit specific attributes.
//  Set them into ignore state
//

#define near
#define far
#define LOADDS
#define EXPORT
#define EXTERNAL
#define INTERNAL

#undef pascal
#define pascal

//
// RQ_... are various request types supported for Get/Set EditorObject
//
#define RQ_FILE         0x1000          // GetEditorObject: File request
#define RQ_FILE_HANDLE  0x1000          //      File Handle
#define RQ_FILE_NAME    0x1100          //      ASCIIZ filename
#define RQ_FILE_FLAGS   0x1200          //      flags
#define RQ_FILE_REFCNT  0x1300          //      reference count
#define RQ_WIN          0x2000          // Window request
#define RQ_WIN_HANDLE   0x2000          //      Window Handle
#define RQ_WIN_CONTENTS 0x2100          //      Window Contents
#define RQ_WIN_CUR      0x2200          //      Current Window
#define RQ_COLOR        0x9000          // Color request
#define RQ_CLIP         0xf000          // clipboard type

#define RQ_THIS_OBJECT	0x00FF		// function is directed to input object

#define RQ_FILE_INIT	0x00FE		// file is init file

//
// toPif is used when placing numeric or boolean switches in the swiDesc table
// to eliminate C 5.X compiler warnings.
//
// For example: { "Switchname", toPIF(switchvar), SWI_BOOLEAN },
//
#define toPIF(x)  (PIF)(void  *)&x


//
// Editor color table endicies. (Colors USERCOLORMIN - USERCOLORMAX are
// unassigned and available for extension use).
//
#define FGCOLOR         21              // foreground (normal) color
#define HGCOLOR         (1 + FGCOLOR)   // highlighted region color
#define INFCOLOR        (1 + HGCOLOR)   // information color
#define SELCOLOR        (1 + INFCOLOR)  // selection color
#define WDCOLOR         (1 + SELCOLOR)  // window border color
#define STACOLOR        (1 + WDCOLOR)   // status line color
#define ERRCOLOR        (1 + STACOLOR)  // error message color
#define USERCOLORMIN    (1 + ERRCOLOR)  // begining of extension colors
#define USERCOLORMAX    35              // end of extension colors


//
//  General type Definitions
//
typedef int  COL;                       // column or position with line

#if !defined (EDITOR)

#if !defined( _FLAGTYPE_DEFINED_ )
#define _FLAGTYPE_DEFINED_ 1
typedef char flagType;
#endif
typedef long	LINE;					// line number within file
typedef void*	PFILE;					// editor file handle

#if !defined (EXTINT)

typedef void*	 PWND;					// editor window handle

#endif	//	EXTINT

#endif	//	EDITOR


typedef char buffer[BUFLEN];            // miscellaneous buffer
typedef char linebuf[BUFLEN];           // line buffer
typedef char pathbuf[MAX_PATH];         // Pathname buffer


typedef struct fl {                     // file location
    LINE    lin;                        // - line number
    COL     col;                        // - column
} fl;

typedef struct sl {                     // screen location
    int     lin;                        // - line number
    int     col;                        // - column
} sl;

typedef struct rn {                     // file range
    fl      flFirst;                    // - Lower line, or leftmost col
    fl      flLast;                     // - Higher, or rightmost
} rn;


typedef struct lineAttr {               // Line color attribute info
    unsigned char attr;                 // - Attribute of piece
    unsigned char len;                  // - Bytes in colored piece
} lineAttr;

#if !defined (cwExtraWnd)

typedef struct ARC {
	BYTE axLeft;
	BYTE ayTop;
	BYTE axRight;
	BYTE ayBottom;
} ARC;
#endif // cwExtraWnd


//
//  Argument defininition structures.
//
//  We define a structure for each of the argument types that may be
//  passed to an extension function. Then, we define the structure
//  argType which is used to pass these arguments around in a union.
//
typedef struct  noargType {             // no argument specified
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
} NOARGTYPE;

typedef struct textargType {            // text argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
    char    *pText;                     // - ptr to text of arg
} TEXTARGTYPE;

typedef struct  nullargType {           // null argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    y;                          // - cursor line
    COL     x;                          // - cursor column
} NULLARGTYPE;

typedef struct lineargType {            // line argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yStart;                     // - starting line of range
    LINE    yEnd;                       // - ending line of range
} LINEARGTYPE;

typedef struct streamargType {          // stream argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yStart;                     // - starting line of region
    COL     xStart;                     // - starting column of region
    LINE    yEnd;                       // - ending line of region
    COL     xEnd;                       // - ending column of region
} STREAMARGTYPE;

typedef struct boxargType {             // box argument specified
    int     cArg;                       // - count of <arg>s pressed
    LINE    yTop;                       // - top line of box
    LINE    yBottom;                    // - bottom line of bix
    COL     xLeft;                      // - left column of box
    COL     xRight;                     // - right column of box
} BOXARGTYPE;

typedef union ARGUNION {
        struct  noargType       noarg;
	struct	textargType	textarg;
	struct	nullargType	nullarg;
	struct	lineargType	linearg;
	struct	streamargType	streamarg;
        struct  boxargType      boxarg;
} ARGUNION;

typedef struct argType {
    int         argType;
    ARGUNION    arg;
} ARG;



//
//  Function definition table definitions
//
typedef ULONG_PTR CMDDATA;
typedef flagType (*funcCmd)(CMDDATA argData, ARG *pArg, flagType fMeta);

typedef struct cmdDesc {                // function definition entry
    char     *name;                     // - pointer to name of fcn
    funcCmd  func;                      // - pointer to function
    CMDDATA  arg;                       // - used internally by editor
    unsigned argType;                   // - user args allowed
} CMD, *PCMD;


typedef unsigned short KeyHandle;

#define NOARG       0x0001              // no argument specified
#define TEXTARG     0x0002              // text specified
#define NULLARG     0x0004              // arg + no cursor movement
#define NULLEOL     0x0008              // null arg => text from arg->eol
#define NULLEOW     0x0010              // null arg => text from arg->end word
#define LINEARG     0x0020              // range of entire lines
#define STREAMARG   0x0040              // from low-to-high, viewed 1-D
#define BOXARG      0x0080              // box delimited by arg, cursor

#define NUMARG      0x0100              // text => delta to y position
#define MARKARG     0x0200              // text => mark at end of arg

#define BOXSTR      0x0400              // single-line box => text

#define FASTKEY     0x0800              // Fast repeat function
#define MODIFIES    0x1000              // modifies file
#define KEEPMETA    0x2000              // do not eat meta flag
#define WINDOWFUNC  0x4000              // moves window
#define CURSORFUNC  0x8000              // moves cursor



//
//  Switch definition table defintions
//
typedef flagType (*PIF)(char  *);
typedef char*	 (*PIFC)(char *);

typedef union swiAct {                  // switch location or routine
    PIF       pFunc;                    // - routine for text
    PIFC      pFunc2;                   // - routine for text
    int       *ival;                    // - integer value for NUMERIC
    flagType  *fval;                    // - flag value for BOOLEAN
} swiAct;

typedef struct swiDesc {                // switch definition entry
    char    *name;                      // - pointer to name of switch
    swiAct  act;                        // - pointer to value or fcn
    int     type;                       // - flags defining switch type
} SWI, *PSWI;


#define SWI_BOOLEAN 0                   // Boolean switch
#define SWI_NUMERIC 1                   // hex or decimal switch
#define SWI_SCREEN  4                   // switch affects screen
#define SWI_SPECIAL 5                   // textual switch
#define SWI_SPECIAL2 6                  // #5, returning an error string
#define RADIX10 (0x0A << 8)             // numeric switch is decimal
#define RADIX16 (0x10 << 8)             // numeric switch is hex


//
//  Get/Set EditorObject data structures
//
typedef struct winContents{             // define window contents
    PFILE       pFile;                  // - handle of file displayed
    ARC         arcWin;                 // - location of window
    fl          flPos;                  // - upper left corner wrt file
} winContents;


//
// FILE flags values
//
#define DIRTY       0x01                // file had been modified
#define FAKE        0x02                // file is a pseudo file
#define REAL        0x04                // file has been read from disk
#define DOSFILE     0x08                // file has CR-LF
#define TEMP        0x10                // file is a temp file
#define NEW         0x20                // file has been created by editor
#define REFRESH     0x40                // file needs to be refreshed
#define READONLY    0x80                // file may not be editted

#define DISKRO      0x0100              // file on disk is read only
#define MODE1       0x0200              // Meaning depends on the file
#define VALMARKS    0x0400              // file has valid marks defined



//
//  Event processing definitions
//
typedef struct mouseevent {             // mouse event data
    short msg;                          // type of message
    short wParam;                       // CW wParam
    long  lParam;                       // CW lParam
    sl    sl;                           // screen location of mouse event
    fl    fl;                           // file location (if event in win)
} MOUSEEVENT, *PMOUSEEVENT;


typedef struct KEY_DATA {
    BYTE    Ascii;                      //   Ascii code
    BYTE    Scan;                       //   Scan code
    BYTE    Flags;                      //   Flags
    BYTE    Unused;                     //   Unused byte
} KEY_DATA, *PKEY_DATA;

//
//  Following are the values for the Flags field of KEY_DATA
//
#define FLAG_SHIFT      0x01
#define FLAG_CTRL       0x04
#define FLAG_ALT        0x08
#define FLAG_NUMLOCK    0x20


typedef union KEY_INFO {
    KEY_DATA    KeyData;
    long        LongData;
} KEY_INFO, *PKEY_INFO;


typedef union EVTARGUNION {
        KEY_INFO        key;            // keystroke for key event
        char  *         pfn;            // asciiz filename
        PMOUSEEVENT     pmouse;         // ptr to mouse event data
        union Rec       *pUndoRec;      // undo information
} EVTARGUNION;

typedef struct EVTargs {                // arguments to event dispatches
    PFILE       pfile;                  // -file handle for file events
    EVTARGUNION arg;
} EVTargs, *PEVTARGS;


typedef struct eventType {              // event definition struct
    unsigned         evtType;           // - type
    flagType (*func)(EVTargs  *);	// - handler
    struct eventType *pEVTNext;         // - next handler in list
    PFILE            focus;             // - applicable focus
    EVTargs          arg;               // - applicable agruments
} EVT, *PEVT;

#define EVT_RAWKEY	    1		// ALL keystrokes
#define EVT_KEY 	    2		// Editting keystrokes
#define EVT_GETFOCUS	    3		// file GETs focus.
#define EVT_LOSEFOCUS	    4		// file looses focus.
#define EVT_EXIT	    5		// about to exit.
#define EVT_SHELL	    6		// about to sell or compile
#define EVT_UNLOAD	    7		// about to be unloaded.
#define EVT_IDLE	    8		// idle event
#define EVT_CANCEL	    9		// do-nothing cancel
#define EVT_REFRESH	    10		// about to refresh a file
#define EVT_FILEREADSTART   11          // about to read file
#define EVT_FILEREADEND     12          // finshed reading file
#define EVT_FILEWRITESTART  13          // about to write file
#define EVT_FILEWRITEEND    14          // finshed writing file
//			    15
//			    16
//			    17
//			    18
//			    19
#define EVT_EDIT	    20		// editting action
#define EVT_UNDO	    21		// undone action
#define EVT_REDO	    22		// redone action


//
//  Undo, Redo and Edit event structs
//
#define EVENT_REPLACE     0
#define EVENT_INSERT      1
#define EVENT_DELETE      2
#define EVENT_BOUNDARY    3

#if !defined (EDITOR)
typedef struct replaceRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of repalcement
    LINE    line;                       // start of replacement
} REPLACEREC;

typedef struct insertRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of file
    LINE    line;                       // line number that was operated on
    LINE    cLine;                      // number of lines inserted
} INSERTREC;

typedef struct deleteRec {
    int     op;                         // operation
    long    dummy[2];                   // editor interal
    LINE    length;                     // length of file
    LINE    line;                       // line number that was operated on
    LINE    cLine;                      // Number of lines deleted
} DELETEREC;

typedef struct boundRec {
    int     op;                         // operation (BOUND)
    long    dummy[2];                   // editor interal
    int     flags;                      // flags of file
    long    modify;                     // Date/Time of last modify
    fl      flWindow;                   // position in file of window
    fl      flCursor;                   // position in file of cursor
} BOUNDREC;

typedef union Rec {
    struct replaceRec r;
    struct insertRec  i;
    struct deleteRec  d;
    struct boundRec   b;
} REC;
#endif  // editor



//
//  Build command definitions
//
#define MAKE_FILE               1       // rule is for a filename
#define MAKE_SUFFIX             2       // rule is a suffix rule
#define MAKE_TOOL               4       // rule is for a tool
#define MAKE_BLDMACRO           8       // rule is for a build macro
#define MAKE_DEBUG              0x80    // rule is debug version


#define LOWVERSION  0x0014		// lowest version of extensions we handle
#define HIGHVERSION 0x0014		// highest version of extensions we handle

#define VERSION     0x0014		// our current version

typedef struct ExtensionTable {
    long	version;
    long	cbStruct;
    PCMD	cmdTable;
    PSWI	swiTable;
    struct CallBack {
	PFILE	    (*AddFile) (char  *);
	flagType    (*BadArg) (void);
	char	    (*Confirm) (char *, char *);
	void	    (*CopyBox) (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
	void	    (*CopyLine) (PFILE, PFILE, LINE, LINE, LINE);
	void	    (*CopyStream) (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
	void	    (*DeRegisterEvent) (EVT  *);
	flagType    (*DeclareEvent) (unsigned, EVTargs	*);
	void	    (*DelBox) (PFILE, COL, LINE, COL, LINE);
	void	    (*DelFile) (PFILE);
	void	    (*DelLine) (PFILE, LINE, LINE);
	void	    (*DelStream) (PFILE, COL, LINE, COL, LINE);
	void	    (*Display) (void);
    int         (*DoMessage) (char  *);
	flagType    (*fChangeFile) (flagType, char  *);
	void	    (*Free) (void  *);
	flagType    (*fExecute) (char  *);
    int         (*fGetMake) (int, char  *, char  *);
	LINE	    (*FileLength) (PFILE);
	PFILE	    (*FileNameToHandle) (char  *, char	*);
	flagType    (*FileRead) (char  *, PFILE);
	flagType    (*FileWrite) (char	*, PFILE);
	PSWI	    (*FindSwitch) (char  *);
	flagType    (*fSetMake) (int, char  *, char  *);
	flagType    (*GetColor) (LINE, lineAttr  *, PFILE);
	void	    (*GetTextCursor) (COL  *, LINE	*);
	flagType    (*GetEditorObject) (unsigned, void *, void	*);
	char *	    (*GetEnv) (char  *);
    int         (*GetLine) (LINE, char  *, PFILE);
	char *	    (*GetListEntry) (PCMD, int, flagType);
	flagType    (*GetString) (char	*, char  *, flagType);
    int         (*KbHook) (void);
	void	    (*KbUnHook) (void);
    void *      (*Malloc) (size_t);
	void	    (*MoveCur) (COL, LINE);
	char *	    (*NameToKeys) (char  *, char  *);
	PCMD	    (*NameToFunc) (char  *);
	flagType    (*pFileToTop) (PFILE);
	void	    (*PutColor) (LINE, lineAttr  *, PFILE);
	void	    (*PutLine) (LINE, char  *, PFILE);
    int         (*REsearch) (PFILE, flagType, flagType, flagType, flagType, char  *, fl  *);
	long	    (*ReadChar) (void);
	PCMD	    (*ReadCmd) (void);
	void	    (*RegisterEvent) (EVT  *);
    void        (*RemoveFile) (PFILE);
	flagType    (*Replace) (char, COL, LINE, PFILE, flagType);
	char *	    (*ScanList) (PCMD, flagType);
    int         (*search) (PFILE, flagType, flagType, flagType, flagType, char  *, fl  *);
	void	    (*SetColor) (PFILE, LINE, COL, COL, int);
	flagType    (*SetEditorObject) (unsigned, void *, void	*);
	void	    (*SetHiLite) (PFILE, rn, int);
	flagType    (*SetKey) (char  *, char  *);
	flagType    (*SplitWnd) (PWND, flagType, int);
	} CallBack;
    } EXTTAB;

//
//	Editor low level function prototypes.
//
//  This list defines the routines within the editor which may be called
//  by extension functions.
//
#if !defined (EDITOR)

extern EXTTAB ModInfo;

#define AddFile(x)		    ModInfo.CallBack.AddFile(x)
#define BadArg			    ModInfo.CallBack.BadArg
#define Confirm(x,y)		    ModInfo.CallBack.Confirm(x,y)
#define CopyBox(x,y,z,a,b,c,d,e)    ModInfo.CallBack.CopyBox(x,y,z,a,b,c,d,e)
#define CopyLine(x,y,z,a,b)	    ModInfo.CallBack.CopyLine(x,y,z,a,b)
#define CopyStream(x,y,z,a,b,c,d,e) ModInfo.CallBack.CopyStream(x,y,z,a,b,c,d,e)
#define DeRegisterEvent(x)	    ModInfo.CallBack.DeRegisterEvent(x)
#define DeclareEvent(x,y)	    ModInfo.CallBack.DeclareEvent(x,y)
#define DelBox(x,y,z,a,b)	    ModInfo.CallBack.DelBox(x,y,z,a,b)
#define DelFile(x)		    ModInfo.CallBack.DelFile(x)
#define DelLine(x,y,z)		    ModInfo.CallBack.DelLine(x,y,z)
#define DelStream(x,y,z,a,b)	    ModInfo.CallBack.DelStream(x,y,z,a,b)
#define Display 		    ModInfo.CallBack.Display
#define DoMessage(x)		    ModInfo.CallBack.DoMessage(x)
#define fChangeFile(x,y)	    ModInfo.CallBack.fChangeFile(x,y)
#define Free(x) 		    ModInfo.CallBack.Free(x)
#define fExecute(x)		    ModInfo.CallBack.fExecute(x)
#define fGetMake(x,y,z) 	    ModInfo.CallBack.fGetMake(x,y,z)
#define FileLength(x)		    ModInfo.CallBack.FileLength(x)
#define FileNameToHandle(x,y)	    ModInfo.CallBack.FileNameToHandle(x,y)
#define FileRead(x,y)		    ModInfo.CallBack.FileRead(x,y)
#define FileWrite(x,y)		    ModInfo.CallBack.FileWrite(x,y)
#define FindSwitch(x)		    ModInfo.CallBack.FindSwitch(x)
#define fSetMake(x,y,z) 	    ModInfo.CallBack.fSetMake(x,y,z)
#define GetColor(x,y,z) 	    ModInfo.CallBack.GetColor(x,y,z)
#define GetTextCursor(x,y)	    ModInfo.CallBack.GetTextCursor(x,y)
#define GetEditorObject(x,y,z)	    ModInfo.CallBack.GetEditorObject(x,y,z)
#define GetEnv(x)		    ModInfo.CallBack.GetEnv(x)
#define GetLine(x,y,z)		    ModInfo.CallBack.GetLine(x,y,z)
#define GetListEntry(x,y,z)	    ModInfo.CallBack.GetListEntry(x,y,z)
#define GetString(x,y,z)	    ModInfo.CallBack.GetString(x,y,z)
#define KbHook			    ModInfo.CallBack.KbHook
#define KbUnHook		    ModInfo.CallBack.KbUnHook
#define Malloc(x)		    ModInfo.CallBack.Malloc(x)
#define MoveCur(x,y)		    ModInfo.CallBack.MoveCur(x,y)
#define NameToKeys(x,y) 	    ModInfo.CallBack.NameToKeys(x,y)
#define NameToFunc(x)		    ModInfo.CallBack.NameToFunc(x)
#define pFileToTop(x)		    ModInfo.CallBack.pFileToTop(x)
#define PutColor(x,y,z) 	    ModInfo.CallBack.PutColor(x,y,z)
#define PutLine(x,y,z)		    ModInfo.CallBack.PutLine(x,y,z)
#define REsearch(x,y,z,a,b,c,d)     ModInfo.CallBack.REsearch(x,y,z,a,b,c,d)
#define ReadChar		    ModInfo.CallBack.ReadChar
#define ReadCmd 		    ModInfo.CallBack.ReadCmd
#define RegisterEvent(x)	    ModInfo.CallBack.RegisterEvent(x)
#define RemoveFile(x)		    ModInfo.CallBack.RemoveFile(x)
#define Replace(x,y,z,a,b)	    ModInfo.CallBack.Replace(x,y,z,a,b)
#define ScanList(x,y)		    ModInfo.CallBack.ScanList(x,y)
#define search(x,y,z,a,b,c,d)	    ModInfo.CallBack.search(x,y,z,a,b,c,d)
#define SetColor(x,y,z,a,b)	    ModInfo.CallBack.SetColor(x,y,z,a,b)
#define SetEditorObject(x,y,z)	    ModInfo.CallBack.SetEditorObject(x,y,z)
#define SetHiLite(x,y,z)	    ModInfo.CallBack.SetHiLite(x,y,z)
#define SetKey(x,y)		    ModInfo.CallBack.SetKey(x,y)
#define SplitWnd(x,y,z) 	    ModInfo.CallBack.SplitWnd(x,y,z)


void	    WhenLoaded		(void);

#endif // EDITOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\menu.h ===
/*** menu.h  - macros and constants for menu.c
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#if !defined(CW)
# error This module must be compiled with /DCW
#else

#define DLG_CONST

/****************************************************************************
 *									    *
 * Editor constants							    *
 *									    *
 *  C_MENUSTRINGS_MAX							    *
 *  C_CITEM_MAX 							    *
 *									    *
 ****************************************************************************/

#define C_MENUSTRINGS_MAX 128
#define C_ITEM_MAX	  21


/****************************************************************************
 *									    *
 * Actions associated with menu items					    *
 *									    *
 * Each menu item keeps a value in bParamUser that tells wich kind of action*
 * it is associated with (dialog box, command, macro or "other") and gives  *
 * an index to the associated table (DialogData, CommandData or MacroData). *
 *									    *
 ****************************************************************************/

/*
 * COMDATA structure used for menu items directly relating to editor commands
 */
typedef struct comData {
    PCMD     pCmd;			 /* pointer to command	       */
    flagType fKeepArg;			 /* arg to be used or not      */
    };

/*
 * Mask to get the menu item type
 */
#define iXXXMENU	0xC0

/*
 * Menu item action types
 */
#define iDLGMENU	0x00
#define iCOMMENU	0x40
#define iMACMENU	0x80
#define iOTHMENU	0xC0

/*
 * CommandData indices for menu items directly relating to editor commands
 */
#define iCOMNEXT	iCOMMENU		/*  0 */
#define iCOMSAVEALL	(1 + iCOMNEXT)		/*  1 */
#define iCOMSHELL	(1 + iCOMSAVEALL)	/*  2 */
#define iCOMUNDO	(1 + iCOMSHELL) 	/*  3 */
#define iCOMREPEAT	(1 + iCOMUNDO)		/*  0 */
#define iCOMCUT 	(1 + iCOMREPEAT)	/*  0 */
#define iCOMCOPY	(1 + iCOMCUT)		/*  4 */
#define iCOMPASTE	(1 + iCOMCOPY)		/*  0 */
#define iCOMDROPANCHOR	(1 + iCOMPASTE) 	/*  5 */
#define iCOMANCHOR	(1 + iCOMDROPANCHOR)	/*  0 */
#define iCOMBOXMODE	(1 + iCOMANCHOR)	/*  0 */
#define iCOMREADONLY	(1 + iCOMBOXMODE)	/*  6 */
#define iCOMFINDSEL	(1 + iCOMREADONLY)	/*  0 */
#define iCOMFINDLAST	(1 + iCOMFINDSEL)	/*  7 */
#define iCOMNEXTERR	(1 + iCOMFINDLAST)	/*  8 */
#define iCOMDEBUGBLD	(1 + iCOMNEXTERR)	/*  9 */
#define iCOMRECORD	(1 + iCOMDEBUGBLD)	/* 10 */
#define iCOMRESIZE	(1 + iCOMRECORD)	/* 11 */
#define iCOMMAXIMIZE	(1 + iCOMRESIZE)	/* 12 */

/*
 * MacroData indices for menu items directly relating to pre-defined macros
 */
#define iMACSAVE	iMACMENU		/*  0 */
#define iMACQUIT	(1 + iMACSAVE)		/*  1 */
#define iMACREDO	(1 + iMACQUIT)		/*  2 */
#define iMACCLEAR	(1 + iMACREDO)		/*  3 */
#define iMACPREVERR	(1 + iMACCLEAR) 	/*  4 */
#define iMACSETERR	(1 + iMACPREVERR)	/*  5 */
#define iMACCLEARLIST	(1 + iMACSETERR)	/*  6 */
#define iMACERRWIN	(1 + iMACCLEARLIST)	/*  7 */
#define iMACHSPLIT	(1 + iMACERRWIN)	/*  8 */
#define iMACVSPLIT	(1 + iMACHSPLIT)	/*  9 */
#define iMACCLOSE	(1 + iMACVSPLIT)	/* 10 */
#define iMACASSIGNKEY	(1 + iMACCLOSE) 	/* 11 */
#define iMACRESTORE	(1 + iMACASSIGNKEY)	/* 12 */



/****************************************************************************
 *									    *
 * Menu items with variable content and/or meaning: We store their set of   *
 * data in an ITEMDATA structure and do the update with the UPDITEM macro   *
 *									    *
 ****************************************************************************/

/*
 * ITEMDATA structure used for menu items with variable content and/or meaning
 */
typedef struct {
    BYTE ichHilite;
    BYTE bParamUser;
    WORD wParamUser;
    } ITEMDATA, *PITEMDATA;

/*
 *  UPDITEM (pItem, pItemData)
 *
 *  Where:
 *	pItem	    is an object of type PMENUITEM
 *	pItemData   is an object of type PITEMDATA
 *
 *  Will update Item with ItemData data:
 *
 *	pItem->ichHilite	with pItemData->ichHilite
 *	pItem->bParamUser	with pItemData->bParamUser
 *	pItem->wParamUser	with pItemData->wParamUser
 */
#define UPDITEM(pItem, pItemData) \
    (pItem)->ichHilite	= (pItemData)->ichHilite, \
    (pItem)->bParamUser = (pItemData)->bParamUser,\
    (pItem)->wParamUser = (pItemData)->wParamUser


/****************************************************************************
 *									    *
 * Prdefined Menus and Menuitems data					    *
 *									    *
 * Note:								    *
 *									    *
 *  MENU ID's are comprised of two parts:                                   *
 *									    *
 *    . The high byte identifies the parent menu			    *
 *    . The low byte identifies the actual menu item.			    *
 *									    *
 *  The low byte - 1 can be used as an index into the respective menu	    *
 *  tables providing that the item is in the STATIC part of the menu	    *
 *									    *
 *  For the 'dynamic' part of certain predefined menus, we use id's with    *
 *  low byte values with high bit set. This allow us to still use the low   *
 *  byte as an index for any extension-supplied items we might insert	    *
 *  between the static part and the dynamic part.			    *
 *									    *
 *  Menus with dynamic parts are the File and Run menus (for now..)	    *
 *									    *
 ****************************************************************************/

/*
 * File Menu
 *
 * Note: Alternate files items are dynamic
 *
 */
#define MID_FILE    0x0000
#define RX_FILE     2
#define ICH_FILE    0
#define CCH_FILE    4
#define CCIT_FILE   12
#define WP_FILE     ((12<<9)|(21<<4)|0)

#define MID_NEW 	(MID_FILE + 1)
#define MID_OPEN	(MID_FILE + 2)
#define MID_MERGE	(MID_FILE + 3)
#define MID_NEXT	(MID_FILE + 4)
#define MID_SAVE	(MID_FILE + 5)
#define MID_SAVEAS	(MID_FILE + 6)
#define MID_SAVEALL	(MID_FILE + 7)

#define MID_PRINT	(MID_FILE + 9)
#define MID_SHELL	(MID_FILE + 10)

#define MID_EXIT	(MID_FILE + 12)

#define MID_FILE1	(MID_FILE + 0x80 + 0)
#define MID_FILE2	(MID_FILE + 0x80 + 1)
#define MID_FILE3	(MID_FILE + 0x80 + 2)
#define MID_FILE4	(MID_FILE + 0x80 + 3)
#define MID_FILE5	(MID_FILE + 0x80 + 4)
#define MID_FILE6	(MID_FILE + 0x80 + 5)
#define MID_FILE7	(MID_FILE + 0x80 + 6)
#define MID_MORE	(MID_FILE + 0x80 + 7)


/*
 * Edit Menu
 */
#define MID_EDIT    0x0100
#define RX_EDIT     8
#define ICH_EDIT    0
#define CCH_EDIT    4
#define CCIT_EDIT   18
#define WP_EDIT     ((18<<9)|(18<<4)|1)

#define MID_UNDO	(MID_EDIT + 1)
#define MID_REDO	(MID_EDIT + 2)
#define MID_REPEAT	(MID_EDIT + 3)

#define MID_CUT 	(MID_EDIT + 5)
#define MID_COPY	(MID_EDIT + 6)
#define MID_PASTE	(MID_EDIT + 7)
#define MID_CLEAR	(MID_EDIT + 8)

#define MID_DROPANCHOR	(MID_EDIT + 10)
#define MID_ANCHOR	(MID_EDIT + 11)

#define MID_BOXMODE	(MID_EDIT + 13)
#define MID_READONLY	(MID_EDIT + 14)

#define MID_SETREC	(MID_EDIT + 16)
#define MID_RECORD	(MID_EDIT + 17)
#define MID_EDITMACROS	(MID_EDIT + 18)


/*
 * Search Menu
 */
#define MID_SEARCH    0x0200
#define RX_SEARCH     14
#define ICH_SEARCH    0
#define CCH_SEARCH    6
#define CCIT_SEARCH   14
#define WP_SEARCH     ((14<<9)|(14<<4)|2)

#define MID_FIND	(MID_SEARCH + 1)
#define MID_FINDSEL	(MID_SEARCH + 2)
#define MID_FINDLAST	(MID_SEARCH + 3)
#define MID_REPLACE	(MID_SEARCH + 4)
#define MID_FINDFILE	(MID_SEARCH + 5)

#define MID_NEXTERR	(MID_SEARCH + 7)
#define MID_PREVERR	(MID_SEARCH + 8)
#define MID_SETERR	(MID_SEARCH + 9)
#define MID_ERRWIN	(MID_SEARCH + 10)

#define MID_GOTOMARK	(MID_SEARCH + 12)
#define MID_DEFMARK	(MID_SEARCH + 13)
#define MID_SETMARK	(MID_SEARCH + 14)


/*
 * Make Menu
 */
#define MID_MAKE    0x0300
#define RX_MAKE     22
#define ICH_MAKE    0
#define CCH_MAKE    4
#define CCIT_MAKE   8
#define WP_MAKE     ((8<<9)|(8<<4)|3)

#define MID_COMPILE	(MID_MAKE + 1)
#define MID_BUILD	(MID_MAKE + 2)
#define MID_REBUILD	(MID_MAKE + 3)
#define MID_TARGET	(MID_MAKE + 4)

#define MID_SETLIST	(MID_MAKE + 6)
#define MID_EDITLIST	(MID_MAKE + 7)
#define MID_CLEARLIST	(MID_MAKE + 8)


/*
 * Run Menu
 *
 * Note: User menu items are dynamic
 *
 */
#define MID_RUN    0x0400
#define RX_RUN	   28
#define ICH_RUN    0
#define CCH_RUN    3
#define CCIT_RUN   5
#define WP_RUN	   ((5<<9)|(12<<4)|4)

#define MID_EXECUTE	(MID_RUN + 1)
#define MID_DEBUG	(MID_RUN + 2)

#define MID_RUNAPP	(MID_RUN + 4)
#define MID_CUSTOM	(MID_RUN + 5)

#define MID_USER1	(MID_RUN + 0x80 + 0)
#define MID_USER2	(MID_RUN + 0x80 + 1)
#define MID_USER3	(MID_RUN + 0x80 + 2)
#define MID_USER4	(MID_RUN + 0x80 + 3)
#define MID_USER5	(MID_RUN + 0x80 + 4)
#define MID_USER6	(MID_RUN + 0x80 + 5)

/*
 * Window Menu
 */
#define MID_WINDOW    0x0500
#define RX_WINDOW     33
#define ICH_WINDOW    0
#define CCH_WINDOW    6
#define CCIT_WINDOW   5
#define WP_WINDOW     ((5<<9)|(5<<4)|5)

#define MID_SPLITH	(MID_WINDOW + 1)
#define MID_SPLITV	(MID_WINDOW + 2)
#define MID_SIZE	(MID_WINDOW + 3)
#define MID_MAXIMIZE	(MID_WINDOW + 4)
#define MID_CLOSE	(MID_WINDOW + 5)

/*
 * Options Menu
 */
#define MID_OPTIONS    0x0600
#define RX_OPTIONS     41
#define ICH_OPTIONS    0
#define CCH_OPTIONS    7
#define CCIT_OPTIONS   4
#define WP_OPTIONS     ((4<<9)|(4<<4)|6)

#define MID_DEBUGBLD	(MID_OPTIONS + 1)
#define MID_ENVIRONMENT (MID_OPTIONS + 2)
#define MID_ASSIGNKEY	(MID_OPTIONS + 3)
#define MID_SETSWITCH	(MID_OPTIONS + 4)


/*
 * Extension Menus are last+1 through last+n
 */
#define MID_EXTENSION	0x700




#if !defined(EXTINT)
/****************************************************************************
 *									    *
 *  FARDATA.C  global variables 					    *
 *									    *
 ****************************************************************************/

int	       cMenuStrings;

char *	   MenuTitles [];
char *	   HelpStrings [];
char *	   HelpContexts [];

char *	   MacroData [];
struct comData CommandData [];

ITEMDATA       InitItemData [];

ITEMDATA       SelModeItemData [];
ITEMDATA       MaximizeItemData [];
#endif

#endif	/* if defined(CW) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\extint.h ===
/*** extint.h - include for for internal extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains definitions required by extensions which are internal to Microsoft
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#if defined(CW)
#if !defined(EDITOR)
#define CC 1				/* use a real C compiler	*/
#define cwExtraWnd  5			/* number of extra bytes in PWND*/
#define DLG_CONST			/* are dialogs type const?	*/
#define HELP_BUTTON

#include <cwindows.h>			/* CW definitions		*/
#include <csdm.h>			/* SDM definitions		*/
#include <csdmtmpl.h>			/* SDM dialog template stuff	*/

#define EXTINT	1			/* extint included.		*/
#include "ext.h"			/* real ext.h			*/

#include "menu.h"			/* menu id's & other defs       */
#endif

/************************************************************************
*
*  types and globals needed for handling menu command and dialog boxes.
*  DLGDATA holds all the info needed to handle a dialog boxed menu
*  command.
*
*************************************************************************/
typedef struct DlgData {
    DLG * pDialog;	/* Dialog Template			    */
    int     cbDialog;	    /* size of that template			*/
    WORD    cabi;	    /* CAB index				*/
    flagType (*pfnCab)(HCAB, flagType, TMC); /* massager*/
    } DLGDATA;
#endif

/************************************************************************
*
*  Additional exports.
*
*************************************************************************/
#ifndef EDITOR
TMC		    PerformDialog   (DLGDATA *);
void		    DlgHelp	    (int);
void		    DoEnableTmc     (TMC, BOOL);
flagType	    DoSetDialogCaption	(char *);
void		    DoSzToCab	    (unsigned, char *, WORD);
char *		    DoSzFromCab     (unsigned, char *, WORD, WORD);
void		    DoGetTmcText    (TMC, char *, WORD);
WORD		    DoGetTmcVal     (TMC);
void		    DoSetTmcListWidth (TMC, WORD);
void		    DoSetTmcText    (TMC, char *);
void		    DoSetTmcVal     (TMC, WORD);
void		    DoRedisplayListBox (TMC);
void		    DoTmcListBoxAddString (TMC, char *, BOOL);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\mepext.h ===
/*  zext.h - Z extension structures
 *
 *  Z extension files are identified as follows:
 *
 *  o	Valid EXE-format files
 *
 *  Modifications
 *
 *	26-Nov-1991 mz	Strip off near/far
 *
 */

/*  The beginning of the user's DS is laid out as follows:
 */

struct ExtDS {
    int 		version;
    struct cmdDesc  *cmdTable;
    struct swiDesc  *swiTable;
    unsigned		dgroup;
    unsigned		cCalls;
    unsigned		(*callout[1])();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\mouse.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mouse.h

Abstract:

    Mouse management for MEP

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1991


Revision History:


--*/


//
//  Mouse flags
//
#define MOUSE_CLICK_LEFT      0x0001
#define MOUSE_CLICK_RIGHT     0x0002
#define MOUSE_DOUBLE_CLICK    0x0010


//
//  The Mouse handler
//
void DoMouse( ROW Row, COLUMN Col, DWORD MouseFlags );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\mep.h ===
/*** mep.h - primary include file for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       10-Jan-1991 ramonsa Converted to Win32 API
*   26-Nov-1991 mz  Strip off near/far
*
************************************************************************/

#include <ctype.h>
#include <direct.h>
#include <fcntl.h>
#include <io.h>
#include <malloc.h>
#include <math.h>
#include <process.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <time.h>
#include <stdio.h>
#include <share.h>

//
//  WINDOWS includes
//
#include <windows.h>

#include <dos.h>
#include <tools.h>
#include <remi.h>

#include "console.h"

typedef     HANDLE  FILEHANDLE, *PFILEHANDLE;
typedef     DWORD   ACCESSMODE, *PACCESSMODE;
typedef     DWORD   SHAREMODE,  *PSHAREMODE;
typedef     DWORD   MOVEMETHOD, *PMOVEMETHOD;

#define     ACCESSMODE_READ     GENERIC_READ
#define     ACCESSMODE_WRITE    GENERIC_WRITE
#define     ACCESSMODE_RW       (GENERIC_READ | GENERIC_WRITE)

#define     SHAREMODE_READ      FILE_SHARE_READ
#define     SHAREMODE_WRITE     FILE_SHARE_WRITE
#define     SHAREMODE_NONE      0

#define     FROM_BEGIN          FILE_BEGIN
#define     FROM_CURRENT        FILE_CURRENT
#define     FROM_END            FILE_END

#define     SHAREMODE_RW        (SHAREMODE_READ | SHAREMODE_WRITE)


//
// assertion support
//
// assert  - assertion macro. We define our own, because if we abort we need
//           to be able to shut down cleanly (or at least die trying). This
//           version also saves us some code over the C library one.
//
// asserte - version of assert that always executes the expression, regardless
//           of debug state.
//
#ifdef DEBUG
#define REGISTER
#define assert(exp) { \
    if (!(exp))  \
    _assertexit (#exp, __FILE__, __LINE__); \
    }
#define asserte(exp)        assert(exp)
#else
#define REGISTER register
#define assert(exp)
#define asserte(exp)        ((exp) != 0)
#endif

typedef long LINE;                      // line number within file

//  LINEREC - The text of the file is an array of line pointers/lengths.  A
//  single procedure call can be used to grab the line *AND* its length.
//  Color in the file is an array of pointer to attr/length arrays.

typedef struct _lineRecType {
    PVOID   vaLine;                     // long address of line
    BOOL    Malloced;                   // Ture if address allocated via malloc
    int     cbLine;                     // number of bytes in line
} LINEREC;

//  VALINE (l) - Returns virtual address of the line record
//      (lineRecType) for line l.

#define VALINE(l)   (pFile->plr + (l))

//  Each file that is in memory has a unique descriptor.  This is so that
//  editing the same file in two windows will allow updates to be reflected
//  in both.
//
//  NOTE: pFileNext must be the first field in the structure. Certain places
//  in the code require this.

typedef struct fileType {
    struct  fileType *pFileNext;        // next file in chain
#ifdef DEBUG
    int     id;                         // debug id byte
#endif
    char    *pName;                     // file name
    LINEREC *plr;                       // addr of line table
    BYTE    *pbFile;                    // addr of full file image
    LINE    lSize;                      // number of lines in block
    LINE    cLines;                     // number of lines in file
    PVOID   vaColor;                    // addr of color table
    PVOID   vaHiLite;                   // highlighting info
    PVOID   vaUndoHead;                 // head of undo list
    PVOID   vaUndoTail;                 // end of undo list
    PVOID   vaUndoCur;                  // current pos in undo list
    PVOID   vaMarks;                    // Marks in this file
    int     cUndo;                      // number of undo-able entries
    int     refCount;                   // reference count window references
    int     type;                       // type of this file
    int     flags;                      // flags for dirty, permanent, etc
    time_t  modify;                     // Date/Time of last modify
} *PFILE;


//
//  for the display manager, there is a separate window allocated for each
//  window on the screen.  Each window has display-relevant information.
//
typedef struct windowType *PWND;


//
// ext.h is the include file provided to extension writers. It should contain
// only definitions that are meaningfull to them. The EDITOR definition below
// prevents it from defining some typedefs and function prototypes which
// conflict with editor internals.
//
#define EDITOR
#include "ext.h"

struct windowType {
    struct  instanceType *pInstance;    // address of instance list
    sl      Size;                       // size of window
    sl      Pos;                        // position of window
};

#define BELL            0x07
#define SHELL       "cmd.exe"
#define TMPVER          "TMP4"          // temp file revision

//
//  debug at a certain place
//
#if  defined (DEBUG)

#define MALLOC(x)           DebugMalloc(x, FALSE, __FILE__, __LINE__)
#define REALLOC(x, y)       DebugRealloc(x, y, FALSE,  __FILE__, __LINE__)
#define FREE(x)             DebugFree(x, __FILE__, __LINE__)
#define ZEROMALLOC(x)       DebugMalloc(x, TRUE, __FILE__, __LINE__)
#define ZEROREALLOC(x,y )   DebugRealloc(x, y, TRUE,  __FILE__, __LINE__)
#define MEMSIZE(x)          DebugMemSize(x, __FILE__, __LINE__)

#else

#define MALLOC(x)           malloc(x)
#define REALLOC(x, y)       realloc(x, y)
#define FREE(x)             free(x)
#define ZEROMALLOC(x)       ZeroMalloc(x)
#define ZEROREALLOC(x,y )   ZeroRealloc(x, y)
#define MEMSIZE(x)          MemSize(x)

#endif


//
//  ID's for assertion checking
//
#ifdef DEBUG
#define ID_PFILE    0x5046              // PF
#define ID_INSTANCE 0x494E              // IN
#endif


//
//  list of files and their debug values
//
#define TEXTLINE    0x1
#define ZALLOC      0x2
#define VMUTIL      0x4
#define VM      0x8
#define FILEIO      0x10
#define CMD     0x20
#define PICK        0x40
#define ZINIT       0x80
#define WINDOW      0x100
#define DISP        0x200
#define Z       0x400
#define Z19     0x800
#define LOAD        0x1000

#define MAXWIN       8
#define MAXMAC    1024




//  **************************************************************
//
//      Macros for accessing fields of struct instanceType
//
//  **************************************************************

#define XWIN(f)     (f)->flWindow.col
#define YWIN(f)     (f)->flWindow.lin
#define XCUR(f)     (f)->flCursorCur.col
#define YCUR(f)     (f)->flCursorCur.lin
#define FLAGS(f)    (f)->flags
#define XOLDWIN(f)  (f)->flOldWin.col
#define YOLDWIN(f)  (f)->flOldWin.lin
#define XOLDCUR(f)  (f)->flOldCur.col
#define YOLDCUR(f)  (f)->flOldCur.lin
#define FTYPE(f)    (f)->type




//  **************************************************************
//
//  VACOLOR (l) - Returns virtual address of the color record
//                (colorRecType) for line l.
//
//  **************************************************************

#define VACOLOR(l)  (PVOID)((PBYTE)pFile->vaColor+sizeof(struct colorRecType)*((long)(l)))




//  **************************************************************
//
//  Flags indicating what has changed since the last display update.
//
//      RCURSOR:    The cursor has moved.  This means the cursor should
//                  be physically moved on the screen, and that the
//                  cursor position status should be changed.
//      RTEXT:      The editing area has been changed.  A more precise
//                  breakdown is available by examining the fChange array.
//      RSTATUS:    In the original interface, this means that something
//                  on the bottom screen line has changed.  In the CW
//                  interface, this means something in the status window
//                  has changed (either the insert mode or the learn mode)
//      RHIGH:      This is set to mean highlighting should be displayed.
//      RFILE:      The file-specific information has changed.  CW
//                  interface only.
//      RHELP:      The Help window has changed.  CW interface only.
//
//  **************************************************************

#define RCURSOR     0x01
#define RTEXT       0x02
#define RSTATUS     0x04
#define RHIGH       0x08


//  **************************************************************
//
//  argument types and arg structures
//
//  **************************************************************

#define GETARG      (NOARG|TEXTARG|NULLARG|NULLEOL|NULLEOW|LINEARG|STREAMARG|BOXARG)
                                        // arg processing required

#define COLORBG    -1
#define COLORNOR    0
#define COLORINF    1
#define COLORERR    2
#define COLORSTA    3

#define INTENSE     8

#define WHITE       7
#define YELLOW      6
#define MAGENTA     5
#define RED     4
#define CYAN        3
#define GREEN       2
#define BLUE        1
#define BLACK       0

#define B_BAK       0
#define B_UNDEL     1
#define B_NONE      2

#define MONO        0
#define CGA     1
#define EGA     2
#define VGA     3
#define MCGA        4
#define VIKING      5

#define MAXUSE  20
#define GRAPH   0x01            // parsing editing chars in macro body
#define EXEC    0x02            // macro is an execution; ending sets fBreak
#define INIT    0x04            // macro needs to be initialized

struct macroInstanceType {
    char *beg;                  // pointer to beginning of string
    char *text;                 // pointer to next command
    flagType flags;             // what type of function is next
    };

typedef struct macroInstanceType MI, *PMI;

//
//  flags for fChange
//
#define FMODIFY 0x01            // TRUE => line was modified



//  **************************************************************
//
//  Macros for dealing with windows.
//
//  **************************************************************

#define WINYSIZE(pwin)  ((pwin)->Size.lin)
#define WINXSIZE(pwin)  ((pwin)->Size.col)
#define WINYPOS(pwin)   ((pwin)->Pos.lin)
#define WINXPOS(pwin)   ((pwin)->Pos.col)
#define WININST(pwin)   ((pwin)->pInstance)


#define XSCALE(x)   max(1,(x)*WINXSIZE(pWinCur)/slSize.col)
#define YSCALE(y)   max(1,(y)*WINYSIZE(pWinCur)/slSize.lin)



//  **************************************************************
//
//  for each instance of a file in memory, there is a window that is
//  allocated for it.  The structure has all relevant information for the
//  instance within the window.  No display information is kept here
//
//  **************************************************************

struct instanceType {
    struct  instanceType *pNext;        // ptr to next file activation
#ifdef DEBUG
    int     id;                         // debug id byte
#endif
    PFILE   pFile;                      // ptr to file structure
    fl      flOldWin;                   // previous file pos of window
    fl      flOldCur;                   // previous file cursor
    fl      flWindow;                   // file coord of window
    fl      flCursorCur;                // file pos of cursor
    fl      flSaveWin;                  // saved coord of window
    fl      flSaveCur;                  // saved y coord of cursor
    fl      flArg;                      // Last Arg position
    fl      flCursor;                   // Cursor just before last function
    flagType fSaved;                    // TRUE => values below valid
    };

typedef struct instanceType *PINS;


//  **************************************************************
//
//  Each mark that is defined is present in a linked list
//
//  **************************************************************

typedef struct mark MARK;
typedef struct filemarks FILEMARKS;

struct mark {
    unsigned flags;     //
    unsigned cb;        // Bytes in this mark structure, including name
    fl fl;              // Location of the mark
    char szName[1];     // Name of mark
};

struct filemarks {
    unsigned cb;        // Total bytes in struct, including marks
    MARK marks[1];      // marks for this file
    };



struct colorRecType {
    PVOID   vaColors;                   // Address of lineAttr array
    int     cbColors;
    };

extern struct cmdDesc cmdTable[];

extern struct swiDesc swiTable[];

extern char * cftab[];

struct fTypeInfo {
    char *ext;                          // extention of file type
    int  ftype;                         // numerical type
};

struct compType {
    struct compType *pNext;             // next link in compile list
    char *pExt;                         // pointer to extension
    char *pCompile;                     // pointer to compile text
};

typedef struct compType COMP;

#define TEXTFILE    0
#define CFILE       1
#define ASMFILE     2
#define PASFILE     3
#define FORFILE     4
#define LSPFILE     5
#define BASFILE     6

//
//  return values for FileStatus
//
#define FILECHANGED 0                   // timestamps differ
#define FILEDELETED 1                   // file is not on disk
#define FILESAME    2                   // timestamps match

extern struct fTypeInfo ftypetbl[];
extern char * mpTypepName[];



//  **************************************************************
//
//  Initialization flags.  These are set when an initialization task has
//  been performed.  It is examined in CleanExit to determine what needs
//  to be restored.
//
//  **************************************************************

#define INIT_VIDEO      1               // Video state is set up
#define INIT_KBD        2               // Keyboard is set to editor state
#define INIT_EDITVIDEO  4               // Editor video state is established
#define INIT_SIGNALS    8               // Signal handlers have been set up
#define INIT_VM         0x10            // VM has been initialized




//  **************************************************************
//
//  CleanExit() flags
//
//  **************************************************************

#define CE_VM       1                   // Clean Up VM
#define CE_SIGNALS  2                   // Clean up signals
#define CE_STATE    4                   // Update state file



//  **************************************************************
//
//  zloop() flags
//
//  **************************************************************

#define ZL_CMD      1                   // command key, should be an event
#define ZL_BRK      2                   // take fBreak into account



//  **************************************************************
//
//  getstring() flags
//
//  **************************************************************

#define GS_NEWLINE  1                   // Entry must be terminated by newline
#define GS_INITIAL  2                   // Entry is hilighted and cleared if graphic
#define GS_KEYBOARD 4                   // Entry must from the keyboard
#define GS_GETSTR   8                   // Called from getstring(), not SDM


//  **************************************************************
//
//  type for pointer to function                                                       *
//
//  **************************************************************

typedef void ( *PFUNCTION)(char *, flagType);

//
//  Internal structure of a key
//
typedef struct _EDITOR_KEY {
    KEY_INFO    KeyInfo;
    WORD        KeyCode;
} EDITOR_KEY, *PEDITOR_KEY;



//  **************************************************************
//
//  Editor Globals.
//
//      slSize       -  Under CW, these are the total number of rows and
//                      columns available.  Without CW, these represent the
//                      editing area, which is 2 less.
//
//  **************************************************************

extern  sl    slSize;                   // dimensions of the screen
#define XSIZE  slSize.col
#define YSIZE  slSize.lin

extern  PFILE     pFilePick;            // pick buffer
extern  PFILE     pFileFileList;        // command line file list
extern  PFILE     pFileIni;             // TOOLS.INI
extern  PFILE     pFileMark;             // Current mark definition file
extern  PFILE     pFileAssign;          // <assign>
extern  struct   instanceType *pInsCur; // currently active window
extern  PWND     pWinCur;               // pointer to current window
extern  struct  windowType WinList[];   // head of all windows
extern  int     iCurWin;                // index of current window
extern  int      cWin;                  // count of active windows
extern  PFILE     pFileHead;            // address of head of file list
extern  COMP      *pCompHead;           // address of head of compile extension list
extern  MARK      *pMarkHead;           // address of head of mark list
extern  char      *pMarkFile;           // additional file to search for marks
extern  char      *pPrintCmd;           // pointer to <printcmd> string
extern  PFILE     pPrintFile;           // file currently printed (to PRN)

//
// Global vars for the fScan routine.
//
extern  buffer  scanbuf;                // buffer for file scanning
extern  buffer  scanreal;               // buffer for file scanning
extern  int  scanlen;                   // length of said buffer
extern  fl   flScan;                    // file loc of current scan
extern  rn   rnScan;                    // range of scan

#if DEBUG
extern  int   debug, indent;            // debugging flags
extern  FILEHANDLE debfh;               // debugging output file
#endif

//
// ARG processing vars
//
extern  fl    flArg;                    // file pos of 1st arg
extern  int   argcount;                 // number of args hit
extern  flagType fBoxArg;               // TRUE => boxarg, FALSE => streamarg
extern  ARG      NoArg;                 // predefined no arg struct

extern  flagType fInSelection;          // TRUE => Selecting text

extern  fl   flLow;                     // low values for args
extern  fl   flHigh;                    // high values for args
extern  LINE     lSwitches;             // Line # in <assign> of switches
extern  int  cRepl;                     // number of replaces
extern  COL      xMargin;               // column of right margin
extern  int      backupType;            // type of backup being done
extern  int      cUndelCount;           // max num of undel backups of the same file
extern  char     *ronlypgm;             // program to run on readonly files
extern  buffer   buf;                   // temp line buffer
extern  buffer   textbuf;               // buffer for text arguments
extern  int  Zvideo;                    // Handle for Z video state
extern  int  DOSvideo;                  // Handle for DOS video state
extern  flagType fAskExit;              // TRUE => prompt at exit
extern  flagType fAskRtn;               // TRUE => prompt on return from PUSHED
extern  flagType fAutoSave;             // TRUE => always save files on switches
extern  flagType fBreak;                // TRUE => exit current TopLoop call
extern  flagType fCgaSnow;              // TRUE => CGA has snow, so fix it
extern  flagType *fChange;              // TRUE => line was changed
extern  unsigned fInit;                 // Flags describing what has been initialized
extern  flagType fCtrlc;                // TRUE => control-c interrupt
extern  flagType fDebugMode;            // TRUE => compiles are debug
extern  flagType fMetaRecord;           // TRUE => Don't execute anything
extern  flagType fDefaults;             // TRUE => do not load users TOOLS.INI
extern  flagType fDisplay;              // TRUE => need to redisplay
extern  flagType fDisplayCursorLoc;     // TRUE => pos of cursor vs window displayed
extern  flagType fEditRO;               // TRUE => allow editting of DISKRO files
extern  flagType fErrPrompt;            // TRUE => prompt after errors
extern  flagType fGlobalRO;             // TRUE => no editing allowed
extern  flagType fInsert;               // TRUE => insertmode is on
extern  flagType fMacroRecord;          // TRUE => We're recording into <record>
extern  flagType fMessUp;               // TRUE => there is a message on dialog line
extern  flagType fMeta;                 // TRUE => <meta> command pressed
extern  flagType fMsgflush;             // TRUE => flush previous compile messages
extern  flagType fNewassign;            // TRUE => <assign> needs refreshing
extern  flagType fRealTabs;             // TRUE => tabs are VI-like
extern  flagType fRetVal;               // return value of last editing function call
extern  flagType fSaveScreen;           // TRUE => Restore DOS screen
extern  flagType fShortNames;           // TRUE => do short-filename matching
extern  flagType fSoftCR;               // TRUE => use soft carriage returns
extern  flagType fTabAlign;             // TRUE => allign cursor to tab characters
extern  flagType fTextarg;              // TRUE => text was typed in
extern  flagType fTrailSpace;           // TRUE => allow trailing spaces in lines
extern  flagType fWordWrap;             // TRUE => space in col 72 goes to newline

//
// Search/Replace globals
//
extern  flagType fUnixRE;               // TRUE => Use UNIX RE's (unixre: switch)
extern  flagType fSrchAllPrev;          // TRUE => previously searched for all
extern  flagType fSrchCaseSwit;         // TRUE => case is significant (case: switch)
extern  flagType fSrchCasePrev;         // TRUE => case was significant
extern  flagType fSrchDirPrev;          // TRUE => previously searched forward
extern  flagType fSrchRePrev;           // TRUE => search previously used RE's
extern  flagType fSrchWrapSwit;         // TRUE => searches wrap (wrap: switch)
extern  flagType fSrchWrapPrev;         // TRUE => previously did wrap
extern  flagType fRplRePrev;            // TRUE => replace previously used RE's
extern  buffer   srchbuf;               // search buffer
extern  buffer   srcbuf;                // source string for replace
extern  buffer   rplbuf;                // destination string for replace
extern  flagType fUseMouse;     // TRUE => Handle mouse events

#define SIGBREAK   21                   // Taken from signal.h
extern  flagType fReDraw;               // TRUE => Screen is already locked
extern  unsigned LVBlength;             // Bytes in LVB (returned from VioGetBuf)
extern  unsigned kbdHandle;             // Handle of logical keyboard

extern  HANDLE   semIdle;               // Idle thread semaphore

extern  PCMD     *rgMac;                // set of macro definitions
extern  int  cMac;                      // number of macros

extern  int   ballevel;                 // current level in paren balance
extern  char      *balopen, *balclose;  // balance open string, close string

extern  unsigned kindpick;              // what is in the pick buffer
extern  char     tabDisp;               // character for tab expansion in display
extern  char     trailDisp;             // Character for trailing spaces
extern  char     Name[];                // editor name
extern  char     Version[];             // editor version
extern  char     CopyRight[];           // editor copyright message
extern  int      EnTab;                 // 0 => no tab 1 => min 2 => max tabification
extern  int      tmpsav;                // number of past files to remember
extern  int      hike;                  // value of HIKE: switch
extern  int      vscroll;               // value of VSCROLL: switch
extern  int      hscroll;               // value of HSCROLL: switch
extern  int      tabstops;              // value of TABSTOPS: switch
extern  int      fileTab;               // spacing of tab chars in file
extern  int      CursorSize;            //  cursor size
extern  EDITOR_KEY keyCmd;              // last commands keystroke
#define isaUserMin 21                   // cw min isa, for consistancy in indecies
extern   int     ColorTab[];            // 16 available colors.
#define fgColor     ColorTab[0]         // foreground color
#define hgColor     ColorTab[1]         // highlight color
#define infColor    ColorTab[2]         // information color
#define selColor    ColorTab[3]         // selection color
#define wdColor     ColorTab[4]         // window border color
#define staColor    ColorTab[5]         // status color
#define errColor    ColorTab[6]         // error color
extern  LINE     cNoise;                // number of lines between noise on status
extern  int      cUndo;                 // count of undo operations retained

extern  int   cArgs;                    // number of files on command line
extern  char       **pArgs;             // pointer to files in command line

extern  PFILE       pFileIni;           // pfile for tools.ini

extern  char       * pNameEditor;       // Base name of editor as invoked
extern  char       * pNameTmp;          // Pathname of .TMP file ( based on name )
extern  char       * pNameInit;         // Pathname of tools.ini
extern  char       * pNameHome;         // "INIT", or "HOME" if "INIT" not defined
extern  char      *pComSpec;            // name of command processor
extern  char    *eolText;               // eol characters for text files


extern  struct cmdDesc  cmdUnassigned;  // unassigned function
extern  struct cmdDesc  cmdGraphic;     // self editing function

extern  char *getlbuf;                  // pointer to fast read-in buffer
extern  unsigned getlsize;              // length of buffer

extern  int cMacUse;                    // number of macros in use
extern  struct macroInstanceType mi[];  // state of macros

#define MAXEXT  50

extern  int      cCmdTab;               // number of cmd tables
extern  PCMD       cmdSet[];            // set of cmd tables
extern  PSWI       swiSet[];            // set of swi tables
extern  char      *pExtName[];          // set of extension names
                                        // CONSIDER: making pExtNames be or include
                                        // CONSIDER: the handles, such that arg meta
                                        // CONSIDER: load can discard an extension

extern  PSCREEN OriginalScreen;         //  Original screen
extern  PSCREEN MepScreen;              //  Out screen
extern  KBDMODE OriginalScreenMode;     //  Original screen Mode


//  **************************************************************
//
//  Background threads
//
//  **************************************************************

//
//  A global critical section is used for synchronizing
//  threads
//
extern  CRITICAL_SECTION    IOCriticalSection;
extern  CRITICAL_SECTION    UndoCriticalSection;
extern  CRITICAL_SECTION    ScreenCriticalSection;

#define MAXBTQ  32                      // Maximum number of entries in
                                        // background threads queues
//
// Background thread data structure
//
typedef struct BTD {

    PFILE       pBTFile;                // Log file handle
    LPBYTE      pBTName;                // Log file name
    flagType    flags;                  // Flags: BT_BUSY and BT_UPDATE
    ULONG       cBTQ;                   // # of entries in queue
    ULONG       iBTQPut;                // Index at wich to put next
    ULONG       iBTQGet;                // Index at wich to get next

    CRITICAL_SECTION    CriticalSection;//  Protects critical info
    PROCESS_INFORMATION ProcessInfo;    //  Process information
    HANDLE              ThreadHandle;   //  Thread Handle
    BOOL                ProcAlive;      //  True if child process

    struct {
        PFUNCTION pBTJProc;                     // Procedure to call
        LPBYTE  pBTJStr;                        // Command to spawn or parameter
        }       BTQJob[MAXBTQ];                 // Holds queued jobs
    struct BTD  *pBTNext;               // Next BTD in list
}  BTD;

//
// Background threads flags
//

#define BT_BUSY     1
#define BT_UPDATE   2

#define fBusy(pBTD) (pBTD->flags & BT_BUSY)

#define UpdLog(pBTD)    (pBTD->flags |= BT_UPDATE)
#define NoUpdLog(pBTD)  (pBTD->flags &= ~BT_UPDATE)

//
//  Background compile and print threads
//
extern  BTD    *pBTDComp;                // Compile thread
extern  BTD    *pBTDPrint;               // Print thread


//
// For dual code
//
#define PFILECOMP   pBTDComp->pBTFile


//  **************************************************************
//
//  Constant strings.  Various strings that are used many times are
//  defined here once to save space.  The values are set in ZINIT.C
//
//  Macro versions are also defined to cast to a non-const, for use where
//  where only a non-const expression will do.
//
//  **************************************************************

extern  char rgchComp[];           // "<compile>"
extern  char rgchPrint[];          // "<print>"
extern  char rgchAssign[];         // "<assign>"
extern  char rgchAutoLoad[];       // "m*.mxt" or equiv...
extern  char rgchEmpty[];          // ""
extern  char rgchInfFile[];        // "<information-file>"
extern  char rgchWSpace[];         // our defintion of whitespace
extern  char rgchUntitled[];       // "<untitled>"

#define RGCHASSIGN  ((char *)rgchAssign)
#define RGCHEMPTY   ((char *)rgchEmpty)
#define RGCHWSPACE  ((char *)rgchWSpace)
#define RGCHUNTITLED    ((char *)rgchUntitled)


typedef struct MSG_TXT{
    WORD    usMsgNo;
    LPBYTE  pMsgTxt;
} MSG_TXT;

extern MSG_TXT  MsgStr[];            // Message strings




extern flagType  fInCleanExit;
extern flagType  fSpawned;


#include "meptype.h"
#include "msg.h"


#ifdef FPO
#pragma optimize( "y", off )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\meptype.h ===
/*** ztype.h - forward declarations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Editor functions - forward type declarations to allow for type-checking
*
*   Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/


flagType          assign         (CMDDATA, ARG *, flagType);
flagType          backtab        (CMDDATA, ARG *, flagType);
flagType          begfile        (CMDDATA, ARG *, flagType);
flagType          begline        (CMDDATA, ARG *, flagType);
flagType          BoxStream      (CMDDATA, ARG *, flagType);
flagType          cancel         (CMDDATA, ARG *, flagType);
flagType          cdelete        (CMDDATA, ARG *, flagType);
flagType          compile        (CMDDATA, ARG *, flagType);
flagType          curdate        (CMDDATA, ARG *, flagType);
flagType          curday         (CMDDATA, ARG *, flagType);
flagType          curtime        (CMDDATA, ARG *, flagType);
flagType          delete         (CMDDATA, ARG *, flagType);
flagType          doarg          (CMDDATA, ARG *, flagType);
flagType          down           (CMDDATA, ARG *, flagType);
flagType          emacscdel      (CMDDATA, ARG *, flagType);
flagType          emacsnewl      (CMDDATA, ARG *, flagType);
flagType          endfile        (CMDDATA, ARG *, flagType);
flagType          endline        (CMDDATA, ARG *, flagType);
flagType          environment    (CMDDATA, ARG *, flagType);
flagType          zexecute       (CMDDATA, ARG *, flagType);
flagType          zexit          (CMDDATA, ARG *, flagType);
flagType          graphic        (CMDDATA, ARG *, flagType);
flagType          home           (CMDDATA, ARG *, flagType);
flagType          information    (CMDDATA, ARG *, flagType);
flagType          zinit          (CMDDATA, ARG *, flagType);
flagType          insert         (CMDDATA, ARG *, flagType);
flagType          insertmode     (CMDDATA, ARG *, flagType);
flagType          lastselect     (CMDDATA, ARG *, flagType);
flagType          ldelete        (CMDDATA, ARG *, flagType);
flagType          left           (CMDDATA, ARG *, flagType);
flagType          linsert        (CMDDATA, ARG *, flagType);
flagType          macro          (CMDDATA, ARG *, flagType);
flagType          mark           (CMDDATA, ARG *, flagType);
flagType          zmessage       (CMDDATA, ARG *, flagType);
flagType          meta           (CMDDATA, ARG *, flagType);
flagType          mgrep          (CMDDATA, ARG *, flagType);
flagType          mlines         (CMDDATA, ARG *, flagType);
flagType          mpage          (CMDDATA, ARG *, flagType);
flagType          mpara          (CMDDATA, ARG *, flagType);
flagType          mreplace       (CMDDATA, ARG *, flagType);
flagType          msearch        (CMDDATA, ARG *, flagType);
flagType          mword          (CMDDATA, ARG *, flagType);
flagType          newline        (CMDDATA, ARG *, flagType);
flagType          nextmsg        (CMDDATA, ARG *, flagType);
flagType          noedit         (CMDDATA, ARG *, flagType);
flagType          noop           (CMDDATA, ARG *, flagType);
flagType          pbal           (CMDDATA, ARG *, flagType);
flagType          zpick          (CMDDATA, ARG *, flagType);
flagType          plines         (CMDDATA, ARG *, flagType);
flagType          ppage          (CMDDATA, ARG *, flagType);
flagType          ppara          (CMDDATA, ARG *, flagType);
flagType          zPrint         (CMDDATA, ARG *, flagType);
flagType          psearch        (CMDDATA, ARG *, flagType);
flagType          searchall      (CMDDATA, ARG *, flagType);
flagType          put            (CMDDATA, ARG *, flagType);
flagType          pword          (CMDDATA, ARG *, flagType);
flagType          qreplace       (CMDDATA, ARG *, flagType);
flagType          quote          (CMDDATA, ARG *, flagType);
flagType          record         (CMDDATA, ARG *, flagType);
flagType          refresh        (CMDDATA, ARG *, flagType);
flagType          repeat         (CMDDATA, ARG *, flagType);
flagType          zreplace       (CMDDATA, ARG *, flagType);
flagType          sdelete        (CMDDATA, ARG *, flagType);
flagType          restcur        (CMDDATA, ARG *, flagType);
flagType          right          (CMDDATA, ARG *, flagType);
flagType          saveall        (CMDDATA, ARG *, flagType);
flagType          savetmpfile    (CMDDATA, ARG *, flagType);
flagType          savecur        (CMDDATA, ARG *, flagType);
flagType          setfile        (CMDDATA, ARG *, flagType);
flagType          setwindow      (CMDDATA, ARG *, flagType);
flagType          sinsert        (CMDDATA, ARG *, flagType);
flagType          zspawn         (CMDDATA, ARG *, flagType);
flagType          tab            (CMDDATA, ARG *, flagType);
flagType          ztell          (CMDDATA, ARG *, flagType);
flagType          lasttext       (CMDDATA, ARG *, flagType);
flagType          promptarg      (CMDDATA, ARG *, flagType);
flagType          unassigned     (CMDDATA, ARG *, flagType);
flagType          zundo          (CMDDATA, ARG *, flagType);
flagType          up             (CMDDATA, ARG *, flagType);
flagType          window         (CMDDATA, ARG *, flagType);
flagType          SetWinCur      (int);

/*************************************************************************
 *
 *  Exported entries
 *
 *  Direct Exports
 */
PFILE                    AddFile         (char *);
char                     BadArg          (void);
void                     CopyBox         (PFILE,PFILE,COL ,LINE ,COL ,LINE ,COL ,LINE);
void                     CopyLine        (PFILE,PFILE,LINE ,LINE ,LINE);
void                     CopyStream      (PFILE,PFILE,COL ,LINE ,COL ,LINE ,COL ,LINE);
flagType                 DeclareEvent    (unsigned, EVTargs *);
void                     RegisterEvent   (EVT *pEVTDef);
void                     DeRegisterEvent (EVT *pEVTDef);
void                     DelBox          (PFILE, COL, LINE, COL, LINE);
void                     DelStream       (PFILE, COL, LINE, COL, LINE);
void                     DoDisplay       (void);
LINE                     FileLength      (PFILE);
int                      fGetMake        (int, char *, char *);
flagType                 fSetMake        (int, char *, char *);
unsigned short           hWalkMake       (unsigned short, int *, char *, char *);
void                     GetTextCursor   (COL *, LINE *);
flagType                 GetEditorObject (unsigned, void *, void *);
void                     MoveCur         (COL ,LINE);
flagType                 pFileToTop      (PFILE);
void                     postspawn       (flagType);
flagType                 prespawn        (flagType);

PCMD                     ReadCmd         (void);
void                     RemoveFile      (PFILE);
flagType                 Replace         (char, COL, LINE, PFILE, flagType);
/*
 * Routines "      ed" through a filter in load.c
 */
void                     DelFile         (PFILE, flagType);
void                     DelLine         (flagType, PFILE, LINE ,LINE);
void                     Display         (void);
char                     fChangeFile     (char , char *);
flagType                 fExecute        (char *);
PFILE                    FileNameToHandle (const char *, const char *);
flagType                 FileRead        (char *,PFILE, flagType);
flagType                 FileWrite       (char *,PFILE);
PSWI                     FindSwitch      (char *);
flagType                 GetColor        (LINE, struct lineAttr *, PFILE);
flagType                 GetColorUntabbed(LINE, struct lineAttr *, PFILE);
int                      GetLine         (LINE ,char *,PFILE);
int                      GetLineUntabed  (LINE ,char *,PFILE);
void                     PutColor        (LINE, struct lineAttr *, PFILE);
void                     PutColorPhys    (LINE, struct lineAttr *, PFILE);
void                     PutLine         (LINE, char *, PFILE);
void                     DelColor        (LINE, PFILE);
int                      REsearch        (PFILE, flagType, flagType, flagType, flagType, struct patType *, fl *);
int                      search          (PFILE, flagType, flagType, flagType, flagType, char *, fl *);
flagType                 SetKey          (char *,char *);
char *                   GetTagLine      (LINE *, char *, PFILE);
void                     PutTagLine      (PFILE, char *, LINE, COL);


/*
 *  Switch setting functions
 */
char *            SetBackup              (char *);
char *            SetCursorSizeSw        (char *);
char *            SetExt                 (char *);
char *            SetFileTab             (char *);
char *            SetLoad                (char *);
char *            SetMarkFile    (char *);
flagType          SetPrintCmd    (char *);
flagType          SetROnly               (char *);
flagType          SetTabDisp             (char *);
flagType          SetTrailDisp   (char *);
char *            SetKeyboard    (char *);

/*           definitions.
 */
char *   SetCursorSize  ( int );
void              resetarg       (void);
void              delarg         (ARG *);
flagType          fCursor        (PCMD);
flagType          fWindow        (PCMD);
flagType          Arg            (flagType);
void              IncArg         (void);
flagType          fGenArg        (ARG *, unsigned int);
void              UpdateHighLight(COL, LINE, flagType);
PCMD              NameToFunc     (char *);
flagType          DoAssign       (char *);
flagType          SetNamedKey    (char *,char *);
flagType          SetMacro       (const char *, const char *);
flagType          SetSwitch      (char *,char *);
flagType          DoCDelete      (char);
char              confirm        (char *, char *);
int               askuser        (int, int, char *,char *);
void              FlushInput     (void);
char *            BuildFence     (const char *, const char *, char *);
void                     DoFence        (char *, flagType);
void              cursorfl       (fl);
void              docursor       (COL ,LINE);
int               dobol          (void);
int               doeol          (void);
int               doftab         (int);
int               dobtab         (int);
flagType          DoText         (int ,int);
flagType          SplitWnd       (PWND, flagType, int);
void              DoStatus       (void);
void              redraw         (PFILE, LINE ,LINE);
void              newscreen      (void);
void              newwindow      (void);
void              noise          (LINE);
void     __cdecl           StatusCat      (unsigned int, char *, char *, ...);
void              bell           (void);
void              makedirty      (PFILE);
void              doscreen       (COL ,LINE ,COL ,LINE);
void              delay          (int);
void              SetScreen      (void);
void              HighLight      (COL ,LINE ,COL ,LINE);
void              AdjustLines    (PFILE, LINE ,LINE);
flagType          UpdateIf       (PFILE, LINE, flagType);
PWND              IsVispFile     (PFILE, PWND);
ULONG             MepWrite       (ULONG Row, ULONG Col, PVOID pBuffer, ULONG BufferSize, DWORD attr, BOOL BlankToEndOfLine, BOOL ShowIt);
flagType          fInRange       (long ,long ,long);
int               DisplayLine    (int, char *, struct lineAttr **, char *, struct lineAttr **);
void              ShowTrailDisp  (buffer, int);
char *          GetFileTypeName(void);
void              SetFileType    (PFILE);
flagType          fInitFileMac   (PFILE);
void              AutoSave       (void);
void              AutoSaveFile   (PFILE);
void              IncFileRef     (PFILE);
void              DecFileRef     (PFILE);
char              fChangeDrive   (const char *);
void		  zputsinit	 (void);
int		  zputs 	 (char *, int, FILEHANDLE);
int		  zputsflush	 (FILEHANDLE);
void              ReestimateLength (PFILE,FILEHANDLE,long);
LINE              readlines      (PFILE, FILEHANDLE);
char              fReadOnly      (char *);
void              SaveAllFiles   (void);
char              LoadDirectory  (char *,PFILE);
char              LoadFake       (char *,PFILE);
char              SaveFake       (char *,PFILE);
char              fScan          (fl,flagType (         *)(void),char, flagType);
void              setAllScan     (char);
PCMD              getstring      (char *,char *,PCMD,flagType);
void              ScrollOut      (char *, char *, int, int, flagType);
flagType          edit           (char);
flagType          szEdit         (char *);
void              FreeMacs       (void);
void              CodeToName     (WORD ,char *);
WORD              NameToCode     (char *);
void              FuncOut        (PCMD, PFILE);
char *            FuncToKey      (PCMD, char *);
void              UnassignedOut  (PFILE);
char *            FuncToKeys     (PCMD, char *);
PCMD              ReadCmdAndKey  (char *);
int               tblFind        (char * [],char * ,flagType);
char              parseline      (char *,char * *,char * *);
int               csoftcr        (COL ,LINE ,char *);
int               softcr         (void);
flagType          mtest          (void);
flagType          mlast          (void);
flagType          fFindLabel     (struct macroInstanceType *,buffer);
void              mPopToTop      (void);
PCMD              mGetCmd        (void);
flagType          fParseMacro    (struct macroInstanceType *, char *);
int               fMacResponse   (void);

flagType             GoToMark       (char *);
PFILE                FindMark       (char *, fl *, flagType);
MARK *               FindLocalMark  (char *, flagType);
MARK *               GetMarkFromLoc (LINE, COL);
void                 MarkInsLine    (LINE, LINE, PFILE);
void                 MarkDelLine    (PFILE, LINE, LINE);
void                 MarkDelStream  (PFILE, COL, LINE, COL, LINE);
void                 MarkDelBox     (PFILE, COL, LINE, COL, LINE);
flagType             fReadMarks     (PFILE);
void                 WriteMarks     (PFILE);
void                 UpdMark        (FILEMARKS **, char *, LINE, COL, flagType);
void                 DefineMark     (char *, PFILE, LINE, COL, flagType);
void                 DeleteMark     (char *);
void                 DelPMark       (MARK *);
void                 MarkCopyLine   (PFILE, PFILE, LINE, LINE, LINE);
void                 MarkCopyBox    (PFILE, PFILE, COL, LINE, COL, LINE, COL, LINE);
FILEMARKS *          GetFMFromFile  (PFILE, COL, LINE, COL, LINE);
void                 AddFMToFile    (PFILE, FILEMARKS *, COL, LINE);
void                 FreeCache      (void);
flagType             fCacheMarks    (PFILE);
void                 AdjustMarks    (MARK *, LINE);
flagType             fMarkIsTemp    (char *);
flagType             fFMtoPfile     (PFILE, FILEMARKS *);
PVOID                FMtoVM         (FILEMARKS *);
PVOID                GetMarkRange   (PFILE, LINE, LINE);
void                 PutMarks       (PFILE, PVOID, LINE);
int                  flcmp          (fl *, fl *);

char              fDoBal         (void);
int               InSet          (char ,char *);
void              pick           (COL ,LINE ,COL ,LINE ,int);
void              ReplaceEdit    (char *,char *);
void              simpleRpl      (char *);
void              patRpl         (void);
char              fDoReplace     (void);
flagType          doreplace      (flagType, ARG *, flagType, flagType);
void              AppFile        (char *, PFILE);
void              appmsgs        (int, PFILE);
void              showasg        (PFILE);
flagType          infprint       (PFILE,PFILE);
void              showinf        (PFILE);
void              ShowMake       (PFILE);
int               TabMin         (int ,char *,char *);
int               TabMax         (int ,char *,char *);
int               LineLength     (LINE ,PFILE);
void              InsertLine     (LINE, char *, PFILE);
LINE      __cdecl zprintf        (PFILE, LINE, char const *, ...);
int               gettextline    (char ,LINE ,char *,PFILE, char);
int               getcolorline   (flagType, LINE, struct lineAttr *, PFILE);
void              puttextline    (flagType, flagType, LINE, char *, PFILE);
void              putcolorline   (flagType, LINE, struct lineAttr *, PFILE);
void              BlankLines     (LINE ,PVOID);
void              BlankColor     (LINE, PVOID);
void              growline       (LINE ,PFILE);
void              InsLine        (flagType, LINE ,LINE ,PFILE);
flagType          fInsSpace      (COL ,LINE ,int ,PFILE, linebuf);
flagType          fInsSpaceColor (COL ,LINE ,int ,PFILE, linebuf, struct lineAttr *);
void              delspace       (COL ,LINE ,int ,PFILE, linebuf);
int               fcolcpy        (struct lineAttr * , struct lineAttr * );
void              ShiftColor     (struct lineAttr [], COL, int);
void              SetColor       (PFILE, LINE, COL, COL, int);
void              CopyColor      (PFILE, PFILE, LINE, COL, COL, LINE, COL);
void              SetColorBuf    (struct lineAttr *, COL, int, int);
flagType          fGetColorPos   (struct lineAttr **, COL *);
void              ColorToPhys    (struct lineAttr *, LINE, PFILE);
void              ColorToLog     (struct lineAttr *, char *);

void              SetHiLite      (PFILE, rn, int);
void              ClearHiLite    (PFILE, flagType);
flagType          UpdHiLite      (PFILE, LINE, COL, COL, struct lineAttr **);
void              UpdOneHiLite   (struct lineAttr *, COL, COL, flagType, INT_PTR);
void              rnOrder        (rn *);

void              BoxToStream    (ARG *);
void              StreamToBox    (ARG *);

void              AckReplace     (LINE, flagType);
void              AckMove        (LINE, LINE);
void              DoAssignLine   (LINE);
void              UpdToolsIni    (char *);
LINE              FindMatchLine  (char *, char *, char *, int, LINE *);

void              GetCurPath     (char *);
flagType          SetCurPath     (char *);

flagType          ExpungeFile    (void);
void              FreeFileVM     (PFILE);
PFILE             pFileLRU       (PFILE);


void              saveflip       (void);
void              restflip       (void);
void              movewin        (COL ,LINE);
void              SortWin        (void);
int               WinInsert      (PWND);
char              Adjacent       (int ,int);
char              WinClose       (int);
char              fDoWord        (void);
PCMD              zloop          (flagType);
flagType          zspawnp        (char const *, flagType);
flagType          DoCancel       (void);
char              testmeta       (void);
char *            ZMakeStr       (const char *);
void              TCcursor       (char ,char);

#define sout(x,y,p,clr)         ((int)x + MepWrite(y, x, p, strlen(p), clr, FALSE, fReDraw))
#define soutb(x,y,p,clr)        ((int)x + MepWrite(y, x, p, strlen(p), clr, TRUE, fReDraw))
#define vout(x,y,p,c,clr)       ((int)x + MepWrite(y, x, p, c, clr, FALSE, fReDraw))
#define voutb(x,y,p,c,clr)      ((int)x + MepWrite(y, x, p, c, clr, TRUE, fReDraw))

#define consoleMoveTo(y, x)     consoleSetCursor(MepScreen, y, x)


int               coutb          (int ,int ,char *,int ,struct lineAttr *);
void              ToRaw          (void);
void              ToCooked       (void);
char *            VideoTag       (void);
char *            whiteskip      (char const *);
char *            whitescan      (char const *);
int               RemoveTrailSpace (char *);
char *            DoubleSlashes  (char *);
char *            UnDoubleSlashes(char *);
flagType __cdecl  FmtAssign      (char *, ...);
flagType          SendCmd        (PCMD);
void              RecordCmd      (PCMD);
void              RecordString   (char *);
void              AppendMacroToRecord (PCMD);
flagType          fSyncFile      (PFILE, flagType);
void              RemoveInstances(PFILE);
int               FileStatus     (PFILE, char *);
void              SetModTime     (PFILE);
time_t            ModTime        (char *);
void              LengthCheck    (LINE, int, char *);
void              IntError       (char *);
#if 0
flagType          CheckForDirt   (void);
#else
flagType          fSaveDirtyFiles(void);
#endif
flagType          InitExt        (char *);
LINE              DoInit         (char *, char *, LINE);
char *            IsTag          (char *);
LINE              LocateTag      (PFILE, char *);
char *            GetIniVar      (char *, char *);
int               loadini        (flagType);
int               init           (void);
void              WriteTMPFile   (void);
flagType          ReadTMPFile    ();
void              RemoveTop      (void);
flagType          dosearch       (flagType, ARG *, flagType, flagType);
int               REsearchS      (PFILE, flagType, flagType, flagType, flagType, char *, fl *);
void                     mgrep1file     (char *, struct findType *, void *);
void                     mrepl1file     (char *, struct findType *, void *);
flagType         mgrep1env  (char *, va_list);
flagType          fFileAdvance   (void);
LINE              SetFileList    (void);
void              TopLoop        (void);
void              LeaveZ         (void);
DECLSPEC_NORETURN void              CleanExit      (int, flagType);
flagType          fPushEnviron   (char *, flagType);
flagType          fIsNum         (char *);
void              InitNames      (char *);
void              ParseCmd       (char *, char **, char **);
flagType          fIsBlank       (PFILE, LINE);
flagType          fVideoAdjust   (int, int);


flagType __cdecl  disperr        (int, ...);
flagType __cdecl  dispmsg        (int, ...);
int      __cdecl  domessage      (char *, ...);
int      __cdecl  printerror     (char *,...);
char *            GetMsg         (unsigned, char *);
void              CreateUndoList (PFILE);
void              LinkAtHead     (PVOID, union Rec *,PFILE);
int               FreeUndoRec    (flagType,PFILE);
int               UnDoRec        (PFILE);
void		  LogReplace	 (PFILE, LINE, LINEREC *, struct colorRecType *);
void              LogInsert      (PFILE, LINE, LINE);
void              LogDelete      (PFILE, LINE, LINE);
void              LogBoundary    (void);
int               ReDoRec        (PFILE);
flagType          fIdleUndo      (flagType);
void              FlushUndoBuffer (void);
void              RemoveUndoList (PFILE);
flagType          fundoable      (flagType);
LINE              updateLine     (PFILE, LINE);
LINE              unupdateLine   (PFILE, LINE);

int                      ZFormat        (REGISTER char *, const REGISTER char *, va_list);

/*  Declarations controlled by C runtime
 */
int                      CtrlC          (ULONG);
void __cdecl            main           (int ,char * *);

#if defined (DEBUG)

void *                   DebugMalloc        (int, BOOL, char *, int);
void *                   DebugRealloc       (void *, int, BOOL, char *, int);
void                     DebugFree          (void *, char *, int);
unsigned                 DebugMemSize       (void *, char *, int);

#endif
/*
 *          Debugging assertion support
 */
#ifdef DEBUG
void              _assertexit    (char *, char *, int);
void              _heapdump      (char *);
flagType          _pfilechk      (void);
flagType          _pinschk       (PINS);
void *            _nearCheck     (void *, char *, char *, int);
#endif

void *                   ZeroMalloc     (int);
void *                   ZeroRealloc    (void *, int);
unsigned                 MemSize        (void *);

/*  Assembly declarations
 */
int                      fstrnicmp      (char *, char *, int);
char *               fstrcpy        (char *, char *);
int                      fstrlen        (char *);
int               zfstrcmp       (char *, char *);
int               fstricmp       (char *, char *);
int               iHash          (long, int);

int               Untab         (int, const char*, int, char*, char);
COL               AlignChar     (COL, const char*);

void              KbHookAsm      (void);
flagType          SetKBType      (void);
void              GetScreenSize (int *, int *);
flagType          SetScreenSize (int, int);
void              SetVideoState  (int);
void              SaveScreen     (void);
void              RestoreScreen  (void);
void                                     WindowChange ( ROW     Rows,  COLUMN   Cols);
int               LineOut        (int, int, const char *, int, int);
int               LineOutB       (int, int, const char *, int, int);
void              HWInit         (void);
void              HWReset        (void);
flagType          Idle           (void);
//void            Yield          (void);
//char *                  lsearch        (char *, int, char *, int);

int               DosLoadModuleHack (char *, int, char *, unsigned int *);
void                     IdleThread     ( void );
int               OS2toErrno     (int);
char *            OS2toErrText   (int, char *);

flagType          fMapEnv        (char *pSrc, char *pDst, int cbDst);
flagType          fSetEnv        (char *p);
void              showenv        (PFILE pFile);
/*
 * Extension Load/Auto-Load
 */
#if defined (HELP_HACK )
char *                  HelpLoad(void);
#endif
char *           load       (char *, flagType);
void             AutoLoadExt    (void);
flagType         AutoLoadDir    (char *, va_list);
void                     AutoLoadFile   (char *, struct findType *, void *);

/*
 * Printing
 */

flagType          DoPrint        (PFILE, flagType);
PFILE             GetTmpFile     (void);


void                     CleanPrint     (char *, flagType);



/*
 * Background Threads
 */

BTD*              BTCreate      (char *);
flagType          BTAdd         (BTD *, PFUNCTION, char *);
flagType          BTKill        (BTD *);
flagType          BTKillAll     (void);
flagType          BTWorking     (void);
void              BTIdle        (void);
void                     BThread       (BTD *);


/*
 * List handling module
 */
void              ListWalker     (PCMD, flagType (         *)(PCMD, char *, PMI, int), flagType);
char *            ScanList       (PCMD, flagType);
char *            ScanMyList     (PCMD, PMI, buffer, flagType);
flagType          fParseList     (PMI,char *);
flagType          fScanPush      (PMI);
flagType          fScanPop       (PMI);
PCMD              GetListHandle  (char *, flagType);
void              AddStrToList   (PCMD, char *);
flagType          fInList        (PCMD, char *, flagType);
flagType          fDelStrFromList(PCMD, char *, flagType);
flagType          CheckAndDelStr (PCMD, char *, PMI, int);
char *            GetListEntry   (PCMD, int, flagType);
int               ListLen        (PCMD, flagType);
flagType          fEmptyList     (PCMD);
void              InitParse      (PCMD, PMI);
void              Listize        (char *);
char *            CanonFilename  (char * src, char * dst);
flagType          fEnvar         (char *);
void              ClearList      (PCMD);
/*
 * real tabs
 */
char *                   pLog           (char*, COL, flagType);
int               cbLog          (char *);
COL               colPhys        (char *, char *);
COL               DecCol         (COL, char *);
COL               IncCol         (COL, char *);


FILEHANDLE  MepFOpen    (LPBYTE FileName,  ACCESSMODE  Access, SHAREMODE  Share, BOOL fCreate);
void        MepFClose   (FILEHANDLE Handle );
DWORD       MepFRead    (PVOID  pBuffer, DWORD  Size, FILEHANDLE  Handle);
DWORD       MepFWrite   (PVOID pBuffer,  DWORD Size, FILEHANDLE  Handle);
DWORD       MepFSeek    (FILEHANDLE  Handle, DWORD  Distance,  MOVEMETHOD  MoveMethod);

#pragma intrinsic( memset,      memcpy )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\msg.h ===
#define	MSGERR_INV_ARG	8001
#define	MSGERR_ARG_REQ	8002
#define	MSGERR_NOEDIT	8003
#define	MSGERR_NOREP	8004
#define	MSGERR_NOCREAT	8005
#define	MSGERR_OPEN	8006
#define	MSGERR_RONLY	8007
#define	MSGERR_SPACE	8008
#define	MSGERR_DEL	8009
#define	MSGERR_REN	8010
#define	MSGERR_OLDVER	8011
#define	MSGERR_SAVEDIR	8012
#define	MSGERR_STFILE	8013
#define	MSGERR_UNDO	8014
#define	MSGERR_REDO	8015
#define	MSGERR_ITHREAD	8016
#define	MSGERR_CTHREAD	8017
#define	MSGERR_PTHREAD	8018
#define	MSGERR_TOOLS	8019
#define	MSGERR_ZFORMAT	8020
#define	MSGERR_ZTELL	8021
#define	MSGERR_CMPCMD	8022
#define	MSGERR_CMPCMD2	8023
#define	MSGERR_CMPFULL	8024
#define	MSGERR_CMPCANT	8025
#define	MSGERR_CMPSRC	8026
#define	MSGERR_PRTFULL	8027
#define MSGERR_PRTCANT  8028
#define MSGERR_NOMEM    8029
#define MSGERR_QUIT     8030
#define	MSG_ASSIGN_HDR	9001
#define	MSG_SWITCH_HDR	9025
#define	MSG_KEYS_HDR1	9050
#define	MSG_KEYS_HDR2	9054
#define	MSG_ASG_FUNC	9061
#define	MSG_ASG_MACROS	9062
#define	MSG_ASG_NUMER	9063
#define	MSG_ASG_BOOL	9064
#define	MSG_ASG_TEXT	9065
#define	MSG_ASG_CLIP	9066
#define	MSG_ASG_LINES	9067
#define	MSG_ASG_PAGES	9068
#define	MSG_PRESS_ANY	10000
#define	MSG_ARGCOUNT	10001
#define	MSG_NEXTFILE	10002
#define	MSG_SAVING	10003
#define	MSG_TELLPROMPT	10004
#define	MSG_SAVEALL	10005
#define	MSG_SAVEONE	10006
#define	MSG_QUEUED	10007
#define	MSG_CMPDONE	10008
#define	MSG_PRINTING	10009
#define	MSG_SCANFILE	10010
#define	MSG_ASN_MISS	10100
#define	MSG_ASN_MISSK	10101
#define	MSG_ASN_UNKKEY	10102
#define	MSG_ASN_INUSE	10103
#define	MSG_ASN_MROOM	10104
#define	MSG_ASN_NOTSWI	10105
#define	MSG_ASN_ILLSET	10106
#define	MSG_ASN_WINCHG	10107
#define	MSG_ASN_UNSUP	10108
#define	MSG_ASN_INVAL	10109
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\inc\version.h ===
#define rmj		2
#define rmm		0
#define rup		0
#define szVerName	"( Windows NT )"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\assign.c ===
/****  assign.c - keyboard reassignment and switch setting
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*        26-Nov-1991 mz        Strip out near/far
*
*
*************************************************************************/
#include "mep.h"


#define DEBFLAG CMD

/****************************************************************************
 *                                                                          *
 *  Assignment types.  Used by UpdToolsIni                                  *
 *                                                                          *
 ****************************************************************************/

#define ASG_MACRO   0
#define ASG_KEY     1
#define ASG_SWITCH  2


/*** NameToFunc - map a user-specified function name into internal structure
 *
 *  Given a name of a function, find it in the system table or in the set
 *  of defined macros.        Return the pointer to the command structure
 *
 *  Since, with user-defined extensions as well as macros, there is the
 *  possibility of name collision (effectively masking one function) we allow
 *  disambiguation by specifying an extension name ala .DEF file format:
 *
 *        func       - look up func in macro table and then in extensions
 *                     in order of installation
 *        exten.func - look up func in exten only.
 *
 *  pName    = char pointer to potential name
 *
 *  Returns pointer to command structure if found, NULL otherwise
 *
 *************************************************************************/
PCMD
FindNameInCmd (
    char    *pName,
    PCMD    pCmd
    ) {
    while (pCmd->name) {
        if (!_stricmp (pName, pCmd->name)) {
            return pCmd;
        }
        pCmd++;
    }
    return NULL;
}


PCMD
NameToFunc (
    char    *pName
    ) {

    /*        see if an extension override is present
     */
    {
        char *pExt = pName;
        PCMD pCmd;
        int i;

        pName = strbscan (pExt, ".");
        if (*pName != '\0') {
            *pName++ = '\0';
            for (i = 0; i < cCmdTab; i++) {
                if (!_stricmp (pExt, pExtName[i])) {
                    pCmd = FindNameInCmd (pName, cmdSet[i]);
                    pName[-1] = '.';
                    return pCmd;
                }
            }
            return NULL;
        }
        pName = pExt;
    }

    {
        REGISTER int k;

        for (k = 0; k < cMac; k++) {
            if (!_stricmp (pName, rgMac[k]->name)) {
                return rgMac[k];
            }
        }
    }


    {
        int i;
        REGISTER PCMD pCmd;

        /* look up function name in table */
        for (i = 0; i < cCmdTab; i++) {
            if ((pCmd = FindNameInCmd (pName, cmdSet[i])) != NULL) {
                return pCmd;
            }
        }
        return NULL;
    }
}



/*** DoAssign - make assignment
*
* Purpose:
*  Executes the keystroke and macro assignment strings passed to it by either
*  the assign command processor, or the tools.ini file processor.
*
* Input:
*  asg  = Pointer to asciiz assignment string.  The line is assumed
*         to be clean (see GetTagLine).
*
* Output:
*  TRUE is assignment made
*
*************************************************************************/
flagType
DoAssign (
    char    *asg
    ) {

    REGISTER char *p;
    flagType fRet;

    asg = whiteskip (asg);
    RemoveTrailSpace (asg);

    if (*(p = strbscan(asg,":")) == 0) {
        return disperr (MSG_ASN_MISS, asg);
    }

    *p++ = 0;
    _strlwr (asg);
    RemoveTrailSpace (asg);
    p = whiteskip (p);

    if (*p == '=') {
        fRet = SetMacro (asg, p = whiteskip (p+1));
    } else {
        fNewassign = TRUE;
        if (NameToFunc (asg) == NULL) {
            fRet = SetSwitch (asg, p);
        } else {
            fRet = SetKey (asg, p);
            if (!fRet) {
                if (*p == '\0') {
                    disperr (MSG_ASN_MISSK, asg);
                } else {
                    disperr (MSG_ASN_UNKKEY, p);
                }
            }
        }
    }
    return fRet;
}


/*** SetMacro - define a keystroke macro
*
* Input:
*  name         = lowercase macro name
*  p            = sequence of editor functions and/or quoted text
*
* Output:
*
*************************************************************************/
flagType
SetMacro (
    char const *name,
    char const *p
    ) {

    REGISTER PCMD pFunc;
    int i, j;

    /* MACRO-NAME:=functions */
    /* see if macro already defined */
    for (i = 0; i < cMac; i++) {
        if (!strcmp (rgMac[i]->name, name)) {
            for (j = 0; j < cMacUse; j++) {
                if ((char *) mi[j].beg == rgMac[j]->name) {
                    return disperr (MSG_ASN_INUSE, name);
                }
            }
            break;
        }
    }

    if (i != cMac) {
        /*
         * redefining a macro: realloc exiting text
         */
        rgMac[i]->arg = (CMDDATA)ZEROREALLOC ((char *) rgMac[i]->arg, strlen(p)+1);
        strcpy ((char *) rgMac[i]->arg, p);
        return TRUE;
    }

    if (cMac >= MAXMAC) {
        return disperr (MSG_ASN_MROOM, name);
    }

    pFunc = (PCMD) ZEROMALLOC (sizeof (*pFunc));
    pFunc->arg = (UINT_PTR) ZMakeStr (p);
    pFunc->name = ZMakeStr (name);
    pFunc->func = macro;
    pFunc->argType = KEEPMETA;
    rgMac[cMac++] = pFunc;


    return TRUE;
}


/*** assign - assign editting function
*
*  Handle key, switch and macro assignments
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
assign (
    CMDDATA argData,
    REGISTER ARG *pArg,
    flagType fMeta
    ) {

    fl      flNew;
    linebuf abuf;
    char * pBuf = NULL;

    switch (pArg->argType) {

    case NOARG:
        GetLine (pArg->arg.noarg.y, abuf, pFileHead);
        return DoAssign (abuf);

    case TEXTARG:
        strcpy ((char *) abuf, pArg->arg.textarg.pText);
        if (!strcmp(abuf, "?")) {
            AutoSave ();
            return fChangeFile (FALSE, rgchAssign);
            }
        return DoAssign (abuf);

    /*  NULLARG is transformed into text to EOL */
    case LINEARG:
        flNew.lin = pArg->arg.linearg.yStart;
        while (    flNew.lin <= pArg->arg.linearg.yEnd &&
                (pBuf = GetTagLine (&flNew.lin, pBuf, pFileHead))) {
            if (!DoAssign (pBuf)) {
                flNew.col = 0;
                cursorfl (flNew);
                if (pBuf) {
                    FREE (pBuf);
                }
                return FALSE;
            }
        }
        if (pBuf) {
            FREE (pBuf);
        }
        return TRUE;

    /*  STREAMARG is illegal    */
    case BOXARG:
        for (flNew.lin = pArg->arg.boxarg.yTop; flNew.lin <= pArg->arg.boxarg.yBottom; flNew.lin++) {
            fInsSpace (pArg->arg.boxarg.xRight, flNew.lin, 0, pFileHead, abuf);
            abuf[pArg->arg.boxarg.xRight+1] = 0;
            if (!DoAssign (&abuf[pArg->arg.boxarg.xLeft])) {
                flNew.col = pArg->arg.boxarg.xLeft;
                cursorfl (flNew);
                return FALSE;
            }
        }
        return TRUE;
    }

    return FALSE;

    argData; fMeta;
}


/*** FindSwitch - lookup switch
*
*  Locate switch descriptor, given it's name
*
* Input:
*  p = pointer to text switch name
*
* Output:
*  Returns PSWI, or NULL if not found.
*
*************************************************************************/
PSWI
FindSwitch (
    char *p
    ) {

    REGISTER PSWI pSwi;
    int i;

    for (i = 0; i < cCmdTab; i++) {
        for (pSwi = swiSet[i]; pSwi != NULL && pSwi->name != NULL; pSwi++) {
            if (!strcmp (p, pSwi->name)) {
                return pSwi;
            }
        }
    }
    return NULL;
}


/*** SetSwitch - Set a switch to a particular value
*
*  Given a switch name, and a value to set it to, perform the assignment
*
* Input:
*  p             = pointer to switch name (possibly prefexed by "no" if a
*                  boolean
*  val           = new value to set switch to
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
SetSwitch (
    char    *p,
    char    *val
    ) {

    PSWI    pSwi;
    int     i;
    flagType f;
    char    *pszError;
    fl      flNew;                          /* new location of cursor       */

    f = TRUE;

    /*  figure out if no is a prefix or not
     */

    if ((pSwi = FindSwitch (p)) == NULL) {
        if (!_strnicmp ("no", p, 2)) {
            p += 2;
            f = FALSE;
            if ((pSwi = FindSwitch (p)) != NULL && pSwi->type != SWI_BOOLEAN) {
                pSwi = NULL;
            }
        }
    }

    if (pSwi == NULL) {
        return disperr (MSG_ASN_NOTSWI, p);
    }

    switch (pSwi->type & 0xFF) {
    case SWI_BOOLEAN:
        if (*val == 0) {
            *pSwi->act.fval = f;
            return TRUE;
        } else if (!f) {
            printerror ("Boolean switch style conflict");
            return FALSE;
        } else if (!_stricmp (val, "no")) {
            *pSwi->act.fval = FALSE;
            return TRUE;
        } else if (!_stricmp (val, "yes")) {
            *pSwi->act.fval = TRUE;
            return TRUE;
        }
        break;

    case SWI_NUMERIC:
        if (!f) {
            if (*val == 0) {
                val = "0";
            } else {
                break;
            }
        }
        if (*val != 0) {
            *pSwi->act.ival = ntoi (val, pSwi->type >> 8);
            return TRUE;
        }
        break;

    case SWI_SCREEN:
        /* change screen parameters */
        i = atoi (val);
        if (i == 0) {
            return disperr (MSG_ASN_ILLSET);
        }
        if ((cWin > 1) &&
            (((pSwi->act.ival == (int *)&XSIZE) && (i != XSIZE)) ||
             ((pSwi->act.ival == (int *)&YSIZE) && (i != YSIZE)))) {
            disperr (MSG_ASN_WINCHG);
            delay (1);
            return FALSE;
        }
        if ((pSwi->act.ival == (int *)&XSIZE && !fVideoAdjust (i, YSIZE)) ||
            (pSwi->act.ival == (int *)&YSIZE && !fVideoAdjust (XSIZE, i))) {
            return disperr (MSG_ASN_UNSUP);
        }
        SetScreen ();
        if (pInsCur && (YCUR(pInsCur) - YWIN(pInsCur) > YSIZE)) {
            flNew.col = XCUR(pInsCur);
            flNew.lin = YWIN(pInsCur) + YSIZE - 1;
            cursorfl (flNew);
        }
        domessage (NULL);
        return TRUE;

    case SWI_SPECIAL:
        /* perform some special initialization */
        if ( ! (*pSwi->act.pFunc) (val) ) {
            return disperr (MSG_ASN_INVAL, pSwi->name, val);
        }
        return TRUE;

    case SWI_SPECIAL2:
        /* perform special initialization with possible error return string */
        if (pszError = (*pSwi->act.pFunc2) (val)) {
            printerror (pszError);
            return FALSE;
        }
        return TRUE;

    default:
        break;
    }

    return FALSE;
}


/*** AckReplace - Acknowledge changes to <assign> file.
*
* Purpose:
*
*   To be called whenever a line in the current file changes. Allows
*   special handling for some files.
*
* Input:
*   line  - Number of the line that changed
*   fUndo - TRUE if this replacement is an <undo> operation.
*
* Output: None
*
* Notes:
*
*   Currently, this means making changes to <assign> take effect immediately.
*   If the user has changed the current line without leaving it, we flag
*   the change so it will take place after they leave.        If the user is
*   elsewhere, the change takes place now.
*
*************************************************************************/

static flagType fChanged = FALSE;

void
AckReplace (
    LINE line,
    flagType fUndo
    ) {


    if (pInsCur->pFile == pFileAssign) {
        if (YCUR(pInsCur) == line || fUndo) {
            fChanged = (flagType)!fUndo;
        } else {
            DoAssignLine (line);
        }
    }
}



/*** AckMove - Possibly parse line in <assign> file.
*
* Purpose:
*
*   To be called whenever the cursor moves to a new line in the current
*   file.  This allows special line processing to take place after a
*   line has been changed.
*
* Input:
*   lineOld -        Number of line we're moving from.
*   lineNew -        Number of line we're moving to.
*
* Output: None.
*
* Notes:
*
*        Currently, this makes the <assign> file work.  If the line we are
*   moving from has changed, we make the assignment.  We rely on AckReplace
*   to set fChanged ONLY when the affected file is <assign>.
*
*************************************************************************/

void
AckMove (
    LINE lineOld,
    LINE lineNew
    ) {
    if (pInsCur->pFile== pFileAssign && fChanged && lineOld != lineNew ) {
        fChanged = FALSE;
        DoAssignLine (lineOld);
    }
}



/*** DoAssignLine - Take line from current file and <assign> with it
*
* Purpose:
*
*   Used by the Ack* functions to perform an <assign> when the time is
*   right.
*
* Input:
*   line -  Line in the file to read.
*
* Output: None
*
*************************************************************************/

#define CINDEX(clr)        ((&clr-&ColorTab[0])+isaUserMin)

void
DoAssignLine (
    LINE line
    ) {
    fl      flNew;
    char    *pch;
    struct lineAttr rgColor[2];

    flNew.lin = line;
    if ((pch = GetTagLine (&flNew.lin, NULL, pInsCur->pFile)) &&
        flNew.lin == line+1) {
        if (!DoAssign(pch)) {
            flNew.col = XCUR(pInsCur);
            flNew.lin--;
            cursorfl (flNew);
            DelColor (line, pInsCur->pFile);
        } else {
            /*
             * Hilite the changed line so we can find it again
             */
            rgColor[0].attr = rgColor[1].attr = (unsigned char)CINDEX(hgColor);
            rgColor[0].len  = (unsigned char)slSize.col;
            rgColor[1].len  = 0xFF;
            PutColor (line, rgColor, pInsCur->pFile);
        }
    }
}



/*** UpdToolsIni - Update one entry in the tools.ini file
*
* Purpose:
*
*   Used for automatic updates, such as when the <assign> file is saved.
*
*   The posible values for asgType are:
*
*        ASG_MACRO   - This is a macro assignment.
*        ASG_KEY     - This assigns a function to a key.
*        ASG_SWITCH  - THis assigns a value to a switch.
*
* Input:
*   pszValue   - Complete string to enter, as in "foo:value".
*   asgType    - Type of assignment.
*
* Output: None
*
* Notes:
*
*   If necessary, the string will be broken across several lines using
*   the continuation character.
*
*   UNDONE: This "effort" has not been made"
*   Every effort is made to preserve the user's tools.ini format.  To this
*   end:
*
*        o When an entry already exists for the given switch or function,
*          the new value is written over the old value, with the first
*          non-space character of each coinciding.
*
*        o If an entry does not exist, a new entry is made at the end
*          of the section, and is indented to match the previous entry.
*
*   We find an existing string by searching through the tagged sections
*   in the same order in which they are read, then pick the last instance
*   of the string.  In other words, the assignment we replace will be
*   the one that was actually used.  This order is assumed to be:
*
*                    [NAME]
*                    [NAME-os version]
*                    [NAME-video type]
*                    [NAME-file extension]
*                    [NAME-..] (if no file extension section)
*
*   If we are not replacing an existing string, we add the new string at
*   the end of the [MEP] section.
*
*   The string pszAssign is altered.
*
*************************************************************************/

void
UpdToolsIni (
    char * pszAssign
    ) {

    char * pchLeft;
    char * pchRight;
    int asgType;
    LINE lReplace, lAdd = 0L, l;
    linebuf lbuf;
    flagType fTagFound = TRUE;

    if (pFileIni == NULL || pFileIni == (PFILE)-1) {
        /*
        ** We assume here that pFileIni has no
        ** value because there is no TOOLS.INI file
        */
        if (CanonFilename ("$INIT:tools.ini", lbuf)) {
            pFileIni = AddFile (lbuf);
            assert (pFileIni);
            pFileIni->refCount++;
            SETFLAG (FLAGS(pFileIni), DOSFILE);
            FileRead (lbuf, pFileIni, FALSE);
        } else {
            return;
        }
    }

    /* First, figure out what is what */
    pchLeft = whiteskip (pszAssign);
    pchRight = strchr (pchLeft, ':');
    *pchRight++ = '\0';
    if (*pchRight == '=') {
        asgType = ASG_MACRO;
        pchRight++;
    } else {
        asgType = NameToFunc (pchLeft) ? ASG_KEY : ASG_SWITCH;
    }
    pchRight = whiteskip (pchRight);


    // First, let's search through the [NAME] section.  If
    // we are replacing, we search for the line to replace.
    // If we are not, we are simply trying to find the end.
    //
    lReplace = 0L;

    if (0L < (l = FindMatchLine (NULL, pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)!l;
    }

    //sprintf (lbuf, "%d.%d", _osmajor, _osminor);
    //if (_osmajor >= 10 && !_osmode) {
    //    strcat (lbuf, "R");
    //}
    if (0L < (l = FindMatchLine (lbuf, pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)(fTagFound || (flagType)!l);
    }

    if (0L < (l = FindMatchLine (VideoTag(), pchLeft, pchRight, asgType, &lAdd))) {
        lReplace = l;
    } else {
        fTagFound = (flagType)(fTagFound || (flagType)!l);
    }

    // UNDONE: This should try to read the extension section
    // currently "active".  What it does is read the extension
    // section appropriate to the current file.  If these are
    // not the same, it fails.
    //
    if (extention (pInsCur->pFile->pName, lbuf)) {
        if (0L < (l = FindMatchLine (lbuf, pchLeft, pchRight, asgType, &lAdd))) {
            lReplace = l;
        } else if (l == -1L) {
            if (0L < (l = FindMatchLine ("..", pchLeft, pchRight, asgType, &lAdd))) {
                lReplace = l;
            } else {
                fTagFound = (flagType)(fTagFound || (flagType)!l);
            }
        }
    }


    // If we are not supposed to replace a line,
    // or if we are but we can't find a suitable
    // line, we simply insert the new line
    //
    strcpy (lbuf, pchLeft);
    if (asgType == ASG_MACRO) {
        strcat (lbuf, ":= ");
    } else {
        strcat (lbuf, ": ");
    }
    strcat (lbuf, pchRight);

    if (!fTagFound) {
        lAdd = 1L;
        InsLine (FALSE, 0L, 1L, pFileIni);
        sprintf (buf, "[%s]", pNameEditor);
        PutTagLine (pFileIni, buf, 0L, 0);
    }

    if (lReplace == 0L) {
        assert (lAdd <= pFileIni->cLines);
        InsLine (FALSE, lAdd, 1L, pFileIni);
    } else {
        lAdd = lReplace;
    }

    PutLine (lAdd, lbuf, pFileIni);
}


/*** FindMatchLine - Find a line to replace in TOOLS.INI
*
* Purpose:
*
*   Called from UpdToolsIni to find the right place to update
*
* Input:
*   pszTag  -        Which tagged section to look in
*   pszLeft -        Left side of the assignment
*   pszRight-        Right side of the assignment
*   asgType -        Type of assignment (one of ASG_*)
*   plAdd   -        Returns line number of place to insert a new line
*
* Output:
*
*   Returns line number in pFileIni of matchine line, 0L if there is
*   no match and -1L if the specified tag does not exist.
*
*************************************************************************/

LINE
FindMatchLine (
    char * pszTag,
    char * pszLeft,
    char * pszRight,
    int    asgType,
    LINE * plAdd
    ) {

    char pszTagBuf[80];
    char * pchRight, * pchLeft;
    LINE lCur, lNext, lReplace = 0L;
    flagType fUser = FALSE;
    flagType fExtmake = FALSE;
    int cchExt;

    strcpy (pszTagBuf, pNameEditor);
    if (pszTag) {
        strcat (pszTagBuf, "-");
        strcat (pszTagBuf, pszTag);
    }

    if ((LINE)0 == (lNext = LocateTag (pFileIni, pszTagBuf))) {
        return -1L;
    }

    if (!_stricmp (pszLeft, "user")) {
        fUser = TRUE;
    } else if (!_stricmp (pszLeft, "extmake")) {
        pchRight = whitescan (pszRight);
        cchExt = (int)(pchRight - pszRight);
        fExtmake = TRUE;
    }

    // Get each line in the current section, checking the right
    // or left side for a match with the passed-in string.
    //
    pchLeft = NULL;
    while (lCur = lNext, pchLeft = GetTagLine (&lNext, pchLeft, pFileIni)) {
        pchRight = strbscan (pchLeft, ":");
        *pchRight = '\0';
        if (pchRight[1] == '=') {
            if (asgType != ASG_MACRO) {
                continue;
            }
            pchRight++;
        } else if (asgType == ASG_MACRO) {
                continue;
        }
        pchRight = whiteskip (pchRight);

        switch (asgType) {
            case ASG_KEY:
                if (!_stricmp (pszRight, pchRight)) {
                    lReplace = lCur;
                }
                break;

            case ASG_SWITCH:
                if (!_stricmp (pszLeft, pchLeft)) {
                    lReplace = lCur;
                }
                break;

            case ASG_MACRO:
                if (fUser) {
                    continue;
                }

                if (!_stricmp (pszLeft, pchLeft)) {
                    if (!(fExtmake && _strnicmp (pszRight, pchRight, cchExt))) {
                        lReplace = lCur;
                    }
                }
                break;

            default:
                assert (FALSE);
        }
    }

    if (!pszTag) {
        *plAdd = lCur;
    }
    return lReplace;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\arg.c ===
/*** arg.c - argument handler
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip out near/far
*
*************************************************************************/
#include "mep.h"


typedef flagType (*FUNCSAVED)(CMDDATA, ARG *, flagType);

PVOID   vaHiLiteSave    = (PVOID)(-1L);
fl      flLastArg;
fl      flLastCursor;

//
// Globals set by SendCmd and used by repeat to repeat the last command
//
flagType    fOKSaved = FALSE;
FUNCSAVED   funcSaved;
CMDDATA     argDataSaved;
ARG         argSaved;
flagType    fMetaSaved;



/*** doarg - perform arg processing
*
*  doarg is the editor function that is used to indicate the beginning of
*  an argument to an editor function.
*
* Input:
*  Standard Editting Function (Everything ignored).
*
* Output:
*  Returns the value returned by editor function that terminates arg. If
*  invalid arg was found, then the return is FALSE.
*
*************************************************************************/
flagType
doarg (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    return Arg (FALSE);
    argData; pArg; fMeta;
}



/*** resetarg - throw away all arg input and restore cursor position.
*
*  Several functions (cancel, invalid args) discard the current arg context.
*  We parse the current arg input and then reset the cursor to the original
*  position.
*
* Input:
*  nothing
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
resetarg (void)
{
    UpdateHighLight (-1, -1L, FALSE);
    pInsCur->pFile->vaHiLite = vaHiLiteSave;
    vaHiLiteSave = (PVOID)(-1L);
    if (argcount)
        pInsCur->flCursorCur = flArg;
    argcount = 0;
}



/*** fCursor - decide if an editor function is a cursor movement function
*
*  When reading in an argument, editor functions that move the cursor are
*  allowed as long as no text has been input.  fCursor defines that set
*  of allowed functions.
*
* Input:
*  pCmd 	= pointer to the internal editor function
*
* Output:
*  Returns TRUE if pCmd is a cursor movement function
*
*************************************************************************/
flagType
fCursor (
    PCMD pCmd
    ) {
    return (flagType) TESTFLAG (pCmd->argType, CURSORFUNC);
}



/*** fWindow - decide if an editor function is a window movement function
*
*  After highlighting text, we are allowed to move the window about via
*  window movement functions without removing the highlight.  fWindow
*  defines that set of window functions.
*
* Input:
*  pf		= pointer to the internal editor function
*
* Output:
*  Returns TRUE if pf is a window movement function
*
*************************************************************************/
flagType fWindow (
    PCMD pCmd
    ) {
    return (flagType) TESTFLAG (pCmd->argType, WINDOWFUNC);
}



/*** Arg - perform all low-level arg processing
*
*  Arg () is responsible for the display of the arg, handling all cursor
*  movement, handling textarg input.
*
* Input:
*  fToText	= TRUE => go immediately to text arg processing, else allow
*		  allow cursor movement
*  fRestore	= TRUE => Establish a test selection before continuing
* Output:
*  Returns value returned by editor function that terminates arg. If invalid
*  arg was found, then the return is FALSE.
*
*************************************************************************/
flagType
Arg (
    flagType fRestore
    ) {
    REGISTER PCMD pFunc = NULL;
    char     p[20];
    char     tbuf[20];

    /*
     * We are being called for a lastselect.  Restore the
     * text selection stored in pInsCur and continue
     */
    if (fRestore) {
	vaHiLiteSave = pInsCur->pFile->vaHiLite;
	ClearHiLite (pInsCur->pFile, FALSE);
	flArg = pInsCur->flArg;
	cursorfl (pInsCur->flCursor);
	UpdateHighLight (XCUR(pInsCur), YCUR(pInsCur), TRUE);
	argcount++;
    } else {
	IncArg ();
    }

    if (!mtest()) {
        dispmsg (MSG_ARGCOUNT,argcount);
    }

    /*
     * Loop to do do cursor movements and display any extra arg indicators
     */

    fInSelection = TRUE;

    while (TRUE) {
        if ((pFunc = zloop (ZL_BRK)) == NULL) {
	    return FALSE;
        } else if ((PVOID)pFunc->func == (PVOID)doarg) {
	    argcount++;
            if (!mtest()) {
                dispmsg (MSG_ARGCOUNT,argcount);
            }
        } else if (fCursor (pFunc) || (PVOID)pFunc->func == (PVOID)meta) {
	    fRetVal = SendCmd (pFunc);
	    UpdateHighLight ( XCUR(pInsCur), YCUR(pInsCur), TRUE);
        } else {
            break;
        }
    }

    fInSelection = FALSE;

    /*
     * Get text arg, if needed.
     * Note that we only accept textarg if no cursor movement occured
     */
    if (   (((PVOID)pFunc->func == (PVOID)graphic) ||
            ((PVOID)pFunc->func == (PVOID)quote))
	&& (pInsCur->flCursorCur.lin == flArg.lin)
	&& (pInsCur->flCursorCur.col == flArg.col)
       ) {
	fTextarg = TRUE;
	sprintf(p,GetMsg(MSG_ARGCOUNT, tbuf), argcount);
	strcat (p, ": ");
	textbuf[0] = '\0';
	pFunc = getstring (textbuf, p, pFunc, FALSE);
    }

    /*
     * If textarg ended in valid function, execute it.
     */
    if (pFunc != NULL) {
	if (!fTextarg) {
	    pInsCur->flArg = flArg;
	    pInsCur->flCursor = pInsCur->flCursorCur;
        }
	return (SendCmd (pFunc));
    }

    return FALSE;
}



/*** IncArg - Increment the arg count
*
* If first arg, save current highlight info on th file, and clear any
* highlighting on screen. Set flArg to be the arg start position, and
* highlight that position.
*
* Input:
*   Nothing
*
* Output:
*   Nothing
*
*************************************************************************/
void IncArg (
) {
    if (!argcount++) {
	vaHiLiteSave = pInsCur->pFile->vaHiLite;
	ClearHiLite (pInsCur->pFile, FALSE);
	flArg = pInsCur->flCursorCur;
	UpdateHighLight (XCUR(pInsCur)+1, YCUR(pInsCur), TRUE);
    }
}



/**** fGenArg - generate the argument based upon editor state
*
*  fGenArg is called to convert the combination of arg, cursor, and
*  additional text into an argument structure to be handed to the editor
*  functions.
*
* Input:
*  pArg 	= pointer to arg structure that will be filled in
*  flags	= bit vector indicating type of arg processing required
*
* Globals:
*  argcount	= number of times ARG has been hit
*  fBoxArg	= Determines argument type (non-CW)
*  SelMode	= Determines argument type (CW)
*  flArg	= File location of arg cursor (may be updated)
*  fTextarg	= TRUE => textarg is present
*  pInsCur	= used for current user cursor location
*  textbuf	= buffer containing any text argument
*
* Output:
*  Returns TRUE if a valid argument was parsed off, FALSE otherwise
*
*************************************************************************/
flagType
fGenArg (
    REGISTER ARG *pArg,
    unsigned int flags
    ) {
    int cArg = argcount;
    long numVal  = 0;			/* value of numarg		*/
    flagType fTextArgLocal = fTextarg;

    fTextarg = FALSE;
    argcount = 0;
    if (cArg == 0) {
	if (TESTFLAG (flags, NOARG)) {
	    pArg->argType = NOARG;
	    pArg->arg.noarg.y = YCUR(pInsCur);
	    pArg->arg.noarg.x = XCUR(pInsCur);
	    return TRUE;
        } else {
            return FALSE;
        }
    } else {
	fl  flLow;
	fl  flHigh;
	fl  flCur;

	flCur = pInsCur->flCursorCur;

	cursorfl (flArg);
	/*  Specially handle text arguments.  User may specify a
	 *  number or a mark that will define the other endpoint
	 *  of an arg region.
	 */
	if (fTextArgLocal) {
	    if (TESTFLAG (flags, NUMARG) && fIsNum (textbuf)) {

		numVal = atol (textbuf);
		if (numVal != 0)
		    flArg.lin = lmax ((LINE)0, flArg.lin + numVal + (numVal > 0 ? -1 : 1));
		fTextArgLocal = FALSE;
            } else if (TESTFLAG (flags,MARKARG) && FindMark (textbuf, &flArg, FALSE)) {
                fTextArgLocal = FALSE;
            }
        }

	flLow.col  = min  (flArg.col, flCur.col);
	flHigh.col = max  (flArg.col, flCur.col);
	flLow.lin  = lmin (flArg.lin, flCur.lin);
	flHigh.lin = lmax (flArg.lin, flCur.lin);

	/*  flArg represents the location of one part of an argument
	 *  and the current cursor position represent the location of the
	 *  other end.	Based upon the flags, we ascertain what type of
	 *  argument is intended.
	 */
	if (fTextArgLocal) {
	    if (TESTFLAG (flags, TEXTARG)) {
		pArg->argType = TEXTARG;
		pArg->arg.textarg.cArg = cArg;
		pArg->arg.textarg.y = flCur.lin;
		pArg->arg.textarg.x = flCur.col;
		pArg->arg.textarg.pText = (char *) textbuf;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (flCur.col == flArg.col && flCur.lin == flArg.lin && numVal == 0) {
	    if (TESTFLAG (flags, NULLARG)) {
		pArg->argType = NULLARG;
		pArg->arg.nullarg.cArg = cArg;
		pArg->arg.nullarg.y = flCur.lin;
		pArg->arg.nullarg.x = flCur.col;
		return TRUE;
            } else if (TESTFLAG (flags, NULLEOL | NULLEOW)) {
		fInsSpace (flArg.col, flArg.lin, 0, pFileHead, textbuf);
                if (TESTFLAG (flags, NULLEOW)) {
                    *whitescan (pLog(textbuf, flArg.col, TRUE)) = 0;
                }
		strcpy (&textbuf[0], pLog (textbuf, flArg.col, TRUE));
		pArg->argType = TEXTARG;
		pArg->arg.textarg.cArg = cArg;
		pArg->arg.textarg.y = flCur.lin;
		pArg->arg.textarg.x = flCur.col;
		pArg->arg.textarg.pText = (char *) textbuf;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (TESTFLAG (flags, BOXSTR) && flCur.lin == flArg.lin) {
	    fInsSpace (flHigh.col, flArg.lin, 0, pFileHead, textbuf);
	    *pLog (textbuf, flHigh.col, TRUE) = 0;
	    strcpy (&textbuf[0], pLog (textbuf, flLow.col, TRUE));
	    pArg->argType = TEXTARG;
	    pArg->arg.textarg.cArg = cArg;
	    pArg->arg.textarg.y = flArg.lin;
	    pArg->arg.textarg.x = flArg.col;
	    pArg->arg.textarg.pText = (char *) textbuf;
	    return TRUE;
        } else if (fBoxArg) {
	    if (TESTFLAG (flags, LINEARG) && flArg.col == flCur.col) {
		pArg->argType = LINEARG;
		pArg->arg.linearg.cArg = cArg;
		pArg->arg.linearg.yStart = flLow.lin;
		pArg->arg.linearg.yEnd	 = flHigh.lin;
		return TRUE;
            } else if (TESTFLAG (flags, BOXARG) && flArg.col != flCur.col) {
		pArg->argType = BOXARG;
		pArg->arg.boxarg.cArg = cArg;
		pArg->arg.boxarg.yTop = flLow.lin;
		pArg->arg.boxarg.yBottom = flHigh.lin;
		pArg->arg.boxarg.xLeft = flLow.col;
		pArg->arg.boxarg.xRight = flHigh.col-1;
		return TRUE;
            } else {
                return FALSE;
            }
        } else if (TESTFLAG (flags, STREAMARG)) {
            pArg->argType = STREAMARG;
            pArg->arg.streamarg.cArg = cArg;
            if (flCur.lin > flLow.lin) {
                pArg->arg.streamarg.yStart = flArg.lin;
                pArg->arg.streamarg.xStart = flArg.col;
                pArg->arg.streamarg.yEnd = flCur.lin;
                pArg->arg.streamarg.xEnd = flCur.col;
            } else if (flArg.lin == flCur.lin) {
                pArg->arg.streamarg.yStart = pArg->arg.streamarg.yEnd = flArg.lin;
                pArg->arg.streamarg.xStart = flLow.col;
                pArg->arg.streamarg.xEnd = flHigh.col;
            } else {
                pArg->arg.streamarg.yStart = flCur.lin;
                pArg->arg.streamarg.xStart = flCur.col;
                pArg->arg.streamarg.yEnd = flArg.lin;
                pArg->arg.streamarg.xEnd = flArg.col;
            }
            return TRUE;
        } else {
            return FALSE;
        }
    }
}



/*** BadArg - inform the user that an invalid arg was input
*
*  Clear arg & print standard error message.
*
* Input:
*  none
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
BadArg ()
{
    resetarg ();
    return disperr (MSGERR_INV_ARG);
}



/*** SendCmd - take a CMD and call it with the appropriate argument parsing
*
*  If the function to be executed is not a window movement command nor a
*  cursor movement command, we remove any highlighting that is present. For
*  cleanliness, we pass a NOARG to cursor and window functions if none is
*  specified. If the function takes args, we decode them. Any errors report
*  back at this point. Finally, we dispatch to the function, sending him the
*  appropriate argument.
*
* Input:
*  pCmd 	    = pointer to command to execute.
*
* Output:
*  Returns value returned by command
*
*************************************************************************/
flagType
SendCmd (
PCMD pCmd
) {
    ARG arg;
    flagType fMeta = (flagType) (TESTFLAG (pCmd->argType, KEEPMETA) ? FALSE : testmeta ());
    flagType fArg  = (flagType) argcount;

    arg.argType = NOARG;
    arg.arg.noarg.x = XCUR(pInsCur);
    arg.arg.noarg.y = YCUR(pInsCur);

    if (TESTFLAG(pCmd->argType, GETARG)) {
	if (!fGenArg (&arg, pCmd->argType)) {
            if (fArg) {
		BadArg ();
            } else {
                disperr (MSGERR_ARG_REQ);
            }
	    return FALSE;
        }
        if (!fCursor (pCmd) && ! fWindow (pCmd)) {

            //  Not a coursor position.
            //  discard any pre-existing highlighting.

            PVOID        vaSave;

	    vaSave = pInsCur->pFile->vaHiLite;
	    pInsCur->pFile->vaHiLite = vaHiLiteSave;
            vaHiLiteSave = (PVOID)(-1L);
	    ClearHiLite (pInsCur->pFile, TRUE);

	    pInsCur->pFile->vaHiLite = vaSave;
        } else if (vaHiLiteSave == (PVOID)(-1L)) {

            // Preserve pre-existing hilighting

	    vaHiLiteSave = pInsCur->pFile->vaHiLite;
	    ClearHiLite (pInsCur->pFile, FALSE);
        }
	resetarg ();
    }

    if (   TESTFLAG (pCmd->argType, MODIFIES)
        && (TESTFLAG (pFileHead->flags, READONLY) || fGlobalRO)) {
        return disperr (MSGERR_NOEDIT);
    }

    if (!fMetaRecord || (PVOID)pCmd->func == (PVOID)record) {
        if (((PVOID)pCmd->func != (PVOID)repeat) && !mtest()) {
            if (argSaved.argType == TEXTARG) {
                FREE (argSaved.arg.textarg.pText);
            }
            funcSaved    = (FUNCSAVED)pCmd->func;
	    argDataSaved = pCmd->arg;
	    argSaved	 = arg;
	    fMetaSaved	 = fMeta;
            if (arg.argType == TEXTARG) {
		argSaved.arg.textarg.pText = ZMakeStr (arg.arg.textarg.pText);
            }
	    fOKSaved = TRUE;
        }
	return (*pCmd->func) (pCmd->arg, (ARG *)&arg, fMeta);
    }

    return FALSE;
}



/*** repeat - repeat the last command
*
*  repeat is the editor function that is used to repeat the last executed function
*
* Input:
*  Standard Editting Function. (Everything ignored)
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType
repeat (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    return fOKSaved
	    ? (*funcSaved) (argDataSaved, (ARG *) &argSaved, fMetaSaved)
            : disperr (MSGERR_NOREP);

    argData; pArg; fMeta;
}


/*** lasttext - perform arg processing on the dialog line
*
*  TextArg is the editor function that is used to allow reediting of a text
*  arg on the dialog line.
*
*  If used with a selection, the first line of the selection is presented
*  for editing.
*
* Input:
*  Standard Editting Function.
*
* Output:
*  Returns .....
*
* Globals:
*  textbuf	= buffer containing any the argument
*
*************************************************************************/
flagType
lasttext (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    REGISTER PCMD pFunc = NULL;
    int 	  cArg	= 0;
    char	  p[20];
    char	  tbuf[20];

    switch (pArg->argType) {
	case NULLARG:
	    cArg = pArg->arg.nullarg.cArg;

	case NOARG:
	    cArg ++;
	    break;

	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, textbuf);
	    *pLog (textbuf, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    strcpy (textbuf, pLog (textbuf, pArg->arg.boxarg.xLeft, TRUE));
	    cArg = pArg->arg.boxarg.cArg;
	    break;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, textbuf, pFileHead);
	    cArg = pArg->arg.linearg.cArg;
	    break;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, textbuf);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (textbuf, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    strcpy (textbuf, pLog (textbuf, pArg->arg.streamarg.xStart, TRUE));
	    cArg = pArg->arg.streamarg.cArg;
	    break;

	default:
	    break;
    }

    while (cArg--) {
        IncArg();
    }

    sprintf(p,GetMsg(MSG_ARGCOUNT, tbuf), argcount);
    strcat (p, ": ");
    if (pFunc = getstring (textbuf, p, NULL, GS_INITIAL)) {
	fTextarg = TRUE;
	return (SendCmd (pFunc));
    } else {
        return FALSE;
    }

    argData; fMeta;
}


/*** promptarg - Prompt the use for a textarg on the dialog line
*
*  If used with a selection, the first line of the selection is used
*  as prompt string.
*
* Input:
*  Standard Editting Function.
*
* Output:
*  Returns .....
*
* Globals:
*  textbuf	= buffer containing any the argument
*
*************************************************************************/
flagType
promptarg (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    REGISTER PCMD pFunc = NULL;
    linebuf	  lbPrompt;
    int 	  cArg = 0;

    switch (pArg->argType) {
	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, lbPrompt);
	    *pLog (lbPrompt, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    strcpy (lbPrompt, pLog (lbPrompt, pArg->arg.boxarg.xLeft, TRUE));
	    cArg = pArg->arg.boxarg.cArg;
	    break;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, lbPrompt, pFileHead);
	    cArg = pArg->arg.linearg.cArg;
	    break;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, lbPrompt);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (lbPrompt, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    strcpy (lbPrompt, pLog (lbPrompt, pArg->arg.streamarg.xStart, TRUE));
	    cArg = pArg->arg.streamarg.cArg;
	    break;

        case TEXTARG:
	    strcpy ((char *) lbPrompt, pArg->arg.textarg.pText);
	    cArg = pArg->arg.textarg.cArg;
	    break;

	default:
	    break;
    }

    while (cArg--) {
        IncArg();
    }

    textbuf[0] = '\0';

    pFunc = getstring (textbuf, lbPrompt, NULL, GS_NEWLINE | GS_KEYBOARD);
    if (pFunc && ((PVOID)pFunc->func != (PVOID)cancel)) {
	fTextarg = TRUE;
	return TRUE;
    } else {
        return FALSE;
    }

    argData; fMeta;
}



/*** UpdateHighLight - Highlight screen during <arg> text selection.
*
*  Maintains screen highlighting information.
*
* Input:
*  x, y 	= position of cursor. (y == -1L causes highlighting to be
*		  removed)
*  fBoxToLine	= TRUE => Turn boxarg into a linearg if arg and cursor
*		  columns are the same
*
* Global:
*  flArg	= Position in file when <arg> was hit.
*
* Output:
*
*************************************************************************/
void
UpdateHighLight (
    COL      x,
    LINE     y,
    flagType fBoxToLine
    ) {

    static fl flCursor          = {-1, -1L};
    rn      rnHiLite;

    /*
     * if remove request, clear it out
     */
    if (y == -1L) {
        ClearHiLite (pInsCur->pFile,TRUE);
        flCursor.lin = -1L;
    } else if (fBoxArg) {
        /*
         * Transition points where we remove highlighting before updating new
         * highlighting:
         *
         *  currently columns are equal, and new highlight would not be.
         *  currently columns are not equal, and new highlight would be.
         *  New cursor position differs in BOTH x and y positions from old.
         *  new position equals the arg position
         */
        if (   ((flCursor.col == flArg.col) && (x != flCursor.col))
                || ((flCursor.col != flArg.col) && (x == flArg.col))
                || ((flCursor.col != x) && (flCursor.lin != y))
                || ((flArg.col == x) && (flArg.lin == y))
            ) {
            ClearHiLite (pInsCur->pFile,TRUE);
        }
        flCursor.lin = y;
        flCursor.col = x;
        /*
         * define New Highlight square
         */
        rnHiLite.flFirst = flArg;
        rnHiLite.flLast  = flCursor;
        /*
         * Ending column is off-by-one. If unequal, adjust accordingly.
         */
        if (rnHiLite.flFirst.col < rnHiLite.flLast.col) {
            rnHiLite.flLast.col--;
        } else if (   (rnHiLite.flFirst.col == rnHiLite.flLast.col)
             && (rnHiLite.flFirst.lin != rnHiLite.flLast.lin)) {
            /*
             * If columns are same, and lines are different, then highlight entire lines.
             */

            rnHiLite.flFirst.col = 0;
            rnHiLite.flLast.col  = sizeof(linebuf);
	}
        SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
    } else {  /* !fBoxArg */

        /*
         *  If we're on the arg line, we can just clear the highlighting
         *  and redraw.
         */
	if (y == flArg.lin) {
	    ClearHiLite (pInsCur->pFile, TRUE);

	    rnHiLite.flFirst = flArg;
	    rnHiLite.flLast.col = x;
	    rnHiLite.flLast.lin = y;

            if (x > flArg.col) {
                rnHiLite.flLast.col--;
            }

	    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
        } else {
            /*
             *  We're not on the arg line.  If we have changed lines, we have
             *  to eliminate the range that specifies the line we're on.
             *  Currently, this means we have to clear the entire hiliting and
             *  regenerate.
             *  If we have not changed lines, only the current line will be updated
             */

	    if (flCursor.lin != y) {
		ClearHiLite (pInsCur->pFile, TRUE);

                /*
                 *  First, generate the arg line
                 */
		rnHiLite.flFirst    = flArg;
		rnHiLite.flLast.lin = flArg.lin;

                if (y < flArg.lin) {
		    rnHiLite.flLast.col = 0;
                } else {
                    rnHiLite.flLast.col = sizeof(linebuf);
                }

		SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);

                /*
                 *  Now generate the block between the arg and the current
                 *  lines.
                 */
		rnHiLite.flFirst.col = 0;
		rnHiLite.flLast.col  = sizeof(linebuf);

		if (y < flArg.lin) {
		    rnHiLite.flFirst.lin = y + 1;
		    rnHiLite.flLast.lin  = flArg.lin - 1;
                } else {
		    rnHiLite.flFirst.lin = flArg.lin + 1;
		    rnHiLite.flLast.lin  = y - 1;
                }

                if (rnHiLite.flLast.lin - rnHiLite.flFirst.lin >= 0) {
                    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
                }
	    }

            /*
             *  Now do the current line
             */
	    rnHiLite.flFirst.lin = y;
	    rnHiLite.flLast.lin  = y;
	    rnHiLite.flLast.col  = x;

            if (y < flArg.lin) {
		rnHiLite.flFirst.col = sizeof(linebuf);
            } else {
		rnHiLite.flFirst.col = 0;
		rnHiLite.flLast.col--;
            }

	    SetHiLite (pInsCur->pFile, rnHiLite, SELCOLOR);
	}
	flCursor.col = x;
	flCursor.lin = y;
    }

    fBoxToLine;
}


/*** BoxStream - Editor command - toggles box/stream modes
*
*  Toggles the user between box and stream selection modes.
*
* Input:
*  Standard Editting function. (Though everything is ignored)
*
* Output:
*   Returns TRUE if we are now in box mode, FALSE for stream.
*
*************************************************************************/
flagType
BoxStream (
    CMDDATA   argData,
    ARG * pArg,
    flagType  fMeta
    ) {

    fBoxArg = (flagType) !fBoxArg;
    if (argcount) {
        UpdateHighLight (-1, -1L, TRUE);
        UpdateHighLight (XCUR(pInsCur), YCUR(pInsCur), TRUE);
    }
    return fBoxArg;

    argData; pArg; fMeta;
}


/*** lastselect - Restore last text selection
*
* Purpose:
*
*   To quickly restore the user text selection after a function has been
*   executed.  This function does not exit until the user completes their
*   selection.
*
* Input:
*
*   The usual editor command arguments.  None is used.
*
* Output:
*
*   Returns FALSE if we are already in text selection mode, TRUE otherwise.
*
* Notes:
*
*   The items we must save and restore are:
*
*		flArg	 - Spot where user hit <arg>
*		flCursor - Spot where cursor was last
*
*   Note that the boxstream state and the argcount are not preserved.
*
*   We rely on Arg () to set up for us.
*
*************************************************************************/

flagType
lastselect (
    CMDDATA   argData,
    ARG * pArg,
    flagType  fMeta
    ) {
    if (argcount) {
        return FALSE;
    }

    Arg (TRUE);

    return TRUE;

    argData; pArg;  fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\cdelete.c ===
/*** cdelete.c - delete the previous character in a line
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"

/*** cdelete - character delete function
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
cdelete (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    return DoCDelete (FALSE);

    argData; pArg; fMeta;
}


/*** emacsdel - emacs character delete function
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
emacscdel (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    return DoCDelete (TRUE);

    argData; pArg; fMeta;

}


/*** DoCDelete - perform character deletion
*
*  Delete the character at the current cursor location
*
* Input:
*  fEmacs	- EMACs type delete flag
*
* Output:
*  Returns TRUE on deletion
*
*************************************************************************/
flagType
DoCDelete (
    flagType fEmacs
    ) {

    fl      fl;                             /* file loc to position at      */
    int     x;
    char    *p;
    linebuf tempbuf;
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;

    fl.col = XCUR(pInsCur);
    fl.lin = YCUR(pInsCur);
    /*
     * xCursor is zero. If yCursor is also zero (top of file), we can't move
     * back, so nothing to delete. Otherwise, move to end of previous line, and
     * if emacs & insert mode, join the lines.
     */
    if (fl.col == 0) {
        if (fl.lin == 0) {
            return FALSE;
        } else {
            fl.lin--;
            fl.col = LineLength (fl.lin, pFileHead);
            if (fInsert && fEmacs) {
                DelStream (pFileHead, fl.col, fl.lin, 0, fl.lin + 1);
            }
        }
    } else {
        /*
         * column is non-zero, so back it up one.
         */
        GetLine (fl.lin, tempbuf, pFileHead);
        x = cbLog (tempbuf);
        fl.col = DecCol (fl.col, tempbuf);
        /*
         * we're in the middle of a line. If in insert mode, back up the cursor, and
         * delete the character there.
         */
        if (fInsert) {
            DelBox (pFileHead, fl.col, fl.lin, fl.col, fl.lin);
        } else {
            /*
             * we're in the middle of a line, but not insert mode. Get the text of the
             * line & pointer to character.
             */
            p = pLog (tempbuf, fl.col, TRUE);
            /*
             * If emacs, and we're actually IN text, then replace the character with a
             * space.
             */
            if (fEmacs) {
                if (fl.col+1 <= x && *p != ' ') {
                    *p = ' ';
                    // SetColor (pFileHead, fl.lin, fl.col, 1, fgColor);
                    PutLine (fl.lin, tempbuf, pFileHead);
                }
            }
            /*
             * if we're beyond the end of the line, just position to the end of the line.
             */
            else if (fl.col+1 > x) {
                fl.col = x;
            }
            /*
             * if the first non-blank character is PAST the current position, then just
             * position at the begining of the line.
             */
            else if ((colPhys (tempbuf, whiteskip (tempbuf)) > fl.col)) {
                fl.col = 0;
            }
            /*
             * finaly, when all else fails, back up, and replace the character under the
             * cursor with a space.
             */
            else if (*p != ' ') {
                *pLog (tempbuf,fl.col,TRUE) = ' ';
                if (fColor = GetColor (fl.lin, rgla, pFileHead)) {
                    ShiftColor (rgla, fl.col, -1);
                    ColorToLog (rgla, buf);
                }
                PutLine (fl.lin, tempbuf, pFileHead);
                if (fColor) {
                    PutColor (fl.lin, rgla, pFileHead);
                }
            }
        }
    }
    cursorfl (fl);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\build.c ===
/*** build.c - utilities for build process
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip out near/far
*
*
*************************************************************************/
#include "mep.h"


/***
*
* Structures & Types
*
*************************************************************************/
/*
 * BUILDCMD - Build command linked list element
 */
struct BuildCmdType {
    struct BuildCmdType *pNext; 	/* next in list 		*/
    int     flags;			/* command type 		*/
    char    *pRule;			/* pointer to rule/filename	*/
    char    *pCmd;			/* pointer to command text	*/
    };

typedef struct BuildCmdType BUILDCMD;

/***
*
* Module data
*
*************************************************************************/
static	BUILDCMD    *pBuildCmdHead	= NULL; /* head of linked list	*/
static	BUILDCMD    *pBuildCmdCur	= NULL; /* most recent lookup	*/

/*** fSetMake - Define Build Command
*
*  Defines the filename extensions (.C, .BAS, etc) to which a given tool
*  command line applies OR the tool class which a command line defines.
*
* Input:
*  SetType =	MAKE_SUFFIX	= define suffix rule
*		MAKE_FILE	= define command for specfic file
*		MAKE_TOOL	= define tool command line
*		MAKE_DEBUG	= definition is for DEBUG, else RELEASE
*
*  fpszCmd =	Formatted  command  string.  Uses current extmake formatting
*		rules. (%s, etc.)
*
*  fpszExt =	If MAKE_EXT	= suffixes (i.e. ".c.obj")
*		If MAKE_FILE	= filename (must include ".")
*		If MAKE_TOOL	= tool name (no "." allowed)
*
* Output:
*  Returns TRUE on success. FALSE on any error.
*
*************************************************************************/
flagType
fSetMake (
    int      SetType,
    char *fpszCmd,
    char *fpszExt
    ) {
    buffer  buf;

    assert (fpszCmd && fpszExt && SetType);
    while (*fpszCmd == ' ') {
        fpszCmd++;
    }
    if (fGetMake (SetType, (char *)buf, fpszExt)) {
        /*
         * If it already existed, then just free teh previous definitions, in
         * preparation for replacement.
         */
        assert (pBuildCmdCur->pCmd);
        assert (pBuildCmdCur->pRule);
        pBuildCmdCur->pCmd  = ZEROREALLOC (pBuildCmdCur->pCmd, strlen(fpszCmd)+1);
        pBuildCmdCur->pRule = ZEROREALLOC (pBuildCmdCur->pRule,strlen(fpszExt)+1);
	strcpy ((char *)pBuildCmdCur->pCmd, fpszCmd);
	strcpy ((char *)pBuildCmdCur->pRule,fpszExt);
    } else {
        /*
         * It didn't already exist, so create a new struct at the head of the list,
         * to be filled in below.
         */
        pBuildCmdCur = (BUILDCMD *)ZEROMALLOC (sizeof(BUILDCMD));
        pBuildCmdCur->pNext = pBuildCmdHead;
	pBuildCmdCur->pCmd  = ZMakeStr (fpszCmd);
	pBuildCmdCur->pRule = ZMakeStr (fpszExt);
        pBuildCmdHead = pBuildCmdCur;
    }
    pBuildCmdCur->flags = SetType;
    return TRUE;
}



/*** fGetMake - Return Build Command
*
*  Returns the	command line which applies to a file or filename extension.
*
* Input:
*  GetType =	    MAKE_SUFFIX     = return suffix rule
*		    MAKE_FILE	    = return command for specfic file
*		    MAKE_TOOL	    = return tool command line
*		    MAKE_DEBUG	    = definition is for DEBUG, else RELEASE
*
*  fpszCmdDst =     Location  to place the formatted command string. Must be
*		    BUFLEN bytes long.
*
*  fpszExt =	    If MAKE_EXT     = suffixes	(i.e.  ".c.obj") for desired
*				      command.
*		    If MAKE_FILE    = filename for desired command
*		    If MAKE_TOOL    = name of tool
*
* Output:
*  Returns 0 on any error, else returns the GetType.
*
*************************************************************************/
int
fGetMake (
    int     GetType,
    char *fpszCmdDst,
    char *fpszExt
    ) {
    assert (fpszCmdDst && fpszExt && GetType);
    /*
     * Here we just walk the linked list looking for an entry whose flags match,
     * and, if a file or suffix rule, whose rule matches.
     */
    for (pBuildCmdCur = pBuildCmdHead;
         pBuildCmdCur;
         pBuildCmdCur = pBuildCmdCur->pNext) {

        if (pBuildCmdCur->flags == GetType) {
	    if (!_stricmp((char *)pBuildCmdCur->pRule,fpszExt)) {
		strcpy (fpszCmdDst,(char *)pBuildCmdCur->pCmd);
                return pBuildCmdCur->flags;
            }
        }
    }
    return 0;
}


/*** hWalkMake - return make commands one at a time.
*
*  Allow an external anyone to walk the command list.
*
* Input
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
unsigned
short
hWalkMake (
    unsigned short handle,
    int     *Type,
    char    *pszRuleDest,
    char    *pszCmdDest
    ) {

    if (handle) {
        pBuildCmdCur = ((BUILDCMD *)handle)->pNext;
    } else {
        pBuildCmdCur = pBuildCmdHead;
    }

    if (pBuildCmdCur) {
        *Type = pBuildCmdCur->flags;
        strcpy (pszRuleDest, pBuildCmdCur->pRule);
        strcpy (pszCmdDest,  pBuildCmdCur->pCmd);
    }
    return (unsigned short) pBuildCmdCur;
}


/*** fShowMake - Show current build commands
*
*  Append a textual representation of the current build commands to the
*  passed pFile
*
* Input:
*  pFile	= File handle to be added to
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
ShowMake (
    PFILE   pFile
    ) {
    buffer  buf;

    assert (pFile);
    /*
     * Here we just walk the linked list and append lines with the info
     */
    for (pBuildCmdCur = pBuildCmdHead;
         pBuildCmdCur;
         pBuildCmdCur = pBuildCmdCur->pNext) {

        if (TESTFLAG (pBuildCmdCur->flags, MAKE_FILE)) {
            sprintf (buf, "    extmake:[%s]", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_SUFFIX)) {
            sprintf (buf, "    extmake:%s", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_TOOL)) {
            sprintf (buf, "    extmake:*%s", pBuildCmdCur->pRule);
        } else if (TESTFLAG (pBuildCmdCur->flags, MAKE_BLDMACRO)) {
            sprintf (buf, "    extmake:$%s", pBuildCmdCur->pRule);
        } else {
            assert (FALSE);
        }
        sprintf (strend(buf), "%s %s"
                    , TESTFLAG (pBuildCmdCur->flags, MAKE_DEBUG) ? ",D" : RGCHEMPTY
                    , pBuildCmdCur->pCmd
                );
        AppFile (buf, pFile);
    }
}


/*** SetExt - assign a particular compile action to a particular action.
*
*  This is called during any initialization to cause a string to be
*  associated with a particular compile action.
*
* Input:
*  val		= char pointer to a string of the form:
*		    .ext string 	    = define .ext.obj rule
*		    .ext.ext string	    = define .ext.ext rule
*		    filename.ext string     = define rule for filename.ext
*		    command string	    = define rule for command
*
*		  During build any %s's in the string are replaced with the
*		  name of the file being compiled.
*
* Output:
*  Returns TRUE, or FALSE if any errors are found.
*
*************************************************************************/
char *
SetExt (
    char *val
    ) {

    buffer  extbuf;                         /* buffer to work on extension  */
    REGISTER int maketype   = 0;            /* type of build command        */
    char    *pCompile;                      /* pointer to command portion   */
    char    *pExt;                          /* pointer to extension portion */
    REGISTER char *pT;                      /* temp pointer                 */
    buffer  tmpval;                         /* (near) buffer to work on     */

    assert (val);
    strcpy ((char *) tmpval, val);
    /*
     * seperate the extension part from the command part. If there is no command,
     * that's an error.
     */
    ParseCmd (tmpval, &pExt, &pCompile);
    if (*pCompile == '\0') {
        return "extmake: Command missing";
    }
    /*
     * CONSIDER: this syntax is somewhat ugly, and unclean to parse
     *
     * Copy the extension part to a local buffer, so we can work on it. Set make
     * type based on the following rules:
     *
     *      Starts with dot:            --> suffix rule.
     *      Starts with "*"             --> tool rule.
     *      Starts with "$"             --> build macro
     *      Starts with "["             --> filename rule.
     *      "text"                      --> Special old-style "tool rule" for TEXT
     *      text <= 3 characters        --> old style suffix rule
     *
     *      In all cases: contains ",d" --> DEBUG rule.
     */
    _strlwr (pExt);
    strcpy (extbuf, pExt);

    if (pT = strstr (extbuf,",d")) {
        maketype = MAKE_DEBUG;
        *pT = 0;
    }

    if (extbuf[0] == '.') {
        maketype |= MAKE_SUFFIX;
    } else if (extbuf[0] == '[') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_FILE;
        if (pT = strchr (extbuf,']')) {
            *pT = 0;
        }
    } else if (extbuf[0] == '*') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_TOOL;
    } else if (extbuf[0] == '$') {
        strcpy (extbuf, extbuf+1);
        maketype |= MAKE_BLDMACRO;
    } else if (!_stricmp (extbuf, "text")) {
        maketype |= MAKE_TOOL;
    } else if (strlen(extbuf) <= 3) {
        ((unsigned short *)extbuf)[0] = (unsigned short)'.';
        strcat (extbuf,pExt);
        strcat (extbuf,".obj");
        maketype |= MAKE_SUFFIX;
    } else  {
        return "extmake: Bad syntax in extension";
    }

    if (fSetMake (maketype, (char *)pCompile, (char *)extbuf)) {
        return NULL;
    } else {
        return "extmake: Error in command line";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\cursor.c ===
/*** cursor.c -  cursor movement functions
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"
#include "keys.h"

void
GetTextCursor (
    COL  *px,
    LINE *py
    ) {
    *px = XCUR(pInsCur);
    *py = YCUR(pInsCur);
}


/*** docursor/cursorfl - Move cursor to new location, adjust windows as needed
*
* Purpose:
*
*   This moves the cursor to a new file position in the current file.
*   If this position is not visible, the current window is readjusted.
*   The rules for vertical adjustment are:
*
*	If the new location is within 'vscroll' lines of the current
*	window, scroll by vscroll lines in the appropriate direction.
*
*	If the new location is further away, adjust the window so that
*	the new location is 'hike' lines from the top.
*
*   The rules for horizontal adjustment is:
*
*	If the new location is within 'hscroll' lines of the current
*	window, scroll by hscroll lines in the appropriate direction
*
*	If the new location is further away, adjust the window so that
*	the new location is 'hscroll' lines from the edge that's in
*	the direction we moved.
*
*   cursorfl is the same as docursor, but takes an fl instead.
*
*   if realtabs is on, cursor is snapped to right hand column of underlying
*   tab characters.
*
* Input:
*  x		- new file column   (docursor only)
*  y		- new file line     (docursor only)
*  fl		- new file position (cursorfl only)
*
* Globals:
*  pWinCur	- Window and
*  pInsCur	-	     file to operate in.
*
* Output:
*   Returns nothing
*
*************************************************************************/
void
docursor (
    COL  x,
    LINE y
    ) {

    fl  fl;

    fl.col = x;
    fl.lin = y;
    cursorfl(fl);
}


void
cursorfl (
    fl  flParam
    ) {
    fl	flNew;			/* New cursor position, window relative */
    fl	flWin;			/* Window position after adjustments	*/
    sl	slScroll;		/* h & vscroll, scaled to window size	*/
    linebuf	buf;

    flParam.col = max( 0, flParam.col );
	flParam.lin = lmax( (LINE)0, flParam.lin );

	/*
     * if real tabs are on, snap to right of any tab we might be over
     */
    if (fRealTabs && fTabAlign) {
        GetLine (flParam.lin, buf, pFileHead);
        if (flParam.col < cbLog(buf)) {
            flParam.col = AlignChar (flParam.col, buf);
        }
    }

    slScroll.col = XSCALE (hscroll);
    slScroll.lin = YSCALE (vscroll);

    flWin = pInsCur->flWindow;

    /* Check for horizontal window adjustments                      */

    flNew.col = flParam.col - flWin.col;
    if (flNew.col < 0) {            /* We went off the left edge    */
        flWin.col -= slScroll.col;
        if (flNew.col < -slScroll.col) { /* One hscroll wont do it    */
            flWin.col += flNew.col + 1;
        }
    } else if (flNew.col >= WINXSIZE(pWinCur)) {   /* off the right edge   */
        flWin.col += slScroll.col;
        if (flNew.col >= WINXSIZE(pWinCur) + slScroll.col) {  /* ...more than hscroll */
            flWin.col += flNew.col - WINXSIZE(pWinCur);
        }
    }

    /* Check for vertical window adjustments                        */

	flNew.lin = flParam.lin - flWin.lin;					/* Too far off, use hike		*/

	if (flNew.lin < -slScroll.lin || flNew.lin >= WINYSIZE(pWinCur) + slScroll.lin) {

        flWin.lin = flParam.lin - YSCALE(hike);
    } else if (flNew.lin < 0) {                      /* Off the top                  */
        flWin.lin -= slScroll.lin;
    } else if (flNew.lin >= WINYSIZE(pWinCur)) {     /* Off the bottom               */
        flWin.lin += slScroll.lin;
    }

    flWin.col = max (0, flWin.col);         /* Can't move window beyond 0   */
    flWin.lin = lmax ((LINE)0, flWin.lin);

    doscreen (flWin.col, flWin.lin, flParam.col, flParam.lin);
}

/*** doscreen - update screen window and cursor locations
*
* Purpose:
*  Performs reasonable bounds checking on the input parameters, and sets the
*  window position and cursor location to values which are legal
*  approximiations for out of range values.
*
* Input:
*  wx,wy	= Proposed new window position (top left corner of screen)
*  cx,cy	= Proposed new cursor position
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
doscreen(
    REGISTER COL  wx,
    REGISTER LINE wy,
    COL  cx,
    LINE cy
    ) {

    COL dx;
    LINE dy, yOld;
    LINE First, Last;

    /*
     * limit window x position to somewhere near our max line length
     * limit window y position to last line of the file (only if we know the
     * length)
     */
    wx =  max( 0, min( wx, (COL)sizeof(linebuf)-(WINXSIZE(pWinCur) - XSCALE (hscroll))));
    wy = lmax( (LINE)0, TESTFLAG (pFileHead->flags, REAL) ? lmin( wy, pFileHead->cLines - 1 ) : wy );

    /*
     * dx,dy is window movement delta, if a change, save it.
     */
    dx = wx - XWIN(pInsCur);
    dy = wy - YWIN(pInsCur);

    if ( dx || dy ) {
        saveflip ();


        if ( dy > 0 ) {

            First = YWIN(pInsCur) + WINYSIZE(pWinCur);
            Last  = YWIN(pInsCur) + WINYSIZE(pWinCur) + dy;

        } else {

            First = YWIN(pInsCur) + dy;
            Last  = YWIN(pInsCur);
        }
    }

    XCUR(pInsCur) =  min (max( wx, min( cx, wx+WINXSIZE(pWinCur)-1 ) ), sizeof(linebuf)-2);
    yOld = YCUR(pInsCur);
    YCUR(pInsCur) = lmax( wy, lmin( cy, wy+WINYSIZE(pWinCur)-1 ) );
    AckMove (yOld, YCUR(pInsCur));
    XWIN(pInsCur) = wx;
    YWIN(pInsCur) = wy;

    if ( dx || dy ) {
        SETFLAG (fDisplay, RSTATUS);

	//  If we're not in a macro and it makes sense to scroll quickly
	//  do it

	if ( !mtest () && dy  && !fInSelection &&
            (Last < pFileHead->cLines-1) && (abs(dy) < WINYSIZE(pWinCur)) ) {


	    consoleSetAttribute( MepScreen, fgColor );
	    consoleScrollVert( MepScreen, WINYPOS(pWinCur), WINXPOS(pWinCur),
			       WINYPOS(pWinCur)+WINYSIZE(pWinCur)-1,
			       WINXPOS(pWinCur)+WINXSIZE(pWinCur)-1, dy  );

	    //	We've scrolled the window.  However, the update state in
	    //	fChange[] is out of date.  We need to scroll it in parallel
	    //	However, since the fChange array is for the SCREEN and not
	    //	for the window, we can't simply SCROLL it.  Perhaps, one day,
	    //	we can make it per-window but for now, we just force
	    //	a synchronous update which can be ugly in a macro.

            redraw( pFileHead, First, Last);
	    DoDisplay ();

        } else {
            newwindow ();
        }
    }
    SETFLAG (fDisplay, RCURSOR);
}


/*** dobol - returns column position of first non-blank character
*
* Input:
*  none
*
* Global:
*  pInsCur	- Current instance
*  pFileHead	- Current file
*
* Output:
*  Returns column of first non-blank character
*
*************************************************************************/
int
dobol (
    void
    ) {

    REGISTER char *p = buf;

    GetLine (YCUR(pInsCur), p, pFileHead);
    return colPhys (p, (whiteskip (p)));
}

int
doeol (
    void
    ) {
    return LineLength (YCUR(pInsCur), pFileHead);
}


/*** doftab - tab function
*
*  Moves the cursor ahead one tab stop. If realtabs and tab align are on,
*  moves to first tab stop off of the current character.
*
* Input:
*  col	    = current column
*
* Output:
*  Returns new column
*
*************************************************************************/
int
doftab (
    int     col
    ) {
    REGISTER int newcol;

    if (tabstops) {
        newcol = col + tabstops - (col%tabstops);

        if (fRealTabs && fTabAlign) {
            linebuf buf;

            GetLine (YCUR(pInsCur), buf, pFileHead);
            while (col >= AlignChar(newcol,buf))
            newcol += tabstops;
	}
        return newcol;
    } else {
        return col;
    }
}


int
dobtab (
    REGISTER int col
    ) {
    return col - (tabstops ? (1 + (col-1)%tabstops) : 0);
}


flagType
left (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    int x = XCUR(pInsCur);

    docursor(fMeta ? XWIN(pInsCur) :  XCUR(pInsCur)-1, YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
right (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    linebuf  buf;

    if (fMeta) {
	docursor (XWIN(pInsCur)+WINXSIZE(pWinCur)-1, YCUR(pInsCur));
    } else if (fRealTabs && fTabAlign) {
	GetLine (YCUR(pInsCur), buf, pFileHead);
	docursor(colPhys(buf, pLog(buf,XCUR(pInsCur),FALSE)+1), YCUR(pInsCur));
    } else {
        docursor (XCUR(pInsCur)+1, YCUR(pInsCur));
    }
    return (flagType)(XCUR(pInsCur) < LineLength (YCUR(pInsCur), pFileHead));

    argData; pArg;
}



flagType
up (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {


    LINE	    y = YCUR(pInsCur);
    LINE	    LinesUp = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more up keys and add them up.
    //	Do this only if NOT in a macro
    //

    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x110)
		LinesUp++;
	    else
	    if (KeyInfo.KeyCode == 0x111 && LinesUp > 0)
		LinesUp--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }

    while ( LinesUp-- )
	docursor (XCUR(pInsCur), fMeta ? YWIN(pInsCur) : YCUR(pInsCur)-1 );

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg;
}



flagType
down (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    LinesDown = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more up keys and add them up.
    //	Do this only if NOT in a macro
    //
    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x111)
		LinesDown++;
	    else
	    if (KeyInfo.KeyCode == 0x110 && LinesDown > 0)
		LinesDown--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }

    while ( LinesDown--)
	docursor (XCUR(pInsCur), fMeta ? YWIN(pInsCur)+WINYSIZE(pWinCur)-1 : YCUR(pInsCur)+1);

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg;
}



flagType
begline (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (fMeta ? 0 : dobol(), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
endline (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (fMeta ? WINXSIZE(pWinCur) : doeol(), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg;
}



flagType
home (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;

    if (fMeta) {
	docursor (XWIN(pInsCur)+WINXSIZE(pWinCur)-1,
		  YWIN(pInsCur)+WINYSIZE(pWinCur)-1 );
    } else {
        cursorfl (pInsCur->flWindow);
    }
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));
    argData; pArg;  fMeta;
}



flagType
tab (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor( doftab( XCUR(pInsCur)), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg; fMeta;
}



flagType
backtab (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    int x = XCUR(pInsCur);

    docursor (dobtab (XCUR(pInsCur)), YCUR(pInsCur));
    return (flagType)(x != XCUR(pInsCur));

    argData; pArg; fMeta;
}



flagType
fIsBlank (
    PFILE pFile,
    LINE line
    ) {
    linebuf buf;

    return (flagType)(gettextline (TRUE, line, buf, pFile, ' ') == 0
		      || (*whiteskip (buf) == 0));
}



/*  ppara - move cursor forward by paragraphs
 *
 *  <ppara> moves forward to the beginning of the next paragraph.  This
 *  is defined as moving to line i where line i-1 is blank, line i
 *  is non-blank and line i is after the one the cursor is on.	If we are
 *  beyond end-of-file, the cursor is not moved.
 *
 *  <meta><ppara> moves forward to the first blank line beyond the current/
 *  next paragraph.  This is defined as moving to line i where line i-1 is
 *  non-blank, line i is blank and line i is after the one the cursor is on.
 *  If we are beyond end-of-file, the cursor is not moved.
 */
flagType
ppara (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    LINE y;
    LINE y1 = YCUR(pInsCur);

    if (YCUR(pInsCur) >= pFileHead->cLines) {
        return FALSE;
    }

    if (!fMeta) {
        for (y = YCUR(pInsCur) + 1; y < pFileHead->cLines; y++) {
            if (fIsBlank (pFileHead, y-1) && !fIsBlank (pFileHead, y)) {
                break;
            }
        }
    } else {
        for (y = YCUR(pInsCur) + 1; y < pFileHead->cLines; y++) {
            if (!fIsBlank (pFileHead, y-1) && fIsBlank (pFileHead, y)) {
                break;
            }
        }
    }

    docursor (0, y);
    return (flagType)(y1 != YCUR(pInsCur));

    argData; pArg;
}




/*  mpara - move cursor backward by paragraphs
 *
 *  <mpara> moves backward to the beginning of the previous paragraph.	This
 *  is defined as moving to line i where line i-1 is blank, line i
 *  is non-blank and line i is before the one the cursor is on.  If we are
 *  at the beginning of the file, the cursor is not moved.
 *
 *  <meta><mpara> moves backward to the first blank line before the current/
 *  next paragraph.  This is defined as moving to line i where line i-1 is
 *  non-blank, line i is blank and line i is before the one the cursor is on.
 *  If we are at the beginning of the file, the cursor is not moved.
 */
flagType
mpara (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    LINE y;
    LINE y1 = YCUR(pInsCur);

    if (YCUR(pInsCur) == 0) {
        return FALSE;
    }

    if (!fMeta) {
        for (y = YCUR(pInsCur) - 1; y > 0; y--) {
            if (fIsBlank (pFileHead, y-1) && !fIsBlank (pFileHead, y)) {
                break;
            }
        }
    } else {
        for (y = YCUR(pInsCur) - 1; y > 0; y--) {
            if (!fIsBlank (pFileHead, y-1) && fIsBlank (pFileHead, y)) {
                break;
            }
        }
    }

    docursor (0, y);
    return (flagType)(y1 != YCUR(pInsCur));

    argData; pArg;
}



/*** ppage - moves the cursor down by pages
*
* Purpose: <ppage> moves the cursor one page forward. The size of the
*	    page is actually the vertical size of the current window.
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at end
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

flagType
ppage (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    PagesDown = 1;
    KBDKEY	    Key;
    EDITOR_KEY	    KeyInfo;

    //
    //	Check if there are more  keys and add them up.
    //	Do this only if NOT in a macro
    //

    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x113)
		PagesDown++;
	    else
	    if (KeyInfo.KeyCode == 0x112 && PagesDown > 0)
		PagesDown--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }


    if (PagesDown > 0)
	doscreen (XWIN(pInsCur), YWIN(pInsCur)+(PagesDown * WINYSIZE(pWinCur)),
		  XCUR(pInsCur), YCUR(pInsCur)+(PagesDown * WINYSIZE(pWinCur)) );

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg; fMeta;
}



/*** mppage - moves the cursor up page by page
*
* Purpose: <mpage> moves the cursor one page backwards. The size of the
*	    page is actually the vertical size of the current window.
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at top
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
mpage (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
	) {

    LINE	    y = YCUR(pInsCur);
    LINE	    PagesUp = 1;
    KBDKEY	    Key;
    EDITOR_KEY	KeyInfo;

    //
    //	Check if there are more  keys and add them up.
    //	Do this only if NOT in a macro
    //
    if (!mtest ())
	while (TRUE) {

	    if (!consolePeekKey( &Key ))
		break;

	    KeyInfo = TranslateKey( Key );

	    if ( KeyInfo.KeyCode == 0x112)
		PagesUp++;
	    else
	    if (KeyInfo.KeyCode == 0x113 && PagesUp > 0)
		PagesUp--;
	    else
		break;

	    consoleGetKey( &Key, FALSE );
	    }


    if (PagesUp > 0)
	doscreen (XWIN(pInsCur), YWIN(pInsCur)-(PagesUp * WINYSIZE(pWinCur)),
		  XCUR(pInsCur), YCUR(pInsCur)-(PagesUp * WINYSIZE(pWinCur)));

    return (flagType)(y != YCUR(pInsCur));

    argData; pArg; fMeta;
}



/*** endfile - Sets the cursor at end of file
*
* Purpose:
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at end
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
endfile (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;
    doscreen (0, pFileHead->cLines - YSCALE (hike), 0, pFileHead->cLines );
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));

    argData; pArg; fMeta;
}



/*** begfile - Sets the cursor at top of file
*
* Purpose:
*
* Input: none
*
* Output:
*  Returns True if possible movement, False if cursor already at top
*  of file.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
begfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    fl	flBefore;

    flBefore = pInsCur->flCursorCur;
    doscreen( 0, (LINE)0, 0, (LINE)0 );
    return (flagType)((flBefore.col != XCUR(pInsCur)) || (flBefore.lin != YCUR(pInsCur)));

    argData; pArg; fMeta;
}


flagType
savecur (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    pInsCur->flSaveWin = pInsCur->flWindow;
    pInsCur->flSaveCur = pInsCur->flCursorCur;
    return pInsCur->fSaved = TRUE;

    argData; pArg; fMeta;
}



flagType
restcur (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {
    if (pInsCur->fSaved) {
	pInsCur->flWindow = pInsCur->flSaveWin;
	pInsCur->flCursorCur = pInsCur->flSaveCur;
	pInsCur->fSaved = FALSE;
        SETFLAG (fDisplay, RSTATUS | RCURSOR);
	newwindow ();
	return TRUE;
    } else {
        return FALSE;
    }

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\console.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    console.c

Abstract:

    Interface to the console for Win32 applications.

Author:

    Ramon Juan San Andres (ramonsa) 30-Nov-1990


Revision History:


--*/

#include <string.h>
#include "mep.h"
#include "mouse.h"




//
//  EVENT BUFFER
//
//   The event buffer is used to store event records from the input
//   queue.
//
#define     INITIAL_EVENTS	32
#define     MAX_EVENTS		64
#define     EVENT_INCREMENT	4

#define     ADVANCE		TRUE
#define     NOADVANCE		FALSE
#define     WAIT		TRUE
#define     NOWAIT		FALSE

//
//  For accessing fields of an event record
//
#define     EVENT_TYPE(p)   ((p)->EventType)
#define     EVENT_DATA(p)   ((p)->Event)

//
//  For casting event records
//
#define     PMOUSE_EVT(p)   (&(EVENT_DATA(p).MouseEvent))
#define     PWINDOW_EVT(p)  (&(EVENT_DATA(p).WindowBufferSizeEvent))
#define     PKEY_EVT(p)     (&(EVENT_DATA(p).KeyEvent))
#define     PMENU_EVT(p)    (&(EVENT_DATA(p).MenuEvent))
#define     PFOCUS_EVT(p)   (&(EVENT_DATA(p).FocusEvent))
//
//  The event buffer structure
//
typedef struct EVENT_BUFFER {
    DWORD		MaxEvents;		    //	Max number of events in buffer
    DWORD		NumberOfEvents; 	    //	Number of events in buffer
    DWORD		EventIndex;		    //	Event Index
    BOOL		BusyFlag;		    //	Busy flag
    CRITICAL_SECTION	CriticalSection;	    //	To maintain integrity
    CRITICAL_SECTION	PeekCriticalSection;	    //	While peeking
    PINPUT_RECORD	EventBuffer;		    //	Event Buffer
} EVENT_BUFFER, *PEVENT_BUFFER;





//
//  Screen attributes
//
#define     BLACK_FGD	    0
#define     BLUE_FGD	    FOREGROUND_BLUE
#define     GREEN_FGD	    FOREGROUND_GREEN
#define     CYAN_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN)
#define     RED_FGD	    FOREGROUND_RED
#define     MAGENTA_FGD     (FOREGROUND_BLUE | FOREGROUND_RED)
#define     YELLOW_FGD	    (FOREGROUND_GREEN | FOREGROUND_RED)
#define     WHITE_FGD	    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)

#define     BLACK_BGD	    0
#define     BLUE_BGD	    BACKGROUND_BLUE
#define     GREEN_BGD	    BACKGROUND_GREEN
#define     CYAN_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN)
#define     RED_BGD	    BACKGROUND_RED
#define     MAGENTA_BGD     (BACKGROUND_BLUE | BACKGROUND_RED)
#define     YELLOW_BGD	    (BACKGROUND_GREEN | BACKGROUND_RED)
#define     WHITE_BGD	    (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED)



//
//  The AttrBg and AttrFg arrays are used for mapping DOS attributes
//  to the new attributes.
//
WORD AttrBg[ ] = {
    BLACK_BGD,				    // black
    BLUE_BGD,				    // blue
    GREEN_BGD,				    // green
    CYAN_BGD,				    // cyan
    RED_BGD,				    // red
    MAGENTA_BGD,			    // magenta
    YELLOW_BGD, 			    // brown
    WHITE_BGD,				    // light gray
    BACKGROUND_INTENSITY | BLACK_BGD,	    // dark gray
    BACKGROUND_INTENSITY | BLUE_BGD,	    // light blue
    BACKGROUND_INTENSITY | GREEN_BGD,	    // light green
    BACKGROUND_INTENSITY | CYAN_BGD,	    // light cyan
    BACKGROUND_INTENSITY | RED_BGD,	    // light red
    BACKGROUND_INTENSITY | MAGENTA_BGD,     // light magenta
    BACKGROUND_INTENSITY | YELLOW_BGD,	    // light yellow
    BACKGROUND_INTENSITY | WHITE_BGD	    // white
};

WORD AttrFg[  ] = {
    BLACK_FGD,				    // black
    BLUE_FGD,				    // blue
    GREEN_FGD,				    // green
    CYAN_FGD,				    // cyan
    RED_FGD,				    // red
    MAGENTA_FGD,			    // magenta
    YELLOW_FGD, 			    // brown
    WHITE_FGD,				    // light gray
    FOREGROUND_INTENSITY | BLACK_FGD,	    // dark gray
    FOREGROUND_INTENSITY | BLUE_FGD,	    // light blue
    FOREGROUND_INTENSITY | GREEN_FGD,	    // light green
    FOREGROUND_INTENSITY | CYAN_FGD,	    // light cyan
    FOREGROUND_INTENSITY | RED_FGD,	    // light red
    FOREGROUND_INTENSITY | MAGENTA_FGD,     // light magenta
    FOREGROUND_INTENSITY | YELLOW_FGD,	    // light yellow
    FOREGROUND_INTENSITY | WHITE_FGD	    // white
};

//
//  GET_ATTRIBUTE performs the mapping from old attributes to new attributes
//
#define GET_ATTRIBUTE(x)    (AttrFg[x & 0x000F ] | AttrBg[( x & 0x00F0 ) >> 4])


//
//  The LINE_INFO structure contains information about each line in the
//  screen buffer.
//
typedef struct _LINE_INFO {

    BOOL    Dirty;              //  True if has not been displayed
    BOOL    Garbage;            //  True if contents are garbage
    int     colMinChanged;      //  if dirty, smallest col changed
    int     colMaxChanged;      //  if dirty, biggest col changed
    PCHAR_INFO  Line;           //  Pointer to the line.

} LINE_INFO, *PLINE_INFO;

#define ResetLineInfo(pli)               \
    {   pli->Dirty          = FALSE;     \
        pli->Garbage        = TRUE;      \
        pli->colMinChanged  = 10000;     \
        pli->colMaxChanged  = -1;        \
	}

//
//  The SCREEN_DATA structure contains the information about individual
//  screens.
//
typedef struct SCREEN_DATA {
    HANDLE              ScreenHandle;       //  Handle to screen
    PLINE_INFO          LineInfo;           //  Array of line info.
    PCHAR_INFO          ScreenBuffer;       //  Screen buffer
    ULONG               MaxBufferSize;      //  Max. buffer size
    ATTRIBUTE           AttributeOld;       //  Attribute - original
    WORD                AttributeNew;       //  Attribute - converted
    ROW                 FirstRow;           //  First row to update
    ROW                 LastRow;            //  Last row to update
    CRITICAL_SECTION	CriticalSection;    //	To maintain integrity
    DWORD               CursorSize;         //  Cursor Size
    SCREEN_INFORMATION	ScreenInformation;  //	Screen information
} SCREEN_DATA, *PSCREEN_DATA;


//
//  Static global data
//
static EVENT_BUFFER	EventBuffer;		    //	Event buffer
static HANDLE		hInput; 		    //	handle to stdin
static HANDLE		hOutput;		    //	handle to stdout
static HANDLE		hError; 		    //	handle to stderr
static PSCREEN_DATA	OutputScreenData;	    //	Screen data for hOutput
static PSCREEN_DATA	ActiveScreenData;	    //	Points to current screen data
static BOOL		Initialized = FALSE;	    //	Initialized flag


#if defined (DEBUG)
    static char DbgBuffer[128];
#endif


//
//  Local Prototypes
//
BOOL
InitializeGlobalState (
    void
    );


PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    );

BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    );

PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    );

void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    );

BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    );

BOOL
MenuEvent (
    PMENU_EVENT_RECORD pEvent
    );

BOOL
FocusEvent (
    PFOCUS_EVENT_RECORD pEvent
    );

BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    );


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    );


BOOL
InitializeGlobalState (
    void
    )
/*++

Routine Description:

    Initializes our global state data.

Arguments:

    None.

Return Value:

    TRUE if success
    FALSE otherwise.

--*/
{


    //
    //	Initialize the event buffer
    //
    InitializeCriticalSection( &(EventBuffer.CriticalSection) );
    InitializeCriticalSection( &(EventBuffer.PeekCriticalSection) );
    EventBuffer.NumberOfEvents	= 0;
    EventBuffer.EventIndex	= 0;
    EventBuffer.BusyFlag	= FALSE;
    EventBuffer.EventBuffer = MALLOC( INITIAL_EVENTS * sizeof(INPUT_RECORD) );

    if ( !EventBuffer.EventBuffer ) {
	return FALSE;
    }

    EventBuffer.MaxEvents = INITIAL_EVENTS;


    //
    //	Get handles to stdin, stdout and stderr
    //
    hInput  = GetStdHandle( STD_INPUT_HANDLE );
    hOutput = GetStdHandle( STD_OUTPUT_HANDLE );
    hError  = GetStdHandle( STD_ERROR_HANDLE );


    //
    //	Initialize the screen data for hOutput
    //
    if ( !(OutputScreenData = MakeScreenData( hOutput )) ) {
	return FALSE;
    }


    //
    //	Current screen is hOutput
    //
    ActiveScreenData = OutputScreenData;


    return (Initialized = TRUE);

}





PSCREEN_DATA
MakeScreenData (
    HANDLE  ScreenHandle
    )
/*++

Routine Description:

    Allocates memory for a SCREEN_DATA information and initializes it.

Arguments:

    ScreenHandle    -	Supplies handle of screen.

Return Value:

    POINTER to allocated SCREEN_DATA structure

--*/
{
    PSCREEN_DATA		ScreenData;	//  Pointer to screen data
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.


    //
    //	Allocate space for the screen data.
    //
    if ( !(ScreenData = (PSCREEN_DATA)MALLOC(sizeof(SCREEN_DATA))) ) {
	return NULL;
    }

    //
    //	Allocate space for our copy of the screen buffer.
    //
    GetConsoleScreenBufferInfo( ScreenHandle,
				&ScrInfo );

    ScreenData->MaxBufferSize = ScrInfo.dwSize.Y    *
				ScrInfo.dwSize.X;

    ScreenData->ScreenBuffer = (PCHAR_INFO)MALLOC( ScreenData->MaxBufferSize *
						    sizeof(CHAR_INFO));

    if ( !ScreenData->ScreenBuffer ) {
        FREE( ScreenData );
        return NULL;
    }

    //
    //	Allocate space for the LineInfo array
    //
    ScreenData->LineInfo = (PLINE_INFO)MALLOC( ScrInfo.dwSize.Y * sizeof( LINE_INFO ) );
    if ( !ScreenData->LineInfo ) {
        FREE( ScreenData->ScreenBuffer );
        FREE( ScreenData );
        return NULL;
    }


    //
    //	Memory has been allocated, now initialize the structure
    //
    ScreenData->ScreenHandle = ScreenHandle;

    ScreenData->ScreenInformation.NumberOfRows = ScrInfo.dwSize.Y;
    ScreenData->ScreenInformation.NumberOfCols = ScrInfo.dwSize.X;

    ScreenData->ScreenInformation.CursorRow = ScrInfo.dwCursorPosition.Y;
    ScreenData->ScreenInformation.CursorCol = ScrInfo.dwCursorPosition.X;

    ScreenData->AttributeNew = ScrInfo.wAttributes;
    ScreenData->AttributeOld = 0x00;

    ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow  = 0;

    InitializeCriticalSection( &(ScreenData->CriticalSection) );

    InitLineInfo( ScreenData );

    return ScreenData;
}





BOOL
InitLineInfo (
    PSCREEN_DATA    ScreenData
    )
/*++

Routine Description:

    Initializes the LineInfo array.

Arguments:

    ScreenData	    -	Supplies pointer to screen data.

Return Value:

    TRUE if initialized, false otherwise.

--*/
{

    ROW 	Row;
    COLUMN	Cols;
    PLINE_INFO	LineInfo;
    PCHAR_INFO	CharInfo;


    LineInfo = ScreenData->LineInfo;
    CharInfo = ScreenData->ScreenBuffer;
    Row      = ScreenData->ScreenInformation.NumberOfRows;
    Cols     = ScreenData->ScreenInformation.NumberOfCols;

    while ( Row-- ) {

        ResetLineInfo (LineInfo);

        LineInfo->Line      = CharInfo;

        LineInfo++;
        CharInfo += Cols;

    }

    return TRUE;
}





PSCREEN
consoleNewScreen (
    void
    )
/*++

Routine Description:

    Creates a new screen.

Arguments:

    None.

Return Value:

    Pointer to screen data.

--*/
{
    PSCREEN_DATA		ScreenData;	   //  Screen data
    HANDLE			NewScreenHandle;
    SMALL_RECT			NewSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.
    CONSOLE_CURSOR_INFO 	CursorInfo;

    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if ( !InitializeGlobalState() ) {
	    return NULL;
	}
    }

    //
    //	Create a new screen buffer
    //
    NewScreenHandle = CreateConsoleScreenBuffer(GENERIC_WRITE | GENERIC_READ,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						NULL,
						CONSOLE_TEXTMODE_BUFFER,
						NULL );

    if (NewScreenHandle == INVALID_HANDLE_VALUE) {
	//
	//  No luck
	//
	return NULL;
    }

    //
    //	We want the new window to be the same size as the current one, so
    //	we resize it.
    //
    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    NewSize.Left    = 0;
    NewSize.Top     = 0;
    NewSize.Right   = ScrInfo.srWindow.Right - ScrInfo.srWindow.Left;
    NewSize.Bottom  = ScrInfo.srWindow.Bottom - ScrInfo.srWindow.Top;

    SetConsoleWindowInfo( NewScreenHandle, TRUE, &NewSize );

    //
    //	Now we create a screen data structure for it.
    //
    if ( !(ScreenData = MakeScreenData(NewScreenHandle)) ) {
	CloseHandle(NewScreenHandle);
	return NULL;
    }


    CursorInfo.bVisible = TRUE;
    ScreenData->CursorSize = CursorInfo.dwSize = 25;

    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
			   &CursorInfo );

    //
    //	We are all set. We return a pointer to the
    //	screen data.
    //
    return (PSCREEN)ScreenData;
}





BOOL
consoleCloseScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Closes a screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if screen closed.
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    //
    //	We cannot close the active screen
    //
    if ( !ScreenData || (ScreenData == ActiveScreenData) ) {
	return FALSE;
    }

    if (ScreenData->ScreenHandle != INVALID_HANDLE_VALUE) {
	CloseHandle(ScreenData->ScreenHandle);
    }

    FREE( ScreenData->LineInfo );
    FREE( ScreenData->ScreenBuffer );
    FREE( ScreenData );

    return TRUE;
}





PSCREEN
consoleGetCurrentScreen (
    void
    )
/*++

Routine Description:

    Returns the current screen.

Arguments:

    none.

Return Value:

    Pointer to currently active screen data.

--*/
{
    if ( !Initialized ) {

	//
	//  We have to initialize our global state.
	//
	if (!InitializeGlobalState()) {
	    return NULL;
	}
    }

    return (PSCREEN)ActiveScreenData;
}





BOOL
consoleSetCurrentScreen (
    PSCREEN   pScreen
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen  -	 Supplies pointer to screen data.

Return Value:

    TRUE if the active screen set
    FALSE otherwise.

--*/
{
    BOOL	    ScreenSet	  = TRUE;
    PSCREEN_DATA    CurrentScreen = ActiveScreenData;


    EnterCriticalSection( &(CurrentScreen->CriticalSection) );

    ScreenSet = SetConsoleActiveScreenBuffer( ((PSCREEN_DATA)pScreen)->ScreenHandle);

    if (ScreenSet) {
	ActiveScreenData = (PSCREEN_DATA)pScreen;
    }

    LeaveCriticalSection( &(CurrentScreen->CriticalSection) );

    return ScreenSet;
}





BOOL
consoleGetScreenInformation (
    PSCREEN            pScreen,
    PSCREEN_INFORMATION    pScreenInfo
    )
/*++

Routine Description:

    Sets the active screen.

Arguments:

    pScreen	-   Supplies pointer to screen data.
    pScreenInfo -   Supplies pointer to screen info buffer

Return Value:

    TRUE if the screen info returned
    FALSE otherwise.

--*/
{

    PSCREEN_DATA ScreenData = (PSCREEN_DATA)pScreen;

    if (!ScreenData) {
	return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    memcpy(pScreenInfo, &(ScreenData->ScreenInformation), sizeof(SCREEN_INFORMATION));

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}



BOOL
consoleSetScreenSize (
    PSCREEN pScreen,
    ROW Rows,
    COLUMN  Cols
    )
/*++

Routine Description:

    Sets the screen size

Arguments:

    pScreen	-   Supplies pointer to screen data.
    Rows	-   Number of rows
    Cols	-   Number of columns

Return Value:

    TRUE if screen size changed successfully
    FALSE otherwise.

--*/
{

    PSCREEN_DATA		ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_SCREEN_BUFFER_INFO	ScreenBufferInfo;
    SMALL_RECT			ScreenRect;
    COORD			ScreenSize;
    USHORT			MinRows;
    USHORT			MinCols;
    ULONG			NewBufferSize;
    BOOL			WindowSet   = FALSE;
    BOOL			Status	    = FALSE;

    //
    //	Won't attempt to resize larger than the largest window size
    //
    ScreenSize = GetLargestConsoleWindowSize( ScreenData->ScreenHandle );

    if ( (Rows > (ROW)ScreenSize.Y) || (Cols > (COLUMN)ScreenSize.X) ) {
        return FALSE;
    }

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    //
    //	Obtain the current screen information.
    //
    if ( GetConsoleScreenBufferInfo( ScreenData->ScreenHandle, &ScreenBufferInfo ) ) {

        //
        //  If the desired buffer size is smaller than the current window
        //  size, we have to resize the current window first.
        //
        if ( ( Rows < (ROW)
                   (ScreenBufferInfo.srWindow.Bottom -
                ScreenBufferInfo.srWindow.Top + 1) ) ||
             ( Cols < (COLUMN)
                   (ScreenBufferInfo.srWindow.Right -
                ScreenBufferInfo.srWindow.Left + 1) ) ) {

            //
            //  Set the window to a size that will fit in the current
            //  screen buffer and that is no bigger than the size to
            //  which we want to grow the screen buffer.
            //
            MinRows = (USHORT)min( (int)Rows, (int)(ScreenBufferInfo.dwSize.Y) );
            MinCols = (USHORT)min( (int)Cols, (int)(ScreenBufferInfo.dwSize.X) );

            ScreenRect.Top  = 0;
            ScreenRect.Left = 0;
            ScreenRect.Right    = (SHORT)MinCols - (SHORT)1;
            ScreenRect.Bottom   = (SHORT)MinRows - (SHORT)1;

            WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

            if ( !WindowSet ) {
                //
                //  ERROR
                //
                goto Done;
            }
        }

        //
        //  Set the screen buffer size to the desired size.
        //
        ScreenSize.X = (WORD)Cols;
        ScreenSize.Y = (WORD)Rows;

        if ( !SetConsoleScreenBufferSize( ScreenData->ScreenHandle, ScreenSize ) ) {

            //
            //  ERROR
            //
            //
            //  Return the window to its original size. We ignore the return
            //  code because there is nothing we can do about it.
            //
            SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &(ScreenBufferInfo.srWindow) );
            goto Done;
        }

        //
        //  resize the screen buffer. Note that the contents of the screen
        //  buffer are not valid anymore. Someone else will have to update
        //  them.
        //
        NewBufferSize = Rows * Cols;

        if (ScreenData->MaxBufferSize < NewBufferSize ) {
            ScreenData->ScreenBuffer = REALLOC( ScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
            ScreenData->MaxBufferSize = NewBufferSize;
            ScreenData->LineInfo = REALLOC( ScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
        }

        //
        //  Set the Window Size. We know that we can grow the window to this size
        //  because we tested the size against the largest window size at the
        //  beginning of the function.
        //
        ScreenRect.Top      = 0;
        ScreenRect.Left     = 0;
        ScreenRect.Right    = (SHORT)Cols - (SHORT)1;
        ScreenRect.Bottom   = (SHORT)Rows - (SHORT)1;

        WindowSet = (BOOL)SetConsoleWindowInfo( ScreenData->ScreenHandle, TRUE, &ScreenRect );

        if ( !WindowSet ) {
            //
            //  We could not resize the window. We will leave the
            //  resized screen buffer.
            //
            //  ERROR
            //
            InitLineInfo( ScreenData );
            goto Done;
        }

        //
        //  Update the screen size
        //
        ScreenData->ScreenInformation.NumberOfRows = Rows;
        ScreenData->ScreenInformation.NumberOfCols = Cols;

        InitLineInfo( ScreenData );

        //
        //  Done
        //
        Status = TRUE;

    } else {

        //
        //  ERROR
        //
        Status = FALSE;
    }

Done:
    //
    //	Invalidate the entire screen buffer
    //
    ScreenData->FirstRow    = ScreenData->ScreenInformation.NumberOfRows;
    ScreenData->LastRow     = 0;

    LeaveCriticalSection( &(ScreenData->CriticalSection) );
    return Status;

}




BOOL
consoleSetCursor (
    PSCREEN pScreen,
    ROW Row,
    COLUMN  Col
    )
/*++

Routine Description:

    Moves the cursor to a certain position.

Arguments:

    pScreen -	Supplies pointer to screen data
    Row     -	Supplies row coordinate
    Col     -	Supplies column coordinate

Return Value:

    TRUE if moved
    FALSE otherwise.

--*/
{

    PSCREEN_DATA    ScreenData	= (PSCREEN_DATA)pScreen;
    COORD	    Position;
    BOOL	    Moved	= FALSE;


    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ((Row != ScreenData->ScreenInformation.CursorRow) ||
	(Col != ScreenData->ScreenInformation.CursorCol) ) {

	assert( Row < ScreenData->ScreenInformation.NumberOfRows);
	assert( Col < ScreenData->ScreenInformation.NumberOfCols);

	Position.Y = (SHORT)Row;
	Position.X = (SHORT)Col;

	if ( SetConsoleCursorPosition( ScreenData->ScreenHandle,
				       Position )) {
	    //
	    //	Cursor moved, update the data
	    //
	    ScreenData->ScreenInformation.CursorRow    =   Row;
	    ScreenData->ScreenInformation.CursorCol    =   Col;

	    Moved = TRUE;
	}
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Moved;
}




BOOL
consoleSetCursorStyle (
    PSCREEN pScreen,
    ULONG   Style
    )

/*++

Routine Description7:

    Sets the cursor style. The two available styles are: underscrore and
    box

Arguments:

    Style	-   New cursor style

Return Value:

    True if cursor style set

--*/

{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;

    CursorInfo.bVisible = TRUE;

    if ( Style == CURSOR_STYLE_UNDERSCORE ) {

	CursorInfo.dwSize = 25;

    } else if ( Style == CURSOR_STYLE_BOX ) {

	CursorInfo.dwSize = 100;

    } else {

	return FALSE;

    }

    ScreenData->CursorSize = CursorInfo.dwSize;

    return SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				  &CursorInfo );

}





ULONG
consoleWriteLine (
    PSCREEN     pScreen,
    PVOID       pBuffer,
    ULONG       BufferSize,
    ROW         Row,
    COLUMN      Col,
    ATTRIBUTE   Attribute,
    BOOL        Blank
    )
/*++

Routine Description7:

    Writes a buffer to the screen with the specified attribute and blanks
    to end of row.

Arguments:

    pScreen	-   Supplies pointer to screen data
    pBuffer	-   Supplies pointer to buffer
    BufferSize	-   Supplies the size of the buffer
    Row 	-   Supplies row coordinate
    Col 	-   Supplies column coordinate
    Attr	-   Supplies the attribute
    Blank	-   TRUE if we should blank to end of last row written.

Return Value:

    Number of bytes written

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    PLINE_INFO	    LineInfo;
    PCHAR_INFO	    CharInfo;
    CHAR_INFO	    Char;
    WORD	    Attr;

    char *	    p = (char *)pBuffer;

    COLUMN      ColsLeft;   //  Available columns
    COLUMN      InfoCols;   //  Columns taken from buffer
    COLUMN      BlankCols;  //  Columns to be blanked
    COLUMN	    Column;	    //	Counter;

    //
    //	We will ignore writes outside of the screen buffer
    //
    if ( ( Row >= ScreenData->ScreenInformation.NumberOfRows ) ||
         ( Col >= ScreenData->ScreenInformation.NumberOfCols ) ) {
        return TRUE;
    }

    //
    //	Ignore trivial writes
    //
    if (BufferSize == 0 && !Blank) {
        return TRUE;
    }


    EnterCriticalSection( &(ScreenData->CriticalSection) );


    //
    //	We will truncate writes that are too long
    //
    if ( (Col + BufferSize) >= ScreenData->ScreenInformation.NumberOfCols ) {
        BufferSize = ScreenData->ScreenInformation.NumberOfCols - Col;
    }

    LineInfo = ScreenData->LineInfo + Row;
    CharInfo = LineInfo->Line + Col;

    ColsLeft  = ScreenData->ScreenInformation.NumberOfCols - Col;
    InfoCols  = min( BufferSize, ColsLeft );
    BlankCols = Blank ? (ColsLeft - InfoCols) : 0;

    //
    //	Set the attribute
    //
    if ( Attribute != ScreenData->AttributeOld ) {
        ScreenData->AttributeOld  = Attribute;
        ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }
    Attr = ScreenData->AttributeNew;

    //
    //	set up default attribute
    //
    Char.Attributes = Attr;

    //
    //	set up number of columns to draw
    //
    Column = InfoCols;

    //
    //	draw chars in all specified columns
    //
    while ( Column-- ) {

        //
        //  use character from input string
        //
        Char.Char.AsciiChar = *p++;

        //
        //  update change portions of line info
        //
        if (LineInfo->Garbage ||
            CharInfo->Attributes != Char.Attributes ||
            CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

            LineInfo->colMinChanged = min (LineInfo->colMinChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->Dirty = TRUE;
	    }

        //
        //  set up new character
        //
        *CharInfo++ = Char;
    }


    //
    //	Blank to end of line
    //
    Char.Attributes     = Attr;
    Char.Char.AsciiChar = ' ';
    Column              = BlankCols;

    while ( Column-- ) {

        //
        //  update change portions of line info
        //
        if (LineInfo->Garbage ||
            CharInfo->Attributes != Char.Attributes ||
            CharInfo->Char.AsciiChar != Char.Char.AsciiChar) {

            LineInfo->colMinChanged = min (LineInfo->colMinChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->colMaxChanged = max (LineInfo->colMaxChanged, (int)(CharInfo - LineInfo->Line));
            LineInfo->Dirty = TRUE;
        }

        *CharInfo++ = Char;
    }


    //
    //	Update row information
    //
    if ( Row < ScreenData->FirstRow ) {
        ScreenData->FirstRow = Row;
    }
    if ( Row > ScreenData->LastRow ) {
        ScreenData->LastRow = Row;
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return (ULONG)(InfoCols + BlankCols);
}





BOOL
consoleShowScreen (
    PSCREEN     pScreen
    )
/*++

Routine Description:

    Moves data from our screen buffer to the console screen buffer.

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if done
    FALSE otherwise

--*/
{

    PSCREEN_DATA	ScreenData = (PSCREEN_DATA)pScreen;
    CONSOLE_CURSOR_INFO CursorInfo;
    PLINE_INFO		LineInfo;
    BOOL		Shown	   = FALSE;
    ROW 		FirstRow;
    ROW 		LastRow;
    COLUMN		LastCol;

    COORD		Position;
    COORD		Size;
    SMALL_RECT		Rectangle;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if ( ScreenData->FirstRow <= ScreenData->LastRow ) {

	Size.X = (SHORT)(ScreenData->ScreenInformation.NumberOfCols);
	Size.Y = (SHORT)(ScreenData->ScreenInformation.NumberOfRows);

	FirstRow = ScreenData->FirstRow;
	LineInfo = ScreenData->LineInfo + FirstRow;

	LastCol  = ScreenData->ScreenInformation.NumberOfCols-1;

	//
	//  Find next dirty block
	//
	while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
	    FirstRow++;
	    LineInfo++;
	}

	while ( FirstRow <= ScreenData->LastRow ) {

	    int colLeft, colRight;

	    //
	    //	Get the block
	    //

	    LastRow  = FirstRow;

	    //
	    //	set up for left/right boundary accrual
	    //

	    colLeft = LastCol + 1;
	    colRight = -1;

	    while ( (LastRow <= ScreenData->LastRow) && LineInfo->Dirty ) {

		//
		//  accrue smallest bounding right/left margins
		//

		colLeft = min (colLeft, LineInfo->colMinChanged);
		colRight = max (colRight, LineInfo->colMaxChanged);

		//
		//  reset line information
		//

		ResetLineInfo (LineInfo);

		//
		//  advance to next row
		//

		LastRow++;
		LineInfo++;
	    }
	    LastRow--;


	    //
	    //	Write the block
	    //
	    assert( FirstRow <= LastRow );

	    Position.X = (SHORT)colLeft;
	    Position.Y = (SHORT)FirstRow;

	    Rectangle.Top    = (SHORT)FirstRow;
	    Rectangle.Bottom = (SHORT)LastRow;
	    Rectangle.Left = (SHORT) colLeft;
	    Rectangle.Right = (SHORT) colRight;

	    //
	    //	Performance hack: making the cursor invisible speeds
	    //	screen updates.
	    //
	    CursorInfo.bVisible = FALSE;
	    CursorInfo.dwSize	= ScreenData->CursorSize;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    Shown = WriteConsoleOutput( ScreenData->ScreenHandle,
					ScreenData->ScreenBuffer,
					Size,
					Position,
					&Rectangle );

#if defined (DEBUG)
	    if ( !Shown ) {
		char DbgB[128];
		sprintf(DbgB, "MEP: WriteConsoleOutput Error %d\n", GetLastError() );
		OutputDebugString( DbgB );
	    }
#endif
	    assert( Shown );

	    CursorInfo.bVisible = TRUE;
	    SetConsoleCursorInfo ( ScreenData->ScreenHandle,
				   &CursorInfo );

	    FirstRow = LastRow + 1;

	    //
	    //	Find next dirty block
	    //
	    while ( (FirstRow <= ScreenData->LastRow) && !LineInfo->Dirty ) {
		FirstRow++;
		LineInfo++;
	    }
	}

	ScreenData->LastRow  = 0;
	ScreenData->FirstRow = ScreenData->ScreenInformation.NumberOfRows;

    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Shown;

}





BOOL
consoleClearScreen (
    PSCREEN     pScreen,
    BOOL        ShowScreen
    )
/*++

Routine Description:

	Clears the screen

Arguments:

    pScreen	-   Supplies pointer to screen data

Return Value:

    TRUE if screen cleared
    FALSE otherwise

--*/
{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    ROW 	    Rows;
    BOOL	    Status = TRUE;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    Rows = ScreenData->ScreenInformation.NumberOfRows;

    while ( Rows-- ) {
	consoleWriteLine( pScreen, NULL, 0, Rows, 0, ScreenData->AttributeOld, TRUE );
    }

    if (ShowScreen) {
	Status = consoleShowScreen( pScreen );
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return Status;
}



BOOL
consoleScrollVert (
    PSCREEN      pScreen,
    ROW          Top,
    COLUMN       Left,
    ROW          Bottom,
    COLUMN       Right,
    INT          Rows
    )
/*++

Routine Description:

    Scrolls

Arguments:

    pScreen     -   Supplies pointer to screen data
    Top         -   Supplies top row
    Left        -   Supplies left column
    Bottom      -   Supplies bottom row
    Right       -   Supplies right column
    Rows        -   Number of rows to scroll

Return Value:

    TRUE if scrolled
    FALSE otherwise

--*/

{
    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;
    SMALL_RECT      Rect;
    COORD           Coord;
    CHAR_INFO       CharInfo;
    BOOLEAN         Ok;
    PLINE_INFO      LineInfo;
    ROW             R;

    if ( Rows ) {

        EnterCriticalSection( &(ScreenData->CriticalSection) );

        //
        //  If there is something to flush, we flush it now
        //
        if ( ScreenData->FirstRow <= ScreenData->LastRow ) {
            consoleShowScreen( pScreen );
        }


        //
        //  Scroll
        //
	Coord.X = (SHORT)Left;
	Coord.Y = (SHORT)Top;

	Rect.Left   = (SHORT)Left;
	Rect.Top    = (SHORT)Top;
	Rect.Right  = (SHORT)Right;
	Rect.Bottom = (SHORT)Bottom;

        if ( Rows > 0 ) {

            Rect.Top    += (short)Rows;

        } else {

            Rect.Bottom += (short)Rows;
            Coord.Y     -= (short)Rows;
        }


        CharInfo.Char.AsciiChar  = ' ';
        CharInfo.Attributes = ScreenData->AttributeNew;

        Ok = ScrollConsoleScreenBuffer(
                ScreenData->ScreenHandle,
                &Rect,
                NULL,
                Coord,
                &CharInfo
                ) != FALSE;

        //
        //  Mark all the lines in our buffer as containing garbage
        //
        LineInfo = ScreenData->LineInfo + Top;
        R        = Bottom - Top + 1;

        while ( R-- ) {
            LineInfo->Garbage = TRUE;
            LineInfo++;
        }

        LeaveCriticalSection( &(ScreenData->CriticalSection) );
    }

    return Ok;
}






BOOL
consoleSetAttribute (
    PSCREEN      pScreen,
    ATTRIBUTE    Attribute
    )
/*++

Routine Description:

    Sets the console attribute

Arguments:

    pScreen	-   Supplies pointer to screen data
    Attribute	-   Supplies the attribute

Return Value:

    TRUE if Attribute set
    FALSE otherwise

--*/
{

    PSCREEN_DATA    ScreenData = (PSCREEN_DATA)pScreen;

    EnterCriticalSection( &(ScreenData->CriticalSection) );

    if (Attribute != ScreenData->AttributeOld) {
	ScreenData->AttributeOld = Attribute;
	ScreenData->AttributeNew = GET_ATTRIBUTE(Attribute);
    }

    LeaveCriticalSection( &(ScreenData->CriticalSection) );

    return TRUE;
}









BOOL
consoleFlushInput (
    void
    )
/*++

Routine Description:

    Flushes input events.

Arguments:

    None.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    EventBuffer.NumberOfEvents = 0;

    return FlushConsoleInputBuffer( hInput );
}







BOOL
consoleGetMode (
    PKBDMODE pMode
    )
/*++

Routine Description:

    Get current console mode.

Arguments:

    pMode   -	Supplies a pointer to the mode flag variable

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    return GetConsoleMode( hInput,
			   pMode );
}






BOOL
consoleSetMode (
    KBDMODE Mode
    )
/*++

Routine Description:

    Sets the console mode.

Arguments:

    Mode    -	Supplies the mode flags.

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    return SetConsoleMode( hInput,
			   Mode );
}


BOOL
consoleIsKeyAvailable (
    void
    )
/*++

Routine Description:

    Returns TRUE if a key is available in the event buffer.

Arguments:

    None.

Return Value:

    TRUE if a key is available in the event buffer
    FALSE otherwise

--*/

{
    BOOL	    IsKey = FALSE;
    PINPUT_RECORD   pEvent;
    DWORD	    Index;

    EnterCriticalSection( &(EventBuffer.CriticalSection) );

    for ( Index = EventBuffer.EventIndex; Index < EventBuffer.NumberOfEvents; Index++ ) {

	pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

	if ( ((EVENT_TYPE(pEvent)) == KEY_EVENT) &&
	     (PKEY_EVT(pEvent))->bKeyDown ) {
	    IsKey = TRUE;
	    break;
	}
    }

    LeaveCriticalSection( &(EventBuffer.CriticalSection) );

    return IsKey;
}




BOOL
consoleDoWindow (
    void
    )

/*++

Routine Description:

    Responds to a window event

Arguments:

    None.

Return Value:

    TRUE if window changed
    FALSE otherwise

--*/

{

    PINPUT_RECORD   pEvent;

    pEvent = NextEvent( NOADVANCE, NOWAIT );

    if (( EVENT_TYPE(pEvent) ) == WINDOW_BUFFER_SIZE_EVENT) {

	pEvent = NextEvent( ADVANCE, WAIT );
	WindowEvent(PWINDOW_EVT(pEvent));
    }

    return FALSE;

}





BOOL
consolePeekKey (
    PKBDKEY Key
    )

/*++

Routine Description:

    Gets the next key from the input buffer if the buffer is not empty.


Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/

{

    PINPUT_RECORD   pEvent;
    BOOL	    Done    = FALSE;
    BOOL	    IsKey   = FALSE;

    EnterCriticalSection(&(EventBuffer.PeekCriticalSection));

    do {

	pEvent = NextEvent( NOADVANCE, NOWAIT );

	if ( pEvent ) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)){
		    IsKey = TRUE;
		    Done  = TRUE;
		}
		break;

	    case MOUSE_EVENT:
		Done = TRUE;
		break;


	    case WINDOW_BUFFER_SIZE_EVENT:
		Done = TRUE;
		break;

        case MENU_EVENT:
        case FOCUS_EVENT:
        Done = TRUE;
        break;

	    default:
		assert( FALSE );
		break;
	    }

	    if ( !Done ) {
		NextEvent( ADVANCE, NOWAIT );
	    }

	} else {
	    Done = TRUE;
	}

    } while ( !Done );

    LeaveCriticalSection(&(EventBuffer.PeekCriticalSection));

    return IsKey;

}






BOOL
consoleGetKey (
    PKBDKEY        Key,
     BOOL           fWait
    )
/*++

Routine Description:

    Gets the next key from  the input buffer.

Arguments:

    Key     -	Supplies a pointer to a key structure
    fWait   -	Supplies a flag:
		if TRUE, the function blocks until a key is ready.
		if FALSE, the function returns immediately.

Return Value:

    TRUE if keystroke read, FALSE otherwise.

--*/
{

    PINPUT_RECORD   pEvent;

    do {
	pEvent = NextEvent( ADVANCE, fWait );

	if (pEvent) {

	    switch ( EVENT_TYPE(pEvent) ) {

	    case KEY_EVENT:
		if (KeyEvent(PKEY_EVT(pEvent), Key)) {
		    return TRUE;
		}
		break;

	    case MOUSE_EVENT:
		MouseEvent(PMOUSE_EVT(pEvent));
		break;

	    case WINDOW_BUFFER_SIZE_EVENT:
		WindowEvent(PWINDOW_EVT(pEvent));
		break;

        case MENU_EVENT:
        MenuEvent(PMENU_EVT(pEvent));
        break;

        case FOCUS_EVENT:
        FocusEvent(PFOCUS_EVT(pEvent));
        break;

	    default:
		break;
	    }
	}
    } while (fWait);

    return FALSE;
}


BOOL
consolePutKey (
    PKBDKEY     Key
    )
/*++

Routine Description:

    Puts a key in the console's input buffer

Arguments:

    Key     -	Supplies a pointer to a key structure

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;

    InputRecord.EventType   =	KEY_EVENT;

    InputRecord.Event.KeyEvent.bKeyDown 	  =   FALSE;
    InputRecord.Event.KeyEvent.wRepeatCount	  =   0;
    InputRecord.Event.KeyEvent.wVirtualKeyCode	  =   Key->Scancode;
    InputRecord.Event.KeyEvent.wVirtualScanCode   =   0;
    InputRecord.Event.KeyEvent.uChar.UnicodeChar  =   Key->Unicode;
    InputRecord.Event.KeyEvent.dwControlKeyState  =   Key->Flags;

    if ( PutEvent( &InputRecord )) {
	InputRecord.Event.KeyEvent.bKeyDown	  =   TRUE;
	return PutEvent( &InputRecord );
    }
    return FALSE;
}


BOOL
consolePutMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Puts a mose event in the console's input buffer

Arguments:

    Row 	-   Supplies the row
    Col 	-   Supplies the column
    MouseFlags	-   Supplies the flags

Return Value:

    TRUE if key put, false otherwise

--*/
{

    INPUT_RECORD    InputRecord;
    COORD	    Position;
    DWORD	    Flags;

    InputRecord.EventType   =	MOUSE_EVENT;

    Position.Y = (WORD)(Row - 1);
    Position.X = (WORD)(Col - 1);

    Flags = 0;

    if ( MouseFlags & MOUSE_CLICK_LEFT ) {
	Flags |= FROM_LEFT_1ST_BUTTON_PRESSED;
    }
    if ( MouseFlags & MOUSE_CLICK_RIGHT ) {
	Flags |= RIGHTMOST_BUTTON_PRESSED;
    }
    if ( MouseFlags & MOUSE_DOUBLE_CLICK ) {
	Flags |= DOUBLE_CLICK;
    }

    InputRecord.Event.MouseEvent.dwMousePosition    =	Position;
    InputRecord.Event.MouseEvent.dwButtonState	    =	Flags;
    InputRecord.Event.MouseEvent.dwControlKeyState  =	0;
    InputRecord.Event.MouseEvent.dwEventFlags	    =	0;

    return PutEvent( &InputRecord );
}



BOOL
consoleIsBusyReadingKeyboard (
    )
/*++

Routine Description:

    Determines if the console is busy reading the keyboard

Arguments:

    None

Return Value:

    TRUE if console is busy reading the keyboard.

--*/
{
    BOOL    Busy;

    EnterCriticalSection(&(EventBuffer.CriticalSection));
    Busy = EventBuffer.BusyFlag;
    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return Busy;
}



BOOL
consoleEnterCancelEvent (
    )
{

    INPUT_RECORD    Record;
    DWORD           dw;

    Record.EventType = KEY_EVENT;
    Record.Event.KeyEvent.bKeyDown            = TRUE;
    Record.Event.KeyEvent.wRepeatCount	      = 0;
    Record.Event.KeyEvent.wVirtualKeyCode     = VK_CANCEL;
    Record.Event.KeyEvent.wVirtualScanCode    = 0;
    Record.Event.KeyEvent.uChar.AsciiChar     = 0;
    Record.Event.KeyEvent.dwControlKeyState   = 0;

    PutEvent( &Record );

    Record.Event.KeyEvent.bKeyDown = TRUE;
    WriteConsoleInput( hInput, &Record, 1, &dw );

    return TRUE;
}


PINPUT_RECORD
NextEvent (
    BOOL    fAdvance,
    BOOL    fWait
    )
/*++

Routine Description:

    Returns pointer to next event record.

Arguments:

    fAdvance	-   Supplies a flag:
		    if TRUE: Advance to next event record
		    if FALSE: Do not advance to next event record

    fWait	-   Supplies a flag:
		    if TRUE, the  blocks until an event is ready.
		    if FALSE, return immediately.

Return Value:

    Pointer to event record, or NULL.

--*/
{
    PINPUT_RECORD  pEvent;
    BOOL Success;

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If the busy flag is set, then the buffer is in the process of
    //	being read. Only one thread should want to wait, so it is
    //	safe to simply return.
    //
    if ( EventBuffer.BusyFlag ) {
	assert( !fWait );
	LeaveCriticalSection(&(EventBuffer.CriticalSection));
	return NULL;
    }

    if (EventBuffer.NumberOfEvents == 0) {

	//
	//  No events in buffer, read as many as we can
	//
	DWORD NumberOfEvents;

	//
	//  If the buffer is too big, resize it
	//
	if ( EventBuffer.MaxEvents > MAX_EVENTS ) {

	    EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					       MAX_EVENTS * sizeof( INPUT_RECORD ) );

	    EventBuffer.MaxEvents = MAX_EVENTS;
	    assert( EventBuffer.EventBuffer );
	    CleanExit( 1, 0 );
	}

	Success = PeekConsoleInput( hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &NumberOfEvents);

	if ((!Success || (NumberOfEvents == 0)) && (!fWait)) {
	    //
	    //	No events available and don't want to wait,
	    //	return.
	    //
	    LeaveCriticalSection(&(EventBuffer.CriticalSection));
	    return NULL;
	}

	//
	//  Since we will block, we have to leave the critical section.
	//  We set the Busy flag to indicate that the buffer is being
	//  read.
	//
	EventBuffer.BusyFlag = TRUE;
	LeaveCriticalSection(&(EventBuffer.CriticalSection));

	Success = ReadConsoleInput (hInput,
				    EventBuffer.EventBuffer,
				    EventBuffer.MaxEvents,
				    &EventBuffer.NumberOfEvents);

	EnterCriticalSection(&(EventBuffer.CriticalSection));

	EventBuffer.BusyFlag = FALSE;

	if (!Success) {
#if defined( DEBUG )
	    OutputDebugString(" Error: Cannot read console events\n");
	    assert( Success );
#endif
	    EventBuffer.NumberOfEvents = 0;
	}
	EventBuffer.EventIndex = 0;
    }

    pEvent = EventBuffer.EventBuffer + EventBuffer.EventIndex;

    //
    //	If Advance flag is set, we advance the pointer to the next
    //	record.
    //
    if (fAdvance) {
	if (--(EventBuffer.NumberOfEvents)) {

	    switch (EVENT_TYPE(pEvent)) {

	    case KEY_EVENT:
	    case MOUSE_EVENT:
        case WINDOW_BUFFER_SIZE_EVENT:
        case MENU_EVENT:
        case FOCUS_EVENT:
		(EventBuffer.EventIndex)++;
		break;

	    default:
#if defined( DEBUG)
		sprintf(DbgBuffer, "WARNING: unknown event type %X\n", EVENT_TYPE(pEvent));
		OutputDebugString(DbgBuffer);
#endif
		(EventBuffer.EventIndex)++;
		break;
	    }
	}
    }


    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return pEvent;
}





void
MouseEvent (
    PMOUSE_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes mouse events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None..

--*/
{
    static  BOOL    Pressed = FALSE;
	    DWORD   MouseFlags;

    //
    //	We only know left and right mouse buttons
    //
    pEvent->dwButtonState &= ( FROM_LEFT_1ST_BUTTON_PRESSED | RIGHTMOST_BUTTON_PRESSED );

    //
    //  Let the editor handle the mouse event
    //
    MouseFlags = 0x00;
    if ( pEvent->dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED ) {
        MouseFlags |=  MOUSE_CLICK_LEFT;
    }
    if ( pEvent->dwButtonState & RIGHTMOST_BUTTON_PRESSED ) {
        MouseFlags |=  MOUSE_CLICK_RIGHT;
    }
    if ( pEvent->dwEventFlags & DOUBLE_CLICK ) {
        MouseFlags |=  MOUSE_DOUBLE_CLICK;
    }

    DoMouse( pEvent->dwMousePosition.Y+1,
        pEvent->dwMousePosition.X+1,
        MouseFlags );

    Pressed = (BOOL)pEvent->dwButtonState;
}





BOOL
WindowEvent (
    PWINDOW_BUFFER_SIZE_RECORD pEvent
    )
/*++

Routine Description:

    Processes window size change events.

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{

    ROW     Rows;
    COLUMN  Cols;
    ULONG   NewBufferSize;
    CONSOLE_SCREEN_BUFFER_INFO	ScrInfo;	//  Screen buffer info.

    UNREFERENCED_PARAMETER( pEvent );

    GetConsoleScreenBufferInfo( ActiveScreenData->ScreenHandle,
				&ScrInfo );

    Rows = ScrInfo.dwSize.Y;
    Cols = ScrInfo.dwSize.X;

    if ( Rows > ActiveScreenData->ScreenInformation.NumberOfRows ||
	 Cols > ActiveScreenData->ScreenInformation.NumberOfCols ) {

	//
	//  resize the screen buffer. Note that the contents of the screen
	//  buffer are not valid anymore. Someone else will have to update
	//  them.
	//
	NewBufferSize = Rows * Cols;

	if (ActiveScreenData->MaxBufferSize < NewBufferSize ) {
	    ActiveScreenData->ScreenBuffer = REALLOC( ActiveScreenData->ScreenBuffer, NewBufferSize * sizeof(CHAR_INFO));
	    ActiveScreenData->MaxBufferSize = NewBufferSize;
	    ActiveScreenData->LineInfo = REALLOC( ActiveScreenData->LineInfo, Rows * sizeof( LINE_INFO ) );
	}

	//
	//  Set the size
	//
	ActiveScreenData->ScreenInformation.NumberOfRows = Rows;
	ActiveScreenData->ScreenInformation.NumberOfCols = Cols;

	ActiveScreenData->FirstRow = ActiveScreenData->ScreenInformation.NumberOfRows;
	ActiveScreenData->LastRow  = 0;

	InitLineInfo( ActiveScreenData );

	//
	//  Let the editor respond the the event
	//
	WindowChange( Rows, Cols );
	return TRUE;
    }

    return FALSE;
}


BOOL
MenuEvent (
    PMENU_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes menu events

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( pEvent );
    return TRUE;
}

BOOL
FocusEvent (
    PFOCUS_EVENT_RECORD pEvent
    )
/*++

Routine Description:

    Processes focus events

Arguments:

    pEvent  -	Supplies pointer to event record

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( pEvent );
    return TRUE;

}


BOOL
KeyEvent (
    PKEY_EVENT_RECORD	pEvent,
    PKBDKEY		pKey
    )
/*++

Routine Description:

    Processes key events.

Arguments:

    pEvent  -	Supplies pointer to event record
    pKey    -	Supplies pointer to key structure to fill out.

Return Value:

    TRUE if key structured filled out, FALSE otherwise.

--*/
{
    // static BOOL AltPressed = FALSE;

    if (pEvent->bKeyDown) {

	WORD  Scan = pEvent->wVirtualKeyCode;

	//
	//  Pressing the ALT key generates an event, but we filter this
	//  out.
	//
    //if (Scan == VK_MENU) {
    //    return FALSE;
    //}
    if ( Scan == VK_MENU && pEvent->uChar.UnicodeChar == 0 ) {
        return FALSE;
    }

	if (Scan != VK_NUMLOCK &&   // NumLock
	    Scan != VK_CAPITAL &&   // Caps Lock
	    Scan != VK_SHIFT   &&   // Shift
	    Scan != VK_CONTROL ) {  // Ctrl

	    pKey->Unicode   = pEvent->uChar.UnicodeChar;
	    pKey->Scancode  = pEvent->wVirtualKeyCode;
	    pKey->Flags     = pEvent->dwControlKeyState;

//#if defined (DEBUG)
//   sprintf(DbgBuffer, "  KEY: Scan %d Unicode %x\n", pKey->Scancode, pKey->Unicode );
//   OutputDebugString(DbgBuffer);
//#endif
	    return TRUE;

	} else {

	    return FALSE;

	}

    } else {

	return FALSE;

    }
}


BOOL
PutEvent (
    PINPUT_RECORD	InputRecord
    )
{

    EnterCriticalSection(&(EventBuffer.CriticalSection));

    //
    //	If no space at beginning of buffer, resize and shift right
    //
    if ( EventBuffer.EventIndex == 0 ) {

	EventBuffer.EventBuffer = REALLOC( EventBuffer.EventBuffer,
					   (EventBuffer.MaxEvents + EVENT_INCREMENT) * sizeof(INPUT_RECORD));

	if ( !EventBuffer.EventBuffer ) {
	    CleanExit(1, 0);
	}

	memmove( EventBuffer.EventBuffer + EVENT_INCREMENT,
		 EventBuffer.EventBuffer ,
		 EventBuffer.NumberOfEvents * sizeof(INPUT_RECORD) );

	EventBuffer.EventIndex = EVENT_INCREMENT;
    }

    //
    //	Add event
    //
    EventBuffer.EventIndex--;
    EventBuffer.NumberOfEvents++;

    memcpy( EventBuffer.EventBuffer + EventBuffer.EventIndex,
	    InputRecord,
	    sizeof(INPUT_RECORD ));

    LeaveCriticalSection(&(EventBuffer.CriticalSection));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\cmd.c ===
/*** cmd.c - handle simple keyboard interactions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"



#define DEBFLAG CMD

struct cmdDesc	cmdUnassigned = {   "unassigned",   unassigned,     0, FALSE };

/*** unassigned - function assigned to unassigned keystrokes
*
*  display an informative message about the unassigned key
*
* Input:
*  Standard editing function
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
unassigned (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {
    buffer buf;

    CodeToName ( (WORD)argData, buf);
    if (buf[0]) {
        printerror ("%s is not assigned to any editor function",buf);
    }

    return FALSE;

    pArg; fMeta;
}



/*** confirm - ask our dear user a yes/no question
*
* Purpose:
*  Asks the user a yes/no question, and gets his single character response. If
*  in a macro, the reponse may also come from the macro stream, or from the
*  passed "if in a macro" default response.
*
* Input:
*  fmtstr	= prompt format string
*  arg		= prompt format parameters
*
* Output:
*  TRUE if 'y', else FALSE.
*
*************************************************************************/
flagType
confirm (
    char *fmtstr,
    char *arg
    ) {
    return (flagType)(askuser ('n', 'y', fmtstr, arg) == 'y');
}


/*** askuser - ask our dear user a question
*
* Purpose:
*  Asks the user a question, and gets his single character response. If in
*  a macro, the reponse may also come from the macro stream, or from the
*  passed "if in a macro" default response.
*
* Input:
*  defans	= default answer for non-alpha responses
*  defmac	= default answer if executing in a macro and no "<" is present
*  fmtstr	= prompt format string
*  arg		= prompt format parameters
*
* Output:
*   the lowercase character response.  If the user presses <cancel>, the
*   integer -1 is returned.
*
*************************************************************************/
int
askuser (
    int defans,
    int defmac,
    char *fmtstr,
    char *arg
    ) {
    int c;
    int x;
    PCMD  pcmd;

    switch (c = fMacResponse()) {
    case 0:
        if ((c = defmac) == 0) {
            goto askanyway;
        }
        break;

    default:
        break;

    case -1:
    askanyway:
	DoDisplay ();
	consoleMoveTo( YSIZE, x = domessage (fmtstr, arg));
	c = (int)((pcmd = ReadCmd())->arg & 0xff);
	SETFLAG (fDisplay,RCURSOR);
        if ((PVOID)pcmd->func == (PVOID)cancel) {
	    sout (x, YSIZE, "cancelled", infColor);
	    return -1;
        } else {
            if (!isalpha (c)) {
                c = defans;
            }
	    vout (x, YSIZE, (char *)&c, 1, infColor);
        }
	break;
    }
    return tolower(c);
}


/*** FlushInput - remove all typeahead.
*
*  FlushInput is called when some action invalidates all input.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
FlushInput (
    void
    ) {
    register BOOL MoreInput;
    while (MoreInput = TypeAhead()) {
        ReadCmd ();
    }
}

/*** fSaveDirtyFile - Prompt the user to save or lose dirty files
*
* Purpose:
*
*   Called just before exit to give the user control over soon-to-be-lost
*   editing changes.
*
* Input: None.
*
* Output:
*
*   Returns TRUE if the user wants to exit, FALSE if not.
*
*************************************************************************/
flagType
fSaveDirtyFiles (
    void
    ) {

    REGISTER PFILE pFile;
    int cDirtyFiles = 0;
    flagType fAgain;
    buffer buf;

    assert (_pfilechk());
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
            if (++cDirtyFiles == 2) {
                do {
                    fAgain = FALSE;
                    switch (askuser (-1, -1, GetMsg (MSG_SAVEALL, buf), NULL)) {
                        case 'y':
                            SaveAllFiles ();
                            return TRUE;

                        case 'n':
                            break;

                        case -1:
                            return FALSE;

                        default:
                            fAgain = TRUE;
                    }
                } while (fAgain);
            }

            do {
                fAgain = FALSE;
                switch (askuser (-1, -1, GetMsg (MSG_SAVEONE, buf), pFile->pName)) {
                    case 'y':
                        FileWrite (pFile->pName, pFile);

                    case 'n':
                        break;

                    case -1:
                        return FALSE;

                    default:
                        fAgain = TRUE;
                }
            } while (fAgain);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\dline.c ===
/*** dline.c - return one display line
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


/*** fInRange - return true if the arguments are in order
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
fInRange (
    long a,
    long x,
    long b
    ) {
    return (flagType) (((a <= x) && (x <= b)) || ((a >= x) && (x >= b)));
}



/*
 * Characters used in window borders
 */

#define DHBAR	((char)0xCD)
#define DVBAR	((char)0xBA)
#define DLTEE	((char)0xB9)
#define DUTEE	((char)0xCA)
#define DRTEE	((char)0xCC)
#define DDTEE	((char)0xCB)
#define DCRSS	((char)0xCE)

/*** DisplayLine - Get's the i'th display line of a window
*
*  Gets exactly what needs to be shown in the i'th line of the screen.
*  This takes care of showing trailing spaces, drawing borders, etc...
*
* Input:
*  yScrLine	- Get i'th line showing in the window
*  pchScrLine	- pointer to line buffer where the screen line is to be put
*  pplaScrLine	- pointer to pointer to place to put color info
*  pchFileLine	- pointer to line buffer
*  pplaFileLine - pointer to pointer to place to put color info
*
* Note:
*  If there is only one window on the screen then we only need one line
*  buffer and one color buffer. DoText should have taken care of this so
*  pchFileLine and *pplaFileLine should be both NULL.
*
* Output:
*  Returns Length of string in pchScrLine
*
****************************************************************************/
int
DisplayLine (
    int               yScrLine,
    char             *pchScrLine,
    struct lineAttr **pplaScrLine,
    char             *pchFileLine,
    struct lineAttr **pplaFileLine
    ) {

    int 	     iWnd;
    REGISTER PWND    pWnd;
    PINS	     pIns;
    PFILE	     pFile;

    int 	     cch;
    REGISTER char   *pch;

    /*
     * one window, speed hack:
     *
     * if there is only one window, just grab the line, append any trailing
     * space display, move the applicable portion of the line to the head of
     * the buffer, space fill out to the window width, and get the color info
     * for the line.
     */
    if (cWin == 1) {

	/*
	 * we always get the detab'ed (non-RAW) line for displaying.
	 */
	cch = gettextline (FALSE,
			   yScrLine + YWIN(pInsCur),
			   pchScrLine,
			   pFileHead,
			   tabDisp);
	ShowTrailDisp (pchScrLine, cch);

	/*
	 * Scroll left to match instance
	 */
	if (XWIN(pInsCur)) {
	    cch = max (0, min (cch - XWIN(pInsCur), XSIZE));
	    memmove( pchScrLine, (pchScrLine + XWIN(pInsCur)), cch );
        } else {
            cch = min (cch, XSIZE);
        }

	/*
	 * Pad end of line with blanks
	 */
        if (cch < XSIZE) {
	    memset ((char *) pchScrLine + cch, ' ', XSIZE - cch);
        }
	pchScrLine[XSIZE] = 0;

	/*
	 * Get color and hiliting info from the file
	 * (UpdHilite takes care of left scroll)
	 */
	GetColorUntabbed ((LINE)(yScrLine + YWIN(pInsCur)), *pplaScrLine, pFileHead);
	UpdHiLite (pFileHead,
		   (LINE) (yScrLine + YWIN(pInsCur)),
		   XWIN(pInsCur),
		   XWIN(pInsCur) + XSIZE - 1,
		   pplaScrLine);
	return XSIZE;
    }

    /*
     * Multiple windows
     *
     * initially set up the line to be all dashes (horizontal screen split)
     * with window borders color
     */
    memset ((char *) (pchScrLine), DHBAR, XSIZE);
    pchScrLine[XSIZE] = 0;
    (*pplaScrLine)->len   = 0xff;
    (*pplaScrLine)->attr  = WDCOLOR;

    /*
     * for each active window
     */
    for (iWnd = 0, pWnd = WinList; iWnd < cWin; iWnd++, pWnd++) {
	/*
	 * if the display line is in the window
	 */
	if (fInRange ((long) WINYPOS(pWnd),
		      (long) yScrLine,
		      (long) (WINYPOS(pWnd) + WINYSIZE(pWnd) - 1))) {
	    /*
	     * Do window on right
	     */
            if (WINXPOS(pWnd)) {
		switch (*(pch = pchScrLine + WINXPOS(pWnd) - 1) & 0xFF) {
		    case DHBAR:
			*pch = DLTEE;
			break;
		    case DRTEE:
			*pch = DVBAR;
			break;
		    case DUTEE:
			*pch = DLTEE;
			break;
		    case DCRSS:
			*pch = DLTEE;
			break;
                }
            }
	    /*
	     * blank the window
	     */
	    memset ((char *) pchScrLine + WINXPOS(pWnd), ' ', WINXSIZE(pWnd));
	    UpdOneHiLite (*pplaScrLine,
			  WINXPOS(pWnd),
			  WINXSIZE(pWnd),
			  TRUE,
			  FGCOLOR);

	    /*
	     * retrieve the window instance and current file
	     */
	    pIns = pWnd->pInstance;
	    pFile = pIns->pFile;

	    /*
	     * get the correct line from the file
	     */
	    cch = gettextline (FALSE,
			       (LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			       pchFileLine,
			       pFile,
			       tabDisp);
	    ShowTrailDisp (pchFileLine, cch);

	    /*
	     * if line is visible
	     */
	    if (cch >= XWIN (pIns)) {

		/*
		 * move the visible portion of the line into the buffer
		 */
		memmove((char*)( pchScrLine + WINXPOS( pWnd )),
			(char*)( pchFileLine + XWIN( pIns )),
			min (cch-XWIN(pIns), WINXSIZE(pWnd)));

		/*
		 * Get color and hiliting info from the file
		 * (UpdHilite takes care of left scroll)
		 */
		GetColorUntabbed ((LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			  *pplaFileLine,
			  pFile);
		UpdHiLite (pFile,
			   (LINE) (yScrLine - WINYPOS(pWnd) + YWIN(pIns)),
			   XWIN(pIns),
			   XWIN(pIns) + WINXSIZE(pWnd) - 1,
			   pplaFileLine);

		/*
		 * Put it in the screen buffer
		 */
		UpdOneHiLite (*pplaScrLine,
			      WINXPOS(pWnd),
			      WINXSIZE(pWnd),
			      FALSE,
			      (INT_PTR) *pplaFileLine);
            }
	    /*
	     * do window left
	     */
	    switch (*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF) {
		case DHBAR:
		    *pch = DRTEE;
		    break;
		case DLTEE:
		    *pch = DVBAR;
		    break;
		case DCRSS:
		    *pch = DRTEE;
		    break;
            }
        } else {
            /*
             * test for break immediately above
             */
            if (WINYPOS(pWnd) + WINYSIZE(pWnd) == yScrLine) {
                switch (*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF) {
                    case DHBAR:
                        *pch = DUTEE;
                        break;
                    case DDTEE:
                        *pch = DCRSS;
                        break;
                }
            } else {
                /*
                 * test for break immediately below
                 */
                if (WINYPOS(pWnd)-1 == yScrLine) {
                    switch (*(pch = pchScrLine + WINXPOS(pWnd) + WINXSIZE(pWnd)) & 0xFF) {
                        case DHBAR:
                            *pch = DDTEE;
                            break;
                        case DUTEE:
                            *pch = DCRSS;
                            break;
                    }
                }
            }
        }
    }
    pchScrLine[XSIZE] = 0;
    return XSIZE;
}



/*** SetTrailDisp - set character displayed for trailing spaces.
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
SetTrailDisp (
    char * val
    ) {
    buffer locval;

    strcpy ((char *) locval, val);

    trailDisp = (char) atoi (locval);

    newscreen ();
    return TRUE;
}



/*** ShowTrailDisp
*
* Input:
*
* Output:
*
*************************************************************************/
void
ShowTrailDisp (
    buffer buf,
    int len
    ) {
    REGISTER char * p;

    if (trailDisp) {
        p = &buf[len];
        while (p > buf && p[-1] == ' ') {
            *--p = trailDisp;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\delete.c ===
/*  sdelete.c - stream delete of characters
 *
 *  Modifications:
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "mep.h"


flagType
delete (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {
    switch (pArg->argType) {
	case BOXARG:
	case LINEARG:
	    ldelete (argType, pArg, fMeta);
	    break;

	default:
	    sdelete (argType, pArg, fMeta);
	    break;
    }
    return TRUE;
}



flagType
sdelete (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {

    fl  fl;

    switch (pArg->argType) {

    case NOARG:
	/* reduce line by one character.  No length overflow is possible */
	DelBox (pFileHead, XCUR (pInsCur), YCUR (pInsCur), XCUR (pInsCur), YCUR (pInsCur));
        return TRUE;

    /*	TEXTARG illegal 	    */
    case NULLARG:
        if (!fMeta) {
	    pick (pArg->arg.nullarg.x, pArg->arg.nullarg.y,
                  0, pArg->arg.nullarg.y+1, STREAMARG);
        }
	DelStream (pFileHead, pArg->arg.nullarg.x, pArg->arg.nullarg.y,
                   0, pArg->arg.nullarg.y+1);
        return TRUE;

    case LINEARG:
    case BOXARG:
	BoxToStream (pArg);

    case STREAMARG:
        if (!fMeta) {
	    pick (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
                  pArg->arg.streamarg.xEnd,   pArg->arg.streamarg.yEnd, STREAMARG);
        }
	DelStream (pFileHead,
		   pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		   pArg->arg.streamarg.xEnd, pArg->arg.streamarg.yEnd);
	fl.col = pArg->arg.streamarg.xStart;
	fl.lin = pArg->arg.streamarg.yStart;
	cursorfl (fl);
	return TRUE;
    }

    return FALSE;

    argType;
}



/*** BoxToStream - Convert a box/line arg to a stream arg
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
BoxToStream (
    ARG * pArg
    ) {

    ARG arg;

    arg = *pArg;

    pArg->argType = STREAMARG;

    if (arg.argType == LINEARG) {
        pArg->arg.streamarg.yStart = arg.arg.linearg.yStart;
        pArg->arg.streamarg.yEnd   = arg.arg.linearg.yEnd;
        pArg->arg.streamarg.xStart = pArg->arg.streamarg.xEnd = flArg.col;
    } else {
        pArg->arg.streamarg.yStart = arg.arg.boxarg.yTop;
        pArg->arg.streamarg.yEnd   = arg.arg.boxarg.yBottom;

        if ((flArg.lin == arg.arg.boxarg.yTop    &&
             flArg.col == arg.arg.boxarg.xLeft)   ||
            (flArg.lin == arg.arg.boxarg.yBottom  &&
             flArg.col == arg.arg.boxarg.xRight + 1)) {
            pArg->arg.streamarg.xStart = arg.arg.boxarg.xLeft;
            pArg->arg.streamarg.xEnd   = arg.arg.boxarg.xRight + 1;
        } else {
            pArg->arg.streamarg.xStart = arg.arg.boxarg.xRight + 1;
            pArg->arg.streamarg.xEnd   = arg.arg.boxarg.xLeft;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\compile.c ===
/*** compile.c - perform asynch compile
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


static char    szFencePost[]   = "+++   M ";
static LINE    yComp	       = 0;   /* last line viewed in compile log */

/*** compile - <compile> editor function
*
*  Implements the <compile> editor function:
*	compile 		= display compile status
*	arg compile		= compile using command based on file extension
*	arg text compile	= compile using command associated with text
*	arg arg text compile	= compile using "text" as command
*	[arg] arg meta compile	= Kill current background compile
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if compile succesfully started or queued.
*
*************************************************************************/
flagType
compile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
) {
    static char szStatus[]	= "no compile in progress";
    
    buffer	pCmdBuf;		    /* compile command to execute   */
    buffer	pFileBuf;		    /* current filename.ext	    */
    buffer	pMsgBuf;

    int 	rc;			    /* Used to pick up return codes */


    switch (pArg->argType) {
    
        case NOARG:

	    domessage (fBusy(pBTDComp) ? szStatus+3 : szStatus);
	    return (flagType) (fBusy(pBTDComp));
    
        case NULLARG:

            if (fMeta) {
                return (flagType) BTKill (pBTDComp);
            }

	    /*
	     * no text was entered, we use default settings according to filename
	     * or extension. Form filename.ext in pFileBuf, get filename extension
	     * into pCmdBuf, and append .obj for the suffix rule.
	     */
	    fileext (pFileHead->pName, pFileBuf);
	    extention (pFileBuf, pCmdBuf);

	    /*
	     * if we don't find a command specifically for this file, or a
	     * command for this suffix rule, trying both DEBUG and non-debug
	     * in both cases, print error and return.
	     */
	    if (!(fGetMake (MAKE_FILE, (char *)pMsgBuf, (char *)pFileBuf))) {
            //if (!(fGetMake (MAKE_SUFFIX, (char *)pMsgBuf, (char *)pCmdBuf))) {
                strcat (pCmdBuf, ".obj");
                if (!(fGetMake (MAKE_SUFFIX, (char *)pMsgBuf, (char *)pCmdBuf))) {
                    return disperr (MSGERR_CMPCMD2, pFileBuf);
                }
            //}
        }

	    /*
	     * pMsgBuf has the user specified compile command, pFileBuf has
	     * the filename. sprintf them together into pCmdBuf.
	     */
	    UnDoubleSlashes (pMsgBuf);
            if ( (rc = sprintf (pCmdBuf, pMsgBuf, pFileBuf)) == 0) {
                return disperr (rc, pMsgBuf);
            }
	    break;
    
        case TEXTARG:
	   /*
	    * text was entered. If 1 arg, use the command associated with "text",
	    * else use the text itself.
	    */
	    strcpy ((char *) buf, pArg->arg.textarg.pText);
	    if (pArg->arg.textarg.cArg == 1) {
		if (!fGetMake (MAKE_TOOL, (char *)pMsgBuf, (char *)"text")) {
                    return disperr (MSGERR_CMPCMD);
                }
		UnDoubleSlashes (pMsgBuf);
                if (rc = sprintf (pCmdBuf, pMsgBuf, buf)) {
                    return disperr (rc, pMsgBuf);
                }
            } else {
                strcpy (pCmdBuf, buf);
            }
	    break;
    
        default:
	    assert (FALSE);
    }
    /*
     * At this point, pCmdBuf has the formatted command we are to exec off, and
     * pFileBuf has the filename.ext of the current file. (pMsgBuf is free)
     */

    AutoSave ();
    Display ();

    /*
     * If there's no activity underway and the log file is not empty and
     * the user wants to flush it: Let's flush !
     */
    if (   !fBusy(pBTDComp)
	&& (pBTDComp->pBTFile)
	&& (pBTDComp->pBTFile->cLines)
	&& (confirm ("Delete current contents of compile log ? ", NULL))
	   ) {
	DelFile (pBTDComp->pBTFile, FALSE);
	yComp = 0;
    }

    /*
     * The log file will be updated dynamically
     */
    UpdLog(pBTDComp);

    /*
     * Send jobs
     */
    if (pBTDComp->cBTQ > MAXBTQ-2) {
        return disperr (MSGERR_CMPFULL);
    }

    if ( BTAdd (pBTDComp, (PFUNCTION)DoFence, pCmdBuf)
        && BTAdd (pBTDComp, NULL,    pCmdBuf)) {
	return dispmsg (MSG_QUEUED, pCmdBuf);
    } else {
        return disperr (MSGERR_CMPCANT);
    }

    argData;
}
    

/*** nextmsg - <nextmsg> editor function
*
*  Implements the <nextmsg> editor function:
*	nextmsg 		= move to next compile error within "pasture"
*	arg numarg nextmsg	= move to "nth" next compile error within the
*				  pasture, where "n" may be a signed long.
*	arg nextmsg		= move to next compile error within the pasture
*				  that does not refer to current file
*	meta nextmsg		= jump the fence into the next pasture.
*				  Discard previous pasture.
*	arg arg nextmsg 	= if current file is compile log, then set
*				  the current location for next error to the
*				  current line in the log. If the file is NOT
*				  the compile log, and it is visible in a
*				  window, change focus to that window. If the
*				  file is NOT visible, then split the current
*				  window to make it visible. If we cannot
*				  split, then do nothing.
*
*  Attempt to display the next error message from the compile. Also make
*  sure that if being displayed, the <compile> psuedo file moves with us.
*
* Input:
*  Standard editing function.
*
* Output:
*  Returns TRUE if message read, or function yCompeted. FALSE if no more
*  messages or no log to begin with.
*
*************************************************************************/

struct msgType {
    char    *pattern;
    int     cArgs;
    };

static struct msgType CompileMsg [] =
{   {	"%s %ld %d:",	    3	    },	    /* Zibo grep		     */
    {	"%[^( ](%ld,%d):",  3	    },	    /* new masm 		     */
    {	"%[^( ](%ld):",     2	    },	    /* cmerge/masm		     */
    {	"%[^: ]:%ld:",	    2	    },	    /* bogus unix GREP		     */
    {	"\"%[^\" ]\", line %ld:", 2 },	    /* random unix CC		     */
    {	NULL,		    0	 }  };

flagType
nextmsg (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    FILEHANDLE  fh;                    /* handle for locating file         */
    flagType	fHopping   = FALSE;	/* TRUE = hopping the fence	    */
    pathbuf	filebuf;		/* filename from error message	    */
    fl		flErr;			/* location of error		    */
    flagType	fLook;			/* look at this error message?	    */
    int 	i;			/* everyone's favorite index        */
    LINE	oMsgNext    = 1;	/* relative message number desired  */
    char	*p;			/* temp pointer 		    */
    char	*pText; 		/* pointer into text buffer	    */
    rn		rnCur;			/* range highlighted in log	    */
    pathbuf	tempbuf;		/* text arg buffer		    */
    linebuf	textbuf;		/* text arg buffer		    */
    
    /*
     * if there's no log, there's no work.
     */
    if (!PFILECOMP || !PFILECOMP->cLines) {
        return FALSE;
    }
    
    switch (pArg->argType) {
    
        case NULLARG:
            /*
             * arg arg: if current file is <compile>, set yComp to current position
             * therein & get next message. If more than one window, move to the next
             * window in the system before doing that.
             */
            if (pArg->arg.nullarg.cArg >= 2) {
		if (pFileHead == PFILECOMP) {
		    yComp = lmax (YCUR(pInsCur) - 1, 0L);
                    if (cWin > 1) {
                        pArg->argType = NOARG;
                        window (0, pArg, FALSE);
                    }
                    break;
                }
                /*
                 * If the file is visible, the we can just make it current, adn we're done.
                 */
		else for (i=cWin; i; ) {
		    pInsCur = WININST(&WinList[--i]);
		    if (pInsCur->pFile == PFILECOMP) {
                        SetWinCur (i);
			return TRUE;
                    }
                }
                /*
                 * The file is not visible, see if we can split the window and go to it.
                 */
		if ((WINYSIZE(pWinCur) > 20) && (cWin < MAXWIN)) {
		    if (SplitWnd (pWinCur, FALSE, WINYSIZE(pWinCur) / 2)) {
			newscreen ();
			SETFLAG (fDisplay, RCURSOR|RSTATUS);
                        SetWinCur (cWin-1);
			fChangeFile (FALSE, rgchComp);
			flErr.lin = 0;
			flErr.col = 0;
			cursorfl (flErr);
			return TRUE;
                    }
                }
		return FALSE;
            }
            /*
             * Null arg: get the first line of the next file. That is signified by the
             * special case offset of 0.
             */
            else {
                oMsgNext = 0;
            }

        case NOARG:
            /*
             * meta: hop to next fence. Begin deleting lines util a fence is reached, or
             * until there are no more lines. Set up to then read the next message line.
             */
            if (fMeta) {
                do {
		    DelLine (FALSE, PFILECOMP, 0L, 0L);
		    GetLine (0L, textbuf, PFILECOMP);
                } while (strncmp (textbuf, szFencePost, sizeof(szFencePost)-1)
                   && PFILECOMP->cLines);
                yComp = 0;
            }
            /*
             * No arg: we just get the next line (offset = 1)
             */
	    break;
        
        case TEXTARG:
            /*
             * text arg is an absolute or relative message number. If it is absolute, (no
             * leading plus or minus sign), we reset yComp to 0 to get the n'th line
             * from the begining of the log.
             */
	    strcpy ((char *)textbuf, pArg->arg.textarg.pText);
            pText = textbuf;
            if (*pText == '+') {
                pText++;
            }
            if (!fIsNum (pText)) {
                return BadArg ();
            }
            if (isdigit(textbuf[0])) {
                yComp = 0;
            }
            oMsgNext = atol (pText);
            break;
        
        default:
    	    assert (FALSE);
    }
    /*
     * Ensure that the compile log file has no highlighting.
     */

    ClearHiLite (PFILECOMP, TRUE);

    /*
     * This loop gets executed once per line in the file as we pass over them. We
     * break out of the loop when the desired error line is found, or we run out
     * of messages
     *
     * Entry:
     *  yComp    = line # previously viewed. (0 if no messages viewed yet)
     *  oMsgNext = relative message number we want to view, or 0, indicating
     *             first message of next file.
     */
    while (TRUE) {
        /*
         * Move to check next line.
         */
        if (oMsgNext >= 0) {
    	    yComp++;
        } else if (oMsgNext < 0) {
            yComp--;
        }
        /*
         * read current line from the log file & check for fences & end of file. If
         * we encounter a fence or off the end, declare that there are no more
         * messages in this pasture.
         */

	NoUpdLog(pBTDComp);

	GetLine (lmax (yComp,1L), textbuf, PFILECOMP);
	if (   (yComp <= 0L)
	    || (yComp > PFILECOMP->cLines)
	    || !strncmp (textbuf, szFencePost, sizeof(szFencePost)-1)
	   ) {
	    UpdLog(pBTDComp);
            if (!fBusy(pBTDComp) || (yComp <= 0L)) {
                yComp = 0;
            }
            domessage ("No more compilation messages" );
            return FALSE;
        }
        /*
         * Attempt to isolate file, row, column from the line.
         */
        for (i = 0; CompileMsg[i].pattern != NULL; i++) {
            flErr.lin = 0;
            flErr.col = 0;
            if (sscanf (textbuf, CompileMsg[i].pattern, filebuf, &flErr.lin,
                    &flErr.col) == CompileMsg[i].cArgs) {
                break;
            }
        }
        /*
         * If A validly formatted line was found, and we can find a message (After :)
         * then skip spaces prior to the error message (pointed to by p), pretty up
         * the file, convert it to canonicalized form
         */
        if (   CompileMsg[i].pattern 
            && (*(p = strbscan (textbuf+strlen(filebuf), ":"))) 
           ) {
	    p = whiteskip (p+1);
            if (filebuf[0] != '<') {
		rootpath (filebuf, tempbuf);
            } else {
                strcpy (tempbuf, filebuf);
            }
            /*
             * Adjust the error message counter such that we'll display the "nth" message
             * we encounter. Set flag to indicate whether we should look at this
             * error message.
             */
	    fLook = FALSE;
	    if (oMsgNext > 0) {
                if (!--oMsgNext) {
                    fLook = TRUE;
                }
            } else if (oMsgNext < 0) {
                if (!++oMsgNext) {
                    fLook = TRUE;
                }
            } else {
                fLook = (flagType) _strcmpi (pFileHead->pName, tempbuf);
            }
    
	    if (fLook) {
                /*
                 * if about to change to new file, check for existance first, and if found,
                 * autosave our current file.
                 */
                if (_strcmpi(pFileHead->pName, tempbuf)) {
                    fh = MepFOpen(tempbuf, ACCESSMODE_READ, SHAREMODE_RW, FALSE);
                    if (fh == NULL) {
                        return disperr (MSGERR_CMPSRC, tempbuf);
                    }
                    MepFClose (fh);
		    AutoSave ();
                }
                /*
                 * Change the current file to that listed in the error message. If successfull,
                 * then also change our cursor location to that of the error.
                 */
		if (filebuf[0] != 0) {
                    if (!fChangeFile (FALSE, strcpy (buf, tempbuf))) {
                        return FALSE;
                    }
		    if (flErr.lin--) {
                        if (flErr.col) {
			    flErr.col--;
                        } else {
			    cursorfl (flErr);
			    flErr.col = dobol ();
                        }
			cursorfl (flErr);
                    }
                }
                /*
                 * Update the contents of the compile log, if it happens to be displayed.
                 */
		rnCur.flLast.lin = rnCur.flFirst.lin = lmax (yComp,0L);
		rnCur.flFirst.col = 0;
		rnCur.flLast.col = sizeof(linebuf);
		SetHiLite (PFILECOMP, rnCur, HGCOLOR);
		UpdateIf (PFILECOMP, lmax (yComp,0L), FALSE);
                /*
                 * Place the actual error message text on the dialog line.
                 */
                if ((int)strlen(p) >= XSIZE) {
                    p[XSIZE] = '\0';
                }
		domessage( "%s", p );
		return TRUE;
            }
        }
    }

    argData;
}


/*** DoFence - Build Fence message line & put it in the log file
*
*  Builds the line output to the compile log which seperates succesive
*  compiles and puts it into the log file.
*
*  "+++ PWB Compile: [drive:pathname] command"
*
* Input:
*  pCmd 	= ptr to command to execute (Series of null terminated strings)
*
* Output:
*  Returns nothing
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

void
DoFence (
    char *pCmd,
    flagType fKilled
    ) {
    linebuf pFenceBuf;

    if (!fKilled) {
	AppFile (BuildFence ("Compile", pCmd, pFenceBuf), pBTDComp->pBTFile);
	UpdateIf (pBTDComp->pBTFile, pBTDComp->pBTFile->cLines - 1, FALSE);
    }
}


// #pragma check_stack ()


/*** BuildFence - Build Fence message line
*
*  Builds the line output to the compile log which seperates succesive
*  compiles.
*
*  "+++ PWB Compile: [drive:pathname] command"
*
* Input:
*  pFunction	= pointer to function name being dealt with
*  pCmd 	= ptr to command to execute (Series of null terminated strings)
*  pFenceBuf	= ptr to buffer in wich to put constructed fence
*
* Output:
*  Returns nothing
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

char *
BuildFence (
    char const *pFunction,
    char const *pCmd,
    char       *pFenceBuf
    ) {
    strcpy (pFenceBuf, szFencePost);
    strcat (pFenceBuf, pFunction);
    strcat (pFenceBuf, ": [");
    GetCurPath (strend (pFenceBuf));
    strcat (pFenceBuf, "] ");
    strcat (pFenceBuf, pCmd);
    return (pFenceBuf);
}

// #pragma check_stack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\display.c ===
/*** display.c - display the current file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#define INCL_SUB
#define INCL_MESSAGES

#include "mep.h"
#include <stdarg.h>
#include "keyboard.h"

#define DEBFLAG DISP



/*** Display & DoDisplay - update the physical display
*
*  We examine all the hints left around for us by the editing and attempt to
*  make a minimal set of changes to the screen. We will do this until one of
*  the following conditions exist:
*
*   - the screen is completely updated
*   - there is a keystroke waiting for us
*
*  When one occurs, we return.
*
*  The hints that are left around are as follows:
*
*   fDisplay is a bit field indicating what part of the general display needs
*   to be updated. The fields (and the corresponding areas) are:
*
*	RTEXT	    the window on the file(s)
*	RSTATUS     the status line on the bottom of the screen
*	RCURSOR     the cursor
*	RHIGH	    the region [xhlStart,yhlStart] [xhlEnd,yhlEnd] is to be
*		    highlighted on the screen.
*
*  fChange[i] is a bit field for each line of the display indicating how the
*  line might have changed. The fields are:
*
*      FMODIFY	   the line has changed somewhat; ideally, we merely compare
*		       each character in the new line (retrieved with GetLine)
*		       with the one kept in the screen shadow array.
*
*  Display checks first to see if we are in a macro, and returns if we are.
*  DoDisplay does not check.
*
* Input:
*  none, other than various globals mentioned above.
*
* Output:
*  screen updated or key hit (or macro in progress for Display).
*
*************************************************************************/

void
Display (
    void
    ) {
    if (!mtest ()) {
        DoDisplay ();
    }
}



void
DoDisplay (
    void
	) {

    int Row, Col;

    if (pFileHead == NULL) {
        return;
    }

    if (TESTFLAG (fDisplay, RCURSOR)) {

        Row = YCUR(pInsCur) - YWIN(pInsCur) + WINYPOS(pWinCur);
        Col = XCUR(pInsCur) - XWIN(pInsCur) + WINXPOS(pWinCur);

	if ( Row >= YSIZE || Col >= XSIZE ) {
            docursor( XCUR(pInsCur), YCUR(pInsCur) );
        }
    }

	/*
     * If text needs updating, do so. Return immediately if a keystroke was
     * pressed.
	 */
	if (TESTFLAG (fDisplay, RTEXT) && !DoText (0, YSIZE)) {
		return;
    }

	if ((fDisplayCursorLoc && TESTFLAG (fDisplay, RCURSOR)) ||
	    TESTFLAG (fDisplay, RSTATUS)) {
        DoStatus ();
    }

    if (TESTFLAG (fDisplay, RCURSOR)) {

        Row = YCUR(pInsCur) - YWIN(pInsCur) + WINYPOS(pWinCur);
        Col = XCUR(pInsCur) - XWIN(pInsCur) + WINXPOS(pWinCur);

        consoleMoveTo( Row, Col );
		RSETFLAG (fDisplay, RCURSOR);
	}
}


/*** DoText - Update window text
*
* Purpose:
*  Update given window until entirely accurate or until there are      *
*  are keystrokes waiting to be entered.  Use the hints in fDisplay    *
*  and fChange to guide the update.				       *
*
* Input:
*  yLow        0-based beginning line number of display update
*  yHigh       0-based ending line number of display update
*
* Output:
*  Returns TRUE if successfully updated screen					*
*	   FALSE if keystrokes are awaiting					*
*
*************************************************************************/

flagType
DoText (
    int yLow,
    int yHigh
    ) {

	REGISTER int		yCur;
	int 				yMin = -1;
	int 				yMax = 0;

	flagType			fReturn = TRUE;

	struct lineAttr 	*plaFile = NULL;
	struct lineAttr 	*plaScr  = NULL;
	struct lineAttr 	*plaFileLine;
	struct lineAttr 	*plaScrLine;

	char				*pchFileLine = NULL;
	char				pchScrLine[ 2 * sizeof(linebuf) * (1 + sizeof(struct lineAttr))];
	int 				cchScrLine;

	// int				chkpnt = yHigh - yLow > 25 ? 20 : 5;
	int					chkpnt = yHigh - yLow > 25 ? 10 : 3;


	fReDraw = FALSE;

	plaScr = (struct lineAttr *) (pchScrLine + sizeof(linebuf));
    if (cWin > 1) {
		pchFileLine = pchScrLine + sizeof(linebuf) * (1 + sizeof(struct lineAttr));
		plaFile = (struct lineAttr *) (pchFileLine + sizeof(linebuf));
    }

    /*
     * For each line in the window, if the line is marked changed, update it.
     */
	for (yCur = yLow; yCur < yHigh; ) {

		if (TESTFLAG(fChange[yCur], FMODIFY)) {
            if (yMin == -1) {
                yMin = yCur;
            }
			yMax = yCur;

			/*
			 * get and display the line
			 */
			plaScrLine	= plaScr;
			plaFileLine = plaFile;
			cchScrLine = DisplayLine (yCur, pchScrLine, &plaScrLine, pchFileLine, &plaFileLine);
			coutb (0, yCur, pchScrLine, cchScrLine, plaScrLine);

			RSETFLAG(fChange[yCur],FMODIFY);
			/*
			 * if it is time to check, and there is a character waiting, stop
			 * the update process, and go process it
			 */
			if ( (yCur % chkpnt == 0) && TypeAhead() ) {
				fReturn = FALSE;
				break;
			}
		}
		yCur++;
	}

    if (fReturn) {
        RSETFLAG (fDisplay, RTEXT);
	}
	//
	//	Update the screen
	//
    fReDraw = TRUE;
	vout(0,0,NULL,0,0);
	return fReturn;
}



/*** DoStatus - Update the status line
*
* Purpose:
*  Creates and displays the status line on the bottom of the screen.
*
* Input:
*  None, other than the various globals that go into the status line.
*
* Output:
*  Returns status line output
*
*************************************************************************/

#define CINDEX(clr)     (unsigned char) ((&clr-&ColorTab[0])+isaUserMin)

void
DoStatus (
    void
    ) {
    struct lineAttr rglaStatus[10];		/* color array for status line	*/
    int 	    cch;
    int         ilaStatus  = 0;        /* index into color array       */
    int         i;
    char        *pchEndBuf;           /* save for end of buffer       */
    char        buf[512];


    /*
     * Start with filename, and file type
     */
    strcpy (buf, pFileHead->pName);
    strcat (buf, " (");
    strcpy ((char *)strend(buf), GetFileTypeName ());

    /*
     * Add other file characterisctics
     */
    if (!TESTFLAG (FLAGS (pFileHead), DOSFILE)) {
        strcat (buf," NL");
    }

    if (TESTFLAG (FLAGS (pFileHead), TEMP)) {
        strcat (buf, " temp");
    }

    if ((TESTFLAG (FLAGS (pFileHead), READONLY)) | fGlobalRO) {
        strcat (buf, " No-Edit");
    }

    if (TESTFLAG (FLAGS (pFileHead), DISKRO)) {
        strcat (buf, " RO-File");
    }

    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus++].len = (unsigned char) strlen (buf);

    if (TESTFLAG (FLAGS(pFileHead), DIRTY)) {
	strcat (buf, " modified");
	rglaStatus[ilaStatus].attr = CINDEX(errColor);
	rglaStatus[ilaStatus++].len = 9;
    }

    pchEndBuf = strend (buf);
    sprintf (strend(buf), ") Length=%ld ", pFileHead->cLines);

    /*
     * Add current location
     */
    if (fDisplayCursorLoc) {
	sprintf (strend(buf), "Cursor=(%ld,%d)", YCUR(pInsCur)+1, XCUR(pInsCur)+1);
    } else {
        sprintf (strend(buf), "Window=(%ld,%d)", YWIN(pInsCur)+1, XWIN(pInsCur)+1);
    }
    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus++].len = (unsigned char) (strend(buf) - pchEndBuf);

    /*
     * Add global state indicators
     */
    if (fInsert | fMeta | fCtrlc | fMacroRecord) {
	rglaStatus[ilaStatus].attr = CINDEX(infColor);
	rglaStatus[ilaStatus].len = 0;
	if (fInsert) {
	    strcat (buf, " insert");
	    rglaStatus[ilaStatus].len += 7;
        }
	if (fMeta) {
	    strcat (buf, " meta");
	    rglaStatus[ilaStatus].len += 5;
        }
	if (fCtrlc) {
	    strcat (buf, " cancel");
	    rglaStatus[ilaStatus].len += 7;
	    fCtrlc = FALSE;
	    FlushInput ();
        }
	if (fMacroRecord) {
	    strcat (buf, " REC");
	    rglaStatus[ilaStatus].len += 4;
        }
	ilaStatus++;
    }

    rglaStatus[ilaStatus].attr = CINDEX(staColor);
    rglaStatus[ilaStatus].len = 0xff;
	pchEndBuf = buf;

    /*
     * if the net result is too long, eat the first part of the filename with
     * an elipses (Leave room for BC as well).
     */
    cch = strlen(buf) - (XSIZE - 4);

    if (cch > 0) {
		pchEndBuf = buf + cch;
		pchEndBuf[0] = '.';
		pchEndBuf[1] = '.';
		pchEndBuf[2] = '.';

        i = 0;

        while ( cch && i <= ilaStatus  ) {

            if ( (int)rglaStatus[i].len > cch ) {

                rglaStatus[i].len -= (unsigned char)cch;
				cch = 0;

			} else {

                cch -= rglaStatus[i].len;
                rglaStatus[i].len = 0;

			}

            i++;
		}
	}

	fReDraw = FALSE;
    coutb (0, YSIZE+1, pchEndBuf, strlen(pchEndBuf), rglaStatus);

	fReDraw = TRUE;
	voutb (XSIZE-2, YSIZE+1, BTWorking() ? "BP" : "  ", 2, errColor);

	RSETFLAG (fDisplay,  RSTATUS);

}



/*** newscreen - Mark entire screen dirty
*
*  Forces entire screen to be redrawn.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
newscreen (
    void
    ) {

	REGISTER int iLine = YSIZE;

	while (iLine--) {
		SETFLAG ( fChange[iLine], FMODIFY );
	}

	SETFLAG (fDisplay, RTEXT);
}



/*** redraw - Mark a range of lines in file dirty
*
*  Marks a range of lines in a file as needing to be updated. Each window that
*  they occur in is marked.
*
* Input:
*  pFile	     = File handle containing dirty lines
*  linFirst, linLast = Range of lines to mark
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
redraw (
    PFILE pFile,
    LINE  linFirst,
    LINE  linLast
    ) {

    LINE	  linFirstUpd, linLastUpd;
    REGISTER PINS pInsTmp;

    int                         iWinTmp;
    REGISTER struct windowType *pWinTmp;

	if (linFirst > linLast) {
	linFirstUpd = linLast;
	linLast     = linFirst;
	linFirst    = linFirstUpd;
    }

    for (iWinTmp = 0, pWinTmp = WinList; iWinTmp < cWin; iWinTmp++, pWinTmp++) {
        if (pWinTmp->pInstance) {
            if (pFile == pWinTmp->pInstance->pFile) {
                pInsTmp = pWinTmp->pInstance;
                linFirstUpd = WINYPOS(pWinTmp) + lmax (0L, linFirst-YWIN(pInsTmp)-1);
                linLastUpd  = WINYPOS(pWinTmp) + lmin ((long) (WINYSIZE(pWinTmp) - 1), linLast - YWIN(pInsTmp));
                while (linFirstUpd <= linLastUpd) {
                    SETFLAG (fChange[linFirstUpd++],FMODIFY);
                }
            }
        }
    }
	SETFLAG (fDisplay, RTEXT);
}



/*** newwindow - Mark current window dirty
*
*  Mark all lines in the current window as needing to be updated
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
newwindow (
    void
    ) {

    REGISTER int iLine;

	//
    // We ignore the next two assertions, because of a more involved problem of
    // screen size being set up AFTER  instances and window layout have been read
    // in on start up. This means that for a short period of time, these
    // conditions might actually exist. We check for the error and limit the
    // access of the fchange array for now.
    //
    //    assert (MEMSIZE (fChange) >= WINYSIZE (pWinCur));
    //    assert (WINYSIZE (pWinCur) + WINYPOS (pWinCur) <= YSIZE);

    for (iLine = 0; iLine < WINYSIZE (pWinCur); iLine++) {
        if (iLine + WINYPOS(pWinCur) < YSIZE) {
            SETFLAG (fChange[iLine + WINYPOS(pWinCur)],FMODIFY);
        }
    }
	SETFLAG (fDisplay, RTEXT);
}



/*** noise
*
* Input:
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
noise (
    REGISTER LINE lin
    ) {

    char szTinyBuf[10];

    if (lin && cNoise) {
		if ((lin % cNoise) == 0) {
            sprintf (szTinyBuf, " %ld", lin);
			soutb (XSIZE-10, YSIZE+1, szTinyBuf, fgColor);
        }
    }

}



/*** dispmsg - display retrieved message on help/status line
*
*  Places a message on the help/status line. It is removed the next time
*  activity occurrs on that line.
*
*  In the CW version, the resulting (formatted) message is placed in the
*  local heap, and actually displayed by the WndProc for the help window.
*
* Input:
*  iMsg 	= index for message string to be retrieved and displayed.
*		  The string may have embedded printf formatting. If iMsg
*		  is zero, the status line is cleared.
*  ...		= variable number of args per the formatted string
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
__cdecl
dispmsg (
    int     iMsg,
    ...
    ) {

	buffer	fmtstr;				/* retrieved formatting string		*/
    //buffer  textbuf;            /* formatted output line            */
    char    textbuf[ 512 ];
	int 	len;				/* Length of message				*/
    va_list Argument;

    va_start(Argument, iMsg);

    if (fMessUp = (flagType)iMsg) {
		GetMsg (iMsg, fmtstr);
		ZFormat (textbuf, fmtstr, Argument);
		len = strlen(textbuf);
        if (len > (XSIZE-1)) {
			//
			//	message is too long, we will truncate it
			//
            textbuf[XSIZE-1] = '\0';
		}
	} else {
		textbuf[0] = ' ';
		textbuf[1] = '\0';
    }

    fReDraw = TRUE;
    soutb (0, YSIZE, textbuf, infColor);

    va_end(Argument);

    return TRUE;
}



/*** disperr - display error message on status line
*
*  prints a formatted error message on the status line, and then waits for a
*  keystroke. Once hit, the message is cleared.
*
* Input:
*  iMsg 	= index for message string to be retrieved and displayed.
*		  The string may have embedded printf formatting.
*  ...		= variable number of args per the formatted string
*
* Output:
*  returns FALSE
*
*************************************************************************/
flagType
__cdecl
disperr (
    int     iMsg,
    ...
    ) {

    buffer  pszFmt;			/* retrieved formatting string	*/
    buffer  bufLocal;			/* formatted output line	*/
    va_list Arguments;

    assert (iMsg);
    GetMsg (iMsg, pszFmt);

    va_start(Arguments, iMsg);

    ZFormat (bufLocal, pszFmt, Arguments);

    fReDraw = TRUE;
    bell ();
    FlushInput ();
    soutb (0, YSIZE, bufLocal, errColor);
    if (fErrPrompt) {
		asserte (*GetMsg (MSG_PRESS_ANY, bufLocal));
        soutb (XSIZE-strlen(bufLocal)-1, YSIZE, bufLocal, errColor);
        SetEvent( semIdle );
		ReadChar ();
        WaitForSingleObject(semIdle, INFINITE);
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE, bufLocal, errColor);
    } else {
        delay (1);
    }

    va_end(Arguments);

    return FALSE;
}



/*** domessage - display a message on the help-status line
*
*  Places a message on the help/status line. It is removed the next time
*  activity occurrs on that line.
*
*  In the CW version, the resulting (formatted) message is placed in the
*  local heap, and actually displayed by the WndProc for the help window.
*
* Input:
*  pszFmt	- Printf formatting string
*  ...		- variable number of args as per the formatting string
*
* Output:
*  Returns nothing
*
* UNDONE: all calls to domessage should be replaced by calls to dispmsg
*
*************************************************************************/
int
__cdecl
domessage (
    char    *pszFmt,
    ...
	) {


#define NEEDED_SPACE_AFTER_MESSAGE      12

    char    bufLocal[512];
	va_list Arguments;
	int 	Length;
	char   *Msg;

    va_start(Arguments, pszFmt);

    if (fMessUp = (flagType)(pszFmt != NULL)) {
        ZFormat (bufLocal, pszFmt, Arguments);
	} else {
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
    }

    fReDraw = TRUE;

	va_end(Arguments);

	//
	//	We have to make sure that the message is not too long for
	//	this line. If it is, se only display the last portion of it.
	//
	Length = strlen( bufLocal );

	if ( Length > XSIZE - NEEDED_SPACE_AFTER_MESSAGE ) {
		Msg = (char *)bufLocal + (Length - ( XSIZE - NEEDED_SPACE_AFTER_MESSAGE ));
		Length =  XSIZE - NEEDED_SPACE_AFTER_MESSAGE;
	} else {
		Msg = (char *)bufLocal;
	}

	soutb( 0, YSIZE, Msg, infColor );

	return	Length;

}



/*** printerror - print error message on status line
*
*  prints a formatted error message on the status line, and then waits for a
*  keystroke. Once hit, the message is cleared.
*
* Input:
*  printf style parameters
*
* Output:
*  Number of characters output in error message
*
*************************************************************************/
int
__cdecl
printerror (
    char *pszFmt,
    ...
    ) {

    buffer       bufLocal;
    va_list      Arguments;
    REGISTER int cch;

    va_start(Arguments, pszFmt);

    ZFormat (bufLocal, pszFmt, Arguments);

    fReDraw = TRUE;
    bell ();
    FlushInput ();
    cch = soutb (0, YSIZE, bufLocal, errColor);
    if (fErrPrompt) {
		asserte (*GetMsg (MSG_PRESS_ANY, bufLocal));
        soutb (XSIZE-strlen(bufLocal)-1, YSIZE, bufLocal, errColor);
        SetEvent( semIdle );
		ReadChar ();
        WaitForSingleObject(semIdle, INFINITE);
		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE, bufLocal, errColor);
    } else {
        delay (1);
    }

    va_end(Arguments);

    return cch;
}



/*** bell
*
* Input:
*
* Output:
*
*************************************************************************/
void
bell (
    void
    ) {

    printf ("%c", BELL);

}



/*** makedirty
*
*
* Input:
*
* Output:
*
*************************************************************************/
void
makedirty (
    REGISTER PFILE pFileDirty
    ) {
    if (!TESTFLAG(FLAGS(pFileDirty),DIRTY)) {
        if (pFileDirty == pFileHead) {
            SETFLAG (fDisplay, RSTATUS);
        }
	SETFLAG (FLAGS(pFileDirty), DIRTY);
    }
}



/*** delay
*
* Input:
*
* Output:
*
*************************************************************************/
void
delay (
    int cSec
    ) {

    time_t lTimeNow, lTimeThen;

    if (mtest () && !mlast ()) {
        return;
    }
    time (&lTimeThen);
    do {
        if (TypeAhead ()) {
            return;
        }
	Sleep (100);
	time (&lTimeNow);
    } while (lTimeNow - lTimeThen < cSec + 1);
}



/*** SetScreen
*
* Purpose:
*   SetScreen () - Set up the editor's internal structures to match the screen
*   size described by ySize and xSize.	Set the hardware to the mode in
*   Zvideo.
*
* Input:
*
* Output:
*
*************************************************************************/
void
SetScreen (
    void
    ) {
    fChange = ZEROREALLOC (fChange, YSIZE * sizeof (*fChange));
    SETFLAG (fDisplay, RSTATUS);
    if (cWin == 1) {
	WINXSIZE(pWinCur) = XSIZE;
	WINYSIZE(pWinCur) = YSIZE;
    }
    newscreen ();
	// SetVideoState(Zvideo);
}



/*** HighLight
*
*
* Input:
*
* Output:
*
*************************************************************************/
void
HighLight (
    COL  colFirst,
    LINE linFirst,
    COL  colLast,
    LINE linLast
    ) {

    rn	rnCur;

    rnCur.flFirst.lin = linFirst;
    rnCur.flFirst.col = colFirst;
    rnCur.flLast.lin  = linLast;
    rnCur.flLast.col  = colLast;

    SetHiLite (pFileHead, rnCur, INFCOLOR);
}



/*** AdjustLines - change all information relevant to deletion/insertion of
*		   lines in a file.
*
* Purpose:
*  When we are deleting or inserting lines, there is some updating that we
*  need to do to retain some consistency in the user's view of the screen.
*  The updating consists of:
*
*      Adjusting all window instances of this window to prevent "jumping".
*      We enumerate all window instances.  If the top of the window is
*      above or inside the deleted/inserted range, do nothing.	If the top of
*      the window is below the inserted/deleted range, we modify the cursor
*      and window position to prevent the window from moving on the text
*      being viewed.
*
*      Ditto for all flip positions
*
* Input:
*  pFile       file that is being modified
*  lin	       beginning line of modification
*  clin        number of lines being inserted (> 0) or deleted (< 0)
*
* Output:
*
*************************************************************************/
void
AdjustLines (
    PFILE pFile,
    LINE  lin,
    LINE  clin
    ) {

    int 	  iWin;
    REGISTER PINS pInsTmp;

    /* walk all instances looking for one whose pFile matches
     */

    for (iWin = 0; iWin < cWin; iWin++) {
        for (pInsTmp = WININST(WinList + iWin);  pInsTmp != NULL; pInsTmp = pInsTmp->pNext) {
	    if (pInsTmp != pInsCur && pInsTmp->pFile == pFile) {
		/* adjust current position if necessary
		 */
		if (YWIN(pInsTmp) >= lin) {
		    YWIN(pInsTmp) = lmax ((LINE)0, YWIN(pInsTmp) + clin);
		    YCUR(pInsTmp) = lmax ((LINE)0, YCUR(pInsTmp) + clin);
                }
		/* adjust flip position if necessary
		 */
		if (YOLDWIN(pInsTmp) >= lin) {
		    YOLDWIN(pInsTmp) = lmax ((LINE)0, YOLDWIN(pInsTmp) + clin);
		    YOLDCUR(pInsTmp) = lmax ((LINE)0, YOLDCUR(pInsTmp) + clin);
                }
            }
        }
    }
}




/*** UpdateIf - Move the cursor position if a particlar file is displayed
*
*  Used to update the view on windows which are not necessarily the current
*  window. Examples: tying together the compile error log with the current
*  view on the source code.
*
* Input:
*  pFileChg	= pointer to the file whose display is to be updated.
*  yNew 	= New cursor line position.
*  fTop 	= cursor line should be positionned at top/bottom of the window
*
* Output:
*  Returns TRUE if on-screen and updated.
*
*************************************************************************/
flagType
UpdateIf (
    PFILE    pFileChg,
    LINE     linNew,
    flagType fTop
    ) {

    PINS     pInsCur;
    PWND     pWndFound	 = NULL;
    flagType fFound	= FALSE;

    /*
     * If this is the top file, we don't want to do anything
     */
    if (pFileChg == pFileHead) {
        return FALSE;
    }

    /*
     * Walk the window list, and check to see if the top instance (file
     * currently in view) is the one we care about. If so, update its cursor
     * and window position.
     */
    while (pWndFound = IsVispFile (pFileChg, pWndFound)) {
	if (pWndFound != pWinCur) {
	    pInsCur = WININST(pWndFound);
	    YCUR(pInsCur) = linNew;
	    XCUR(pInsCur) = 0;
	    YWIN(pInsCur) = fTop ?
			YCUR(pInsCur) :
			lmax (0L, YCUR(pInsCur) - (WINYSIZE(pWndFound)-1));
	    XWIN(pInsCur) = 0;
	    fFound = TRUE;
        }
    }

    /*
     * If any visible instances of the file were discovered above, redraw the
     * entire file, such that all windows will be updated, regardless of view.
     */
    if (fFound) {
        redraw (pFileChg, 0L, pFileChg->cLines);
    }

    return fFound;
}



/*** IsVispFile - See if pfile is visibke
*
*  Determines if a particular pFile is currently visible to the user, and
*  returns a pointer to the window first found in.
*
* Input:
*  pFile	= pFile of interest
*  pWin 	= pWin to start at, or NULL to start at begining
*
* Output:
*  Returns pWin of first window found, or NULL
*
*************************************************************************/
PWND
IsVispFile (
    PFILE           pFile,
    REGISTER PWND   pWnd
    ) {

    /*
     * If NULL starting pWnd specified, then start at first one.
     */
    if (!pWnd++) {
        pWnd = &WinList[0];
    }

    /*
     * for all remaining windows currently active, check top instance for pFile
     * of interest
     */
    for (; pWnd < &WinList[cWin]; pWnd++) {
        if (WININST(pWnd)->pFile == pFile) {
            return pWnd;
        }
    }
    return NULL;
}





/*** GetMsg - Message Retriever
*
* Purpose:
*  Get an error message from the message segment and copy it to a
*  buffer, returning a pointer to the buffer.
*
* Input:
*  iMsg 	 = Message number to get
*  pchDst	 = pointer to place to put it
*
* Output:
*  returns pDest
*
* Exceptions:
*  None
*
*************************************************************************/
char *
GetMsg (
    unsigned  iMsg,
    char     *pchDst
    ) {

    char *pch;
    WORD   i;

    for (i=0; (MsgStr[i].usMsgNo != (WORD)iMsg) && (MsgStr[i].usMsgNo != 0); i++);
    pch = MsgStr[i].pMsgTxt;

    strcpy ((char *)pchDst, pch);

    return pchDst;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\env.c ===
/*  env.c - manipulate editor environment
 *
 *  Modifications:
 *
 *	26-Nov-1991 mz	Strip off near/far
 *
 */

#include "mep.h"

/*  environment - function to perform environment manipulation
 *
 *  set environment
 *  display environment
 *  perform env substitution
 *
 *  fn	sets environment
 *  meta fn does env substitution
 *
 *  noarg	    sets current line into env
 *  textarg	    sets text into env		    single ? displays env
 *  nullarg	    sets to eol into env
 *  linearg	    sets each line into env
 *  streamarg	    sets each fragment into env
 *  boxarg	    sets each fragment into env
 *
 *  meta noarg	    maps current line
 *  meta textarg    illegal
 *  meta nullarg    maps to eol
 *  meta linearg    maps each line
 *  meta streamarg  maps each fragment
 *  meta boxarg     maps each fragment
 *
 *  argData	keystroke
 *  pArg	definition of arguments
 *  fMeta	TRUE => meta was invoked
 *
 *  Returns:	TRUE if operation was successful
 *		FALSE otherwise
 */

static char *pmltl = "Mapped line %ld too long";



flagType
environment (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ){

    linebuf ebuf, ebuf1;
    LINE l;
    int ol;

    if (!fMeta) {
	/*  Perform environment modifications
	 */
        switch (pArg->argType) {

	case NOARG:
	    GetLine (pArg->arg.noarg.y, ebuf, pFileHead);
            return fSetEnv (ebuf);

	case TEXTARG:
	    strcpy ((char *) ebuf, pArg->arg.textarg.pText);
            return fSetEnv (ebuf);

	case NULLARG:
	    fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, ebuf);
            return fSetEnv (&ebuf[pArg->arg.nullarg.x]);

	case LINEARG:
	    for (l = pArg->arg.linearg.yStart; l <= pArg->arg.linearg.yEnd; l++) {
		GetLine (l, ebuf, pFileHead);
		if (!fSetEnv (ebuf)) {
		    docursor (0, l);
		    return FALSE;
                }
            }
            return TRUE;

	case BOXARG:
	    for (l = pArg->arg.boxarg.yTop; l <= pArg->arg.boxarg.yBottom; l++) {
		fInsSpace (pArg->arg.boxarg.xRight, l, 0, pFileHead, ebuf);
		ebuf[pArg->arg.boxarg.xRight+1] = 0;
		if (!fSetEnv (&ebuf[pArg->arg.boxarg.xLeft])) {
		    docursor (pArg->arg.boxarg.xLeft, l);
		    return FALSE;
                }
            }
            return TRUE;

        }
    } else {
	/*  Perform environment substitutions
	 */
        switch (pArg->argType) {

	case NOARG:
	    GetLine (pArg->arg.noarg.y, ebuf, pFileHead);
	    if (!fMapEnv (ebuf, ebuf, sizeof(ebuf))) {
		printerror (pmltl, pArg->arg.noarg.y+1);
		return FALSE;
            }
	    PutLine (pArg->arg.noarg.y, ebuf, pFileHead);
            return TRUE;

	case TEXTARG:
            return BadArg ();

	case NULLARG:
	    fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, ebuf);
	    if (!fMapEnv (&ebuf[pArg->arg.nullarg.x],
			  &ebuf[pArg->arg.nullarg.x],
			  sizeof(ebuf) - pArg->arg.nullarg.x)) {
		printerror (pmltl, pArg->arg.nullarg.y+1);
		return FALSE;
            }
	    PutLine (pArg->arg.nullarg.y, ebuf, pFileHead);
            return TRUE;

	case LINEARG:
	    for (l = pArg->arg.linearg.yStart; l <= pArg->arg.linearg.yEnd; l++) {
		GetLine (l, ebuf, pFileHead);
		if (!fMapEnv (ebuf, ebuf, sizeof (ebuf))) {
		    printerror (pmltl, l+1);
		    docursor (0, l);
		    return FALSE;
                }
		PutLine (l, ebuf, pFileHead);
            }
            return TRUE;

	case BOXARG:
	    for (l = pArg->arg.boxarg.yTop; l <= pArg->arg.boxarg.yBottom; l++) {
		fInsSpace (pArg->arg.boxarg.xRight, l, 0, pFileHead, ebuf);
		ol = pArg->arg.boxarg.xRight + 1 - pArg->arg.boxarg.xLeft;
		memmove ( ebuf1, &ebuf[pArg->arg.boxarg.xLeft], ol);
		ebuf1[ol] = 0;
		if (!fMapEnv (ebuf1, ebuf1, sizeof (ebuf1)) ||
		    strlen (ebuf1) + strlen (ebuf) - ol >= sizeof (ebuf)) {
		    printerror (pmltl, l+1);
		    docursor (0, l);
		    return FALSE;
                }
		strcat (ebuf1, &ebuf[pArg->arg.boxarg.xRight + 1]);
		strcpy (&ebuf[pArg->arg.boxarg.xLeft], ebuf1);
		PutLine (l, ebuf, pFileHead);
            }
            return TRUE;

        }
    }

    return FALSE;
    argData;
}




/*  fMapEnv - perform environment substitutions
 *
 *  pSrc	character pointer to pattern string
 *  pDst	character pointer to destination buffer
 *  cbDst	amount of space in destination
 *
 *  Returns	TRUE if successful substitution
 *		FALSE if length overflow
 */
flagType
fMapEnv (
    char *pSrc,
    char *pDst,
    int cbDst
    ) {

    buffer tmp;
    char *pTmp, *p, *pEnd, *pEnv;
    int l;

    /*	when we find a $()-surrounded token, we'll null-terminate it using p
     *	and attempt to find it in the environment.  If we find it, we replace
     *	it.  If we don't find it, we drop it out.
     */

    pTmp = tmp;
    pEnd = pTmp + cbDst;

    while (*pSrc  != 0) {
    if (pSrc[0] == '$' && pSrc[1] == '(' && *(p = strbscan (pSrc + 2, ")")) != '\0') {
            *p = '\0';
            //pEnv = getenv(pSrc + 2);
            pEnv = getenvOem(pSrc + 2);
	    *p = ')';
            if (pEnv != NULL) {
                if ((l = strlen (pEnv)) + pTmp > pEnd) {
                    free(pEnv);
		    return FALSE;
                } else {
		    strcpy (pTmp, pEnv);
		    pTmp += l;
                }
                free(pEnv);
            }
	    pSrc = p + 1;
	    continue;
        }
        if (pTmp > pEnd) {
	    return FALSE;
        } else {
            *pTmp++ = *pSrc++;
        }
    }
    *pTmp = '\0';
    strcpy (pDst, tmp);
    return TRUE;
}




/*  fSetEnv - take some text and set it in the environment
 *
 *  We ignore leading/trailing blanks.	"VAR=blah" is done with quotes removed.
 *
 *  p		character pointer to text
 *
 *  returns	TRUE if successfully set
 *		FALSE otherwise
 */
flagType
fSetEnv (
    char *p
    ){
    char *p1;

    p = whiteskip (p);
    RemoveTrailSpace (p);
    /*	Handle quoting
     */
    p1 = strend (p) - 1;

    if (strlen (p) > 2 && *p == '"' && *p1 == '"') {
	p++;
	*p1 = 0;
    }

    if (!strcmp (p, "?")) {
	AutoSave ();
	return fChangeFile (FALSE, "<environment>");
    }

    if ((p = ZMakeStr (p)) == NULL) {
        return FALSE;
    }

//    if (putenv (p)) {
    if (putenvOem (p)) {
        FREE (p);
	return FALSE;
    }

    FREE (p);
    return TRUE;
}




/*  showenv - dump the environment into a file
 *
 *  pFile	file where output goes
 */
void
showenv (
    PFILE pFile
    ){

    int i;

    DelFile (pFile, FALSE);
    for (i = 0; environ[i] != NULL; i++) {
        AppFile (environ[i], pFile);
    }
    RSETFLAG (FLAGS(pFile), DIRTY);
    SETFLAG (FLAGS(pFile), READONLY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\fscan.c ===
/*** fscan.c - iterate a function across all characters in a file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	27-Nov-1991 mz	Strip procedure qualifiers
*
*************************************************************************/
#include "mep.h"

/*** fScan - Apply (*pevent)() until it returns TRUE
*
*  Starting one character to the right of (x, y) (left for !fFor), move
*  through the file forward (backward for !fFor) and call pevent on each
*  character. Also call once at the end of each line on the '\0' character.
*
* Input:
*  flStart	- location in pFileHead at which to start scan
*  pevent	- function to call for done signal
*  fFor 	- TRUE means go forward through file, FALSE backwards
*  fWrap	- TRUE means wrap around the ends of the file, ending at the
*		  starting position. The range to be scanned (defined below)
*		  must include the appropriate start/end of the file.
*
* Globals:
*  rnScan	- Region to confine scan to.
*
*  Returns TRUE if pevent returned true for some file position FALSE if we
*  ran out of scanning region first.
*
*  During the life of fScan, the following globals are valid, and maybe
*  used by pevent:
*
*      flScan	    - Position in file pevent should look at.
*      scanbuf	    - Contents of line to be looking at.
*      scanreal     - Un-Detabbed version of same.
*      scanlen	    - Number of characters in scanbuf.
*
*  The line in scanbuf is detabbed, howver the pevent routine is called once
*  per physical character, if fRealTabs is true.
*
*************************************************************************/
flagType
fScan (
    fl      flStart,
    flagType (*pevent) (void),
    flagType fFor,
    flagType fWrap
    ) {

    LINE    yLim;                           /* limitting line for scanning  */

    flScan = flStart;

    if (!fFor) {
        /*
         * backwards scan.
         *
         * dec current column. If it steps outside of rnScan, then back up a line, and
         * set the column to the right hand column.
         */
        if (--flScan.col < rnScan.flFirst.col) {
            flScan.lin--;
            flScan.col = rnScan.flLast.col;
        }
        /*
         * While we are within the line range of rnScan, check for CTRL-C aborts, and
         * get each line.
         */
        yLim = rnScan.flFirst.lin;
        while (flScan.lin >= yLim) {
            if (fCtrlc) {
                return (flagType)!DoCancel();
            }
            scanlen = GetLine (flScan.lin, scanreal, pFileHead) ;
            scanlen = Untab (fileTab, scanreal, scanlen, scanbuf, ' ');
            /*
             * ensure that the scan column position is within range, and then for every
             * column in the rane of the current line, call the pevent routine
             */
            flScan.col = min ( (  flScan.col < 0
                                ? rnScan.flLast.col
                                : flScan.col)
                              , scanlen);

            while (flScan.col >= rnScan.flFirst.col) {
                if ((*pevent)()) {
                    return TRUE;
                }
                if (fRealTabs) {
                    flScan.col = colPhys (scanreal, (pLog (scanreal, flScan.col, TRUE) - 1));
                } else {
                    flScan.col--;
                }
            }
            /*
             * display status to user. If we just scanned to begining of file, and we are
             * to wrap, then set the new stop limit as the old start position, and set the
             * next line to be scanned as the last in the file.
             */
            noise (flScan.lin--);
            if ((flScan.lin < 0) && fWrap) {
                yLim = flStart.lin;
                flScan.lin = pFileHead->cLines - 1;
            }
        }
    } else {
        /*
         * forwards scan. Same structure as above, only in the other direction.
         */
        flScan.col++;
        yLim = rnScan.flLast.lin;
        while (flScan.lin <= yLim) {
            if (fCtrlc) {
                return (flagType)!DoCancel();
            }
            scanlen = GetLine (flScan.lin, scanreal, pFileHead);
            scanlen = Untab (fileTab, scanreal, scanlen, scanbuf, ' ');
            scanlen = min (rnScan.flLast.col, scanlen);
            while (flScan.col <= scanlen) {
                if ((*pevent)()) {
                    return TRUE;
                }
                if (fRealTabs) {
                    flScan.col = colPhys (scanreal, (pLog (scanreal, flScan.col, TRUE) + 1));
                } else {
                    flScan.col++;
                }
            }
            flScan.col = rnScan.flFirst.col;
            noise (++flScan.lin);
            if (fWrap && (flScan.lin >= pFileHead->cLines)) {
                flScan.lin = 0;
                if (flStart.lin) {
                    yLim = flStart.lin - 1;
                } else {
                    break;
                }
            }
        }
    }
    return FALSE;
}




/*** setAllScan - set maximal scan range
*
*  Sets scan range such that fScan operates on the entire file.
*
* Input:
*  fDir 	= TRUE => scan will procede forwards, else backwards
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
setAllScan (
    flagType fDir
    ) {
    rnScan.flFirst.col = 0;
    rnScan.flFirst.lin = fDir ? YCUR(pInsCur) : 0;
    rnScan.flLast.col  = sizeof(linebuf)-1;
    rnScan.flLast.lin  = pFileHead->cLines - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\file.c ===
/*** file.c - file management
*
*   The internal file structure uses a combination of local memory
*   (managed by LMAlloc and free) and virtual memory (managed by malloc/ffree
*   and (pb|VA)To(pb|VA)).
*
*   We maintain one record for each file that Z has "in memory".  If a file
*   appears in multiple windows, there is only one record for that file.
*   Each window is treated as a separate instance of the editor, with a
*   separate record for each file that is present in that window.
*
*   Graphically, this appears as follows:
*
*    WinList (set of windows on the screen) 0 ... cWin-1
*   +---------------+---------------+---------------+---------------+
*   |   Window 1    |   Window 2    |   Window 3    |   Window 4    |
*   |               |               |               |               |
*   |windowType     |               |               |               |
*   |               |               |               |               |
*   |pInstance-+    |pInstance-+    |pInstance-+    |pInstance-+    |
*   +----------|----+----------|----+----------|----+----------|----+
*              |               v               v               |
*              v              ...             ...              v
*     +-------------+          pFileHead              +-------------+
*     |instanceType |              |                  |instanceType |
*     |             |   +----------+-----------+      |             |
*   +--pNext        |   |          v           |    +--pNext        |
*   | |pFile------------+   +-------------+    |    | |pFile        |
*   | +-------------+       |fileType     |    |    | +-------------+
*   |                       |             |    |    |
*   +------+              +--pFileNext    |    |    +------+
*          |           +-----pName        |    |           |
*          v           |  | +-------------+    |           v
*     +-------------+  |  |                    |      +-------------+
*     |instanceType |  |  |                    |      |instanceType |
*     |             |  |  |                    |      |             |
*   +--pNext        |  |  +--------+           |    +--pNext        |
*   | |pFile----+   |  |           |           +-------pFile        |
*   | +---------|---+  |           v                | +-------------+
*   |           |      |    +-------------+         |
*   +------+    v      |    |fileType     |         +------+
*          |   ...     |    |             |                |
*          v           |  +--pFileNext    |                v
*         ...          |  | |pName        |               ...
*          +-----------+  | +-------------+
*          |              |
*          v              |
*       +--------+        |
*       |filename|        +--------+
*       +--------+                 |
*                                  v
*                                 ...
*
*   Modifications:
*
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#define INCL_DOSFILEMGR

#include "mep.h"

#define DIRTY       0x01                /* file had been modified       */
#define FAKE        0x02                /* file is a pseudo file        */
#define REAL        0x04                /* file has been read from disk */
#define DOSFILE     0x08                /* file has CR-LF               */
#define TEMP        0x10                /* file is a temp file          */
#define NEW         0x20                /* file has been created by editor*/
#define REFRESH     0x40                /* file needs to be refreshed   */
#define READONLY    0x80                /* file may not be editted      */



#define DEBFLAG FILEIO

/*** AutoSave - take current file and write it out if necessary
*
* AutoSave is called when it makes sense to be paranoid about saving the
* file.  We save the file only when autosaving is enabled and when the
* file is real and dirty.
*
* Input:
*  none
*
* Output:
*  none
*
*************************************************************************/
void
AutoSave (
    void
    ) {
    AutoSaveFile (pFileHead);
}


/*** AutoSaveFile - AutoSave a specific file
*
* Called when it makes sense to be paranoid about saving a specific file. We
* save the file only when autosaving is enabled and when the file is real and
* dirty.
*
* Input:
*  pFile        = File to be autosaved
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
AutoSaveFile (
    PFILE   pFile
    ) {
    if (fAutoSave && (FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
        fSyncFile (pFile, TRUE);
        FileWrite (NULL, pFile);
    }
}



/*  GetFileTypeName - return the text corresponding to the file type
 *
 *  GetFileTypeName takes the file type as set in the file structure of the
 *  current file and returns the textual string corresponding to that type.
 *
 *  returns         character pointer to the type-specific text
 */
char *
GetFileTypeName (
    void
    ) {
    if (TESTFLAG (FLAGS (pFileHead),FAKE)) {
        return "pseudo";
    }
    return mpTypepName[FTYPE (pFileHead)];
}



/*  SetFileType - set the file type of a file based upon its extension
 *
 *  pFile           pointer to file whose type will be determined
 */
void
SetFileType (
    PFILE pFile
    ) {
    pathbuf fext;
    REGISTER int i;

    extention (pFile->pName, fext);

    for (i = 0; ftypetbl[i].ext; i++) {
        if (!strcmp (ftypetbl[i].ext, (char *)&fext[1])) {
            break;
        }
    }

    FTYPE(pFile) = ftypetbl[i].ftype;
}




/*  fChangeFile  - change the current file, drive or directory.  We form the
 *  canonicalized name and attempt to find it in our internal list.  If
 *  present, then things are simple:  relink it to the head of the current
 *  window instance set.  If not present, then we need to read it in.
 *
 *  The actual algorithm is much simpler:
 *
 *      If file not in file list then
 *          create new entry in file list
 *      Find file in file list
 *      If file not in window instance list then
 *          add file to top of window instance list
 *      while files in window instance list do
 *          select top file
 *          if file is in memory then
 *              change succeeded
 *          else
 *          if read in succeeds then
 *              change succeeded
 *          pop off top file
 *      change failed
 *
 *
 *  fShort      TRUE => allow searching for short names
 *  name        name of file.
 *
 *  Returns:    TRUE if change succeeded
 *              FALSE otherwise
 */
flagType
fChangeFile (
    flagType  fShort,
    char      *name
    ) {

    PFILE    pFileTmp;
    pathbuf  bufCanon;
    flagType fRead;

    //
    //  Turn file name into canonical form
    //

    if (!CanonFilename (name, bufCanon)) {

        //
        // We may have failed because a drive or directory
        // went away.  If the file named is on the file
        // list, we remove it.
        //

        printerror ("Cannot access %s - %s", name, error () );

        pFileTmp = FileNameToHandle (name, (fShort && fShortNames) ? name : NULL);
        if (pFileTmp != NULL) {
            RemoveFile (pFileTmp);
        }

        return FALSE;
    }

    //
    //  name     has the input name
    //  bufCanon has the full "real" name
    //
    //  Check to see if the file is in the current file set
    //

    pFileTmp = FileNameToHandle (bufCanon, (fShort && fShortNames) ? name : NULL);

    if (pFileTmp == NULL) {

        //
        //  File not loaded.  If it is a directory, change to it
        //

        if (strlen (bufCanon) == 2 && bufCanon[1] == ':') {
            bufCanon[2] = '\\';
        }

        if (_chdir (bufCanon) != -1) {
            domessage ("Changed directory to %s", bufCanon);
            return TRUE;
        }

        //
        //  Must be a file.  Create a new internal file for it
        //
        pFileTmp = AddFile (bufCanon);
    }

    //
    //  Bring the found file to the top of the MRU list
    //

    pFileToTop (pFileTmp);

    //
    // if the file is not currently in memory, read it in
    //
    domessage (NULL);

    if (((FLAGS (pFileHead) & (REAL|REFRESH)) == REAL)
        || (fRead = FileRead (pFileHead->pName, pFileHead, TRUE))) {

        //  If we just read in the file AND the file is new then
        //  reset cached location to TOF.
        //
        if (fRead && TESTFLAG (FLAGS (pFileHead), NEW)) {
            YCUR(pInsCur) = 0;
            XCUR(pInsCur) = 0;
        }
        fSyncFile (pFileHead, TRUE);
        cursorfl (pInsCur->flCursorCur);
        fInitFileMac (pFileHead);

        //
        //  Set the window's title
        //
        //char     *p;
        //p = pFileHead->pName + strlen(pFileHead->pName);
        //
        //while ( p > pFileHead->pName && *p != '\\' ) {
        //    p--;
        //}
        //if ( *p == '\\' ) {
        //    p++;
        //}
        //sprintf( bufCanon, "%s - %s", pNameEditor, p );
        //SetConsoleTitle( bufCanon );
        return TRUE;
    }

    // The file was not successfully read in.  Remove this instance and
    // return the indicated error.
    //
    RemoveTop ();

    return FALSE;
}




/*** fInitFileMac - Initialize macros associated with a file
*
*  Sets the curfile family of macros, and attempts to read any extension-
*  specific section from tools.ini.
*
* Input:
*  pFileNew     = File to set information for
*
* Output:
*  Returns TRUE if TOOLS.INI section found, else FALSE
*
*************************************************************************/
flagType
fInitFileMac (
    PFILE   pFileNew
    ) {

    char  fbuf[ 512 ];

    strcpy (fbuf, pFileNew->pName);
    FmtAssign ("curFile:=\"%s\"", DoubleSlashes (fbuf));

    filename (pFileNew->pName, fbuf);
    FmtAssign ("curFileNam:=\"%s\"", fbuf);

    if (!extention (pFileNew->pName, fbuf)) {
        fbuf[0] = '.';
        fbuf[1] = '\0';
    }
    FmtAssign ("curFileExt:=\"%s\"", fbuf);

    return InitExt (fbuf);
}




/*  AddFile - create a named file buffer
 *
 *  Create and initialize a named buffer.  The contents are initially
 *  empty.
 *
 *  p           character pointer to name
 *
 *  returns     file handle to internal file structure
 */
PFILE
AddFile (
    char *p
    ) {

    PFILE pFileTmp;
    PFILE pFileSrch;

#ifdef DEBUG
    /*
     * assert we're not attempting to add a duplicate entry
     */
    for (pFileTmp = pFileHead;
         pFileTmp != NULL;
         pFileTmp = pFileTmp->pFileNext) {

        assert (_stricmp ((char *)(pFileTmp->pName), p));
    }
#endif

    pFileTmp = (PFILE) ZEROMALLOC (sizeof (*pFileTmp));
#ifdef DEBUG
    pFileTmp->id = ID_PFILE;
#endif
    pFileTmp->pName = ZMakeStr (p);

    /*
     * Everything that we explicitly set NULL, we can assume, as LMAlloc init's
     * the allocated PFILE to all nulls.
     *
     *  pFileTmp->pFileNext = NULL;
     *  pFileTmp->cLines = 0;
     *  pFileTmp->refCount = 0;
     *  FLAGS(pFileTmp) = FALSE;
     *  pFileTmp->cUndo = 0;
     */
    pFileTmp->plr      = NULL;
    pFileTmp->pbFile   = NULL;
    pFileTmp->vaColor  = (PVOID)(-1L);
    pFileTmp->vaHiLite = (PVOID)(-1L);
        pFileTmp->vaMarks  = NULL;
    pFileTmp->vaUndoCur = pFileTmp->vaUndoHead = pFileTmp->vaUndoTail = (PVOID)(-1L);

    CreateUndoList (pFileTmp);
    /*
     * Place the file at the end of the pFile list
     */
    if (pFileHead == NULL) {
        pFileHead = pFileTmp;
    } else {
        for (pFileSrch = pFileHead;
             pFileSrch->pFileNext;
             pFileSrch = pFileSrch->pFileNext) {
            ;
        }
        pFileSrch->pFileNext = pFileTmp;
    }

    SetFileType (pFileTmp);

    return pFileTmp;
}




/*  IncFileRef - note a new reference to a file
 */
void
IncFileRef (
    PFILE pFile
    ) {
    pFile -> refCount++;
}





/*  DecFileRef - remove a reference to a file
 *
 *  When the reference count goes to zero, we remove the file from the memory
 *  set
 */
void
DecFileRef (
    PFILE pFileTmp
    ) {
    if (--(pFileTmp->refCount) <= 0) {
        RemoveFile (pFileTmp);
    }
}



/*  FileNameToHandle - return handle corresponding to the file name
 *
 *  FileNameToHandle is used to locate the buffer pointer corresponding to
 *  a specified file.  Short names are allowed.  If the input name is 0-length
 *  we return the current file.
 *
 *  pName       character pointer to name being located.  Case is significant.
 *  pShortName  short name of file.  This may be NULL
 *
 *  Returns     handle to specified file (if found) or NULL.
 */
PFILE
FileNameToHandle (
    char const *pName,
    char const *pShortName
    ) {

    PFILE pFileTmp;

    if (pName[0] == 0) {
        return pFileHead;
    }

    for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext)
        if (!_stricmp (pName, pFileTmp->pName))
            return pFileTmp;

    if ( pShortName != NULL ) {
        for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
            REGISTER char *pFileName = pFileTmp->pName;
            pathbuf nbuf;

            if (filename (pFileName, nbuf) &&
                !_stricmp (nbuf, pShortName)) {
                return pFileTmp;
            }
        }
    }
    //for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
    //REGISTER char *pFileName = pFileTmp->pName;
    //pathbuf nbuf;
    //
    //if (!stricmp (pName, pFileName) ||
    //    (pShortName != NULL &&
    //     filename (pFileName, nbuf) &&
    //         !stricmp (nbuf, pShortName))) {
    //        return pFileTmp;
    //    }
    //}
    return NULL;
}



/*** pFileToTop - make the specified file the top of the current window
*
* Search  the instance list in the current window for the file. If it is
* found, relink it to be the top one. Otherwise, allocate a new instance for
* it  and  place it at the top of the instance list. Also bring the file to
* the top of the pFileHead file list. Ensure that it is on the list to begin
* with.
*
* Input:
*  pFileTmp     = file to bring to top
*
* OutPut:
*  Returns FALSE if the pFile is invalid or NULL
*
*************************************************************************/
flagType
pFileToTop (
    PFILE pFileTmp
    ) {

    EVTargs e;
    PINS    pInsLast        = (PINS) &pInsCur;
    PINS    pInsTmp         = pInsCur;
    PFILE   pFilePrev;

    assert (_pfilechk());
    assert (_pinschk(pInsCur));

    /*
     * if we're about to lose focus, declare it
     */
    if (pFileTmp != pFileHead) {
        e.pfile = pFileHead;
        DeclareEvent (EVT_LOSEFOCUS,(EVTargs *)&e);
    }

    /*
     * Move file to head of file list. Ensure, at the same time, that the file
     * is in fact ON the list, and declare the event if in fact it is moved.
     */
    if (pFileTmp != pFileHead) {
        for (pFilePrev = pFileHead;
                         pFilePrev && (pFilePrev->pFileNext != pFileTmp);
             pFilePrev = pFilePrev->pFileNext ) {
            ;

        }

        if (!pFilePrev) {
            return FALSE;
        }

        pFilePrev->pFileNext = pFileTmp->pFileNext;
        pFileTmp->pFileNext = pFileHead;
        pFileHead = pFileTmp;

        e.pfile = pFileHead;
        DeclareEvent (EVT_GETFOCUS,(EVTargs *)&e);
    }

    /*
     * pFileTmp now points to a file structure for the correct file. Try to find
     * an instance of the file in the current window. If not in the instance
     * list, allocate it. If it is in the instance list, remove it.
     */
    while (pInsTmp != NULL) {
        if (pInsTmp->pFile == pFileTmp) {
            break;
        }
        pInsLast = pInsTmp;
        pInsTmp = pInsTmp->pNext;
    }

    if (pInsTmp == NULL) {
        pInsTmp = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
        pInsTmp->pFile = pFileTmp;
#ifdef DEBUG
        pInsTmp->id = ID_INSTANCE;
#endif
        IncFileRef (pFileTmp);
    } else {
        pInsLast->pNext = pInsTmp->pNext;
    }
    /*
     * Regardless, then, of where it came from, place the new instance back onto
     * the head of the list
     */
    pInsTmp->pNext = pInsCur;
    WININST(pWinCur) = pInsCur = pInsTmp;

    SETFLAG(fDisplay, RCURSOR | RSTATUS);
    newscreen ();

    return TRUE;

}



/*  RemoveTop - removes the top file in the current instance list
 *              If there is no next file, leave
 */
void
RemoveTop (
    void
    ) {
    PINS    pInsTmp = pInsCur;

    WININST(pWinCur) = pInsCur = pInsCur->pNext;
    FREE ((char *) pInsTmp);
    DecFileRef (pFileHead);
    if (pInsCur) {
        pFileToTop (pInsCur->pFile);
    }
}




/*** RemoveFile  - free up all resources attached to a particular file
*
* Purpose:
*
*   To free all memory used to keep track of a file.  If the file still
*   appears in some instance lists, it is removed from them.
*
* Input:
*
*   pFileRem - File in question
*
* Output:
*
*   Returns TRUE.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
RemoveFile (
    PFILE    pFileRem
    ) {

    PFILE pFilePrev = (PFILE) &pFileHead;
    PFILE pFileTmp = pFileHead;

    if (pFileRem->refCount > 0) {
        RemoveInstances (pFileRem);
    }

    while (pFileTmp != pFileRem) {
        pFilePrev = pFileTmp;
        pFileTmp = pFileTmp->pFileNext;
        if (pFileTmp == NULL) {
            IntError ("RemoveFile can't find file");
        }
    }


    /*
     * It's important that pFileNext be the first field in a pfile, and we assert
     * that here. This allows us to not special case pFileHead, but adjust it by
     * treating it as the pFileNext of a non-existant structure.
     */
    assert ((void *)&(pFilePrev->pFileNext) == (void *)pFilePrev);
    pFilePrev->pFileNext = pFileTmp->pFileNext;

    FreeFileVM (pFileTmp);

    FREE (pFileTmp->pName);

#if DEBUG
    pFileTmp->id = 0;
#endif

    FREE ((char *) pFileTmp);

    if (pFileTmp == pFileIni) {
        pFileIni = NULL;
    }
}



/*** RemoveInstances - Remove all instances of a file
*
* Purpose:
*
*  Used by RemoveFile to make sure that there are no file instances
*  referring to a given file
*
* Input:
*  pFile        = File in question
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
RemoveInstances (
    PFILE   pFile
    ) {

    PINS    pIns;
    PINS    pInsPrev;
    PWND    pWndCur;

    for (pWndCur = &WinList[0];
         pWndCur < &WinList[cWin];
         pWndCur++) {

        pInsPrev = NULL;
        pIns = WININST(pWndCur);
        while (pIns) {

            /*
             * assert not an infinite loop
             */
            assert (!pInsPrev || (pIns != WININST (pWndCur)));

            if (pIns->pFile == pFile) {
                if (!pInsPrev) {
                    WININST (pWndCur) = pIns->pNext;
                } else {
                    pInsPrev->pNext = pIns->pNext;
                }
                {
                    PINS pInsTmp = pIns;
                    pIns = pIns->pNext;
                    FREE(pInsTmp);
                }
            } else {
                pInsPrev = pIns;
                pIns = pIns->pNext;
            }
        }
        assert (_pinschk (WININST (pWndCur)));
    }
    //
    // If the resulting instance list for the current window becomes empty,
    // bring up the <untitled> file in it.
    //
    if (!(pInsCur = WININST (pWinCur))) {
        fChangeFile (FALSE, RGCHUNTITLED);
    }
}




/*  fSyncFile - Attempt to make logical file and physical file the same
 *
 *  When editing in a network or multi-tasking environment, we need to make
 *  sure that changes made underneath us are properly reflected to the
 *  user.  We do this by snapshotting the time-of-last-write and periodically
 *  comparing it with the version on disk.  When a mismatch is found, we
 *  prompt the user and give him the opportunity to reread the file
 *
 *  pFileLoc    file structure of interest
 *  fPrompt     TRUE => prompt user for permission to refresh, else just
 *              refresh.
 *
 *  returns     TRUE iff the logical file and the physical file are the same.
 */
flagType
fSyncFile (
    PFILE pFileLoc,
    flagType fPrompt
    ) {
    if (pFileLoc == NULL) {
        pFileLoc = pFileHead;
    }

    switch (FileStatus (pFileLoc, NULL)) {

    case FILECHANGED:
        if (fPrompt) {
            if (!confirm ("%s has been changed.  Refresh? ", pFileLoc->pName)) {
                /* No, validate this edit session */
                SetModTime (pFileLoc);
                return FALSE;
            }
        }
        FileRead (strcpy( buf, pFileLoc->pName ), pFileLoc, TRUE);
        RSETFLAG (FLAGS (pFileLoc), DIRTY);
        SETFLAG (fDisplay, RSTATUS);
        return TRUE;

    case FILEDELETED:
        domessage ("File has been deleted");
        break;

    default:
        break;

    }
    return TRUE;
}




/*  FileStatus - compare logical info about a file with file on disk
 *
 *  Compare the last modified time with the last snapshot.  If the filename
 *  contains metachars, the file is not believed to have changed.  Further, if
 *  the file is a pseudo file, it cannot have changed.
 *
 *  pFile       file of interest (contains mod time)
 *  pName       name of file to examine (when writing to diff. name)
 *
 *  returns     FILECHANGED if timestamps differ
 *              FILEDELETED if file on disk does not exist
 *              FILESAME    if timestamps are the same
 */
int
FileStatus (
    PFILE pFile,
    char *pName
    ){

    time_t modtime;

    if (TESTFLAG(FLAGS(pFile),FAKE)) {
        return FILESAME;
    }

    if (pName == NULL) {
        pName = pFile->pName;
    }

    if (*strbscan (pName, "?*") != 0) {
        return FILESAME;
    }

    if ((modtime = ModTime (pName)) == 0L) {
        return FILEDELETED;
    }

    if (pFile->modify != modtime) {
        return FILECHANGED;
    }

    return FILESAME;
}




/*  SetModTime - Snapshot a file's last-modification time
 *
 *  pFile       file of interest
 */
void
SetModTime (
    PFILE pFile
    ) {
    pFile->modify = ModTime (pFile->pName);
}



/*  ModTime - Return the time of last modification for a file
 *
 *  If the file does not exist or contains meta chars, return 0 as the time-
 *  stamp.
 *
 *  pName       character pointer to file name
 *
 *  Returns     last modification time of file.
 */

time_t
ModTime (
    char *pName
    ) {

    struct _stat statbuf;

    if (*strbscan (pName, "?*")) {
        return 0L;
    }

    if (_stat (pName, &statbuf) == -1) {
        return 0L;
    }

    return statbuf.st_mtime;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\event.c ===
/*** event.c - handle events for z extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"

EVT *pEVTHead	    = NULL;	    /* head of event chain	    */


/*** DeclareEvent - post the ocurrance of an event, and pass message
*
* Called by the various pieces of code that actualy detect event ocurrance,
* this routine traverses the event handler list, and invokes the event handler
* for each with matching criteria.
*
* event 	- Event Type.
* pargs 	- Pointer to any args to be passed to the handling routine
*
* Returns	- TRUE if the event has been consumed, and should be further
*		  ignored by the caller. Else FALSE.
*
*************************************************************************/
flagType
DeclareEvent (
    unsigned event,
    EVTargs *pargs
    ) {

    EVT *pEVTCur;

    //
    // For each in chain, if:
    //      - event type matches
    //      - focus is not specified, (all files) or matches the current focus
    //      - if it's a keyboard event, either no key was specified, or the
    //        matching key was specified
    // then we invoke the handler.
    //
    for (pEVTCur = pEVTHead; pEVTCur; pEVTCur = pEVTCur->pEVTNext) {
	assert (pEVTCur->pEVTNext != pEVTCur);
        if (pEVTCur->evtType != event) {
            //
            //  Skip events that don't match
            //
        } else if (pEVTCur->focus != NULL && pEVTCur->focus != pFileHead) {
            //
            //  Skip events that aren't for this file
            //
        } else if ((event == EVT_KEY || event == EVT_RAWKEY) &&
            pEVTCur->arg.arg.key.LongData != 0 && pEVTCur->arg.arg.key.LongData != pargs->arg.key.LongData) {
            //
            //  Skip events that don't match keystrokes
            //
        } else if (pEVTCur->func (pargs) != 0) {
            //
            //  Event handler eats event, don't propogate it
            //
            return TRUE;
        }
    }
    return FALSE;
}




/* RegisterEvent - Register Event handler
 *
 * Called by the extension that wishes to recieve event notification. Just
 * places ptr at head of list.
 *
 * pEVTDef	- Pointer to Event Definition struct.
 *
 */
void
RegisterEvent (
    EVT *pEVTDef
    ) {
    pEVTDef->pEVTNext = pEVTHead;
    pEVTHead = pEVTDef;
}



/* DeRegisterEvent - DeRegister Event handler
 *
 * Called by the extension that wishes to stop recieving event notification.
 * Just removes struct from list.
 *
 * pEVTDef	- Pointer to Event Definition struct.
 *
 */
void
DeRegisterEvent (
    EVT *pEVTDef
    ) {

    EVT *pEVTCur;

    if (pEVTHead) {
        if (pEVTHead == pEVTDef) {
	    pEVTHead = pEVTDef->pEVTNext;
        } else {
	    for (pEVTCur=pEVTHead; pEVTCur; pEVTCur=pEVTCur->pEVTNext) {
		if (pEVTCur->pEVTNext == pEVTDef) {
		    pEVTCur->pEVTNext = pEVTDef->pEVTNext;
		    break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\insert.c ===
/*  sinsert.c - stream insert of characters
 *
 *  Modifications:
 *
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "mep.h"


flagType
insert (
    CMDDATA argType,
    ARG * pArg,
    flagType fMeta
    ) {

    switch (pArg->argType) {

	case BOXARG:
	case LINEARG:
	    linsert (argType, pArg, fMeta);
	    break;

	default:
	    sinsert (argType, pArg, fMeta);
	    break;
    }
    return TRUE;
}



flagType
sinsert (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    switch (pArg->argType) {

    case NOARG:
	CopyBox (NULL, pFileHead, pArg->arg.noarg.x, pArg->arg.noarg.y,
				  pArg->arg.noarg.x, pArg->arg.noarg.y,
				  pArg->arg.noarg.x, pArg->arg.noarg.y);
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	flHigh.col = 0;
	flHigh.lin++;
	CopyStream (NULL, pFileHead, pArg->arg.nullarg.x, pArg->arg.nullarg.y,
				     0, 		  pArg->arg.nullarg.y + 1,
				     pArg->arg.nullarg.x, pArg->arg.nullarg.y);
        return TRUE;

    case LINEARG:
    case BOXARG:
	BoxToStream (pArg);

    case STREAMARG:
	CopyStream (NULL, pFileHead,
		    pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		    pArg->arg.streamarg.xEnd,	pArg->arg.streamarg.yEnd,
		    pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart);
	return TRUE;

    DEFAULT_UNREACHABLE;
    }

    argData; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\hilite.c ===
/*** hilite.c - editor multiple-file highlighting support
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains the common code to maintain multiple highlighted regions across
*   multiple files.
*
* Highlighting Overview
*
*   Each pFile contains a vm pointer to a linked list of blocks each of which
*   contain up to RNMAX ranges in the file currently highlighted. The ranges
*   are maintained in order of the first coordinate of the range (see below),
*   though they may overlap. Each block may not be completely full, due to the
*   insertion algorithm which maintains the order.
*
*		      +---------------+   +---------------+   +---------------+
*   pFile->vaHiLite-->|vaNext	      |-->|vaNext	  |-->|-1L	      |
*		      +---------------+   +---------------+   +---------------+
*		      |irnMac	      |   |irnMac	  |   |irnMac	      |
*		      +---------------+   +---------------+   +---------------+
*		      |rnHiLite[RNMAX]|   |rnHiLite[RNMAX]|   |rnHiLite[RNMAX]|
*		      +---------------+   +---------------+   +---------------+
*
*   Clearing all current highlighting for a file simply involves deallocating
*   the list of highlight ranges.
*
*   Adding a highlight region either updates an existing region (if the start
*   points are the same, and the new end point is the same in one direction and
*   greater in the other), or insertion of a new range in the sorted list. If
*   a block is full, when asertion is attempted in that block, the block will
*   be split in half, and a new block inserted into the linked list.
*
*   Each range is "normally" an ordered pair of coordinates (a range, or rn)
*   specifying the range of the file to be hilighted. However, Arg processing
*   always specifies that the first coordinate of this pair is the location at
*   which the user hit ARG, and the second is the travelling corrdinate as he
*   specifies the region on screen. For this reason, if the x coordinates are
*   in reverse order, the right-most coordinate is decremented by one to
*   reflect the correct highlighting for arguments.
*
*
* Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"

#define RNMAX	20			/* max number of rns per block	*/
					/* MUST BE EVEN 		*/

/*
 * HiLiteBlock - block of highlighting information as kept in VM
 */
struct HiLiteBlock {
    PVOID   vaNext;                     /* va of next block, or -1      */
    int     irnMac;			/* number of rns in block	*/
    rn	    rnHiLite[RNMAX];		/* ranges with highlighting	*/
    char    coHiLite[RNMAX];		/* colors to be used		*/
    };



/*** SetHiLite - Mark a range in a file to be highlighted
*
*  Marks the specfied range in a file as needing to be highlighted. The next
*  time that portion of the file is updated on screen, the highlighting
*  attributes will be applied.
*
* Input:
*  pFile	= file to be highlighted
*  rnCur	= Range to be highlighted
*  coCur	= Color to use for highlighting
*
* Output:
*
*************************************************************************/
void
SetHiLite (
    PFILE   pFile,
    rn      rnCur,
    int     coCur
    ) {

    struct HiLiteBlock	hbCur;		 /* block being worked on	 */
    int 		irnCur; 	 /* index into block		 */
    PVOID               vaCur;           /* va of current block          */
    PVOID               vaNew;           /* va of new split block        */
    PVOID               vaNext;          /* va of next block             */

    /*
     * If the file does not yet have one, allocate the first highlight block
     */
    if (pFile->vaHiLite == (PVOID)(-1L)) {
	irnCur = 0;
        hbCur.vaNext = (PVOID)(-1L);
	hbCur.irnMac = 0;
        // PREFIX!  This MALLOC is not checked for failure
        vaCur = pFile->vaHiLite = MALLOC ((long)sizeof(hbCur));
    } else {
	vaCur = pFile->vaHiLite;
	while (1) {
            // rjsa VATopb (vaCur, (char *)&hbCur, sizeof(hbCur));
            memmove((char *)&hbCur, vaCur, sizeof(hbCur));
	    assert (hbCur.irnMac <= RNMAX);

	    /*
	     * search contents of current block for first range which occurs on
	     * the same or a later position than the new one.
	     */
	    for (irnCur = 0; irnCur<hbCur.irnMac; irnCur++) {
                if (hbCur.rnHiLite[irnCur].flFirst.lin > rnCur.flFirst.lin) {
                    break;
                }
		if (   (hbCur.rnHiLite[irnCur].flFirst.lin == rnCur.flFirst.lin)
                    && (hbCur.rnHiLite[irnCur].flFirst.col >= rnCur.flFirst.col)) {
                    break;
                }
            }
	    /*
	     * if we found something, exit the search, else move to next block,
	     * if there is one.
	     */
            if (irnCur != hbCur.irnMac) {
                break;
            }
            if (hbCur.vaNext == (PVOID)(-1L)) {
                break;
            }
            vaCur = hbCur.vaNext;
        }
    }

    /*
     * vaCur = va of block needing insertion/modification
     * irnCur = index of rn for same or later position
     * hbCur = contents of block last read
     *
     * if irnCur<RNMAX we operate on the current block, else we allocate a
     * new one, link it to the list, and place our new highlighted region
     * in it.
     */
    if (irnCur >= RNMAX) {
        // PREFIX! This MALLOC is not checked for failure
        hbCur.vaNext = MALLOC ((long)sizeof(hbCur));
        // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
        memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
        vaCur = hbCur.vaNext;
        hbCur.vaNext = (PVOID)(-1L);
		hbCur.irnMac = 1;
		hbCur.rnHiLite[0] = rnCur;
        // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
        memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
	return;
    }

    /*
     * If the upper first coordinate matches, and one of the second coordinates
     * then just update the second.
     */
    if (   (irnCur >= 0)
	&& (   (hbCur.rnHiLite[irnCur].flFirst.lin == rnCur.flFirst.lin)
	    && (hbCur.rnHiLite[irnCur].flFirst.col == rnCur.flFirst.col))
	&& (   (hbCur.rnHiLite[irnCur].flLast.lin == rnCur.flLast.lin)
	    || (hbCur.rnHiLite[irnCur].flLast.col == rnCur.flLast.col))
	&& (hbCur.coHiLite[irnCur] == (char)coCur)
	) {

	/*
	 * If the columns have changed, redraw the entire range (only the columns
	 * changed, but on all lines), otherwise just redraw those lines which
	 * have changed.
	 */
        if (hbCur.rnHiLite[irnCur].flLast.col != rnCur.flLast.col) {
            redraw (pFile,rnCur.flFirst.lin,rnCur.flLast.lin);
        } else {
            redraw (pFile,hbCur.rnHiLite[irnCur].flLast.lin,rnCur.flLast.lin);
        }
	hbCur.rnHiLite[irnCur].flLast = rnCur.flLast;
    } else {
	redraw (pFile,rnCur.flFirst.lin,rnCur.flLast.lin);

	/*
	 * if the block to be modified is full, then split it into two blocks.
	 */
	if (hbCur.irnMac == RNMAX) {
	    hbCur.irnMac = RNMAX/2;
	    vaNext = hbCur.vaNext;
            vaNew = hbCur.vaNext = MALLOC ((long)sizeof(hbCur));
            // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
            memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
	    memmove ((char *)&hbCur.rnHiLite[0],
		 (char *)&hbCur.rnHiLite[RNMAX/2]
		 ,(RNMAX/2)*sizeof(rn));
	    memmove ((char *)&hbCur.coHiLite[0],
		 (char *)&hbCur.coHiLite[RNMAX/2]
		 ,(RNMAX/2)*sizeof(char));
	    hbCur.vaNext = vaNext;
            // rjsa pbToVA ((char *)&hbCur, vaNew, sizeof(hbCur));
            memmove(vaNew, (char *)&hbCur, sizeof(hbCur));

	    /*
	     * select which of the two blocks (vaCur, the first half; or vaNew,
	     * the second) to operate on. ReRead the old block if required.
	     */
	    if (irnCur >= RNMAX/2) {
		vaCur = vaNew;
		irnCur -= RNMAX/2;
            } else {
                //rjsa VATopb (vaCur, (char *)&hbCur, sizeof(hbCur));
                memmove((char *)&hbCur, vaCur, sizeof(hbCur));
            }
        }

	/*
	 * Move the rn's that follow where we want to be, up by one,
	 * and insert ours.
	 */
        if (irnCur < hbCur.irnMac) {
	    memmove ((char *)&hbCur.rnHiLite[irnCur+1],
		 (char *)&hbCur.rnHiLite[irnCur]
                 ,(hbCur.irnMac - irnCur)*sizeof(rn));
        }
	memmove ((char *)&hbCur.coHiLite[irnCur+1],
	     (char *)&hbCur.coHiLite[irnCur]
	     ,(hbCur.irnMac - irnCur));
	hbCur.rnHiLite[irnCur] = rnCur;
	hbCur.coHiLite[irnCur] = (char)coCur;
	hbCur.irnMac++;
    }

    /*
     * update the block in vm
     */
    // rjsa pbToVA ((char *)&hbCur, vaCur, sizeof(hbCur));
    memmove(vaCur, (char *)&hbCur, sizeof(hbCur));
}



/*** ClearHiLite - remove all highlighting from a file
*
*  Removes all highlighting information for a file, and marks those lines
*  affected as needing to be redrawn.
*
* Input:
*  pFile	= file affected.
*  fFree	= TRUE => free the VM used
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
ClearHiLite (
    PFILE   pFile,
    flagType fFree
    ) {

	struct HiLiteBlock	*hbCur, *hbNext;
    int 		irn;

	while (pFile->vaHiLite != (PVOID)(-1L)) {

		hbCur = ( struct HiLiteBlock *)(pFile->vaHiLite );

		assert (hbCur->irnMac <= RNMAX);

		/*
		 * for each of the highlight ranges in the block, mark the lines as
		 * needing to be redrawn, so that highlighting will be removed from
		 * the screen.
		 */
		for (irn = hbCur->irnMac; irn; ) {
			irn--;
			redraw (pFile
					,hbCur->rnHiLite[irn].flFirst.lin
					,hbCur->rnHiLite[irn].flLast.lin
					);
		}

		/*
		 * discard the vm used by the block, and point at the next block in
		 * the chain
		 */
		hbNext = hbCur->vaNext;
        if (fFree) {
            FREE(pFile->vaHiLite);
        }
		pFile->vaHiLite = hbNext;
    }
}



/*** UpdHiLite - Update a color buffer with highlighting information
*
*  Apply all highlighting ranges that apply to a particluar portion
*  of a line in a file to a color buffer. Ensure that areas outside
*  the highlight range are unaffected, and that areas within are
*  updated appropriately.
*
* Input:
*  pFile	= File being operated on
*  lin		= line
*  colFirst	= first col
*  colLast	= last col
*  ppla 	= Pointer to Pointer to lineattr array to be updated
*
* Output:
*  Returns TRUE if highlighting occurred.
*
*************************************************************************/
flagType
UpdHiLite (
    PFILE             pFile,
    LINE              lin,
    COL               colFirst,
    COL               colLast,
    struct lineAttr **ppla
    ) {

	struct HiLiteBlock	*hbCur;		 /* block being worked on	 */
    PVOID               vaCur;           /* va of current block          */
    int 		irnCur; 	 /* index into block		 */

    COL 		colHiFirst;
    COL 		colHiLast;
    COL 		colHiTmp;

    COL 		col;
    struct lineAttr    *pla;

    flagType		fRv = FALSE;	 /* highlighting occurred	 */

    /*
     * First we scroll it to the left (if needed)
     */
    if (colFirst) {
	for (col = 0, pla = *ppla;
	     col + pla->len <= colFirst;
             col += pla++->len) {
            ;
        }

        if (col < colFirst && pla->len != 0xff) {
            pla->len -= (unsigned char) (colFirst - col);
        }

	/*
	 * Take care here we modify THEIR pointer
	 */
	*ppla = pla;
    }

    /*
     * for all blocks of hiliting info
     */
    vaCur = pFile->vaHiLite;
	while (vaCur != (PVOID)(-1L)) {

		/*
		 * get block
		 */
		hbCur = (struct HiLiteBlock *)vaCur;
		assert (hbCur->irnMac <= RNMAX);

		/*
		 * for each range within the block
		 */
		for (irnCur = 0; irnCur<hbCur->irnMac; irnCur++) {
			/*
			 * is the range affecting the line we're looking for ?
			 */
			if (fInRange (hbCur->rnHiLite[irnCur].flFirst.lin
						 ,lin
						 ,hbCur->rnHiLite[irnCur].flLast.lin)) {

				/*
				 * Watch out: range coordinates might be inversed
				 */
				if (  (colHiFirst = hbCur->rnHiLite[irnCur].flFirst.col)
					> (colHiLast  = hbCur->rnHiLite[irnCur].flLast.col)) {

					colHiTmp   = colHiFirst - 1;
					colHiFirst = colHiLast;
					colHiLast  = colHiTmp;
                }


				/*
				 * is the range affecting the portion of line we're looking for ?
				 */
				if (!(colHiLast < colFirst || colHiFirst > colLast)) {
					/*
					 * Yes: signals work done and do the hilite
					 */
					fRv = TRUE;
					UpdOneHiLite (*ppla
								,max(colFirst, colHiFirst) - colFirst
								,min(colLast,	colHiLast ) - max(colFirst, colHiFirst) + 1
								,TRUE
								,(int) hbCur->coHiLite[irnCur]);
                }
            }
        }
		vaCur = hbCur->vaNext;
    }
    return fRv;
}



/*** UpdOneHiLite - Update the highlighting on one line of attributes
*
*  Modifies an existing attribute line to include highlighting.
*
* Input:
*  pla		   = Pointer to attribute information for line
*  colFirst	   = Starting column
*  colLast	   = Ending column
*  fattr (CW only) = TRUE: attr is color index
*		     FALSE: attr is pointer to lineAttr array
*  attr 	   = color index or pointer to lineAttr array to be used
*
* Output:
*  *pla updated
*
*************************************************************************/
void
UpdOneHiLite (
    struct lineAttr *pla,
    COL              colFirst,
    COL              len,
    flagType         fattr,
    INT_PTR          attr
    ) {

    struct lineAttr *plaFirstMod;   /* pointer to first cell to be modified    */
    struct lineAttr *plaLastMod;    /* pointer to last cell to be modified     */
    COL		     colLast = colFirst + len - 1;
    COL 	     colFirstMod;   /* starting column for first modified cell */
    COL 	     colLastMod;    /* starting column for last modified cell  */

    struct lineAttr *plaSrc;	    /* source pointer for moving cells	       */
    struct lineAttr *plaDst;	    /* destination pointer for moving cells    */
    struct lineAttr *plaSrcSav;     /* temporary pointer		       */

    struct lineAttr *plaExt;	    /* pointer to external array of lineAttr   */
    COL 	     colSrc;
    COL 	     colSrcEnd;

    struct lineAttr  rglaTmp[3];    /* buffer for creating cells	       */
    int 	     claTmp = 0;    /* number of cells to insert	       */

    /*
     * First we Find the first cell that will be affected by the change
     */
    for (colFirstMod = 0, plaFirstMod = pla;
	 colFirstMod + plaFirstMod->len <= colFirst;
         colFirstMod += plaFirstMod++->len) {
        ;
    }

    /*
     * Next we find the last cell that will be affected by the change
     */
    for (colLastMod = colFirstMod, plaLastMod = plaFirstMod;
	 colLastMod + plaLastMod->len <= colLast;
         colLastMod += plaLastMod++->len) {
        ;
    }

    /*
     * If the first affected cell doesn't start on our boundary, let's
     * create a new cell to be inserted
     */
    if (colFirstMod < colFirst) {
	rglaTmp[0].len	= (unsigned char) (colFirst - colFirstMod);
	rglaTmp[0].attr = plaFirstMod->attr;
	claTmp++;
    } else {
        rglaTmp[0].len = 0;
    }

    if (fattr) {
	/*
	 * Only one color for the updated range: we always create
	 * the cell of new color
	 */
	rglaTmp[1].len	= (unsigned char) (colLast - colFirst + 1);
	rglaTmp[1].attr = (unsigned char) attr;
	claTmp++;
    } else {
	/*
	 * Colors for the updated range come from an array of lineAttr
	 * We first get its address (this is a hack because 16 bit pointer
	 * can be cast to an int)
	 */
	plaExt = (struct lineAttr *) attr;

	/*
	 * Count the number of cells to copy.
	 */
	for (plaSrc = plaExt, colSrc = 0, colSrcEnd = colLast - colFirst + 1;
	     colSrc + plaSrc->len <= colSrcEnd;
             colSrc += plaSrc++->len, claTmp++) {
            ;
        }

	/*
	 * Build trailing cell if needed
	 */
	if (colSrc < colSrcEnd) {
            rglaTmp[1].len  = (unsigned char) (colSrcEnd - colSrc);
	    rglaTmp[1].attr = (unsigned char) plaSrc->attr;
	    claTmp++;
        } else {
            rglaTmp[1].len = 0;
        }
    }

    /*
     * If the last affected cell doesn't end on our boundary, we
     * create a new cell to be inserted. We take care of the final
     * cell.
     */
    if (colLastMod + plaLastMod->len > colLast + 1) {
	rglaTmp[2].len = (unsigned char) ((plaLastMod->len == 0xff) ?
	    0xff :
	    colLastMod + (int) plaLastMod->len - colLast - 1);
	rglaTmp[2].attr = plaLastMod->attr;
	claTmp++;
    } else {
        rglaTmp[2].len = 0;
    }

    /*
     * Then we move the info tail to its new place if needed
     *
     * UNDONE: Here we could use Move() instead of copying cell by cell
     */
    if (plaLastMod->len != 0xff) {
	plaDst = plaFirstMod + claTmp;
	plaSrc = plaLastMod + 1;
        if (plaDst < plaSrc) {
	    do {
		*plaDst++ = *plaSrc;
            } while (plaSrc++->len != 0xff);
        } else {
            for (plaSrcSav = plaSrc; plaSrc->len != 0xff; plaSrc++) {
                ;
            }
	    plaDst += plaSrc - plaSrcSav;
	    do {
		*plaDst-- = *plaSrc--;
            } while (plaSrc >= plaSrcSav);
        }
    }

    /*
     * Finally insert the created cells
     */
    for (plaDst = plaFirstMod, claTmp = 0; claTmp < 3; claTmp++) {
        if (claTmp == 1 && !fattr) {
	    /*
	     * UNDONE: Here we could use Move() instead of copying cell by cell
	     */
	    for (plaSrc = plaExt, colSrc = 0, colSrcEnd = colLast - colFirst + 1;
		 colSrc + plaSrc->len <= colSrcEnd;
                 plaDst++, colSrc += plaSrc++->len) {
                *plaDst = *plaSrc;
            }
        }
        if (rglaTmp[claTmp].len) {
            *plaDst++ = rglaTmp[claTmp];
        }
    }
}





/*** rnOrder - ensure that a range is in correct first/last order
*
*  Ensure that a range is in correct first/last order
*
* Input:
*  prn		= Pointer to range
*
* Output:
*  *prn updated
*
*************************************************************************/
void
rnOrder (
    rn      *prn
    ) {

    rn	    rnTmp;

    rnTmp.flFirst.lin = lmin (prn->flFirst.lin, prn->flLast.lin);
    rnTmp.flLast.lin  = lmax (prn->flFirst.lin, prn->flLast.lin);
    rnTmp.flFirst.col = min (prn->flFirst.col, prn->flLast.col);
    rnTmp.flLast.col  = max (prn->flFirst.col, prn->flLast.col);

    *prn = rnTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\getstr.c ===
/*** getstr.c - text argument handler
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "cmds.h"


#define ISWORD(c) (isalnum(c) || isxdigit(c) || c == '_' || c == '$')



/*** getstring - one line editor
*
*  This routine handles the entering and editting of single line responses
*  on the dialog line.
*
* Input:
*  pb	   = pointer to destination buffer for user's response
*  prompt  = pointer to prompt string
*  pFunc   = first editting function to process
*  flags   = GS_NEWLINE  entry must be terminated by newline, else any other
*			 non-recognized function will do.
*	     GS_INITIAL  entry is highlighted, and if first function is
*			 graphic, the entry is replaced by that graphic.
*	     GS_KEYBOARD entry must from the keyboard (critical situation ?)
*
* Output:
*  Returns pointer to command which terminated the entry
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
PCMD
getstring (
    char    *pb,
    char    *prompt,
    PCMD    pFunc,
    flagType flags
    ) {

    flagType fMetaTextArg;

    int xbeg;
    int iRespCur;	/* current position in response */

    if ((iRespCur = strlen(pb)) == 0) {
        RSETFLAG(flags, GS_INITIAL);
    }
    memset ((char *) pb+iRespCur, '\0', sizeof(linebuf) - iRespCur);

    if (pFunc != NULL) {
	xbeg = flArg.col;
    } else {
	iRespCur = 0;
	xbeg = XCUR(pInsCur);
    }

    fMetaTextArg = fMeta;

    /*
     * main editing loop. [Re]Display entry line & process editting action.
     */
    while (TRUE) {
	ScrollOut (prompt, pb, iRespCur, TESTFLAG(flags, GS_INITIAL) ? hgColor : fgColor, (flagType) TESTFLAG (flags, GS_KEYBOARD));
	RSETFLAG (fDisplay, RCURSOR);
        if (pFunc == NULL) {
	    if ((pFunc = (TESTFLAG (flags, GS_KEYBOARD) ? ReadCmd () : zloop (FALSE))) == NULL) {
		SETFLAG (fDisplay, RCURSOR);
		break;
            }
        }
	SETFLAG (fDisplay, RCURSOR);


        if ((PVOID)pFunc->func == (PVOID)newline ||
              (PVOID)pFunc->func == (PVOID)emacsnewl) {
            //
            //  newline functions: if allowed, terminate, else not allowed
            //  at all
            //
            if (!TESTFLAG(flags, GS_NEWLINE)) {
		bell ();
            } else {
                break;
            }
        } else if ((PVOID)pFunc->func == (PVOID)graphic ||
              (PVOID)pFunc->func == (PVOID)quote) {
            //
            //  graphic functions: place the graphic character into the
            //  response buffer. If erasing default response, then remove it
            //  from buffer.
            //
	    if (TESTFLAG(flags, GS_INITIAL)) {
		iRespCur = 0;
		memset ((char *) pb, '\0', sizeof(linebuf));
            }
            if (pFunc->func == quote) {
                while ((pFunc->arg = ReadCmd()->arg) == 0) {
                    ;
                }
            }
            if (fInsert) {
                memmove ((char*) pb+iRespCur+1, (char*)pb+iRespCur, sizeof(linebuf)-iRespCur-2);
            }
            pb[iRespCur++] = (char)pFunc->arg;
        } else if ((PVOID)pFunc->func == (PVOID)insertmode) {
            //
            //  insert command.
            //
	    insertmode (0, (ARG *) NULL, FALSE);
        } else if ((PVOID)pFunc->func == (PVOID)meta) {
            //
            //  meta command
            //
	    meta (0, (ARG *) NULL, FALSE);
        } else if ((PVOID)pFunc->func == (PVOID)left ||
              (PVOID)pFunc->func == (PVOID)cdelete ||
              (PVOID)pFunc->func == (PVOID)emacscdel) {
            //
            //  Cursor leftward-movement functions: update cursor position
            //  and optionally remove characters from buffer.
            //
	    if (iRespCur > 0) {
		iRespCur--;
                if ((PVOID)pFunc->func != (PVOID)left) {
                    if (fInsert) {
			memmove ( (char*) pb+iRespCur, (char*) pb+iRespCur+1, sizeof(linebuf)-iRespCur);
                    } else if (!pb[iRespCur+1]) {
			pb[iRespCur] = 0;
                    } else {
                        pb[iRespCur] = ' ';
                    }
                }
            }
        } else if ((PVOID)pFunc->func == (PVOID)right) {
            //
            //  Cursor right movement functions: update cursor position, and
            //  possibly get characters from current display.
            //
	    if (pFileHead && pb[iRespCur] == 0) {
		fInsSpace (xbeg+iRespCur, YCUR(pInsCur), 0, pFileHead, buf);
		pb[iRespCur] = buf[xbeg+iRespCur];
		pb[iRespCur+1] = 0;
            }
            iRespCur++;
        } else if ((PVOID)pFunc->func == (PVOID)begline ||
              (PVOID)pFunc->func == (PVOID)home) {
            //
            //  Home function: update cursor position
            //
	    iRespCur = 0;
        } else if ((PVOID)pFunc->func == (PVOID)endline) {
            //
            //  End function: update cursor position
            //
            iRespCur = strlen (pb);
        } else if ((PVOID)pFunc->func == (PVOID)delete ||
              (PVOID)pFunc->func == (PVOID)sdelete) {
            //
            //  Delete function: remove character
            //
            memmove ( (char*) pb+iRespCur, (char*) pb+iRespCur+1, sizeof(linebuf)-iRespCur);
        } else if ((PVOID)pFunc->func == (PVOID)insert ||
              (PVOID)pFunc->func == (PVOID)sinsert) {
            //
            //  Insert function: insert space
            //
	    memmove ( (char*) pb+iRespCur+1, (char*) pb+iRespCur, sizeof(linebuf)-iRespCur-1);
            pb[iRespCur] = ' ';
        } else if((PVOID)pFunc->func == (PVOID)doarg) {
            //
            //  Arg function: clear from current position to end
            //  of response.
            //
	    memset ((char *) pb+iRespCur, '\0', sizeof(linebuf) - iRespCur);
        } else if ((PVOID)pFunc->func == (PVOID)pword) {
            //
            //  Pword function: mive roght until the char to the left of
            //  the cursor is not part of a word, but the char under the
            //  cursor is.
            //
	    while (pb[iRespCur] != 0) {
		iRespCur++;
                if (!ISWORD (pb[iRespCur-1]) && ISWORD (pb[iRespCur])) {
                    break;
                }
            }
        } else if ((PVOID)pFunc->func == (PVOID)mword) {
            //
            //  Mword function
            //
            while (iRespCur > 0) {
		if (--iRespCur == 0 ||
                    (!ISWORD (pb[iRespCur-1]) && ISWORD (pb[iRespCur]))) {
                    break;
                }
            }
        } else if (TESTFLAG (pFunc->argType, CURSORFUNC)) {
            //
            //  Other cursor movement function: not allowed, so beep.
            //
            bell ();
        } else {
            //
            //  All other functions: if new line required to terminate,
            //  then beep, otherwise terminate and return the
            //  function terminated with.
            //
            if ((PVOID)pFunc != (PVOID)NULL) {
                if (TESTFLAG(flags, GS_NEWLINE) && (PVOID)pFunc->func != (PVOID)cancel) {
		    bell ();
                } else {
                    break;
                }
            }

        }
	/*
	 * process here to truncate any potential buffer overruns
	 */
        if (!TESTFLAG(pFunc->argType, KEEPMETA)) {
            fMeta = FALSE;
        }
	pFunc = NULL;
	if (iRespCur > sizeof(linebuf) - 2) {
	    iRespCur = sizeof(linebuf) - 2;
	    pb[iRespCur+1] = 0;
	    bell ();
        }
	RSETFLAG(flags, GS_INITIAL);
    }

    fMeta = fMetaTextArg ^ fMeta;
    return pFunc;
}




/*** ScrollOut - Update dialog line
*
*  Place a prompt, and a portion of the users response, onto the dialog of the
*  screen. Update the cursor position to the requested position relative to
*  the begining of the users response. Always ensure that that cursor position
*  is within the text actually displayed.
*
* Input:
*  szPrompt	- Text of prompt
*  szResp	- Text of users response
*  xCursor	- Current X position within reponse that is to get cursor
*  coResp	- Color to display response as
*  fVisible	- Forces display
*
* Globals:
*  hscroll	- Horizontal scroll amount
*  infColor	- Color that prompt will be displayed with
*  slSize	- Version 1 only, contains line on screen for output.
*
* Output:
*  Dialog line updated.
*
*************************************************************************/
void
ScrollOut (
    char     *szPrompt,                      /* prompt text                  */
    char     *szResp,                        /* users response string        */
    int      xCursor,                        /* Current pos w/in response    */
    int      coResp,                         /* response color               */
    flagType fVisible                        /* force display                */
    ) {

    int     cbPrompt;			/* length of the prompt string	*/
    int     cbResp;			/* length of the text displayed */
    int     cbDisp;			/* This position must be disp'd */
    int     xOff;			/* offset of string trailer	*/

#define LXSIZE	 XSIZE

    if (!mtest () || mlast () || fVisible) {
	cbPrompt = strlen (szPrompt);
        cbResp   = strlen (szResp);

	/*
	 * The distance of the new cursor position is calculated from the
	 * left edge of the text to be displayed. If there is more text
	 * than there is window, we also adjust the left edge based on hscroll.
	 */
        if (xOff = max (xCursor - (LXSIZE - cbPrompt - 1), 0)) {
            xOff += hscroll - (xOff % hscroll);
        }

        cbDisp = min (LXSIZE-cbPrompt, cbResp-xOff);

	/*
	 * output the prompt, the reponse string in the requested color,
	 * if required blank what's left, and finally update the cursor
	 * position.
	 */
	vout (0, YSIZE, szPrompt, cbPrompt, infColor);
        vout (cbPrompt, YSIZE, (char *)(szResp + xOff), cbDisp, coResp);
        if (cbPrompt + cbDisp < LXSIZE) {
            voutb (cbPrompt + cbDisp, YSIZE, " ", 1, fgColor);
        }
        consoleMoveTo( YSIZE, xCursor-xOff+cbPrompt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\graphic.c ===
/*** graphic.c - simple single character editing
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"


struct cmdDesc cmdGraphic = {	"graphic",  graphic,	0, FALSE };

/*** graphic - Editor <graphic> function
*
* Purpose:
*   Inserts character in text at current cursor position. Delete
*   previously selected text if any.
*
* Input:
*   the usual
*
* Output:
*   TRUE if character successfully inserted (FALSE means line too long)
*
* Notes:
*
*************************************************************************/
flagType
graphic (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    delarg (pArg);
    return edit ( ((KEY_DATA *)&argData)->Ascii );

    fMeta;
}





/*** szEdit - insert a string at the current position.
*
* Purpose:
*   Inserts character in text at current cursor position.
*
* Input:
*   sz		= String to be entered
*
* Output:
*   FALSE if the line was too long, else true.
*
* Notes:
*
*************************************************************************/
flagType
szEdit (
    char *sz
    )
{
    while (*sz) {
        if (!edit (*sz++)) {
            return FALSE;
        }
    }
    return TRUE;
}





/*** edit
*
* Purpose:
*   Inserts character in text at current cursor position.
*
* Input:
*   c		= Character to be entered
*
* Output:
*   FALSE if the line was too long, else true.
*
* Notes:
*
*************************************************************************/
flagType
edit (
    char c
    )
{
    COL     dx;
    fl      fl;                             /* loc to place cursor at       */
    COL     tmpx;
    COL     x;

    /*
     * point at current location
     */
    fl.col = XCUR(pInsCur);
    fl.lin = YCUR(pInsCur);

    if (fWordWrap && xMargin > 0) {

        /*
         * if space entered just past right margin, then copy everything to the right
         * of the space to the next line.
         */
	if (c == ' ' && fl.col >= xMargin) {
	    tmpx = softcr ();
	    CopyStream (NULL, pFileHead, fl.col, fl.lin,
					 tmpx,	 fl.lin+1,
					 fl.col, fl.lin);
	    fl.lin++;
	    fl.col = tmpx;
	    cursorfl (fl);
	    return TRUE;
        } else if (fl.col >= xMargin + 5) {

	    /*	move backward to the beginning of the current word
	     *	and break it there.
	     *
	     *	Make sure we have a line that contains the cursor
	     */
            fInsSpace (fl.col, fl.lin, 0, pFileHead, buf);

	    /*	We'll go backwards to find the first place where
	     *	the char there is non-space and the char to
	     *	the left of it is a space.  We'll break the line at
	     *	that place.
	     */
            for (x = fl.col - 1; x > 1; x--) {
                if (buf[x-1] == ' ' && buf[x] != ' ') {
                    break;
                }
            }

	    /*	if we've found the appropriate word, break it there
	     */
	    if (x > 1) {
		dx = fl.col - x;
		tmpx = softcr ();
		CopyStream (NULL, pFileHead, x,    fl.lin,
					     tmpx, fl.lin + 1,
					     x,    fl.lin);
		fl.col = tmpx + dx;
		fl.lin++;
		cursorfl (fl);
            }
        }
    }

    if (Replace (c, fl.col, fl.lin, pFileHead, fInsert)) {
	right ((CMDDATA)0, (ARG *)NULL, FALSE);
	return TRUE;
    } else {
	LengthCheck (fl.lin, 0, NULL);
	return FALSE;
    }
}





/*** quote - Editor <quote> function
*
* Purpose:
*   Inserts character in text at current cursor position. Delete
*   previously selected text if any.
*
* Input:
*   the usual
*
* Output:
*   TRUE if character successfully inserted (FALSE means line too long)
*
*************************************************************************/
flagType
quote (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    char c;

    delarg (pArg);

    while ((c = (char)(ReadCmd()->arg)) == 0) {
        ;
    }
    return edit (c);

    argData; fMeta;
}




/*** delarg - deletes current selected area
*
* Purpose:
*   <graphic> and <quote> delete previously selected text. Here we do it
*
* Input:
*   pArg    pointer to current ARG structure
*
* Output:
*   None
*
* Notes:
*
*************************************************************************/
void
delarg (
    ARG * pArg
    )
{
    fl      fl;

    switch (pArg->argType) {

	case STREAMARG:
	    DelStream (pFileHead,
		       pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
		       pArg->arg.streamarg.xEnd,   pArg->arg.streamarg.yEnd   );
	    fl.col = pArg->arg.streamarg.xStart;
	    fl.lin = pArg->arg.streamarg.yStart;
            break;

	case LINEARG:
	    DelLine (TRUE, pFileHead,
		     pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd);
	    fl.col = 0;
	    fl.lin = pArg->arg.linearg.yStart;
            break;

	case BOXARG:
	    DelBox (pFileHead,
		       pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
		       pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom);
	    fl.col = pArg->arg.boxarg.xLeft;
	    fl.lin = pArg->arg.boxarg.yTop;
	    break;

	default:
	    return;
    }
    cursorfl(fl);
}





/*** Replace - edit character in a file
*
* Purpose:
*   Replace will take the specified character and place it into the
*   specified position in the specified file.  If the edit is a NOP
*   (overstriking the same character) then no modification takes place
*
* Input:
*   c		character to edit in file
*   x, y	column, row of file to be changed
*   pFile	file being modified
*   fInsert	TRUE => character is inserted before the position
*
* Output:
*    TRUE => line was successfully edited, FALSE => line was too long
*
* Notes:
*
*************************************************************************/
flagType
Replace (
    char    c,
    COL     x,
    LINE    y,
    PFILE   pFile,
    flagType fInsert
    )
{
    linebuf buf;                             /* working buffer               */
    struct  lineAttr rgla[sizeof(linebuf)];
    flagType fColor = FALSE, fSpace = 0;
    char    *pxLog;

    fColor = GetColor (y, rgla, pFile);

    if (fInsSpaceColor (x, y, fInsert ? 1 : 0, pFile, buf, fColor ? rgla : NULL)) {

        pxLog = pLog (buf, x, TRUE);

        if (cbLog(buf) <= x) {

            /*
             * If the logical length of the buffer is less than what we need, then it was
             * at least space filled by fInsert, and we just need to append our character
             * to the buffer
             */

            *(unsigned int UNALIGNED *)pxLog = (unsigned int)(unsigned char)c;

        } else if (fInsert || (*pxLog != c)) {

            /*
             * if we're inserting, or the character we're overtyping is different, place
             * the character. Be sure to check the new logical length of the line as well,
             * in case it was a tab that overflowed it.
             */

            *pxLog = c;
            if (cbLog(buf) >= sizeof(linebuf)) {
                return FALSE;
            }
        }

        if (fInsert) {
            MarkCopyBox (pFile, pFile, x, y, sizeof(linebuf), y, x+1, y);
        }

        PutLine (y, buf, pFile);
        if (fColor) {
            ColorToLog (rgla, buf);
            PutColor (y, rgla, pFile);
        }
        return TRUE;
    }
    return FALSE;
}





/*** curdate, curday and curtime - editting functions
*
* Purpose:
*  insert current day/date/time into text being editted
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE if text entered.
*
*************************************************************************/
flagType
curdate (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  buf;
    time_t    ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    sprintf (buf, "%.2s-%.3s-%.4s", s+8, s+4, s+20);
    return szEdit (buf);

    argData; pArg; fMeta;
}




flagType
curday (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  buf;
    time_t ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    sprintf (buf, "%.3s",s);
    return szEdit (buf);

    argData; pArg; fMeta;
}





flagType
curtime (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    buffer  buf;
    time_t ltime;
    char    *s;

    time (&ltime);
    s = ctime (&ltime);
    sprintf (buf, "%.8s",s+11);
    return szEdit (buf);


    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\fileio.c ===
/*** fileio.c - perform low-level file input and output
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#include "mep.h"

#include <rm.h>

int fdeleteFile( char *p );

/*  Large-buffer I/O routines
 *
 *  It is best for Z to read in data in large blocks.  The fewer times we
 *  issue system calls, the better.  The VM code has conveniently allocated
 *  us some large amount of space for us.  All we need to do is maintain
 *  a pointer to the next characters to read/write and a count of the number
 *  of characters in the buffer
 *
 *  The data structures used are:
 *
 *      char *getlbuf;
 *          This is a long pointer to the beginning of the buffer.
 *      char *getlptr;
 *          This is a long pointer to the next char position in the buffer.
 *      unsigned int getlsize;
 *          This is the length of the buffer in bytes.
 *
 *  The routines provided to access this are:
 *
 *      zputsinit ();
 *          Initializes for subsequent zputs's.
 *      zputs (buf, len, fh);
 *          Writes out from buf length len using getlbuf and fh.
 *          Returns EOF if no more room.
 *      zputsflush (fh);
 *          Flushes out the buffer.  Returns EOF if no more room.
 */

char         *getlbuf   = NULL;
char        *getlptr    = NULL;
// unsigned int    getlsize    = 0;
unsigned int    getlc       = 0;

// BUGBUG
//  FileExists is used because of problems with stat() and
//  FindFirstFile() which are not easily reproducible.
flagType FileExists (char  *path );

// BUGBUG
//  MepMove is used because FAT does not provide rename functionality
#define rename  MepMove
int MepMove ( char *oldname,   char *newname);



/*  zputsinit - initialize for future zputs's
 *
 *  Set next-char pointer to beginning.  Set count of chars to 0
 */
void
zputsinit (
    void
    )
{
    getlptr = getlbuf;
    getlc = 0;
}





/*** zputs - output a string
*
* Input:
*  p            = character pointer to data to be output
*  len          = number of bytes to output
*  fh           = DOS file handle to use
*
* Output:
*  Returns EOF if out-of-space
*
*************************************************************************/
int
zputs (
    char        *p,
    int         len,
    FILEHANDLE  fh
    )
{
    REGISTER unsigned int c;

    while (len != 0) {
        c = len;
        if (c > (unsigned)(getlsize-getlc)) {
            c = (unsigned)(getlsize-getlc);
        }
        memmove (getlptr, (char*)p, c);
        len -= c;
        getlptr += c;
        getlc += c;
        p += c;
        if (getlc == getlsize) {
            if (zputsflush (fh) == EOF) {
                return EOF;
            }
        }
    }
    return !EOF;
}





/*** zputsflush - dump out buffered data
*
* Input:
*  fh           = DOS file handle to use for output
*
* Output:
*  Returns EOF if disk full
*
*************************************************************************/
int
zputsflush (
    FILEHANDLE     fh
    )
{

    ULONG   bytesWritten;

    // rjsa DosWrite (fh, getlbuf, getlc, &bytesWritten);
    bytesWritten = MepFWrite(getlbuf, getlc, fh);
    if (bytesWritten != getlc) {
        return EOF;
    }
    zputsinit ();
    return !EOF;
}





/* ReestimateLength - reestimate the length of a file based on
 * the current file position and length in bytes
 */
void
ReestimateLength (
    PFILE       pFile,
    FILEHANDLE  fh,
    long        len
    )
{
    LINE avg;

    if (pFile->cLines == 0) {
        avg = 400;
    } else {
        avg = (MepFSeek (fh, 0L, FROM_CURRENT) - getlc) / pFile->cLines;
        avg = len / avg;
    }

    growline (avg + 1, pFile);
}





/* read lines from the specified handle.
 */
LINE
readlines (
    PFILE       pFile,
    FILEHANDLE  fh
    )
{
    LINE    line        = 0;            /* line number being read in          */
    long    bufpos      = 0L;           /* position of beg of buffer in file  */
    unsigned int buflen = 0;            /* number of bytes of data in buffer  */
    long    cbFile;                     // length of file
    char    *pb;


    cbFile = MepFSeek(fh, 0L, FROM_END);

    MepFSeek (fh, 0L, FROM_BEGIN);

    pFile->pbFile = MALLOC (cbFile);

    if ( pFile->pbFile == NULL ) {
        //
        //      No heap space, cannot read file
        //
        disperr (MSGERR_NOMEM);
        return -1;
    }

    //  Assume a non-dos file until we see a CR-LF.
    RSETFLAG (FLAGS (pFile), DOSFILE);

    //  Read entire file into buffer and set up for scan
    buflen = MepFRead (pFile->pbFile, cbFile, fh);
    pb = pFile->pbFile;

    //  Loop, while there's more data to parse
    while (buflen != 0) {
        LINEREC vLine;                  // line record of current line
        REGISTER int iCharPos = 0;      // logical line length (tabs expanded)

        vLine.cbLine   = 0;
        vLine.vaLine   = (PVOID)pb;
        vLine.Malloced = FALSE;

        //  Loop, processing each character in the line
        //
        //  Special char handling is as follows:
        //  0.  Lines are broken at end of input
        //  1.  Lines are broken when they overflow line buffers
        //  2.  Lines are broken at \n's or \r\n's.
        //  3.  Lines are broken at \0's since the editor relies on asciiz
        //  4.  Embedded \r's are retained.

        while (TRUE) {
            int c;                      // char being processed

            //  if no more data, break current line.
            if (buflen == 0)
                break;

            //  if \n or \0 then eat it and break current line
            if (pb[0] == '\n' || pb[0] == '\0') {
                pb++;
                buflen--;
                break;
                }

            //  if \r\n then eat them and break current line
            if (pb[0] == '\r' && buflen > 1 && pb[1] == '\n') {
                pb += 2;
                buflen -= 2;
                SETFLAG (FLAGS (pFile), DOSFILE);
                break;
                }

            //  if no more room to expand in a buffer, break current line
            if (iCharPos >= sizeof (linebuf)-1)
                break;

            //  Get current character
            c = *pb++;
            buflen--;

            //  We have a character that we allow in the
            //  line.  Advance length of logical line.
            if (c != 0x09)
                iCharPos++;
            else {
                //  Expand a tab to the next logical position
                iCharPos += 8 - (iCharPos & 7);

                //  if the tab causes overflow in the line length
                //  back up over the tab and break the line
                if (iCharPos >= sizeof(linebuf)-1) {
                    pb--;
                    buflen++;
                    break;
                }
            }

            //  Advance length of physical line
            vLine.cbLine++;
        }

        //  If the user halted reading the file in, undo everything
        if (fCtrlc) {
            FlushInput ();
            DelFile (pFile, FALSE);
            return -1;
        }

        //  Give the user feedback about our progress
        noise (line);

        //  If we're within 10 lines of the end of the line array then
        if (line >= pFile->lSize-10) {
            LINE avg;
            //  reestimate the number of lines

            if (pFile->cLines == 0)
                //  Assume 400 lines if the file is now empty
                avg = 400;
            else {
                //  compute average line length so far
                avg = (int)(pb - pFile->pbFile) / pFile->cLines;

                //  extrapolate number of lines in entire file from this
                //  average
                avg = cbFile / avg;
            }
            growline (avg + 1, pFile);
        }

        if (pFile->cLines <= line) {
            growline (line+1, pFile);
            pFile->cLines = line+1;
        }

        pFile->plr[line++] = vLine;
    }

    if (line == 0)
        SETFLAG (FLAGS (pFile), DOSFILE);

    RSETFLAG (FLAGS(pFile), DIRTY);
    newscreen ();
    return line;
}





/*** FileRead - read in a file
*
*  The file structure is all set up; all that needs to be done is to fill in
*  the lines parts. We delete everything currently in the file. If the file
*  is designated as a pseudo file (first char is a <), then we go and check
*  for the specially named files. Otherwise we try to read in the file. If
*  that fails, and we can, we try to create it. If everything fails, we
*  return FALSE.
*
* Input:
*  name         = pointer to file name to read
*  pFile        = file structure to read the file into.
*  fAsk         = TRUE -> ask to create if it doesn't exist
*
* Output:
*  Returns TRUE on read in.
*  Modifies global fUserCanceledRead
*
* Notes:
*  Hack (terrible one): Under CW, FileRead sets fUserCanceledRead anytime
*  there has been an attempt to read a non existent file AND the user
*  has been prompted for file creation AND the user canceled the operation
*
*  This is used by fFileAdvance (ZEXIT.C) and ReadStateFile (STATFILE.C)
*
*************************************************************************/
flagType
FileRead (
    char    *name,
    PFILE   pFile,
    flagType fAsk
    )
{

    EVTargs     e;
    FILEHANDLE  fh;
    flagType    fNew = FALSE;
    char        *n;
    buffer      Buf;

    assert (pFile);


    e.pfile = pFile;
    e.arg.pfn = (char *)name;
    if (DeclareEvent (EVT_FILEREADSTART, (EVTargs *)&e)) {
        return TRUE;
    }

    if (!mtest ()) {
        dispmsg (MSG_NEXTFILE, name);
    }

    /* process special names */
    if (*name == '<') {
        fNew = LoadFake (name, pFile);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return fNew;
    }

    DelFile (pFile, FALSE);

    if (*strbscan (name, "?*") != 0) {
        fNew = LoadDirectory (name, pFile);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return fNew;
    }

    if ((fh = MepFOpen (name, ACCESSMODE_READ, SHAREMODE_RW, FALSE)) == NULL) {
        if (!fAsk) {
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        if (!confirm ("%s does not exist. Create? ", name)) {
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        if ((fh = MepFOpen (name, ACCESSMODE_WRITE, SHAREMODE_RW, TRUE)) == NULL) {
            n = name;
            if ( strlen(name) > 20 ) {
                strcpy( Buf, name + strlen(name)-20);
                Buf[0] = Buf[1] = Buf[2] = '.';
                n = Buf;
            }
            disperr (MSGERR_NOCREAT, n, error ());
            DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
            return FALSE;
        }
        SETFLAG (FLAGS (pFile), NEW);
        fNew = TRUE;
    }

    if (fNew) {
        PutLine((LINE)0, RGCHEMPTY, pFile);
        SETFLAG (FLAGS (pFile), DOSFILE);
    } else if (readlines (pFile, fh) == -1)  {
        DoCancel();
        MepFClose (fh);
        DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);
        return FALSE;
    }

    MepFClose (fh);
    SETFLAG (FLAGS(pFile), REAL);
    RSETFLAG (FLAGS(pFile), READONLY);

    if (fReadOnly (name)) {
        SETFLAG (FLAGS(pFile), DISKRO);
        if (!fEditRO) {
            SETFLAG (FLAGS(pFile), READONLY);
        }
    } else {
        RSETFLAG (FLAGS(pFile), DISKRO);
    }

    SetModTime (pFile);
    CreateUndoList (pFile);
    (void)fReadMarks (pFile);

    DeclareEvent (EVT_FILEREADEND, (EVTargs *)&e);

    return TRUE;
}





/*  fReadOnly - see if a file is read-only
 *
 *  p           full name of file
 *
 *  Returns:    TRUE iff file is read only
 */
flagType
fReadOnly (
    char *p
    )
{

    DWORD   Attr;

    Attr = GetFileAttributes(p);

    if ( Attr != -1 && (Attr & FILE_ATTRIBUTE_READONLY) != 0)
        return TRUE;
    else
        return FALSE;
}


int
__cdecl
ZFormatArgs (REGISTER char * Buf, const char * Format, ...)
{
    va_list arglist;
    int result;

    va_start (arglist, Format);
    result = ZFormat (Buf, Format, arglist);
    va_end (arglist);
    return result;
}

/*** FileWrite - Write file to disk
*
*  Writes out the specified file. If no name was given then use the name
*  originally assigned to the file; else use the given name. We start by
*  writing to a temp file (extention .$). If this succeeds, we fdelete the
*  source (for undeleteability) and rename the temp to the source.
*
* Input:
*  savename     = name to save as.
*  pFile        = file to be saved
*
* Returns:
*
*************************************************************************/
flagType
FileWrite (
    char    *savename,
    PFILE   pFile
    )
{

    EVTargs     e;
    FILEHANDLE  fh;                            /* file handle for output       */
    LINE        i;
    int         len, blcnt;
    pathbuf     fullname, tmpname;
    char        linebuffer[sizeof(linebuf) + 2];
    char        *p;
    PCMD        pCmd;
    flagType    fNewName  = FALSE;
    char        *fileEOL;
    int         cbfileEOL;

    //
    //  If we are trying to save a FAKE file with a <name>,
    //  we call SaveFake for special processing.
    //

    if (TESTFLAG (FLAGS(pFile), FAKE) && !savename &&
        (pFile->pName[0] == '\0' || pFile->pName[0] == '<')) {
        return SaveFake (pFile->pName, pFile);
    }

    //if (TESTFLAG (FLAGS(pFile), FAKE) && savename &&
    //(savename[0] == '\0' || savename[0] == '<'))
    //    return SaveFake (savename, pFile);

    //
    //  get a canonical form of the output file name.  If no name was
    //  input, use the name in the file itself
    //

    if (!savename || !*savename) {
        strcpy (fullname, pFile->pName);
    } else  if (rootpath (savename, fullname)) {
        return disperr (MSGERR_OPEN, savename, "");
    }

    savename = fullname;

    //
    // See if it is a directory.  If so, we cannot save to it.
    //

    {
        DWORD att = GetFileAttributes (fullname);

        if (att != -1 && TESTFLAG (att, FILE_ATTRIBUTE_DIRECTORY))
        return disperr (MSGERR_SAVEDIR, fullname);
    }

    //
    //  If the file is read-only, display a message and let the user direct
    //  us to use the readonly program to rectify it.
    //

    if (fReadOnly (fullname)) {
        disperr (MSGERR_RONLY, fullname);
        if (ronlypgm != NULL) {
            if (strstr (ronlypgm, "%s") != NULL) {
                fileext (fullname, buf);
                sprintf (tmpname, ronlypgm, buf);
                }
            else
                ZFormatArgs (tmpname, ronlypgm, fullname);
            if (confirm("Invoke: \"%s\" (y/n)?", tmpname))
                if (zspawnp (tmpname, TRUE))
                    SetModTime (pFile);
            }

        //
        //  We've given the user one chance to fix the read-onlyness of the
        //  file.  We now prompt him until he gives us a writeable name or
        //  cancels.
        //
    if ( !savename || !*savename ) {
        strcpy( tmpname, pFile->pName );
    } else {
        strcpy( tmpname, savename );
    }
    //tmpname[0] = '\0';
    while (fReadOnly (fullname)) {

        pCmd = getstring (tmpname, "New file name: ", NULL,
                              GS_NEWLINE | GS_INITIAL | GS_KEYBOARD);

            if ( pCmd == NULL || (PVOID)pCmd->func == (PVOID)cancel)
                return FALSE;

            CanonFilename (tmpname, fullname);

            if (!TESTFLAG(FLAGS(pFile), FAKE))
                fNewName = TRUE;
            }
        }

    //
    //  fullname is the name of the file we are writing
    //

    upd (fullname, ".$", tmpname);

    //
    //  Send notification about the beginning of the write operation
    //

    e.pfile = pFile;
    e.arg.pfn = (char *)savename;
    if (DeclareEvent (EVT_FILEWRITESTART, (EVTargs *)&e))
        return TRUE;


    if (!(fh = MepFOpen(tmpname, ACCESSMODE_RW, SHAREMODE_READ, FALSE))) {
        if (!(fh = MepFOpen(tmpname, ACCESSMODE_RW, SHAREMODE_READ, TRUE))) {
            disperr (MSGERR_OPEN, tmpname, error ());
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
        }
    }

    dispmsg (MSG_SAVING, fullname);
    blcnt = 0;
    zputsinit ();
    fileEOL = TESTFLAG (FLAGS (pFile), DOSFILE) ? "\r\n" : "\n";
    cbfileEOL = strlen (fileEOL);

    for (i = 0; i < pFile->cLines; i++) {

        /*
         * always get the RAW line for output. No tab conversions here.
         */

        len = gettextline (TRUE, i, linebuffer, pFile, ' ');

        if (!mtest ()) {
            noise (i);
        }

        if (fCtrlc) {
            DoCancel();
            MepFClose (fh);
            _unlink (tmpname);
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
        }

        if (len) {
            while (blcnt--) {
                if (zputs (fileEOL, cbfileEOL, fh) == EOF) {
                    if (!fCtrlc) {
                        disperr (MSGERR_SPACE, tmpname);
                    } else {
                        FlushInput ();
                    }
                    MepFClose (fh);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            blcnt = 0;
            if (zputs (linebuffer, len, fh) == EOF ||
                zputs (fileEOL, cbfileEOL, fh) == EOF) {

                if (!fCtrlc)
                    disperr (MSGERR_SPACE, tmpname);
                else
                    FlushInput ();
                MepFClose (fh);
                _unlink (tmpname);
                DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                return FALSE;
            }
        } else {
            blcnt++;
        }
    }

    if (zputsflush (fh) == EOF) {

        if (!fCtrlc) {
            disperr (MSGERR_SPACE, tmpname);
        } else {
            FlushInput ();
        }

        MepFClose (fh);
        _unlink (tmpname);
        DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
        return FALSE;
    }

    MepFClose (fh);

    /* fullname     NAME.EXT
     * tmpname      NAME.$
     * buf          temp buffer
     */
    rootpath (fullname, buf);
    strcpy (fullname, buf);

    /* fullname     full NAME.EXT
     * tmpname      NAME.$
     * buf          temp buffer
     */
    if (!_strcmpi (fullname, pFile->pName) && TESTFLAG (FLAGS (pFile), NEW)) {
        if (_unlink (fullname) == -1) {
            fileext (fullname, fullname);
            disperr (MSGERR_DEL, fullname, error ());
            _unlink (tmpname);
            DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
            return FALSE;
            }
        }
    else {
        switch (backupType) {

        case B_BAK:
            upd (fullname, ".bak", linebuffer);
            /* foo.bar => foo.bak */
            if (_unlink (linebuffer) == -1) {
                p = error ();
                if (FileExists(linebuffer)) {
                    fileext (linebuffer, linebuffer);
                    disperr (MSGERR_DEL, linebuffer, p);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            if (rename (fullname, linebuffer) == -1) {
                p = error ();
                if (FileExists(fullname)) {
                    disperr (MSGERR_REN, fullname, linebuffer, p);
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    return FALSE;
                }
            }
            break;

        case B_UNDEL:
            /* remove foo.bar */
            i = fdeleteFile (fullname);
            if (i && i != 1) {
                _unlink (tmpname);
                DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                return disperr (MSGERR_OLDVER, fullname);
            }

        case B_NONE:
            if (_unlink (fullname) == -1) {
                p = error ();
                if (FileExists(fullname)) {
                    _unlink (tmpname);
                    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
                    fileext (fullname, fullname);
                    return disperr (MSGERR_DEL, fullname, p);
                    }
                }
            }
        }

    if (rename (tmpname, fullname) == -1) {
        disperr (MSGERR_REN, tmpname, fullname, error ());
        _unlink (tmpname);
        DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);
        return FALSE;
    }

    RSETFLAG (FLAGS (pFile), NEW);

    if (!_strcmpi (savename, pFile->pName) || fNewName) {
        if (fNewName) {
            /*
             * We gave a new name to this file and successfully saved it:
             * this becomes the new file's name
             */
            FREE (pFile->pName);
            pFile->pName = ZMakeStr (fullname);
        }
        RSETFLAG (FLAGS(pFile), (DIRTY | DISKRO));
        SETFLAG (fDisplay,RSTATUS);
        SetModTime( pFile );
    }

    WriteMarks (pFile);
    DeclareEvent (EVT_FILEWRITEEND, (EVTargs *)&e);

    return TRUE;
}




/* fdeleteFile - Remove file the way RM does it - checks for undelcount
 *
 *      This code is extracted from Ztools. the only difference being that this
 *      checks for undelcount so our deleted stuff don't grow without bounds
 *
 * The delete operation is performed by indexing the file name in a separate
 * directory and then renaming the selected file into that directory.
 *
 * Returns:
 *
 *  0 if fdelete was successful
 *  1 if the source file did not exist
 *  2 if the source was read-only or if the rename failed
 *  3 if the index was not accessable
 */
int
fdeleteFile(
        char *p
    )
{
        char dir[MAXPATHLEN];                   /* deleted directory            */
        char idx[MAXPATHLEN];                   /* deleted index                        */
        char szRec[MAXPATHLEN];                 /* deletion entry in index      */
        char recbuf[MAXPATHLEN];
        int attr, fhidx;
        int errc;
        int count,c;

    fhidx = -1;

        //
        //      See if the file exists
        //
        if( ( attr = GetFileAttributes( p ) ) == -1) {
                errc = 1;
                goto Cleanup;
        }

        //
        //      What about read-only files?
        //
        if (TESTFLAG (attr, FILE_ATTRIBUTE_READONLY)) {
                errc = 2;
                goto Cleanup;
        }

        //
        //      Form an attractive version of the name
        //
    pname (p);

        //
        // generate deleted directory name, using defaults from input file
        //
    upd (p, RM_DIR, dir);

        //
        //      Generate index name
        //
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);

        //
        // make sure directory exists (reasonably)
        //
        if( _mkdir (dir) == 0 ) {
                SetFileAttributes(dir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
        }

        //
        // extract filename/extention of file being deleted
        //
    fileext (p, szRec);

        //
        // try to open or create the index
        //
    if ((fhidx = _open (idx, O_CREAT | O_RDWR | O_BINARY,
                           S_IWRITE | S_IREAD)) == -1) {
                errc = 3;
                goto Cleanup;
        }

        if (!convertIdxFile (fhidx, dir)) {
                errc = 3;
                goto Cleanup;
    }

        //
        // scan the index and count how many copies of this file already exist
        //
        for (count=c=0; readNewIdxRec( fhidx, recbuf, c++ ); ) {
                if ( !strcmp( szRec, recbuf )) {
                        count++;
                }
        }

    if (count < cUndelCount) {

                //
                //      Determine new name
                //
                sprintf (strend (dir), "\\deleted.%03x",
                         _lseek (fhidx, 0L, SEEK_END) / RM_RECLEN);

                //
                //      Move the file into the directory
                //
                _unlink (dir);

                if (rename(p, dir) == -1) {
                        errc = 2;
                        goto Cleanup;
                }

                //
                //      Index the file
                //
                if (!writeNewIdxRec (fhidx, szRec)) {
                        rename( dir, p );
                        errc = 2;
                        goto Cleanup;
                }
        } else {

                char buf1[MAXPATHLEN], buf2[MAXPATHLEN], *p1;

                strcpy (buf1, dir);
                strcat (buf1, "\\deleted.");
                p1 = strend (buf1);
                *buf2 = 0;

                _lseek( fhidx, 0L, SEEK_SET );

                for ( count=c=0; readNewIdxRec( fhidx, recbuf, c++ ); count++ ) {
                        if (!strcmp ( szRec, recbuf)) {
                                sprintf (p1, "%03x", count);
                if (! *buf2) {
                                        _unlink (buf1);
                } else {
                    rename (buf1, buf2);
                }
                                strcpy (buf2, buf1);
            }
        }
                rename (p, buf2);
        }

        errc = 0;

Cleanup:
        if ( fhidx != -1 ) {
                _close(fhidx);
        }

        return errc;
}




/*  SetBackup - assign the mode of file backup
 *
 *  This is called during initialization to set the backup type
 *
 *  val         char pointer to "undel", "none", "bak"
 *
 *  If any errors are found, SetBackup will return FALSE otherwise it returns
 *  TRUE.
 */
char *
SetBackup (
    char *val
    )
{
    buffer  bufLocal;

    strcpy ((char *) bufLocal, val);
    _strlwr (bufLocal);

    if (!strcmp (bufLocal, "undel")) {
        backupType = B_UNDEL;
    } else if (!strcmp (bufLocal, "bak")) {
        backupType = B_BAK;
    } else if (!strcmp (bufLocal, "none")) {
        backupType = B_NONE;
    } else {
        return "Backup type must be one of 'undel', 'bak or 'none'";
    }

    return NULL;
}





/*  SetFileTab - set the spacing of tab characters in the file
 *
 *  This is called during initialization to set the number of spaces per
 *  file tab character for output display.  This is for people
 *  who presume that 0x09 is not on 8-character boundaries.  The legal
 *  range for this value is 1-8.
 *
 *  val         char pointer to remainder of assignment
 *
 *  If any errors are found, SetFileTab will return FALSE, otherwise it returns
 *  TRUE.
 */
char *
SetFileTab (
    char *val
    )
{
    int i;
    buffer tmpval;

    strcpy ((char *) tmpval, val);

    i = atoi (tmpval);

    if (i < 1 || i > 8) {
        return "filetab: Value must be between 1 and 8";
    }

    fileTab = i;
    newscreen ();
    return NULL;
}





/*  SetROnly - set the read-only program
 *
 *  This is called during initialization to set the program called when
 *  trying to write a read-only program.
 *
 *  val         char pointer to remainder of assignment
 *
 *  If any errors are found, SetROnly will return FALSE, otherwise it returns
 *  TRUE.
 */
flagType
SetROnly (
    char *pCmd
    )
{

    if (ronlypgm != NULL)
        FREE (ronlypgm);

    if (strlen (pCmd) != 0)
        ronlypgm = ZMakeStr (pCmd);
    else
        ronlypgm = NULL;

    return TRUE;
}





/*  SortedFileInsert - take the passed in line and insert it into the file
 *
 *  pFile       file for insertion
 *  pStr        pointer to string
 */
void
SortedFileInsert (
    PFILE pFile,
    char *pStr
    )
{
    linebuf buf;
    LINE    hi, lo, mid;
    int     d;

    hi = pFile->cLines-1;
    lo = 0;

    while (lo <= hi) {
        mid = (hi + lo) / 2;
        GetLine (mid, buf, pFile);
        d = strcmp (pStr, buf);
        if (d < 0) {
            hi = mid - 1;
        } else if (d == 0) {
            return;
        } else {
            lo = mid + 1;
        }
    }

    /*  lo is the line # for insertion
     */
    InsertLine (lo, pStr, pFile);
}





struct ldarg {
    PFILE pFile;
    int   linelen;
    };


/*  LoadDirectoryProc - take enumerated file and place into file
 *
 *  szFile      pointer to file name to place into file
 *  pfbuf       pointer to find buffer
 *  pData       pointer to data for insertion
 */
void
LoadDirectoryProc (
    char * szFile,
    struct findType *pfbuf,
    void *pData
    )
{
    struct ldarg *pldarg = (struct ldarg *)pData;

    pldarg->linelen = max (pldarg->linelen, (int)strlen(szFile));
    SortedFileInsert (pldarg->pFile, szFile);

    pfbuf;
}





/*  LoadDirectory - load the matching contents of the name into a fake file.
 *
 *  name        matching pattern for files
 *
 *  Returns:    TRUE always
 */

static char szNoMatchingFiles[] = "No matching files";

flagType
LoadDirectory (
    char *fname,
    PFILE pFile
    )
{
    struct ldarg ldarg;

    ldarg.linelen = 0;
    ldarg.pFile = pFile;

    /*  Make sure undo believes that this file is fake.
     */
    SETFLAG (FLAGS(pFile), FAKE + REAL);

    /*  We walk the matching files, entering the names into the file one at
     *  a time in sorted order and, at the same time, determine the max string
     *  length.
     *  We then use CopyBox to collapse the file.
     */

    /*  Enumerate all lines into file
     */
    forfile ((char *)fname, A_ALL, LoadDirectoryProc, &ldarg);

    /*  If file is empty, note it
     */
    if (pFile->cLines == 0) {
        AppFile (szNoMatchingFiles, pFile);
    } else {

        /*  File is pFile->cLines long with a max line len of
         *  ldarg.linelen.  Since we are gathering the thing in columns
         *  we will have pwinCur->xSize / (ldarg.linelen + 2) columns, each of
         *  which will have pFile->cLines / # cols lines.
         */
        int ccol;
        LINE cline, i;

        ccol = max (WINXSIZE(pWinCur) / (ldarg.linelen + 2), 1);
        cline = (pFile->cLines + ccol - 1) / ccol;
        ldarg.linelen = WINXSIZE(pWinCur) / ccol;

        /*  Now, for each of the columns, copy them into position.  Remember
         *  that one column is ALREADY in position.
         */
        for (i = 1; i < ccol; i++) {
            /*  copy lines cline..2*cline - 1
             *  columns 0..ldarg.linelen  to
             *  line 0, column ldarg.linelen*i
             */
            CopyBox (pFile, pFile, 0,                       cline,
                                   ldarg.linelen-1,         2 * cline - 1,
                                   ldarg.linelen * (int) i, (LINE)0);
            DelLine (TRUE, pFile, cline, 2 * cline - 1);
        }
    }
    RSETFLAG (FLAGS(pFile), DIRTY);
    return TRUE;
}





/*  LoadFake - load a fake or pseudo file into memory.  Fake files are used
 *  for two purposes:  as temporary buffers or for information displays.
 *
 *  name        name of pseudo file
 *
 *  Returns:    TRUE always.
 */
flagType
LoadFake (
    char *name,
    PFILE pFile
    )
{
    SETFLAG (FLAGS(pFile), FAKE | REAL | REFRESH | DOSFILE);
    if (!strcmp (name, rgchInfFile)) {
        showinf (pFile);
    } else if (!strcmp (name, rgchAssign)) {
        showasg (pFile);
    } else if (!strcmp (name, "<environment>")) {
        showenv (pFile);
    } else {
         RSETFLAG (FLAGS(pFile), REFRESH);
    }
    return TRUE;
}




/*** SaveFake - "Save" a pseudo-file.  Meaning depends on file
*
* Purpose:
*
*   In some cases, "saving" a pseudo-file means something.  Currently
*   we have:
*
*       <assign> - Update changed lines to TOOLS.INI.
*
* Input:
*   savename -
*   pFile    -
*
* Output:
*
*   Returns TRUE if file was saved, FALSE if not
*
*************************************************************************/
flagType
SaveFake (
    char * savename,
    PFILE pFile
    )
{
    struct  lineAttr rnBuf[10];
    LINE    l;

    if (!_stricmp (pFile->pName, rgchAssign)) {
        for (l = 0; l < pFile->cLines; l++) {
            if (GetColor (l, rnBuf, pFile)) {
                GetLine (l, buf, pFile);
                UpdToolsIni (buf);
                DelColor (l, pFile);
                redraw (pFile, l, l);
            }
        }
    } else {
        return FALSE;
    }

    return TRUE;

    savename;
}





/*** SaveAllFiles - Find all dirty files and save them to disk
*
* Purpose:
*
*   To save all dirty files, of course.
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
SaveAllFiles (
    void
    )
{
    PFILE pFile;
    int i;

    i = 0;
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY) {
            FileWrite (NULL, pFile);
            i++;
            }
        }

    domessage ("Save %d files", i);

}




FILEHANDLE
MepFOpen (
    LPBYTE      FileName,
    ACCESSMODE  Access,
    SHAREMODE   Share,
    BOOL        fCreate
    )
{
    FILEHANDLE  Handle;

    Handle = CreateFile(FileName, Access, Share, NULL, OPEN_EXISTING, 0, NULL);
    if ((Handle == INVALID_HANDLE_VALUE) && fCreate) {
        Handle = CreateFile(FileName, Access, Share, NULL, CREATE_NEW,
                             FILE_ATTRIBUTE_NORMAL, NULL);
    }
    if (Handle == INVALID_HANDLE_VALUE) {
        return (HANDLE)0;
    } else {
        return Handle;
    }
}




void
MepFClose (
    FILEHANDLE Handle
    )
{
    CloseHandle(Handle);
}



DWORD
MepFRead (
    PVOID       pBuffer,
    DWORD       Size,
    FILEHANDLE  Handle
    )
{
    DWORD BytesRead;
    if ( !ReadFile(Handle, pBuffer, Size, &BytesRead, NULL) ) {
        return 0;
    } else {
        return BytesRead;
    }
}




DWORD
MepFWrite (
    PVOID       pBuffer,
    DWORD       Size,
    FILEHANDLE  Handle
    )
{
    DWORD BytesWritten;

    if ( !WriteFile(Handle, pBuffer, Size, &BytesWritten, NULL) ) {
        return 0;
    } else {
        return BytesWritten;
    }
}


DWORD
MepFSeek (
    FILEHANDLE  Handle,
    DWORD       Distance,
    MOVEMETHOD  MoveMethod
    )
{
    assert (Handle != INVALID_HANDLE_VALUE);
    return SetFilePointer(Handle, Distance, NULL, MoveMethod);
}






flagType
FileExists (
    char    *path
    )
{
    return (flagType)((GetFileAttributes(path) == -1) ? FALSE : TRUE);
}


//
//  rename may be defined as MepMove, but now we want the real one, so
//  we undefine it.
//
#ifdef rename
#undef rename
#endif

int MepMove (
     char *oldname,
     char *newname
    )
{
    #define BUFFERSIZE (1024 * 32)

    FILE    *fhSrc, *fhDst;
    void    *buffer;
    size_t  BytesRead;
    size_t  BytesWritten;


    if (FileExists (newname)) {
        return -1;
    }

    //
    //  First, try the rename
    //
    if (rename(oldname, newname) == 0) {
        return 0;
    }

    //
    //  Cannot rename, try to copy
    //
        if (!(fhSrc = fopen(oldname, "r"))) {
                return -1;
        }

        if (!(fhDst = fopen(newname, "w"))) {
                fclose(fhSrc);
                return -1;
        }

    buffer = MALLOC(BUFFERSIZE);
    if ( !buffer ) {
        disperr (MSGERR_NOMEM);
        return -1;
    }

    do {
        BytesRead       = fread(buffer, 1, BUFFERSIZE, fhSrc);
        if (BytesRead) {
            BytesWritten    = fwrite(buffer, 1, BytesRead, fhDst);
        }

    } while (BytesRead);

    fclose(fhSrc);
    fclose(fhDst);

    FREE(buffer);

    return _unlink(oldname);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\linsert.c ===
/*** linsert.c - line insert
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#include "mep.h"


flagType
linsert (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    linebuf lbuf;
    int l;

    if (pArg->argType == STREAMARG) {
        StreamToBox (pArg);
    }

    switch (pArg->argType) {
    case NOARG:
	CopyLine (NULL, pFileHead, pArg->arg.noarg.y, pArg->arg.noarg.y,
				   pArg->arg.noarg.y);
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	GetLine (pArg->arg.nullarg.y, lbuf, pFileHead);
	strcpy (lbuf, whiteskip (lbuf));
	l = strlen (lbuf) + 1;
        if (l + pArg->arg.nullarg.x > sizeof(linebuf)) {
            LengthCheck (pArg->arg.nullarg.y, 0, NULL);
        }
	memmove ((char *) lbuf + pArg->arg.nullarg.x,(char *) lbuf, 
	      sizeof(linebuf) - l - pArg->arg.nullarg.x);
	memset ((char *) lbuf, ' ', pArg->arg.nullarg.x);
	PutLine (pArg->arg.nullarg.y, lbuf, pFileHead);
        return TRUE;

    case LINEARG:
	CopyLine (NULL, pFileHead, pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd,
				   pArg->arg.linearg.yStart);
        return TRUE;

    case BOXARG:
	CopyBox (NULL, pFileHead, pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop,
				  pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom,
				  pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop);
	return TRUE;

    DEFAULT_UNREACHABLE;
    }

    argData; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\key.c ===
/*** key.c - keyboard handling routines
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*	03-Dec-1990 ramonsa addapted from old key.c
*	26-Nov-1991 mz	    Strip off near/far
*
*************************************************************************/
#define INCL_DOSSEMAPHORES
#include "mep.h"

#include "keyboard.h"
#include "keys.h"
#include "cmds.h"




//
//  CodeCmdMap
//
//      The KeyCode field in the KEY_INFO structure used within the editor
//  is just an index into this table.
//
//      This table contains pointers to the editor functions attached to
//  particular keystrokes.
//
PCMD CodeCmdMap [] =
    {

            //************************************************************
/*  Key  */ //
/* Index */ //  256 ASCII characters
            //
            //  BugBug this is from the old code, there is no reason to have
            //         256 entries here.
            //
/* 0000 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0004 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0008 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 000C */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0010 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0014 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 0018 */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,
/* 001C */	CMD_graphic,	CMD_graphic,	CMD_graphic,	CMD_graphic,

/* 0020 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0024 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0028 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 002C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0030 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0034 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0038 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 003C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0040 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0044 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0048 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 004C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0050 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0054 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0058 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 005C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0060 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0064 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0068 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 006C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0070 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0074 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0078 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 007C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 0080 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0084 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0088 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 008C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0090 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0094 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0098 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 009C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00A0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00A4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00A8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00AC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00B8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00BC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00C0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00C4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00C8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00CC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00D8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00DC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,

/* 00E0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00E4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00E8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00EC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F0 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F4 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00F8 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 00FC */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,


            //**********************************************************
            //
            //  Special Keys
            //
            //
            //  Function Keys (f1-f12)
            //
/* 0100 */  CMD_unassigned, CMD_setfile,    CMD_psearch,    CMD_msearch,
/* 0104 */  CMD_unassigned, CMD_window,     CMD_zexecute,   CMD_zexit,
/* 0108 */	CMD_meta,		CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 010C */  CMD_begline,    CMD_endline,    CMD_left,       CMD_right,
            //    Up            Down            Pgup            Pgdown
/* 0110 */  CMD_up,         CMD_down,       CMD_mpage,      CMD_ppage,
            //    Ins           Del             Goto
/* 0114 */  CMD_insertmode, CMD_delete,     CMD_unassigned, CMD_unassigned,

            //
            //  Numeric white keys (Numlock on) 0-9
            //
/* 0118 */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 011C */  CMD_graphic,    CMD_graphic,    CMD_graphic,    CMD_graphic,
/* 0120 */  CMD_graphic,    CMD_graphic,    CMD_unassigned, CMD_unassigned,

            //
            //  Numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 0124 */	CMD_graphic,	CMD_zpick,		CMD_graphic,	  CMD_graphic,
            //   NUMENTER
/* 0128 */  CMD_emacsnewl,  CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //  Named Keys :
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 012C */  CMD_unassigned, CMD_emacscdel,  CMD_tab,        CMD_unassigned,
            //  ESC         ENTER
/* 0130 */  CMD_cancel,     CMD_emacsnewl,  CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 0134 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0138 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 013C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  ALT+ 0-9
            //
/* 0140 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0144 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0148 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ a-z
            //
/* 014C */  CMD_doarg,      CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0150 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0154 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0158 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 015C */	CMD_unassigned, CMD_record, 	CMD_unassigned, CMD_unassigned,
/* 0160 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0164 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ function keys (f1-f12)
            //
/* 0168 */  CMD_unassigned, CMD_zprint,     CMD_unassigned, CMD_unassigned,
/* 016C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0170 */	CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ lower case punctuation
            //
            //    `               -               =              [
/* 0174 */  CMD_unassigned, CMD_unassigned, CMD_assign,     CMD_unassigned,
            //    ]               \               ;              '
/* 0178 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    ,                .              /
/* 017C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 0180 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Up            Down            Pgup            Pgdown
/* 0184 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Ins           Del             Goto
/* 0188 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ numeric white keys (Numlock on) 0-9
            //
/* 018C */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_noop,
/* 0190 */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_noop,
/* 0194 */  CMD_noop,       CMD_noop,       CMD_noop,       CMD_unassigned,

            //
            //  ALT+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 0198 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 019C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  ALT+ named keys:
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 01A0 */  CMD_unassigned, CMD_undo,       CMD_unassigned, CMD_unassigned,
            //  ESC         ENTER
/* 01A4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 01A8 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01AC */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01B0 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  CTRL+ 0-9
            //
/* 01B4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01B8 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 01BC */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ a-z
            //
/* 01C0 */	CMD_mword,		CMD_boxstream,	CMD_ppage,		CMD_right,
/* 01C4 */	CMD_up, 		CMD_pword,		CMD_cdelete,	CMD_unassigned,
/* 01C8 */  CMD_unassigned, CMD_sinsert,    CMD_unassigned, CMD_replace,
/* 01CC */	CMD_mark,		CMD_linsert,	CMD_textarg,	CMD_quote,
/* 01D0 */	CMD_unassigned, CMD_mpage,		CMD_left,		CMD_tell,
/* 01D4 */	CMD_lastselect, CMD_insertmode, CMD_mlines, 	CMD_down,
/* 01D8 */  CMD_ldelete,    CMD_plines,     CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ function keys  (f1-f12)
            //
/* 01DC */  CMD_unassigned, CMD_unassigned, CMD_compile,    CMD_unassigned,
/* 01E0 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_zprint,
/* 01E4 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ lower case punctuation
            //
            //    `               -               =              [
/* 01E8 */	CMD_unassigned, CMD_unassigned, CMD_noop,		CMD_pbal,
            //    ]               \               ;              '
/* 01EC */  CMD_setwindow,  CMD_qreplace,   CMD_unassigned, CMD_unassigned,
            //    ,                .              /
/* 01F0 */	CMD_unassigned, CMD_noop,		CMD_unassigned, CMD_unassigned,


            //
            //  CTRL+ numeric white keys (Numlock off)
            //
			//	  Home			End 			Left			Right
/* 01F4 */	CMD_home,		CMD_unassigned,	CMD_mword,		CMD_pword,
            //    Up            Down            Pgup            Pgdown
/* 01F8 */	CMD_unassigned, CMD_unassigned, CMD_begfile,	CMD_endfile,
            //    Ins           Del             Goto
/* 01FC */  CMD_zpick,      CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ numeric white keys (Numlock on) (0-9)
            //
/* 0200 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0204 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0208 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 020C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 0210 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  CTRL+ named keys
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 0214 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
			//	ESC 		ENTER
/* 0218 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  Additional:
            //
/* 021C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0220 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0224 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,



            //*************************************************************
            //
            //  SHIFT+ function keys  (f1-f12)
            //
/* 0228 */  CMD_information,CMD_unassigned, CMD_nextmsg,    CMD_unassigned,
/* 022C */  CMD_unassigned, CMD_searchall,  CMD_refresh,    CMD_zinit,
/* 0230 */  CMD_zspawn,     CMD_information,CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric white keys (Numlock off)
            //
            //    Home          End             Left            Right
/* 0234 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Up            Down            Pgup            Pgdown
/* 0238 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //    Ins           Del             Goto
/* 023C */  CMD_put,        CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric white keys (Numlock on) (0-9)
            //
/* 0240 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0244 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
/* 0248 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ numeric grey keys
            //
            //   NUM-           NUM+            NUM*             NUM/
/* 024C */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,
            //   NUMENTER
/* 0250 */  CMD_unassigned, CMD_unassigned, CMD_unassigned, CMD_unassigned,

            //
            //  SHIFT+ named keys
            //
            //  SPACE       BKSP            TAB             BKTAB
/* 0254 */	CMD_graphic,	CMD_unassigned, CMD_backtab,	CMD_unassigned,
            //  ESC         ENTER
/* 0258 */  CMD_unassigned, CMD_emacsnewl,  CMD_unassigned, CMD_unassigned,


            NULL
};

#define LAST_CODE 0x25b


typedef struct KEYNAME {
    WORD    KeyCode;                    // Key Code
    char    *pName;                     // name of key
} KEYNAME, *PKEYNAME;


//
//  CodeNameMap
//
//      This table maps KeyCodes to their corresponding printable name
//  and vice-versa.
//
KEYNAME CodeNameMap[] =
{

    {   0x0100, "f1"            },      {   0x0101, "f2"            },
    {   0x0102, "f3"            },      {   0x0103, "f4"            },
    {   0x0104, "f5"            },      {   0x0105, "f6"            },
    {   0x0106, "f7"            },      {   0x0107, "f8"            },
    {   0x0108, "f9"            },      {   0x0109, "f10"           },
    {   0x010A, "f11"           },      {   0x010B, "f12"           },

    {   0x010C, "home"          },      {   0x010D, "end"           },
    {   0x010E, "left"          },      {   0x010F, "right"         },
    {   0x0110, "up"            },      {   0x0111, "down"          },
    {   0x0112, "pgup"          },      {   0x0113, "pgdn"          },
    {   0x0114, "ins"           },      {   0x0115, "del"           },
    {   0x0116, "goto"          },

    {   0x0118, "num0"          },      {   0x0119, "num1"          },
    {   0x011A, "num2"          },      {   0x011B, "num3"          },
    {   0x011C, "num4"          },      {   0x011D, "num5"          },
    {   0x011E, "num6"          },      {   0x011F, "num7"          },
    {   0x0120, "num8"          },      {   0x0121, "num9"          },

    {   0x0124, "num-"          },      {   0x0125, "num+"          },
    {   0x0126, "num*"          },      {   0x0127, "num/"          },
    {   0x0128, "numenter"      },

    {   0x012C, "space"         },      {   0x012D, "bksp"          },
    {   0x012E, "tab"           },      {   0x012F, "bktab"         },
    {   0x0130, "esc"           },      {   0x0131, "enter"         },

    {   0x0140, "alt+0"         },      {   0x0141, "alt+1"         },
    {   0x0142, "alt+2"         },      {   0x0143, "alt+3"         },
    {   0x0144, "alt+4"         },      {   0x0145, "alt+5"         },
    {   0x0146, "alt+6"         },      {   0x0147, "alt+7"         },
    {   0x0148, "alt+8"         },      {   0x0149, "alt+9"         },

    {   0x014C, "alt+a"         },      {   0x014D, "alt+b"         },
    {   0x014E, "alt+c"         },      {   0x014F, "alt+d"         },
    {   0x0150, "alt+e"         },      {   0x0151, "alt+f"         },
    {   0x0152, "alt+g"         },      {   0x0153, "alt+h"         },
    {   0x0154, "alt+i"         },      {   0x0155, "alt+j"         },
    {   0x0156, "alt+k"         },      {   0x0157, "alt+l"         },
    {   0x0158, "alt+m"         },      {   0x0159, "alt+n"         },
    {   0x015A, "alt+o"         },      {   0x015B, "alt+p"         },
    {   0x015C, "alt+q"         },      {   0x015D, "alt+r"         },
    {   0x015E, "alt+s"         },      {   0x015F, "alt+t"         },
    {   0x0160, "alt+u"         },      {   0x0161, "alt+v"         },
    {   0x0162, "alt+w"         },      {   0x0163, "alt+x"         },
    {   0x0164, "alt+y"         },      {   0x0165, "alt+z"         },

    {   0x0168, "alt+f1"        },      {   0x0169, "alt+f2"        },
    {   0x016A, "alt+f3"        },      {   0x016B, "alt+f4"        },
    {   0x016C, "alt+f5"        },      {   0x016D, "alt+f6"        },
    {   0x016E, "alt+f7"        },      {   0x016F, "alt+f8"        },
    {   0x0170, "alt+f9"        },      {   0x0171, "alt+f10"       },
    {   0x0172, "alt+f11"       },      {   0x0173, "alt+f12"       },

    {   0x0174, "alt+`"         },      {   0x0175, "alt+-"         },
    {   0x0176, "alt+="         },      {   0x0177, "alt+["         },
    {   0x0178, "alt+]"         },      {   0x0179, "alt+\\"        },
    {   0x017A, "alt+;"         },      {   0x017B, "alt+'"         },
    {   0x017C, "alt+,"         },      {   0x017D, "alt+."         },
    {   0x017E, "alt+/"         },

    {   0x0180, "alt+home"      },      {   0x0181, "alt+end"       },
    {   0x0182, "alt+left"      },      {   0x0183, "alt+right"     },
    {   0x0184, "alt+up"        },      {   0x0185, "alt+down"      },
    {   0x0186, "alt+pgup"      },      {   0x0187, "alt+pgdn"      },
    {   0x0188, "alt+ins"       },      {   0x0189, "alt+del"       },
    {   0x018A, "alt+goto"      },

    {   0x018C, "alt+num0"      },      {   0x018D, "alt+num1"      },
    {   0x018E, "alt+num2"      },      {   0x018F, "alt+num3"      },
    {   0x0190, "alt+num4"      },      {   0x0191, "alt+num5"      },
    {   0x0192, "alt+num6"      },      {   0x0193, "alt+num7"      },
    {   0x0194, "alt+num8"      },      {   0x0195, "alt+num9"      },

    {   0x0198, "alt+num-"      },      {   0x0199, "alt+num+"      },
    {   0x019A, "alt+num*"      },      {   0x019B, "alt+num/"      },
    {   0x019C, "alt+numenter"  },

    {   0x01A0, "alt+space"     },      {   0x01A1, "alt+bksp"      },
    {   0x01A2, "alt+tab"       },      {   0x01A3, "alt+bktab"     },
    {   0x01A4, "alt+esc"       },      {   0x01A5, "alt+enter"     },

	{	0x01B4, "ctrl+0"		},		{	0x01B5, "ctrl+1"		},
	{	0x01B6, "ctrl+@"		},
    {   0x01B6, "ctrl+2"        },      {   0x01B7, "ctrl+3"        },
	{	0x01B8, "ctrl+4"		},		{	0x01B9, "ctrl+5"		},
	{	0x01BA, "ctrl+^"		},
    {   0x01BA, "ctrl+6"        },      {   0x01BB, "ctrl+7"        },
    {   0x01BC, "ctrl+8"        },      {   0x01BD, "ctrl+9"        },

    {   0x01C0, "ctrl+a"        },      {   0x01C1, "ctrl+b"        },
    {   0x01C2, "ctrl+c"        },      {   0x01C3, "ctrl+d"        },
    {   0x01C4, "ctrl+e"        },      {   0x01C5, "ctrl+f"        },
    {   0x01C6, "ctrl+g"        },      {   0x01C7, "ctrl+h"        },
    {   0x01C8, "ctrl+i"        },      {   0x01C9, "ctrl+j"        },
    {   0x01CA, "ctrl+k"        },      {   0x01CB, "ctrl+l"        },
    {   0x01CC, "ctrl+m"        },      {   0x01CD, "ctrl+n"        },
    {   0x01CE, "ctrl+o"        },      {   0x01CF, "ctrl+p"        },
    {   0x01D0, "ctrl+q"        },      {   0x01D1, "ctrl+r"        },
    {   0x01D2, "ctrl+s"        },      {   0x01D3, "ctrl+t"        },
    {   0x01D4, "ctrl+u"        },      {   0x01D5, "ctrl+v"        },
    {   0x01D6, "ctrl+w"        },      {   0x01D7, "ctrl+x"        },
    {   0x01D8, "ctrl+y"        },      {   0x01D9, "ctrl+z"        },

    {   0x01DC, "ctrl+f1"       },      {   0x01DD, "ctrl+f2"       },
    {   0x01DE, "ctrl+f3"       },      {   0x01DF, "ctrl+f4"       },
    {   0x01E0, "ctrl+f5"       },      {   0x01E1, "ctrl+f6"       },
    {   0x01E2, "ctrl+f7"       },      {   0x01E3, "ctrl+f8"       },
    {   0x01E4, "ctrl+f9"       },      {   0x01E5, "ctrl+f10"      },
    {   0x01E6, "ctrl+f11"      },      {   0x01E7, "ctrl+f12"      },

    {   0x01E8, "ctrl+`"        },      {   0x01E9, "ctrl+-"        },
    {   0x01EA, "ctrl+="        },      {   0x01EB, "ctrl+["        },
    {   0x01EC, "ctrl+]"        },      {   0x01ED, "ctrl+\\"       },
    {   0x01EE, "ctrl+;"        },      {   0x01EF, "ctrl+'"        },
    {   0x01F0, "ctrl+,"        },      {   0x01F1, "ctrl+."        },
    {   0x01F2, "ctrl+/"        },

    {   0x01F4, "ctrl+home"     },      {   0x01F5, "ctrl+end"      },
    {   0x01F6, "ctrl+left"     },      {   0x01F7, "ctrl+right"    },
    {   0x01F8, "ctrl+up"       },      {   0x01F9, "ctrl+down"     },
    {   0x01FA, "ctrl+pgup"     },      {   0x01FB, "ctrl+pgdn"     },
    {   0x01FC, "ctrl+ins"      },      {   0x01FD, "ctrl+del"      },
    {   0x01FE, "ctrl+goto"     },

    {   0x0200, "ctrl+num0"     },      {   0x0201, "ctrl+num1"     },
    {   0x0202, "ctrl+num2"     },      {   0x0203, "ctrl+num3"     },
    {   0x0204, "ctrl+num4"     },      {   0x0205, "ctrl+num5"     },
    {   0x0206, "ctrl+num6"     },      {   0x0207, "ctrl+num7"     },
    {   0x0208, "ctrl+num8"     },      {   0x0209, "ctrl+num9"     },

    {   0x020C, "ctrl+num-"     },      {   0x020D, "ctrl+num+"     },
    {   0x020E, "ctrl+num*"     },      {   0x020F, "ctrl+num/"     },
    {   0x0210, "ctrl+numenter" },

    {   0x0214, "ctrl+space"    },      {   0x0215, "ctrl+bksp"     },
    {   0x0216, "ctrl+tab"      },      {   0x0217, "ctrl+bktab"    },
	{	0x0218, "ctrl+esc"		},		{	0x0219, "ctrl+enter"	},

    {   0x0228, "shift+f1"      },      {   0x0229, "shift+f2"      },
    {   0x022A, "shift+f3"      },      {   0x022B, "shift+f4"      },
    {   0x022C, "shift+f5"      },      {   0x022D, "shift+f6"      },
    {   0x022E, "shift+f7"      },      {   0x022F, "shift+f8"      },
    {   0x0230, "shift+f9"      },      {   0x0231, "shift+f10"     },
    {   0x0232, "shift+f11"     },      {   0x0233, "shift+f12"     },

    {   0x0234, "shift+home"    },      {   0x0235, "shift+end"     },
    {   0x0236, "shift+left"    },      {   0x0237, "shift+right"   },
    {   0x0238, "shift+up"      },      {   0x0239, "shift+down"    },
    {   0x023A, "shift+pgup"    },      {   0x023B, "shift+pgdn"    },
    {   0x023C, "shift+ins"     },      {   0x023D, "shift+del"     },
    {   0x023E, "shift+goto"    },

    {   0x0240, "shift+num0"    },      {   0x0241, "shift+num1"    },
    {   0x0242, "shift+num2"    },      {   0x0243, "shift+num3"    },
    {   0x0244, "shift+num4"    },      {   0x0245, "shift+num5"    },
    {   0x0246, "shift+num6"    },      {   0x0247, "shift+num7"    },
    {   0x0248, "shift+num8"    },      {   0x0249, "shift+num9"    },

    {   0x024C, "shift+num-"    },      {   0x024D, "shift+num+"    },
    {   0x024E, "shift+num*"    },      {   0x024F, "shift+num/"    },
    {   0x0250, "shift+numenter"},

    {   0x0254, "shift+space"   },      {   0x0255, "shift+bksp"    },
    {   0x0256, "shift+tab"     },      {   0x0257, "shift+bktab"   },
    {   0x0258, "shift+esc"     },      {   0x0259, "shift+enter"   },


    {   0x0000, NULL        }
};

char UnknownKey [] = "???";


/*** ReadCmd - read the next command from the keyboard.
*
*  ReadCmd is used whenever an editor function is being read. It reads a
*  keystroke and looks it up in the key definition table and returns the
*  matching function.
*
* Input:
*  none
*
* Globals:
*  keyCmd	= last key hit. Updated.
*
* Output:
*  Returns a pointer to function. If not a macro, the function's arg is the
*  keystroke actually used. In addition, the key used is placed in wKeyCmd.
*
*************************************************************************/
PCMD
ReadCmd (
    void
    ) {

    WORD    i;                              /* key code                 */
    EVTargs e;                              /* arg struct for declaring event*/

    do {
        if (!TypeAhead () ) {

            SetEvent( semIdle );

            keyCmd = TranslateKey (ReadChar ());

        WaitForSingleObject(semIdle, INFINITE);
        } else {
            keyCmd = TranslateKey (ReadChar ());
        }
        e.arg.key = keyCmd.KeyInfo;
    } while (DeclareEvent (EVT_RAWKEY, (EVTargs *)&e));

    if (fCtrlc && keyCmd.KeyCode == 0) {
        return NameToFunc ("cancel");
    }

    i = keyCmd.KeyCode;

    if (i > 0 && i <= LAST_CODE) {
        if ((PVOID)CodeCmdMap[i]->func != (PVOID)macro) {
            if ( (PVOID)CodeCmdMap[i]->func == (PVOID)(unassigned) ) {
                CodeCmdMap[i]->arg = (long)keyCmd.KeyCode;
            } else {
                CodeCmdMap[i]->arg = keyCmd.KeyInfo.LongData;
            }
		}
		return CodeCmdMap[i];
    }

	return (PCMD) &cmdUnassigned;
}



/*** FreeMacs - Unassign all keys assigned to macros
*
*  This routine is used to unassign all keys that are assigned to macro
*  definitions. Called immediately prior to releasing all macro definitions.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
FreeMacs (
    void
    ) {
    int     i       = 0;

    while (CodeCmdMap[i]) {
        if ((PVOID)CodeCmdMap[i]->func == (PVOID)macro) {
            CodeCmdMap[i] = CMD_unassigned;
        }
        i++;
    }
}









/*** CodeToName - convert a key codeinto a printable name for the keystroke
*
* Purpose:
*
*   If the index is >= 0x0100, we use the text corresponding to the key in
*   the special key table.  If the index is <= 0x00FF, we look up the
*   key (= index) in the special key table and use the corresponding string.
*   If the key is < 0x0020, we display it as ^ followed by a letter.  If
*   the key is >= 0x0080, we display the key as alt-ddd.  Otherwise, the
*   index itself is a printable character.
*
* Input:
*
*   index	Index of keystroke of interest
*
* Output:
*
*   p		buffer to place readable name
*
*************************************************************************/
void
CodeToName (
    WORD Code,
    char *p
    ) {

    WORD i = 0;
    char * pName = NULL;

    while (CodeNameMap[i].pName != NULL) {
        if (CodeNameMap[i].KeyCode == (WORD)Code) {
            pName = CodeNameMap[i].pName;
            break;
        }
        i++;
    }

    if (pName) {
        strcpy(p, pName);
    } else {
        *p = '\0';
    }
}





/*** NameToCode - convert a key name into a key code
*
* Purpose:
*
*   If the name is one character, then index = first char of name.  If name
*   is two characters and begins with ^, then index = control-second
*   character.	If the name is alt-ddd, then use ddd as the index.
*   Otherwise, look up name in key table, convert the found keystroke to an
*   index and return that index.
*
* Input:
*
*   pName	character pointer to name being indexed
*
* Output:
*
*   Returns     0-based index of matching key or 0 if not found
*
*************************************************************************/
WORD
NameToCode (
    char *pName
    )
{

    WORD i      = (WORD)strlen (pName);
    WORD Code   = 0;
    char Name[20];

    if (i == 1) {
        //
        //  Code is ascii
        //
        return (WORD)(pName[0]);
    } else if (i == 2 && pName[0] == '^') {
        sprintf(Name, "ctrl+%c", pName[1]);
    } else {
        strcpy(Name, pName);
    }

    i = 0;
    while (CodeNameMap[i].pName != NULL) {
        if (!strcmp(Name, CodeNameMap[i].pName)) {
            Code = CodeNameMap[i].KeyCode;
            break;
        }
        i++;
    }

    if (Code) {
        return Code;
    } else {
        return 0;
    }
}




/*** SetKey - associate an editor function with a keystroke
*
* SetKey is used to create a keyboard assignment. Any current assignment to
* the keystroke is discarded and each time that particular keystroke is
* seen, the corresponding editor function will be invoked.
*
* Input:
*  name		= local pointer to name of string being assigned
*  p		= pointer to keystroke
*
* Output:
*  Returns TRUE if a successful assignment was made.
*
*************************************************************************/
flagType
SetKey (
    char    *name,
    char    *p
    )
{

    WORD    Code;
    buffer  keybuf;
    PCMD    pCmd;

    if (strlen(strcpy (keybuf, p)) > 1) {
        _strlwr (keybuf) ;
    }
    Code = NameToCode (keybuf);
    if (Code) {
        if (pCmd = NameToFunc (name)) {
            CodeCmdMap[Code] = pCmd;
            return TRUE;
        }
    }
    return FALSE;
}



/*** FuncOut - append into a file current key assignments
*
* Purpose:
*
* Input:
*
*   pFunc	pointer to command structure
*   pFile	file to place text
*
* Output: None.
*
*************************************************************************/
void
FuncOut (
    PCMD pFunc,
    PFILE pFile
    ) {

    WORD     i;
    char     *p;
    flagType fFirst;

    if ((PVOID)pFunc->func != (PVOID)graphic && (PVOID)pFunc->func != (PVOID)unassigned) {
        sprintf (buf, "%20Fs:", pFunc->name);
        p = buf + 21;
        fFirst = TRUE;

        for (i = 0; CodeCmdMap[i] != NULL; i++) {
            if (CodeCmdMap[i] == pFunc) {
                CodeToName (i, p);
                AppFile (buf, pFile);
                fFirst = FALSE;
            }
        }

        if (fFirst) {
            sprintf (p, "is unassigned");
            buf[0] = ';';
            AppFile (buf, pFile);
        }
    }
}




/*** FuncToKeys - return all key names for a key attached to the given function
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char *
FuncToKeys (
    PCMD pFunc,
    char * dst
    ) {

    WORD     i;
    flagType f = FALSE;

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if (CodeCmdMap[i] == pFunc) {
            if (f) {
                sprintf (strend (dst), " and ");
            }
	    f = TRUE;
            CodeToName (i, strend (dst));
        }
    }

    if (!f) {
        sprintf (strend (dst), "is unassigned");
    }

    return dst;
}




/*** FuncToKey - return a key name for a key attached to the given function
*
* Purpose:
*
*   used only by showasg ()
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
char *
FuncToKey (
    PCMD pFunc,
    char * dst
    ) {

    WORD i;

    dst[0] = '\0';

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if (CodeCmdMap[i] == pFunc) {
            CodeToName (i, dst);
            break;
        }
    }
    return dst;
}




/*** UnassignedOut - Dump the names of all unassigned keys to a file
*
* Purpose:
*
*   Used by showasg to generate the table of unassigned keys.
*
* Input:
*   pFile - File to dump to.
*
* Output: None
*
*************************************************************************/
void
UnassignedOut (
    PFILE pFile
    ) {

    WORD i, col = 0;
    char KeyName[20];

    buf[0] = ';';

    for (i = 0; CodeCmdMap[i] != NULL; i++) {
        if ((PVOID)CodeCmdMap[i]->func == (PVOID)unassigned) {
            CodeToName (i, KeyName);
	    sprintf (buf + col * 16 + 1, "%14s |", KeyName);
	    if (col++ == 4) {
		AppFile (buf, pFile);
		col = 0;
            }
        }
    }
}





/****************************************************************************
 *									    *
 *  SetKeyboard - Handle 'keyboard:' editor switch			    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	In order to support the extra keys on the IBM Enhanced keyboards,   *
 *	it is necessary to use a separate INT 16H service to characters.    *
 *	This can cause two problems:					    *
 *									    *
 *	    1. If the keyboard is mistakenly identified as enhanced when    *
 *	       it is not, unpredictable bad things may happen.		    *
 *									    *
 *	    2. Mouse menus don't support the enhanced keyboard BIOS call.   *
 *	       There may be other programs that do not either.		    *
 *									    *
 *	The user can then set 'keyboard:compatible' to solve the problem.   *
 *	This will prevent the user of F11, F12 and the grey keys.	    *
 *									    *
 *	Switch values are:						    *
 *									    *
 *	    keyboard:enhanced	-  Use INT 16H, AH = 10H		    *	*
 *	    keyboard:compatible -  Use INT 16H, AH = 0			    *	*
 *	    keyboard:		-  Detect keyboard type and use that	    *
 *									    *
 *  INPUT:								    *
 *									    *
 *	lpszVal     String following the colon				    *
 *									    *
 *  OUTPUT:								    *
 *									    *
 *	Int16_CmdBase  Set to 0 or 10H					    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if lpszVal is acceptable					    *
 *	FALSE if lpszVal is not recognized				    *
 *	FALSE if lpszVal is 'enhanced', but we detect a compatible keyboard *
 *									    *
 ****************************************************************************/
char *
SetKeyboard (
    char *lpszVal
    ) {

    return NULL;

    lpszVal;
}



/*** ReadCmdAndKey - Read a key, return the command and key name
*
* Purpose:
*
*   This is used only by the <tell> function.  Waits for a key press,
*   then fills 'buf' with the name of the key.
*
* Input:
*   buf - Place for the key name
*
* Output:
*
*   buf  -  Gets filled with keyname.
*
*   Returns the PCMD attached to the key.
*
*************************************************************************/
PCMD
ReadCmdAndKey (
    char * buf
    ) {

    WORD        i;
    EVTargs     e;
    PCMD        pCmd;
    EDITOR_KEY  k;

    do {
        if (!TypeAhead () ) {

            SetEvent( semIdle);
            k = TranslateKey (ReadChar ());
        WaitForSingleObject( semIdle, INFINITE);
        } else {
            k = TranslateKey (ReadChar ());
        }
        e.arg.key = k.KeyInfo;
    } while (DeclareEvent (EVT_RAWKEY, (EVTargs *)&e));

    if (i = k.KeyCode) {
        CodeToName (i, buf);
        pCmd = CodeCmdMap[i];
    } else {
	strcpy (buf, UnknownKey);
	pCmd = CMD_unassigned;
    }

    return pCmd;
}

//
//	No-op, provided for compatibility with other versions of MEP, which do
//	not map the entire keyboard
//
flagType
noop (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
	argData; pArg; fMeta;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\keyboard.c ===
#include    "mep.h"
#include    "keyboard.h"

void
mepInitKeyboard (
    void
    ) {

    KBDMODE    Mode;

    Mode = CONS_ENABLE_ECHO_INPUT | CONS_ENABLE_WINDOW_INPUT | CONS_ENABLE_MOUSE_INPUT ;
    consoleSetMode(Mode);
}



void
KbHook (
    void
    ){

	KBDMODE Mode = OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT );
	consoleSetMode(Mode);
	consoleFlushInput();
}



void
KbUnHook (
    void
	){

	consoleSetMode(OriginalScreenMode);
}




KBDMODE
KbGetMode (
    void
    ){

    KBDMODE Mode;

	consoleGetMode(&Mode);
    return Mode;
}



void
KbSetMode (
    KBDMODE Mode
    ){

	consoleSetMode(Mode);
}



BOOL
TypeAhead (
    void
    ) {
	return consoleIsKeyAvailable();
}





KBDKEY
ReadChar (
    void
    ) {

	KBDKEY	kbdi;
	consoleGetKey(&kbdi, TRUE);
	return kbdi;
}



void
GetScreenSize (
    int*    pYsize,
    int*    pXsize
    ) {

    SCREEN_INFORMATION  ScreenInformation;
    consoleGetScreenInformation( MepScreen, &ScreenInformation );
    *pYsize = (int)(ScreenInformation.NumberOfRows);
	*pXsize = (int)(ScreenInformation.NumberOfCols);

}




flagType
SetScreenSize (
    int     YSize,
    int     XSize
    ) {

	if (consoleSetScreenSize( MepScreen, YSize, XSize)) {
		return TRUE;
	}
	return FALSE;
}    




void
SetVideoState (
    int     handle
    ) {

	consoleClearScreen(MepScreen, TRUE);

    handle;
}    







void
SaveScreen (
    void
    ) {
	//KBDMODE Mode = OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT );
	//consoleSetMode(Mode);
	consoleSetCurrentScreen(MepScreen);
}




void
RestoreScreen (
    void
    ) {
    //consoleSetMode(OriginalScreenMode);
	consoleSetCurrentScreen(OriginalScreen);
}



void
WindowChange (
	ROW 	Rows,
	COLUMN	Cols
	)
{

	char bufLocal[2];

	if ( (cWin > 1) && (( Rows > (ROW)(YSIZE+2) ) || ( Cols > (COLUMN)(XSIZE) )) ) {
		//
		//	Won't allow to grow the screen if we have more than one window.
		//
		consoleSetScreenSize(MepScreen, YSIZE+2, XSIZE );
		disperr (MSG_ASN_WINCHG);
		return;
	}

	// EnterCriticalSection( &ScreenCriticalSection );

	// consoleClearScreen( MepScreen, FALSE );


   if ( Rows == (ROW)YSIZE+3 ) {
		//
		//	Erase the status line.
		//

		bufLocal[0] = ' ';
		bufLocal[1] = '\0';
		soutb(0, YSIZE+1, bufLocal, fgColor);
	}

	YSIZE = Rows-2;
	XSIZE = Cols;
	// LeaveCriticalSection( &ScreenCriticalSection );
	SetScreen();
	Display();
}


/*	SetCursorSize - set the cursor size
 *
 */
char *
SetCursorSizeSw (
    char *val
    )
{
	int 	i;
	buffer	tmpval;

    strcpy ((char *) tmpval, val);

    i = atoi (tmpval);

	if (i != 0 && i != 1) {
		return "CursorSize: Value must be 0 or 1";
    }

	CursorSize = i;

	return SetCursorSize( CursorSize );

}


char *
SetCursorSize (
	int Size
    )
{
	ULONG	CursorStyle;

	if ( Size == 0 ) {
		CursorStyle = CURSOR_STYLE_UNDERSCORE;
	} else {
		CursorStyle = CURSOR_STYLE_BOX;
	}

	if ( !consoleSetCursorStyle( MepScreen, CursorStyle ) ) {
		return "CursorSize: Cannot set Cursor size";
	}

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\load.c ===
/*** load.c - handle z extensions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*  (The following discussion is applicable ONLY to Z running on DOS 3.x and
*  before).
*
*  Z is extended by reading special EXE files into memory and performing
*  some simple links between Z and the module. The entry point as specified
*  in the EXE is called. This entry is defined by the extension library
*  (which calls the user routine WhenLoaded).
*
*  Issues:
*
*   Initialization
*       The WhenLoaded routine is called. Since it has full _access to all Z
*       functions, it's entry-point table needs to be defined beforehand.
*
*       Solved by having the entry-point table statically defined and
*       located through a well-known pointer in the image.
*
*   Entry points
*       Z services need to have entry points allowing data
*       references. All extension entry points needs to be too.
*
*       Extensions are done by mandate. Z services will have stub routines
*       that perform the calling sequence conversions.
*
*   Revision History:
*
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#define INCL_DOSMODULEMGR
#define INCL_DOSFILEMGR
#define INCL_DOSINFOSEG

#include "mep.h"
#include "keyboard.h"
#include "cmds.h"
#include "keys.h"

#include <stdlib.h>
#include <errno.h>


#include "mepext.h"

#define DEBFLAG LOAD




/*** extension stub routines
*
*  These routines are required under the following conditions:
*
*       - The exported entry point takes a different parameter list than the
*         "real" internal routine.
*
*       - The exported entry point takes pointers, and the
*         "real" routine takes pointers.
*
*  In general, we try to maintain the exported routines as close to thier
*  internal counterparts as is possible.
*
*************************************************************************/
void
E_DelLine (
    PFILE   pFile,
    LINE    yStart,
    LINE    yEnd
    ) {

    DelLine (TRUE, pFile, yStart, yEnd);
}

char *
E_getenv (char *p)
{
    return (getenvOem(p));
}

void
E_DelFile (PFILE pFile)
{
    DelFile (pFile, TRUE);
}


int
E_GetLine (
    LINE     line,
    char *buf,
    PFILE    pFile
    ) {

        int      i;
    flagType fTabsSave = fRealTabs;

    fRealTabs = FALSE;
        i = GetLine (line, buf, pFile);
    fRealTabs = fTabsSave;

    return i;
}



long
E_ReadChar (void)
{
    EDITOR_KEY  Key;

    Key = TranslateKey( ReadChar() );

    return Key.KeyInfo.LongData;
}


/*** E_FileNameToHandle - Extension interface
*
*  Equivalent to our FileNameToHandle routine, except that strings are
*  copied local before FileNameToHandle is actually called, and we do
*  attempt to ensure that the file has been read prior to returning.
*
* Input:
*  As per FileNameToHandle
*
* Output:
*  Returns PFILE if successfull, else NULL.
*
* Exceptions:
*  Since we may call FileRead, the actions that ocurr there also apply
*  here.
*
*************************************************************************/
PFILE
E_FileNameToHandle (
    char *pName,
    char *pShortName
    ) {

        PFILE   pFileNew;

        if (pFileNew = FileNameToHandle (pName, pShortName )) {
        if (TESTFLAG(FLAGS (pFileNew),REFRESH)) {
            FileRead (pFileNew->pName, pFileNew, TRUE);
        }
    }
    return pFileNew;
}


flagType
E_FileRead (
    char *name,
    PFILE   pFile
    ) {

        return FileRead (name, pFile, TRUE);
}

int
E_DoMessage (
    char *p
    ) {

    return (p != 0) ? domessage ("%s", p) : domessage(NULL);
}


void
MoveCur (
    COL     x,
    LINE    y
    ) {

    fl fl;

    fl.col = x;
    fl.lin = y;
    cursorfl (fl);
}



void
E_Free(
        void *  p
        )
{
        FREE( p );
}



void *
E_Malloc(
        size_t n
        )
{

        return MALLOC( n );
}






/* GetEditorObject - Extension gateway into Z internal data
 *
 * This routines allows the extension user to get >copies< of certain Z editor
 * internal data items.
 *
 * index        = index to data item desired
 * wParam       = word parameter
 * pDest        = pointer to the location to place whatever it is the user
 *                wanted.
 *
 * The index varies, based on the request type. For RQ_FILE and RQ_WIN, the
 * low byte of the index specifes the "nth most recent file" or "window #n".
 * Special case value of FF, causes wParam to be used as the file or window
 * handle. Window values are 1-8, 0 is current window.
 *
 * returns TRUE on successfull copy of data, else FALSE for bad request.
 */
flagType
GetEditorObject (
    unsigned index,
    void     *wParam,
    void     *pDest
    ) {

    unsigned lowbyte;
    PFILE    pFileCur;
    PWND     pWinLocal;

    lowbyte = index & 0x00ff;

    switch (index & 0xf000) {           /* upper nyble is request type  */

        case RQ_FILE:
        if (lowbyte == RQ_THIS_OBJECT) {
            pFileCur = (PFILE)wParam;
        } else if (lowbyte == RQ_FILE_INIT) {
            pFileCur = pFileIni;
        } else {
            pFileCur = pFileHead;
            while (lowbyte-- && pFileCur) {
               pFileCur = pFileCur->pFileNext;
            }
        }

        if (pFileCur == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

        case RQ_FILE_HANDLE:
                    *(PFILE *)pDest = pFileCur;
            return TRUE;

        case RQ_FILE_NAME:
                    strcpy((char *)pDest,pFileCur->pName);
            return TRUE;

        case RQ_FILE_FLAGS:
                    *(int *)pDest = pFileCur->flags;
            return TRUE;
        }
        break;

    //
    // We support the direct manipulation of the ref count, so that extensions
    // can cause pFiles to be preserved even when explicitly arg-refresh'ed by
    // users
    //
    case RQ_FILE_REFCNT:
                //  What is pFileCur?
                pFileCur = pFileHead;
                *(int *)pDest = pFileCur->refCount;
                return TRUE;

        case RQ_WIN:
            if (lowbyte == RQ_THIS_OBJECT) {
            pWinLocal = (PWND)wParam;
        } else if (lowbyte == 0) {
            pWinLocal = pWinCur;
        } else if ((int)lowbyte <= cWin) {
            pWinLocal = &(WinList[lowbyte-1]);
        } else {
            pWinLocal = 0;
        }

        if (pWinLocal == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

        case RQ_WIN_HANDLE:
                    *(PWND *)pDest = pWinLocal;
            return TRUE;

        case RQ_WIN_CONTENTS:
            //{
            //    char b[256];
            //    sprintf(b, "GetWinContents: Index %d Win 0x%x pFile 0x%x\n",
            //            lowbyte, pWinLocal, pWinLocal->pInstance->pFile );
            //    OutputDebugString(b);
            //}
            ((winContents *)pDest)->pFile           = pWinLocal->pInstance->pFile;
                    ((winContents *)pDest)->arcWin.axLeft   = (BYTE)pWinLocal->Pos.col;
                    ((winContents *)pDest)->arcWin.ayTop    = (BYTE)pWinLocal->Pos.lin;
                    ((winContents *)pDest)->arcWin.axRight  = (BYTE)(pWinLocal->Pos.col + pWinLocal->Size.col);
                    ((winContents *)pDest)->arcWin.ayBottom = (BYTE)(pWinLocal->Pos.lin + pWinLocal->Size.lin);
            ((winContents *)pDest)->flPos           = pWinLocal->pInstance->flWindow;
            return TRUE;
        }
            break;

        case RQ_COLOR:
        if (lowbyte >= 20) {
            *(unsigned char *)pDest = (unsigned char)ColorTab[lowbyte-20];
        }
            return TRUE;

        case RQ_CLIP:
            *(unsigned *)pDest = kindpick;
            return TRUE;

    }

    return FALSE;
}





/* SetEditorObject - Extension gateway into setting Z internal data
 *
 * This routines allows the extension user to set certain Z editor internal
 * data items.
 *
 * index        = index to data item desired
 * pSrc         = pointer to the location to get whatever it is the user
 *                wishes to set it to.
 *
 * returns TRUE on successfull copy of data, else FALSE for bad request.
 */
flagType
SetEditorObject(
    unsigned index,
    void     *wParam,
    void     *pSrc
    ) {

    unsigned lowbyte;
    PFILE    pFileCur;
    PWND     pWinLocal;

    lowbyte = index & 0xff;
    switch (index & 0xf000) {           /* upper nyble is request type  */

        case RQ_FILE:
            if (lowbyte == RQ_THIS_OBJECT) {
            pFileCur = (PFILE)wParam;
        } else {
            pFileCur = pFileHead;
            while (lowbyte-- && pFileCur) {
                pFileCur = pFileCur->pFileNext;
            }
        }

        if (pFileCur == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */

                case RQ_FILE_FLAGS:
                    pFileCur->flags = *(int *)pSrc;
                return TRUE;

        //
        // We support the direct manipulation of the ref count, so that extensions
        // can cause pFiles to be preserved even when explicitly arg-refresh'ed by
        // users
        //
                case RQ_FILE_REFCNT:
                    pFileCur->refCount = *(int *)pSrc;
                    return TRUE;
        }
            break;

        case RQ_WIN:
            if (lowbyte == RQ_THIS_OBJECT) {
            pWinLocal = (PWND)wParam;
        } else if (lowbyte == 0) {
            pWinLocal = pWinCur;
        } else if ((int)lowbyte <= cWin) {
            pWinLocal = &WinList[lowbyte-1];
        } else {
            pWinLocal = 0;
        }

        if (pWinLocal == 0) {
            return FALSE;
        }

            switch (index & 0xff00) {   /* field request in next nyble  */
            case RQ_WIN_CUR:
                SetWinCur ((int)(pWinLocal - WinList));
                return TRUE;

            default:
                break;
        }

        case RQ_COLOR:
        if (lowbyte >= isaUserMin) {
            ColorTab[lowbyte-isaUserMin] = *(unsigned char *)pSrc;
        }
            break;

        case RQ_CLIP:
        kindpick = (WORD)wParam;
            return TRUE;
    }
    return FALSE;
}



/* NameToKeys - returns keys associated with function name
 *
 * pName        - pointer to function key name
 * pDest        - pointer to place for keys assigned (Can be same as pName)
 */
char *
NameToKeys (
    char *pName,
    char *pDest
    ) {

    buffer  lbuf;
    PCMD    pCmd;

    strcpy ((char *) lbuf, pName);
    pCmd = NameToFunc (lbuf);
    lbuf[0] = 0;
    if (pCmd) {
        FuncToKeys(pCmd,lbuf);
    }
    strcpy (pDest, (char *) lbuf);

    return pDest;
}



/* E_KbHook - Hook keyboard, AND force next display to update screen
 */
int
E_KbHook(
    void
    ) {

    newscreen ();
    KbHook();
    return 1;
}




/* E_Error - Invalid entry
 */
int
E_Error(
    void
    ) {

    printerror ("Illegal Extension Interface Called");
    return 0;
}



/*** E_GetString - interface for prompting the user
*
*  Prompts the user for a string, and returns the result.
*
* Input:
*  fpb          = pointer to destination buffer for user's response
*  fpPrompt     = pointer to prompt string
*  fInitial     = TRUE => entry is highlighted, and if first function is
*                 graphic, the entry is replaced by that graphic.
*
* Output:
*  Returns TRUE if canceled, else FALSE
*
*************************************************************************/
flagType
E_GetString (
    char *fpb,
    char *fpPrompt,
    flagType fInitial
    ) {

        UNREFERENCED_PARAMETER( fInitial );

        return  (flagType)(CMD_cancel == getstring (fpb, fpPrompt, NULL, GS_NEWLINE | GS_INITIAL));

}

EXTTAB et =
    {   VERSION,
        sizeof (struct CallBack),
        NULL,
        NULL,
        {
            AddFile,
            BadArg,
            confirm,
            CopyBox,
            CopyLine,
            CopyStream,
            DeRegisterEvent,
            DeclareEvent,
            DelBox,
            E_DelFile,
            E_DelLine,
            DelStream,
            DoDisplay,
            E_DoMessage,
            fChangeFile,
            E_Free,
            fExecute,
            fGetMake,
            FileLength,
            E_FileNameToHandle,
            E_FileRead,
            FileWrite,
            FindSwitch,
            fSetMake,
            GetColor,
            GetTextCursor,
            GetEditorObject,
            E_getenv,
            E_GetLine,
            GetListEntry,
            E_GetString,
            E_KbHook,
            KbUnHook,
            E_Malloc,
            MoveCur,
            NameToKeys,
            NameToFunc,
            pFileToTop,
            PutColor,
            PutLine,
            REsearchS,
            E_ReadChar,
            ReadCmd,
            RegisterEvent,
            RemoveFile,
            Replace,
            ScanList,
            search,
            SetColor,
            SetEditorObject,
            SetHiLite,
            SetKey,
            SplitWnd
            }
        };


/*** SetLoad - load a new extension to Z
*
*  Since tools.ini really cannot execute editor commands as it is read,
*  we can get modules loaded by making the load operation a switch. SetLoad
*  is the mechanism by which things get loaded.
*
* Input:
*  val          = char pointer to remainder of assignment
*
* Output:
*  Returns pointer to error string if any errors are found, else NULL.
*
*************************************************************************/
char *
SetLoad (
    char *val
    ) {
    char    *pemsg;                         /* error returned by load       */

    if (pemsg = load (val, TRUE)) {
        return pemsg;
    } else {
        return NULL;
    }
}




/*** load - load, link, initialize Z extensions
*
*  Read the header into memory.
*  Allocate memory, perform relocations, link to resident, initialize.
*
* Input:
*  pName        = character pointer to name of file to be loaded
*  fLibPath     = TRUE => search 8 character basename under OS/2, allowing
*                 basename.DLL in LIBPATH.
*
* Output:
*  Returns C error code
*
*************************************************************************/
char *
load (
    char *pName,
    flagType fLibpath
    ) {

    pathbuf fbuf;                           /* full path (or user spec'd)   */
    pathbuf fname;                          /* copy of input param          */
    int     i;                              /* everyone's favorite utility var*/
    EXTTAB  *pExt;                          /* pointer to the extension hdr */
    char    *pT;                            /* temp pointer to filename     */

    HANDLE  modhandle;                      /* library handle               */
    FARPROC pInit;                          /* pointer to init routine      */


    /*
     * barf if we have too many extensions
     */
    if (cCmdTab >= MAXEXT) {
        return sys_errlist[ENOMEM];
    }


    /*
     * make near copy of string
     */
    strcpy ((char *) fname, pName);

    /*
     * Form a fully qualified pathname in fbuf. If can't qualify, and there is
     * no extension, append ".PXT". If that fails, then just copy the text into
     * fbuf).
     */
    if (!findpath (fname, fbuf, FALSE)) {
        if (!(pT = strrchr (fname, '\\'))) {
            pT = fname;
        }
        if (!(strchr(pT, '.'))) {
            strcat (pT, ".pxt");
            if (!findpath (fname, fbuf, FALSE)) {
                strcpy (fbuf, fname);
            }
        } else {
            strcpy (fbuf, fname);
        }
    }

    /*
     * See if extension already loaded, by looking for the filename.ext in the
     * table. If already loaded, we're done.
     */
    filename (fbuf, fname);
    for (i = 1; i < cCmdTab; i++) {
        if (!strcmp (pExtName[i], fname)) {
            return 0;
        }
    }

    if (! (modhandle = LoadLibrary(fbuf))) {
        if (fLibpath) {
            filename(fbuf, fname);
            if (!(modhandle = LoadLibrary(fname))) {
                //
                // error here
                //
                sprintf( buf, "load:%s - Cannot load, Error: %d", fname, GetLastError() );
                return buf;
            }
        }
    }


    /*
     * One way or another, we succeeded. Now get the address of the ModInfo
     */
    if (!(pExt = (EXTTAB *)GetProcAddress(modhandle, "ModInfo"))) {
        FreeLibrary(modhandle);
        return buf;
        }

    //
    //  Version check.  Check to see if the extensions version is in our
    //  allowed range.  If it isn't, we fail due to a bad version.  If it
    //  is, we handle it specially
    //

    if (pExt->version < LOWVERSION || pExt->version > HIGHVERSION) {
        FreeLibrary(modhandle);
        return sys_errlist[ENOEXEC];
        }

    //
    //  For now, we will allow appending of entries.  Make sure that the
    //  number required by the extension is not more than we can supply
    //

    if (pExt->cbStruct > sizeof (struct CallBack)) {
        FreeLibrary(modhandle);
        return sys_errlist[ENOEXEC];
        }

    /*
     * get the current registers (for our DS), and get the entry point to the
     * .DLL.
     */
    if (!(pInit = GetProcAddress(modhandle, "EntryPoint"))) {
        FreeLibrary(modhandle);
        return buf;
    }
    /*
     * Copy to the extension's call table the table we have defined. Copy only
     * the number of entry points that the extension knows about, in case it is
     * less than we support.
     */
    memmove (&pExt->CallBack, &et.CallBack, pExt->cbStruct);

    /*
     * Now that we know the extension will be staying, set up the appropriate
     * info in our internal tables.
     */
    filename (fname, fbuf);
    pExtName[cCmdTab] = ZMakeStr (fbuf);
    swiSet[cCmdTab  ] = pExt->swiTable;
    cmdSet[cCmdTab++] = pExt->cmdTable;

    /*
     *  Finally, Initialize the extension
     */
    //assert (_heapchk() == _HEAPOK);
    (*pInit) ();
    //assert (_heapchk() == _HEAPOK);

    /*
     * use root extension name for TOOLS.INI initialization & Load any
     * extension-specific switches
     */
    filename (pExtName[cCmdTab-1], fname);
    DoInit (fname, NULL, 0L);

    return 0;
}







/*** AutoLoadExt - Automatically load extensions
*
*  Search for, and automatically load extensions.
*
*  On startup, this routine is called to search for and load extension which
*  match a particular name pattern:
*
*   Version 1.x,:   m*.mxt on PATH
*   Version 2.x,:   pwb*.mxt on PATH
*
*  Under OS/2, the normal load processing does NOT occur, such that M*.DLL
*  is NOT looked for on the path.
*
*  Any failures during these loads are NOT reported. It is assumed that any
*  files which match the pattern and cannot be loaded are not valid
*  extensions. The "load:" command executed anywhere else will report the
*  appropriate errors on explicit attempts to load the files.
*
* Input:
*  none
*
* Output:
*  Returns nothing.
*
*************************************************************************/
void
AutoLoadExt (
    void
    ) {
    char    *pathenv;    /* contents of PATH environment var*/
    va_list templist;

    memset( &templist, 0, sizeof(va_list) );
    AutoLoadDir (".", templist);
    // pathenv = getenv("PATH");
    pathenv = getenvOem("PATH");
    if (pathenv) {
        forsemi (pathenv, AutoLoadDir, NULL);
        free( pathenv );
    }
}




/*** AutoLoadDir - Scan one directory for Auto-Load files
*
*  Support routine for AutoLoadExt. Generally called by forsemi(). Scans a single
*  directory for files which can be autoloaded.
*
* Input:
*  dirname      = directory name.
*
* Output:
*  Returns nothing
*
*************************************************************************/
flagType
AutoLoadDir (
    char    *dirname,
    va_list dummy
    ) {

    buffer  patbuf;
    /*
     * Construct the fully qualified pattern to be searched for, and use forfile.
     */
        strcpy (patbuf, dirname);
        if ( patbuf[0] != '\0' ) {
                if ( patbuf[strlen(patbuf) - 1] != '\\' ) {
                        strcat(patbuf, "\\");
                }
        }
    strcat (patbuf, rgchAutoLoad);
    forfile (patbuf, A_ALL, AutoLoadFile, NULL);
    return TRUE;
    dummy;
}





/*** AutoLoadFile - Auto-Load one extension
*
*  Called by forfile() when a match is found. Simply calls load() with
*  the filename.
*
* Input:
*  szFile       - filename to attempt to load
*
* Output:
*  Returns nothing.
*
*************************************************************************/
void
AutoLoadFile (
    char    *szFile,
    struct findType *pfbuf,
    void * dummy
    ) {

    load (szFile, FALSE);

    pfbuf; dummy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\lang.c ===
/*** lang.c - Language dependent routines
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#include "mep.h"

typedef int ( __cdecl *STRCMP) (const char *, const char *);


/* return index+1 of first string s that is in table */
int
tblFind (
    char * tbl[],
    char * s,
    flagType fCase
    )
{
    int    i;
    STRCMP f;

    f = fCase ? (STRCMP)FNADDR(strcmp) : (STRCMP)FNADDR(_stricmp);
    for (i=0; tbl[i]; i++) {
        if (!(*f) (tbl[i], s)) {
            return i+1;
        }
    }
    return 0;
}




flagType
parseline (
    char *pbuf,
    char **ppbegtok,
    char **ppendtok
    ) {

    char *p1, *p2;

    p1 = whiteskip (pbuf);
    if (!*p1) {
	return FALSE;
    } else if (*(p2 = whitescan (p1))) {
	*p2++ = 0;
	p2 += strlen( p2 ) - 1;
	while (*p2)
            if (*p2 == ' ') {
		break;
            } else {
                p2--;
            }
        if (!*++p2) {
            p2 = NULL;
        }
    } else {
        p2 = NULL;
    }
    *ppbegtok = p1;
    *ppendtok = p2;
    return TRUE;
}




//
// csoftcr - perform C soft CR processing.
//
// Algorithm:
//  Given that you have just entered a newline at the end of a line:
//      If the original line begins with "}", tab back once.
//      else If the original line ends with "{" or begins with a C keyword, tab
//           in once.
//      else If the line >preceding< the original line >doen't< end with "{"
//           but does begin with a C keyword, tab back once.
//
//  C keywords used are: if, else, for, while, do, case, default.
//
int
csoftcr (
    COL  x,
    LINE y,
    char *pbuf
    ) {

    char *pbeg, *pend;

    if (parseline (pbuf, &pbeg, &pend)) {
        if (*pbeg == '}') {
	    return dobtab (x);
        } else if ( (pend && *pend == '{' ) || tblFind (cftab, pbeg, TRUE ) ) {
	    return doftab (x);
        } else if (y) {
	    GetLineUntabed (y-1, pbuf, pFileHead);
            if (parseline (pbuf, &pbeg, &pend)) {
                if ( !(pend && *pend == '{') && tblFind (cftab, pbeg, TRUE) ) {
                    return dobtab (x);
                }
            }
        }
    }
    return -1;
}




//
// softcr - perform semi-intelegent indenting.
//
// Algorithm:
//  Given that you have just entered a newline at the end of a line:
//      Move to the first non-blank position on the line.
//      If a C file, attempt to get new x position.
//      If not found, move to the first non-blank position on the following
//          line.
//      If that line was blank, stay in the original first non-blank position.
//
int
softcr (
    void
    ) {

    linebuf pbuf;
    char *p;
    int x1, x2;


    if (!fSoftCR) {
        return 0;
    }

    GetLineUntabed (YCUR(pInsCur), pbuf, pFileHead);

    if (*(p=whiteskip(pbuf)) == 0) {
        p = pbuf;
    }
    x1 = (int)(p - pbuf);

    switch (FTYPE(pFileHead)) {

    case CFILE:
	x2 = csoftcr (x1, YCUR(pInsCur), pbuf);
        break;

    default:
	x2 = -1;
        break;

    }

    if (x2 >= 0) {
        return x2;
    }

    GetLineUntabed (YCUR(pInsCur)+1, pbuf, pFileHead);
    if (pbuf[0] != 0) {
        if (*(p=whiteskip (pbuf)) != 0) {
            return (int)(p - pbuf);
        }
    }
    return x1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\ldelete.c ===
/*** LDELETE.C
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"

flagType
ldelete (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    fl      fl;
    int     l;

    if (pArg->argType == STREAMARG) {
        StreamToBox (pArg);
    }

    switch (pArg->argType) {

    case NOARG:
        if (!fMeta) {
            pick (0, pArg->arg.noarg.y, 0, pArg->arg.noarg.y, LINEARG);
        }
	DelLine (TRUE, pFileHead, pArg->arg.noarg.y, pArg->arg.noarg.y);
	break;

    case NULLARG:
	l = LineLength (pArg->arg.nullarg.y, pFileHead);
        if (!fMeta) {
	    pick (min (l, pArg->arg.nullarg.x),   pArg->arg.nullarg.y,
		  max (l, pArg->arg.nullarg.x)-1, pArg->arg.nullarg.y,
                  BOXARG);
        }
	DelBox (pFileHead, min (l, pArg->arg.nullarg.x),   pArg->arg.nullarg.y,
			   max (l, pArg->arg.nullarg.x)-1, pArg->arg.nullarg.y);
	return TRUE;

    case LINEARG:
        if (!fMeta) {
	    pick (0, pArg->arg.linearg.yStart,
                  0, pArg->arg.linearg.yEnd, LINEARG);
        }
	DelLine (TRUE, pFileHead, pArg->arg.linearg.yStart,
				  pArg->arg.linearg.yEnd);
	fl.col = pInsCur->flCursorCur.col;
	fl.lin = pArg->arg.linearg.yStart;
	cursorfl (fl);
	break;

    case BOXARG:
        if (!fMeta) {
	    pick (pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
                  pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom, BOXARG);
        }
	DelBox (pFileHead, pArg->arg.boxarg.xLeft,    pArg->arg.boxarg.yTop,
			   pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom);
	fl.col = pArg->arg.boxarg.xLeft;
	fl.lin = pArg->arg.boxarg.yTop;
	cursorfl (fl);
	break;

    default:
	return FALSE;
    }
    return TRUE;

    argData;
}




/*** StreamToBox - Convert a stream arg to a box/line arg
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
StreamToBox (
    ARG * pArg
    ) {

    ARG arg;

    arg = *pArg;

    if (arg.arg.streamarg.xStart == arg.arg.streamarg.xEnd) {
        pArg->argType = LINEARG;

        pArg->arg.linearg.yStart = arg.arg.streamarg.yStart;
        pArg->arg.linearg.yEnd   = arg.arg.streamarg.yEnd;
    } else {
        pArg->argType = BOXARG;

        pArg->arg.boxarg.yTop    = arg.arg.streamarg.yStart;
        pArg->arg.boxarg.yBottom = arg.arg.streamarg.yEnd;

        if (arg.arg.streamarg.xEnd > arg.arg.streamarg.xStart) {
            pArg->arg.boxarg.xLeft  = arg.arg.streamarg.xStart;
            pArg->arg.boxarg.xRight = arg.arg.streamarg.xEnd - 1;
        } else {
            pArg->arg.boxarg.xLeft  = arg.arg.streamarg.xEnd;
            pArg->arg.boxarg.xRight = arg.arg.streamarg.xStart -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\list.c ===
/***  LIST.C  File list handling functions
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   In order to operate on a list of files, instead of just the current
*   file, we use a file list.  This is a name, much like a macro name, whose
*   value is a bunch of strings and/or lists.  We can think of a typical
*   list this way:
*
*	    list:= "one two three" sub1 "four" sub2 "five"
*	    sub1:= "subone subtwo" sub2 "subthree"
*	    sub2:= "whatever something nothing"
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"

/****************************************************************************
 *
 *  LISTS:
 *
 *	A list is kept as a macro.  The interface defined here assumes
 *	the existence of M macro handling.
 *
 ****************************************************************************/

#define LITERAL 1

static buffer bufList;
static MI ScanStack[MAXUSE];
static int scanSP;


/*** ListWalker - Given a list head, call back with each list member
*
* Purpose:
*
*   To walk through a list and call back to a function with information
*   about each list element.  This function is used when the caller needs
*   access to the list itself.	When a copy of the list's elements is
*   sufficient, ScanList is preferred.
*
*   This function should not be used outside of this module.
*
* Input:
*   Parameters:
*	imac -> Index of list
*	pfn  -> Call back function
*
* Output:   None
*
* Notes:
*
*   The callback function takes four arguments:
*
*	pcmd -	The handle of the list currently being searched.  This is
*		important because it may be different from the original
*		during a recursive scan.
*
*	str  -	A buffer containing a copy of the current string
*
*	pmi  -	A pointer to the macro instance structure.  This contains:
*
*		    -> text - A pointer just beyond the current element
*		    -> beg  - The start of the current list.
*
*	i    - The index of the current element within the current sublist.
*
*************************************************************************/
void
ListWalker (
    PCMD     pcmd,
    flagType (*pfn)(PCMD, char *, PMI, int),
    flagType fRecurse
    ) {

    MI mi;
    int i;

    if (pcmd == NULL) {
        return;
    }

    assert ((PVOID)pcmd->func == (PVOID)macro);

    InitParse (pcmd, &mi);
    for (i = 0; fParseList (&mi, bufList); i++) {
        if (!fRecurse || TESTFLAG (mi.flags, LITERAL)) {
            if (!TESTFLAG (mi.flags, LITERAL)) {
                Listize (bufList);
            }
            if (!(*pfn)(pcmd, bufList, &mi, i)) {
                return;
            }
        }else {
            ListWalker (GetListHandle (bufList, FALSE), pfn, TRUE);
        }
    }
}





/*** ScanList - External list scanner, does not require keeping an instance
*
* Purpose:
*   To scan through a list.  Calling with a list handle will return the
*   first element of the list.	To get the rest of the list, call with
*   NULL until NULL is returned.
*
* Input:
*   Parameters:
*	pcmdStart -> Handle of list to start scanning, or NULL to get
*		     next element.
*	fRecurse  -> TRUE means go down sublists, FALSE means return
*		     sublist names with '@' prepended.
*
* Output:
*   Returns Pointer to next element, or NULL if there are no more.
*
* Note:
*   Does not allow multiple simultaneous scans.
*
*************************************************************************/
char *
ScanList (
    PCMD pcmdStart,
    flagType fRecurse
    ) {
    static MI mi;

    return ScanMyList (pcmdStart, &mi, bufList, fRecurse);
}





/*** ScanMyList - Real list scanner
*
* Purpose:
*   To scan through a list.  Calling with a list handle will return the
*   first element of the list.	To get the rest of the list, call with
*   NULL until NULL is returned.
*
* Input:
*   Parameters:
*	pcmdStart -> Handle of list to start scanning, or NULL to get
*		     next element.
*	pmi	  -> pointer to instance MI structure
*	bufScan   -> pointer to instance buffer
*	fRecurse  -> TRUE means go down sublists, FALSE means return
*		     sublist names with '@' prepended.
* Output:
*   Returns Pointer to next element, or NULL if there are no more.
*
* Note:
*   Allows multiple simultaneous scans.
*
*************************************************************************/
char *
ScanMyList (
    PCMD         pcmdStart,
    REGISTER PMI pmi,
    buffer       bufScan,
    flagType     fRecurse
    ) {

    if (pcmdStart) {
	scanSP = -1;		/* Clear list stack		      */
	InitParse (pcmdStart, pmi);
    }

    while (!fParseList(pmi, bufScan)) {  /* Pop till we find something   */
        if (!(fRecurse && fScanPop (pmi))) {
            return NULL;    /* We're completely done                */
        }
    }

    /* Push lists till we hit a string      */

    while (!TESTFLAG(pmi->flags, LITERAL)) {
	if (fRecurse) {
	    if (pcmdStart = GetListHandle (bufScan, FALSE)) {
		if (!fScanPush (pmi)) { /* Stack overflow */
		    printerror ("List Error: Nested too deeply at '%s'", bufScan);
		    return NULL;
                }
		InitParse (pcmdStart, pmi);
            } else {  /* Error! List does not exist */
		printerror ("List Error: '%s' does not exist", bufScan);
		return NULL;
            }

            if (!fParseList (pmi, bufScan)) {
                if (!fScanPop (pmi)) {
                    return NULL;
                }
            }
        } else {
	    Listize (bufScan);
	    break;
        }
    }
    return bufScan;
}




/*** fParseList - Return next list element
*
* Purpose:
*
*   To read a list.
*
* Input:
*   Parameters:
*	pmi ->	macroInstance.	Points to a macro value and the
*		element to be returned.
*
* Output:
*   Parameters:
*	pmi ->	The current element field is advanced.	The flags
*		field indicates whether we found a literal or a
*		sublist.
*	buf ->	Place to put the element.  If this is NULL, we do not
*		return the element.
*
*   Returns TRUE if something was found.
*
*************************************************************************/
flagType
fParseList (
    REGISTER PMI pmi,
    REGISTER char * buf
    ) {

    assert (pmi);
    assert (pmi->text);

    /* CONSIDER: DO we really want to ignore empty quote pairs? */
    /* Scan through any number of double quote pairs */
    while (*(pmi->text = whiteskip (pmi->text)) == '"') {
	pmi->flags ^= LITERAL;
	pmi->text++;
    }

    if (*pmi->text == '\0') {
        return FALSE;
    }

    if (buf) {	/* Copy to whitspace, " or end of string */
	while (!strchr ("\"\t ", *pmi->text)) {
            if (*pmi->text == '\\') {
                /* Backslashes protect characters */
                pmi->text++;
            }
	    *buf++ = *pmi->text++;
        }
	*buf = '\0';
    }
    return TRUE;
}





/****************************************************************************
 *
 *  List Stack Management.
 *
 *	ScanList uses a stack of MI's to keep track
 *	of what has been scanned so far.  The stack elements are kept in
 *	a private stack defined here.
 *
 ****************************************************************************/


/*** fScanPush - Save current list scan state
*
* Purpose:
*
*   Called by ScanList to save its place so a sublist can be scanned
*
* Input:
*   Parameters:
*	pmi ->	Pointer to instance to save.
*
* Output:
*   Returns FALSE for a stack overflow, TRUE otherwise.
*
*************************************************************************/
flagType
fScanPush (
    PMI pmi
    ) {

    if (scanSP >= (MAXUSE-1)) {
        return FALSE;
    }

    ScanStack[++scanSP] = *pmi;
    assert (scanSP >= 0);
    return TRUE;
}




/*** fScanPop - Restore previous scan state
*
* Purpose:
*
*   Restore state after scanning a sublist
*
* Input: None.
*
* Output:
*   Parameters:
*	pmi -> Place to put previous state
*
*   Returns TRUE if a meaningful pop took place, FALSE if there was no
*   previous state.
*
*************************************************************************/
flagType
fScanPop (
    PMI pmi /* register here increases code size */
    ) {

    if (scanSP < 0) {
        return FALSE;
    }

    *pmi = ScanStack[scanSP--];
    return TRUE;
}




/*** GetListHandle - Create a handle for the given list name
*
* Purpose:
*
*   It's much easier to deal with lists if the user can carry around something
*   that tells us how to access a list quickly.  Therefore, we use this to
*   take a literal name and return a PCMD of the macro
*
* Input:
*   Parameters:
*	sz  ->	Name to look for.
*
* Output:
*
*   Returns PLHEAD
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
PCMD
GetListHandle (
    char * sz,  /* register doesn't help */
    flagType fCreate
    )
{

    REGISTER PCMD * prgMac;

    for (prgMac = rgMac; prgMac < &rgMac[cMac]; prgMac++) {
        if (!strcmp ((*prgMac)->name, sz)) {
            return *prgMac;
        }
    }

    if (!fCreate) {
        return NULL;
    }

    SetMacro (sz, rgchEmpty);

    return rgMac[cMac-1];
}




/*** AddStrToList - Add a list item to the end of a list
*
* Purpose:
*
*   This is how we build lists, n'est-ce pas?
*
* Input:
*   Parameters:
*	pcmd->	List to append to
*	sz  ->	Item to add.  If this item begins with a @, then we add
*		a list (not the contents, the name).
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*   If the original string ends in a double quote ("), we assume that
*   this is a closing quote; the string ends with a literal.  If the
*   original ends with anything else, we assume that it is the end of
*   a list name.  If the string passed in begins with a '@', the rest
*   of the string is a list name.
*
*   To append a list to either type of original, we append a space and
*   the list name.
*
*   To append a literal to a literal terminated original, we replace the
*   original's double quote with a space, append the new string, then
*   append a double quote.
*
*   To append a literal to a list terminated original, we append a space
*   and double quote, the new string, then a double quote.
*
*   Backslashes are doubled.  This allows the list to be read by the
*   macro processor.
*
*************************************************************************/
void
AddStrToList (
    PCMD pcmd,
    char * sz   /* register doesn't help */
    ) {

    flagType fString = TRUE;	/* TRUE -> sz is a string, FALSE a list */
    flagType fQuote = FALSE;	/* TRUE means original ends in string	*/
    int len;			/* Length of original string		*/
    int lensz;			/* Length of new string 		*/
    int fudge = 0;		/* Additional spaces or quotes		*/
    REGISTER char * pchOld;	/* Original list			*/
    pathbuf szPathName; 	/* Place to put fully qualified filename*/

    if (!pcmd) {
        return;
    }

    // The user should not be able to pass in a non-macro PCMD.  The
    // user can specify a name for a list, and that name must be
    // translated into a PCMD by GetListHandle.  That function will
    // not return a PCMD for anything other than a macro.
    //
    assert ((PVOID)pcmd->func == (PVOID)macro);

    pchOld = (char *)pcmd->arg;

    len = RemoveTrailSpace (pchOld);

    if (sz[0] == '@') { /* We simply append this to the original    */
        sz[0] = ' ';
        fString = FALSE;
        strcpy (szPathName, sz);
    } else {
        CanonFilename (sz, szPathName);
        DoubleSlashes (szPathName);

        if (len && pchOld[len-1] == '"') {
            fQuote = TRUE;          /* We're appending a literal to */
            fudge = 1;              /* a list ending in a literal   */
            pchOld[len-1] = ' ';
        } else {
            fudge = 3;          /* Appending literal to non-literal */
        }
    }

    lensz = strlen (szPathName);

    /* Now generate new string  */

    pcmd->arg = (CMDDATA)ZEROREALLOC ((char *)pcmd->arg, len + lensz + fudge + 1);
    strcpy ((char *)pcmd->arg, pchOld);

    if (fString && !fQuote) {
        strcat ((char *)pcmd->arg, " \"");
    }

    strcat ((char *)pcmd->arg, szPathName);

    if (fString) {
        strcat ((char *)pcmd->arg, "\"");
    }
}




/***  fInList - Check to see if a string is already in the list
*
* Purpose:
*
*   To see if an element is in a list.
*
* Input:
*   Parameters:
*	pcmd -> List to look in
*	pch  -> Literal to look for
*
* Output:
*
*   Returns TRUE iff pch is in pcmd
*
*************************************************************************/
flagType
fInList (
    PCMD pcmd,
    char * pch,
    flagType fRecurse
    ) {

    char * pchList; /* register here increases code size */
    MI mi;

    for (pchList = ScanMyList (pcmd, &mi, bufList, fRecurse);
         pchList;
         pchList = ScanMyList (NULL, &mi, bufList, fRecurse)) {
        if (!_stricmp (pchList, pch)) {
            return TRUE;
        }
    }
    return FALSE;
}



/*** fDelStrFromList -
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fDelStrFromList (
    PCMD pcmd,
    char * pch,
    flagType fRecurse
    ) {

    strcpy (buf, pch);
    ListWalker (pcmd, CheckAndDelStr, fRecurse);

    return (flagType)(buf[0] == '\0');
}




/*** CheckAndDelStr - If str matches buf, remove it
*
* Purpose:
*
*   ListWalker callback function for fDelStrFromList.  Deletes a string from
*   a list.
*
* Input:
*   Parameters:
*	pcmd -> List to remove from
*	pch  -> Copy of the element to remove
*	pmi  -> Scan state
*	i    -> Index into pcmd of the element.
*
* Output:
*
*   Returns TRUE if successful
*
* Notes:
*
*   We use ListWalker instead of ScanList because we need access to the
*   list position itself, not a copy of the element.
*
*************************************************************************/
flagType
CheckAndDelStr(
    PCMD pcmd,
    char * pch,
    PMI pmi,            /* register doesn't help */
    int  i
    ) {

    char * pchNext; /* register doesn't help */

    if (!strcmp (pch, buf)) {
        DoubleSlashes (buf);
        pchNext = strbscan (pmi->text, " \t\"");
	memmove (pmi->text - strlen(buf), pchNext, strlen (pchNext) + 1);
        buf[0] = '\0';  /* signal success */
        return FALSE;
    }

    return TRUE;

    pcmd; i;
}




/*** GetListEntry - Given an index into a list, get the index'th element
*
* Purpose:
*
*   To get a particular list element when its position is known.
*
* Input:
*   Parameters:
*	pcmd  -> The list.
*	iList -> The index.
*
* Output:
*
*   Returns pointer to the element, or NULL if there is no iList'th element
*
*************************************************************************/
char *
GetListEntry (
    PCMD pcmd,
    int iList,
    flagType fRecurse
    ) {

    int i;
    REGISTER char * pchList;
    MI mi;

    for (pchList = ScanMyList (pcmd, &mi, bufList, fRecurse), i = 0;
         pchList && i < iList;
         pchList = ScanMyList (NULL, &mi, bufList, fRecurse), i++) {
        ;
    }
    return pchList;
}





/*** ListLen - Return the number of elements in the list
*
* Purpose:
*
*   To count the elements in a list. Useful when you don't want to toast
*   ScanList.
*
* Input:
*   Parameters:
*	pcmd -> The list.
*
* Output:
*
*   Returns Number of items in list.
*
*************************************************************************/
int
ListLen (
    PCMD pcmd,
    flagType fRecurse
    ) {

    MI mi;
    int i = 0;

    if (ScanMyList (pcmd, &mi, bufList, fRecurse)) {
        do {
            i++;
        }while (ScanMyList (NULL, &mi, bufList, fRecurse));
    }
    return i;
}




/*** fEmptyList - Test the list for being empty
*
* Purpose:
*
*   The fastest way to check for an empty list.  Useful when you don't
*   want to toast ScanList.
*
* Input:
*   Parameters:
*	pcmd -> The list, of course.
*
* Output:
*
*   Returns TRUE for empty list.
*
*************************************************************************/
flagType
fEmptyList (
    PCMD pcmd
    ) {

    MI mi;

    return (flagType)(NULL != ScanMyList (pcmd, &mi, bufList, FALSE));
}





/*** InitParse - set a search instance to the beginning of a list
*
* Purpose:
*
*   To set up a parsing instance to the beginning of a list.
*
* Input:
*   Parameters:
*	pcmd -> List
*	pmi  -> instance
*
* Output: None.
*
*************************************************************************/
void
InitParse (
    PCMD pcmd,
    PMI pmi     /* register doesn't help */
    ) {

    pmi->beg = pmi->text = (char *)pcmd->arg;
    pmi->flags = 0;
}




/*** Listize - Prepend a '@' to the argument
*
* Purpose:
*
*   To turn a string into a list name.	Works in place, assumes there is
*   room for it.
*
* Input:
*   Parameters:
*	sz -> Name to mess with
*
* Output: None.
*
*************************************************************************/
void
Listize (
    REGISTER char * sz
    ) {

    memmove ( sz+1, sz,strlen (sz)+1);
    sz[0] = '@';
}



/*** CanonFilename - Replace a simple filename with a full pathname
*
* Purpose:
*
*   To get a full pathname for a file.	The file need not exist.
*   The simple filename may be of the form $ENV:name or $(ENV):name.
*
* Input:
*
*   szName   -> Relative path/filename.
*   pchCanon -> Result.
*
* Output:
*
*   Returns pointer to full, lower-case pathaname with drive.
*
* Notes:
*
*   If szName has an $ENV specification and ENV is not defined, the
*   file is searched for in the root.
*   If given drive is a ghost drive, let the system prompt for a disk
*   change.
*
*************************************************************************/
char *
CanonFilename (
    char * szName,
    char * pchCanon
    ) {

    pathbuf buf;

    if ( strlen(szName) < sizeof(buf) ) {
        if (szName[0] == '<' || szName[0] == '\0') {
            strcpy (pchCanon, szName);
            return pchCanon;
        }

        strcpy (buf, szName);

        if ( szName
         && (szName[0] != '$' || findpath(szName, buf, TRUE))
             && !rootpath (buf, pchCanon)) {

            _strlwr (pchCanon);
            return pchCanon;
        }
    }
    return NULL;

}





/*** fEnvar - Check a filename for having a $ENV at the front
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fEnvar (
    char * szName
    ) {
    return (flagType)((szName[0] == '$') && strchr (szName, ':'));
}




/*** ClearList - Make a list empty
*
* Purpose:
*
*   To quickly empty an existing list.
*
* Input:
*   pcmd -> List to clear
*
* Output: None
*
*************************************************************************/
void
ClearList (
    PCMD pcmd
    ) {
    SetMacro ((char *)pcmd->name, rgchEmpty);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\macro.c ===
/*  macro.c - perform keystroke macro execution
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


/*  macros are simply a list of editor functions interspersed with quoted
 *  strings.  The execution of a macro is nothing more than locating each
 *  individual function and calling it (calling graphic (c) for each quoted
 *  character c).  We maintain a stack of macros being executed; yes, there is
 *  a finite nesting limit.  Sue me.
 *
 *  Each editor function returns a state value:
 *	TRUE => the function in some way succeeded
 *	FALSE => the functin in some way failed
 *
 *  There are several macro-specific functions that can be used to take
 *  advantage of these values:
 *
 *
 *  :>label	defines a text label in a macro
 *
 *  =>label	All are transfers of control.  => is unconditional transfer,
 *  ->label	-> transfers if the previous operation failed and +> transfers
 *  +>label	if the previous operation succeeded.
 *		If the indicated label is not found, all macros are terminated
 *		with an error.	If no label follows the operator it is assumed
 *		to be an exit.
 */



/*  macro adds a new macro to the set being executed
 *
 *  argData	pointer to text of macro
 */
flagType
macro (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ){
    return fPushEnviron ((char *) argData, FALSE);

    pArg; fMeta;
}





/*  mtest returns TRUE if a macro is in progress
 */
flagType
mtest (
    void
    ) {
    return (flagType)(cMacUse > 0);
}





/* mlast returns TRUE if we are in a macro and the next command must come
 * from the keyboard
 */
flagType
mlast (
    void
    ) {
    return (flagType)(cMacUse == 1
                        &&  (   (mi[0].text[0] == '\0')
                                || (   (mi[0].text[0] == '\"')
                                    && (*whiteskip(mi[0].text + 1) == '\0')
                                   )
                            )
                    );
}





/*  fParseMacro - parses off next macro command
 *
 *  fParse macro takes a macro instance and advances over the next command,
 *  copying the command to a separate buffer.  We return a flag indicating
 *  the type of command found.
 *
 *  pMI 	pointer to macro instance
 *  pBuf	pointer to buffer where parsed command is placed
 *
 *  returns	flags of type of command found
 */
flagType
fParseMacro (
    struct macroInstanceType *pMI,
    char *pBuf
    ) {

    char *p;
    flagType fRet = FALSE;

    // Make sure the instance is initialized.  This means that ->text
    // is pointing to the first command in the macro.  If this is a graphic
    // character, skip over the " and set the GRAPH flag.
    //
    if (TESTFLAG (pMI->flags, INIT)) {
	pMI->text = whiteskip (pMI->text);
	if (*pMI->text == '"') {
	    pMI->text++;
	    SETFLAG (pMI->flags, GRAPH);
        }
	RSETFLAG (pMI->flags, INIT);
    }

    if (TESTFLAG (pMI->flags, GRAPH) && *pMI->text != '\0') {
        // We are inside quotes.  If we are now looking at
        // a \, skip to the next character.  Don't forget to check
        // for a \ followed by nothing.
        //
        if (*pMI->text == '\\') {
            if (*++pMI->text == 0) {
                return FALSE;
            }
        }
	*pBuf++ = *pMI->text++;
	*pBuf = 0;

        // If the next character is a ", move -> up to the following
        // command and signal that we're out of quotes.
        //
	if (*pMI->text == '"') {
	    RSETFLAG (pMI->flags, GRAPH);
	    pMI->text = whiteskip (pMI->text+1);
        }
	fRet = GRAPH;
    } else {
        // We are outside quotes.  First read through any
        // <x commands.
        //
        while (*(pMI->text) == '<') {
            pMI->text = whiteskip(whitescan(pMI->text));
        }

        // Now skip through whitespace to the command name.
        // Copy what we find into the caller's buffer.
        //
	p = whitescan (pMI->text);
	memmove ((char*) pBuf, (char *) pMI->text, (unsigned int)(p-pMI->text));
	pBuf[p-pMI->text] = '\0';

	pMI->text = whiteskip (p);  /* Find the next thing in the macro. */
    }

    // If the next thing is a quote, enter quote mode.
    //
    if (*pMI->text == '"') {
	SETFLAG (pMI->flags, GRAPH);
	pMI->text++;
    }
    return fRet;
}





/*** fMacResponse - peek ahead and eat any embedded macro response
*
* Purpose:
*  Scans ahead in the macro text for an item beginning with a "<", which
*  supplies a response to the question asked by a preceding function.
*
* Input:
*  None
*
* Output:
*  Returns NULL if not found, -1 if the user is to be prompted, and a character
*  if a character is supplied.
*
* Exceptions:
*  none
*
*************************************************************************/
int
fMacResponse (
    void
    ) {

    int     c;
    struct macroInstanceType *pMI;

    if (mtest()) {
        pMI = &mi[cMacUse-1];
        if ((TESTFLAG (pMI->flags, INIT | GRAPH)) == 0) {
            if (*(pMI->text) != '<')
                return 0;
            c = (int)*(pMI->text+1);
            if ((c == 0) || (c == ' ')) {
                return -1;
            }
            pMI->text = whiteskip(pMI->text+2);
            return c;
        }
    }
    return -1;
}




/*  fFindLabel finds a label in macro text
 *
 *  The goto macro functions call fFindLabel to find the appropriate label.
 *  We scan the text (skipping quoted text) to find the :> leader for the label.
 *
 *  pMI 	pointer to active macro instance
 *  lbl 	label to find (case is not significant) with goto operator
 *		=>, -> or +>  This will be modified.
 *
 *  returns	TRUE iff label was found
 */
flagType
fFindLabel (
    struct macroInstanceType *pMI,
    buffer lbl
    ) {

    buffer lbuf;

    lbl[0] = ':';
    pMI->text = pMI->beg;
    while (*pMI->text != '\0') {
        if (!TESTFLAG (fParseMacro (pMI, lbuf), GRAPH)) {
            if (!_stricmp (lbl, lbuf)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}




/*  mPopToTop - clear off intermediate macros up to a fence
 */
void
mPopToTop (
    void
    ) {

    while (cMacUse && !TESTFLAG (mi[cMacUse-1].flags, EXEC)) {
        cMacUse--;
    }
}




/*  mGetCmd returns the next command from the current macro, popping state
 *
 *  The command-reader code (cmd) calls mGetCmd when a macro is in progress.
 *  We are expected to return either a pointer to the function (cmdDesc) for
 *  the next function to execute or NULL if there the current macro is finished.
 *  We will adjust the state of the interpreter when a macro finishes.	Any
 *  errors detected result in ALL macros being terminated.
 *
 *  For infinite looping inside a macro, we will look for ^C too.
 *
 *  returns	NULL if current macro finishes
 *		pointer to function descriptor for next function to execute
 */
PCMD
mGetCmd (
    void
    ) {

    buffer mname;
    PCMD pFunc;
    struct macroInstanceType *pmi;

    if (cMacUse == 0) {
        IntError ("mGetCmd called with no macros in effect");
    }
    pmi = &mi[cMacUse-1];
    while ( pmi->text &&  *pmi->text != '\0') {
        //  Use heuristic to see if infinite loop
        //
        if (fCtrlc) {
            goto mGetCmdAbort;
        }


        if (TESTFLAG (fParseMacro (pmi, mname), GRAPH)) {
            pFunc = &cmdGraphic;
                pFunc->arg = mname[0];
            return pFunc;
            }

            /*
             * if end of macro, exit
             */
            if (!mname[0]) {
                break;
            }

        _strlwr (mname);

        pFunc = NameToFunc (mname);

            //  found an editor function / macro
            //
            if (pFunc != NULL) {
            return pFunc;
            }

        if (mname[1] != '>' ||
            (mname[0] != '=' && mname[0] != ':' &&
             mname[0] != '+' && mname[0] != '-')) {
            printerror ("unknown function %s", mname);
            goto mGetCmdAbort;
            }

        /* see if goto is to be taken */
        if (mname[0] == '=' ||
            (fRetVal && mname[0] == '+') ||
            (!fRetVal && mname[0] == '-')) {

            /* if exit from current macro, then exit scanning loop
             */
                if (mname[2] == '\0') {
                    break;
                }

            /* find label
             */
            if (!fFindLabel (pmi, mname)) {
            printerror ("Cannot find label %s", mname+2);
mGetCmdAbort:
            resetarg ();
            DoCancel ();
            mPopToTop ();
            break;
                }
            }
    }

    /*	we have exhausted the current macro.  If it was entered via EXEC
     *	we must signal TopLoop that the party's over
     */
    fBreak = (flagType)(TESTFLAG (mi[cMacUse-1].flags, EXEC));
    if ( cMacUse > 0 ) {
        cMacUse--;
    }
    return NULL;
}




/*  fPushEnviron - push a stream of commands into the environment
 *
 *  The command-reader of Z (zloop) will retrieve commands either from the
 *  stack of macros or from the keyboard if the stack of macros is empty.
 *  fPushEnviron adds a new context to the stack.
 *
 *  p		character pointer to command set
 *  f		flag indicating type of macro
 *
 *  returns	TRUE iff environment was successfully pushed
 */
flagType
fPushEnviron (
    char *p,
    flagType f
    ) {
    if (cMacUse == MAXUSE) {
	printerror ("Macros nested too deep");
	return FALSE;
    }
    mi[cMacUse].beg = mi[cMacUse].text = p;
    mi[cMacUse++].flags = (flagType)(f | INIT);
    return TRUE;
}





/*  fExecute - push a new macro into the environment
 *
 *  pStr	pointer to macro string to push
 *
 *  returns	value of last executed macro.
 */
flagType
fExecute (
    char *pStr
    ) {

    pStr = whiteskip (pStr);

    if (fPushEnviron (pStr, EXEC)) {
        TopLoop ();
    }

    return fRetVal;
}





/*  zexecute pushes a new macro to the set being executed
 *
 *  arg 	pointer to text of macro
 */
flagType
zexecute (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    LINE i;
    linebuf ebuf;

    switch (pArg->argType) {

    /*  NOARG illegal   */

    case TEXTARG:
	strcpy ((char *) ebuf, pArg->arg.textarg.pText);
	fMeta = fExecute (ebuf);
	break;

    /*  NULLARG converted to TEXTARG    */

    case LINEARG:
	fMeta = FALSE;
        for (i = pArg->arg.linearg.yStart; i <= pArg->arg.linearg.yEnd; i++) {
	    if (GetLine (i, ebuf, pFileHead) != 0) {
		fMeta = fExecute (ebuf);
                if (!fMeta) {
                    break;
                }
            }
        }
        break;

    /*	STREAMARG illegal   */
    /*  BOXARG illegal      */

    }
    Display ();
    return fMeta;
    argData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\mark.c ===
/*	mark.c - do marking and repositioning
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"

PFILE       pFileMark   = NULL;    /* mark file handle                     */
flagType    fCacheDirty = 0;       /* TRUE => cache has ben changed        */
PFILE       pFileCache  = NULL;    /* Cached file                          */
FILEMARKS * pfmCache    = NULL;    /* Cached marks                         */

/* Flags for mark.flags  */

#define MF_DIRTY    1	    /* Mark has changed, but is not written	*/
#define MF_TEMP     2
#define MF_DUMMY    4	    /* This is dummry last mark 		*/



/*** mark - <mark> editor function
*
* Purpose:
*
*		       <mark> - Goes to top of file
*		  <arg><mark> - Toggle last/current window position
*	 <arg> textarg <mark> - Goes to named mark
*   <arg><arg> textarg <mark> - Defines mark at cursor
*   <arg><arg> textarg <mark> - Removes named mark
*
* Input:
*
* Output:
*
*   Returns FALSE if you try to go to a non-existent mark, TRUE
*   otherwise.
*
*************************************************************************/
flagType
mark (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
        docursor (0, (LINE)0);
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
        if (fIsNum (mbuf)) {
            docursor (0, atol (mbuf)-1);
            return TRUE;
        }
        if (pArg->arg.textarg.cArg == 2) {
            if (fMeta) {
                DeleteMark (mbuf);
            } else {
                DefineMark (mbuf, pFileHead, pArg->arg.textarg.y+1, pArg->arg.textarg.x+1, FALSE);
            }
            return TRUE;
        } else {
            return GoToMark (mbuf);
        }

    case NULLARG:
        restflip();
        return TRUE;

    /*  LINEARG illegal             */
    /*  STREAMARG illegal           */
    /*  BOXARG illegal              */

    }

    return FALSE;
    argData;
}





/*** GoToMark - Move cursor to a mark
*
* Purpose:
*
*   Goes to the named mark.
*
* Input:
*   pszMark -	Name of mark to go to.
*
* Output:
*
*   Returns TRUE if mark exists, FALSE, otherwise.
*
*************************************************************************/
flagType
GoToMark (
    char * pszMark
    ) {

    PFILE pFile;
    fl fl;

    if (pFile = FindMark (pszMark, &fl, TRUE)) {
        if (TESTFLAG(FLAGS(pFile), REAL) ||
            FileRead (pFile->pName, pFile, FALSE)) {
            pFileToTop (pFile);
            cursorfl (fl);
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        printerror ("'%s': Mark not found", pszMark);
        return FALSE;
    }
}





/*** FindMark - Get a mark's file location - used from outside
*
* Purpose:
*
*   Find a mark
*
* Input:
*   pszMark - Mark to search for.
*   fCheckAllFiles - TRUE  => Search through all files for mark
*		     FALSE => Look in only the current file
*
* Output:
*   * pfl - fl of mark.
*
*   Returns pFile of file the mark is in, NULL if mark is not found.
*
*************************************************************************/
PFILE
FindMark (
    char * pszMark,
    fl * pfl,
    flagType fCheckAllFiles
    ) {

    REGISTER PFILE pFile;
    MARK UNALIGNED*  pm;
    char    szMark[BUFLEN];
    char    szFile[BUFLEN];
    linebuf lbuf;
    LINE    y, l;
    COL     x;

    // If we are checking the current file only,
    // make sure it's cached and check it.
    //
    if (!fCheckAllFiles) {
        if (fCacheMarks (pFileHead) &&
            (pm = FindLocalMark (pszMark, FALSE))) {
            *pfl = pm->fl;
            //return pFile;
            return pFileHead;
        } else {
            return NULL;
        }
    }

    // Now, trundle through the pFile list
    // looking at the marks we have already
    // read from the markfile.
    //
    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (TESTFLAG (FLAGS(pFile), VALMARKS) && fCacheMarks (pFile)) {
            if (pm = FindLocalMark (pszMark, FALSE)) {
                *pfl = pm->fl;
                return pFile;
            }
        }
    }

    // None of the files we have read so far
    // has the mark defined. We'll make one
    // pass through the markfile to see if
    // it's there.
    //
    if (pFileMark) {
        for (l = 0L; l < pFileMark->cLines; l++) {
            GetLine (l, lbuf, pFileMark);
            if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, buf, &y, &x) >= 3)
            if (!_stricmp (szMark, pszMark)) {
                CanonFilename (buf, szFile);
                if (!(pFile = FileNameToHandle (szFile, NULL))) {
                    pFile = AddFile (szFile);
                }
                (void)fReadMarks (pFile);
                pfl->lin = y - 1;
                pfl->col = x - 1;
                return pFile;
            }
        }
    }
    return NULL;
}




/*** FindLocalMark - Find a mark in a FILEMARKS structure
*
* Purpose:
*
*   To find a mark in the cached marks.  If found, a pointer into
*   the cache is returned,
*
* Input:
*   pszMark	- Mark Name
*   fDirtyOnly	- TRUE => Return only changed marks.
*
* Output:
*
*   Returns pointer to mark.
*
*************************************************************************/
MARK *
FindLocalMark (
    char * pszMark,
    flagType fDirtyOnly
    ) {

    REGISTER MARK UNALIGNED * pm;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; (char *)pm += pm->cb) {
        if (!_stricmp (pszMark, pm->szName)) {
            if (fDirtyOnly && !TESTFLAG(pm->flags, MF_DIRTY)) {
                return NULL;
            } else {
                return (MARK *)pm;
            }
        }
        assert (pm->cb);
    }
    return NULL;
}





/*** GetMarkFromLoc - Return the first mark past a given location
*
* Purpose:
*
*   To get a pointer to a mark given its file location.
*
* Input:
*   x, y - Mark location
*
* Output:
*
*   Returns Pointer to the mark.
*
*************************************************************************/
MARK *
GetMarkFromLoc (
    LINE y,
    COL  x
    ) {

    REGISTER MARK UNALIGNED * pm;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; (char *)pm += pm->cb) {
        if (pm->fl.lin > y || ((pm->fl.lin == y) && (pm->fl.col >= x))) {
            break;
        }
    }
    return (MARK *) pm;
}




/*** SetMarkFile - Change markfile
*
* Purpose:
*
*   Changes to a new markfile.
*
* Input:
*   val - String after the 'markfile' switch
*
* Output:
*
*   Returns Error string if error, NULL otherwise
*
* Notes:
*
*   We:
*
* UNDONE:o Magically ensure that the current markfile is up to date and
*	  saved to disk.  This means, at the very least, that there
*	  can be no dirty files.
*
*	o Remove the current markfile from the file list.
*
*	o Read in the new markfile.
*
*	o Invalidate all current marks.  This is just marking them
*	  invalid in the PFILE.
*
*
*************************************************************************/
char *
SetMarkFile (
    char *val
    ) {

    REGISTER PFILE pFile;
    buffer  tmpval;
    pathbuf pathname;

    strcpy ((char *) tmpval, val);

    if (NULL == CanonFilename (tmpval, pathname)) {
        sprintf (buf, "'%s': name is malformed", tmpval);
        return buf;
    }

    if (!(pFile = FileNameToHandle (pathname, NULL))) {
        pFile = AddFile (pathname);
    }

    if (!TESTFLAG(FLAGS(pFile), REAL) && !FileRead (pathname, pFile, FALSE)) {
        RemoveFile (pFile);
        sprintf (buf, "'%s' - %s", pathname, error());
        return buf;
    }

    pFileMark = pFile;

    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (!TESTFLAG(FLAGS(pFile), FAKE)) {
            RSETFLAG (FLAGS(pFile), VALMARKS);
        }
    }
    return NULL;
}





/*** MarkInsLine - Adjust marks after an InsLine
*
* Purpose:
*
*   After InsLine inserts a bunch of blank lines, it calls this to update
*   any marks that would be "moved down".
*
* Input:
*   line - line number at which insertion took place
*   n	 - Number of new lines
*   pFile- File this occurred in
*
* Output: None
*
*************************************************************************/
void
MarkInsLine (
    LINE line,
    LINE n,
    PFILE pFile
    ) {

    MARK UNALIGNED * pm;

    if (!fCacheMarks (pFile)) {
        return;
    }

    if (pm = GetMarkFromLoc (line, 0)) {
        AdjustMarks ((MARK *)pm, n);
    }
}





/*** MarkDelStream - Adjust Marks after a DelStream
*
* Purpose:
*
*   After DelStream or DelLines removes a stream (DelLine removes a
*   "stream" with the beginning and ending points at the left and right
*   edges of the file), this takes care of updating any remaining
*   marks.
*
* Input:
*   pFile  - Affected file
*   xStart - 0-based starting point
*   yStart
*   xEnd   - 0-based ending point
*   yEnd
*
* Output: None
*
*************************************************************************/
void
MarkDelStream (
    PFILE pFile,
    COL  xStart,
    LINE yStart,
    COL  xEnd,
    LINE yEnd
    ) {

    REGISTER MARK UNALIGNED * pm;
    MARK UNALIGNED *      pmStart = NULL;
    MARK UNALIGNED *      pmEnd = NULL;
    fl          flStart;
    fl          flEnd;
    flagType    fAgain = FALSE;

    if (!fCacheMarks (pFile)) {
        return;
    }

    /* yEnd++;  WHY? */
    flStart.lin = yStart;
    flStart.col = xStart;
    flEnd.lin = yEnd;
    flEnd.col = xEnd;

    for (pm = pfmCache->marks; pmEnd == NULL ; (char *)pm += pm->cb) {
        // Look for first mark past beginning
        // of stream. Assume for the moment that
        // it is inside the stream
        //
        if (pmStart == NULL) {
            if (flcmp (&flStart, (fl *) &pm->fl) < 1) {
                pmStart = pm;
            } else {
                continue;
            }
        }

        // A first mark has been found. We start
        // looking for the first mark past the end
        // of the stream.  If these are the same,
        // there are no marks to remove.
        //
        if (flcmp (&flEnd, (fl *) &pm->fl) < 1) {
            // We know that we will end up here
            // because the last "mark" is higher
            // than any real mark
            //
            if ((pmEnd = pm) != pmStart)
                // We're here if there were
                // any marks inside the deleted
                // stream
                //
                memmove ((char *)pmStart,
                         (char *)pmEnd,
                        (unsigned int)(((char *)pfmCache + pfmCache->cb) - (char *)pmEnd ));

            if (pmStart->fl.lin == yEnd) {
                pmStart->fl.col -= xEnd;
            }
            AdjustMarks ((MARK *)pmStart, yStart - (yEnd + 1));
        }

        assert (pm->cb ||
                (TESTFLAG(pm->flags, MF_DUMMY) &&
                pm->fl.lin == 0x7FFFFFFF &&
                pm->fl.col == 0x7FFF));
    }
}






/*** MarkDelBox - Adjust Marks after a DelBox
*
* Purpose:
*
*   After deleting a box of text, we must remove any marks that are
*   defined inside it, then shift left any marks that are to the
*   right of it.
*
* Input:
*   pFile - Affected file
*   xLeft, yTop - Upper left hand corner of box
*   xRight, yBottom - Lower right hand corner of box
*
* Output: None
*
*************************************************************************/
void
MarkDelBox (
    PFILE pFile,
    COL  xLeft,
    LINE yTop,
    COL  xRight,
    LINE yBottom
    ) {

    MARK UNALIGNED *   pm;
    MARK UNALIGNED *   pmStart = NULL;
    MARK UNALIGNED *   pmEnd = NULL;
    fl       flUpLeft;
    fl       flLoRight;
    flagType fAgain;
    flagType fInBox = FALSE;	/* Marks are within box top/bottom */

    if (!fCacheMarks (pFile)) {
        return;
    }

    /* yBottom++;  WHY? */
    flUpLeft.lin = yTop;
    flUpLeft.col = xLeft;
    flLoRight.lin = yBottom;
    flLoRight.col = xRight;


    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY) ; !fAgain && ((char *)pm += pm->cb)) {
        /* First, look for lowest possible mark */
        fAgain = FALSE;
        if (!fInBox) {
            if (flcmp (&flUpLeft, (fl *) &pm->fl) < 1) {
                fAgain = TRUE;
                fInBox = TRUE;
            } else {
                ;
            }
        } else if (flcmp ((fl *) &pm->fl, &flLoRight) < 1) {
            /* Now we're in range.  Check
            ** for being inside the box.
            */
            if (pm->fl.col >= xLeft) {
                if (pm->fl.col <= xRight) {
                    DelPMark ((MARK *) pm);
                    fAgain = TRUE;
                } else {   /* Mark to the right of box */
                    pm->fl.col -= xRight - xLeft + 1;
                }
            } else {
                ;
            }
        } else {
            if (pm->fl.lin == yBottom) {
                pm->fl.col -= xRight - xLeft + 1;
            } else {
                break;      /* We've gone past the box */
            }
        }
    }
}





/*** fReadMarks - Read marks from the current markfile
*
* Purpose:
*
*   Gets the current marks for a given file.
*
* Input:
*   pFile - File to read marks for.
*
* Output:
*
*   Returns TRUE if pFile has marks and they are in VM, FALSE otherwise.
*
*************************************************************************/
flagType
fReadMarks (
    PFILE pFile
    ) {

    FILEMARKS UNALIGNED * pfm = NULL;
    LINE        l;
    char        szMark[BUFLEN];
    char        szFile[BUFLEN];
    linebuf     lbuf;
    LINE        yMark;
    COL         xMark;


    if (TESTFLAG (FLAGS(pFile), VALMARKS)) {
		return (flagType)(pFile->vaMarks != NULL);
    }

    // psuedo files cannot have marks
    // saved in the markfile.
    //
    if (pFileMark == NULL || TESTFLAG(FLAGS(pFile), FAKE)) {
        return FALSE;
    }

    for (l = 0L; l < pFileMark->cLines; l++) {
        GetLine (l, lbuf, pFileMark);
        if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, szFile, &yMark, &xMark) >= 3) {
            if (!_stricmp (szFile, pFile->pName)) {
                UpdMark ((FILEMARKS **) &pfm, szMark, yMark, xMark, FALSE);
            }
        }
    }

    // Now pfm points to a good FILEMARKS structure.
    // First, throw away current marks.  Then, if we
    // actually found some marks for this file, we
    // put them in VM.
    //
    return fFMtoPfile (pFile, (FILEMARKS *)pfm);
}




/*** WriteMarks - Write Marks back out to the markfile.
*
* Purpose:
*
*   To update the markfile if any marks have changed
*
* Input:
*   pFile - owner of the marks
*
* Output: None.
*
*************************************************************************/
void
WriteMarks (
    PFILE pFile
    ) {

    REGISTER MARK UNALIGNED * pm;
    char            szMark[BUFLEN];
    char            szFile[BUFLEN];
    linebuf         lbuf;
    LINE            yMark, l;
    COL             xMark;

    if (pFileMark == NULL || TESTFLAG(FLAGS(pFile), FAKE)) {
        return;
    }

    if (!fCacheMarks (pFile)) {
        return;
    }

    // First, we read the whole file looking for marks for
    // this file.  When we find one, we look it up in the
    // cache to find the new value and write it back
    // out.  Unchanged marks are not re-written.
    //
    for (l = 0L; l < pFileMark->cLines; l++) {
        GetLine (l, lbuf, pFileMark);
        if (sscanf (lbuf, " %[^ ] %[^ ] %ld %d ", szMark, szFile, &yMark, &xMark) >= 3) {
            if (!_stricmp (szFile, pFile->pName)) {
                if (pm = FindLocalMark (szMark, TRUE)) {
                    sprintf (lbuf, "%s %s %ld %d", szMark, szFile, pm->fl.lin+1, pm->fl.col+1);
                    PutLine (l, lbuf, pFileMark);
                    RSETFLAG (pm->flags, MF_DIRTY);
                }
            }
        }
    }

    // Now we read through the cache to find any new marks.  These
    // will be appended to the markfile.
    //
    for (   pm = pfmCache->marks;
            !TESTFLAG(pm->flags, MF_DUMMY);
            (char *)pm += pm->cb) {

        if (TESTFLAG (pm->flags, MF_DIRTY)) {
            sprintf (lbuf, "%s %s %ld %d", pm->szName,
                                          pFile->pName,
                                          pm->fl.lin + 1,
                                          pm->fl.col + 1);
            AppFile (lbuf, pFileMark);
        }
    }
}





/*** UpdMark - Add a mark to a FILEMARKS
*
* Purpose:
*
*   This creates the FILEMARKS structure, adds marks to it and
*   updates existing marks in it.  The caller does not need to
*   know which of these is going to happen.
*
* Input:
*   ppfm    - Pointer to a pointer to FILEMARKS.
*   pszMark - Mark name.
*   yMark   - Mark location (1-based)
*   xMark
*   fTemp   - TRUE => This marks should not be written to the markfile
*
* Output: None.  *ppfm may be changed
*
* Notes:
*
*   The first argument is a ** because the * will be updated when a
*   re-LMAlloc is required.
*
*************************************************************************/
void
UpdMark (
    FILEMARKS ** ppfm,
    char       * pszMark,
    LINE         yMark,
    COL          xMark,
    flagType     flags
    ) {

    FILEMARKS UNALIGNED * pfm;
    FILEMARKS UNALIGNED * pfmOld;         /* pfm prior to realloc     */
    REGISTER MARK UNALIGNED * pm;
    int      cbNewMark;
    fl       flMark;
    flagType fExist = FALSE;

    assert (ppfm);

    /* Convert to 0-based */
    flMark.lin = yMark-1;
    flMark.col = xMark-1;
    cbNewMark  = sizeof(MARK) + strlen(pszMark);

    // If we already have a FILEMARKS structure,
    // we look for the slot in pfm->marks
    // where the new mark will go.
    //
    if (pfm = *ppfm) {
        for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
            if (!_stricmp (pszMark, pm->szName)) {
                fExist = TRUE;
                break;
            }

            // Check for current mark coming later than
            // new mark
            //
            if (flcmp ((fl *) &pm->fl, &flMark) > 0) {
                break;
            }
        }
    } else {
        // New structure.  Allocate mem and create
        // a dummy mark.
        //
        pfm = (FILEMARKS *)ZEROMALLOC (sizeof(FILEMARKS));
        pfm->cb = sizeof(FILEMARKS);
        pm = pfm->marks;
        pm->cb = sizeof(MARK);
        pm->fl.lin = 0x7FFFFFFF;
        pm->fl.col = 0x7FFF;
        pm->szName[0] = '\0';
        pm->flags = MF_DUMMY;
    }

    // At this point, pfm points to the current FILEMARKS
    // structure, and pm points into that structure at
    // the place where the new mark will go, or the existing
    // mark be updated.
    //
    if (!fExist) {

        pfmOld = pfm;

        // First, get enough extra space for a new mark, adjusting pm
        // if a new alloc was required
        //
		pfm = (FILEMARKS *)ZEROREALLOC((PVOID)pfm, pfm->cb + cbNewMark);
        if (pfmOld != pfm) {
            pm = (MARK *)((char *)pfm + ((char *)pm - (char *)pfmOld));
        }

        // Now pm points to the location in pfm where
        // our new mark should go.  We will move the
        // original filemarks up to leave space for the
        // new one.
        //
        memmove ((char *)((char *)pm + cbNewMark),
                (char *)pm,
                (unsigned int)(pfm->cb - ((char *)pm - (char *)pfm)));

        strcpy (pm->szName, pszMark);
        pm->flags = 0;
        pm->cb = cbNewMark;

        pfm->cb += cbNewMark;
    }

    if (pfm == pfmCache) {
        fCacheDirty = TRUE;
    }
    pm->flags = flags;
    pm->fl = flMark;

    *ppfm = (FILEMARKS *)pfm;
}




/*** DefineMark - Add new mark / update existing mark
*
* Purpose:
*
*   This is called from the outside to create/update marks.
*
* Input:
*   pszMark - Mark's name
*   pFile   - File the mark will be in
*   y, x    - File location of the mark (1-based)
*   fTemp   - True -> the mark is temporary
*
* Output: None.
*
*************************************************************************/
void
DefineMark (
    char * pszMark,
    PFILE pFile,
    LINE y,
    COL  x,
    flagType fTemp
    ) {

    flagType fFirstMark = (flagType)!fCacheMarks (pFile);

    if (fFirstMark) {
        FreeCache ();
    }

    UpdMark (&pfmCache, pszMark, y, x, (flagType)(MF_DIRTY | (fTemp ? MF_TEMP : 0)));

    if (fFirstMark) {
	pFileCache = pFile;
	(void)fFMtoPfile (pFile, pfmCache);
    }
}





/*** DeleteMark - Remove a mark
*
* Purpose:
*
*   Un-define a mark.
*
* Input:
*   pszMark - Mark to remove
*
* Output: None
*
* Notes:
*
*   A message is displayed reporting on success or failure.
*
*************************************************************************/
void
DeleteMark (
    char * pszMark
    ) {

    REGISTER PFILE pFile;
    MARK UNALIGNED * pm;

    for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
        if (TESTFLAG (FLAGS(pFile), VALMARKS) && fCacheMarks (pFile)) {
            if (pm = FindLocalMark (pszMark, FALSE)) {
                DelPMark ((MARK *)pm);
                domessage ("%s: mark deleted", pszMark);
                return;
            }
        }
    }
    printerror ("%s: Mark not found", pszMark);
}




/*** DelPMark - Remove a mark when a pointer to the MARK is known
*
* Purpose:
*
*   Physically remove a mark from a FILEMARKS structure
*
* Input:
*   pm - Pointer (into pfmCache) of mark to remove
*
* Output: None
*
*************************************************************************/
void
DelPMark (
    MARK * pm
    ) {

    MARK UNALIGNED * p;
    int cb;

    p   = pm;
    cb  = p->cb;

	memmove ((char *)pm,
		 (char *)((char *)pm + cb),
		(unsigned int)(((char *)pfmCache + pfmCache->cb) - ((char *)pm + cb)));

	pfmCache->cb -= cb;
}





/*** MarkCopyLine - Copy marks after a CopyLine call
*
* Purpose:
*
*   When CopyLine moves stuff from or to the clipboard, this moves marks
*   with it.
*
* Input:
*   pFileSrc - File moved from
*   pFileDst - File moved to
*   yStart   - First line from pFileSrc
*   yEnd     - Last number from pFileDst
*   yDst     - Target line in pFileDst
*
* Output: None
*
* Notes:
*
*   Marks are copied only from and to the clipboard.
*
*
*************************************************************************/
void
MarkCopyLine (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    LINE    yStart,
    LINE    yEnd,
    LINE    yDst
    ) {

    FILEMARKS * pfm;

    if (pFileSrc != pFilePick && pFileDst != pFilePick) {
        return;
    }

    if (NULL == (pfm = GetFMFromFile (pFileSrc, 0, yStart, sizeof(linebuf)-1, yEnd))) {
        return;
    }

    AddFMToFile (pFileDst, pfm, 0, yDst);

	if ( pfm ) {
		FREE (pfm);
	}
}




/*** MarkCopyBox - Copy marks after a CopyBox call
*
* Purpose:
*
*   When CopyBox moves stuff from or to the clipboard, this moves marks
*   with it.
*
* Input:
*   pFileSrc	    - File moved from
*   pFileDst	    - File moved to
*   xLeft, yTop     - Upper left corner of source box
*   xRight, yBottom - Lower right corner of source box
*   xDst, yDst	    - Upper left corner of target
*
* Output: None
*
* Notes:
*
*   Marks are copied only from and to the clipboard.
*
*************************************************************************/
void
MarkCopyBox (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom,
    COL     xDst,
    LINE    yDst
    )
{

    FILEMARKS UNALIGNED * pfm;

    /* User is inserting blank region. */
    if (pFileSrc == NULL) {
        pFileSrc = pFileDst;
        xDst = xRight + 1;
        xRight = sizeof(linebuf);
    } else if (pFileSrc != pFileDst &&
        pFileSrc != pFilePick &&
        pFileDst != pFilePick) {
        return;
    }

    if (NULL == (pfm = GetFMFromFile (pFileSrc, xLeft, yTop, xRight, yBottom))) {
        return;
    }

    AddFMToFile (pFileDst, (FILEMARKS *)pfm, xDst, yDst);

	if ( pfm ) {
		FREE (pfm);
	}
}





/*** GetFMFromFile - Generate a FILEMARKS for marks in a file region
*
* Purpose:
*
*   Generates a subset of a FILEMARKS structure whose marks fall
*   within a certain range.  Needed by MarkCopy*.
*
* Input:
*   pFile	    - File to get marks from
*   xLeft, yTop     - Start of range
*   xRight, yBottom - End of range
*
* Output:
*
*   Returns Pointer to new structure, NULL if there are no marks in range
*
*************************************************************************/
FILEMARKS *
GetFMFromFile (
    PFILE   pFile,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom
    )
{

    FILEMARKS UNALIGNED * pfm = NULL;
    REGISTER MARK UNALIGNED * pm;
    fl       flStart;
    fl       flEnd;
    flagType fInRange = FALSE;

    if (!fCacheMarks (pFile)) {
        return NULL;
    }

    flStart.lin = yTop;
    flStart.col = xLeft;
    flEnd.lin = yBottom;
    flEnd.col = xRight;

    for (pm = pfmCache->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
        if ((fInRange || flcmp (&flStart, (fl *) &pm->fl) < 1) &&
            (flcmp ((fl *) &pm->fl, &flEnd) < 1)) {
            fInRange = TRUE;
            if ((pm->fl.col >= xLeft && pm->fl.col <= xRight)) {
                UpdMark (   (FILEMARKS **) &pfm,
                            pm->szName,
                            pm->fl.lin - yTop + 1,
                            pm->fl.col - xLeft + 1,
                            (flagType)pm->flags);
            }
        } else {
            break;  /* We're out of range again*/
        }
    }
    return (FILEMARKS *) pfm;
}




/*** AddFMToFile - Add a bunch of marks to a file
*
* Purpose:
*
*   Insert the marks from one FILEMARKS structure into another.  The
*   target structure is in pfmCache.
*
* Input:
*   pFile - Target file
*   pfm   - Source marks
*   cZero - # of columns to adjust source marks to fit into target file
*   zZero - # of lines to adjust source marks to fit into target file
*
* Output: None
*
*************************************************************************/
void
AddFMToFile (
    PFILE       pFile,
    FILEMARKS * pfm,
    COL         cZero,
    LINE        lZero
    )
{

    REGISTER MARK UNALIGNED * pm;

    if (lZero || cZero) {
        for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
            pm->fl.lin += lZero;
            pm->fl.col += cZero;
        }
    }

    if (!fCacheMarks (pFile)) {
        (void)fFMtoPfile (pFile, pfm);
        return;
    }

    for (pm = pfm->marks; !TESTFLAG(pm->flags, MF_DUMMY); (char *)pm += pm->cb) {
        UpdMark (&pfmCache, pm->szName, pm->fl.lin+1, pm->fl.col+1, (flagType)pm->flags);
    }
}





/*** FreeCache - Write a cache to VM
*
* Purpose:
*
*   To save the marks for a file into VM.
*
* Input: None
*
* Output: None
*
*************************************************************************/
void
FreeCache (
    void
    ) {

    if (pFileCache) {

        assert (pfmCache);

        if (fCacheDirty) {
			if (pFileCache->vaMarks != NULL) {
				FREE(pFileCache->vaMarks);
				pFileCache->vaMarks = NULL;
            }

            // PREFIX!  This MALLOC is not checked for failure
            memmove(pFileCache->vaMarks = MALLOC ((long)pfmCache->cb),
                    (char *)pfmCache,
                    pfmCache->cb);
        }

        FREE (pfmCache);
		pFileCache	= NULL;
		pfmCache	= NULL;
        fCacheDirty = FALSE;
    }
}






/*** fCacheMarks - Copy marks to a cache.  Save caches contents if nec.
*
* Purpose:
*
*   Before most mark operations can take place, the cache must contain
*   the marks for the given file.
*
* Input:
*   pFile - File to cache marks for.
*
* Output:
*
*   Returns FALSE if the file has no marks, TRUE otherwise.
*
* Notes:
*
*   On return the cache is usable whether or not the given file had marks.
*
*************************************************************************/
flagType
fCacheMarks (
    PFILE pFile
    ) {

	unsigned cbCache;
    FILEMARKS UNALIGNED *Marks;

    assert (pFile);

    // First we make sure that the VM version of
    // marks is updated for this file.  fReadMarks
    // return TRUE iff the file has marks and they
    // are in VM.
    //
    if (fReadMarks (pFile)) {

        // The marks are ready to be cached.  First,
        // let's see if they are already chached.
        //
        if (pFileCache == pFile) {
            return TRUE;
        }

        // They're not. If the cache is currently
        // being used, we save it and clear it.
        //
        FreeCache ();

        // Finally, alloc a new cache, plop
        // the marks into it and mark the
        // cache in use.
		//
		Marks = (FILEMARKS *)(pFile->vaMarks);
                // PREFIX! This MALLOC is not checked for failure
		pfmCache = (FILEMARKS *)ZEROMALLOC (cbCache = (unsigned)(Marks->cb) );

        memmove((char *)pfmCache, pFile->vaMarks, cbCache);

        pFileCache  = pFile;
        fCacheDirty = FALSE;

        return TRUE;
    } else { /* No marks, return FALSE */
        return FALSE;
    }
}






/*** AdjustMarks - Change later marks when one has changed
*
* Purpose:
*
*   To update marks in a FILEMARKS structure after some lines have been
*   added or removed.
*
* Input:
*   pm	   - pointer to first mark that has changed.
*   yDelta - Number of lines to change by.  May be negative
*
* Output: None
*
*************************************************************************/
void
AdjustMarks (
    REGISTER MARK * pm,
    LINE yDelta
    ) {

    REGISTER MARK UNALIGNED * pm1;

    assert (pm);

    pm1 = pm;
    for (;!TESTFLAG(pm1->flags, MF_DUMMY); (char *)pm1 += pm1->cb) {
        pm1->fl.lin += yDelta;
        SETFLAG (pm1->flags, MF_DIRTY);
    }
    fCacheDirty = TRUE;
}






/*** fFMtoPfile - Attach a FILEMARKS structure to a pFile.
*
* Purpose:
*
*   To attach some marks to a file.
*
* Input:
*   pFile   - File to get the marks
*   pfm     - The marks
*
* Output:
*
*   Returns TRUE if there were any marks, FALSE if not.
*
*************************************************************************/
flagType
fFMtoPfile (
    PFILE       pFile,
    FILEMARKS * pfm
    ) {

    SETFLAG (FLAGS(pFile), VALMARKS);

	if (pFile->vaMarks != NULL) {
		FREE(pFile->vaMarks);
		pFile->vaMarks = NULL;
    }
	return (flagType)((pFile->vaMarks = FMtoVM (pfm)) != NULL);
}





/*** fFMtoPfile - Copy a FILEMARKS structure into VM, return address
*
* Purpose:
*
*   To convert a local FILEMARKS structure into a VM copy.  Allocates
*   the VM and frees the local memory.
*
* Input:
*   pfm -   Pointer to FILEMARKS.  May be NULL.
*
* Output:
*
*
*************************************************************************/
PVOID
FMtoVM (
    FILEMARKS * pfm
    ) {

	PVOID l = NULL;

	if (pfm) {

        l = MALLOC ((long)(pfm->cb));
		memmove(l, (char *)pfm, pfm->cb);

		//
		//	I do not free pfm here because this should be done by the
		//	caller.
		//
		// if (pfm != pfmCache) {
		//	  FREE (pfm);
		// }

	}

    return l;
}




/*** GetMarkRange - Get a VM copy of a range of marks
*
* Purpose:
*
*   Used by <undo> to get the marks attached to a piece of a file.
*
* Input:
*   pFile - File to check
*   xLeft, yTop - Upper left corner of range
*   xRight, yBottom - Lower right corner of range
*
* Output:
*
*	Returns VM address of structure
*
*************************************************************************/
PVOID
GetMarkRange (
    PFILE pFile,
    LINE  yStart,
    LINE  yEnd
    ) {
    return FMtoVM (GetFMFromFile (pFile, 0, yStart, sizeof(linebuf), yEnd));
}




/*** PutMarks - Put marks back into a file.
*
* Purpose:
*
*   Used by <undo> to restore marks to a file.
*
* Input:
*   pfm -   Pointer to FILEMARKS.  May be NULL.
*
* Output:
*
*
*************************************************************************/
void
PutMarks (
    PFILE pFile,
    PVOID vaMarks,
    LINE  y
    ) {

    FILEMARKS UNALIGNED * pfm;
	FILEMARKS * Marks;
    unsigned cb;

	if ( vaMarks ) {

		Marks = ((FILEMARKS *)vaMarks);

		pfm = (FILEMARKS *)ZEROMALLOC (cb = (unsigned)Marks->cb);
		memmove((char *)pfm, vaMarks, cb);

		AddFMToFile (pFile, (FILEMARKS *) pfm, 0, y);
	}
}





/*** flcmp - Returns relative position of two FL's
*
* Purpose:
*
*   Useful for comparing the positions of two marks.
*
* Input:
*   pfl1    - "Left side" mark
*   pfl2    - "Right side" mark
*
* Output:
*
*   Returns:
*
*	< 0	*pfl1 < *pfl2
*	= 0	*pfl1 = *pfl2
*	> 0	*pfl1 > *pfl2
*
*
*************************************************************************/
int
flcmp (
    REGISTER fl * pfl1,
    REGISTER fl * pfl2
    ) {

    REGISTER fl UNALIGNED * fl1 = pfl1;
    REGISTER fl UNALIGNED * fl2 = pfl2;

    if (fl1->lin < fl2->lin) {
        return -1;
    } else if (fl1->lin == fl2->lin) {
        return fl1->col - fl2->col;
    } else {
        return 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\mepstr.c ===
/************************************************************************
 *
 *              Microsoft Editor Messages and strings
 *
 *
 *  This file contains all the messages and strings used in MEP.
 *
 *
 * Revision History:
 *
 *          9/28/90     ramonsa     Adapted from original msg.txt file
 *
 ************************************************************************/



/************************************************************************
 *
 *  String constants
 *
 *  Strings that are used only in a few places and that are used only by
 *  MEP are declared here.
 *
 ************************************************************************/







/************************************************************************
 *
 *  Messages
 *
 *  Strings that might be shared are declared here for now. When the new
 *  message retriever is ready this might change.
 *
 *  String constants are also declared here (for eliminating duplications)
 *  if:
 *
 *  -   They are long
 *  -   They are used in different places but are not used extremely often
 *      (if they are used too often then they might be defined up here
 *      as constants to reduce the overhead at the expense of wasting
 *      memory.
 *
 *
 *  NOTE:
 *
 *      Messages must have a number assigned in msg.h
 *
 ************************************************************************/

#include "mep.h"


MSG_TXT MsgStr[] = {

//
//       8000 series: error messages
//                                                                  // 8001
    MSGERR_INV_ARG,     "Invalid Argument",                         // 8002
    MSGERR_ARG_REQ,     "Argument Required",                        // 8003
    MSGERR_NOEDIT,      "No-Edit file may not be modified",         // 8004
    MSGERR_NOREP,       "No command to repeat",                     // 8005
    MSGERR_NOCREAT,     "Cannot create %s - %s",                    // 8006
    MSGERR_OPEN,        "Cannot open %s - %s",                      // 8007
    MSGERR_RONLY,       "%s is read-only",                          // 8008
    MSGERR_SPACE,       "Out of space on %s",                       // 8009
    MSGERR_DEL,         "Can't delete %s - %s",                     // 8010
    MSGERR_REN,         "Can't rename %s to %s - %s",               // 8011
    MSGERR_OLDVER,      "Can't delete old version of %s",           // 8012
    MSGERR_SAVEDIR,     "Cannot save to directory: %s",             // 8013
    MSGERR_STFILE,      "Unsupported status file version",          // 8014
    MSGERR_UNDO,        "Nothing to UnDo",                          // 8015
    MSGERR_REDO,        "Nothing to ReDo",                          // 8016
    MSGERR_ITHREAD,     "Unable to start Idle thread",              // 8017
    MSGERR_CTHREAD,     "Unable to start compile thread",           // 8018
    MSGERR_PTHREAD,     "Unable to start printing thread",          // 8019
    MSGERR_TOOLS,       "Unable to read TOOLS.INI[%s]",             // 8020
    MSGERR_ZFORMAT,     "Unrecognized %% command in '%s'",          // 8021
    MSGERR_ZTELL,       "%s is not an editor function or macro",    // 8022
    MSGERR_CMPCMD,      "No compile command known",                 // 8023
    MSGERR_CMPCMD2,     "No compile command known for %s",          // 8024
    MSGERR_CMPFULL,     "Compile list full, try later",             // 8025
    MSGERR_CMPCANT,     "Cannot compile",                           // 8026
    MSGERR_CMPSRC,      "Source file not found: %s",                // 8027
    MSGERR_PRTFULL,     "Print list full, try later",               // 8025
    MSGERR_PRTCANT,     "Cannot print",
    MSGERR_NOMEM,       "Not enough memory",
    MSGERR_QUIT,        "Cannot recover from previous error, will quit",
//
//       9000 series: <assign> file text
//
    MSG_ASSIGN_HDR,     "; Assigning Editor Functions and Macros to Keystrokes", // 9001
            9002,       ";",
            9003,       ";   o To assign a function to a new key, find a line of the form",
            9004,       ";     \"func:keyname\" and replace \"keyname\" with the name of the new key.",
            9005,       ";",
            9006,       ";   o To remove a function from a given key, find the line that reads",
            9007,       ";     \"unassigned:\"  and append the key name.",
            9008,       ";",
            9009,       ";   o The assignment you make will not take effect until you move the",
            9010,       ";     cursor to a different line.  When you do, the line will be highlighted.",
            9011,       ";",
            9012,       ";   o To make the assignment permanent, save this file.",
            9013,       ";",
            9014,       ";   o A list of unused keys is shown after the assignment list.",
            9015,       ";",
            9016,       ";   o To return to editing, use the File menu to switch back to your",
            9017,       ";     file.",
            9018,       "?",

    MSG_SWITCH_HDR,     "; Setting Editor Switch Values", // 9025
            9026,       ";",
            9027,       ";   o To change the value of a switch, find the line that shows the",
            9028,       ";     current value and enter a new value.",
            9029,       ";",
            9030,       ";   o The change you make will not take effect until you move the cursor",
            9031,       ";     to a different line.",
            9032,       "?",


    MSG_KEYS_HDR1,      ";                                Available Keys", // 9050
            9051,       ";",
            9052,       ";------------------------------------------------------------------------------",
            9053,       "?",
    MSG_KEYS_HDR2,      ";    PLAIN      |     SHIFT     |     CTRL      |      ALT      |  SHIFT+CTRL", // 9054
            9055,       ";------------------------------------------------------------------------------",
            9056,       "?",

    MSG_ASG_FUNC,       ";   Instrinsic Editor Functions", // 9061
    MSG_ASG_MACROS,     ";   Macros",                      // 9062
    MSG_ASG_NUMER,      ";   Numeric Switches",            // 9063
    MSG_ASG_BOOL,       ";   Boolean Switches",            // 9064
    MSG_ASG_TEXT,       ";   Text Switches",               // 9065
    MSG_ASG_CLIP,       "The clipboard is empty",          // 9066
    MSG_ASG_LINES,      "%ld line%s in %s clipboard",      // 9067
    MSG_ASG_PAGES,      "%d virtual pages",                // 9068
//
//       10000 series: misc utility text
//
    MSG_PRESS_ANY,      "Press any key...",                          // 10000
    MSG_ARGCOUNT,       "Arg [%d]",                                  // 10001
    MSG_NEXTFILE,       "Next file is %s...",                        // 10002
    MSG_SAVING,         "Saving %s...",                              // 10003
    MSG_TELLPROMPT,     "Press key to tell about:",                  // 10004
    MSG_SAVEALL,        "Save all remaining changed files (Y/N)?",   // 10005
    MSG_SAVEONE,        "%s has changed!  Save changes (Y/N)?",      // 10006
    MSG_QUEUED,         "Queued: %s",                                // 10007
    MSG_CMPDONE,        "Compilation complete",                      // 10008
    MSG_PRINTING,       "Printing %s... Press Esc to abort",         // 10009
    MSG_SCANFILE,       "Scanning %s...",                            // 10010
//
//       10100: assign errors
//
    MSG_ASN_MISS,       "missing ':' in %s",                                        // 10100
    MSG_ASN_MISSK,      "Missing key assignment for '%s'",                          // 10101
    MSG_ASN_UNKKEY,     "'%s' is an unknown key",                                   // 10102
    MSG_ASN_INUSE,      "macro %s is in use",                                       // 10103
    MSG_ASN_MROOM,      "Not enough room for macro %s",                             // 10104
    MSG_ASN_NOTSWI,     "%s is not an editor switch",                               // 10105
    MSG_ASN_ILLSET,     "Illegal setting",                                          // 10106
    MSG_ASN_WINCHG,     "Cannot change screen parameters when windows present",     // 10107
    MSG_ASN_UNSUP,      "Not supported by video display",                           // 10108
    MSG_ASN_INVAL,      "%Fs: Invalid value '%s'",                                  // 10109
//
//  End of array
//
    0, ""
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\newline.c ===
/*  newline.c - move to the next line
 *
 *  Modifications:
 *	26-Nov-1991 mz	Strip off near/far
 */

#include "mep.h"



/* move to a new line unless in insert mode, then we split the current line
 */
flagType
emacsnewl (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    int tmpx;

    if (fInsert && !argcount) {
	tmpx = softcr ();
	CopyStream (NULL, pFileHead, XCUR (pInsCur), YCUR (pInsCur),
				     tmpx,	     YCUR (pInsCur)+1,
                     XCUR (pInsCur), YCUR (pInsCur));

    redraw( pFileHead, YCUR(pInsCur)-1, YCUR(pInsCur)+1 );

	docursor (tmpx, YCUR (pInsCur)+1);
	return TRUE;
    } else {
        return newline (argData, pArg, fMeta);
    }
}




flagType
newline (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    ) {

    docursor (fMeta ? 0 : softcr (), YCUR(pInsCur)+1);
    return TRUE;

    argData; pArg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\pbal.c ===
/*** pbal.c - balance parenthesis
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"


#define BALOPEN "([{"
#define BALCLOS ")]}"

static flagType fBalMeta;



flagType
pbal (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    flagType fFor;
    fl       flCur;

    fBalMeta = fMeta;

    switch (pArg->argType) {

    case NOARG: 		    /* balance a single character */
        balopen  = BALOPEN;
	balclose = BALCLOS;
	setAllScan (fFor = FALSE);
        break;


    /*  TEXTARG illegal             */


    case NULLARG:
        balopen  = BALCLOS;
	balclose = BALOPEN;
	setAllScan (fFor = TRUE);
        break;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }


    ballevel  = 0;
    flCur.col = XCUR(pInsCur);
    flCur.lin = YCUR(pInsCur);

    if (!fScan (flCur, FNADDR(fDoBal), fFor, FALSE)) {
	domessage ("No unbalanced characters found");
	return FALSE;
    }
    return TRUE;

    argData;
}





flagType
fDoBal (
    void
    ) {

    int k, x;

    if ((k=InSet(scanbuf[flScan.col], balclose)) != -1) {
	ballevel ++;
    } else if ((k=InSet(scanbuf[flScan.col], balopen)) != -1) {
	if (--ballevel < 0) {
	    HighLight (flScan.col, flScan.lin, flScan.col, flScan.lin);
	    if (!fInRange ((long)XWIN (pInsCur), (long)flScan.col, (long)(XWIN (pInsCur) + WINXSIZE(pWinCur))-1) ||
		!fInRange (YWIN (pInsCur), flScan.lin, (YWIN (pInsCur) + WINYSIZE(pWinCur))-1)) {
		/*  Balance point not on screen, put onto status line
		 */
		x = strlen (scanbuf);
                if (x >= XSIZE) {
		    if (x - flScan.col < XSIZE/2) {
			memmove ((char *) scanbuf, (char *) scanbuf + x - XSIZE, XSIZE);
			flScan.col -= x - XSIZE;
                    } else {
			memmove ((char *) scanbuf, (char *) scanbuf + flScan.col - XSIZE/2, XSIZE);
			flScan.col = XSIZE/2;
                    }
                }
		scanbuf[XSIZE] = 0;
		scanbuf[flScan.col] = 0;
                x = sout (0, YSIZE, scanbuf, infColor);
		x = vout (x, YSIZE, &balopen[k], 1, hgColor);
		soutb (x, YSIZE, &scanbuf[flScan.col+1], infColor);
            }
            if (!fBalMeta) {
                edit (balclose[k]);
            }
	    return TRUE;
        }
    }
    return FALSE;
}





int
InSet (
    char c,
    char *p
    )
{

    int i;

    for (i=0; *p; i++) {
        if (*p++ == c) {
            return i;
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\mep.c ===
/*** mep.c - top level for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*************************************************************************/
#define INCL_DOS

#include "mep.h"
#include "version.h"


#define DEBFLAG Z

/*
 * use double macro level to force rup to be turned into string representation
 */
#define VER(x,y,z)  VER2(x,y,z)
#define VER2(x,y,z)  "Version "###x##"."###y"."###z" "szVerName

char Name[]      = "Microsoft (R) Editor";
char Version[]   = VER(rmj,rmm,rup);
char CopyRight[] = "Copyright (C) Microsoft Corp 1987-1990.  All rights reserved";


/*** main - program entry
*
* Input:
*  C standard command line parameters.  Recognizes:
*
*       /e string   - Execute string of commands on startup
*       /t          - Following file is "temporary", not kept in file history
*       /D          - Don't read tools.ini
*       /r          - Global no-edit mode (can't edit files)
*       /m markname - Start up at given mark
*       /pwb        - Start as PWB
*
*  When the editor is built with DEBUG defined, the following are also
*  recognized:
*
*       /d debflags - Specifies which debugging to turn on
*       /f filename - Specifies file for debug output
*
*  The following are present in the CW version of the editor only.  They are
*  for testing only and should NOT be documented:
*
*       /vt tapename- Set tape name
*       /vr         - Record messages to file "default.key"
*       /vp         - Play back messages from file "default.key"
*       /vd digit   - Set playback delay from 0 to 9
*
*
* Output:
*  Returns nothing. Exits via CleanExit()
*
* Exceptions:
*  Various and sundry, based on program operation
*
*************************************************************************/
void __cdecl
main (
    int c,
    char **v
    ) {

        char            *pExecute               = NULL;                 /* string to execute on start   */
        char            *szMark                 = NULL;                 /* mark to go to on start               */
        char            *szName                 = v[0];                 /* ptr to invokation name               */
        flagType        InLoop                  = TRUE;

        ConvertAppToOem( c, v );
        SHIFT(c,v);
#if DEBUG
    debug =  0;
    //debfh = stdout;
#endif

        while (c && fSwitChr (**v) && InLoop) {


        switch ((*v)[1]) {
#if DEBUG
        case 'f':
        case 'F':
            SHIFT(c,v);
            if ((debfh = MepFOpen(*v, ACCESSMODE_WRITE, SHAREMODE_RW, TRUE)) == NULL) {
                printf("Can't open %s for debug output - using stdout\n", *v);
                //debfh = stdout;
            }
            // setbuf(debfh, NULL);
            break;
#endif

        case 'e':
        case 'E':
            //
            //  /e command to execute
            //
            if ( c > 1 ) {
                            SHIFT (c, v);
                pExecute = *v;
            }
            break;

        case 't':
        case 'T':
            //
            //  /t next file is temporary .. don't keep in file history
                        //
                        InLoop = FALSE;
            break;


#if DEBUG
        case 'd':
            //
            // /d### debug level
            //
            SHIFT(c,v);
            debug = ntoi (*v, 16);
            break;
#else
        case 'd':
#endif
        case 'D':
            //
            //  /D don't read tools.ini
            //
            fDefaults = TRUE;
            break;

        case 'r':
        case 'R':
            //
            // /r Enter with noedit
            //
            fGlobalRO = TRUE;
            break;

        case 'm':
        case 'M':
            //
            //  /m markname - start at markname
            //
            SHIFT(c,v);
            szMark = *v;

        default:
                        printf ("%s %s\n", Name, Version);
                        printf ("%s\n", CopyRight);
                        printf("Usage: %s [/D] [/e cmd-string] [/m mark] [/r] [[/t] filename]*\n", szName);
                        fSaveScreen = FALSE;
            exit(1);
            break;
        }
                if (InLoop) {
                        SHIFT(c,v);
                }
    }

    InitNames (szName);

    cArgs = c;
    pArgs = v;
        // assert (_heapchk() == _HEAPOK);

    /*
     * At this point, command line arguments have been processed. Continue with
     * initialization.
     */
    if (!init ()) {
        CleanExit (1, CE_VM);
    }

    /*
     * based on the re-entry state, take appropriate initial action:
     *  - PWB_ENTRY:    process rest of command line
     *  - PWB_COMPILE:  read compile log, and go to first error in log
     *  - PWB_SHELL:    do nothing
     */

#if 0
    //
    // BUGBUG what is this supposed to do?
    // 
    if (szMark) {
        GoToMark;
    }
#endif
    domessage (CopyRight);

    Display ();

    /*
     * execute autostart macro if present
     */
    if (NameToFunc ("autostart")) {
        fExecute ("autostart");
        Display ();
    }

    /*
     * execute command line /e parameter if present
     */
    if (pExecute) {
        fExecute (pExecute);
    }

    TopLoop ();
    CleanExit (0, CE_VM | CE_SIGNALS | CE_STATE);
}





/*** TopLoop - read a command and execute it until termination
*
*  We read commands from the editor input and send them to the proper
*  recipients. We continue to do this until a termination flag is seen.
*
* Input:
*  None
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
TopLoop (
    void
    ) {
    PCMD pFuncPrev = &cmdUnassigned;

    while (!fBreak) {
        PCMD pFunc = zloop (ZL_CMD | ZL_BRK);

        if (pFunc != NULL) {
            /*  if prev wasn't graphic or this wasn't graphic then
             *      log a boundary
             */
            if (pFuncPrev->func != graphic || pFunc->func != graphic) {
                LogBoundary ();
            }
            fRetVal = SendCmd (pFunc);
            if (pFunc->func != cancel) {
                if (fCtrlc) {
                    DoCancel ();
                }
            }
            pFuncPrev = pFunc;
        }
    }
    fBreak = FALSE;
}





/*** zloop - read next command, potentially updating screen
*
*  zloop updates screen until a command is read that is not a macro
*  invocation. If a macro invocation is seen then just execute it and
*  continue. The reason for this is that the macro invocation will set up a
*  new input context that we'll retrieve in the next loop.
*
*  We call RecordCmd for each command, in case we have recording on.  If
*  the user has done <meta><record>, we record macro names, not their
*  values.  This is because a macro with flow control, especially a loop,
*  will behave badly (possibly hang) because none of the editing commands
*  return values.
*
* Input:
*  flags      - ZL_CMD      command key, should be an event
*             - ZL_BRK      take fBreak into account
*
* Output:
*  Returns a pointer to command structure that is next to be executed
*
*************************************************************************/
PCMD
zloop (
    flagType flags
    ) {

    REGISTER PCMD pFunc;
    EVTargs e;

    while (!fBreak || !TESTFLAG(flags, ZL_BRK)) {

        /*
         * Between every command, check heap and pfile list consistancy
         */
                // assert (_heapchk() == _HEAPOK);
                // assert (_pfilechk());

        /*  if macro in progress then
         */
        if (mtest ()) {
            pFunc = mGetCmd ();
        } else {
            DoDisplay ();

            do {
                pFunc = ReadCmd ();
                e.arg.key = keyCmd.KeyInfo;
                if (!TESTFLAG(flags, ZL_CMD)) {
                    break;
                }
            } while (DeclareEvent (EVT_KEY, (EVTargs *)&e));
        }

        if (pFunc != NULL) {
            RecordCmd (pFunc);
            if (pFunc->func == macro) {
                fRetVal = SendCmd (pFunc);
            } else {
                break;
            }
        }
    }
    return pFunc;
}





/*** Idle & IdleThread - Code executed at idle time
*
*  Idle loop. Structured so that only ONE idle-item does something each time
*  though the loop. Ensures minimum exit delay. When nothing has
*  happened we sleep a bit each time, to make sure we're not hogging the CPU.
*
*  Also causes the screen to be updated, if need be.
*
*  Idle is structure so that routines which it calls return either:
*       TRUE - idle processing done, perhaps more to be done
*       FALSE - no idle processing done, and no more anticipated.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
IdleThread (
    void
    ) {
    while (TRUE) {

        WaitForSingleObject( semIdle, INFINITE);
        Idle();
        SetEvent( semIdle );
        Sleep(100L);
    }
}



flagType
Idle (
    void
    ) {

    if (TESTFLAG (fDisplay, (RTEXT | RCURSOR | RSTATUS))) {
        DoDisplay ();
    }

    if (!DeclareEvent (EVT_IDLE, NULL)) {
        if (!fIdleUndo (FALSE)) {
                return FALSE;
        }
    }

    /*
     * got here, means someone processed idle, and may have more to do
     */
    return TRUE;
}



/*** IntError - Internal error Processor.
*
*  Allow user to abort, or attempt to continue.
*
* Input:
*  p            = pointer to error string
*
* Output:
*  Returns only if user says to.
*
*************************************************************************/
void
IntError (
    char *p
    ) {
    static char pszMsg [] = "MEP internal error - %s, continue? ";

        if ( OriginalScreen ) {
                consoleSetCurrentScreen( OriginalScreen );
        }
    printf ("\n");
    if (TESTFLAG (fInit, INIT_VIDEO)) {
        if (!confirm (pszMsg, p)) {
#if DEBUG
            fflush (debfh);
#endif
            CleanExit (1, CE_STATE);
        } else {
        ;
        }
    } else {
        printf (pszMsg, p);
        CleanExit (1, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\pick.c ===
/*** pick.c - pick a piece of text and put it into the put buffer
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"


#define DEBFLAG PICK



flagType
zpick (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    ) {

    buffer pbuf;

    /*	LINEARG illegal 	    */
    /*	BOXARG illegal		    */

    switch (pArg->argType) {

    case NOARG:
	pick (0, pArg->arg.noarg.y, 0, pArg->arg.noarg.y, LINEARG);
        return TRUE;

    case TEXTARG:
        if (pFilePick != pFileHead) {
            DelFile (pFilePick, TRUE);
        }
	strcpy ((char *) pbuf, pArg->arg.textarg.pText);
	PutLine ((LINE)0, pbuf, pFilePick);
	kindpick = BOXARG;
        return TRUE;

    /*  NULLARG is converted into TEXTARG   */

    case LINEARG:
	pick (0, pArg->arg.linearg.yStart,
	      0, pArg->arg.linearg.yEnd, LINEARG);
        return TRUE;

    case BOXARG:
	pick (pArg->arg.boxarg.xLeft,  pArg->arg.boxarg.yTop,
	      pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom, BOXARG);
        return TRUE;

    case STREAMARG:
	pick (pArg->arg.streamarg.xStart,  pArg->arg.streamarg.yStart,
	      pArg->arg.streamarg.xEnd,    pArg->arg.streamarg.yEnd, STREAMARG);
	return TRUE;
    }

    return FALSE;
    argData; fMeta;
}




void
pick (
    COL  xstart,
    LINE ystart,
    COL  xend,
    LINE yend,
    int  kind
    )
{

    if (pFilePick != pFileHead) {
        DelFile (pFilePick, TRUE);
    }
    kindpick = kind;

    switch (kind) {

    case LINEARG:
	CopyLine (pFileHead, pFilePick, ystart, yend, (LINE)0);
        break;

    case BOXARG:
	CopyBox (pFileHead, pFilePick, xstart, ystart, xend, yend, (COL)0, (LINE)0);
        break;

    case STREAMARG:
	CopyStream (pFileHead, pFilePick, xstart, ystart, xend, yend, (COL)0, (LINE)0);
	break;
    }
}




flagType
put (
    CMDDATA argData,
    ARG  *pArg,
    flagType fMeta
    )
{

    flagType fTmp = FALSE;
    int      i;
    buffer   putbuf;
    pathbuf  filebuf;
    FILEHANDLE fh;
    PFILE    pFileTmp;
    char     *pBuf;


    switch (pArg->argType) {

	case BOXARG:
	case LINEARG:
	case STREAMARG:
	    delarg (pArg);
	    break;

	case TEXTARG:
	    strcpy ((char *) buf, pArg->arg.textarg.pText);
            DelFile (pFilePick, TRUE);
            if (pArg->arg.textarg.cArg > 1) {
                pBuf = whiteskip (buf);
                if (*pBuf == '!') {
		    findpath ("$TMP:z.$", filebuf, TRUE);
		    fTmp = TRUE;
		    sprintf (putbuf, "%s >%s", pBuf+1, filebuf);
		    zspawnp (putbuf, TRUE);
		    pBuf = filebuf;
                }
                if (*pBuf != '<') {
                    CanonFilename (pBuf, putbuf);
                } else {
                    strcpy (putbuf, pBuf);
                }
                //
                // If we find the file in the existing file history, read it in, if not already
                // in, and just to a copy operation on the desired text.
                //
                if ((pFileTmp = FileNameToHandle (putbuf, pBuf)) != NULL) {
                    if (!TESTFLAG (FLAGS (pFileTmp), REAL)) {
			if (!FileRead(pFileTmp->pName,pFileTmp, FALSE)) {
			    printerror ("Cannot read %s", pFileTmp->pName);
			    return FALSE;
                        }
                    }
		    CopyLine (pFileTmp, pFilePick, (LINE)0, pFileTmp->cLines-1, (LINE)0);
                } else {
                    if ((fh = MepFOpen(putbuf, ACCESSMODE_READ, SHAREMODE_RW, FALSE)) == NULL) {
			printerror ("%s does not exist", pBuf);
			return FALSE;
                    }
		    readlines (pFilePick, fh);
                    MepFClose (fh);
                }
                if (fTmp) {
                    _unlink (filebuf);
                }
                kindpick = LINEARG;
            } else {
                PutLine ((LINE)0, buf, pFilePick);
                kindpick = BOXARG;
            }
	    break;
    }

    switch (kindpick) {

	case LINEARG:
	    CopyLine (pFilePick, pFileHead, (LINE)0, pFilePick->cLines-1, YCUR (pInsCur));
            break;

	case BOXARG:
	    i = LineLength ((LINE)0, pFilePick);
	    CopyBox (pFilePick, pFileHead, 0, (LINE)0, i-1, pFilePick->cLines-1, XCUR (pInsCur), YCUR (pInsCur));
            break;

	case STREAMARG:
	    i = LineLength (pFilePick->cLines-1, pFilePick);
	    CopyStream (pFilePick, pFileHead, 0, (LINE)0, i, pFilePick->cLines-1, XCUR (pInsCur), YCUR (pInsCur));
	    break;
    }

    return TRUE;

    argData; fMeta;
}




/*** CopyLine - copy lines between files
*
*  If the source file is NULL, then we insert blank lines.
*
* Input:
*  pFileSrc	= source file handle
*  pFileDst	= destination file handle
*  yStart	= first line to be copied
*  yEnd 	= last line to be copied
*  yDst 	= location of destination of copy
*
*************************************************************************/
void
CopyLine (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    LINE    yStart,
    LINE    yEnd,
    LINE    yDst
    )
{
    linebuf buf;
    struct lineAttr * rgla = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));

    if (pFileSrc != pFileDst) {
        if (yStart <= yEnd) {
            InsLine (TRUE, yDst, yEnd - yStart + 1, pFileDst);
            if (pFileSrc != NULL) {
                MarkCopyLine (pFileSrc, pFileDst, yStart, yEnd, yDst);
                while (yStart <= yEnd) {
                    gettextline (TRUE, yStart++, buf, pFileSrc, ' ');
                    puttextline (TRUE, TRUE, yDst++, buf, pFileDst);
                    if (getcolorline (TRUE, yStart-1, rgla, pFileSrc)) {
                        putcolorline (TRUE, yDst-1, rgla, pFileDst);
                    }
                }
            }
        }
    }
    FREE (rgla);
}




/*** CopyBox - copy a box from one place to another
*
*  If the source file is NULL, then we insert blank space. We copy the box
*  defined by the LOGICAL box xLeft-xRight and yTop-yBottom inclusive.
*
* Input:
*  pFileSrc	= source file handle
*  pFileDst	= destination file handle
*  xLeft	= column location of beginning of copy
*  yTop 	= line location of beginning of copy
*  xRight	= column location of end of copy
*  yBottom	= line location of end of copy
*  xDst 	= column location of destination of copy
*  yDst 	= line location of destination of copy
*
*************************************************************************/
void
CopyBox (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xLeft,
    LINE    yTop,
    COL     xRight,
    LINE    yBottom,
    COL     xDst,
    LINE    yDst
    )
{
    int     cbDst;                          /* count of bytes in destination*/
    int     cbMove;                         /* count of bytes to move around*/
    linebuf dstbuf;                         /* buffer for result            */
    char    *pDst;                          /* physical pointer to dest     */
    char    *pSrcLeft;                      /* physical pointer to src left */
    char    *pSrcRight;                     /* physical pointer to src right+1*/
    linebuf srcbuf;                         /* buffer for source line       */
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;

    /*
     *  Do not allow overlapped copies.
     */
    if ((pFileSrc == pFileDst)
        && ((      fInRange ((LINE)xLeft, (LINE)xDst, (LINE)xRight)
                && fInRange (yTop, yDst, yBottom))
            || (   fInRange ((LINE)xLeft, (LINE)(xDst + xRight - xLeft), (LINE)xRight)
                && fInRange (yTop, yDst + yBottom - yTop, yBottom))
            )
        ) {
        return;
    }

    /*
     * If valid left and right coordinates for box, then for each line...
     */
    if (xLeft <= xRight) {
        /*
         *  Let the Marker update any affected marks.
         */
        MarkCopyBox (pFileSrc, pFileDst, xLeft, yTop, xRight, yBottom, xDst, yDst);
        while (yTop <= yBottom) {

            if (!pFileSrc) {
                //
                //  File is not a file, just insert spaces.
                //
                if (!fInsSpace (xDst, yDst, xRight - xLeft + 1, pFileDst, dstbuf)) {
                    LengthCheck (yDst, 0, NULL);
                }
                pDst  = pLog (dstbuf, xDst, TRUE);
            } else {
                //
                //  When source IS a file, we:
                //   - get both source and destination lines
                //   - ensure that the source line is detabbed (only way to ensure proper
                //     alignment in the copy.
                //   - get phsical pointers to right and left of source.
                //   - get phsical pointer to destination
                //   - get length of physical move and current destination
                //   - physical length check the potential destination result
                //   - open up a hole in the destination line for the source
                //   - copy the source range into the destination
                //   - perform logical length check.
                //
                fInsSpace (xRight+1, yTop, 0, pFileSrc, fRealTabs ? dstbuf : srcbuf);
                if (fRealTabs) {
                    Untab (fileTab, dstbuf, strlen(dstbuf), srcbuf, ' ');
                }
                fInsSpace (xDst,   yDst, 0, pFileDst, dstbuf);

                pSrcLeft  = pLog (srcbuf, xLeft, TRUE);
                pSrcRight = pLog (srcbuf, xRight, TRUE) + 1;

                pDst      = pLog (dstbuf, xDst, TRUE);

                cbMove  = (int)(pSrcRight - pSrcLeft);
                cbDst   = strlen (dstbuf);

                if (cbDst + cbMove > sizeof(linebuf)) {
                    LengthCheck (yDst, 0, NULL);
                } else {
                    memmove (pDst + cbMove, pDst, strlen(dstbuf) - (int)(pDst - dstbuf) + 1);

                    memmove (pDst, pSrcLeft, cbMove);

                    if (cbLog(dstbuf) > sizeof(linebuf)) {
                        LengthCheck (yDst, 0, NULL);
                        *pLog (dstbuf, sizeof(linebuf) - 1, TRUE) = 0;
                    }
                }
            }
            if (fColor = GetColor (yDst, rgla, pFileDst)) {
                if (pFileSrc) {
                    CopyColor (pFileSrc, pFileDst, yTop, xLeft, cbMove, yDst, xDst);
                } else {
                    ShiftColor (rgla, (int)(pDst - dstbuf), xRight - xLeft + 1);
                    ColorToLog (rgla, dstbuf);
                }
            }
            PutLine (yDst, dstbuf, pFileDst);
            if (fColor) {
                PutColor (yDst, rgla, pFileDst);
            }
            yDst++;
            yTop++;
        }
    }
}





/*** CopyStream - copy a stream of text (including end-of-lines)
*
*  If source file is NULL, then we insert blank space. We copy starting at
*  xStart/yStart and copy through to the character before xEnd/yEnd. This
*  means that to copy line Y INCLUDING the line separator, we specify
*  (xStart,yStart) = (0,Y) and (xEnd,yEnd) = (0, Y+1)
*
* Input:
*  pFileSrc	= source file handle
*  pFileDst	= destination file handle
*  xStart	= column location of beginning of copy
*  yStart	= line location of beginning of copy
*  xEnd 	= column location of end of copy
*  yEnd 	= line location of end of copy
*  xDst 	= column location of destination of copy
*  yDst 	= line location of destination of copy
*
*************************************************************************/
void
CopyStream (
    PFILE   pFileSrc,
    PFILE   pFileDst,
    COL     xStart,
    LINE    yStart,
    COL     xEnd,
    LINE    yEnd,
    COL     xDst,
    LINE    yDst
    )
{
    linebuf dstbuf;                         /* buffer for result            */
    char    *pDst;
    linebuf srcbuf;                         /* buffer for source line       */
    LINE    yDstLast;

    /*
     * validate copy...must be different files, and coordinates must make sense.
     */
    if (!(pFileSrc != pFileDst &&
        (yStart < yEnd || (yStart == yEnd && xStart < xEnd)))) {
        return;
    }

    /*
     *  Special case a single-line stream as a box copy
     */
    if (yStart == yEnd) {
        CopyBox (pFileSrc, pFileDst, xStart, yStart, xEnd-1, yEnd, xDst, yDst);
        return;
    }

    /*
     * Valid stream copy. First, copy the intermediate lines.
     */
    CopyLine (pFileSrc, pFileDst, yStart+1, yEnd, yDst+1);

    /*
     * Form last line of destination stream. Copy last part of dest line onto
     * last part of last source line. Make sure that each copy of the
     * source/dest is correct length
     */
    fInsSpace (xDst, yDst, 0, pFileDst, dstbuf);    /*  dddddeeeeee   */
    if (pFileSrc != NULL) {
        fInsSpace (xEnd, yEnd, 0, pFileSrc, srcbuf);/*  AAAABBBBB     */
    } else {
	memset ((char *) srcbuf, ' ', xEnd);
    }
    pDst = pLog (dstbuf,xDst, TRUE);
    yDstLast = yDst + yEnd - yStart;
    LengthCheck (yDstLast, xEnd, pDst);
    strcpy ( pLog(srcbuf,xEnd,TRUE), pDst);         /*  AAAAeeeeee    */
    PutLine (yDstLast, srcbuf, pFileDst);

    /*
     * Form first line of destination stream. Copy last part of first source
     * line onto last part of dest line
     */
    if (pFileSrc != NULL) {
        fInsSpace (xStart, yStart, 0, pFileSrc, srcbuf);/*  CCCCCDDDDD*/
        LengthCheck (yDst, xDst, srcbuf + xStart);
        strcpy (pDst, pLog(srcbuf,xStart,TRUE));        /*  dddddDDDDD*/
    } else {
        *pDst = 0;
    }
    PutLine (yDst, dstbuf, pFileDst);

    /*
     * To update marks, we first adjust any marks at yDst, then add new
     * marks from the src.
     */
    MarkCopyBox (pFileDst, pFileDst, xDst, yDst, sizeof(linebuf), yDst, xEnd-1, yDstLast);
    MarkCopyBox (pFileSrc, pFileDst, 0, yEnd, xEnd, yEnd, 0, yDstLast);
    MarkCopyBox (pFileSrc, pFileDst, xStart, yStart, sizeof(linebuf), yStart, xDst, yDst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\mouse.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    mouse.c

Abstract:

    Mouse support for MEP

Author:

    Ramon Juan San Andres (ramonsa) 07-Nov-1991


Revision History:


--*/

#include <string.h>
#include "mep.h"
#include "cmds.h"
#include "mouse.h"



void
DoMouseInWindow(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    );

flagType
SetCurrentWindow(
    int iWin
    );

void
DoMouse(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Handles Mouse events. Invoked by the MEP console interface

Arguments:

    Row         -   Supplies row position of the mouse
    Col         -   Supplies column position of the mouse
    MouseFlags  -   Supplies miscelaneous flags

Return Value:

    none

--*/


{
            int     i;
            KBDKEY  Key;
    static  BOOL    Clicked  = FALSE;
    static  BOOL    Dragging = FALSE;
    static  BOOL    InMouse  = FALSE;
    static  ROW     LastRow;
    static  COLUMN  LastCol;
    struct  windowType *winTmp;

    if ( fUseMouse ) {
        if ( !InMouse ) {
            InMouse = TRUE;
            if ( MouseFlags & MOUSE_CLICK_LEFT ) {
                //
                //  If dragging, start selection
                //
                if ( !fInSelection && Clicked && !Dragging && ( (LastRow != Row) || (LastCol != Col) ) ) {


    //#ifdef DEBUG
    //              char dbgb[256];
    //              sprintf( dbgb, "  MOUSE: Selecting at Row %d, Col %d\n", Row, Col );
    //              OutputDebugString( dbgb );
    //#endif
                    //
                    //  Start selection
                    //
                    Key.Unicode     = 'A';
                    Key.Scancode    = 'A';
                    Key.Flags       = CONS_RIGHT_ALT_PRESSED;

                    consolePutMouse( Row, Col, MouseFlags );
                    consolePutKey( &Key );
                    consolePutMouse( LastRow, LastCol, MouseFlags );

                    Dragging = TRUE;
                    InMouse  = FALSE;

                    return;

                } else {

                    Clicked  = TRUE;
                    LastRow  = Row;
                    LastCol  = Col;
                }

            } else {

                Clicked  = FALSE;
                Dragging = FALSE;
            }

            if ( cWin == 1 ) {

                DoMouseInWindow( Row, Col, MouseFlags );

            } else {

                //
                //  Determine what window we're in
                //
                for ( i=0; i<cWin; i++ ) {

                    winTmp = &(WinList[i]);

                    if ( ( (LINE)(Row-1) >= WINYPOS( winTmp ) )                         &&
                         ( (LINE)(Row-1) <= WINYPOS( winTmp ) + WINYSIZE( winTmp ) )    &&
                         ( (COL)(Col-1)  >= WINXPOS( winTmp ) )                         &&
                         ( (COL)(Col-1)  <  WINXPOS( winTmp ) + WINXSIZE( winTmp ) ) ) {

                        //
                        //  Found the window that we're in. Make that window
                        //  the current (i.e. "active" window ).
                        //
                        iCurWin = i;

                        if ( (winTmp == pWinCur) || SetCurrentWindow (iCurWin) ) {

                            DoMouseInWindow( Row - WINYPOS( winTmp ),
                                             Col - WINXPOS( winTmp ),
                                             MouseFlags );
                        }

                        break;
                    }
                }
            }

            InMouse = FALSE;
        }
    }
}


flagType
SetCurrentWindow(
    int iWin
    )
{
    flagType f;

    WaitForSingleObject(semIdle, INFINITE);

    f = SetWinCur( iWin );

    SetEvent( semIdle );

    return f;
}


void
DoMouseInWindow(
    ROW     Row,
    COLUMN  Col,
    DWORD   MouseFlags
    )
/*++

Routine Description:

    Handles Mouse events. Called by DoMouse after setting the active
    window.

Arguments:

    Row         -   Supplies row position of the mouse
    Col         -   Supplies column position of the mouse
    MouseFlags  -   Supplies miscelaneous flags

Return Value:

    none

--*/

{

    KBDKEY          Key;
    static BOOL     fFirstClick = FALSE;

    WaitForSingleObject(semIdle, INFINITE);

    //
    //  If the mouse is clicked, move the cursor to the mouse position.
    //
    if ( MouseFlags & MOUSE_CLICK_LEFT ) {

        //
        //  Toggle boxmode if necessary
        //
        if ( fInSelection && (MouseFlags & MOUSE_CLICK_RIGHT) ) {
            SendCmd( CMD_boxstream );
        }

        if ( (LINE)(Row-1) == WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

            //
            //    scroll the window
            //
            Key.Unicode     = '\0';
            Key.Scancode    = VK_DOWN;
            Key.Flags       = 0;

            consolePutMouse( Row + WINYPOS( pWinCur )-1,
                             Col + WINXPOS( pWinCur ),
                             MouseFlags );
            consolePutKey( &Key );

        } else  if ( (LINE)(Row-1) <  WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

            //
            //  Move the cursor to the new location
            //
            docursor( XWIN(pInsCur) + Col - 1, YWIN(pInsCur) + Row - 1  );

            //
            //  If we are making a selection, hilite it
            //
            if ( fInSelection ) {
                UpdateHighLight ( XCUR(pInsCur), YCUR(pInsCur), TRUE);
            }
        }

    } else if ( MouseFlags & MOUSE_CLICK_RIGHT ) {

        if ( !fInSelection ) {

            if ( !fFirstClick ) {

                fFirstClick = TRUE;

                if ( (LINE)(Row-1) <  WINYPOS( pWinCur ) + WINYSIZE( pWinCur ) ) {

                    //
                    //  Position the cursor and press the F1 key
                    //
                    docursor( XWIN(pInsCur) + Col - 1, YWIN(pInsCur) + Row - 1  );

                    Key.Unicode     = 0;
                    Key.Scancode    = VK_F1;
                    Key.Flags       = 0;
                    consolePutKey( &Key );
                }
            }
        }

    } else {

        fFirstClick = FALSE;
    }

    SetEvent( semIdle );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\record.c ===
/***  RECORD.C - Handle function-by-function recording
*
*       Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "cmds.h"


/* Use the pFile MODE1 flag for <record> quote mode */
#define INQUOTES    MODE1


static PFILE    pFileRecord;
static char     szRecordName[]  = "<record>";
static PCMD     pcmdRecord      = NULL;



/*** record - <record> edit command
*
* Purpose:
*
*   Toggles recording state.  When turning on, the file <record> is erased
*   (unless we are appending), the string "macroname:= " is inserted into
*   the file and quote mode is turned off.  When turning off, quote marks
*   are appended to the macro (if needed) and the macro is assigned.
*
*	       <record> - Starts/stops recording using the current macro
*			  name.
*		  <arg> - Start/stops recording using the default macro
*			  name.
*	  <arg> textarg - Starts recording a macro named 'textarg'.
*		 <meta> - Like <record>, but commands are not executed.
*	    <arg> <arg> - Like <record>, but append to current recording.
*   <arg> <arg> textarg - Start appending to macro named 'textarg'.
*
*   If recording is on, only <record> will work.
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
record (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    LINE        line;
    char        *pch;
    char        *szDefaultName  = "recordvalue";
    char    *lpch	    = NULL;
    flagType    fAppend         = FALSE;
    flagType    fNameGiven      = FALSE;

    // Check for the <record> file.  If we haven't done a <record>
    // yet, see if the user has created it.  If not, create it.
    // If this is the first time through, make sure it gets set to
    // READONLY.
    //
    if (pFileRecord == NULL) {
        if ((pFileRecord = FileNameToHandle(szRecordName,szRecordName)) == NULL) {
            pFileRecord = AddFile (szRecordName);
            FileRead (szRecordName, pFileRecord, FALSE);
        }
        SETFLAG (FLAGS(pFileRecord), REAL | FAKE | DOSFILE);
    }

    if (fMacroRecord) {
        // We need to turn off. Let's check for an open quote at the end
        // of the recording and close it.  Then we can DoAssign the whole
        // thing and we're done.
        //
        if (pArg->argType == NOARG) {
            if (TESTFLAG(FLAGS(pFileRecord), INQUOTES)) {
                GetLine (pFileRecord->cLines-1, buf, pFileRecord);
                strcat (buf, "\"");
                PutLine (pFileRecord->cLines-1, buf, pFileRecord);
                RSETFLAG (FLAGS(pFileRecord), INQUOTES);
            }
            fMacroRecord = FALSE;

            if (fMetaRecord) {
                domessage (NULL);
                fMetaRecord = FALSE;
            }

            // This may look like we're supporting multiple macro
            // definitions in the record file, but it is really a
            // cheap way to get GetTagLine to free up the heap space
            // it uses.
            //
            pch = NULL;
            line = 0;
            while ((pch = GetTagLine (&line, pch, pFileRecord))) {
                DoAssign (pch);
            }
        } else {
            ;
        }
    } else {
        // We are turning recording on.  First, decide on the name
        // of the macro to record to, and whether we are appending
        // or starting over.
        //
        switch (pArg->argType) {

            case NOARG:
		lpch = pcmdRecord ? pcmdRecord->name : (char *)szDefaultName;
                break;

            case TEXTARG:
                lpch = pArg->arg.textarg.pText;
                fNameGiven = TRUE;

            case NULLARG:
                fAppend = (flagType)(pArg->arg.textarg.cArg > 1);
                break;
        }

        assert (lpch);
        strcpy ((char far*)buf, lpch);

        while ((pcmdRecord = NameToFunc (buf)) == NULL) {
            if (!SetMacro (buf, RGCHEMPTY)) {
                return FALSE;
            }
        }

        // If we are not appending, we delete the file, insert a
        // new name and possibly a current value.
        //
        if (!fAppend || fNameGiven) {
            DelFile (pFileRecord, FALSE);
            strcat (buf, ":=");
            PutLine (0L, buf, pFileRecord);
            if (fAppend) {
                AppendMacroToRecord (pcmdRecord);
            }
        }


        RSETFLAG (FLAGS(pFileRecord), INQUOTES);
        fMacroRecord = TRUE;

        if (fMetaRecord = fMeta) {
            strcpy (buf, "<record>");
            FuncToKey (CMD_record, buf);
            domessage ("No-Execute Record Mode - Press %s to resume normal editing", buf);
        }
    }

    SETFLAG (fDisplay, RSTATUS);
    return fMacroRecord;

    argData;
}




/*** tell - Editor command - Tells us the names and values of things
*
* Purpose:
*
*   This allows the user to easily disover the name of a key, the name
*   of the function attached to a given key or the value of a macro.
*
*		<tell>	Prompts for a keystroke, then displays the key's
*			name and the function assigned to it in this
*			format: "function:KeyName"
*	   <arg><tell>	Like <tell>, but if the key has a macro attached,
*			displays "MacroName:= Macro Value"
* <arg> textarg <tell>	Like <arg><tell>, but gets the macro name from
*			the textarg instead of a keystroke.
*		<meta>	All of the above, except the output is inserted into
*			the current file.
*
*   Insertion takes place at the cursor.  The insertion will be
*   atomic; the user will see only the final product.
*
* Input:
*
*   The usual.
*
* Output:
*
*   Returns FALSE if the function is <unassigned>, TRUE otherwise.
*
*************************************************************************/
flagType
ztell (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer   buf;
    buffer   buf2;
    PCMD     pCmd;
    char     *pch;
    flagType fWrap      = fWordWrap;
    flagType fInQuotes  = FALSE;
    flagType fMacro     = FALSE;

    switch (pArg->argType) {

        case NOARG:
        case NULLARG:
            dispmsg (MSG_TELLPROMPT);
            pCmd = ReadCmdAndKey (buf2);
            if ((pArg->argType == NULLARG) &&
                (PVOID)pCmd->func == (PVOID)macro) {
                goto domacro;
            }
notmacro:
            sprintf (buf, "%Fs:%s",pCmd->name, buf2);
            break;

        case TEXTARG:
            strcpy (buf2, pArg->arg.textarg.pText);
            if (NULL == (pCmd = NameToFunc (buf2))) {
                disperr (MSGERR_ZTELL, buf2);
                return FALSE;
            }

            if ((PVOID)pCmd->func == (PVOID)macro) {
domacro:
                fMacro = TRUE;
                sprintf (buf, "%Fs:=", pCmd->name);
            } else {
                goto notmacro;
            }
    }

    // Now buf is filled with the string to display.
    // if fMacro is TRUE, we must also append the
    // value of pCmd->arg
    //
    if (fMeta) {
        fWordWrap = FALSE;
        pch = buf - 1;
doitagain:
        while (*++pch) {
            if (*pch == ' ' && XCUR(pInsCur) >= xMargin) {
                edit (' ');
                edit (' ');
                edit ('\\');
                docursor (softcr(), YCUR(pInsCur) + 1);
            } else {
                edit (*pch);
            }
        }
        if (fMacro) {
            pch = (char *)pCmd->arg - 1;
            fMacro = FALSE;
            goto doitagain;
        }
        fWordWrap = fWrap;
    } else {
        if (fMacro ) {
            strncat (buf, (char *)pCmd->arg, XSIZE);
        }
        domessage (buf);
    }
    return (flagType)((PVOID)pCmd->func != (PVOID)unassigned);

    argData;
}



/*** RecordCmd - Append a command name to the <record> file.
*
* Purpose:
*
*   Whenever a command is about to be performed, this function should
*   be called.
*
* Input:
*   pCmd -> The command to record
*
* Output: None
*
* Notes:
*
*   The basic operation is to append pCmd->name to the file.  This
*   means checking for:
*
*	o Line overflow.  If appending to the line would overflow the
*	  maximum line length (BUFLEN - 3), we must append a " \" and
*	  write to the next line.
*
*	o Graphic characters.  If the function is <graphic>, then we add
*	  the ASCII character, not "graphic".  If we are outside quotes, we
*	  must add quotes first and flag quote mode.  To flag quote mode
*	  we use the special 'MODE1' flag in pFile.
*
*	o <unassigned>.  This is considered user clumsiness and is not
*	  recorded.
*
*	o All other cases.  If the previous function was <graphic> and the
*	  current function is not, we must close quotes first.
*
*************************************************************************/
void
RecordCmd (
    PCMD pCmd
    )
{
    buffer szCmdName;
    buffer buf;
    REGISTER char * pchEndLine;
    REGISTER char * pchNew;
    char c;
    LINE line;
    int entab;

    if (!fMacroRecord) {   /* If we're not on, do nothing */
        return;
    }

    assert (pFileRecord);

    if ((PVOID)pCmd->func == (PVOID)unassigned ||
        (PVOID)pCmd->func == (PVOID)record ||
        (!fMetaRecord && (PVOID)pCmd->func == (PVOID)macro)) {
        return;
    }

    // First, we get the current (i.e. last) line to play with.
    // Let's also set a pointer to the end of it so we don't have
    // to keep strcat'ing and strlen'ing it.
    //
    GetLine ((line = pFileRecord->cLines-1), buf, pFileRecord);
    pchEndLine = strend (buf);
    pchNew = szCmdName;


    // Now we generate the new text.  Since we may be moving into and
    // out of quotes, we have four possible transitions from the
    // previous entry:
    //
    //      last cmd type   this cmd type   resulting pattern
    //
    //      graphic         graphic         >c<
    //      non-graphic     graphic         > "c<
    //      graphic         non-graphic     >" cmdname<
    //      non-graphic     non-graphic     > cmdname<
    //
    if ((PVOID)pCmd->func == (PVOID)graphic) {
        if (!TESTFLAG(FLAGS(pFileRecord), INQUOTES)) {
            *pchEndLine++ = ' ';
            *pchEndLine++ = '"';
            SETFLAG (FLAGS(pFileRecord), INQUOTES);
        }
        c = (char)pCmd->arg;
        if (c == '"' || c == '\\') {
            *pchNew++ = '\\';
        }

        *pchNew++ = c;
        *pchNew = '\0';
    } else {
        if (TESTFLAG (FLAGS(pFileRecord), INQUOTES)) {
            *pchEndLine++ = '"';
            RSETFLAG (FLAGS(pFileRecord), INQUOTES);
        }
        *pchEndLine++ = ' ';
	strcpy ((char *)pchNew, pCmd->name);
    }


    // Finally, let's add the new text to the file. We'll add
    // a continuation character if necessary.
    //
    entab = EnTab;
    EnTab = 0;
    if ((COL) ((pchEndLine - buf) + strlen (szCmdName)) > xMargin) {
        strcpy (pchEndLine, " \\");
        PutLine (line+1, szCmdName, pFileRecord);
        UpdateIf (pFileRecord, line+1, FALSE);
    } else {
        strcpy (pchEndLine, szCmdName);
        UpdateIf (pFileRecord, line, FALSE);
    }

    PutLine (line, buf, pFileRecord);
    EnTab = entab;

    return ;
}





/*** RecordString - Record an entire string
*
* Purpose:
*
*   To record a string that woule be missed by RecordCmd.
*
* Input:
*   psz - String to record.
*
* Output: None
*
* Notes:
*
*   Currently implemented by callinto RecordCmd.  Should be implemented
*   by having RecordCmd and RecordString call common "write to <record>"
*   code.
*
*************************************************************************/
void
RecordString (
    char * psz
    )
{

    if (!fMacroRecord) {  /* If we're not on, do nothing */
        return;
    }

    while (*psz) {
	(CMD_graphic)->arg = *psz++;
	RecordCmd (CMD_graphic);
    }
}




/*** AppendMacroToRecord - Append the current value of a macro to <record>
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
AppendMacroToRecord (
    PCMD pCmdMac
    )
{
    flagType fDone;
    char     *pchValue, *pch;
    LINE     line;


    // First, get the raw macro value
    //
    pchValue = (char *)pCmdMac->arg;

    // Now, throw the vlaue into the file one line
    // at a time.  Start at the end of the file
    //
    line = pFileRecord->cLines - 1;

    do {
        GetLine (line, buf, pFileRecord);

        for (pch = pchValue + min ((ULONG)(xMargin + 5 - strlen(buf)), (ULONG)strlen (pchValue));
             pch > pchValue && *pch && *pch != ' ' && *pch != '\t';
             pch--) {
            ;
        }

        // Now pch points at either the last space, the end
        // of the value or the beginning.  If it points to the
        // beginning or end, we copy all of pchValue.  Otherwise,
        // we copy just up to pch
        //
        if (!*pch || pch == pchValue) {
            strcat (buf, pchValue);
            fDone = TRUE;
        } else {
            strncat (buf, pchValue, (int)(pch - pchValue));
            strcat (buf, "  \\");
            pchValue = pch + 1;
        }

        PutLine (line++, buf, pFileRecord);
    } while (!fDone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\search.c ===
/*** search.c - search routines for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Searches funnel through these routines as follows:
*
*         psearch     msearch     searchall   mgrep
*              \         |         /           /
*               \        |        /           /
*                \_______|_______/           /
*                        |                  /
*                        v                 /
*                     dosearch            /
*                      /___\_____________/
*                     /     \
*                    /       \
*                search    REsearch   REsearchS   <=== all exported to extensions
*
*   Global variables, and their meanings:
*
*   User set-able switches:
*     fUnixRE         unixre: switch. TRUE => Use UNIX Regular Expressions
*     fSrchCaseSwit   case: switch.   TRUE => case is significant
*     fSrchWrapSwit   wrap: switch.   TRUE => searches wrap
*
*   Previous Search Parameters:
*     fSrchAllPrev    TRUE => searched for all occurrances
*     fSrchCasePrev   TRUE => case was significant
*     fSrchDirPrev    TRUE => searched forward
*     fSrchRePrev     TRUE => used a regular expressions
*     fSrchWrapPrev   TRUE => wrapped around
*
*     srchbuf         search string
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/

#include <string.h>
#include <stdarg.h>
#include "mep.h"


static  int cAll;                       /* count of ocurrances for all  */
static  int cGrepped;                   /* count of ocurrances for mgrep*/
static  struct patType *patBuf  = NULL; /* compiled pattern             */


/***************************************************************************\

MEMBER:     lsearch

SYNOPSIS:   strstr based on supplied lengths rather than strlen()

ALGORITHM:

ARGUMENTS:

RETURNS:

NOTES:      Supplied strings may not be zero terminated or may have embedded
            NULs
            This is a brute force algorithm which should be updated to
            something reasonable if performance is a problem

HISTORY:    14-Aug-90 davegi
                Created

KEYWORDS:

SEEALSO:

\***************************************************************************/
char*
lsearch (
    char*   pchSrc,
    ULONG   cbSrc,
    char*   pchSub,
    ULONG   cbSub
    )
{

    REGISTER ULONG      i;
    REGISTER ULONG      j;

    assert( pchSrc );
    assert( pchSub );

    //  If the sub-string is longer than the source string or,
    //  cbSrc > strlen( pchSrc) (hack for backwards search), return NULL

    if(( cbSub > cbSrc ) || ( cbSrc > strlen( pchSrc ) + 1)) {
        return NULL;
    }

    //  Short Circuit...
    //  If first character in pchSub does not exist in pchSrc

    if( ! memchr( pchSrc, *pchSub, cbSrc )) {
        return NULL;
    }

    i = j = 0;
    do {
        if( pchSrc[ i ] == pchSub[ j ] ) {
            i++;
            j++;
        } else {
            i = i - j + 1;
            j = 0;
        }
    } while(( j < cbSub ) && ( i < cbSrc ));
    return ( j >= cbSub ) ? &( pchSrc[ i - cbSub ]) : NULL;
}



static char szNullStr[] = "";


/*** mgrep - multiple file search
*
*  Using the internal editor search code, and optimizing for those files
*  already in memory, search for a string or regular expression.
*
*  Searches the file list specified by the greplist macro.
*
*   no arg:         search for previous search string
*   Single arg:     search for string.
*   Double arg:     search for regular expression.
*   meta:           toggle case from current switch setting
*
*  Files to be searched which are already in the file history are simply
*  searched. Files which are NOT in the file history, are read in, and if
*  no occurance of the search string is found, they are then discarded as
*  well.
*
* Input:
*  Standard editting function
*
* Globals:
*                   - grep file list
*  fSrchCaseSwit    - users 'case' switch
*  fSrchRePrev      - previous RE search flag
*  fUnixRE          - users 'unixre' switch
*  pasBuf           - compiled RE pattern
*  srchbuf          - last searched for string.
*
* Output:
*  Returns TRUE on found.
*
*************************************************************************/
flagType
mgrep (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int     l;                              /* length of matched string     */
    PCMD    pcmdGrepList;                   /* pointer to grep list         */
    char    *szGrepFile;                    /* pointer to current grep file */

    assert (pArg);
    fSrchCasePrev = fSrchCaseSwit;          /* assume case switch to begin  */

    switch (pArg->argType) {

    /*
     * TEXTARG: use text as search string. If RE search, also compile the regular
     * expression into patBuf. (Fall into NOARG code).
     */
    case TEXTARG:
        strcpy ((char *) buf, pArg->arg.textarg.pText);
        srchbuf[0] = 0;
        if (pArg->arg.textarg.cArg == 2) {
            if (patBuf != NULL) {
                FREE((char *) patBuf);
            }
            patBuf = RECompile (buf, fSrchCaseSwit, (flagType)!fUnixRE);
            if (patBuf == NULL) {
                printerror ((RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
                return FALSE;
            }
            fSrchRePrev = TRUE;
        } else {
            fSrchRePrev = FALSE;
        }
        strcpy (srchbuf, buf);


    /*
     * NOARG: use previous search string & parameters
     */
    case NOARG:
        if (srchbuf[0] == 0) {
            printerror ("No search string specified");
            return FALSE;
        }
        break;
    }

    /*
     * Ee must ensure that no background compile is underway. Then get a pfile
     * there.
     */
    if (fBusy(pBTDComp)) {
        printerror ("Cannot mgrep to <compile> during background compile");
        return FALSE;
    }

    if ((PFILECOMP = FileNameToHandle (rgchComp, rgchComp)) == NULL) {
        PFILECOMP = AddFile ((char *)rgchComp);
        FileRead ((char *)rgchComp, PFILECOMP, FALSE);
        SETFLAG (FLAGS (PFILECOMP), READONLY);
    }

    /*
     * Under OS/2, if it is clear that we will destroy the log file contents
     * we ask the user and empty the file if he says so.
     */
    if (PFILECOMP->cLines
        && (confirm ("Delete current contents of compile log ? ", NULL))
       ) {
        DelFile (PFILECOMP, FALSE);
    }


    BuildFence ("mgrep", rgchEmpty, buf);
    AppFile (buf, PFILECOMP);
    /*
     * When not in a macro, indicate on the dialog line what it is we are
     * searching for
     */
    if (!mtest ()) {
        l = sout (0, YSIZE, "mgrep for '", infColor);
        l = sout (l, YSIZE, srchbuf, fgColor);
        soutb (l, YSIZE, "'", infColor);
    }

    if (fMeta) {
        fSrchCasePrev = (flagType)!fSrchCasePrev;
    }
    cGrepped = 0;

    /*
     * Get the list handle, and initialize to start at the head of the list.
     * Attempt to process each list element. If starts with "$", use forsemi to
     * process each file or pattern in each directory listed in the environment
     * variable, else process the filename directly.
     */
    if (pcmdGrepList = GetListHandle ("mgreplist", TRUE)) {
        szGrepFile = ScanList (pcmdGrepList, TRUE);
        while (szGrepFile) {
            char    *pathstr;
            char    *tmp = NULL;

            if (*szGrepFile == '$') {
                char    *p;

                if (*(p=strbscan (szGrepFile, ":"))) {
                    *p = 0;

                    if ((tmp = getenvOem (szGrepFile+1)) == NULL) {
                        pathstr = szNullStr;
                    } else {
                        pathstr = tmp;
                    }

                    *p++ = ':';
                    szGrepFile = p;
                }
            } else {
                pathstr = szNullStr;
            }

            forsemi (pathstr, mgrep1env, szGrepFile);

            if( tmp != NULL ) {
                free( tmp );
            }

            szGrepFile = ScanList (NULL, TRUE);
            if (fCtrlc) {
                return FALSE;
            }
        }
    }
    if (cGrepped) {
        nextmsg (0, &NoArg, FALSE);
    }
    domessage ("%d occurrences found",cGrepped);
    return (flagType)(cGrepped != 0);

    argData;
}





/*** mgrep1env - perform grep on environment variable when found
*
*  Called when an environment variable is found in the mgrep list to
*  process all the files in that path. Called once per directory entry
*  in the list.
*
* Input:
*  pszEnv       = pointer to directory name
*  pFileName    = pointer to filename
*
* Output:
*  Returns nothing.
*
*************************************************************************/
flagType
mgrep1env (
    char *  pszEnv,
    va_list pa
    )
{
    char   *pszFn = (char *)va_arg( pa, char* );
    pathbuf bufFn;                          /* filename buffer              */

    if (fCtrlc) {
        return TRUE;
    }

    /*
     * construct full pathname in buffer.
     */
    {
        pathbuf bufBuild;

        strcpy (bufBuild, pszEnv);
        if (*pszEnv && (*(strend(bufBuild)-1) != '\\')) {
            *(int *) strend (bufBuild) = '\\';
        }
        strcat (bufBuild, pszFn);
        CanonFilename (bufBuild, bufFn);
    }

    forfile (bufFn, A_ALL, mgrep1file, NULL);

    return FALSE;
}




/*** mgrep1file - grep the contents of 1 file.
*
*  Searches through one file for stuff.
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
mgrep1file (
    char   *szGrepFile,
    struct findType *pfbuf,
    void * dummy
    )
{

    flagType fDiscard;                      /* discard the file read?       */
    fl       flGrep;                         /* ptr to current grep loc      */
    int      l;                              /* length of matched string     */
    PFILE    pFileGrep;                      /* file to be grepped           */

    assert (szGrepFile);

    if (fCtrlc) {
        return;
    }

    flGrep.lin = 0;
    flGrep.col = 0;

    /*
     * If we can get a handle to the file, then it's alread in the list, and we
     * should not discard it when done. If it is not in the list, we read it in,
     * but we'll discard it, unless something is found there.
     */
    if (!(pFileGrep = FileNameToHandle (szGrepFile, szGrepFile))) {
        pFileGrep = AddFile (szGrepFile);
        SETFLAG (FLAGS (pFileGrep), REFRESH);
        fDiscard = TRUE;
    } else {
        fDiscard = FALSE;
    }

    /*
     * If the file needs to be physically read, do so.
     */
    if ((FLAGS (pFileGrep) & (REFRESH | REAL)) != REAL) {
        FileRead (pFileGrep->pName, pFileGrep, FALSE);
        RSETFLAG (FLAGS(pFileGrep), REFRESH);
    }

    /*
     * Use either the normal searcher, or the regular expression searcher, based
     * on the use of regular expressions.
     */
    do {
        if (fSrchRePrev) {
            l = REsearch (pFileGrep,        /* file to search               */
                          TRUE,             /* direction: forward           */
                          FALSE,            /* not a searchall              */
                          fSrchCasePrev,    /* case                         */
                          FALSE,            /* wrap                         */
                          patBuf,           /* pattern                      */
                          &flGrep);         /* start/end location           */
        } else {
            l = search (pFileGrep,
                          TRUE,             /* direction: forward           */
                          FALSE,            /* not a searchall              */
                          fSrchCasePrev,    /* case                         */
                          FALSE,            /* wrap                         */
                          srchbuf,          /* pattern                      */
                          &flGrep);         /* start/end location           */
        }

        if (l >= 0) {
            /*
             * if the search was successfull, if adding to <compile>, do so, else
             * highlight the found search string and exit.
             */
            buffer  linebuf;

            fDiscard = FALSE;
            cGrepped++;
            GetLine (flGrep.lin, linebuf, pFileGrep);
            zprintf (  PFILECOMP
                     , PFILECOMP->cLines
                     , "%s %ld %d: %s"
                     , pFileGrep->pName
                     , ++flGrep.lin
                     , ++flGrep.col
                     , linebuf);
        } else {
            /*
             * If the search was not successfull, discard the file, if needed, and move
             * to the next.
             */
            if (fDiscard) {
                RemoveFile (pFileGrep);
            }
            if (UpdateIf (PFILECOMP, PFILECOMP->cLines, FALSE)) {
                Display ();
            }
            return;
        }
    } while (TRUE);

    pfbuf; dummy;
}




/*** psearch - plus search function
*
*  Search the current file forward for a string.
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
psearch (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (TRUE, pArg, fMeta, FALSE);

    argData;
}




/*** msearch - minus search function
*
*  Search the current file backward for a string.
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
msearch (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (FALSE, pArg, fMeta, FALSE);

    argData;
}




/*** searchall
*
*  Searches the entire current file for a string, and highlights all ocurrances
*
* Input:
*  Standard Editor Editing Function
*
* Output:
*  Returns TRUE on success (at least one string found).
*
*************************************************************************/
flagType
searchall (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return dosearch (TRUE, pArg, fMeta, TRUE);

    argData;
}




/*** dosearch - perform search operation
*
*  Single funnel for all file search operations.
*
*  NULLARG is converted into TEXTARG
*  LINEARG, STREAMARG, BOXARG are illegal
*
* Input:
*  fForard      = TRUE => Indicates that search is forward
*  pArg         = pointer to user specified args
*  fMeta        = TRUE => if meta on
*  fAll         = TRUE => highlight all ocurrances
*
* Output:
*  Returns TRUE if found
*
*************************************************************************/
flagType
dosearch (
    flagType fForward,
    ARG * pArg,
    flagType fMeta,
    flagType fAll
    )
{
    int     l;                              /* length of matched string     */
    fl      flCur;                          /* file loc before/after search */
    rn      rnCur;                          /* range to be highlighted      */

    assert (pArg);
    fSrchCasePrev = fSrchCaseSwit;          /* assume case switch to begin  */

    switch (pArg->argType) {

    /*
     * TEXTARG: use text as search string. If RE search, also compile the regular
     * expression into patBuf. (Fall into NOARG code).
     */
    case TEXTARG:
        strcpy ((char *) buf, pArg->arg.textarg.pText);
        srchbuf[0] = 0;
        if (pArg->arg.textarg.cArg == 2) {
            if (patBuf != NULL) {
                FREE((char *) patBuf);
            }
            patBuf = RECompile (buf, fSrchCaseSwit, (flagType)!fUnixRE);
            if (patBuf == NULL) {
                printerror ((RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
                return FALSE;
            }
            fSrchRePrev = TRUE;
        } else {
            fSrchRePrev = FALSE;
        }

        fSrchWrapPrev = fSrchWrapSwit;
        strcpy (srchbuf, buf);

    /*
     * NOARG: use previous search string & parameters
     */
    case NOARG:
        if (srchbuf[0] == 0) {
            printerror ("No search string specified");
            return FALSE;
        }
        break;

    }

    /*
     * The case to be used is the use's case switch, or the opposite of that if
     * meta was specified. Save rest of globals as well.
     */
    fSrchAllPrev = fAll;
    if (fMeta) {
        fSrchCasePrev = (flagType)!fSrchCasePrev;
    }

    fSrchDirPrev = fForward;

    /*
     * When not in a macro, indicate on the dialog line what it is we are
     * searching for
     */
    if (!mtest ()) {
        char c;
        l = sout (0, YSIZE, fSrchDirPrev ? "+Search for '" : "-Search for '", infColor);
        c = srchbuf[ XSIZE - 14];
        srchbuf[ XSIZE-14] = '\0';
        l = sout (l, YSIZE, srchbuf, fgColor);
        srchbuf[ XSIZE-14] = c;
        soutb (l, YSIZE, "'", infColor);
    }

    /*
     * If this is a search for all occurrances, we begin the search from the
     * file begining. Otherwise, set the start position of the search to the
     * current cursor position.
     */
    if (fSrchAllPrev) {
        flCur.col = 0;
        flCur.lin = 0;
    } else {
        flCur.col = XCUR (pInsCur) + (fSrchDirPrev ? 1 : -1);
        flCur.lin = YCUR (pInsCur);
    }

    /*
     * Use either the normal searcher, or the regular expression searcher, based
     * on the use of regular expressions.
     */
    if (fSrchRePrev) {
        l = REsearch (pFileHead,
                      fSrchDirPrev,
                      fSrchAllPrev,
                      fSrchCasePrev,
                      fSrchWrapPrev,
                      patBuf,
                      &flCur);
    } else  {
        l = search (pFileHead,
                    fSrchDirPrev,
                    fSrchAllPrev,
                    fSrchCasePrev,
                    fSrchWrapPrev,
                    srchbuf,
                    &flCur);
    }

    /*
     * if the search was successfull, output the count of items founf for search
     * all, or highlight the found search string for a single ocurrance search
     */
    if (l >= 0) {
        if (fSrchAllPrev) {
            newscreen ();
            domessage ("%d occurrences found",cAll);
        } else {
            rnCur.flFirst = flCur;
            rnCur.flLast.col = flCur.col+l-1;
            rnCur.flLast.lin = flCur.lin;
            ClearHiLite( pFileHead, TRUE);
            SetHiLite (pFileHead,rnCur,HGCOLOR);
            Display();
        }
        cursorfl (flCur);
        return TRUE;
    }

    /*
     * If the search was not successfull, indicate as such.
     */
    if (!mtest ()) {
        srchbuf[XSIZE-12] = 0;
        domessage (fSrchDirPrev ? "+'%s' not found" : "-'%s' not found", srchbuf);
    }
    return FALSE;
}





/*** search - look for a string in a file
*
*  search will begin a scan of the file looking for a particular string in the
*  specified file beginning at the specified location. We perform simple
*  character string matching. We return the length and location of the match.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = character pointer to the search string
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns      length of match if found, -1 if not found
*
*************************************************************************/
int
search (
    PFILE   pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    char    *pat,
    fl      *pflStart
    )
{
    int     cbPhys;                         /* physical length of line      */
    fl      flCur;                          /* current location in file     */
    LINE    yMac;
    linebuf sbuf;
    linebuf pbuf;
    int     lpat            = strlen (pat);
    int     l;
    char    *pFound;
    char    *pSearch;                       /* point at which to search     */
    rn      rnCur;                          /* range to be highlighted      */

    assert (pat && pflStart && pFile);
    strcpy (pbuf, pat);
    if (!fCase) {
        _strlwr (pbuf);
    }
    cAll = 0;
    flCur = *pflStart;

    if (fForward) {
        /*
         * forward search. Search every line up until the end of the file. (or up
         * until the original start position, if wrap was set). Check for CTRL+C
         * break, and get each lines text.
         */
        yMac = pFile->cLines;

        while (flCur.lin < yMac) {
            if (fCtrlc) {
                break;
            }
            cbPhys = GetLine (flCur.lin, sbuf, pFile);
            l = cbLog (sbuf);

            /*
             * search the buffer for the string of interest. Convert string to lower case
             * first if case insensitive search.
             */
            if (!fCase) {
                _strlwr (sbuf);
            }

            pSearch = pLog (sbuf,flCur.col,TRUE);
            if (colPhys (sbuf, pSearch) != flCur.col) {
                pSearch++;
            }

            while ((l > flCur.col)
                && (pFound = lsearch (pSearch, cbPhys - (ULONG)(pSearch-sbuf), pbuf, lpat))) {

                /*
                 * string found. Compute starting column of match. If not already found,
                 * update the caller's copy. For search-all, add the highlight, else for
                 * search once, return the length.
                 */
                flCur.col = colPhys (sbuf, pFound);
                if (!cAll) {
                    *pflStart = flCur;
                }
                cAll++;
                if (!fAll) {
                    return colPhys(sbuf, pFound+lpat) - colPhys(sbuf, pFound);
                }
                rnCur.flFirst = flCur;
                rnCur.flLast.lin = flCur.lin;
                rnCur.flLast.col = flCur.col+lpat-1;
                SetHiLite (pFile,rnCur,HGCOLOR);
                pSearch = pLog (sbuf,flCur.col,TRUE) + 1;
                flCur.col = colPhys (sbuf, pSearch);
            }
            noise (flCur.lin++);

            /*
             * if wrap around supported, then if we're at the end of the file, wrap around
             * to the begining.
             */
            if (fWrap && (flCur.lin >= pFile->cLines)) {
                yMac = pflStart->lin;
                flCur.lin = 0;
            }
            flCur.col = 0;
        }
    } else {
        /*
         * backwards search. Doesn't have to be concerned about searchall, since those
         * always occur forward. Otherwise, the same as above, only backwards.
         */
        assert (!fAll);
        yMac = 0;
        while (flCur.lin >= yMac) {
            if (fCtrlc) {
                break;
            }
            GetLine (flCur.lin, sbuf, pFile);
            l = cbLog (sbuf);

            /*
             * search the buffer for the string of interest. Convert string to lower
             * case first if case insensitive search. Terminate the buffer at the
             * starting column (this is a backwards search)
             */
            if (!fCase) {
                _strlwr (sbuf);
            }
            pSearch  = pLog (sbuf, flCur.col, TRUE);
            *(pSearch+1) = 0;
            cbPhys   = (int)(pSearch - sbuf);
            pSearch  = sbuf;

            /*
             * search the line forward once for any occurrance. Then if FOUND, search
             * repeatedly for the LAST occurrance in the text, and return the info on
             * that.
             */
            if (pFound = lsearch (pSearch, cbPhys - (ULONG)(pSearch-sbuf), pbuf, lpat)) {
                do {
                    pSearch = pFound;
                } while (pFound = lsearch (pSearch+1, cbPhys - (ULONG)(pSearch-sbuf) , pbuf, lpat));
                flCur.col = colPhys (sbuf, pSearch);
                *pflStart = flCur;
                return colPhys(sbuf, pLog (sbuf,flCur.col,TRUE) + lpat) - flCur.col;
            }
            noise (flCur.lin--);
            if (fWrap && (flCur.lin < 0)) {
                yMac = pflStart->lin;
                flCur.lin = pFile->cLines-1;
            }
            flCur.col = sizeof(linebuf)-1;
        }
    }

    /*
     * end of search. if a search for all, and found at least one, then return the
     * pattern length. Else, return -1.
     */
    if (fAll && cAll) {
        return lpat;
    }
    return -1;
}




/*** REsearch - look for a pattern in a file
*
*  REsearch will begin a scan of the file looking for a particular pattern
*  in the specified file beginning at the specified location. We perform
*  regular expression matching. We return the length and location of the
*  match.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = pointer to compiled pattern
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns length of (first) match if found, -1 if not found
*
*************************************************************************/
int
REsearch (
    PFILE    pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    struct patType *pat,
    fl       *pflStart
    )
{
    fl      flCur;
    int     l, rem;
    rn      rnCur;                          /* area to be highlighted       */
    linebuf sbuf;
    LINE    yMac;
    unsigned MaxREStack = 512;
    RE_OPCODE **REStack = (RE_OPCODE **)ZEROMALLOC (MaxREStack * sizeof(*REStack));
    flagType fAgain;

    assert (pat && pflStart && pFile);
    cAll = 0;
    flCur = *pflStart;

    if (fForward) {
        /*
         * forward search. Search every line up until the end of the file. (or up
         * until the original start position, if wrap was set). Check for CTRL+C
         * break, and get each lines text.
         */
        yMac = pFile->cLines;
        while (flCur.lin < yMac) {
            if (fCtrlc) {
                break;
            }
            if (GetLine (flCur.lin, sbuf, pFile) >= flCur.col) {
                fAgain = TRUE;
                do {
                    switch (rem = REMatch (pat, sbuf, pLog (sbuf, flCur.col, TRUE), REStack, MaxREStack, TRUE)) {

                        case REM_MATCH:
                            //
                            // update rnCur to reflect the logical coordinates of the string actually
                            // found.
                            // when real tabs are on, REStart returns the physical character position of
                            // the found string, which still needs to be mapped to the logical columns.
                            //
                            rnCur.flFirst.lin = rnCur.flLast.lin = flCur.lin;
                            rnCur.flFirst.col = colPhys (sbuf, REStart ((struct patType *) patBuf));
                            rnCur.flLast.col  = colPhys (sbuf, REStart ((struct patType *) patBuf) + RELength (pat, 0)) - 1;

                            //
                            // If not already found, update the caller's copy. For search-all, add the
                            // highlight, else for search once, return the length.
                            //
                            if (!cAll++) {
                                *pflStart = rnCur.flFirst;
                            }
                            if (fAll) {
                                SetHiLite (pFile,rnCur,HGCOLOR);
                            } else {
                                FREE (REStack);
                                return rnCur.flLast.col - rnCur.flFirst.col + 1;
                            }
                            flCur.col = rnCur.flFirst.col + 1;
                            break;

                        case REM_STKOVR:
                            //
                            //  The RE machine stack overflowed.  Increase and try again
                            //
                            MaxREStack += 128;
                            REStack = (RE_OPCODE **)ZEROREALLOC((PVOID)REStack, MaxREStack * sizeof (*REStack));
                            break;

                        //
                        //  Either REM_INVALID (we passed in bad parameters), or REM_UNDEF (undefined
                        //  opcode in pattern.  Either way, it's an internal error
                        //
                        default:
                            printerror ("Internal Error: RE error %d, line %ld", rem, flCur.lin);

                        case REM_NOMATCH:
                            fAgain = FALSE;
                            break;

                    }
                } while (fAgain);
            }
            noise (flCur.lin++);

            /*
             * if wrap around supported, then if we're at the end of the file, wrap around
             * to the begining.
             */
            if (fWrap && (flCur.lin >= pFile->cLines)) {
                yMac = pflStart->lin;
                flCur.lin = 0;
            }
            flCur.col = 0;
        }
    } else {
        /*
         * backwards search. Doesn't have to be concerned about searchall, since those
         * always occur forward. Otherwise, the same as above, only backwards.
         */
        assert (!fAll);
        if (flCur.col < 0) {
            flCur.lin--;
        }
        yMac = 0;
        while (flCur.lin >= yMac) {
            if (fCtrlc) {
                break;
            }
            l = GetLine (flCur.lin, sbuf, pFile);
            if (flCur.col < 0) {
                flCur.col = l;
            }
            fAgain = TRUE;
            do {
                switch (rem = REMatch (pat, sbuf, pLog (sbuf, flCur.col, TRUE), REStack, MaxREStack, FALSE)) {
                    case REM_MATCH:
                        pflStart->col = colPhys (sbuf, REStart ((struct patType *) patBuf));
                        pflStart->lin = flCur.lin;
                        FREE (REStack);
                        return   colPhys (sbuf, REStart ((struct patType *) patBuf) + RELength (pat, 0))
                               - colPhys (sbuf, REStart ((struct patType *) patBuf));

                    case REM_STKOVR:
                        MaxREStack += 128;
                        REStack = (RE_OPCODE **)ZEROREALLOC ((PVOID)REStack, MaxREStack * sizeof(*REStack));
                        break;

                    default:
                        printerror ("Internal Error: RE error %d, line %ld", rem, flCur.lin);

                    case REM_NOMATCH:
                        fAgain = FALSE;
                        break;
                }
            } while (fAgain);

            flCur.col = -1;
            noise (flCur.lin--);
            if (fWrap && (flCur.lin < 0)) {
                yMac = pflStart->lin;
                flCur.lin = pFile->cLines-1;
            }
        }
    }

    FREE (REStack);

    /*
     * end of search. if a search for all, and found at least one, then return the
     * pattern length. Else, return -1.
     */
    if (fAll && cAll) {
        return RELength (pat, 0);
    }
    return -1;

    fCase;
}




/*** REsearchS - look for a pattern in a file
*
*  REsearchS will begin a scan of the file looking for a particular pattern
*  in the specified file beginning at the specified location. We perform
*  regular expression matching. We return the length and location of the
*  match.
*
*  REsearchS is the same as REsearch, except that is takes an uncompiled
*  string.
*
* Input:
*  pFile        = pointer to file structure to be searched
*  fForward     = TRUE => search forward from the specified location
*  fAll         = TRUE => find and highlight all ocurrances
*  fCase        = TRUE => case is significant in comparisons
*  fWrap        = TRUE => search wraps around ends of file
*  pat          = pointer to RE character string
*  pflStart     = pointers to the location of the beginning of search. Updated
*                 to reflect the actually found location (or the first found
*                 for a searchall).
*
* Output:
*  Returns length of (first) match if found, -1 if not found
*
*************************************************************************/
int
REsearchS (
    PFILE   pFile,
    flagType fForward,
    flagType fAll,
    flagType fCase,
    flagType fWrap,
    char    *pat,
    fl      *pflStart
    )
{
    assert (pat && pflStart && pFile);
    if (patBuf != NULL) {
        FREE ((char *) patBuf);
    }
    patBuf = RECompile (pat, fCase, (flagType)!fUnixRE);
    if (patBuf == NULL) {
        printerror ( (RESize == -1) ? "Invalid pattern" : "Not enough memory for pattern");
        return -1;
    }
    return REsearch (pFile, fForward, fAll, fCase, fWrap, patBuf, pflStart);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\show.c ===
/*** show.c - useful information displays
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#include "mep.h"
#include "cmds.h"


/*** showasg - construct the <assign> file
*
* Input:
*  pFile        = pFile to contruct it in
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
showasg (
    PFILE   pFile
    )
{
    int     i, j;
    PSWI    pSwi;
    linebuf tempbuf;
    extern unsigned char Int16CmdBase;

    /*
     * if now new assignments have been made (and file isn't empty), then don't
     * refresh the contents!
     */
    if (!fNewassign && pFile->cLines) {
        return;
    }

    fNewassign = FALSE;
    pFileAssign = pFile;
    DelFile (pFile, FALSE);

    /*
     * Write header to assign file
     */
    appmsgs (MSG_ASSIGN_HDR, pFile);
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * Start editor section on intrinsic functions with editor name, comment, and
     * dump the functions.
     */
    zprintf (pFile, pFile->cLines, "[%s]", pNameEditor);
    AppFile (GetMsg (MSG_ASG_FUNC, tempbuf), pFile);
    AppFile ((char *)rgchEmpty, pFile);
    for (i = 0; cmdSet[0][i].name; i++) {
        FuncOut (&cmdSet[0][i], pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * The section on macros
     */
    AppFile (GetMsg (MSG_ASG_MACROS, tempbuf), pFile);
    AppFile ((char *)rgchEmpty, pFile);
    for (i = 0; i < cMac; i++) {
        FuncOut (rgMac[i], pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * section specfic to each extension
     */
    for (i = 1; i < cCmdTab; i++) {
        zprintf (pFile, pFile->cLines, "[%s-%s]", pNameEditor, pExtName[i]);
        AppFile ((char *)rgchEmpty, pFile);
        for (j = 0; cmdSet[i][j].name; j++) {
            FuncOut (&cmdSet[i][j], pFile);
        }
        AppFile ((char *)rgchEmpty, pFile);
    }

    /*
     * Write available keys header
     */
    appmsgs (MSG_KEYS_HDR1, pFile);
    UnassignedOut (pFile);
    AppFile ((char *)rgchEmpty, pFile);

    /*
     * Remember the start of the switches section, and dump that header
     */
    lSwitches = pFile->cLines - 1;
    appmsgs (MSG_SWITCH_HDR, pFile);

    for (i = 0; i < cCmdTab; i++) {

        if (i) {
                zprintf (pFile, pFile->cLines, "[%s-%s]", pNameEditor, pExtName[i]);
        } else {
            zprintf (pFile, pFile->cLines, "[%s]", pNameEditor);
        }

            AppFile (GetMsg(MSG_ASG_NUMER, tempbuf), pFile);
            AppFile ((char *)rgchEmpty, pFile);

        for (pSwi = swiSet[i]; pSwi->name != NULL; pSwi++) {

                if ((pSwi->type & 0xFF) == SWI_NUMERIC ||
                        (pSwi->type & 0xFF) == SWI_SCREEN) {

                if ((pSwi->type & 0xFF00) == RADIX16) {
                            zprintf (pFile, pFile->cLines, "%20Fs:%x", pSwi->name, *pSwi->act.ival);
                } else {
                    zprintf (pFile, pFile->cLines, "%20Fs:%d", pSwi->name, *pSwi->act.ival);
                }

            } else if ((i == 0) && (pSwi->type & 0xFF) >= SWI_SPECIAL) {

                if (pSwi->act.pFunc2 == SetFileTab) {
                    j = fileTab;
                } else if (pSwi->act.pFunc == SetTabDisp) {
                            j = (unsigned char)tabDisp;
                } else if (pSwi->act.pFunc == SetTrailDisp) {
                            j = (unsigned char)trailDisp;
                } else if (pSwi->act.pFunc == (PIF)SetCursorSizeSw ) {
                    j = CursorSize;
                } else {
                    continue;
                }

                        zprintf (pFile, pFile->cLines, "%20Fs:%ld", pSwi->name, (long)(unsigned)j);
            }
        }

            AppFile ((char *)rgchEmpty, pFile);

            AppFile (GetMsg(MSG_ASG_BOOL,tempbuf), pFile);
            AppFile ((char *)rgchEmpty, pFile);

        for (pSwi = swiSet[i]; pSwi->name != NULL; pSwi++) {
            if ((pSwi->type & 0xFF) == SWI_BOOLEAN) {
                zprintf (pFile, pFile->cLines, "%20Fs:%s", pSwi->name, *pSwi->act.fval ? "yes" : "no");
            }
        }

            AppFile ((char *)rgchEmpty, pFile);

            if (i == 0) {
                AppFile (GetMsg(MSG_ASG_TEXT,tempbuf), pFile);
                AppFile ((char *)rgchEmpty, pFile);

                zprintf (pFile, pFile->cLines, "%11s:%s", "backup",
                                backupType == B_BAK ? "bak" : backupType == B_UNDEL ? "undel" : "none");

                ShowMake (pFile);
            if (pFileMark) {
                zprintf (pFile, pFile->cLines, "%11s:%s", "markfile", pFileMark->pName);
            }
            zprintf (pFile, pFile->cLines, "%11s:%s", "printcmd", pPrintCmd ? pPrintCmd : "");
            zprintf (pFile, pFile->cLines, "%11s:%s", "readonly", ronlypgm ? ronlypgm : "");
                AppFile ((char *)rgchEmpty, pFile);

        }
    }

    FTYPE(pFile) = TEXTFILE;
    RSETFLAG (FLAGS(pFile), DIRTY);
}



/*** appmsgs - append series of text messages to pFile
*
*  Appends a series of text strings to the passed pFile
*
* Input:
*  iMsg         - Starting message number
*  pFile        - pFile to append to
*
* Output:
*  Returns
*
*************************************************************************/
void
appmsgs (
    int     iMsg,
    PFILE   pFile
    )
{
    linebuf tempbuf;

    while (TRUE) {
        GetMsg (iMsg++,tempbuf);
        if (tempbuf[0] == '?') {
            break;
        }
        AppFile (tempbuf, pFile);
    }
}


static char szEmptyClipboard[] = "The clipboard is empty";


/*** showinf - construct <information-file>
*
* Input:
*  pFile        - pFile to construct in
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
showinf (
    PFILE pFile
    )
{
    PFILE pFileTmp;

    DelFile (pFile, FALSE);
    SETFLAG (FLAGS(pFile), READONLY);
    AppFile (Name, pFile);
    AppFile (Version, pFile);
    AppFile ((char *)rgchEmpty, pFile);
    RSETFLAG (FLAGS(pFile), DIRTY);
    for (pFileTmp = pFileHead; pFileTmp != NULL; pFileTmp = pFileTmp->pFileNext) {
        infprint (pFileTmp, pFile);
    }
    AppFile ((char *)rgchEmpty, pFile);
    if (pFilePick->cLines == 0) {
        AppFile (szEmptyClipboard, pFile);
    } else {
        zprintf (pFile, pFile->cLines, "%ld line%s in %s clipboard", pFilePick->cLines,
                 pFilePick->cLines == 1 ? (char *)rgchEmpty : "s",
                 kindpick == STREAMARG ? "stream" : kindpick == LINEARG ? "line" :
                 kindpick == BOXARG ? "box" : "?");
    }
    AppFile ((char *)rgchEmpty, pFile);
    FTYPE(pFile) = TEXTFILE;
    RSETFLAG (FLAGS(pFile), DIRTY);
}




/*** infprint - print info about 1 file
*
*  Appends to the information file the info on 1 file
*
* Input:
*  pFile        - pFile of interest
*  pFileDisplay - pFile to display in
*
* Output:
*  Returns FALSE
*
*************************************************************************/
flagType
infprint (
    PFILE pFile,
    PFILE pFileDisplay
    )
{
    if (TESTFLAG(FLAGS(pFile),REAL)) {
        zprintf (pFileDisplay, pFileDisplay->cLines, "%-30s %c%ld lines", pFile->pName,
                       TESTFLAG(FLAGS(pFile),DIRTY) ? '*' : ' ',
                       pFile->cLines);
    } else {
        zprintf (pFileDisplay, pFileDisplay->cLines, "%-20s", pFile->pName);
    }
    return FALSE;
}




/*** information - show editting history
*
*  Display the information file
*
* Input:
*  standard editing function
*
* Output:
*  Returns TRUE on successfull display
*
*************************************************************************/
flagType
information (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    AutoSave ();
    return fChangeFile (FALSE, rgchInfFile);

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\statfile.c ===
/*** statefile.c - Code for status/state file processing
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"



/*** ReadTMPFile - Read the editor .STS/.TMP status file
*
*  Load up the information from the project status file.
*
* Input:
*
* Output:
*
*************************************************************************/
flagType
    ReadTMPFile (
    )
{
    FILE    *fhTmp;                         /* .TMP file file handle        */

    PWND    pWin = NULL;

    int     x;                              /* x corrdinate read from file  */
    int     y;                              /* y corrdinate read from file  */

    char    *pName;
    char    *pData;
    PINS    pInsNew  = NULL;
    PINS    pInsHead = NULL;
    PFILE   pFileTmp;                       /* pFile being created          */
    PFILE  *ppFileList;

    ppFileList = &pFileHead;
    while (pFileTmp = *ppFileList) {
        ppFileList = &pFileTmp->pFileNext;
        }

    if ((fhTmp = pathopen (pNameTmp, buf, "rt")) != NULL) {

        /*
         * Read the header lines in the file. We ignore the first line (editor
         * version), make sure that the second line contains the expected .TMP file
         * version string, and the third line has two integers, which are the screen
         * dimensions.
         */
        if ((fgetl (buf, sizeof(buf), fhTmp) == 0)
            || (fgetl (buf, sizeof(buf), fhTmp) == 0)
            || strcmp(buf,TMPVER)
            || (fgetl (buf, sizeof(buf), fhTmp) == 0)
            || (sscanf (buf, "%d %d", &x, &y) != 2)) {
        } else {
            /*
             * For each line in the rest of the .TMP file, process
             */
            while (fgetl (buf, sizeof(buf), fhTmp) != 0) {
                // assert (_heapchk() == _HEAPOK);
                assert (_pfilechk());
                /*
                 * Process previous search & replace strings
                 */
                if (!_strnicmp ("SRCH:", buf, 5)) {
                    strcpy (srchbuf, buf+5);
                } else if (!_strnicmp ("DST:", buf, 4)) {
                    strcpy (rplbuf, buf+4);
                } else if (!_strnicmp ("SRC:", buf, 4)) {
                    strcpy (srcbuf, buf+4);
                } else if (!_strnicmp ("INS:", buf, 4)) {
                    fInsert = (flagType)!_strnicmp ("ON", buf+4, 2);
                } else {
                    switch (buf[0]) {

                        /*
                         * lines begining with ">" indicate a new window. On the rest of
                         * the line, the first two digits are the window screen position,
                         * and the next are the window size.
                         */
                        case '>':
                            pWin = &WinList[cWin++];
                            sscanf (buf+1, " %d %d %d %d ",
                                    &WINXPOS(pWin), &WINYPOS(pWin),
                                    &WINXSIZE(pWin), &WINYSIZE(pWin));
                            pWin->pInstance = NULL;
                            break;

                        /*
                         * Lines begining with a space are instance descriptors of the files
                         * in the most recent window's instance list.
                         */
                        case ' ':
                            /*
                             * allocate new instance, and place at tail of list (list now
                             * created in correct order).
                             */
                            if (pInsNew) {
                                pInsNew->pNext = (PINS) ZEROMALLOC (sizeof (*pInsNew));
                                pInsNew = pInsNew->pNext;
                            } else {
                                pInsHead = pInsNew = (PINS) ZEROMALLOC (sizeof (*pInsNew));
                            }
#ifdef DEBUG
                            pInsNew->id = ID_INSTANCE;
#endif
                            /*
                             * isolate filename and parse out instance information
                             */
                            if (buf[1] == '\"') {
                                pName = buf + 2;
                                pData = strrchr(buf, '\"');
                                *pData++ = '\0';
                            } else {
                                ParseCmd (buf, &pName,&pData);
                            }

                            sscanf (pData, " %d %ld %d %ld "
                                         , &XWIN(pInsNew), &YWIN(pInsNew)
										 , &XCUR(pInsNew), &YCUR(pInsNew));
							//
							//	If the cursor position falls outside of the current
							//	window, we patch it
							//
							if( XCUR(pInsNew) - XWIN(pInsNew) > XSIZE ) {

								XCUR(pInsNew) = XWIN(pInsNew) + XSIZE - 1;
							}

							if ( YCUR(pInsNew) - YWIN(pInsNew) > YSIZE ) {

								YCUR(pInsNew) = YWIN(pInsNew) + YSIZE - 1;
							}

							/*
							//
							//	If the window and cursor dimensions conflict with
							//	the current dimensions, we patch them.
							//
							if ((XWIN(pInsNew) > XSIZE) || (YWIN(pInsNew) > YSIZE)) {
								XWIN(pInsNew) = XSIZE;
								YWIN(pInsNew) = YSIZE;
							}

							//if ((XCUR(pInsNew) > XSIZE) || (YCUR(pInsNew) > YSIZE)) {
							//	XCUR(pInsNew) = 0;
							//	YCUR(pInsNew) = 0;
							//}
							*/

                            /*
                             * create file structure
                             */
                            pFileTmp = (PFILE) ZEROMALLOC (sizeof (*pFileTmp));
#ifdef DEBUG
                            pFileTmp->id = ID_PFILE;
#endif
                            pFileTmp->pName = ZMakeStr (pName);

			    pFileTmp->plr      = NULL;
			    pFileTmp->pbFile   = NULL;
                            pFileTmp->vaColor  = (PVOID)(-1L);
                            pFileTmp->vaHiLite = (PVOID)(-1L);
                            pFileTmp->vaUndoCur  = (PVOID)(-1L);
                            pFileTmp->vaUndoHead = (PVOID)(-1L);
                            pFileTmp->vaUndoTail = (PVOID)(-1L);

                            CreateUndoList (pFileTmp);

                            /*
                             * Place the file at the end of the pFile list
                             */
                            *ppFileList = pFileTmp;
                            ppFileList = &pFileTmp->pFileNext;
                            SetFileType (pFileTmp);
                            IncFileRef (pFileTmp);
                            pInsNew->pFile = pFileTmp;
                            break;

                        /*
                         * A blank line occurrs at the end of the file list for a window.
                         * We use this to advance to next window. If we *just* found more
                         * than one window, fix the screen mode to match the last value
                         */
                        case '.':
                        case '\0':
							if (cWin >	1 && !fVideoAdjust (x, y)) {
                                goto initonewin;
                            }
                            assert (pWin && cWin);
                            pWin->pInstance = pInsHead;
                            pInsHead = pInsNew = NULL;
                            break;
                    }
                }
            }
        }

        fclose (fhTmp);

        /*
         * At startup, current window is always first window
         */
        pWinCur = WinList;
    }

	if (cWin == 1) {
		WINXSIZE(pWinCur) = XSIZE;
        WINYSIZE(pWinCur) = YSIZE;
	} else if (cWin == 0) {
initonewin:
        /*
         * if no status file was read, ensure that we have at least one valid window,
         * the size of the screen
         */
        cWin = 1;
        pWinCur = WinList;
        pWinCur->pInstance = NULL;
        WINXSIZE(pWinCur) = XSIZE;
        WINYSIZE(pWinCur) = YSIZE;
    }

    assert(pWinCur);

    pInsCur = pWinCur->pInstance;

    /*
     * Get the file to edit from the command line, if any.
     * This will eventually set pInsCur.
     */
    if (!fFileAdvance() && fCtrlc) {
        CleanExit (1, CE_VM | CE_SIGNALS);
    }

    /*
     * Find windows with no instance: set current file to <untitled>
     */
    for (pWin = WinList; pWin < &WinList[cWin]; pWin++) {
        if (pWin->pInstance == NULL) {
            pInsHead = (PINS) ZEROMALLOC (sizeof (*pInsHead));
#ifdef DEBUG
            pInsHead->id = ID_INSTANCE;
#endif
            if (!(pInsHead->pFile = FileNameToHandle (rgchUntitled, rgchEmpty))) {
                pInsHead->pFile = AddFile ((char *)rgchUntitled);
            }
            IncFileRef (pInsHead->pFile);
            pWin->pInstance = pInsHead;
        }
    }

    /*
     * Set current instance if not already done by fFileAdvance
     */
    if (pInsCur == NULL) {
        pInsCur = pWinCur->pInstance;
    }

    assert (pInsCur);

    /*
     * If we cannot change to the current file, we will walk the window instance
     * list until we get a valid file. If no one can be loaded then we switch to
     * the <untitled> pseudo-file.
     * NB: fChangeFile does a RemoveTop so we don't need to move pInsCur
     */
    while ((pInsCur != NULL) && (!fChangeFile (FALSE, pInsCur->pFile->pName))) {
        ;
    }

    if (pInsCur == NULL) {
        fChangeFile (FALSE, rgchUntitled);
    }

    return TRUE;
}




/*** WriteTMPFile
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
WriteTMPFile (
    void
    )
{
    FILE    *fh;
    int     i, j;
    PFILE   pFileTmp;
    PINS    pInsTmp;

    if ((fh = pathopen (pNameTmp, buf, "wt")) == NULL) {
        return;
    }
    fprintf (fh, "%s %s\n", Name, Version);
    fprintf (fh, TMPVER"\n");
    fprintf (fh, "%d %d\n", XSIZE, YSIZE);

    /*
y	  * we truncate the search, src and rpl buffers back 10 characters each from the
     * maximum before writing them out. This avoids more major hacks in the code
     * which reads these lines back in, which limit the total line length to
     * BUFLEN.
     */
    srchbuf[sizeof(srcbuf)-10] = 0;
    srcbuf[sizeof(srcbuf)-10] = 0;
    rplbuf[sizeof(rplbuf)-10] = 0;
    fprintf (fh, "SRCH:");
    fprintf (fh, "%s", srchbuf);
    fprintf (fh, "\nSRC:");
    fprintf (fh, "%s", srcbuf);
    fprintf (fh, "\nDST:");
    fprintf (fh, "%s", rplbuf);

    fprintf (fh, "\nINS:%s\n", (fInsert)?"ON":"OFF");
    for (i = 0; i < cWin; i++) {
	if ((pInsTmp = WinList[i].pInstance) != NULL) {
	    fprintf (fh, "> %d %d %d %d\n", WinList[i].Pos.col, WinList[i].Pos.lin,
		     WinList[i].Size.col, WinList[i].Size.lin);
	    j = 0;
	    while (pInsTmp != NULL) {
		if (tmpsav && tmpsav == j)
		    break;
		pFileTmp = pInsTmp->pFile;
		if (!TESTFLAG (FLAGS (pFileTmp), FAKE | TEMP)) {
		    j++;
		    if (*whitescan(pFileTmp->pName) == '\0') {
			fprintf (fh, " %s %d %ld %d %ld\n", pFileTmp->pName,
				 XWIN(pInsTmp), YWIN(pInsTmp),
				 XCUR(pInsTmp), YCUR(pInsTmp));
		    } else {
			fprintf (fh, " \"%s\" %d %ld %d %ld\n", pFileTmp->pName,
				 XWIN(pInsTmp), YWIN(pInsTmp),
				 XCUR(pInsTmp), YCUR(pInsTmp));
		    }
                }
		pInsTmp = pInsTmp->pNext;
            }
	    /* empty window */
            if (j == 0) {
                fprintf (fh, " %s 0 0 0 0\n", rgchUntitled);
            }
            fprintf (fh, ".\n");
        }
    }
    fclose (fh);
}


flagType
savetmpfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
	argData; pArg; fMeta;

	WriteTMPFile();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\tab.c ===
/*** tab.c - perform tabification on output
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"



/*** TabMin - tabify buf, outside of strings
*
*  tabify buf in place and return length. Take into account " and ' chars
*  and remember escaping
*
* Input:
*  tab		= tab stops to entab to
*  src		= source buffer
*  dst		= destination buffer
*
* Output:
*  Returns physical length of buffer
*
*************************************************************************/
int
TabMin (
    int     tab,
    char    *src,
    char    *dst
    )
{
    int      column         = 0;            /* current column offset        */
    char     cQuote;                        /* character that began a quote */
    int      cSpaces;                       /* count of spaces in run       */
    flagType fEscape        = FALSE;        /* TRUE => processing escape    */
    flagType fQuote         = FALSE;        /* TRUE => processing quote     */
    REGISTER char *pDst     = dst;          /* moving ptr into dest         */
    REGISTER char *pSrc     = src;          /* moving ptr into source       */

    /*
     *  while there are characters to output
     */
    while (*pSrc) {

        /*
         *  if we are not quoting or escaping then we collect runs of spaces
         */
        if (!fQuote && !fEscape) {
            cSpaces = 0;

            /*
             * while there are spaces or tabs, collect runs thereof each time we have
             * advanced to a tab boundary output the tab and reset the count of spaces.
             */

            while ((*pSrc == ' ') || (*pSrc == '\t')) {
                if (*pSrc == '\t') {
                    cSpaces = 0;
                    column += tab - (column % tab);
                    *pDst++ = '\t';
                } else {
                    cSpaces++;
                    column++;
                    if ((column % tab) == 0) {
                        *pDst++ = (char)((cSpaces != 1) ? '\t' : ' ');
                        cSpaces = 0;
                    }
                }
                pSrc++;
            }

            /*
             * non-space found. Output remainder of spaces
             */
            while (cSpaces--) {
                *pDst++ = ' ';
            }
        }

        /*
         * determine what state we are in
         */
        if (!fQuote) {
            if (!fEscape) {

                /*
                 * if we are not quoting and we are not escaping, check for quoted strings and
                 * escaped characters.
                 */
                if (*pSrc == '"' || *pSrc == '\'') {
                    cQuote = *pSrc;
                    fQuote = TRUE;
                } else if (*pSrc == '\\') {
                    fEscape = TRUE;
                }
            } else {
                //
                //  We are not quoting. If we are escaping, reset escape.
                fEscape = FALSE;
            }
         } else if (!fEscape) {
            //
            //  In a quote, not escaping, check for end of quote, or
            //  beginning of escape
            //
            if (*pSrc == cQuote) {
                fQuote = FALSE;
            } else if (*pSrc == '\\') {
                fEscape = TRUE;
            }
         } else {
            //
            // Inside quote and inside escape, just reset escape mode
            //
            fEscape = FALSE;
        }

        /*
         * Finally, output the character
         */
        if (*pSrc) {
            *pDst++ = *pSrc++;
            column++;
        }
    }

    /*
     * terminate the destination string, and return
     */
    *pDst = 0;
    return (int)(pDst-dst);
}





/*** TabMax - tabify line regardless of content
*
* Input:
*  tab		= tab stops to entab to
*  src		= source buffer
*  dst		= destination buffer
*
* Output:
*  Returns physical length of buffer
*
*************************************************************************/
int
TabMax (
    int     tab,
    char    *src,
    char    *dst
    )
{

    int      column         = 0;            /* current column offset        */
    unsigned cSpaces;                       /* count of spaces in run       */
    REGISTER char *pDst     = dst;          /* moving ptr into dest         */
    REGISTER char *pSrc     = src;          /* moving ptr into source       */

    /*
     * while there are characters to output
     */
    while (*pSrc) {
        cSpaces = 0;

        /*
         * coallesce runs of spaces while there are spaces to coallesce
         */
        while ((*pSrc == ' ') || (*pSrc == '\t')) {
            if (*pSrc == '\t') {
                cSpaces = 0;
                column += tab - (column % tab);
                *pDst++ = '\t';
            } else {
                cSpaces++;
                column++;

                /*
                 * if we have advanced to a tab boundary output a tab & reset the count of
                 * spaces
                 */
                if ((column % tab) == 0) {
                    *pDst++ = (char)((cSpaces != 1) ? '\t' : ' ');
                    cSpaces = 0;
                }
            }
            pSrc++;
        }

        /*
         * output remainder of spaces
         */
        while (cSpaces--) {
            *pDst++ = ' ';
        }

        /*
         * Finally copy the character
         */
        if (*pSrc) {
            *pDst++ = *pSrc++;
            column++;
        }
    }

    *pDst = 0;
    return (int)(pDst-dst);
}




/*** SetTabDisp - tabdisp switch setting function
*
*  set character displayed for tabs to a new character
*
* Input:
*  Standard switch setting routine: ptr to string
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
SetTabDisp (
    char * val
    )
{
	char   NewVal;

	if ((NewVal = (char)atoi(val)) == 0) {
		NewVal = ' ';
	}

	tabDisp = NewVal;
	newscreen ();

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\setfile.c ===
/*  setfile.c - top-level file management commands
*
*   Modifications:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"


static char *NoAlternate = "no alternate file";


/*** setfile - editor command to change and save files
*
*  <setfile>			- set to previous file on instance list
*  <arg> text <setfile> 	- set to specified file
*  <arg> <setfile>		- set to file spacified at current cursor pos
*  <arg><arg> text <setfile>	- write current file to specified filename
*  <arg><arg> <setfile>		- write current file to disk
*  <meta> ...			- do not autosave current file on change
*
*   The following is undocumented:
*
*   <arg><arg> "text" <meta> <setfile> - Like <arg><arg><setfile>, but
*					 doesn't prompt for confirmation
*					 and switches to new file even
*					 for pseudo-files.
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
setfile (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    linebuf name; /* name to set to.  'linebuf', so fInsSpace can take it   */
    pathbuf path;
    char    *p = name;

    switch (pArg->argType) {

    case NOARG:
        if (pInsCur->pNext == NULL) {
            domessage( NoAlternate );
            return FALSE;
        }
        name[0] = 0;
        break;

    case TEXTARG:
        if (pArg->arg.textarg.cArg > 1) {
	    CanonFilename (pArg->arg.textarg.pText, path);
            /* The fMeta thing is a definite hack */
            if (fMeta || confirm("Do you want to save this file as %s ?", path)) {
                if (FileWrite (path, pFileHead)) {
                    if (!TESTFLAG (FLAGS(pFileHead), FAKE) || fMeta) {
                        FREE (pFileHead->pName);
                        pFileHead->pName = ZMakeStr (path);
                        RSETFLAG (FLAGS(pFileHead), (DIRTY | FAKE | TEMP));
			}
                    SETFLAG (fDisplay, RSTATUS);
                    SetModTime( pFileHead );
                    return TRUE;
		    }
		else
                    return FALSE;
		}
	    else {
                DoCancel();
                return FALSE;
		}
	    }
	else
	    findpath (pArg->arg.textarg.pText, name, TRUE);
        break;

    case NULLARG:
	if (pArg->arg.nullarg.cArg > 1)
            return (flagType)!FileWrite (NULL, pFileHead);

        fInsSpace (pArg->arg.nullarg.x, pArg->arg.nullarg.y, 0, pFileHead, name);
        p = pLog(name,pArg->arg.nullarg.x,TRUE);

	//
	//  Check to see if this a C file and it is an #include line
	//

	if ((FTYPE (pFileHead) == CFILE && strpre ("#include ", p)) ||
	    (FTYPE (pFileHead) == ASMFILE && strpre ("include", p))) {

	    //
	    //	skip the include directive
	    //

	    p = whitescan (p);
	    p = whiteskip (p);
	    }

        /*
         * Terminate filename at first whitespace
         */
        *whitescan (p) = 0;

        /*
         * If file is C, attempt to strip off #include delimiters if present
         */
        if (FTYPE (pFileHead) == CFILE) {
	    if (*p == '"')
                *strbscan (++p, "\"") = 0;
	    else
	    if (*p == '<') {
                *strbscan (++p, ">") = 0;
		sprintf (path, "$INCLUDE:%s", p);
		CanonFilename (path, p = name);
		}
	    else
                *strbscan (p, "\">") = 0;
	    }
	else {
            /*
             * If file is ASM, attempt to remove comment chars if present
             */
	    if (FTYPE (pFileHead) == ASMFILE)
                * strbscan (p, ";") = 0;
	    }

        break;
	}

    if (!fMeta)
        AutoSave ();

    if (name[0] == 0) {
        strcpy (name, pInsCur->pNext->pFile->pName);
    }

    return fChangeFile (TRUE, p);

    argData;
}




/*** refresh - re-read or discard file
*
*  <refresh>		- re-read current file
*  <arg> <refresh>	- remove current file from memory
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
refresh (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    EVTargs e;

    switch (pArg->argType) {
    case NOARG:
	if (confirm("Do you want to reread this file? ", NULL)) {
            /*
             * Offer to the extensions as an event
             */
	    e.pfile = pFileHead;
	    DeclareEvent (EVT_REFRESH,(EVTargs *)&e);

            /*
             * if assigns, force re-read
             */
            if (!strcmp (pFileHead->pName, rgchAssign)) {
                fNewassign = TRUE;
            }

	    FileRead (pFileHead->pName, pFileHead, TRUE);
	    RSETFLAG (FLAGS (pFileHead), DIRTY);
	    SETFLAG (fDisplay, RSTATUS);
	    return TRUE;
        }
	return FALSE;

    case NULLARG:
	if (pInsCur->pNext == NULL) {
	    domessage( NoAlternate );
	    return FALSE;
        }
        if (!confirm ("Do you want to delete this file from the current window? ", NULL)) {
            return FALSE;
        }

	RemoveTop ();

	newscreen ();

	while (pInsCur != NULL) {
            if (fChangeFile (FALSE, pFileHead->pName)) {
                return TRUE;
            }
        }
	return fChangeFile (FALSE, rgchUntitled);
    }

    return FALSE;
    argData; fMeta;
}




/*** noedit - Toggle no-edit flags
*
* Purpose:
*
*   To give the user control over the edit/no-edit state of the editor and
*   its files.	The editor has two flags controlling this:
*
*	Global no-edit	 => When flag is set, no file may be edited.
*	Per-file no-edit => When set, the given file cannot be edited
*
*   This function can be invoked as follows:
*
*	  <noedit>  Toggles global no-edit state.  When set, has same
*		    effect as /r switch.
*
*   <meta><noedit>  Toggles the per-file no-edit state for current file.
*
* Output:  Returns new state.  TRUE means no editing, FALSE means editing
*	   is allowed
*
* Notes:
*
*   This does not allow the user to change permissions on pseudo files.
*
*************************************************************************/
flagType
noedit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    SETFLAG (fDisplay, RSTATUS);

    if (!fMeta) {
        return fGlobalRO = (flagType)!fGlobalRO;
    }

    if (TESTFLAG (FLAGS(pFileHead), FAKE)) {
        return (flagType)(TESTFLAG(FLAGS(pFileHead), READONLY));
    }

    if (TESTFLAG (FLAGS(pFileHead), READONLY)) {
	RSETFLAG (FLAGS(pFileHead), READONLY);
	return FALSE;
    } else {
	SETFLAG (FLAGS(pFileHead), READONLY);
	return TRUE;
    }
    argData; pArg;
}





/*** saveall - Editor <saveall> function
*
* Purpose:
*   Saves all dirty files.
*
* Input:   The usual. Accepts only NOARG.
*
* Output:
*	   Returns always true.
*
*************************************************************************/
flagType
saveall (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    SaveAllFiles ();
    return TRUE;

    argData; pArg; fMeta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\replace.c ===
/*** replace.c - string replacement functions
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Repalces funnel through these routines as follows:
*
*	zreplace    mreplace	qreplace
*	     \         |	 /
*	      \        |	/
*	       \______ | ______/
*		      \|/
*		       v
*		   doreplace
*		       |
*		    (fScan)
*		       |
*		   fDoReplace
*		     /	 \
*		    /	  \
*		patRpl	simpleRpl (if a change is made)
*		    \ 	  /
*		     \   /
*		  ReplaceEdit
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/
#define NOVM
#include "mep.h"


static flagType       fQrpl   = FALSE;  /* TRUE => prompt for replacement     */
static struct patType *patBuf = NULL;	/* compiled pattern		      */
static int            srchlen;          /* length of textual search           */
static unsigned       MaxREStack;       /* Elements in RE stack               */
static RE_OPCODE      ** REStack;       /* Stack for REMatch                  */



/*** mreplace - multiple file search and replace
*
*  Perform a search and replace across multiple files. Acts like qreplace, in
*  that the first instance the user is always asked. he may then say "replace
*  all".
*
* Input:
*  Standard editting function.
*
* Output:
*  Returns TRUE on successfull replacement.
*
*************************************************************************/
flagType
mreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (TRUE, pArg, fMeta, TRUE);

    argData;
}



/*** zreplace & qreplace - perform search/replace
*
*  Editting functions which implement search & replace. qreplace prompts,
*  zreplace does not.
*
* Input:
*  Standard editting function parameters.
*
* Output:
*  Returns
*
*************************************************************************/
flagType
zreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (FALSE, pArg, fMeta, FALSE);

    argData;
}





flagType
qreplace (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    return doreplace (TRUE, pArg, fMeta, FALSE);

    argData;
}




/*** doreplace - perform search-replace
*
*  Performs the actual search and replace argument verification, set up and
*  high level control.
*
* Input:
*  fQuery	= TRUE if a query replace
*  pArg 	= pArg of parent function
*  fMeta	= fMeta of parent function
*  fFiles	= TRUE is multiple file search and replace.
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
doreplace (
    flagType fQuery,
    ARG * pArg,
    flagType fMeta,
    flagType fFiles
    )
{
    buffer  bufFn;                          /* filename buffer              */
    fl      flStart;
    char    *p;
    PCMD    pCmd;
    PFILE   pFileSave;                      /* file to save as top of heap  */

    p = "Query Search string: ";
    if (!fQuery) {
        p += 6;
    }

    fQrpl = fQuery;
    fSrchCasePrev = fMeta ? (flagType)!fSrchCaseSwit : fSrchCaseSwit;
    Display ();
    cRepl = 0;

    /*
     * If not menu-driven, ask the user for a search string. If none is entered,
     * we're done.
     */
    if ((pCmd = getstring (srcbuf, p, NULL, GS_NEWLINE | GS_INITIAL)) == NULL || (PVOID)pCmd->func == (PVOID)cancel) {
        return FALSE;
    }

    if (srcbuf[0] == '\0') {
        return FALSE;
    }

    /*
     * If RE search to take place, the compile the expression.
     */
    if (pArg->arg.nullarg.cArg == 2) {
	if (patBuf != NULL) {
            FREE ((char *) patBuf);
	    patBuf = NULL;
        }
	patBuf = RECompile (srcbuf, fSrchCaseSwit, (flagType)!fUnixRE);
	if (patBuf == NULL) {
	    printerror ((RESize == -1) ?
			"Invalid pattern" :
			"Not enough memory for pattern");
	    return FALSE;
        }
	fRplRePrev = TRUE;
    } else {
        fRplRePrev = FALSE;
    }

    /*
     * If not menu driven, ask the user for a replacement string. Confirm the
     * entry of a null string. Error check the replacement if an RE search.
     */
    if ((pCmd = getstring (rplbuf, "Replace string: ", NULL, GS_NEWLINE | GS_INITIAL)) == NULL ||
        (PVOID)pCmd->func == (PVOID)cancel) {
        return FALSE;
    }

    if (rplbuf[0] == 0) {
        if (!confirm ("Empty replacement string, confirm: ", NULL)) {
            return FALSE;
        }
    }

    if (fRplRePrev && !RETranslate (patBuf, rplbuf, scanreal)) {
	printerror ("Invalid replacement pattern");
	return FALSE;
    }

    srchlen = strlen (srcbuf);

    switch (pArg->argType) {

    case NOARG:
    case NULLARG:
	setAllScan (TRUE);
        break;

    case LINEARG:
	rnScan.flFirst.col = 0;
        rnScan.flLast.col  = sizeof(linebuf)-1;
	rnScan.flFirst.lin = pArg->arg.linearg.yStart;
        rnScan.flLast.lin  = pArg->arg.linearg.yEnd;
        break;

    case BOXARG:
	rnScan.flFirst.col = pArg->arg.boxarg.xLeft;
        rnScan.flLast.col  = pArg->arg.boxarg.xRight;
	rnScan.flFirst.lin = pArg->arg.boxarg.yTop;
        rnScan.flLast.lin  = pArg->arg.boxarg.yBottom;
        break;

    case STREAMARG:
	if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
	    rnScan.flFirst.col = pArg->arg.streamarg.xStart;
            rnScan.flLast.col  = pArg->arg.streamarg.xEnd;
	    rnScan.flFirst.lin = pArg->arg.streamarg.yStart;
            rnScan.flLast.lin  = pArg->arg.streamarg.yEnd;
        } else {
	    rnScan.flFirst.col = 0;   /* Do all but last line first */
            rnScan.flLast.col  = sizeof(linebuf)-1;
	    rnScan.flFirst.lin = pArg->arg.streamarg.yStart;
            rnScan.flLast.lin  = pArg->arg.streamarg.yEnd - 1;
	    flStart.col = pArg->arg.streamarg.xStart - 1;
	    flStart.lin = rnScan.flFirst.lin;
	    fScan (flStart, fDoReplace , TRUE, fSrchWrapSwit);

            rnScan.flLast.col   = pArg->arg.streamarg.xEnd;
	    rnScan.flFirst.lin	= ++rnScan.flLast.lin;
        }
    }

    flStart.col = rnScan.flFirst.col-1;
    flStart.lin = rnScan.flFirst.lin;
    if (fRplRePrev) {
	MaxREStack = 512;
        REStack = (RE_OPCODE **)ZEROMALLOC (MaxREStack * sizeof(*REStack));
    }

    if (fFiles) {
        /*
         * Get the list handle, and initialize to start at the head of the list.
         * Attempt to read each file.
         */
	if (pCmd = GetListHandle ("mgreplist", TRUE)) {
	    pFileSave = pFileHead;
	    p = ScanList (pCmd, TRUE);
	    while (p) {
		CanonFilename (p, bufFn);
		forfile (bufFn, A_ALL, mrepl1file, &p);
		p = ScanList (NULL, TRUE);
                if (fCtrlc) {
                    return FALSE;
                }
            }
	    pFileToTop (pFileSave);
            dispmsg (0);
        }
    } else {
        fScan (flStart, fDoReplace , TRUE, fSrchWrapSwit);
    }

    if (fRplRePrev) {
        FREE (REStack);
    }
    domessage ("%d occurrences replaced", cRepl);
    return (flagType)(cRepl != 0);
}




/*** mrepl1file - search/replace the contents of 1 file.
*
*  Searches through one file for stuff.
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
mrepl1file (
    char   *szGrepFile,
    struct findType *pfbuf,
    void *dummy
    )
{
    flagType fDiscard;                      /* discard the file read?       */
    fl      flGrep;                         /* ptr to current grep loc      */
    int     cReplBefore;                    /* number of matches before     */
    PFILE   pFileGrep;                      /* file to be grepped           */

    assert (szGrepFile);
    assert (_pinschk(pInsCur));

    if (fCtrlc) {
        return;
    }

    /*
     * If we can get a handle to the file, then it's alread in the list, and we
     * should not discard it when done. If it is not in the list, we read it in,
     * but we'll discard it, unless something is found there.
     */
    if (!(pFileGrep = FileNameToHandle (szGrepFile, szGrepFile))) {
        pFileGrep = AddFile (szGrepFile);
        SETFLAG (FLAGS (pFileGrep), REFRESH);
        fDiscard = TRUE;
    } else {
        fDiscard = FALSE;
    }

    assert (_pinschk(pInsCur));

    /*
     * If the file needs to be physically read, do so.
     */
    if ((FLAGS (pFileGrep) & (REFRESH | REAL)) != REAL) {
        FileRead (pFileGrep->pName, pFileGrep, FALSE);
        RSETFLAG (FLAGS(pFileGrep), REFRESH);
    }

    dispmsg (MSG_SCANFILE, szGrepFile);
    pFileToTop (pFileGrep);

    /*
     * run through the file, searching and replacing as we go.
     */
    cReplBefore = cRepl;
    setAllScan (FALSE);
    flGrep.col = rnScan.flFirst.col-1;
    flGrep.lin = rnScan.flFirst.lin;
    fScan (flGrep, fDoReplace, TRUE, FALSE);
    /*
     * If the search was not successfull, discard the file, if needed, and move
     * to the next.
     */
    if (cReplBefore == cRepl) {
        if (fDiscard) {
            RemoveFile (pFileGrep);
        }
    } else {
        AutoSaveFile (pFileGrep);
    }

    assert (_pinschk(pInsCur));

    pfbuf; dummy;

}




/*** fDoReplace - called by fScan as file is scanned.
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
fDoReplace (
    void
    )
{
    int  c;
    char *p = pLog (scanreal, flScan.col, TRUE);

    if (fRplRePrev) {
	int rem;
	flagType fAgain = TRUE;

        do {
	    switch (rem = REMatch (patBuf, scanreal, p, REStack, MaxREStack, TRUE)) {
		case REM_NOMATCH:
		    flScan.col = scanlen;
		    return FALSE;

		case REM_STKOVR:
		    MaxREStack += 128;
                    REStack = (RE_OPCODE **)ZEROREALLOC ((char *)REStack, MaxREStack * sizeof(*REStack));
		    break;

		default:
		    printerror ("Internal Error: RE error %d, line %ld", rem, flScan.lin);

		case REM_MATCH:
		    fAgain = FALSE;
		    break;
            }
        } while (fAgain);

	c = colPhys (scanreal, REStart (patBuf));
	srchlen = RELength (patBuf, 0);
        if (c + srchlen - 1 > scanlen) {
            return FALSE;
        }
	flScan.col = c;
    } else {
        if ( (*(fSrchCasePrev ? strncmp : _strnicmp)) (srcbuf, p, srchlen)) {
            return FALSE;
        }
        if (flScan.col + srchlen - 1 > scanlen) {
            return FALSE;
        }
    }

    if (fQrpl) {
    ClearHiLite (pFileHead, TRUE);
    Display();
	cursorfl (flScan);
	HighLight (flScan.col, flScan.lin, flScan.col+srchlen-1, flScan.lin);
	Display ();
        c = askuser ('n', 'a', "Replace this occurrence? (Yes/No/All/Quit): ",
			  NULL);
	ClearHiLite (pFileHead, TRUE);
	redraw (pFileHead, flScan.lin, flScan.lin);
        RSETFLAG (fDisplay, RHIGH);

        switch (c) {

	case -1:
	case 'q':
	    fCtrlc = TRUE;
            return TRUE;

	case 'n':
            return FALSE;

	case 'a':
	    dispmsg(0); 		/* clear dialog line		*/
	    fQrpl = FALSE;
	    break;
        }
    }

    if (fRplRePrev) {
	patRpl ();
    } else {
        simpleRpl (p);
    }
    return FALSE;
}





/*** simpleRpl & patRpl - perform textual replacement
*
* Purpose:
*
* Input:
*
* Output:
*  Returns .....
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
simpleRpl (
    char *p
    )
{
    ReplaceEdit (p, rplbuf);
}





void
patRpl (
    void
    )
{
    buffer txt;

    RETranslate (patBuf, rplbuf, txt);
    ReplaceEdit (REStart (patBuf), txt);
}





/*** ReplaceEdit - perform replacement in a line of text
*
* Purpose:
*
* Input:
*  p		= pointer to beginning of match within scanreal
*  rpl		= text of replacement
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
ReplaceEdit (
    char *p,
    char *rpl
    )
{
    int c;                      /*  length of replacement string              */

    /*	if the len of line - len of search + len of replacement string < BUFLEN
     *	then we can make the replacement.  Otherwise we flag an error and
     *	advance to the next line
     */
    c = strlen (rpl);
    if (cbLog (scanreal) + c - srchlen < sizeof(linebuf)) {
	/*  open up a space in the buffer at the spot where the string was
	 *  found.  Move the characters starting at the END of the match to
	 *  the point after where the END of the replacement is.
	 */
	memmove ((char*) &p[c], (char *) &p[srchlen], sizeof(linebuf) - flScan.col - c);
	memmove ((char *) p, (char *) rpl, c);
        PutLine (flScan.lin, scanreal, pFileHead);

	/*  if search length != 0 or replace length != 0, skip over replacement */
        if (srchlen != 0 || c != 0) {
            flScan.col += c - 1;
        }

        //
        // Adjust scan len to account for the fact that the end of the region being
        // scanned may have moved as a result of the replacement. Adjust by the
        // replacement difference, and bound by 0 and the length of the line.
        //
	scanlen = max (0, min (scanlen + c - srchlen, cbLog(scanreal)));
	cRepl++;
    } else {
	printerror ("line %ld too long; replacement skipped", flScan.lin+1);
	flScan.col = scanlen;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\table.c ===
/***  table.c - function tables for editor
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip off near/far
*
*  IMPORTANT:  cmdTable and swiTable MUST be sorted according to name of the
*  command/switch.  The table searching logic in ASSIGN.C will break otherwise.
*
*  IMPORTANT:  The names in cmdTable and SwiTable MUST be in lower case.
*************************************************************************/

#include "mep.h"


// #define toPIF(x)  (PIF)(long)(void *)&x

/*  short form to allow compact table description
 */
#define ANO     NOARG
#define ATXT    TEXTARG
#define ANUL    NULLARG
#define ALIN    LINEARG
#define ASTR    STREAMARG
#define ABOX    BOXARG
#define ANUM    NUMARG
#define AMRK    MARKARG

#define AEOL    NULLEOL
#define AEOW    NULLEOW
#define ABST    BOXSTR
#define FK	FASTKEY

#define MD      MODIFIES
#define KM      KEEPMETA
#define WFN     WINDOWFUNC
#define CFN     CURSORFUNC

/*  names of internal editor functions
 *
 *  Each function has a definition of how arguments are to be processed.
 *  This definition is comprised of a bitmap describing which arguments are
 *  legal and, if so, how they are to be interpreted.  The definitions are:
 *
 *
 *  MODIFIES    MD      The function will modify the contents of the file being
 *                      editted.
 *
 *  KEEPMETA    KM      The function being executed does not take the <meta>
 *                      prefix.  The state of the <meta> flag is preserved
 *                      across this editor function.
 *
 *  CURSORFUNC  CFN     The function being executed is a cursor movement
 *                      function.  It is allowed within the context of
 *                      an <arg> to select a file range on the screen; it
 *                      cannot take an <arg>.  It does not remove highlighting
 *                      that is present on the screen.
 *
 *  WINDOWFUNC  WFN     The function being executed is a window movement
 *                      function.  It does not remove highlighting that is
 *                      present on the screen.
 *
 *  NOARG       ANO     The function accepts the absence of an <arg> function.
 *                      When called the function receives a pointer to a
 *                      structure containing the location where the function
 *                      is expected to be applied.
 *
 *  TEXTARG     ATXT    The function accepts a textual argument that may
 *                      be typed in or selected on the screen.  The function is
 *			called with a pointer to the asciz text of the
 *                      argument.  See NULLEOL, NULLEOW, BOXSTR.
 *
 *  NULLARG     ANUL    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      containing the location of the arg within the file.
 *
 *  NULLEOL     AEOL    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      indicating TEXTARG and containing a pointer to the
 *                      asciz text of the line from the cursor to end-of-line.
 *
 *  NULLEOW     AEOW    The function accepts an <arg> with no discernable
 *                      cursor movement (cursor is on <arg> position).  The
 *                      function is called with a pointer to a structure
 *                      indicating TEXTARG and containing a pointer to the
 *                      asciz text of the line from the cursor to the next
 *                      whitespace.
 *
 *  LINEARG     ALIN    The function accepts an <arg> that is in the same
 *                      column as the cursor.  The function is expected to be
 *                      applied to all lines beginning in the range <arg> to
 *                      cursor inclusive.  The function is called with a
 *                      pointer to a structure containing the beginning
 *                      line of the range and the ending line of the range
 *
 *  STREAMARG   ASTR    The function accepts an <arg> that is considered to
 *                      apply beginning at a specific file location and
 *                      proceeding through all intervening lines and line-
 *                      breaks up until just to the left of the ending file
 *                      position.  The function is called with a pointer to
 *                      a structure containing the beginning point of the range
 *                      and the first point just beyond the end of the range.
 *
 *  BOXARG      ABOX    The function accepts an <arg> that is considered to
 *                      apply to a rectangle on the screen.  The function is
 *                      called with a pointer to a structure containing the
 *                      left and right column boundaries (inclusive) and the
 *                      top and bottom line numbers (inclusive) that describe
 *                      the region.
 *
 *  BOXSTR      ABST    If a BOXARG is presented to the function and the box
 *                      contains only a single line, the function is called
 *                      with a pointer to a structure marked TEXTARG and
 *			containing a pointer to the selection as an asciz
 *                      string.
 *
 *  NUMARG      ANUM    If text was specified and is numeric, it is considered
 *                      to represent a number of lines offset from the cursor
 *                      and represents the other end of an arg.  The
 *                      above tests are then applied, excluding TEXTARG.
 *
 *  MARKARG     AMRK    If text was specified and interpreted as a mark, it is
 *                      considered to be the other end of an arg.  The above
 *			tests are then applied, excluding TEXTARG.
 *
 *  FASTKEY	FK	The command will be repeated while the user holds down
 *			the invoking key.
 */

struct cmdDesc cmdTable[] = {
/*			     0|KM|CFN|WFN|ANO|ATXT|ANUL|AEOL|AEOW|ALIN|ASTR|ABOX|ABST|ANUM|AMRK|MD|FK*/
{"arg",        doarg,	   0,0|KM								     },
{"assign",     assign,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN	   |ABOX|ABST|ANUM|AMRK      },
{"backtab",    backtab,    0,0	 |CFN								     },
{"begfile",    begfile,    0,0	 |CFN								     },
{"begline",    begline,    0,0	 |CFN								     },
{"boxstream",  BoxStream,  0,0	 |CFN								     },
{"cancel",     cancel,	   0,0		 |ANO|ATXT|ANUL 	 |ALIN|ASTR|ABOX		     },
{"cdelete",    cdelete,    0,0	 |CFN							       |MD   },
{"compile",    compile,    0,0		 |ANO|ATXT|ANUL 			|ABST		     },
{"copy",       zpick,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN|ASTR|ABOX     |ANUM|AMRK      },
{"curdate",    curdate,    0,0		 |ANO						       |MD   },
{"curday",     curday,	   0,0		 |ANO						       |MD   },
{"curtime",    curtime,    0,0		 |ANO						       |MD   },
{"delete",     delete,     0,0           |ANO     |ANUL           |ALIN|ASTR|ABOX              |MD   },
{"down",       down,	   0,0	 |CFN								  |FK},
{"emacscdel",  emacscdel,  0,0		 |ANO						       |MD   },
{"emacsnewl",  emacsnewl,  0,0		 |ANO						       |MD   },
{"endfile",    endfile,    0,0	 |CFN								     },
{"endline",    endline,    0,0	 |CFN								     },
{"environment",environment,0,0		 |ANO|ATXT|ANUL 	 |ALIN	   |ABOX		     },
{"execute",    zexecute,   0,0		     |ATXT     |AEOL	 |ALIN		|ABST|ANUM	     },
{"exit",       zexit,	   0,0		 |ANO	  |ANUL 					     },
{"graphic",    graphic,    0,0		 |ANO			 |ALIN|ASTR|ABOX		    |MD   },
{"home",       home,	   0,0	 |CFN								     },
{"information",information,0,0		 |ANO							     },
{"initialize", zinit,	   0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"insert",     insert,	   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"insertmode", insertmode, 0,0		 |ANO							     },
{"lastselect", lastselect, 0,0|KM	 |ANO							     },
{"lasttext",   lasttext,   0,0|KM	 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX		     },
{"ldelete",    ldelete,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"left",       left,	   0,0	 |CFN								  |FK},
{"linsert",    linsert,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"mark",       mark,	   0,0		 |ANO|ATXT|ANUL 			|ABST		     },
{"message",    zmessage,   0,0           |ANO|ATXT|ANUL          |ALIN|ASTR|ABOX                     },
{"meta",       meta,	   0,0|KM								     },
{"mgrep",      mgrep,	   0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"mlines",     mlines,	   0,0	     |WFN|ANO|ATXT|ANUL 					  |FK},
{"mpage",      mpage,	   0,0	 |CFN								  |FK},
{"mpara",      mpara,	   0,0	 |CFN								  |FK},
{"mreplace",   mreplace,   0,0		 |ANO	  |ANUL 				       |MD   },
{"msearch",    msearch,    0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"mword",      mword,	   0,0	 |CFN								  |FK},
{"newline",    newline,    0,0	 |CFN								     },
{"nextmsg",    nextmsg,    0,0		 |ANO|ATXT|ANUL 					     },
{"noedit",     noedit,	   0,0	 |CFN								     },
{"noop",		noop,	   0,0		 |ANO			 |ALIN|ASTR|ABOX			|MD   },
{"paste",      put,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN|ASTR|ABOX		|MD   },
{"pbal",       pbal,	   0,0		 |ANO	  |ANUL 				       |MD   },
{"plines",     plines,	   0,0	     |WFN|ANO|ATXT|ANUL 					  |FK},
{"ppage",      ppage,	   0,0	 |CFN								  |FK},
{"ppara",      ppara,	   0,0	 |CFN								  |FK},
{"print",      zPrint,	   0,0		 |ANO|ATXT		 |ALIN|ASTR|ABOX		     },
{"prompt",     promptarg,  0,0|KM	 |ANO|ATXT		 |ALIN|ASTR|ABOX		     },
{"psearch",    psearch,    0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"pword",      pword,	   0,0	 |CFN								  |FK},
{"qreplace",   qreplace,   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"quote",      quote,	   0,0		 |ANO			 |ALIN|ASTR|ABOX	       |MD   },
{"record",     record,	   0,0		 |ANO|ATXT|ANUL 					     },
{"refresh",    refresh,    0,0		 |ANO	  |ANUL 					     },
{"repeat",     repeat,	   0,0		 |ANO							     },
{"replace",    zreplace,   0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX     |ANUM|AMRK|MD   },
{"restcur",    restcur,    0,0           |ANO                                                        },
{"right",      right,	   0,0	 |CFN								  |FK},
{"saveall",    saveall,    0,0		 |ANO							     },
{"savecur",    savecur,    0,0		 |ANO							     },
{"savetmpfile",	savetmpfile,	0,0		 |ANO								 },
{"sdelete",    sdelete,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"searchall",  searchall,  0,0		 |ANO|ATXT	    |AEOW		|ABST		     },
{"setfile",    setfile,    0,0           |ANO|ATXT|ANUL                         |ABST                },
{"setwindow",  setwindow,  0,0		 |ANO	  |ANUL 					     },
{"shell",      zspawn,	   0,0		 |ANO|ATXT     |AEOL	 |ALIN	   |ABOX		     },
{"sinsert",    sinsert,    0,0		 |ANO	  |ANUL 	 |ALIN|ASTR|ABOX	       |MD   },
{"tab",        tab,	   0,0	 |CFN								     },
{"tell",       ztell,	   0,0		 |ANO|ATXT|ANUL 					     },
{"unassigned", unassigned, 0,0		 |ANO|ATXT|ANUL 	 |ALIN|ASTR|ABOX		     },
{"undo",       zundo,	   0,0		 |ANO							     },
{"up",	       up,	   0,0	 |CFN								  |FK},
{"window",     window,     0,0           |ANO     |ANUL                                              },
{NULL,         NULL,       0,0                                                                       }
    };



/* names of switches */
struct swiDesc swiTable[] = {
    {   "askexit",          toPIF(fAskExit),            SWI_BOOLEAN },
    {   "askrtn",           toPIF(fAskRtn),             SWI_BOOLEAN },
    {   "autosave",         toPIF(fAutoSave),           SWI_BOOLEAN },
    {	"backup",	    (PIF)SetBackup,		SWI_SPECIAL2 },
	{	"case", 		toPIF(fSrchCaseSwit),	SWI_BOOLEAN },
	{	"cursorsize",		(PIF)SetCursorSizeSw,		SWI_SPECIAL2 },
#if DEBUG
    {   "debug",            toPIF(debug),               SWI_NUMERIC  | RADIX10},
#endif
    {   "displaycursor",    toPIF(fDisplayCursorLoc),   SWI_BOOLEAN },
    {	"editreadonly",     toPIF(fEditRO),		SWI_BOOLEAN },
    {   "entab",            toPIF(EnTab),               SWI_NUMERIC  | RADIX10},
    {	"enterboxmode",     toPIF(fBoxArg),		SWI_BOOLEAN },
    {   "enterinsmode",     toPIF(fInsert),             SWI_BOOLEAN },
    {   "errcolor",         toPIF(errColor),            SWI_NUMERIC  | RADIX16},
    {	"errprompt",	    toPIF(fErrPrompt),		SWI_BOOLEAN },
    {	"extmake",	    (PIF)SetExt,		SWI_SPECIAL2 },
    {   "fgcolor",          toPIF(fgColor),             SWI_NUMERIC  | RADIX16},
    {	"filetab",	    (PIF)SetFileTab,		SWI_SPECIAL2 },
    {	"height",	    toPIF(YSIZE),		SWI_SCREEN  },
    {   "hgcolor",          toPIF(hgColor),             SWI_NUMERIC  | RADIX16},
    {   "hike",             toPIF(hike),                SWI_NUMERIC  | RADIX10},
    {   "hscroll",          toPIF(hscroll),             SWI_NUMERIC  | RADIX10},
    {   "infcolor",         toPIF(infColor),            SWI_NUMERIC  | RADIX16},
    {	"keyboard",	    (PIF)SetKeyboard,		SWI_SPECIAL },
    {	"load", 	    (PIF)SetLoad,		SWI_SPECIAL2 },
    {	"markfile",	    (PIF)SetMarkFile,		SWI_SPECIAL2 },
    {	"msgflush",	    toPIF(fMsgflush),		SWI_BOOLEAN },
    {   "noise",            toPIF(cNoise),              SWI_NUMERIC  | RADIX10},
    {	"printcmd",	    SetPrintCmd,		SWI_SPECIAL },
    {   "readonly",         SetROnly,                   SWI_SPECIAL },
    {	"realtabs",	    toPIF(fRealTabs),		SWI_BOOLEAN },
    {   "rmargin",          toPIF(xMargin),             SWI_NUMERIC  | RADIX10},
    {   "savescreen",       toPIF(fSaveScreen),         SWI_BOOLEAN },
    {	"searchwrap",	    toPIF(fSrchWrapSwit),	SWI_BOOLEAN },
    {	"selcolor",	    toPIF(selColor),		SWI_NUMERIC  | RADIX16},
    {   "shortnames",       toPIF(fShortNames),         SWI_BOOLEAN },
    {   "snow",             toPIF(fCgaSnow),            SWI_BOOLEAN },
    {   "softcr",           toPIF(fSoftCR),             SWI_BOOLEAN },
    {   "stacolor",         toPIF(staColor),            SWI_NUMERIC  | RADIX16},
    {	"tabalign",	    toPIF(fTabAlign),		SWI_BOOLEAN },
    {	"tabdisp",	    SetTabDisp, 		SWI_SPECIAL },
    {   "tabstops",         toPIF(tabstops),            SWI_NUMERIC  | RADIX10},
    {   "tmpsav",           toPIF(tmpsav),              SWI_NUMERIC  | RADIX10},
    {   "traildisp",        SetTrailDisp,               SWI_SPECIAL },
    {   "trailspace",       toPIF(fTrailSpace),         SWI_BOOLEAN },
    {	"undelcount",	    toPIF(cUndelCount), 	SWI_NUMERIC  | RADIX10},
    {   "undocount",        toPIF(cUndo),               SWI_NUMERIC  | RADIX10},
    {   "unixre",           toPIF(fUnixRE),             SWI_BOOLEAN },
    {   "usemouse",         toPIF(fUseMouse),           SWI_BOOLEAN },
    {   "viewonly",         toPIF(fGlobalRO),           SWI_BOOLEAN },
    {   "vscroll",          toPIF(vscroll),             SWI_NUMERIC  | RADIX10},
    {	"wdcolor",	    toPIF(wdColor),		SWI_NUMERIC  | RADIX16},
    {	"width",	    toPIF(XSIZE),		SWI_SCREEN  },
    {   "wordwrap",         toPIF(fWordWrap),           SWI_BOOLEAN },
    {   NULL,               NULL,                       0 }
    };
/* c keyword table for softcr routine */
char * cftab[] = {
    "if"        ,
    "else"      ,
    "for"       ,
    "while"     ,
    "do"        ,
    "case"      ,
    "default"   ,
    NULL
    };

/* file type table.  Z identifies files by their extention.  Many extentions
 * can be a single type.  The soft tabbing algorithms and the compile commands
 * are driven by this mechanism.
 */
struct fTypeInfo ftypetbl[] = {
    {   "c",    CFILE       },
    {   "h",    CFILE       },
    {   "asm",  ASMFILE     },
    {   "inc",  ASMFILE     },
    {   "pas",  PASFILE     },
    {   "for",  FORFILE     },
    {   "lsp",  LSPFILE     },
    {   "bas",  BASFILE     },
    {   NULL,   TEXTFILE    }
    };

/*  mpTypepName - pointers to the textual names of each type
 */
char * mpTypepName[] =
    {   "text",                         /*  #define TEXTFILE    0             */
        "C",                            /*  #define CFILE       1             */
        "macro",                        /*  #define ASMFILE     2             */
        "pascal",                       /*  #define PASFILE     3             */
        "fortran",                      /*  #define FORFILE     4             */
        "lisp",                         /*  #define LSPFILE     5             */
        "BASIC"                         /*  #define BASFILE     6             */
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\textline.c ===
/*** textline.c - basic line manipulators for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Edit-level to file-level interface.
*
*   The internal representation of a file is that of an array of line records
*   with each line record containing a pointer to the text of the line and a
*   length of that line. The line array is pointed to by the plr field of
*   the file descriptor. The lSize field is the MAXIMUM number of lines that
*   the line array can hold and the cLines is the number of lines actually
*   present. Here are some assumptions:
*
*    plr = NULL => no line array allocated
*    lineRec.vaLine = -1L => 0-length line
*
*   Tabs: functions and characters.
*
*   The tab function is a cursor movement command, and responds to the
*   "tabstops" editor switch. It has NO RELATIONSHIP to physical tab
*   characters, and how tab characters are treated or placed in the text file.
*
*   Tab characters, their interpretation and placement in editted text, is
*   controlled by three switchs:
*
*     Switch	  Editor Var	  Meaning
*     ----------- --------------- -------
*     filetab:
*     entab:
*     realtabs:   fRealTabs	  TRUE	=>  Tab  characters are NOT treated as
*				  runs	of  spaces for editting purposes. They
*				  are	defined   as   having  variable  (1-8)
*				  multi-column width.
*				  FALSE => Tabs characters in text are treated
*				  as runs of spaces.
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip near/far
*************************************************************************/
#include "mep.h"
#include <stdarg.h>

#define DELTA 400

//
//	BugBug Compiler asserts generating intrinsic code for memset
//
#pragma function( memset )

/*** LineLength - returns length of a specific line
*
* Input:
*  line 	= 0-based line number in file
*  pFile	= pointer to file
*
* Output:
*  Returns the logical number of characters, after tab expansion
*
*************************************************************************/
int
LineLength (
    LINE    line,
    PFILE   pFile
    )
{
    linebuf tmpbuf;

    return GetLineUntabed (line, tmpbuf, pFile);
}




/*** GetLine - gets a line into a particular buffer.
*
* If "fReal-Tabs" is NOT set, the line has all tabs expanded into spaces.
* No CR/LF is present.
*
* Input:
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
GetLine (
    LINE    line,
    char    *buf,
    PFILE   pFile
    )
{
    return gettextline (fRealTabs, line, buf, pFile, ' ');
}





/*** GetLineUntabed - gets a line into a particular buffer, always untabed.
*
* The line has all tabs expanded into spaces.
* No CR/LF is present.
*
* Input:
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
GetLineUntabed (
    LINE    line,
    char    *buf,
    PFILE   pFile
    )
{
    return gettextline (FALSE, line, buf, pFile, ' ');
}





/****************************************************************************
 *									    *
 *  GetColor (line, buf, pFile) 					    *
 *									    *
 *	line - 0-based line number in file to get color info for.	    *
 *	buf  - Place to put copy of line color info.			    *
 *	pFile- File to retrieve info from.				    *
 *									    *
 *  RETURNS:								    *
 *									    *
 *	TRUE if there is color attached to this line, FALSE otherwise.	    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Gets the color array associated with given line in the given file.  *
 *	The color array can be used by the cout routines to display the     *
 *	line in different colors.					    *
 *									    *
 ****************************************************************************/
flagType
GetColor (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    return (flagType)getcolorline (fRealTabs, line, buf, pFile);
}




/*** GetColorUntabbed - Get color with "untabbing"
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
GetColorUntabbed (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    return (flagType)getcolorline (FALSE, line, buf, pFile);
}



/*** getcolorline
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
int
getcolorline (
    flagType fRaw,
    LINE     line,
    struct   lineAttr * buf,
    PFILE    pFile
    )
{
    struct colorRecType *vColor;
    linebuf lbuf;

    //
    // Set default colors, in case there is no color for this line.
    //
    buf->len = 0xff;
    buf->attr = FGCOLOR;

    if ((pFile->vaColor == (PVOID)(-1L)) || (line >= pFile->cLines)) {
        return FALSE;
    }

    vColor = VACOLOR(line);

    if (vColor->vaColors == (PVOID)(-1L)) {
        return FALSE;
    }

    memmove((char *)buf, vColor->vaColors, vColor->cbColors);

    if (!fRaw) {
        if (gettextline (TRUE, line, lbuf, pFile, ' ')) {
            ColorToLog (buf, lbuf);
        }
    }

    return TRUE;
}






/****************************************************************************
 *									    *
 *  PutColor (line, buf, pFile) 					    *
 *									    *
 *	line - 0-based line number in file to attach color to.		    *
 *	buf  - Color array.						    *
 *	pFile- File to attach to.					    *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Copies the contents of buf into VM space and attaches it to the     *
 *	given line.  If no colorRecType array exists, one is allocated.     *
 *	If color for the given line already exists, it is discarded.	    *
 *									    *
 ****************************************************************************/
void
PutColor (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    putcolorline (FALSE, line, buf, pFile);
}





/*** PutColorPhys
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
PutColorPhys (
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
    putcolorline (TRUE, line, buf, pFile);
}




/*** putcolorline
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
putcolorline (
    flagType fRaw,
    LINE line,
    struct lineAttr * buf,
    PFILE pFile
    )
{
	struct colorRecType vColor;
	struct colorRecType *Color;
    int     cbBuf;
    long    l;
    PBYTE    vaColor;

    //
    // Ignore color for lines which don't exist.
    //
    if (line >= pFile->cLines) {
        return;
    }

    //
    // Make sure we have a color array. If it doesn't exist, allocate one for the
    // number of lines we have so far. Initialize the entries therein to no color.
    //
    redraw (pFile, line, line);
    if (pFile->vaColor == (PVOID)(-1L)) {
        pFile->vaColor  = MALLOC (pFile->lSize * sizeof(vColor));
        if ( !pFile->vaColor ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        vColor.vaColors = (PVOID)(-1L);
	vColor.cbColors = 0;
        vaColor = (PBYTE)pFile->vaColor;
	for (l=0; l<pFile->lSize; l++) {
            memmove(vaColor, (char *)&vColor, sizeof(vColor));
	    vaColor += sizeof (vColor);
        }
    }

    //
    // Now throw away the current color info for the line in question, allocate
    // new VM for the new information, then place the color info into VM, and
    // update the VA info in the color array.
	//
	Color = VACOLOR(line);
	if (Color->vaColors != (PVOID)(-1L)) {
		FREE (Color->vaColors);
    }
    if (!fRaw) {
        ColorToPhys (buf, line, pFile);
    }
    cbBuf = fcolcpy (NULL, (struct lineAttr *)buf) << 2;
    Color->vaColors = MALLOC ((long)cbBuf);
    if ( !Color->vaColors ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }
	Color->cbColors = cbBuf;
	memmove(Color->vaColors,	(char *)buf, cbBuf);
}





/*** DelColor - Remove color from a line
*
* Purpose:
*
*   To free the color attached to a file line.
*
* Input:
*   line -  Line to free
*   pFile-  File with the color
*
* Output: None
*
*************************************************************************/
void
DelColor (
    LINE line,
    PFILE pFile
    )
{
    struct colorRecType *vColor;

    if (pFile->vaColor != (PVOID)-1L) {

        vColor = VACOLOR(line);
        if (vColor->vaColors != (PVOID)-1L) {
            FREE(vColor->vaColors);
            vColor->vaColors = (PVOID)-1L;
	}
    }
}





/*** gettextline - gets a line into a particular buffer.
*
* Input:
*  fRaw 	= TRUE => the line is returned unmodified, otherwise tabs are
*		  expanded according to fileTab.
*  line 	= 0-based line number in file to return.  Lines beyond EOF
*		  are simply empty.
*  buf		= destination of line.
*  pFile	= pointer to the file structure from which the line is to be
*		  retrieved.
*  bTab 	= character used for tab expansion
*
* Output:
*  Returns the number of characters in the line.
*
*************************************************************************/
int
gettextline (
    flagType fRaw,
    LINE    line,
    char    *buf,
    PFILE   pFile,
    char    bTab
    )
{
    LINEREC *vLine;
    linebuf getbuf;
    REGISTER char *p = fRaw ? buf : getbuf;
    int     cbLine;

    if (pFile->cLines <= line) {
        return buf[0] = 0;
    }

    /*
     * get line record
     */
    vLine = VALINE(line);

    if (vLine->vaLine == (PVOID)(-1L)) {
        return buf[0] = 0;
    }

    cbLine = min (sizeof(linebuf)-1, vLine->cbLine);

    /*
     * get line
	 */
	// BUGBUG remove
	// memmove(p, vLine->vaLine == (PVOID)-1 ? (PVOID)(-(ULONG)vLine->vaLine) : vLine->vaLine, cbLine);

	memmove(p, vLine->vaLine, cbLine );
	p[cbLine] = 0;

    if (!fRaw) {
		return Untab (fileTab, p, strlen(p), buf, bTab);
    } else {
        return cbLine;
    }
}



/*  PutLine - put a buffer into the  file.  No CR/LF is present in the input
 *  line.  Grow the file if need be.
 *
 *  line	0-based line number in file to replace.  Growth of the file
 *		inserts blank lines.
 *  buf 	source of line.
 *  pFile	pointer to the file structure into which the line is to be
 *		place.
 */
void
PutLine (
    LINE line,
    char *buf,
    REGISTER PFILE pFile
    )
{
    puttextline (FALSE, TRUE, line, buf, pFile);
}




/*** InsertLine - insert a buffer into the  file.
*
*  Like PutLine, except inserts the line immediately prior to the specified
*  line. Grows the file.
*
* Input:
*  line 	= 0-based line number in file to insert before.
*  buf		= source of line.
*  pFile	= pointer to the file structure into which the line is to be
*		  placed.
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
InsertLine (
    LINE    line,
    char    *buf,
    REGISTER PFILE pFile
    )
{
    InsLine (TRUE, line, 1L, pFile);
    puttextline (FALSE, TRUE, line, buf, pFile);
}




/*** zprintf - insert formatted text into file being editted
*
*  Like fprintf, except that it inserts it's output into a file being
*  editted. "\n"'s in the text cause a line break, and insert multiple
*  lines. Examples:
*
*	zprintf (pFile, line, "this is a number %d", num);
*
*  Inserts a new line in front of line number "line" with the new text.
*
*	zprintf (pFile, line, "this is \na number %d\n", num);
*
*  Inserts three lines: one containing "this is", the next containing "a
*  number", and the last blank.
*
* Input:
*  pFile	= target file
*  lFirst	= starting line number
*  fmt		= formatting string
*  ...		= args as per string
*
* Output:
*  Returns the line number of the last line written + 1.
*
*************************************************************************/
LINE
__cdecl
zprintf (
    PFILE   pFile,
    LINE    lFirst,
    char const *fmt,
    ...
    )
{
    linebuf  fbuf;                           /* buffer into which to format  */
    REGISTER char *pEnd;                    /* pointer into it              */
    REGISTER char *pStart;                  /* pointer to begining of line  */
    va_list  Arguments;

    /*
     * Start by getting the formatted text
     */
    va_start(Arguments, fmt);
    ZFormat (fbuf, fmt, Arguments);

    /*
     * for each substring in the file, insert the text
     */
    pStart = fbuf;
    do {
        if (pEnd = strchr(fbuf,'\n')) {
            *pEnd = 0;
        }
        InsertLine (lFirst++, pStart, pFile);
        pStart = pEnd+1;
    } while (pEnd);
    va_end(Arguments);
    return lFirst;
}





/*  puttextline - put a buffer into the  file.	No CR/LF is present in the input
 *  line.  Grow the file if need be.  Convert to tabbed representation based on
 *  flag
 *
 *  fRaw	TRUE => line is placed into memory unmodified, otherwise
 *		trailing spaces are eliminated (fTrailSpace) and spaces are
 *		converted to tabs.
 *  fLog	TRUE => make this action undo-able.
 *  line	0-based line number in file to replace.  Growth of the file
 *		inserts blank lines.
 *  buf 	source of line.
 *  pFile	pointer to the file structure into which the line is to be
 *		place.
 */
void
puttextline (
    flagType fRaw,
    flagType fLog,
    LINE line,
    char *buf,
    REGISTER PFILE pFile
    )
{
    static struct lineAttr rgla[sizeof(linebuf)];
    LINEREC *vLine;
    struct colorRecType vColor;
    int newLen;
    flagType fChange, fColor;
    linebuf putbuf;
    PVOID  va;

    redraw (pFile, line, line);
	makedirty (pFile);

    if (pFile->cLines <= line) {
		growline (line+1, pFile);
		pFile->cLines = line+1;
		SETFLAG (fDisplay, RSTATUS);
    } else {
        if (pFile == pInsCur->pFile) {
            AckReplace (line, FALSE);
        }
    }

    /* get line record */
    vLine = VALINE(line);

    fChange = FALSE;
    newLen = strlen (buf);

    if (!fRaw) {
        if (!fTrailSpace && pFile == pFileHead) {
            newLen = RemoveTrailSpace (buf);
        }
        if (fRealTabs) {
            fColor = (flagType)getcolorline (FALSE, line, rgla, pFile);
        }

        switch (EnTab) {

		case 0:
            break;

		case 1:
			newLen = TabMin (fileTab, buf, putbuf);
			buf = putbuf;
            break;

		case 2:
			newLen = TabMax (fileTab, buf, putbuf);
			buf = putbuf;
            break;

		default:
			break;
        }
    }

    /*	We now have the real text that we'd like to replace in the file.
     *	If logging is requested then
     *	    we log this replacement action
     *	else
     *	    free the current line
     *	allocate a new line
     *	copy the line into the allocated line
     *	set the length
     *	replace line record
     */

    if (fLog) {
        if (pFile->vaColor != (PVOID)(-1)) {
            memmove((char *)&vColor, VACOLOR(line), sizeof(vColor));
            if (vColor.vaColors != (PVOID)(-1L)) {
                va = MALLOC ((long)vColor.cbColors);
                if ( !va ) {
                    disperr(MSGERR_NOMEM);
                    disperr(MSGERR_QUIT);
                    CleanExit(4,FALSE);
                }
                memmove(va, vColor.vaColors, (long)vColor.cbColors);
				vColor.vaColors = va;
            }
        } else {
            vColor.vaColors = (PVOID)(-1L);
			vColor.cbColors = 0;
        }

        LogReplace (pFile, line, vLine, &vColor);
	} else if (vLine->Malloced) {
		vLine->Malloced = FALSE;
        FREE (vLine->vaLine);
    }

    if (newLen == 0) {
        vLine->vaLine   = (PVOID)(-1L);
        vLine->Malloced = FALSE;
    } else {
        vLine->vaLine   = MALLOC((long) newLen);
        if ( !vLine->vaLine ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        vLine->Malloced = TRUE;
	vLine->cbLine	= newLen;

	memmove(vLine->vaLine, buf, newLen);

    }
    if (fRealTabs && !fRaw && fColor) {
        PutColor (line, rgla, pFile);
    }
}





/*  FileLength - return the number of lines in a file
 *
 *  pFile	handle of file
 *
 *  returns	number of lines in file
 */
LINE
FileLength (
    PFILE pFile
    )
{
    return pFile->cLines;
}





/*  BlankLines - blank a series of line records in a file's line structure.
 *  We can be either gross (fill in one at a time) or be reasonable (fill in
 *  fixed size blocks at a time, or be smart (fill a block then copy
 *  exponentially large blocks).  We are smart.
 *
 *  n		number of line records to blank
 *  va		virtual address of first line to blank
 */
void
BlankLines (
    LINE    n,
    PVOID   va
    )
{

    LINEREC vLine;
    long    copylen = (long) sizeof (vLine);
    PBYTE   dst     = (PBYTE)va;
    long    amtleft = (long) sizeof (vLine) * n;
    long    amtdone = 0L;

    vLine.vaLine    = (PVOID)(-1L);
    vLine.Malloced  = FALSE;
    vLine.cbLine    = -1;

    while (amtleft != 0L) {
        if (amtdone == 0L) {
            // Copy first blank line
            memmove(dst, (char *)&vLine, (int) copylen);
        } else {
            // Copy bunch
	    copylen = amtleft < amtdone ? amtleft : amtdone;
            memmove(dst, va, copylen);
        }
        dst     += copylen;
	amtleft -= copylen;
	amtdone += copylen;
    }
}



/*  BlankColor - blank a series of color records in a file's line structure.
 *  We can be either gross (fill in one at a time) or be reasonable (fill in
 *  fixed size blocks at a time, or be smart (fill a block then copy
 *  exponentially large blocks).  We are smart.
 *
 *  n		number of color records to blank
 *  va		virtual address of first color to blank
 */
void
BlankColor (
    LINE    n,
    PVOID    va
    )
{
    struct colorRecType vColor;
    long    copylen = (long) sizeof (vColor);
    PBYTE   dst     = (PBYTE)va;
    long    amtleft = (long) sizeof (vColor) * n;
    long    amtdone = 0L;

    vColor.vaColors = (PVOID)(-1L);
    vColor.cbColors = -1;
    while (amtleft != 0L) {
        if (amtdone == 0L) {
            // Copy one
            memmove(dst, (char *)&vColor, (int) copylen);
        } else {
            copylen = amtleft < amtdone ? amtleft : amtdone;
            // Copy a bunch
            memmove(dst, va, copylen);
        }
        dst     += copylen;
	amtleft -= copylen;
	amtdone += copylen;
    }
}





/* growLine - make a structure n lines long */
void
growline (
    REGISTER LINE line,
    REGISTER PFILE pFile
    )
{
    long    tmp1;
    LINE    lSize;
    PBYTE   vaTmp;
    struct colorRecType vColor;

    //
    // IF the file has a color array, and if the requested growth is greater than
    // the number of lines in the file, copy over the existing color array to
    // larger VM, release the previous array, and initialize the "new" entries in
    // that array.
    //
    if ((pFile->vaColor != (PVOID)(-1L)) && (pFile->lSize < line)) {
	tmp1 = (lSize = line + DELTA) * (long) sizeof(vColor);
        vaTmp = (PBYTE)MALLOC (tmp1);
        if ( !vaTmp ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
        memmove(vaTmp, pFile->vaColor, pFile->cLines * sizeof(vColor));
        FREE (pFile->vaColor);
        pFile->vaColor  = (PVOID)vaTmp;
        vColor.vaColors = (PVOID)(-1L);
	vColor.cbColors = 0;
        vaTmp +=  pFile->cLines * sizeof(vColor);
	for (lSize = pFile->cLines; lSize < line+DELTA;  lSize++) {
            memmove(vaTmp, (char *)&vColor, sizeof(vColor));
	    vaTmp += sizeof(vColor);
        }
    }

    //
    // If there are no lines, or not enough lines allocated for, allocate a new
    // line buffer which is larger than the request by DELTA lines (allows us to
    // avoid this operation for every added line). If there were line records,
    // move them into this new buffer, and free the old one. Blank out the added
    // records.
    //
    if ((pFile->plr == NULL) || (pFile->lSize < line)) {
	tmp1 = (lSize = line + DELTA) * (long) sizeof (LINEREC);
        vaTmp = (PBYTE)MALLOC (tmp1);
        if ( !vaTmp ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
	if (pFile->plr != NULL) {
	    memmove(vaTmp, pFile->plr,
		    ((long)pFile->cLines) * sizeof (LINEREC));
	    FREE (pFile->plr);
        }
        pFile->lSize   = lSize;
	pFile->plr = (LINEREC *)vaTmp;
	BlankLines (lSize - pFile->cLines, VALINE(pFile->cLines));
        if (pFile->vaColor != (PVOID)(-1L)) {
            BlankColor (lSize - pFile->cLines, VACOLOR(pFile->cLines));
        }
    }
}




/*  DelLine - delete n lines from the file, starting at line n.  Shrink what-
 *  ever structures are necessary.
 *
 *  The line range yStart-yEnd is deleted inclusively.
 *
 *
 *  pFile	file structure from which lines are deleted
 *  yStart	beginning 0-based line number to be deleted
 *  yEnd	ending line to be deleted
 */
void
DelLine (
    flagType fLog,
    PFILE pFile,
    LINE yStart,
    LINE yEnd
    )
{
    if (yStart >= pFile->cLines || yStart > yEnd) {
        return;
    }

    redraw (pFile, yStart, pFile->cLines);
    makedirty (pFile);

    yEnd = lmin (yEnd, pFile->cLines-1);

    /*	if logging this delete operation is requested then
     *	    Log the delete range
     *	else
     *	    free up the data being deleted
     */
    if (fLog) {
        LogDelete (pFile, yStart, yEnd);
    }

    /*	block transfer the remainder of the file down
     */
    memmove(VALINE(yStart), VALINE(yEnd+1),
	    ((long)(pFile->cLines-yEnd-1))*sizeof(LINEREC));

    /* Do the same for the color.
    */
    if (pFile->vaColor != (PVOID)(-1L)) {
        memmove(VACOLOR(yStart), VACOLOR(yEnd+1),
                ((long)(pFile->cLines-yEnd-1))*sizeof(struct colorRecType));
    }

    /*	remove lines from count
     */
    pFile->cLines -= yEnd - yStart + 1;
    SETFLAG (fDisplay, RSTATUS);

    /*	Clear out line records
     */
    BlankLines (yEnd - yStart + 1, VALINE (pFile->cLines));
    if (pFile->vaColor != (PVOID)(-1L)) {
        BlankColor (yEnd - yStart + 1, VACOLOR (pFile->cLines));
    }

    if (fLog) {
        AdjustLines (pFile, yStart, yStart - yEnd - 1);
    }

    MarkDelStream (pFile, 0, yStart, sizeof(linebuf), yEnd);
}





/*  DelFile - delete contents of file
 *
 *  pFile	file structure that is to be cleared
 */
void
DelFile (
    REGISTER PFILE pFile,
    flagType fLog
    )
{
    DelLine (fLog, pFile, (LINE)0, pFile->cLines - 1);
    RSETFLAG (FLAGS(pFile), DIRTY);
}





/*  InsLine - insert a block of blank lines into the file.
 *
 *  line	0-based line before which the insertion will occur.
 *  n		number of blank lines to insert
 *  pFile	file structure for the operation
 */
void
InsLine (
    flagType fLog,
    LINE line,
    LINE n,
    REGISTER PFILE pFile
    )
{
    if (line >= pFile->cLines) {
	return;
    }
    redraw (pFile, line, n+pFile->cLines);
    makedirty (pFile);
    if (fLog) {
        LogInsert (pFile, line, n);
    }
    growline (pFile->cLines + n, pFile);
    memmove(VALINE(line+n), VALINE(line),
	    (long)sizeof(LINEREC)*(pFile->cLines - line));
    if (pFile->vaColor != (PVOID)(-1L)) {
        memmove(VACOLOR(line+n), VACOLOR(line),
	    (long)sizeof(struct colorRecType)*(pFile->cLines - line));
	BlankColor (n, VACOLOR(line));
    }
    BlankLines (n, VALINE(line));
    pFile->cLines += n;
    SETFLAG (fDisplay, RSTATUS);
    if (fLog) {
        AdjustLines (pFile, line, n);
    }
    MarkInsLine (line, n, pFile);
}





/*** fInsSpace - open up a space in a line.
*
*  The line is retrieved and copied into buf and the appropriate number of
*  spaces are inserted. The line is NOT replaced in the file.
*
* Input:
*  x		= 0-based logical column of insertion
*  y		= 0-based line insertion
*  n		= number of spaces to insert
*  pFile	= file structure for the operation
*  buf		= destination of line.
*
* Output:
*  Returns FALSE if line ended up too long (still copied, but truncated)
*
* Notes:
*
*   Often called with n==0 for the following side effects:
*
*	o Trailing spaces added up to column x.
*	o If column x is in a tab,
*	o Line truncated to sizeof linebuf.
*
*   Otherwise GetLine is used.
*
*************************************************************************/
flagType
fInsSpace (
    REGISTER COL  x,
    LINE    y,
    int     n,
    PFILE   pFile,
    linebuf buf
    )
{
    return fInsSpaceColor (x, y, n, pFile, buf, NULL);
}




flagType
fInsSpaceColor (
    REGISTER COL  x,
    LINE    y,
    int     n,
    PFILE   pFile,
    linebuf buf,
    struct lineAttr * pla
    )
{
    int     cbLine;                         /* logical length if line       */
    int     cbMove;                         /* physical length to move      */
    int     cbPhys;                         /* physical length of line      */
    int     colPhys;                        /* Physical column x            */
    int     i;                              /* temp                         */
    flagType fRaw = TRUE;                   /* return value: init ok        */

    /*
     * if the requested insertion is already too out, then truncate IT, and
     * set return flag to indicate truncation.
     */
    if (x >= sizeof(linebuf)) {
        x = sizeof(linebuf)-1;
        fRaw = FALSE;
    }

    /*
     * Read the line, get the logical length, and if needed, pad the line such
     * that the logical length is x.
     */
    cbPhys = GetLine (y, buf, pFile);
    cbLine = cbLog (buf);
	if (cbLine < x) {
		memset ((char *) buf+cbPhys, ' ', x-cbLine);
        cbPhys += (x - cbLine);
        buf[cbPhys] = 0;
        cbLine = x;
        assert (x == cbLog(buf));
    }

    /*
     * In the case that the requested position is over a tab, we add spaces in
     * front of the cursor position. We do this by adding the number of spaces
     * between the requested column and the "aligned" column, and then aligning
     * to that column.
     */
    i = AlignChar (x,buf);
    n += x - i;
    x = i;

    /*
     * open up a space of n chars at location x, moving the chars and NUL
     * For overflow, we have two cases to consider:
     *      x + n + 1 > BUFLEN
     *          set n to be BUFLEN - 1 - x and continue
     *      cbLine + n + 1 > BUFLEN
     *          set cbLine to be BUFLEN - 1 - n and move the bytes
     */
    if (x + n + 1 > sizeof(linebuf)) {
        n = sizeof(linebuf) - 1 - x;
        fRaw = FALSE;
    } else {
        if (cbLine + n >= sizeof(linebuf)) {
            cbLine = sizeof(linebuf) - 1 - n;
            *pLog(buf,cbLine,TRUE) = 0;
            cbPhys = strlen(buf);
            fRaw = FALSE;
        }
        colPhys = (int)(pLog(buf,x,TRUE) - buf);
        cbMove = cbPhys - colPhys + 1;
        memmove ((char *) pLog(buf,x,FALSE)+n, (char *) pLog(buf,x,TRUE), cbMove);
        if (pla) {
            ShiftColor (pla, colPhys, n);
        }
    }
    /*
     * fill the new space with blanks
     */
    n += (int)(pLog(buf,x, FALSE) - pLog(buf,x, TRUE));
    memset ((char *) pLog(buf,x, TRUE), ' ', n);
    buf[sizeof(linebuf)-1] = 0;
    return fRaw;
}




/*** delspace - delete text from a line
*
*  The line is retrieved and copied into buf and the appropriate number of
*  characters are deleted. The line is NOT replaced in the file.
*
* Input:
*  xDel 	= 0-based logical column of deletion
*  yDel 	= 0-based line of deletion
*  cDel 	= logical number of spaces to delete
*  pFile	= file structure for the operation
*  buf		= buffer into which to place the resulting line
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
delspace (
    COL     xDel,
    LINE    yDel,
    int     cDel,
    PFILE   pFile,
    linebuf buf
    )
{
    int     cDelPhys;                       /* count of bytes to remove from buff*/
    int     cLog;                           /* logical length of buffer     */
    REGISTER char *pDelPhys;                /* pointer to physical deletion point*/

    /*
     * Get and compute the logical length of the line. We have work only if the
     * logical length of the line is greater than (past) the logical deletion
     * point.
     */
    GetLine (yDel, buf, pFile);
    cLog = cbLog(buf);

    if (cLog > xDel) {
        /*
         * Compute the physical deletion point (we use it a lot). If the end of the
         * range to be deleted is beyond the actual end of the line, all we need do
         * is truncate at the physical deletion point.
         */
        pDelPhys = pLog(buf,xDel,TRUE);
        if (cLog <= xDel + cDel) {
            *pDelPhys = 0;
        } else if (cDel) {
            /*
             * Compute the physical length of bytes to be removed, and move the remaining
             * portion of the line over that deleted.
             */
            cDelPhys = (unsigned int)max ((pLog(buf,xDel+cDel,TRUE) - pDelPhys), 1);
            memmove ((char*) pDelPhys,
                     (char*) pDelPhys + cDelPhys
                  , (unsigned int)(pLog(buf,cLog,TRUE) - pDelPhys - cDelPhys + 1));
        }
    }
}





/*** DelBox - delete a box from a file
*
*  The box delimited by xLeft-xRight and yTop-yBottom is deleted inclusively.
*
* Input:
*  pFile	= file to be modified
*  xLeft	= column start of box
*  yTop 	= line start of box
*  xRight	= column end of box
*  yBottom	= line end of box
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
DelBox (
    PFILE   pFile,
    REGISTER COL  xLeft,
    REGISTER LINE yTop,
    COL     xRight,
    LINE    yBottom
    )
{
    linebuf  buf;
    struct lineAttr rgla[sizeof(linebuf)];
    flagType fColor;
    REGISTER int cCol = xRight - xLeft + 1;

    MarkDelBox (pFile, xLeft, yTop, xRight, yBottom);
    if (xLeft <= xRight) {
        while (yTop <= yBottom) {
            delspace (xLeft, yTop, cCol, pFile, buf);
            if (fColor = GetColor (yTop, rgla, pFile)) {
                ShiftColor (rgla, xRight, -cCol);
                ColorToLog (rgla, buf);
            }
            PutLine (yTop++, buf, pFile);
            if (fColor) {
                PutColor (yTop-1, rgla, pFile);
            }
        }
    }
}





/*** DelStream - delete a stream from a file
*
*  The stream specified starting at (xStart,yStart) is deleted up through
*  the character before (xEnd, yEnd).
*
* Input:
*  pFile	= file to be modified
*  xStart	= column start of stream
*  yStart	= line start of stream
*  xEnd 	= column end of stream
*  yEnd 	= line end of stream
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
DelStream (
    PFILE   pFile,
    REGISTER COL  xStart,
    REGISTER LINE yStart,
    COL     xEnd,
    LINE    yEnd
    )
{
    linebuf pbuf, sbuf;

    CopyColor (pFile, pFile, yEnd, xEnd, sizeof(linebuf), yStart, xStart);
    fInsSpace (xStart, yStart, 0, pFile, pbuf);
    *pLog (pbuf, xStart, TRUE) = 0;
    DelLine (TRUE, pFile, yStart, yEnd - 1);
    delspace (0, yStart, xEnd, pFile, sbuf);
    LengthCheck (yStart, xStart, sbuf);
    strcpy (pLog (pbuf, xStart, TRUE), sbuf);
    PutLine (yStart, pbuf, pFile);
    MarkCopyBox (pFile, pFile, xEnd, yStart, sizeof(linebuf), yStart, xStart, yStart);
}




/*  LengthCheck - verify/truncate a buffer prior to strcpy
 *
 *  Verify that the result of a strcpy will fit within a buffer.
 *  If the line is too long, display an error and truncate the string so
 *  that it will fit within a buffer.
 *
 *  line	line of interest (for display)
 *  offset	offset where strcpy begins
 *  pStr	pointer to copied string.  If NULL, the message is displayed.
 */
void
LengthCheck (
    LINE line,
    int  offset,
    REGISTER char *pStr
    )
{
    if (pStr == NULL || offset + strlen (pStr) + 1 > sizeof(linebuf)) {
	printerror ("Line %ld too long", line + 1);
        if (pStr != NULL) {
            pStr[BUFLEN - offset - 1] = 0;
        }
    }
}





/****************************************************************************
 *									    *
 *  fcolcpy (dst, src)							    *
 *									    *
 *	dst   - address of destination of copy				*
 *	src   - address of source of copy				*
 *									    *
 *  RETURNS:								    *
 *									    *
 *	Number of struct lineAttr's copied                                  *
 *									    *
 *  DESCRIPTION:							    *
 *									    *
 *	Copies the contents of src to dst.  The length of the array,	    *
 *	including the terminating 0xFFFF, is returned.	If the		    *
 *	destination is NULL, the number of items is still returned, but     *
 *	no copy takes place.						    *
 *									    *
 ****************************************************************************/
int
fcolcpy (
    struct lineAttr *  dst,
    struct lineAttr *  src
    )
{

	struct lineAttr *p = src;
	int size;

	while ((p->len != 0xFF) && ((p++)->attr != 0xFF)) {
	}

	size = (int)((PBYTE)p - (PBYTE)src);

	if ( dst ) {
		memmove((char *)dst, (char *)src, size);
	}

	return size / sizeof(struct lineAttr);
}




/*** FreeFile - Free all resources for LRU clean file or MRU dirty file
*
* Purpose:
*
*   When we are low on memory, we call this to get some back.  This frees
*   the text of the file from VM, as well as the pFile structure and name
*   from local memory.
*
*   The strategy is to find the least recently used clean file and throw it
*   out.  If there are no such files, we find the most recently used dirty
*   file, ask the user if he wants to save it, then flush it.  The user
*   can hit <cancel> to not flush the file.
*
* Input:
*
* Output:
*
*   Returns TRUE if successfull.
*
*
* Exceptions:
*
*   Pseudo files are not removed.
*   Dirty user files will be saved to disk first.
*
* Notes:
*
*************************************************************************/
flagType
ExpungeFile (
    void
    )
{
    flagType fRet   = FALSE;
    PFILE    pFile;

    /*
     * Ensure that we do NOT attempt to update any text screens (and possibly
     * attempt to allocate more memory).
     */
    RSETFLAG (fDisplay, RTEXT);

    if (!(pFile = pFileLRU (pFileHead))) {

        /*
         * No LRU clean files found. Ask if user wants to save them all, and let
         * him try. Then look for an LRU clean file again.
         */
        if (confirm ("Save all changed files?",NULL)) {
            SaveAllFiles ();
        }

        if (!(pFile = pFileLRU (pFileHead))) {
            /*
             * No LRU clean files, and he didn't want to save them all. So, we walk
             * the pFile list, and let him decide for each one. As soon as we find one
             * that we can flush, do so.
             */

            for (pFile = pFileHead; pFile; pFile = pFile->pFileNext) {
                if (   ((FLAGS(pFile) & (DIRTY | FAKE)) == DIRTY)
		    && (pFile != pFileIni)
                    && (pFile != pFileHead)
                    && (pFile != pFileMark)) {

                    if (confirm ("Save file %s before flushing?",pFile->pName)) {
                        FileWrite (NULL, pFile);
                    }
                    break;
                }
            }
        }
    }

    /*
     * We have some kind of pFile. Either it was clean, or it was dirty and the
     * user said save it, or it is dirty, and the user said flush it anyway. So
     * we do...
     */
    if (pFile) {
        domessage ("Flushing %s from memory", pFile->pName);
        RemoveFile (pFile);
        fRet = TRUE;
    }

    SETFLAG (fDisplay, RTEXT);
    return fRet;
}





/*** pFileLRU - Return last clean user file in file list
*
* Purpose:
*
*   Used by ExpungeFile to find LRU clean file.
*
* Input:
*
*   Head of list of files in MRU order
*
* Output:
*
*   Returns LRU pFile.
*
*
* Exceptions:
*
*   TOOLS.INI and the current mark file
*
* Notes:
*
*   The function recurses to the end of the list, then backtracks through
*   the unacceptable files to the one we want and returns that.  The
*   recursion take 4 bytes for each call.  The maximum number of calls
*   should be about 250.
*
*************************************************************************/
PFILE
pFileLRU (
    PFILE pFile
    )
{
    static PFILE pFileRet;

    if (pFile == NULL) {
        return NULL;
    }

    if (pFileRet = pFileLRU (pFile->pFileNext)) {
        return pFileRet;
    }

    if (TESTFLAG (FLAGS(pFile), FAKE) || TESTFLAG (FLAGS(pFile), DIRTY)) {
        return NULL;
    }

    if (pFile == pFileIni || pFile == pFileMark) {
        return NULL;
    }

    return pFile;
}






/*** FreeFileVM  - Free VM space associated with the given file
*
* Purpose:
*
*   To recover VM used by a file
*
* Input:
*
*   pFile - File in question.
*
* Output:
*
*   Returns nothing
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void
FreeFileVM (
    PFILE pFile
    )
{
    LINE  i;
    LINEREC *vLine;


    for (i = 0; i < min( 1, pFile->cLines ); i++) {
        vLine = VALINE(i);
		if (vLine->Malloced) {
			vLine->Malloced = FALSE;
            FREE (vLine->vaLine);
        }
    }

    pFile->cLines = 0;
    pFile->lSize  = 0;

    if (pFile->plr != NULL) {
	FREE (pFile->plr);
	pFile->plr = NULL;
    }

    if (pFile->pbFile != NULL) {
	 FREE (pFile->pbFile);
	 pFile->pbFile = NULL;
     }

    RemoveUndoList (pFile);

    RSETFLAG (FLAGS (pFile), REAL);
}






/*** GetTagLine - Get a line, assuming a tools.ini-style format
*
* Purpose:
*
*   To get a clean, complete line in DoAssign form.  This means:
*
*	o Blank lines are skipped
*	o Lines beginning with ';' are skipped
*	o Text past a ';' not in quotes is eliminated
*	o Lines with continuation characters are concatenated
*	o When we reach another tag, we stop reading
*
*   The continuation character is a '\'; it must be preceded by
*   a space or tab and followed by nothing or whitespace and/or a comment.
*   Any leading whitespace on following lines is stripped.
*
* Input:
*   buf -   Place to put result.  This must be NULL initially and a
*	    GetTagLine returned pointer afterwords
*
* Output:
*
*   Returns pointer to next line, or NULL if we are done
*
* Notes:
*
*   When we return NULL, we also free the buffer.  If the caller stops
*   before NULL is returned, s/he must also free the buffer.
*
*   Because a line may be arbitrarily long, we may need to LMAlloc more
*   space for it.  Because of this, the routine itself will alloc all space
*   used.  When a non-NULL pointer is passed in, it is assumed that this
*   points to the heap.
*
*************************************************************************/

#define GTL_NORMAL  0
#define GTL_QUOTE   1
#define GTL_WS	    2
#define GTL_CONT    3

char *
GetTagLine (
    LINE * pCurLine,
    char * buf,
    PFILE  pFile
    )
{
    int     cch;
    int     ochScan;                        /* saved offset of pchScan      */
    int     state = GTL_NORMAL;
    int     statePrev;
    REGISTER char * pchScan;
    char    *pchSlash;
    char    *pch;
    flagType fEof = FALSE;
    flagType fWS;

    if (buf == NULL) {
        buf = ZEROMALLOC (sizeof(linebuf));
        if ( !buf ) {
            disperr(MSGERR_NOMEM);
            disperr(MSGERR_QUIT);
            CleanExit(4,FALSE);
        }
    }

    buf[0] = '\0';  /* Ya start with nothin' */
    pchScan = buf;

    //  We do this:
    //
    //      Get a line
    //      If it's a tag line or the last line, stop reading
    //      If it is blank or begins with a ';', start over
    //      Clean up the line
    //      If we are left looking at a \, reset pointers, allocate
    //      Enough more space to leave BUFLEN bytes of space, and
    //      Start over.
    //
    //  When we're done, 'buf' points to a complete line
    //
    while (TRUE) {
        GetLine ((*pCurLine)++, pchScan, pFile);

	if (IsTag (pchScan) || (*pCurLine) > pFile->cLines) {
            (*pCurLine)--;  /* Leave caller pointing at tag line    */
            fEof = TRUE;
            break;
        }

        /* Squeeze out all leading spaces. */
        pch = whiteskip (pchScan);
        memmove ((char *)pchScan, (char*)pch, strlen(pch) + 1);

        // Now look for a continuation sequence.  This is whitespace
        // followed by a \ followed by nothing but whitespace and/or
        // a comment.  We use a modified FSM with these states:
        //
        // GTL_NORMAL   Outside quotes
        // GTL_QUOTE    Inside quotes
        // GTL_WS       Reading whitespace
        // GTL_CONT     Possible continuation sequence found.
        //
        for (fWS = TRUE, statePrev = state = GTL_NORMAL;
            *pchScan;
            pchScan++) {
            if (*pchScan == ';' && fWS && statePrev != GTL_QUOTE) {
                *pchScan-- = '\0';
            } else {
                fWS = (flagType)(strchr (rgchWSpace, *pchScan) != NULL);
                switch (state) {

                    case GTL_NORMAL:
                        if (fWS) {
                            state = GTL_WS;
                            statePrev = GTL_NORMAL;
                        } else if (*pchScan == '"') {
                            state = GTL_QUOTE;
                        }
                        break;

                    case GTL_QUOTE:
                        if (fWS) {
                            state = GTL_WS;
                            statePrev = GTL_QUOTE;
                        } else if (*pchScan == '"') {
                            state = GTL_NORMAL;
                        }
                        break;

                    case GTL_WS:
                        if (*pchScan == '\\') {
                            pchSlash = pchScan;
                            state = GTL_CONT;
                            break;
                        }

                    case GTL_CONT:
                        if (!fWS) {
                            if (*pchScan == '"') {
                                state = statePrev == GTL_QUOTE ?
                                                    GTL_NORMAL :
                                                    GTL_QUOTE;
                            } else {
                                state = statePrev;
                            }
                        }
                        break;
                }
            }
        }

        if (state == GTL_CONT) {
            pchScan = pchSlash-1;   /* -1 to strip the space */
            /* Make sure there is enough space for getline! */
            cch = MEMSIZE (buf);
            ochScan = (int)(pchScan - buf);
            if ((cch - ochScan) < sizeof(linebuf)) {
                pch = buf = ZEROREALLOC (buf, cch + sizeof(linebuf));
                pchScan = pch + ochScan;
            }
        } else if (buf[0] == '\0') {
            continue;
        } else {
            break;
        }
    }


    // 'buf' holds whatever we got.  If 'fEof' is TRUE, this may be
    // nothing at all.  If 'fEof' is FALSE and we have nothing, then
    // we are confused.
    //
    if (fEof) {
        if (pchScan != buf) {
            // The user had a continuation character at the end
            // of the last line in the section or file. Erase the
            // trailing [garbage] and issue a warning message.
            //
            printerror ("Warning: continuation character on last line!");
            *pchScan = '\0';
            return buf;
        } else {
            FREE (buf);
            return NULL;
        }
    } else {
        assert (buf[0]);
    }

    return buf;
}





/*** cbLog - return logical length of entabbed line
*
*  Given a line possible entabbed, return the logical length of that line.
*
* Input:
*  pBuf 	= pointer to line in question
*
* Output:
*  Returns logical length of line
*
*************************************************************************/
int
cbLog (
    REGISTER char *pBuf
    )
{
    REGISTER int cbLine;

    if (!fRealTabs) {
        return strlen(pBuf);
    }

    cbLine = 0;
    while (*pBuf) {
        if (*pBuf++ == '\t') {
            cbLine = ((cbLine + fileTab) / fileTab) * fileTab;
        } else {
            cbLine++;
        }
    }
    return cbLine;
}





/*** colPhys - return logical column from physical pointer
*
*  Given a buffer and a pointer into it, determine the logical column
*  that that pointer represents. If a null is encountered before the
*  pointer into the buffer, the rest of the buffer contents are ignored
*  (that is, tab expansion calculation is not done), and the column is
*  returned as if the rest of the line up to the pointer were NOT tabs.
*
* Input:
*  pBuf 	= pointer to buffer
*  pCur 	= pointer into buffer
*
* Output:
*  Returns 0 based column represented
*
*************************************************************************/
COL
colPhys (
    char    *pBuf,
    char    *pCur
    )
{
    COL     colRet  = 0;

    /*
     * Special case the current pointer preceding the buffer, and return a
     * column of -1.
     */
    if (pBuf > pCur) {
        return -1;
    }

    while (*pBuf && (pBuf < pCur)) {
        if (*pBuf++ == '\t') {
            colRet = ((colRet + fileTab) / fileTab) * fileTab;
        } else {
            colRet++;
        }
    }

    if (pBuf < pCur) {
        colRet += (COL)(pCur - pBuf);
    }

    return colRet;
}





/*** IncCol, DecCol - Increment/Decrement a column w/ tabs
*
*  Increment or decrement a column position, taking into account tab
*  characters on the line and the fRealTabs flag. Ensure that the resulting
*  logical column position rests on a character, or the first column
*  position of an underlying tab, if fRealTabs is on.
*
* Input:
*  col		= column position to start
*  pText	= buffer containing the text of the line
*
* Output:
*  Returns new column position
*
*************************************************************************/
COL
DecCol (
    COL     col,
    char    *pText
    )
{
    return colPhys (pText, pLog (pText, col, FALSE) - 1);
}





COL
IncCol (
    COL     col,
    char    *pText
    )
{
    return colPhys (pText, pLog (pText, col, TRUE) + 1);
}





/*** AppFile - Append a line to the given file without logging the change
*
* Purpose:
*
*   Used to generate pseudo files that display information, such as
*   <information> and <assign>.
*
* Input:
*   p	  - Line to add.
*   pFile - File to add it to
*
* Output: None.
*
*************************************************************************/
void
AppFile (
    char *p,
    PFILE pFile
    )
{
    puttextline (FALSE, FALSE, pFile->cLines, p, pFile);
}




/*** PutTagLine - Put a line into file with continuation chars
*
* Purpose:
*
*   Used to generate TOOLS.INI type entries, in which a single logical
*   line can be broken into many physical lines separated by continuation
*   characters.
*
*   The current logical line is replaced.
*
* Input:
*   pFile   -	The file to put into
*   pszLine -	The line to put
*   line    -	The number of the line to replace
*
* Output: None
*
*************************************************************************/
void
PutTagLine (
    PFILE  pFile,
    char * pszLine,
    LINE   y,
    COL    x
    )
{
    PFILE    pFileCur   = pFileHead;
    fl       flWindow;
    fl       flCursor;
    flagType fWrap      = fWordWrap;
    LINE     yCur;
    linebuf  lbuf;

    // We remember which file we're in, then switch to the
    // given and use edit() to insert to string.  In between
    // in each character we check to see if we have been bumped
    // to thenext line.  If so, we retrieve the previous line
    // and append a continuation character.  When we're done, we
    // restore the previous state of pFile.
    //
    pFileToTop (pFile);
    flWindow = pInsCur->flWindow;
    flCursor = pInsCur->flCursorCur;

    pInsCur->flCursorCur.lin = y;

    if (x < 0) {
        x = LineLength (y, pFile);
    }

    pInsCur->flCursorCur.col = x;

    fWordWrap = TRUE;
    yCur      = y;

    while (*pszLine) {
        edit (*pszLine++);
        if (yCur != YCUR(pInsCur)) {
            GetLine (yCur, lbuf, pFile);
            strcat (lbuf, "  \\");
            PutLine (yCur, lbuf, pFile);
            yCur = YCUR(pInsCur);
        }
    }

    fWordWrap = fWrap;
    pInsCur->flWindow = flWindow;
    pInsCur->flCursorCur = flCursor;
    pFileToTop (pFileCur);
}





/*** ShiftColor - Shift color left or right within a line
*
* Purpose:
*
*   Shifts color to the left or right.	Shifting left deletes the
*   covered coilor.  Shifting right propogates the color at the
*   left edge of the shift.
*
* Input:
*   rgla    - Array of colors to work on.
*   xStart  - Column to start with
*   n	    - Number of columns to shift by.
*
* Output: None.
*
* Notes:
*
*   It is assumed that the color can properly be shifted by simply
*   adding or subtracting the given number of columns.	This means
*   that when fRealTabs is on, the color array should be presented
*   in physical form, as returned by GetColor().
*
*************************************************************************/
void
ShiftColor (
    struct lineAttr rgla[],
    COL x,
    int len
    )
{
    struct lineAttr * plaEnd;
    struct lineAttr * plaRight;
    struct lineAttr * plaLeft;

    int      dColRight;
    int      dColLeft;
    flagType fFoundRight = FALSE;
    flagType fFoundLeft  = FALSE;


    plaEnd    = plaLeft = plaRight = rgla;
    dColRight = dColLeft = x;

    fFoundRight  = fGetColorPos (&plaRight, &dColRight);
    fFoundLeft   = fGetColorPos (&plaLeft, &dColLeft);
    (void)fGetColorPos (&plaEnd, NULL);

    if (!fFoundLeft) {
        return;
    }

    if (len < 0) {
        // User is shifting left.  If the deletion
        // all lies within a single color, we simply shorten
        // that color.  If it does not, we delete the entries
        // for the colors we lose, then shorten the colors
        // on either side.
        //
        if (plaLeft == plaRight) {
            plaLeft->len = (unsigned char)((int)plaLeft->len + len);
        } else {
            memmove ((char *)(plaLeft + 1),
		    (char *)plaRight,
                    (unsigned int)(sizeof(*plaEnd) * (plaEnd - plaRight + 1)));
            plaLeft->len = (unsigned char)(dColLeft > 0 ? dColLeft : 0);
            if (fFoundRight) {
                (plaLeft+1)->len -= (unsigned char)dColRight;
            }
        }
    } else {
        plaLeft->len += (unsigned char)len;
    }
}




/*** CopyColor - Copy part of a line of color
*
* Purpose:
*
*   When text is copied, we make the color follow it with this.
*
* Input:
*   pFileSrc	- Source of color.  If NULL, the color is fgColor.
*   pFileDst	- Destination of color.
*   yStart	- Line to get color from.
*   xStart	- Column to start in
*   len		- length of color to copy
*   yDst	- Line to put color on
*   xDst	- Column to start in
*
* Output: None.
*
* Notes:
*
*   The color copied overwrites existing color.
*
*   This could be made faster by splicing in the color directly,
*   rather than calling UpdOneHiLite().
*
*************************************************************************/
void
CopyColor (
    PFILE pFileSrc,
    PFILE pFileDst,
    LINE  yStart,
    COL   xStart,
    COL   len,
    LINE  yDst,
    COL   xDst
    )
{
    struct lineAttr * rglaSrc = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));
    struct lineAttr * rglaDst = (struct lineAttr *)ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));
    struct lineAttr * plaLeft;
    COL xLeft, cCol;
    flagType fLeft = TRUE, fColorDst, fColorSrc = FALSE;

    if ( !rglaSrc || !rglaDst ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }


    xLeft = xStart;

    fColorDst = (flagType)getcolorline (TRUE, yDst, rglaDst, pFileDst);

    if (!pFileSrc ||
        !(fColorSrc = (flagType)GetColor (yStart, plaLeft = rglaSrc, pFileSrc)) ||
        !(fLeft = fGetColorPos(&plaLeft, &xLeft)) ) {

        if (fColorSrc || fColorDst) {
            UpdOneHiLite (rglaDst, xDst, len, TRUE, fLeft ? fgColor : plaLeft->attr);
        } else {
            goto freestuff;
        }
    } else {
        assert(plaLeft && plaLeft->len != 0xFF);

        plaLeft->len -= (unsigned char)xLeft;

        for (cCol = 0; cCol < len; cCol += plaLeft->len, plaLeft++) {
            if (plaLeft->len != 0xFF) {
                if ((int)plaLeft->len > (len - cCol)) {
                    plaLeft->len = (unsigned char)(len - cCol);
                }
                UpdOneHiLite (rglaDst, xDst + cCol, TRUE, plaLeft->len, plaLeft->attr);
            }
        }
    }

    putcolorline (TRUE, yDst, rglaDst, pFileDst);

freestuff:
    FREE (rglaSrc);
    FREE (rglaDst);
}





/*** SetColor - Assign a color to a stretch of text
*
* Purpose:
*
*   Add color to a file.
*
* Input:
*   pFile   - File to add color to.
*   y	    - Line to add color to.
*   x	    - Column to start in.
*   len	    - Length of color.
*   color   - color to attach.
*
* Output: None.
*
*************************************************************************/
void
SetColor (
    PFILE pFile,
    LINE  y,
    COL   x,
    COL   len,
    int   color
    )
{
    struct lineAttr * rgla = (struct lineAttr * )ZEROMALLOC (sizeof(linebuf) * sizeof(struct lineAttr));
    struct lineAttr * pla;

    if ( !rgla ) {
        disperr(MSGERR_NOMEM);
        disperr(MSGERR_QUIT);
        CleanExit(4,FALSE);
    }

    if (GetColorUntabbed (y, rgla, pFile)) {
        UpdOneHiLite (rgla, x, len, TRUE, color);
    } else {
        if (color == FGCOLOR) {
            goto freeit;
        }

        pla = rgla;

        if (x) {
            pla->len = (unsigned char)x;
            (pla++)->attr = (unsigned char)fgColor;
        }

        pla->len = (unsigned char)len;
        pla->attr = (unsigned char)color;
        (++pla)->len = 0xFF;
    }

    PutColor (y, rgla, pFile);

freeit:
    FREE (rgla);
}





/*** fGetColorPos - Get color array position of real column
*
* Purpose:
*
*   Given an array of lineAttr and a column number, find the
*   color array element and offset that corresponds to that
*   absolute column.
*
* Input:
*   ppla    - Color array to examine.
*   pOff    - Column in text line to find.  If NULL, this is a
*	      request to find the array terminator.
*
* Output:
*   ppla   - Element of input array that specifies the color field
*	     in which the input column will be found.  If the column
*	     lies beyond the defined color, this will be the terminator.
*   pOff   - The offset into the color field ppla which corresponds
*	     to the user's column.
*
*   Returns TRUE if the user's column lay within the color definition,
*   FALSE if not.
*
*************************************************************************/
flagType
fGetColorPos (
    struct lineAttr **ppla,
    COL * pOff
    )
{
    COL Off;
    COL x;

    if (pOff) {
        Off = *pOff;
    }

    for (x = 0; (*ppla)->len != 0xFF; x += (*ppla)->len, (*ppla)++) {
        if (pOff && (Off - x < (COL)((*ppla)->len))) {
            break;
        }
    }

    if (pOff) {
        *pOff = Off - x;
    }

    return (flagType)((*ppla)->len != 0xFF);
}






/*** ColorToPhys - Change a line's color info from logical to physical
*
* Purpose:
*
*   The logical color representation encodes one color column per screen
*   column.  The physical color representation encodes one color column
*   per file character.  The difference is that the file character may
*   be a tab, which represents 1-8 screen columns.
*
*   This function takes a logical color array and converts it to a
*   physical array, using the text the color is attached to.
*
* Input:
*   pla  -  Logical color array.
*   line -  Line number this is attached to to.
*   pFile-  File the line is in.
*
* Output: None
*
*************************************************************************/
void
ColorToPhys (
    struct lineAttr * pla,
    LINE  line,
    PFILE pFile
    )
{
    struct lineAttr * plaCur;
    linebuf  lBuf;
    COL      xLog, xPhys, xShrink;
    flagType fRealTabsOrig = fRealTabs;

    fRealTabs = TRUE;
    if (gettextline (TRUE, line, lBuf, pFile, ' ')) {
        // We read through the color array, keeping
        // track of the logical column represented
        // by the color fields.  At each field, we ask
        // what physical column the end of the field
        // represents.  If the two columns differ,
        // we shrink the current current field. The
        // amount to shrink is the difference between
        // the columns less the amount we have already
        // shrunk.
        //
        for (plaCur = pla, xShrink = 0, xLog = plaCur->len;
             plaCur->len != 0xFF;
             xLog += (++plaCur)->len) {

            xPhys = (COL)(pLog(lBuf, xLog, FALSE) - lBuf);

            plaCur->len -= (unsigned char)((xLog - xPhys) - xShrink);
            xShrink += (xLog - xPhys) - xShrink;
        }
    }
    fRealTabs = fRealTabsOrig;
}





/*** ColorToLog - Change a line's color info from physical to logical
*
* Purpose:
*
*   This is the opposite of ColorToPhys.
*
* Input:
*   pla   - Physical color array
*   pText - Text to for conversion
*
* Output: None.
*
*************************************************************************/
void
ColorToLog (
    struct lineAttr * pla,
    char * pText
    )
{
    struct lineAttr * plaCur;
    COL     xLog, xPhys, xGrow;

    // We read through the color array, keeping
    // track of the phsyical column represented
    // by the color fields.  At each field, we ask
    // what logical column the end of the field
    // represents.  If the two columns differ,
    // we grow the current current field. The
    // amount to grow is the difference between
    // the columns less the amount we have already
    // shrunk.
    //
    for (plaCur = pla, xGrow = 0, xPhys = plaCur->len;
         plaCur->len != 0xFF;
         xPhys += (++plaCur)->len) {

        xLog = colPhys (pText, pText + xPhys);

        plaCur->len += (unsigned char)((xLog - xPhys) - xGrow);
        xGrow += (xLog - xPhys) - xGrow;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\untab.c ===
#include    <string.h>
#include	<stdlib.h>
#include    "mep.h"

extern int		fileTab;
extern flagType	fRealTabs;


/***************************************************************************\

MEMBER:     Untab

SYNOPSIS:   Expand tabs in line

ALGORITHM:  

ARGUMENTS:  int 	- number of characters per tab
	    const char* - pointer to source line
	    int 	- number of chars in source line
	    char*	- pointer to destination line
	    char	- replacement character for tab

RETURNS:    int     - length of untabbed line

NOTES:	    

HISTORY:    13-Jul-90 davegi
		Saved pDst and computed return value from it rather tha pDst
	    28-Jul-90 davegi
		Converted from 286 MASM
	    18-Mar-1992 markz
		Untab at most BUFLEN chars

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

int
Untab (
    int 	cbTab,
    const char*	pSrc,
    int 	cbSrc,
    char*	pDst,
    char	cTab
    )
{
    
    const char*	pSrcStart;
    const char* pDstStart;
    int         i;
    int 	ccTab;
    char	buffer[128];
    
    assert( pSrc );
    assert( pDst );

    if (( size_t )strlen(pSrc) != ( size_t ) cbSrc ) {
        sprintf(buffer, "\nWARNING: strlen(pSrc) [%d] != cbSrc [%d]\n", strlen(pSrc), cbSrc);
        OutputDebugString(buffer);
        sprintf(buffer, "File %s, line %d\n", __FILE__, __LINE__ );
        OutputDebugString(buffer);
        cbSrc = (int)strlen(pSrc);
    }

    // assert( strlen( pSrc ) >= ( size_t ) cbSrc );
    
    //  Short circuit...
    //  If there are no tabs in the source, copy the source to the destination
    //  and return the supplied number of characters in the source (destination)
    
    if( ! strchr( pSrc, '\t' )) {
        strcpy( pDst, pSrc );
        return cbSrc;
    }
    
    //  Remember where we started
    
    pSrcStart = pSrc;
    pDstStart = pDst;

    //  While we are not at the end of the source copy a character from the
    //  source to the destination
    
    while (*pSrc  && pDst < pDstStart + BUFLEN - 1) {
        if (( *pDst++ = *pSrc++ ) == '\t' ) {

                //  If the character copied was a tab, replace it with the
                //  appropriate number of cTab characters

                pDst--;
                ccTab = (int)(cbTab - (( pDst - pDstStart ) % cbTab ));

            for( i = 0; i < ccTab && pDst < pDstStart + BUFLEN - 1; i++ ) {
                    *pDst++ = cTab;
            }
	    }
	}

    *pDst = '\0';	// Terminating NUL
    
    //return strlen( pDstStart );
    return (int)(pDst - pDstStart);
}





/***************************************************************************\

MEMBER:     AlignChar

SYNOPSIS:   Get logical starting column of character

ALGORITHM:  

ARGUMENTS:  COL 	-
	    const char*	-

RETURNS:    COL	    - starting column of character

NOTES:	    

HISTORY:
		03-Jul-91 ramonsa
		re-converted from 286 MASM
		20-Aug-90 davegi
		Return the supplied column when end of buffer is reached
	    14-Aug-90 davegi
		Return supplied column when it's passed the end of the buf
	    28-Jul-90 davegi
		Converted from 286 MASM\

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

COL
AlignChar (
	COL			col,
    const char*	buf
    )
{
	register	int		CurCol;
	register	int		NextCol;
				int 	NewCurCol;
				char	Char;


	CurCol = col;

	//
	//	If we are not using real tabs, we just return supplied column,
	//	otherwise we figure out the column position.
	//
	if ( fRealTabs ) {

		NextCol = 0;

		while ( NextCol <= col ) {

			Char = *buf++;

			if ( Char == '\0' ) {
				//
				//	Reached end of file, return the supplied column
				//
				CurCol = col;
				break;
			}

			CurCol = NextCol;

			if ( Char == '\t' ) {

				NewCurCol = NextCol;

				CurCol += fileTab;

				NextCol = CurCol - ( CurCol % fileTab);

				CurCol = NewCurCol;

			} else {

				NextCol++;

			}
		}
	}

	return CurCol;

}




/***************************************************************************\

MEMBER:     pLog

SYNOPSIS:   Return a physical pointer given a logical offset

ALGORITHM:  

ARGUMENTS:  

RETURNS:    char*	- pointer into pBuf

NOTES:	    This is a many to one mapping due to tabs. That is, many logical
	    offsets may point to the same physical pointer if they point
	    to within a fileTab of a tab character.

HISTORY:    13-Aug-90 davegi
		Fixed return value when no tabs are present in line
		Fixed return value when first char is a tab
	    10-Aug-90 davegi
		Fixed return value when xOff is negative
	    28-Jul-90 davegi
		Converted from 286 MASM

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

char*
pLog (
    char*       pBuf,
    int 	xOff,
    flagType	fBound
    )
{
    
    REGISTER char *pLast;
    REGISTER int   cbpBuf;
    int            cbpBufNext;
    
    assert( pBuf );
    
    //  If xOff is 0 return pBuf

    if( xOff == 0 ) {
        return pBuf;
    }

    //  If xOff is negative return pBuf - 1

    if( xOff < 0 ) {
	return pBuf - 1;
    }

    //  If we're not using real tabs, return the physical pointer which is
    //  at the (possibly bounded) logical offset
    
    if( ! fRealTabs ) {
        
        //  If required, bound the return value by the line length
   
        if( fBound ) {
            xOff = min(( size_t ) xOff, strlen( pBuf ));
        }
 
	return ( char* ) &( pBuf[ xOff ]);
    }

    if( ! strchr( pBuf, '\t' )) {

        //  If xOff is past the end of the line,
        //  return the physical pointer which is at the (possibly bounded)
        //  logical offset

        if( xOff > ( cbpBuf = strlen( pBuf ))) {
            if( fBound ) {
                xOff = cbpBuf;
            }
        }
        return ( char* ) &( pBuf[ xOff ]);
    }


    //  pLast:   last physical position in buffer;
    //  cbpBuf:  Last LOGICAL offset within buffer;
    //  cbpNext: Next LOGICAL offset within buffer
    //           (i.e. cbpBuf + tab)


    pLast  = pBuf;
    cbpBuf = 0;
    while (pBuf = strchr(pBuf, '\t')) {
        cbpBuf += (int)(pBuf - pLast);
        if (xOff < cbpBuf) {
            /*
             *  We're past the wanted column. Adjust and return
             *  pointer.
             */
            cbpBuf -= (int)(pBuf - pLast);
            return (char *)pLast + xOff - cbpBuf;
        }
        cbpBufNext = cbpBuf + fileTab -  (cbpBuf + fileTab)%fileTab;
        if ((cbpBuf <= xOff) && (xOff < cbpBufNext)) {
            /*
             *  Wanted column lies within this tab. return current
             *  position.
             */
            return (char *)pBuf;
        }
        pLast = ++pBuf;             // Skip this tab and continue
        cbpBuf  = cbpBufNext;
    }

    //  No more tabs in buffer. If wanted column is past the end of the
    //  buffer, return pointer based on fBound. Otherwise the
    //  physical column is (xOff - cbpBuf) positions from pLast.

    pBuf = pLast + strlen(pLast);
    cbpBufNext = (int)(cbpBuf + pBuf - pLast);
    if (xOff > cbpBufNext) {
        if (fBound) {
            return (char *)pBuf;
        }
    }
    return (char *)pLast + xOff - cbpBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\transkey.c ===
/*** transkey.c - keyboard translation
*
*   Copyright <C> 1988, Microsoft Corporation
*
* Revision History:
*
*       03-Dec-1990 ramonsa     createdc
*
*************************************************************************/

//#define INCL_DOSSEMAPHORES
#include "mep.h"
#include "keyboard.h"
#include "keys.h"
#include "cmds.h"


WORD  GetNumlockIndex (WORD Scan);




#define NORMAL_KEY     0
#define ALT_KEY        1
#define CTRL_KEY       2
#define SHIFT_KEY      3


//      This table is indexed by a Scan code (as found in the KBDKEY
//  structure), and contains entries for the corresponding internal
//  MEP codes.
//
WORD   MapTable[][4] = {

    //  Normal  Alt     Ctrl    Shift               Scan code
    //
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  00
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  01     Left mouse
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  02     Right mouse
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  03
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  04
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  05
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  06
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  07
    {   0x012D, 0x01A1, 0x0215,  0x0255  },      //  08     bksp
	{	0x012E, 0x01A2, 0x0216,  0x0256	 },		 //	 09		tab-bktab
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0B
    {   0x0116, 0x018A, 0x01FE,  0x0000  },      //  0C     goto
    {   0x0131, 0x01A5, 0x0219,  0x0259  },      //  0D     enter
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  0F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  10     Shift
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  11     Ctrl
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  12
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  13     Pause
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  14     Caps Lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  15
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  16
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  17
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  18
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  19
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1A
    {   0x0130, 0x0000, 0x0218,  0x0258  },      //  1B     esc
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  1F
    {   0x0000, 0x01A0, 0x0214,  0x0000  },      //  20     space
    {   0x0112, 0x0186, 0x01FA,  0x023A  },      //  21     pgup
    {   0x0113, 0x0187, 0x01FB,  0x023B  },      //  22     pgdown
    {   0x010D, 0x0181, 0x01F5,  0x0235  },      //  23     end
    {   0x010C, 0x0180, 0x01F4,  0x0234  },      //  24     home
    {   0x010E, 0x0182, 0x01F6,  0x0236  },      //  25     left
    {   0x0110, 0x0184, 0x01F8,  0x0238  },      //  26     up
    {   0x010F, 0x0183, 0x01F7,  0x0237  },      //  27     right
    {   0x0111, 0x0185, 0x01F9,  0x0239  },      //  28     down
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  29
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2C     Print Scrn
    {   0x0114, 0x0188, 0x01FC,  0x023C  },      //  2D     ins
    {   0x0115, 0x0189, 0x01FD,  0x023D  },      //  2E     del
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  2F
    {   0x0000, 0x0140, 0x01B4,  0x0000  },      //  30     0
    {   0x0000, 0x0141, 0x01B5,  0x0000  },      //  31     1
    {   0x0000, 0x0142, 0x01B6,  0x0000  },      //  32     2
    {   0x0000, 0x0143, 0x01B7,  0x0000  },      //  33     3
    {   0x0000, 0x0144, 0x01B8,  0x0000  },      //  34     4
    {   0x0000, 0x0145, 0x01B9,  0x0000  },      //  35     5
    {   0x0000, 0x0146, 0x01BA,  0x0000  },      //  36     6
    {   0x0000, 0x0147, 0x01BB,  0x0000  },      //  37     7
    {   0x0000, 0x0148, 0x01BC,  0x0000  },      //  38     8
    {   0x0000, 0x0149, 0x01BD,  0x0000  },      //  39     9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  3F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  40
    {   0x0000, 0x014C, 0x01C0,  0x0000  },      //  41     a
    {   0x0000, 0x014D, 0x01C1,  0x0000  },      //  42     b
    {   0x0000, 0x014E, 0x01C2,  0x0000  },      //  43     c
    {   0x0000, 0x014F, 0x01C3,  0x0000  },      //  44     d
    {   0x0000, 0x0150, 0x01C4,  0x0000  },      //  45     e
    {   0x0000, 0x0151, 0x01C5,  0x0000  },      //  46     f
    {   0x0000, 0x0152, 0x01C6,  0x0000  },      //  47     g
    {   0x0000, 0x0153, 0x01C7,  0x0000  },      //  48     h
    {   0x0000, 0x0154, 0x01C8,  0x0000  },      //  49     i
    {   0x0000, 0x0155, 0x01C9,  0x0000  },      //  4A     j
    {   0x0000, 0x0156, 0x01CA,  0x0000  },      //  4B     k
    {   0x0000, 0x0157, 0x01CB,  0x0000  },      //  4C     l
    {   0x0000, 0x0158, 0x01CC,  0x0000  },      //  4D     m
    {   0x0000, 0x0159, 0x01CD,  0x0000  },      //  4E     n
    {   0x0000, 0x015A, 0x01CE,  0x0000  },      //  4F     o
    {   0x0000, 0x015B, 0x01CF,  0x0000  },      //  50     p
    {   0x0000, 0x015C, 0x01D0,  0x0000  },      //  51     q
    {   0x0000, 0x015D, 0x01D1,  0x0000  },      //  52     r
    {   0x0000, 0x015E, 0x01D2,  0x0000  },      //  53     s
    {   0x0000, 0x015F, 0x01D3,  0x0000  },      //  54     t
    {   0x0000, 0x0160, 0x01D4,  0x0000  },      //  55     u
    {   0x0000, 0x0161, 0x01D5,  0x0000  },      //  56     v
    {   0x0000, 0x0162, 0x01D6,  0x0000  },      //  57     w
    {   0x0000, 0x0163, 0x01D7,  0x0000  },      //  58     x
    {   0x0000, 0x0164, 0x01D8,  0x0000  },      //  59     y
    {   0x0000, 0x0165, 0x01D9,  0x0000  },      //  5A     z
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  5F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  60
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  61
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  62
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  63
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  64
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  65
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  66
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  67
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  68
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  69
    {   0x0126, 0x019A, 0x020E,  0x024E  },      //  6A     num*
    {   0x0125, 0x0199, 0x020D,  0x024D  },      //  6B     num+
    {   0x0128, 0x019C, 0x0210,  0x0250  },      //  6C     numenter
    {   0x0124, 0x0198, 0x020C,  0x024C  },      //  6D     num-
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  6E
    // {   0x0000, 0x017E, 0x01F2,  0x0000  },      //  ??     /
    {   0x0127, 0x019b, 0x020F,  0x024F  },      //  6F     num/
    {   0x0100, 0x0168, 0x01DC,  0x0228  },      //  70     f1
    {   0x0101, 0x0169, 0x01DD,  0x0229  },      //  71     f2
    {   0x0102, 0x016A, 0x01DE,  0x022A  },      //  72     f3
    {   0x0103, 0x016B, 0x01DF,  0x022B  },      //  73     f4
    {   0x0104, 0x016C, 0x01E0,  0x022C  },      //  74     f5
    {   0x0105, 0x016D, 0x01E1,  0x022D  },      //  75     f6
    {   0x0106, 0x016E, 0x01E2,  0x022E  },      //  76     f7
    {   0x0107, 0x016F, 0x01E3,  0x022F  },      //  77     f8
    {   0x0108, 0x0170, 0x01E4,  0x0230  },      //  78     f9
    {   0x0109, 0x0171, 0x01E5,  0x0231  },      //  79     f10
    {   0x010A, 0x0172, 0x01E6,  0x0232  },      //  7A     f11
    {   0x010B, 0x0173, 0x01E7,  0x0233  },      //  7B     f12
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  7F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  80
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  81
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  82
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  83
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  84
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  85
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  86
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  87
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  88
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  89
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  8F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  90     Num lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  91     Scroll Lock
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  92
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  93
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  94
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  95
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  96
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  97
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  98
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  99
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9A
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9B
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9C
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9D
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9E
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  9F
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  A9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AA
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AB
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AC
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AD
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AE
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  AF
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  B9
    {   0x0000, 0x017A, 0x01EE,  0x0000  },      //  BA     ;
	{	0x0000, 0x0176, 0x01EA,	 0x0000	 },		 //	 BB		+
    {   0x0000, 0x017C, 0x01F0,  0x0000  },      //  BC     ,
    {   0x0000, 0x0175, 0x01E9,  0x0000  },      //  BD     -
    {   0x0000, 0x017D, 0x01F1,  0x0000  },      //  BE     .
    {   0x0000, 0x017E, 0x01F2,  0x0000  },      //  BF     /
    {   0x0000, 0x0174, 0x01E8,  0x0000  },      //  C0     `
    {   0x0000, 0x017B, 0x01EF,  0x0000  },      //  C1     '
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  C9
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CA
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CB
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CC
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CD
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CE
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  CF
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D0
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D1
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D2
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D3
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D4
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D5
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D6
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D7
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D8
    {   0x0000, 0x0000, 0x0000,  0x0000  },      //  D9
	{	0x0000, 0x0000, 0x0000,  0x0000  },		 //	 DA
	{	0x0000, 0x0177, 0x01EB,  0x0000  },		 //	 DB		[
	{	0x0000, 0x0179, 0x01ED,  0x0000  },		 //	 DC	   backslash
    {   0x0000, 0x0178, 0x01EC,  0x0000  },      //  DD     ]
    {   0x0000, 0x017B, 0x01EF,  0x0000  },      //  DE     '
    {   0x0000, 0x0176, 0x01EA,  0x0000  },      //  DF     =
};

#define LAST_SCAN       0xDF


//      This table contains entries for codes when NUMLOCK is on,
//  it is not indexed by scan code, but by an index obtain thru the
//  function GetNumlockIndex function.
//
WORD   MapNumlockTable[][4] = {
    //  Special Alt     Ctrl    Shift               Index   Key
	//
    {   0x0118, 0x018C, 0x0200,  0x0240  },      //    0    num0
    {   0x0119, 0x018D, 0x0201,  0x0241  },      //    1    num1
    {   0x011A, 0x018E, 0x0202,  0x0242  },      //    2    num2
    {   0x011B, 0x018F, 0x0203,  0x0243  },      //    3    num3
    {   0x011C, 0x0190, 0x0204,  0x0244  },      //    4    num4
    {   0x011D, 0x0191, 0x0205,  0x0245  },      //    5    num5
    {   0x011E, 0x0192, 0x0206,  0x0246  },      //    6    num6
    {   0x011F, 0x0193, 0x0207,  0x0247  },      //    7    num7
    {   0x0120, 0x0194, 0x0208,  0x0248  },      //    8    num8
    {   0x0121, 0x0195, 0x0209,  0x0249  },      //    9    num9
    {   0x0124, 0x0198, 0x020C,  0x024C  },      //   10    num-
    {   0x0125, 0x0199, 0x020D,  0x024D  },      //   11    num+
    {   0x0126, 0x019A, 0x020E,  0x024E  },      //   12    num*
    {   0x0127, 0x019B, 0x020F,  0x024F  },      //   13    num/
	{	0x0128, 0x019C, 0x0210,  0x0250  }, 	 //   14	numenter

	{	0x0000, 0x0000, 0x0000,  0x0000  }		 //   15



};

#define NUMLOCK_NOMAP	((WORD)(-1))


/*** TranslateKey
*
* Purpose:
*
*       Translates a KBDKEY structure into a KEY_INFO structure.
*
*       This is the only function within the editor that knows about
*   the scan codes in the KBDKEY structure. All other editor functions
*   use our own codes (as found in the KEY_INFO structure).
*
* Input:
*       KBDKEY  structure
*
* Returns
*       KEY_INFO structure
*
*
*************************************************************************/

EDITOR_KEY
TranslateKey (
    KBDKEY  kbdi
    ) {

    BYTE            Ascii   =   (BYTE)kbdi.Unicode;
    BYTE            Scan    =   (BYTE)kbdi.Scancode;
    BYTE            Flags   =   0x00;

    DWORD           KbdiFlags   =   kbdi.Flags;

    EDITOR_KEY      k;
    WORD            MepCode     = 0;
	WORD			ControlKey  = 0;
	WORD			Index;


    if (Scan <= LAST_SCAN) {

        if (KbdiFlags & (CONS_LEFT_ALT_PRESSED | CONS_RIGHT_ALT_PRESSED)) {
            Flags       |= FLAG_ALT;
            ControlKey  = ALT_KEY;
        }

        if (KbdiFlags & (CONS_LEFT_CTRL_PRESSED | CONS_RIGHT_CTRL_PRESSED)) {
            Flags       |= FLAG_CTRL;
            //Ascii       &= 0x0F;
            if ( !ControlKey ) {
                ControlKey = CTRL_KEY;
            } else {
                //
                // Foreign keyboard stuff
                //
                if ( Ascii != 0x00 ) {
                    Flags   = 0;
                    ControlKey = 0;
                }
            }
        }

        if (KbdiFlags & CONS_SHIFT_PRESSED) {
            Flags     |= FLAG_SHIFT;
            if ( !ControlKey ) {
                ControlKey  = SHIFT_KEY;
            }
        }


		if (KbdiFlags & CONS_NUMLOCK_PRESSED) {

            Flags |= FLAG_NUMLOCK;

			//
			//	Numlock is set, determine which table to use
			//
			Index = GetNumlockIndex(Scan);

            if (Index == NUMLOCK_NOMAP) {
                //
                //  Key not affected by Numlock, use normal table
                //
                MepCode  = MapTable[Scan][ControlKey];
            } else {
                //
                //  Key is affected by Numlock, use special table
                //
                MepCode   = MapNumlockTable[Index][ControlKey];
            }
        } else {
            //
            //  Numlock not set, use normal table
            //
            MepCode  = MapTable[Scan][ControlKey];
        }
    }

    k.KeyInfo.KeyData.Ascii     =   Ascii;
    k.KeyInfo.KeyData.Scan      =   Scan;
    k.KeyInfo.KeyData.Flags     =   Flags;
    k.KeyInfo.KeyData.Unused    =   0x00;

    if (MepCode) {
        //
        //  Found an MEP code
        //
        k.KeyCode   =   MepCode;
    } else {
        //
        //  Our scan code is within the 256 ASCII characters, form the
        //  KEY_INFO structure and return.
        //
        k.KeyCode   =   Ascii;
    }

    return k;
}





WORD
GetNumlockIndex (
    WORD Scan
    )
{
    switch (Scan) {
        case 0x60:    return 0;      //  num0
        case 0x61:    return 1;      //  num1
        case 0x62:    return 2;      //  num2
        case 0x63:    return 3;      //  num3
        case 0x64:    return 4;      //  num4
        case 0x65:    return 5;      //  num5
        case 0x66:    return 6;      //  num6
        case 0x67:    return 7;      //  num7
        case 0x68:    return 8;      //  num8
        case 0x69:    return 9;      //  num9
        case 0x6D:    return 10;     //  num-
        case 0x6B:    return 11;     //  num+
        case 0x6A:    return 12;     //  num*
        case 0x6F:    return 13;     //  num/
        case 0x6C:    return 14;     //  numenter
        default:      return NUMLOCK_NOMAP;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\window.c ===
/**** window.c - window movement commands
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"

#define DEBFLAG WINDOW


void
saveflip (
    void
    )
{
    XOLDCUR(pInsCur) = XCUR(pInsCur);
    YOLDCUR(pInsCur) = YCUR(pInsCur);
    XOLDWIN(pInsCur) = XWIN(pInsCur);
    YOLDWIN(pInsCur) = YWIN(pInsCur);
}





void
restflip (
    void
    )
{
    doscreen( XOLDWIN(pInsCur), YOLDWIN(pInsCur),
	      XOLDCUR(pInsCur), YOLDCUR(pInsCur) );
}





void
movewin (
    COL  x,
    LINE y
    )
{
    doscreen( x, y, XCUR(pInsCur), YCUR(pInsCur) );
}





flagType
setwindow (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    switch (pArg->argType) {

    case NOARG:
	if (fMeta) {
            soutb (0, (int)(YCUR(pInsCur)-YWIN(pInsCur)), rgchEmpty, fgColor);
	    redraw (pFileHead, YCUR(pInsCur), YCUR(pInsCur));
	    SETFLAG( fDisplay, RCURSOR );
        } else {
	    newscreen ();
	    SETFLAG( fDisplay, RSTATUS | RCURSOR );
        }
        return TRUE;

    /*  TEXTARG illegal             */

    case NULLARG:
	movewin (XCUR(pInsCur), YCUR(pInsCur));
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData;
}




flagType
plines (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
	movewin (XWIN(pInsCur), YWIN(pInsCur) + YSCALE (vscroll));
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
	if (fIsNum (mbuf)) {
	    movewin ( XWIN(pInsCur), YWIN(pInsCur) + atol (mbuf));
	    return TRUE;
        } else {
            return BadArg ();
        }

    case NULLARG:
	movewin( XWIN(pInsCur), YCUR(pInsCur) );
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData; fMeta;
}




flagType
mlines (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer mbuf;

    switch (pArg->argType) {

    case NOARG:
	movewin (XWIN(pInsCur), YWIN(pInsCur) - YSCALE (vscroll));
        return TRUE;

    case TEXTARG:
	strcpy ((char *) mbuf, pArg->arg.textarg.pText);
	if (fIsNum (mbuf)) {
	    movewin (XWIN(pInsCur), YWIN(pInsCur) - atol (mbuf));
	    return TRUE;
        } else {
            return BadArg ();
        }

    case NULLARG:
	movewin (XWIN(pInsCur), YCUR(pInsCur)-(WINYSIZE(pWinCur)-1));
        return TRUE;

    /*	LINEARG illegal 	    */
    /*	STREAMARG illegal	    */
    /*  BOXARG illegal              */

    }

    return FALSE;

    argData; fMeta;
}





/*
 * <window>		Move to next window
 * <arg><window>	split window horizontal
 * <arg><arg><window>	split window vertical
 * <meta><window>	close/merge current window
 *
 * CW: needs this hack
 * <arg><meta><window>	Move to previous window
 */
flagType
window (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int i, v;
    flagType fVert = TRUE;

    v = TRUE;

    switch (pArg->argType) {

    case NOARG:
	/* change current window */
	if (cWin != 1) {
	    if (fMeta) {
		/*  <meta><window> - close current window.  Scan for window
		 *  that is adjacent to iCurWin
		 */
		if (!WinClose (iCurWin)) {
		    printerror ("Cannot close this window");
		    return FALSE;
                }
            } else {
		/* select next window */
                iCurWin = (iCurWin + 1) % cWin;
            }

	    v = SetWinCur (iCurWin);
        } else {
            v = FALSE;
        }
        break;

    case NULLARG:
	if (cWin == MAXWIN) {
	    printerror ("Too many windows");
	    return FALSE;
        }

	if (pArg->arg.nullarg.cArg == 1) {
	    i = pArg->arg.nullarg.y - YWIN (pInsCur);
	    fVert = FALSE;
        } else {
            i = pArg->arg.nullarg.x - XWIN(pInsCur);
        }

        if (!SplitWnd (pWinCur, fVert, i)) {
            return FALSE;
        }

        // docursor (XWIN(pInsCur), YWIN(pInsCur));
	break;
    }

    newscreen ();
    SETFLAG (fDisplay, RCURSOR|RSTATUS);
    DoDisplay();
    return (flagType)v;

    argData;
}





/*** SplitWnd - Creates a new window by splitting an existing window
*
* Purpose:
*
*   When the user asks to split a window, this is called.  It does
*   everything after the split location is known.
*
* Input:
*   Parameters:
*	pWnd	->  Window to split
*       fVert   ->  TRUE for vertical split, FALSE for horizontal
*	pos	->  Window relative offset to split at
*
*   Globals:
*	fZoomed -> To prevent splitting a zoomed window
*
* Output:
*
*   Returns TRUE if we split, FALSE otherwise.
*
*************************************************************************/
flagType
SplitWnd (
    PWND    pWnd,
    flagType fVert,
    int     pos
    )
{
    PINS    pInsTmp;
    PINS    pInsNext;
    struct windowType winTmp;
    LINE    Line, LineWin;
    LINE    NewLineWin;
    COL     Col;

    winTmp      = *pWnd;
    Line        = YCUR(pInsCur);
    Col         = XCUR(pInsCur);
    LineWin     = YWIN(pInsCur);
    NewLineWin  = (Line == 0) ? Line : Line - 1;

    if (!fVert) {
        if (pos < 5 || WINYSIZE(pWnd) - pos < 5) {
            printerror ("Window too small to split");
            return FALSE;
        }

        /*
         * new y size is remainder of window
         * old y size is reduced by the new window and separator
         * new y position is just below new separator
         */
        YWIN(pInsCur)   = NewLineWin;
        winTmp.Size.lin = WINYSIZE(pWnd) - pos - 2;
        WINYSIZE(pWnd) -= winTmp.Size.lin + 1;
        winTmp.Pos.lin  = WINYPOS(pWnd) + WINYSIZE(pWnd) + 1;

    } else {
        if (pos < 10 || WINXSIZE(pWnd) - pos < 10) {
            printerror ("Window too small to split");
            return FALSE;
        }

        YWIN(pInsCur) = NewLineWin;
        newwindow ();
        winTmp.Size.col = WINXSIZE(pWnd) - pos - 2;
        WINXSIZE(pWnd) -= winTmp.Size.col + 1;
        winTmp.Pos.col  = WINXPOS(pWnd) + WINXSIZE(pWnd) + 1;
    }

    //
    // Allocate and set up the new current instance for this window.
    // Set the new cursor position to home
    //
    pInsTmp = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
    *pInsTmp = *pInsCur;

    winTmp.pInstance = pInsTmp;

    //
    // Walk the old instance list, and copy it to the new instance list
    //
    pInsNext = pInsCur;
    while (pInsNext = pInsNext->pNext) {
        pInsTmp->pNext = (PINS) ZEROMALLOC (sizeof (*pInsTmp));
        pInsTmp = pInsTmp->pNext;
        *pInsTmp = *pInsNext;
    }
    pInsTmp->pNext = NULL;
    WinList[cWin++] = winTmp;
    IncFileRef (pFileHead);
    SortWin ();
    YCUR(pInsCur) = Line;
    XCUR(pInsCur) = Col;
    YWIN(pInsCur) = LineWin;
    return TRUE;
}





/*  SortWin - sort window list based upon position on screen
 */
void
SortWin (
    void
    )
{
    struct windowType winTmp;
    int i, j;

    for (i = 0; i < cWin; i++) {
        for (j = i+1; j < cWin; j++) {
	    if (WinList[j].Pos.lin < WinList[i].Pos.lin ||
		(WinList[j].Pos.lin == WinList[i].Pos.lin &&
		 WinList[j].Pos.col < WinList[i].Pos.col)) {
                if (iCurWin == i) {
                    pWinCur = &WinList[iCurWin = j];
                }
		winTmp = WinList[i];
		WinList[i] = WinList[j];
		WinList[j] = winTmp;
            }
        }
    }
}






/* SetWinCur - Set current window
 *
 * Entry:
 *  iWin	= index to new current window.
 */
flagType
SetWinCur (
    int     iWin
    )
{
    iCurWin = iWin;
    pWinCur = &WinList[iWin];
    pInsCur = pWinCur->pInstance;

    /*
     * If we cannot change to the current file, we will walk the window instance
     * list until we get a valid file. If no one can be loaded then we switch to
     * the <untitled> pseudo-file.
     * NB: fChangeFile does a RemoveTop so we don't need to move pInsCur
     */
    while ((pInsCur != NULL) && (!fChangeFile (FALSE, pInsCur->pFile->pName))) {
        ;
    }

    if (pInsCur == NULL) {
        fChangeFile (FALSE, rgchUntitled);
    }
    return (flagType)(pInsCur != NULL);
}





/*  Adjacent - return true if two windows are adjacent to each other
 *
 *  Adjacent returns true if window i is to the left or above window j
 *  and exactly matches some size attributes
 */
flagType
Adjacent (
    int i,
    int j
    )
{
    REGISTER PWND pWini = &WinList[i];
    REGISTER PWND pWinj = &WinList[j];

    if (WINYSIZE(pWini) == WINYSIZE(pWinj) &&
	WINYPOS(pWini)	== WINYPOS(pWinj)  &&
	(WINXPOS(pWini) + WINXSIZE(pWini) + 1 == WINXPOS(pWinj) ||
         WINXPOS(pWinj) + WINXSIZE(pWinj) + 1 == WINXPOS(pWini))) {
	return TRUE;
    } else {
	return (flagType)
	   (WINXSIZE(pWini) == WINXSIZE(pWinj) &&
	    WINXPOS(pWini)  == WINXPOS(pWinj) &&
	    (WINYPOS(pWini) + WINYSIZE(pWini) + 1 == WINYPOS(pWinj) ||
             WINYPOS(pWinj) + WINYSIZE(pWinj) + 1 == WINYPOS(pWini)));
    }
}






/*  WinClose - close a window.
 *
 *  We walk the entire window list trying to find another window that
 *  is adjacent to the specified window.  When found, we free all data relevant
 *  to the specified window and expand the found window to encompass the
 *  new region.
 *
 *  j		window to be closed
 *
 *  returns	TRUE iff window was closed
 */
flagType
WinClose (
    int j
    )
{
    PINS pInsTmp;
    PINS pInsNext;
    REGISTER PWND pWini;
    REGISTER PWND pWinj = &WinList[j];
    int i;

    /*	Find adjacent window
     */
    for (i = 0; i < cWin; i++) {
        if (Adjacent (i, j)) {
            break;
        }
    }

    /*	No adjacent window found
     */
    if (i == cWin) {
        return FALSE;
    }

    pWini = &WinList[i];

    /*	Free up all those instances
     */
    pInsTmp = pWinj->pInstance;
    while (pInsTmp != NULL) {

        /*
         * we decrement the ref count here, without using DecFileRef, so that the file
         * will NOT be removed by having a zero reference count. This allows it to
         * live, unreferenced, in the file list, even if it is dirty. That allows us
         * to close any window that has dirty files associated with it.
         */
	pInsTmp->pFile->refCount--;
	pInsNext = pInsTmp;
	pInsTmp = pInsTmp->pNext;
        FREE ((char *) pInsNext);
    }

    /*	Expand pWini to encompass pWinj
     */
    if (WINYPOS(pWinj) == WINYPOS(pWini)) {
	WINXSIZE(pWini) += WINXSIZE(pWinj) + 1;
    } else {
        WINYSIZE(pWini) += WINYSIZE(pWinj) + 1;
    }
    WINXPOS(pWini) = min (WINXPOS(pWinj), WINXPOS(pWini));
    WINYPOS(pWini) = min (WINYPOS(pWinj), WINYPOS(pWini));
    memmove ((char *)&WinList[j], (char *)&WinList[j+1], (cWin-j-1) * sizeof (WinList[0]));
    if (i > j) {
        i--;
    }
    pWinCur = &WinList[iCurWin = i];
    cWin--;
    SortWin ();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\undo.c ===
/*** Undo.c - handle all undo operations for editor
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   N-level undo/redo:
*
*   For each file, keep a d-linked list of edit records in VM, head / tail /
*   current pointers into this list, and a count of "boundaries" between
*   undo-able edit operations. When that count exceeds "cUndo", we move excess
*   records from the tail of the undo list to a dead-record list, for eventual
*   discard.
*
*   Freeing or rereading a file flushes its undo list.
*
*   There are 4 types of undo records:
*
*   Putline logs a "replace" record
*	line
*	va of old line
*   No optimization for recycling same space
*   Optimization for replacing same line
*
*   Insline logs an "insert" record
*	line
*	number of lines inserted
*
*   Delline logs a "delete" record
*	line
*	number deleted
*	VAs of deleted lines
*
*   Top loop logs "boundary" records
*	file flags
*	file modification time
*	window position
*	cursor position
*   Optimization of entering boundary on top of boundary
*   Top loop also contains an optimization to prevent boundaries between
*   graphic functions.
*
*   UNDO moves backwards in the undo list, reversing the effects of each record
*   logged until a boundary is encountered.
*
*   REDO moves forwards in the undo list, repeating the effects of each record
*   logged.
*
*   After an UNDO or REDO, the next record logging will cause the undo records
*   from the current position forward to be moved to the dead-record list for
*   eventual discard.
*
*   Discarding of dead records occurs durring the system idle loop, or when an
*   out-of-memory condition ocurrs.
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"



#define HEAD	    TRUE
#define TAIL	    FALSE

#define LINEREC(va,l)  ((PBYTE)(va)+sizeof(LINEREC)*((long)(l)))
#define COLORREC(va,l) ((PBYTE)(va)+sizeof(struct colorRecType)*((long)(l)))

#if defined (DEBUG)

	#define DUMPIT(x,y)   UNDODUMP(x,y)

	void
	UNDODUMP (
		PVOID	vaCur,
		char	*Stuff
		);

#else

	#define DUMPIT(x,y)

#endif


PVOID   vaDead = (PVOID)-1L;                   /* head of dead undo list       */



/*
 * UNDO record definitions.
 * NOTE: these records are duplicated in a less complete form in EXT.H for
 * extension users. BE SURE to change them there if you EVER change them
 */
struct replaceRec {
	int	op;			/* operation				*/
	PVOID	flink;			/* editor internal			*/
	PVOID	blink;			/* editor internal			*/
	LINE	length; 		/* length of replacement	*/
	LINE	line;			/* start of replacement 	*/
	LINEREC vLine;			/* text of line 			*/
	struct	colorRecType vColor;	/* color of line			*/
	PVOID	vaMarks;		/* marks attached to line	*/
    };

struct insertRec {
	int	op;			/* operation				*/
	PVOID	flink;			/* editor internal			*/
	PVOID	blink;			/* editor internal			*/
    LINE    length;
	LINE	line;			/* line number that was operated on */
	LINE	cLine;			/* number of lines inserted			*/
    };

struct deleteRec {
	int	op;			/* operation			*/
	PVOID	flink;			/* editor internal		*/
	PVOID	blink;			/* editor internal		*/
    LINE    length;
	LINE	line;			/* line number that was operated on */
	LINE	cLine;			/* Number of lines deleted			*/
	PVOID	vaLines;		/* editor internal					*/
	PVOID	vaColor;		/* Color of lines					*/
	PVOID	vaMarks;		/* marks attached to lines			*/
    };

struct boundRec {
	int	op;			/* operation (BOUND)			*/
	PVOID	flink;			/* editor interal				*/
	PVOID	blink;			/* editor interal				*/
	int	flags;			/* flags of file				*/
	time_t	modify; 		/* Date/Time of last modify		*/
	fl	flWindow;		/* position in file of window	*/
	fl	flCursor;		/* position in file of cursor	*/
    };

union Rec {
    struct replaceRec r;
    struct insertRec  i;
    struct deleteRec  d;
    struct boundRec   b;
    };



/*** CreateUndoList - initialize undo list for a file.
*
*  Allocate the doubly-linked undo list with a single boundary record. Also
*  clears any existing list.
*
* Input:
*  pFile	= file to operate on
*
*************************************************************************/
void
CreateUndoList (
    PFILE pFile
    )
{
	struct boundRec *boundary;

	RemoveUndoList (pFile);

	if (!(FLAGS(pFile) & READONLY)) {

        pFile->vaUndoCur = pFile->vaUndoHead = pFile->vaUndoTail
			= MALLOC ((long)sizeof (union Rec));

		boundary = (struct boundRec *)(pFile->vaUndoHead);

		boundary->op			= EVENT_BOUNDARY;
		boundary->blink			= boundary->flink		 = (PVOID)(-1L);
		boundary->flWindow.col	= boundary->flCursor.col = 0;
		boundary->flWindow.lin	= boundary->flCursor.lin = 0L;
		boundary->flags			= FLAGS (pFile);

	}
}





/*** LinkAtHead - link a record in at the head of the undo queue
*
*  This is the routine which also discards any re-doable operations. When
*  called, if the "current" position is not at the head of the list, that
*  means we are adding a new editting operation, and we discard everything
*  between the head of the list and the current position, which becomes the
*  new head.
*
* Input:
*  vaNewHead	= new head of linked list
*  precNewHead	= pointer to the record itself
*  pFile	= file whose list we are mucking with
*
*************************************************************************/
void
LinkAtHead (
    PVOID     vaNewHead,
    union Rec *precNewHead,
    PFILE   pFile
    )
{
	EVTargs e;		   /* event notification parameters*/

    /*
     * Declare the event
     */
    e.arg.pUndoRec = precNewHead;
    DeclareEvent (EVT_EDIT, &e);

    /*
     * discard any records between current position and head of list
     */
	while (pFile->vaUndoCur != pFile->vaUndoHead) {

		if (((union Rec *)(pFile->vaUndoHead ))->b.op == EVENT_BOUNDARY) {
			pFile->cUndo--;
		}

		FreeUndoRec ( HEAD, pFile );
    }

    /*
     * Modify the current head of the list to point at the new head.
     */
	((union Rec *)(pFile->vaUndoHead))->b.flink = vaNewHead;

    /*
     * Update the links in the new head, and send it out
     */
	memmove(vaNewHead, (char *)precNewHead, sizeof (union Rec));

	((union Rec *)vaNewHead)->b.flink = (PVOID)(-1L);
	((union Rec *)vaNewHead)->b.blink = pFile->vaUndoHead;

    pFile->vaUndoCur = pFile->vaUndoHead = vaNewHead;

}





/*** LogReplace - log replace action
*
* Allocate (or update) a replace record.
*
* Input:
*  pFile	= file being changed
*  line 	= line being replaced
*  vLine	= linerec being replaced
*
*************************************************************************/
void
LogReplace (
    PFILE   pFile,
    LINE    line,
    LINEREC * pvLine,
    struct colorRecType * pvColor
    )
{
    EVTargs e;				/* event notification parameters*/
	union Rec *rec;
	union Rec rec1;
	PVOID vaReplace;

	if ( pFile->vaUndoHead == (PVOID)-1L) {
		CreateUndoList( pFile );
	}

	vaReplace = pFile->vaUndoHead;

	if (!(FLAGS(pFile) & READONLY)) {

		rec = (union Rec *)vaReplace;

		if ((rec->r.op == EVENT_REPLACE) && (rec->r.line == line)) {

            /*
             * Optimization for immediately replacing the same line in a file with no
             * intervening boundary or other operation. Discard the passed in "old" line,
             * and update the other data in the existing replace record.
			 */
			rec->r.length = pFile->cLines;
			e.arg.pUndoRec = rec;
			DeclareEvent (EVT_EDIT, &e);

			if (pvLine->Malloced) {
				pvLine->Malloced = FALSE;
				FREE(pvLine->vaLine);
				pvLine->vaLine = (PVOID)-1L;
            }

		} else {

            /*
             * if not optimizable, create new replace record
             */
			vaReplace	= MALLOC( (long)sizeof(union Rec) );

			memcpy( &rec1, rec, sizeof(rec1) );

			rec1.r.op		= EVENT_REPLACE;
			rec1.r.vLine	= *pvLine;
			rec1.r.line		= line;
			rec1.r.vColor	= *pvColor;
			rec1.r.vaMarks	= GetMarkRange (pFile, line, line);
			rec1.r.length	= pFile->cLines;
			LinkAtHead( vaReplace, &rec1, pFile );
        }
    }
}




/*** LogInsert - log line insertion
*
*  Add one EVENT_INSERT record to head of list
*
* Input:
*  pFile	= file being changed
*  line 	= line being inserted at
*  cLines	= number of lines being inserted
*
*************************************************************************/
void
LogInsert (
    PFILE   pFile,
    LINE    line,
    LINE    cLines
    )
{
	union Rec rec;
    PVOID     vaInsert;

	if (!(FLAGS(pFile) & READONLY)) {

		vaInsert	= MALLOC( (long)sizeof(union Rec) );

        rec.i.op    = EVENT_INSERT;
		rec.i.length= pFile->cLines;
		rec.i.line	= line;
		rec.i.cLine = cLines;
		LinkAtHead (vaInsert,&rec,pFile);

    }
}



/*** LogDelete - Log delete action
*
*  Add one EVENT_DELETE record to head of list
*
* Input:
*  pFile	= file being changed
*  start	= 1st line being deleted
*  end		= last line being deleted
*
*************************************************************************/
void
LogDelete (
    PFILE   pFile,
    LINE    start,
    LINE    end
    )
{
    union Rec rec;
    long      cLine;
    PVOID     vaDelete;

    if (!(FLAGS(pFile) & READONLY)) {

        cLine    = end - start + 1;
        vaDelete = MALLOC ((long) sizeof (union Rec));

        rec.d.op      = EVENT_DELETE;
		rec.d.length  = pFile->cLines;
		rec.d.line	  = start;
		rec.d.cLine   = cLine;
	rec.d.vaLines = MALLOC (cLine * sizeof (LINEREC));
        rec.d.vaMarks = GetMarkRange (pFile, start, end);

        memmove(rec.d.vaLines,
		LINEREC (pFile->plr, start),
		cLine * sizeof (LINEREC));

        if (pFile->vaColor != (PVOID)-1L &&
            (rec.d.vaColor = MALLOC (cLine * sizeof (struct colorRecType))) != NULL) {
            memmove(rec.d.vaColor,
                    COLORREC (pFile->vaColor, start),
                    cLine * sizeof (struct colorRecType));
        } else {
            rec.d.vaColor = (PVOID)-1;
        }

		LinkAtHead( vaDelete, &rec, pFile );
    }
}





/*** LogBoundary - note end of editor function
*
*  Add one EVENT_BOUNDARY record to head of list.  A boundary record signals
*  the end of a Z edit function. If count of undo operations on this file
*  exceeds the max allowed, move the overflow to the dead-record list for
*  eventual discard.
*
*  If a EVENT_BOUNDARY record is already at the head, do not add another. This
*  allows LogBoundary() to be called at the top loop without generating bogus
*  EVENT_BOUNDARY records.
*
*************************************************************************/
void
LogBoundary (
    void
    )
{
    union Rec rec;
    PVOID     vaBound;
    EVTargs   e;

    if (!(FLAGS(pFileHead) & READONLY)) {

		vaBound = pFileHead->vaUndoCur;

        memmove((char *)&rec, vaBound, sizeof (rec));

		rec.b.flags 		= FLAGS (pFileHead);
		rec.b.modify		= pFileHead->modify;
		rec.b.flWindow.col	= XWIN (pInsCur);
		rec.b.flWindow.lin	= YWIN (pInsCur);
		rec.b.flCursor.col	= XCUR (pInsCur);
		rec.b.flCursor.lin	= YCUR (pInsCur);

		if (rec.b.op != EVENT_BOUNDARY) {

            vaBound = MALLOC ((long) sizeof (rec));

			rec.b.op = EVENT_BOUNDARY;
			LinkAtHead( vaBound, &rec, pFileHead );

            (pFileHead->cUndo)++;

			while ( pFileHead->cUndo > cUndo ) {
                if (FreeUndoRec(TAIL,pFileHead) == EVENT_BOUNDARY) {
                    pFileHead->cUndo--;
                }
			}

		} else {

			e.arg.pUndoRec = &rec;
			DeclareEvent (EVT_EDIT, &e);
            memmove(vaBound, (char *) &rec.b, sizeof (rec.b));
        }
    }
}





/*** FreeUndoRec - move record to dead-record list
*
*  Pick off one record from the Head of the list, or the tail of the list and
*  place it in the dead-record list. Return the .op of the next undo record.
*
* Input:
*  fHead	= TRUE -> place at head of list
*  pFile	= file to work on
*
*************************************************************************/
int
FreeUndoRec (
    flagType fHead,
    PFILE    pFile
    )
{
    PVOID     vaNext;
    PVOID     vaRem;

    /*
     * Get the dead record, and move up the list (if at head), or truncate the list
     * if at tail.
     */
    vaRem = fHead ? pFile->vaUndoHead : pFile->vaUndoTail;

    if (fHead) {
        vaNext = pFile->vaUndoHead = ((union Rec *)vaRem)->b.blink;
    } else {
        vaNext = pFile->vaUndoTail = ((union Rec *)vaRem)->b.flink;
    }

    /*
     * Update the links in the newly exposed (head or tail) record.
     */
    if (fHead) {
        ((union Rec *)vaNext)->b.flink = (PVOID)-1;
    } else {
        ((union Rec *)vaNext)->b.blink = (PVOID)-1;
    }

    EnterCriticalSection(&UndoCriticalSection);
    /*
     * Update the removed record to properly live in the dead list
     */
    ((union Rec *)vaRem)->b.blink  = vaDead;
    vaDead          = vaRem;


    LeaveCriticalSection(&UndoCriticalSection);

	return ((union Rec *)vaNext)->b.op;
}





/*** UnDoRec - undo an editting action
*
*  Reverse the action of the current undo record for the file. Do not log the
*  change. Return the type of the next record.
*
* Input:
*  pFile	= file being operated on
*
*************************************************************************/
int
UnDoRec (
    PFILE   pFile
    )
{
	union Rec *rec;
    LINEREC vlCur;
    struct colorRecType vcCur;
    EVTargs e;				/* event notification params	*/

	rec = (union Rec *)(pFile->vaUndoCur);

	e.arg.pUndoRec = rec;
    DeclareEvent (EVT_UNDO, &e);

	switch (rec->b.op) {

    case EVENT_REPLACE:
        /*
         * Swap the line in the file with the line in the replace record.
         */
		memmove((char *)&vlCur,
				LINEREC (pFile->plr, rec->r.line),
				sizeof (vlCur));

		memmove(LINEREC (pFile->plr, rec->r.line),
			   (char *)&rec->r.vLine,
			   sizeof (rec->r.vLine));

        /* Do the same for the color.
         *
         */
		if (pFile->vaColor != (PVOID)-1L) {

            memmove((char *)&vcCur,
					COLORREC (pFile->vaColor, rec->r.line),
                    sizeof (vcCur));

			memmove(COLORREC (pFile->vaColor, rec->r.line),
					(char *)&rec->r.vColor,
					sizeof (rec->r.vColor));
        }

		rec->r.vLine = vlCur;
		pFile->cLines = rec->r.length;
		AckReplace( rec->r.line, TRUE );
		PutMarks( pFile, rec->r.vaMarks, rec->r.line );
		break;

    case EVENT_INSERT:
		/*	delete the blank(!) lines that are present
		 */
		DelLine( FALSE, pFile, rec->i.line, rec->i.line + rec->i.cLine - 1);
		pFile->cLines = rec->i.length;
		break;

    case EVENT_DELETE:
		/*	insert a range of blank lines
		 *	copy the linerecs from the stored location to the blank area
		 */
		InsLine( FALSE, rec->d.line, rec->d.cLine, pFile );
		memmove(LINEREC (pFile->plr, rec->d.line),
				rec->d.vaLines,
				(long)rec->d.cLine * sizeof (LINEREC));

		if (pFile->vaColor != (PVOID)-1L) {

			memmove(COLORREC (pFile->vaColor, rec->d.line),
					rec->d.vaColor,
					(long)rec->d.cLine * sizeof (struct colorRecType));
		}

		pFile->cLines = rec->d.length;
		PutMarks (pFile, rec->d.vaMarks, rec->d.line);
		break;
    }

	pFile->vaUndoCur = rec->i.blink;
	return ((union Rec *)(pFile->vaUndoCur))->i.op;
}




/*** ReDoRec - redo editting action
*
*  Repeat the action of the current undo record for a file. Do not log the
*  change.
*
* Input:
*  pFile	= file to operate on
*
* Output:
*  Returns the type of record undone.
*
*************************************************************************/
int
ReDoRec (
    PFILE   pFile
    )
{
	EVTargs 	e;				/* event notification params	*/
	union Rec	*rec;
    LINEREC vlCur;

	rec = (union Rec *)(pFile->vaUndoCur);

	e.arg.pUndoRec = rec;
    DeclareEvent (EVT_UNDO, &e);

	switch (rec->b.op) {

    case EVENT_REPLACE:
        /*
         * Swap the line in the file with the line in the replace record.
         */
        memmove((char *)&vlCur,
				LINEREC (pFile->plr, rec->r.line),
                sizeof (vlCur));

		memmove(LINEREC (pFile->plr, rec->r.line),
				(char *)&rec->r.vLine,
				sizeof (rec->r.vLine));

		rec->r.vLine = vlCur;
		pFile->cLines = rec->r.length;
		AckReplace (rec->r.line, FALSE);
		break;

    case EVENT_INSERT:
		/*	Insert lines
		 */
		InsLine(FALSE, rec->i.line, rec->i.cLine, pFile);
		pFile->cLines = rec->d.length + rec->i.cLine;
        break;

    case EVENT_DELETE:
		/*	delete lines
		 */
		DelLine( FALSE, pFile, rec->d.line, rec->d.line + rec->d.cLine - 1 );
		pFile->cLines = rec->d.length - rec->d.cLine;
		break;
    }

	pFile->vaUndoCur = rec->i.flink;
	return ((union Rec *)(pFile->vaUndoCur))->i.op;
}





/*** zundo - Undo edit function
*
*  <undo>	- Reverse last edit function ( except undo )
*  <meta><undo> - Repeat previously undone action
*
* Input:
*  Standard editting function
*
* Output:
*  Returns TRUE if something done.
*
*************************************************************************/
flagType
zundo (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    int fTmp;
	union Rec rec;

    if (!fundoable(fMeta)) {
        if (!mtest ()) {
            disperr (fMeta ? MSGERR_REDO : MSGERR_UNDO);
        }
		return FALSE;
	}

    LogBoundary ();

    while ((fMeta ? ReDoRec (pFileHead) : UnDoRec (pFileHead)) != EVENT_BOUNDARY) {
        ;
    }

    /*
     * swap the flags so that traversals up and down the undo list work correctly.
     * If we now think that the file might not be dirty, check the modification
     * times as well. (This allows us to retain UNDO histories across file saves,
     * without erroneously reporting that a file is clean when it is not).
     * re-display the file.
     */
    memmove((char *)&rec, pFileHead->vaUndoCur, sizeof (rec));

    fTmp = FLAGS (pFileHead);
    rec.b.flags |= FLAGS(pFileHead) & VALMARKS;
    FLAGS(pFileHead) = rec.b.flags;
    rec.b.flags = fTmp;
    SETFLAG (fDisplay, RSTATUS);

    if (!TESTFLAG(FLAGS(pFileHead),DIRTY)
        && (rec.b.modify != pFileHead->modify)) {
        SETFLAG(FLAGS(pFileHead),DIRTY);
    }

    doscreen (rec.b.flWindow.col, rec.b.flWindow.lin, rec.b.flCursor.col, rec.b.flCursor.lin);
    newscreen ();

    return TRUE;

    argData; pArg;
}





/*** fundoable - return TRUE/FALSE if something is un/redoable
*
* Input:
*  fMeta	= TRUE -> redo check
*
* Output:
*  Returns TRUE is an undo or redo (as selected) can be performed
*
*************************************************************************/
flagType
fundoable (
    flagType fMeta
    )
{
	union Rec *rec;

    if (!pFileHead || pFileHead->vaUndoCur == (PVOID)-1L) {
        return FALSE;
    }

	rec = (union Rec *)(pFileHead->vaUndoCur);

	if (fMeta && (rec->i.flink == (PVOID)(-1))) {
        return FALSE;
	} else if (!fMeta && (rec->i.blink == (PVOID)(-1))) {
        return FALSE;
    }
    return TRUE;
}




/*  fIdleUndo - while MEP is in an idle loop waiting for keystrokes, free
 *  the extra stuff from the dead-record list.
 *
 *  returns	TRUE iff more to free
 */
flagType
fIdleUndo (
    flagType fAll
    )
{
    int         i;
	union Rec	*rec;
    LINEREC vLine;
	flagType	MoreToFree;
	PVOID		p;

    EnterCriticalSection(&UndoCriticalSection);

	// DUMPIT(vaDead, "\n\n***** In fIdleUndo\n");

    /*
     * if there is a dead list then
     */
    while (vaDead != (PVOID)(-1L)) {

		rec = (union Rec *)vaDead;

        /*
         *  Free stored lines(s)
         */
		switch (rec->b.op) {

        case EVENT_REPLACE:
			if (rec->r.vLine.Malloced) {
				rec->r.vLine.Malloced = FALSE;
				FREE(rec->r.vLine.vaLine);
				rec->r.vLine.vaLine = (PVOID)-1L;
            }
            break;

        case EVENT_DELETE:
			BlankLines (rec->d.cLine, rec->d.vaLines);
			for (i = 0; i < rec->d.cLine; i++) {
				memmove((char *)&vLine, LINEREC(rec->d.vaLines,i), sizeof(vLine));
				if (vLine.Malloced) {
					vLine.Malloced = FALSE;
					FREE (vLine.vaLine);
					vLine.vaLine = (PVOID)-1L;
                }
            }
			FREE (rec->d.vaLines);
            break;

        case EVENT_INSERT:
			break;
        }

        /*
         * free dead record.
		 */
		p = vaDead;
		vaDead = rec->b.blink;

		FREE (p);


        if (!fAll) {
            break;
        }
    }

    MoreToFree =  (flagType)(vaDead != (PVOID)(-1L));

    LeaveCriticalSection(&UndoCriticalSection);

    return MoreToFree;

}





/*  FlushUndo - Toss all unneeded undo records.
 */
void
FlushUndoBuffer (
    void
    )
{
    PFILE pFile = pFileHead;

    while (pFile) {
		RemoveUndoList (pFile);
		pFile = pFile->pFileNext;
    }
    fIdleUndo (TRUE);
}





/*  RemoveUndoList - transfer undolist to end of the dead list.
 */
void
RemoveUndoList (
    PFILE pFile
    )
{

    if (pFile->vaUndoTail != (PVOID)-1L) {

        EnterCriticalSection(&UndoCriticalSection);

        ((union Rec *)(pFile->vaUndoTail))->b.blink = vaDead;
        vaDead = pFile->vaUndoHead;

        LeaveCriticalSection(&UndoCriticalSection);

    }
    pFile->vaUndoHead = pFile->vaUndoTail = pFile->vaUndoCur = (PVOID)-1L;
    pFile->cUndo = 0;
}



#ifdef DEBUG
void
UNDODUMP (
    PVOID   vaCur,
    char    *Stuff
    )
{
    union Rec rec;

    char DbgBuffer[256];


    if (vaCur != (PVOID)-1) {
        OutputDebugString (Stuff);
        OutputDebugString("=============================================\n");
    }

    while (vaCur != (PVOID)-1L) {
        memmove((char *)&rec, vaCur, sizeof (rec));
        sprintf(DbgBuffer,  "\nUndo Record at va = %p\n",vaCur);
        OutputDebugString(DbgBuffer);
        sprintf(DbgBuffer,    "  flink           = %p\n",rec.b.flink);
        OutputDebugString(DbgBuffer);
        sprintf(DbgBuffer,    "  blink           = %p\n",rec.b.blink);
        OutputDebugString(DbgBuffer);

        switch (rec.b.op) {

        case EVENT_BOUNDARY:
            OutputDebugString("  Operation       = BOUNDARY\n");
            sprintf(DbgBuffer,"  yW, xW, yC, xC  = %ld, %d, %ld, %d\n",
                     rec.b.flWindow.lin, rec.b.flWindow.col, rec.b.flCursor.lin, rec.b.flCursor.col);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  flags           = %X\n",rec.b.flags);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_REPLACE:
            OutputDebugString("  Operation       = REPLACE\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.r.line, rec.r.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  vLine           = va:%p cb:%d\n",rec.r.vLine.vaLine,
                     rec.r.vLine.cbLine);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_INSERT:
            OutputDebugString("  Operation       = INSERT\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.i.line, rec.i.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  cLine           = %ld\n",rec.i.cLine);
            OutputDebugString(DbgBuffer);
            break;

        case EVENT_DELETE:
            OutputDebugString("  Operation       = DELETE\n");
            sprintf(DbgBuffer, "  line & length   = %ld & %ld\n", rec.d.line, rec.d.length);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  cLine           = %ld\n",rec.d.cLine);
            OutputDebugString(DbgBuffer);
            sprintf(DbgBuffer, "  vaLines         = %p\n",rec.d.vaLines);
            OutputDebugString(DbgBuffer);
            break;
        }

        vaCur = rec.b.blink;
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\word.c ===
/*** word.c - movement by words
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#include "mep.h"

#define ISWORD(c) (flagType)((isalnum(c) || isxdigit(c) || c == '_' || c == '$'))

flagType fWordMeta;


/*** fDoWord  -  Checks for beginning or end of word during fScan.
*
*  Checks the character at flScan and the previous character for a change
*  between ISWORD and !ISWORD. This finds:
*
*	ISWORD -> !ISWORD ==> Just after end of a word
*	!ISWORD -> ISWORD ==> First character of word.
*
*  Normally returns TRUE for first character. If fWordMeta, returns TRUE for
*  end of word. fWordMeta holds <meta>, so <meta><xword> functions move to
*  end of word, while <xword> functions move to the beginning.
*
*  Exception: if current character is last on the line and fWordMeta is set,
*  we return TRUE and move the cursor one character to the right.
*
* Globals:
*  scanbuf	- Detabbed text of line being scanned.
*  scanlen	- Index of last character in scanbuf
*  fWordMeta	- Value of fMeta when editor function was invoked
*
* Outputs:
*  Returns if (fWordMeta)
*	TRUE	- character at (flScan.col, flScan.lin) begins a word
*	FALSE	- Otherwise
*   else
*	TRUE	- character at (flScan.col - 1, flScan.lin) ends a word
*	FALSE	- Otherwise
*
*  Moves cursor before returning TRUE
*
*************************************************************************/
flagType
fDoWord (
    void
    )
{
    if (!fWordMeta) {
	if (ISWORD (scanbuf[flScan.col]) && (flScan.col == 0 || !ISWORD (scanbuf[flScan.col-1]))) {
	    cursorfl (flScan);
	    return TRUE;
        }
    } else if (flScan.col > 0 && ISWORD (scanbuf[flScan.col-1])) {
	if (!ISWORD (scanbuf[flScan.col])) {
	    cursorfl (flScan);
	    return TRUE;
        } else if (flScan.col == scanlen) {
	    docursor (flScan.col+1, flScan.lin);
	    return TRUE;
        }
    }
    return FALSE;
}





/*** pword - move forward one word
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on cursor moved
*
*************************************************************************/
flagType
pword (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    fl flCur;

    flCur = pInsCur->flCursorCur;
    fWordMeta = fMeta;
    setAllScan (TRUE);
    fScan (flCur, FNADDR(fDoWord), TRUE, FALSE);
    return (flagType)((flCur.col != XCUR(pInsCur)) || (flCur.lin != YCUR(pInsCur)));

    argData; pArg;
}





/*** mword - move backwards one word
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on cursor moved
*
*************************************************************************/
flagType
mword (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    fl flCur;

    flCur = pInsCur->flCursorCur;
    fWordMeta = fMeta;
    setAllScan (FALSE);
    fScan (flCur, FNADDR(fDoWord), FALSE, FALSE);
    return (flagType)((flCur.col != XCUR(pInsCur)) || (flCur.lin != YCUR(pInsCur)));

    argData; pArg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\z19.c ===
/*  z19.c - Terminal dependent output routines.
*
*   Modifications:
*
*	26-Nov-1991 mz	Strip near/far
*
*************************************************************************/

#include "mep.h"


#define DEBFLAG  Z19



ULONG
MepWrite (
    ULONG   Row,
    ULONG   Col,
    PVOID   pBuffer,
    ULONG   BufferSize,
    DWORD   Attr,
    BOOL    BlankToEndOfLine,
    BOOL    ShowIt
    )
{
    ULONG   CharactersWritten = 0;

    // EnterCriticalSection( &ScreenCriticalSection );

    if (pBuffer) {

	CharactersWritten = consoleWriteLine( MepScreen,
					      pBuffer,
					      BufferSize,
					      Row,
					      Col,
					      Attr,
					      BlankToEndOfLine );

    }

    //
    //	If we want to update the screen, do it
    //
    if (ShowIt)
	consoleShowScreen( MepScreen );

    // LeaveCriticalSection( &ScreenCriticalSection );

    return CharactersWritten;
}




/*  coutb - output line with color, and blank extension
 *
 *  Purpose:
 *   outputs a string of characters, utilizing an array of color information and
 *   blank extending the line to the right hand side of the window.
 *
 *  Entry:
 *   pwnd    = pointer to CW window info (CW version only)
 *   x	     = starting column for output
 *   y	     = line number to be written
 *   p	     = pointer to text
 *   c	     = count of characters in text
 *   colors  = pointer to array of color info
 *
 * Returns:
 */
int
coutb (
    int 	 x,
    int 	 y,
    char	*p,
    int 	 c,
    struct lineAttr * colors
    )
{
    int   cnt;
    DWORD clr;

    int   x1 = x;
    char *p1 = p;
    int   c1 = c;
    struct lineAttr *colors1 = colors;

    if (c1) {
	do {
	    cnt = min (c1, (int)colors1->len);
	    MepWrite( y,
		      x1,
		      p1,
		      cnt,
		      clr = (DWORD)ColorTab[colors1->attr - isaUserMin],
		      FALSE,
		      FALSE );

	    x1 += cnt;
	    p1 += cnt;
	    c1 -= cnt;
	} while (((colors1++)->len != 0xFF) && (c1 > 0));
    }

    if (x1 < XSIZE) {
	MepWrite( y, x1, " ", 1, clr, TRUE, fReDraw );
    } else {
	MepWrite( y, x1, NULL, 0, clr, FALSE, fReDraw );
    }

    return x1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zdebug.c ===
/*** zdebug.c - perform debugging operations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   NOTE:
*    The intent of this file is to contain primarily *non-release* code for
*    internal debugging. As such it exists in a seperate segment, and all
*    routines should be FAR.
*
*   Revision History:
*
*	26-Nov-1991 mz	Strip off near/far
*************************************************************************/

#include "mep.h"


#define DEBFLAG Z

#if defined DEBUG

static char DbgBuffer[128];


void *
DebugMalloc (
    int     Size,
    BOOL    ZeroIt,
    char *  FileName,
    int     LineNumber
    )
{
	void	*b;
	//int	HeapStatus;

	UNREFERENCED_PARAMETER( FileName );
	UNREFERENCED_PARAMETER( LineNumber );

    if (ZeroIt) {
		b = ZeroMalloc(Size);
    } else {
		b = malloc(Size);
    }

	//
	//	Heap check time
	//
	// HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d\n", HeapStatus );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}

	return b;

}


void *
DebugRealloc (
    void    *Mem,
    int     Size,
    BOOL    ZeroIt,
    char *  FileName,
    int     LineNumber
    )
{
	void *	b;
	//int	HeapStatus;

    if (ZeroIt) {
		b = ZeroRealloc(Mem, Size);
    } else {
		b = realloc(Mem, Size);
	}

	//
	//	Heap check time
	//
	//HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d\n", HeapStatus );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}

	return b;
}






void
DebugFree (
    void    *Mem,
    char    *FileName,
    int     LineNumber
    )
{
	//int HeapStatus;

	free( Mem );

	//
	//	Heap check time
	//
	//HeapStatus = _heapchk();
	//
	//if ( HeapStatus != _HEAPOK ) {
	//	sprintf(DbgBuffer, "  Error: _heapchk status %d File %s line %d\n", HeapStatus, FileName, LineNumber );
	//	OutputDebugString(DbgBuffer);
	//	assert( HeapStatus == _HEAPOK );
	//}
}




unsigned
DebugMemSize (
    void *  Mem,
    char *  FileName,
    int     LineNumber
    )
{
	return MemSize( Mem );
}


#endif


#ifdef DEBUG
/*** _assertexit - display assertion message and exit
*
* Input:
*  pszExp	- expression which failed
*  pszFn	- filename containing failure
*  line 	- line number failed at
*
* Output:
*  Doesn't return
*
*************************************************************************/
void
_assertexit (
    char    *pszExp,
    char    *pszFn,
    int     line
    )
{
	static char _assertstring[] = "Editor assertion failed: %s, file %s, line %d\n";
	static char AssertBuffer[256];

	sprintf( AssertBuffer, _assertstring, pszExp, pszFn, line );

	OutputDebugString( AssertBuffer );

	// fprintf(stderr, _assertstring, pszExp, pszFn, line);
	// fflush(stderr);
    //
    //  BugBug
    //      If we CleanExit, then we will never be able to read the
    //      assertion text!
    //
	// if (!fInCleanExit) {
    //    CleanExit (1, CE_STATE);
	// }
    abort();
}




/*** _nearCheck - check far pointer to be a valid near one.
*
*  asserts that the passed far pointer is indeed a valid near pointer
*
* Input:
*  fpCheck	- pointer to be checked
*  pName	- pointer to it's name
*  pFileName	- pointer to file name containing the check
*  LineNum	- the line number in the file containing the check
*
* Output:
*  Returns near pointer
*
* Exceptions:
*  asserts out on failure
*
*************************************************************************/
void *
_nearCheck (
    void *fpCheck,
    char    *pName,
    char    *pFileName,
    int     LineNum
    )
{
    return fpCheck;

    pName; pFileName; LineNum;
}




/*** _pfilechk - verify integrity of the pfile list
*
* Purpose:
*
* Input:
*  none
*
* Output:
*  Returns TRUE if pfile list looks okay, else FALSE.
*
*************************************************************************/
flagType
_pfilechk (
    void
    )
{
    PFILE   pFileTmp    = pFileHead;

	while ( pFileTmp != NULL ) {

#ifdef DEBUG
		if ( pFileTmp->id != ID_PFILE ) {
			return FALSE;
		}
#endif
		if ( pFileTmp->pName == NULL ) {
			return FALSE;
		}

		pFileTmp = pFileTmp->pFileNext;
	}

	return TRUE;
}





/*** _pinschk - verify integrity of an instance list
*
* Purpose:
*
* Input:
*  pIns		- Place to start the check
*
* Output:
*  Returns TRUE if instance list looks okay, else FALSE.
*
*************************************************************************/
flagType
_pinschk (
    PINS    pIns
    )
{
    int     cMax        = 64000/sizeof(*pIns);

    while (pIns && cMax--) {
        if (   (pIns->id != ID_INSTANCE)
            || (pIns->pFile == 0)
            || ((PVOID)pIns->pNext == (PVOID)0xffff)
            ) {
            return FALSE;
        }
        pIns = pIns->pNext;
    }
    return (flagType)(cMax != 0);
}





/*** _heapdump - dump the heap status to stdout
*
* Purpose:
*
* Input:
*   p		= pointer to title string
*
* Output:
*  Returns nothing
*
*************************************************************************/
void
_heapdump (
    char    *p
    )
{
    p;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zexit.c ===
/*** zexit.c - perform exiting operations
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"


extern char *ConsoleTitle;

/*** zexit - exit the editor function
*
* Purpose:
*   <exit>	    save current file, state and advance to next file on
*		    command line
*   <arg><exit>     save current file, state and exit now
*   <meta><exit>    save state and exit
*
* Input:
*  Standard editor function parameters
*
* Output:
*  Returns .....
*
* Exceptions:
*
*************************************************************************/
flagType
zexit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    flagType f  = FALSE;

    /*
     * auto-save current file if appropriate
     */
    if (!fMeta) {
        AutoSave ();
    }


    /*
     *  <exit> goes to the next file on the command line
     *  if we got an arg (<arg><exit> or <arg><meta><exit>) and some files remain
     *     from the command line, then we prompt the user for confirmation.
     */
    if (   (   (pArg->argType == NOARG)
            || (   (pArg->argType == NULLARG)
                && (pFileFileList)
                && (pFileFileList->cLines)
                && (!confirm ("You have more files to edit. Are you sure you want to exit? (y/n): ", NULL))
               )
           )
        && fFileAdvance ()
       ) {
        return FALSE;
    }

    /*
     * If there is background compile in progress that the user does not wish to
     * kill, abort.
     */
    if (!BTKillAll ()) {
        return FALSE;
    }


    /*
     * If we ask, and the user changes his mind, abort.
     */
    if (fAskExit && !confirm("Are you sure you want to exit? (y/n): ", NULL)) {
        return FALSE;
    }


    /* Prompt the user to save dirty files.  If the user chooses
     * not to exit at this time, fSaveDirtyFiles returns FALSE.
     */
    if (!fSaveDirtyFiles()) {
        return FALSE;
    }


    /*
     * At this point, it looks like we're going to exit. Give extensions a chance
     * to change things prior to writing the temp file.
     */
    DeclareEvent (EVT_EXIT, NULL);

    //
    //  Restore original console title
    //
    //SetConsoleTitle( &ConsoleTitle );

    /*
     * Finally, leave.
     */
    CleanExit (0, CE_VM | CE_SIGNALS | CE_STATE);

    argData;
}






/*** fFileAdvance - attempt to read in the next file on the command line
*
* Purpose:
*  We get the next file from the command line and try to read it in.
*
* Input:
*
* Output:
*  Returns TRUE iff the next file was successfully read in
*
*************************************************************************/
flagType
fFileAdvance (
    void
    )
{
    pathbuf    buf;           /* buffer to get filename       */
    int      cbLine;        /* length of line               */
    flagType fTmp;          /* TRUE=> temp file             */
    char     *pBufFn;       /* pointer to actual file name  */

    while (pFileFileList && (pFileFileList->cLines)) {

        pBufFn = buf;
        fTmp   = FALSE;

        /*
         * get and delete the top line in the list, containing the next filename
         */
        cbLine = GetLine (0L, buf, pFileFileList);
        DelLine (FALSE, pFileFileList, 0L, 0L);

        if (pFileFileList->cLines == 0) {
            RemoveFile (pFileFileList);
            pFileFileList = 0;
        }

        if (cbLine) {

            /*
             * if it starts with "/t " the user wants it to be a temp
             */
            if ((buf[0] == '/') && (buf[1] == 't')) {
                fTmp = TRUE;
                pBufFn += 3;
            }

            /*
             * if we can open it, and in fact it became the current file (not just
             * a directory or drive change), set flags as appropriate and return
             * success.
             */
            if (fChangeFile (FALSE, pBufFn)) {
                if (strcmp(pFileHead->pName,pBufFn) == 0) {
                    if (fTmp) {
                        SETFLAG (FLAGS (pFileHead), TEMP);
                    }
                    return TRUE;
                }
            }
        }
    }

    if (pFileFileList) {
        RemoveFile (pFileFileList);
        pFileFileList = 0;
    }
    return FALSE;
}





/*** SetFileList - Create list of fully qualified paths
*
*  Creates the <file-list> psuedo file, and scans the command line for all
*  non-switch parameters. For each of those it adds their fully qualified
*  path name to the psuedo file. This allows the user to change directories
*  at will, and not lose the ability to <exit> to get to the next file he
*  specified on the command line.
*
* Input:
*  none
*
* Output:
*  Returns number of files in <file-list>
*  <file-list> created
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
LINE
SetFileList (
    void
    )
{
    pathbuf buf;			    /* buffer to build path in	    */
    char    *pBufAdd;			    /* pointer to place path at     */

    pFileFileList = AddFile ("<file-list>");
    IncFileRef (pFileFileList);
    SETFLAG (FLAGS(pFileFileList), REAL | FAKE | DOSFILE | READONLY);

    pBufAdd = buf;

    while (cArgs && !fCtrlc) {

        if (fSwitChr (**pArgs)) {
            //
            //  if filename is preceded by -t, then prepend a -t to the
            //  file list
            //
            _strlwr (*pArgs);
            if (!strcmp ("t", *pArgs+1) && cArgs >= 2) {
                strcpy (buf, "/t ");
                pBufAdd = buf+3;
            }
        } else {
            //
            //  Form full pathname, and add each filename to the file
            //  list pseudo-file
            //
            if ( strlen(*pArgs) > sizeof(buf) ) {
                printerror( "File name too long." );
            } else {
                *pBufAdd = '\0';
                CanonFilename (*pArgs, pBufAdd);
                if ( *pBufAdd == '\0' || strlen(pBufAdd) > BUFLEN ) {
                    printerror( "File name too long." );
                } else {
                    PutLine (pFileFileList->cLines, pBufAdd = buf, pFileFileList);
                }
            }
        }

        SHIFT (cArgs, pArgs);
    }

    return pFileFileList->cLines;
}





/*** CleanExit - Clean up and return to DOS.
*
* Input:
*  retc 	- Return code to DOS
*  flags	= OR combination of one or more:
*		    CE_VM	Clean Up VM
*		    CE_SIGNALS	Clean up signals
*		    CE_STATE	Update state file
*
* Output:
*  Doesn't Return
*
*************************************************************************/
void
CleanExit (
    int      retc,
    flagType flags
    )
{
    fInCleanExit = TRUE;
    domessage (NULL);
    prespawn (flags);

    //if (!fSaveScreen) {
    //    voutb (0, YSIZE+1, NULL, 0, fgColor);
    //}

    exit(retc);
}





/*** prespawn - pre-spawn "termination" processing
*
*  A form of "termination" prior to spawning a process. Restore/save state as
*  required before shelling out a program
*
* Input:
*  flags	= OR combination of one or more:
*		    CE_VM	Clean Up VM
*		    CE_SIGNALS	Clean up signals
*		    CE_STATE	Update state file
*
* Output:
*  Returns .....
*
*************************************************************************/
flagType
prespawn (
    flagType flags
    )
{
    if (TESTFLAG (flags, CE_STATE)) {
        WriteTMPFile ();
    }

#if DEBUG
    fflush (debfh);
#endif

    /*
     * Unhook the keyboard and return it to cooked mode, reset hardware as
     * appropriate and restore the screen mode on entry, and it's contents if
     * so configured.
     */
	KbUnHook ();

    SetErrorMode( 0 );

    if (TESTFLAG(fInit, INIT_VIDEO)) {
		SetVideoState(1);
	}

    //if (fSaveScreen) {
    RestoreScreen();
    //}

    fSpawned = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zprint.c ===
/*** zprint.c - print functions
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#define INCL_DOSPROCESS
#include "mep.h"
#include "keyboard.h"
#include "keys.h"


/*** SetPrintCmd - sets the print command string ************************
*
*   Stores the given <printcmd> switch string to be used by the <print>
*   command and makes pPrintCmd global variable point to it.
*
*   Input:
*	pCmd = pointer to the new command string
*	       NULL means clear it up
*   Output:
*	Returns always TRUE
*
*   Note:
*	pPrintCmd is assigned NULL when no <printcmd> defined
*
*************************************************************************/

flagType
SetPrintCmd (
    char *pCmd
    )
{
    if (pPrintCmd != NULL)
	FREE (pPrintCmd);

    if (strlen (pCmd) != 0)
	pPrintCmd = ZMakeStr (pCmd);
    else
	pPrintCmd = NULL;

    return TRUE;
}






/*** zPrint - <print> editor function
*
*   Prints file(s) or designated area
*
*   Input:
*	NOARG	    Print current file
*	TEXTARG     List of files to print
*	STREAMARG   Print designated area
*	BOXARG	    Print designated area
*	LINEARG     Print designated area
*
*   Output:
*	Returns TRUE if the printing has been successful, FALSE otherwise
*
*************************************************************************/
flagType
zPrint (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    flagType	fOK;		    /* Holds the return value		*/
    PFILE       pFile;              /* general file pointer             */

    /*
     * The following is used only when we scan a list of files (TEXTARG)
     */
    flagType	fNewFile;	    /* Did we open a new file ? 	*/
    buffer	pNameList;	    /* Holds the list of file names	*/
    char	*pName, *pEndName;  /* Begining and end of file names	*/
    flagType	fDone = FALSE;	    /* Did we finish with the list ?	*/

    /*
     *	If we can flush the files, that's the moment
     */
    AutoSave ();

    switch (pArg->argType) {

	case NOARG:
	    return (DoPrint (pFileHead, FALSE));

	case TEXTARG:
	    /*
	     * Get the list in a buffer
	     */
	    strcpy ((char *) pNameList, pArg->arg.textarg.pText);

	    /*
	     * Empty list = no work
	     */
            if (!*(pName = whiteskip (pNameList))) {
                return FALSE;
            }

	    /*
	     * For each name:
	     *	     - pName points at the begining
	     *	     - Make pEndName pointing just past its ends
	     *	     - If it's already the end of the string
	     *		then we're done with the list
	     *		else put a zero terminator there
	     *	     - Do the job with the name we've found :
	     *		. Get the file handle (if it doen't exist yet,
	     *		  create one and switch fNewFile on
	     *		. Call DoPrint
	     *	     - Let pName point to the next name
	     */
	    fOK = TRUE;

	    do {
		pEndName = whitescan (pName);
                if (*pEndName) {
		    *pEndName = 0;
                } else {
                    fDone = TRUE;
                }

		if ((pFile = FileNameToHandle (pName, pName)) == NULL) {
		    pFile = AddFile (pName);
		    FileRead (pName, pFile, FALSE);
		    fNewFile = TRUE;
                } else  {
                    fNewFile = FALSE;
                }

		fOK &= DoPrint (pFile, FALSE);

                if (fNewFile) {
                    RemoveFile (pFile);
                }

		pName = whiteskip (++pEndName);

            } while (!fDone && *pName);

	    /*
	     * Just in case we would change the behaviour to stopping all
	     * things at the first error :
	     *
	     *	} while (fOK && !fDone && *pName);
	     */
            return (fOK);

	case STREAMARG:
	case BOXARG:
	case LINEARG:
	    /*
	     *	If we print an area, we'll put the text in a temporary file,
	     *	call DoPrint with this file and then destroy it.
	     */
	    pFile = GetTmpFile ();

	    switch (pArg->argType) {
		case STREAMARG:
		    CopyStream (pFileHead, pFile,
				pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart,
				pArg->arg.streamarg.xEnd, pArg->arg.streamarg.yEnd,
				0L,0L);
                    break;

		case BOXARG:
		    CopyBox (pFileHead, pFile,
			     pArg->arg.boxarg.xLeft, pArg->arg.boxarg.yTop,
			     pArg->arg.boxarg.xRight, pArg->arg.boxarg.yBottom,
			     0L,0L);
                    break;

		case LINEARG:
		    CopyLine (pFileHead, pFile,
			      pArg->arg.linearg.yStart, pArg->arg.linearg.yEnd,
			      0L);
		    break;
            }

	    /*
	     * If we have to spawn a print command, then we need to make a real
	     * disk file
	     */
            if (pPrintCmd && (!FileWrite (pFile->pName, pFile))) {
		fOK = FALSE;
            } else {
                fOK = DoPrint (pFile, TRUE);
            }
	    RemoveFile (pFile);
	    return (fOK);
    }

    return FALSE;
    argData; fMeta;
}





/*** DoPrint - Does the printing
*
*   If a <printcmd> has been defined
*	queue up the job for the <print> thread (synchronous exec under DOS)
*   else
*	send the file to the printer, each line at a time
*
*   Input:
*	pFile = File to be printed.
*
*   Output:
*	Returns True if the printing has been succesful, False otherwise
*
*************************************************************************/
flagType
DoPrint (
    PFILE    pFile,
    flagType fDelete
    )
{
    assert (pFile);

    if (pPrintCmd) {
	buffer	 pCmdBuf;		// Buffer for command construction

	if (TESTFLAG (FLAGS (pFile), DIRTY) && confirm ("File %s is dirty, do you want to save it ?", pFile->pName))
            FileWrite (pFile->pName, pFile);

	sprintf (pCmdBuf, pPrintCmd, pFile->pName);


	if (pBTDPrint->cBTQ > MAXBTQ-2)
	    disperr (MSGERR_PRTFULL);
	else
	if (BTAdd (pBTDPrint, (PFUNCTION)NULL, pCmdBuf) &&
	    (!fDelete || BTAdd (pBTDPrint, (PFUNCTION)CleanPrint, pFile->pName)))
            return TRUE;
	else
            disperr (MSGERR_PRTCANT);

	if (fDelete)
            _unlink (pFile->pName);

	return FALSE;
    }
    else {
        static char   szPrn[] = "PRN";
	flagType      fOK = TRUE;	//  Holds the return value
	LINE	      lCur;		//  Number of line we're printing
	char	      pLineBuf[sizeof(linebuf)+1];
					//  Holds the line we're printing
	unsigned int  cLen;		//  Length of line we're printing
	EDITOR_KEY    Key;		//  User input (for abortion)
	int	      hPrn;		//  PRN file handle

	dispmsg (MSG_PRINTING,pFile->pName);

	if ((hPrn = _open (szPrn, O_WRONLY)) == -1) {
	    disperr (MSGERR_OPEN, szPrn, error());
	    fOK = FALSE;
	}
	else {
	    for (lCur = 0; lCur < pFile->cLines; lCur++) {
		if (TypeAhead () &&
		    (Key = TranslateKey(ReadChar()), (Key.KeyCode == 0x130)) &&
		    (!Key.KeyInfo.KeyData.Flags)) {

		    fOK = FALSE;
		    break;
                }
		cLen = GetLine (lCur, pLineBuf, pFile);
//		* (int UNALIGNED *) (pLineBuf + cLen++) = '\n';
		* (pLineBuf + cLen++) = '\n';
		if (_write (hPrn, pLineBuf, cLen) == -1) {
		    disperr (MSGERR_PRTCANT);
		    fOK = FALSE;
		    break;
                }
            }
	    _close (hPrn);
        }
	domessage (NULL);

        if (fDelete) {
            _unlink (pFile->pName);
        }
	return fOK;
    }
}





/*** GetTmpFile - Allocates temporary files
*
* Input:
*   nothing
*
* Output:
*   pointer to the allocated file
*
* Remark:
*   We do not use mktemp as it is creating files in the current directory.
*
* Notes:
*   - Each new call changes the content of the work buffer, so
*     the caller needs to save the string before doing a new call.
*   - There is a limit of 26 names to be generated
*
*************************************************************************/
PFILE
GetTmpFile (
    void
    )
{
    static pathbuf pPath = "";
    static char   *pVarLoc;

    if (!*pPath) {
	pathbuf pName;

	sprintf (pName, "$TMP:ME%06p.PRN", _getpid);
	findpath (pName, pPath, TRUE);
	pVarLoc  = strend (pPath) - 10;
	*pVarLoc = 'Z';
    }

    if (*pVarLoc == 'Z') {
	*pVarLoc = 'A';
    } else {
        ++*pVarLoc;
    }

    return (AddFile (pPath));

}





/*** Clean - cleans the printer intermediate file
*
* Input:
*   pName = Name of the file to get rid of
*
* Output:
*   None
*
* Remarks: - Under OS/2, since we're called by the background thread, we
*	     need to switch stack checking off
*	   - The background thread calls this routime at idle time
*
*************************************************************************/

// #pragma check_stack (off)

void
CleanPrint (
    char     *pName,
    flagType fKilled
    )
{
    _unlink (pName);
    fKilled;
}

// #pragma check_stack ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zaux.c ===
/*** zaux.c - helper routines for Z
*
*   Modifications
*
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/
#define INCL_SUB
#define INCL_DOSERRORS
#define INCL_DOSMISC

#include "mep.h"
#include <stdarg.h>
#include <errno.h>

/*** ParseCmd - Parse "command" line into two pieces
*
* Given a text string, returns a pointer to the first word (non-whitespace)
* in the text, which is null terminated by this routine, and a pointer to
* the second word.
*
* Input:
*  pText	= Pointer to text string
*  ppCmd	= Pointer to place to put pointer to first word
*  ppArg	= Pointer to place to put pointer to second word
*
* Output:
*  Returns nothing. Pointers update, and string possible modified to include
*  null terminator after first word.
*
*************************************************************************/
void
ParseCmd (
    char    *pText,
    char    **ppCmd,
    char    **ppArg
    )
{
    REGISTER char *pCmd;                    /* working pointer              */
    REGISTER char *pArg;                    /* working pointer              */

    pArg = whitescan (pCmd = whiteskip (pText));
    if (*pArg) {
        *pArg++ = '\0';
        pArg = whiteskip (pArg);
    }
    *ppCmd = pCmd;
    *ppArg = pArg;
}





char *
whiteskip (
    const char *p
    )
{
    return strbskip ((char *)p, (char *)rgchWSpace);
}





char *
whitescan (
    const char *p
    )
{
    return strbscan ((char *)p, (char *)rgchWSpace);
}





/*** RemoveTrailSpace - remove trailing white space characters from line
*
* Input:
*  p		= pointer to line to be stripped.
*
* Output:
*  Returns new length of line.
*
*************************************************************************/
int
RemoveTrailSpace (
    REGISTER char *p
    )
{
    REGISTER int len = strlen (p);

    while (len && strchr(rgchWSpace,p[len-1])) {
        len--;
    }

    p[len] = 0;
    return len;
}




/*** DoubleSlashes - given a character string, double all backslashes
*
* Input:
*  pbuf 	= pointer to character buffer
*
* Output:
*  Returns pbuf
*
*************************************************************************/
char *
DoubleSlashes (
    char * pbuf
    )
{
    REGISTER int l;
    REGISTER char *p;

    p = pbuf;
    l = strlen (p);
    while (l) {
        if (*p == '\\') {
            memmove ((char *) (p+1),(char *) p,     l+1);
            *p++ = '\\';
        }
        p++;
        l--;
    }
    return pbuf;
}





/*** UnDoubleSlashes - given a character string, un-double all backslashes
*
* Input:
*  pbuf 	= pointer to character buffer
*
* Output:
*  Returns pbuf
*
*************************************************************************/
char *
UnDoubleSlashes (
    char * pbuf
    )
{
    REGISTER char *p1;
    REGISTER char *p2;

    p1 = p2 = pbuf;
    while (*p1) {
        if ((*p2++ = *p1++) == '\\') {
            if (*p1 == '\\') {
                p1++;
            }
        }
    }
    return pbuf;
}




/*** fIsNum - see if a string is entirely digits
*
* Input:
*  p		= pointer to string
*
* Output:
*  Returns TRUE if valid number.
*
*************************************************************************/
flagType
fIsNum (
    char *p
    )
{
    if (*p == '-') {
        p++;
    }
    return (flagType)(*strbskip (p, "0123456789") == 0);
}





/*** OS2toErrTxt - Get Error Text for OS/2 error
*
* Get the error message text for an OS/2 returned error.
*
* Input:
*  erc		= OS/2 error number
*  buf		= location to place the error (BUFSIZE)
*
* Output:
*  Returns buf
*
*************************************************************************/
char *
OS2toErrText (
    int     erc,
    char *  buf
    )
{

    sprintf(buf, "Windows error No. %lu", GetLastError());
    return buf;

    erc;
}





/*** OS2toErrno - Convert OS/2 error code to C runtime error
*
* Purpose:
*  Maps errors returned by some OS/2 calls to equivalent C runtime errors,
*  such that routines which differ in OS/2 implementation can return equivalent
*  errors as their DOS counterparts.
*
* Input:
*  code 	= OS/2 returned error code
*
* Output:
*  returns a C runtime error constant
*
* Exceptions:
*  none
*
* Notes:
*  CONSIDER: It's been suggested that this routine, and error message
*  CONSIDER: presentation under OS/2 be changed to use DosGetMessage.
*
*************************************************************************/
int
OS2toErrno (
    int code
    )
{
    buffer buf;

    printerror (OS2toErrText (code,buf));

    return code;
}




union argPrintfType {
    long *pLong;
    int  *pInt;
    char **pStr;
    char **fpStr;
    };


/***  ZFormat - replace the C runtime formatting routines.
*
* Purpose:
*
*   ZFormat is a near-replacement for the *printf routines in the C runtime.
*
* Input:
*   pStr - destination string where formatted result is placed.
*   fmt  - formatting string.  Formats currently understood are:
*		    %c single character
*		    %[n][l]d %[n][l]x
*		    %[m.n]s
*		    %[m.n]|{dpfe}F - print drive, path, file, extension
*				     of current file.
*		      * may be used to copy in values for m and n from arg
*			list.
*		    %%
*   arg  - is a list of arguments
*
* Output:
*
*   Returns 0 on success, MSGERR_* on failure.	The MSGERR_* value may
*   be passed to disperr, as in:
*
*	if (err = ZFormat (pszUser))
*	    disperr (err, pszUser).
*
*   Note that the error message wants to display the offending string.
*
*   Currently, the only return value is:
*
*	MSGERR_ZFORMAT	8020	Unrecognized %% command in '%s'
*
*************************************************************************/

int
ZFormat (
    REGISTER char *pStr,
    const REGISTER char *fmt,
    va_list vl
    )
{
    char   c;
    char * pchar;
    int *  pint;



    *pStr = 0;
    while (c = *fmt++) {
        if (c != '%') {
	    *pStr++ = c;
        } else {
	    flagType fFar = FALSE;
	    flagType fLong = FALSE;
	    flagType fW = FALSE;
	    flagType fP = FALSE;
	    flagType fdF = FALSE;
	    flagType fpF = FALSE;
	    flagType ffF = FALSE;
	    flagType feF = FALSE;
	    char fill = ' ';
	    int base = 10;
	    int w = 0;
	    int p = 0;
	    int s = 1;
	    int l;

	    c = *fmt;
	    if (c == '-') {
		s = -1;
		c = *++fmt;
            }
	    if (isdigit (c) || c == '.' || c == '*') {
		/*  parse off w.p
		 */
		fW = TRUE;
		if (c == '*') {
		    pint = va_arg (vl, int *);
		    w = *pint;
		    fmt++;
                } else {
                    if (c == '0') {
                        fill = '0';
                    }
		    w = s * atoi (fmt);
		    fmt = strbskip (fmt, "0123456789");
                }
		if (*fmt == '.') {
		    fP = TRUE;
		    if (fmt[1] == '*') {
		   	p = va_arg (vl, int);
			fmt += 2;
                    } else {
			p = atoi (fmt+1);
			fmt = strbskip (fmt+1, "0123456789");
                    }
                }
            }
	    if (*fmt == 'l') {
		fLong = TRUE;
		fmt++;
            }
	    if (*fmt == 'F') {
		fFar = TRUE;
		fmt++;
            }
            if (*fmt == '|') {
                while (*fmt != 'F') {
		    switch (*++fmt) {
			case 'd': fdF = TRUE; break;
			case 'p': fpF = TRUE; break;
			case 'f': ffF = TRUE; break;
			case 'e': feF = TRUE; break;
			case 'F': if (fmt[-1] == '|') {
				    fdF = TRUE;
				    fpF = TRUE;
				    ffF = TRUE;
				    feF = TRUE;
				    }
				  break;
                        default :
                            // va_end(vl);
			    return MSGERR_ZFORMAT;
                    }
                }
            }

	    switch (*fmt++) {
	    case 'c':
		p = va_arg (vl, int);
		*pStr++ = (char)p;
		*pStr = 0;
		
                break;

	    case 'x':
		base = 16;
	    case 'd':
		if (fLong) {
		
		    _ltoa ( va_arg (vl, long), pStr, base);
		
                } else {
		    _ltoa ( (long)va_arg (vl, int), pStr, base);
		
                }
                break;

	    case 's':
		pchar = va_arg (vl, char *);
		if (fFar) {
                    if (!fP) {
                        p = strlen ( pchar );
                    }
		    memmove ((char *) pStr, pchar , p);
		
                } else {
                    if (!fP) {
                        p = strlen ( pchar );
                    }
		    memmove ((char *) pStr, pchar , p);
		
                }
		fill = ' ';
		pStr[p] = 0;
                break;

	    case 'F':
		pStr[0] = 0;
                if (fdF) {
                    drive (pFileHead->pName, pStr);
                }
                if (fpF) {
                    path (pFileHead->pName, strend(pStr));
                }
                if (ffF) {
                    filename (pFileHead->pName, strend(pStr));
                }
                if (feF) {
                    extention (pFileHead->pName, strend(pStr));
                }
                break;

	    case '%':
		*pStr++ = '%';
		*pStr = 0;
                break;

            default:
                // va_end(vl);
		return MSGERR_ZFORMAT;
            }

	    /*	text is immediately at pStr.  Check width to justification
	     */
	    l = strlen (pStr);
	    if (w < 0) {
		/*  left-justify
		 */
		w = -w;
		if (l < w) {
		    memset ((char *) &pStr[l], fill, w - l);
		    pStr[w] = 0;
                }
            } else if (l < w) {
		/*  right-justify
		 */
		memmove ((char *) &pStr[w-l], (char *) &pStr[0], l);
		memset ((char *) &pStr[0], fill, w - l);
		pStr[w] = 0;
            }
	    pStr += strlen (pStr);
        }
    }
    *pStr = 0;
    // va_end(vl);
    return 0;
}

/*  FmtAssign - formatted assign
 *
 *  FmtAssign is used to both format and perform an assignment
 *
 *  pFmt	character pointer to sprintf-style formatting
 *  arg 	set of unformatted arguments
 *
 *  returns	result of DoAssign upon formatted result
 */
flagType
__cdecl
FmtAssign (
    char *pFmt,
    ...
    )
{
    char buf[ 512 ];
    va_list pArgs;

    va_start (pArgs, pFmt);
    ZFormat (buf, pFmt, pArgs);
    va_end (pArgs);
    return DoAssign (buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zspawn.c ===
/*** zspawn.c - shell command and support
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Contains the shell command, and associated support code.
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"
#include "keyboard.h"




/*** zspawn - <shell> editor function
*
*   <shell>		runs command
*   <meta><shell>	runs command with no save of current file
*   <arg><shell>	uses text from line on screen as program to execute
*   <arg>text<shell>	does command /C text
*
* Input:
*  Standard Editting Function
*
* Output:
*  Returns TRUE on successfull spawn.
*
*************************************************************************/
flagType
zspawn (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    buffer   sbuf;
    flagType f = FALSE;
    LINE     i;

    DeclareEvent (EVT_SHELL, NULL);
    if (!fMeta) {
        AutoSave ();
    }

    soutb (0, YSIZE+1, "***** PUSHED *****", fgColor);
    domessage (NULL);
    consoleMoveTo( YSIZE, 0 );

    switch (pArg->argType) {
    case NOARG:
	f = zspawnp (rgchEmpty, TRUE);
        break;

    case TEXTARG:
	strcpy ((char *) sbuf, pArg->arg.textarg.pText);
	f = zspawnp (sbuf, TRUE);
        break;

    /*  NULLARG converted to TEXTARG*/

    case LINEARG:
	for (i = pArg->arg.linearg.yStart; i <= pArg->arg.linearg.yEnd; i++) {
	    GetLine (i, sbuf, pFileHead);
            if (!(f = zspawnp (sbuf, (flagType)(i == pArg->arg.linearg.yEnd)))) {
		docursor (0, i);
		break;
            }
        }
        break;

    /*  STREAMARG illegal           */

    case BOXARG:
	for (i = pArg->arg.boxarg.yTop; i <= pArg->arg.boxarg.yBottom; i++) {
	    fInsSpace (pArg->arg.boxarg.xRight, i, 0, pFileHead, sbuf);
	    sbuf[pArg->arg.boxarg.xRight+1] = 0;
	    if (!(f = zspawnp (&sbuf[pArg->arg.boxarg.xLeft],
                               (flagType)(i == pArg->arg.boxarg.yBottom)))) {
		docursor (pArg->arg.boxarg.xLeft, i);
		break;
            }
        }
	break;
    }

    fSyncFile (pFileHead, TRUE);
    return f;

    argData;
}




/*** zspawnp - shell out a program
*
*  Execute the specified program, syncronously. Under DOS, if PWB and
*  minimize memory usage is on, we use the shell to execute the command,
*  else we just use system().
*
* Input:
*  p		= pointer to command string
*  fAsk 	= TRUE => ask to hit any key before returning
*
* Globals:
*  fIsPwb	= TRUE => we are executing as PWB
*  memuse	= memory usage options
*
* Output:
*  Returns TRUE on success
*
*************************************************************************/
flagType
zspawnp (
    REGISTER char const *p,
    flagType fAsk
    )
{
    intptr_t    i;
    flagType fCmd       = FALSE;            /* TRUE => null shell           */
    KBDMODE  KbdMode;

    /*
     * support suppression of the prompt by explicit character in front of
     * command, then skip any leading whitespace
     */
    if (*p == '!') {
        fAsk = FALSE;
        p++;
    }

    p = whiteskip (p);
    /*
     * if no command to execute, use command processor
     */
    if (!*p) {
        fCmd = TRUE;
        fAsk = FALSE;
        p = pComSpec;
    }

    KbdMode = KbGetMode();
	prespawn (CE_VM);
	i = fCmd ? _spawnlp (P_WAIT, (char *)p, (char *)p, NULL) : system (p);
    postspawn ((flagType)(!mtest () && fAskRtn && (i != -1) && fAsk));
    // Hook the keyboard
    KbHook();
    KbSetMode(KbdMode);

    if (i == -1) {
        printerror ("Spawn failed on %s - %s", p, error ());
    }
    return (flagType)(i != -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zutil.c ===
/*** zutil.c - misc utility functions not big enough to warrent their own file
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*	26-Nov-1991 mz	Strip off near/far
*
*************************************************************************/

#include "mep.h"


void *
ZeroMalloc (
    int Size
    )
{
    return calloc(Size, 1);
}




void *
ZeroRealloc (
    void   *pmem,
    int     Size
    )
{
    int     cbOrg  = 0;                   /* original size of block       */
    void    *p;				 /* pointer to returned block	 */

    if (pmem) {
        cbOrg = _msize (pmem);
    }

    p = realloc(pmem, Size);

    /*
     * if reallocated, and now larger, zero fill the new addition to the block.
     * if a new allocation, zero fill the whole thing.
     */
    if (cbOrg < Size) {
	memset ((char *)p+cbOrg, 0, Size-cbOrg);
    }
    return p;
}





unsigned
MemSize (
    void * p
    )
{
    return _msize (p);
}





/*** ZMakeStr - Make local heap copy of string
*
*  Allocate local memory for the passed string, and copy it into that memory.
*
* Input:
*  p		= Pointer to string
*
* Output:
*  Returns pointer to newly allocated memory
*
* Exceptions:
*  LMAlloc
*
*************************************************************************/
char *
ZMakeStr (
    char const *p
    )
{
    return strcpy (ZEROMALLOC (strlen (p)+1), p);
}





/*** ZReplStr - Modify local heap copy of string
*
*  Reallocate local memory for the passed string, and copy it into that memory.
*
* Input:
*  pDest	= pointer to heap entry (NULL means get one)
*  p		= Pointer to string
*
* Output:
*  Returns pointer to newly allocated memory
*
* Exceptions:
*  LMAlloc
*
*************************************************************************/
char *
ZReplStr (
    char    *pDest,
    char const *p
    )
{
    return pDest ? strcpy (ZEROREALLOC (pDest, strlen (p)+1), p) : ZMakeStr(p);
}





/*** DoCancel - clear input & force display update
*
* Input:
*  none
*
* Output:
*  Returns nothing
*
*************************************************************************/
flagType
DoCancel ()
{
    FlushInput ();
    SETFLAG (fDisplay, RTEXT | RSTATUS);
    return TRUE;
}





/*** cancel - <cancel> editting function
*
*
*
* Input:
*  Standard editing function
*
* Output:
*  Returns TRUE
*
*************************************************************************/
flagType
cancel (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    if (pArg->argType == NOARG) {
        fMeta = fMessUp;
	domessage (NULL);
        if (!fMeta) {
            DeclareEvent (EVT_CANCEL, NULL);
        }
    } else {
	domessage ("Argument cancelled");
	resetarg ();
    }
    return DoCancel ();

    argData;
}




/*** testmeta- return meta status & clear
*
*  Returns current status of meta indicator, and clears it.
*
* Input:
*  none
*
* Output:
*  Returns previous setting of meta
*
*************************************************************************/
flagType
testmeta (
    void
    )
{
    flagType f;

    f = fMeta;
    fMeta = FALSE;
    if (f) {
        SETFLAG( fDisplay, RSTATUS );
    }
    return f;
}





/*** meta - <meta> editor function
*
*  Toggle state of the meta flag, and cause screen status line to be updated.
*
* Input:
*  Standard editor function.
*
* Output:
*  Returns new META state
*
*************************************************************************/
flagType
meta (
    CMDDATA argData,
    ARG *pArg,
    flagType MetaFlag
    )
{
    SETFLAG( fDisplay, RSTATUS );
    return fMeta = (flagType)!fMeta;

    argData; pArg; MetaFlag;
}





/*** insertmode - <insertmode> editor function
*
*  Toggle setting of fInsert flag & cause status line to be updated.
*
* Input:
*  Standard editting function
*
* Output:
*  Returns new fInsert value.
*
*************************************************************************/
flagType
insertmode (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    SETFLAG( fDisplay, RSTATUS );
    return fInsert = (flagType)!fInsert;

    argData; pArg; fMeta;
}





/*** zmessage - <message> editor function
*
*   Macro allowing the user to display a message on the dialog line
*
*   Input:
*	User message (textarg) or no arg to clear the dialog line
*
*   Output:
*	Returns always TRUE
*
*
*************************************************************************/
flagType
zmessage (
    CMDDATA argData,
    ARG * pArg,
    flagType fMeta
    )
{
    linebuf lbMsg;
    char    *pch = lbMsg;

    switch (pArg->argType) {

	case NOARG:
	    pch = NULL;
	    break;

	case TEXTARG:
	    strcpy ((char *) lbMsg, pArg->arg.textarg.pText);
	    break;

	case NULLARG:
	    GetLine (pArg->arg.nullarg.y, lbMsg, pFileHead);
	    goto MsgAdjust;

	case LINEARG:
	    GetLine (pArg->arg.linearg.yStart, lbMsg, pFileHead);
	    goto MsgAdjust;

	case STREAMARG:
	    fInsSpace (pArg->arg.streamarg.xStart, pArg->arg.streamarg.yStart, 0, pFileHead, lbMsg);
            if (pArg->arg.streamarg.yStart == pArg->arg.streamarg.yEnd) {
                *pLog (lbMsg, pArg->arg.streamarg.xEnd+1, TRUE) = 0;
            }
	    pch = pLog (lbMsg, pArg->arg.streamarg.xStart, TRUE);
	    goto MsgAdjust;

	case BOXARG:
	    fInsSpace (pArg->arg.boxarg.xRight, pArg->arg.boxarg.yTop, 0, pFileHead, lbMsg);
	    *pLog (lbMsg, pArg->arg.boxarg.xRight+1, TRUE) = 0;
	    pch = pLog (lbMsg, pArg->arg.boxarg.xLeft, TRUE);
MsgAdjust:
	    if (pch > lbMsg) {
		strcpy (lbMsg, pch);
		pch = lbMsg;
            }
	    *pLog (lbMsg, XSIZE, TRUE) = 0;
	    break;
    }

    domessage (pch);
    return TRUE;

    argData; fMeta;
}





/*** GetCurPath gets the current drive and directory
*
*   Input:
*     szBuf: buffer to receive the current path
*
*   Output:
*     Nothing
*
*************************************************************************/
void
GetCurPath (
    char *szBuf
    )
{

    if (!GetCurrentDirectory(MAX_PATH, szBuf)) {
        *szBuf = '\00';
    }
    _strlwr (szBuf);
}





/*** SetCurPath - sets the current drive and directory
*
*   Input:
*     szPath: New path
*
*   Output:
*     TRUE if successful, FALSE otherwise.
*
*************************************************************************/
flagType
SetCurPath (
    char *szPath
    )
{

    if (_chdir (szPath) == -1) {
	return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zinit.c ===
/*** zinit.c - editor initialization
*
*   Copyright <C> 1988, Microsoft Corporation
*
*   Revision History:
*       26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/
#define INCL_DOSFILEMGR
#define INCL_SUB
#define INCL_DOSERRORS
#define INCL_DOSSEMAPHORES
#define INCL_DOSPROCESS

#include "mep.h"
#include "keyboard.h"
#include <conio.h>


#define DEBFLAG ZINIT

#define TSTACK          2048            /* Thread stack size            */

/*
 * Data initializations
 */
flagType    fAskExit    = FALSE;
flagType    fAskRtn     = TRUE;
flagType    fAutoSave   = TRUE;
flagType    fBoxArg     = FALSE;
flagType    fCgaSnow    = TRUE;
flagType    fEditRO     = TRUE;
flagType    fErrPrompt  = TRUE;
flagType    fGlobalRO   = FALSE;
flagType    fInsert     = TRUE;
flagType    fDisplayCursorLoc = FALSE;
flagType    fMacroRecord= FALSE;
flagType    fMsgflush   = TRUE;
flagType    fNewassign  = TRUE;
flagType    fRealTabs   = TRUE;
flagType    fSaveScreen = TRUE;
flagType    fShortNames = TRUE;
flagType    fSoftCR     = TRUE;
flagType    fTabAlign   = FALSE;
flagType    fTrailSpace = FALSE;
flagType    fWordWrap   = FALSE;
flagType    fBreak      = FALSE;
/*
 * Search/Replace globals
 */
flagType fUnixRE        = FALSE;
flagType fSrchAllPrev   = FALSE;
flagType fSrchCaseSwit  = FALSE;
flagType fSrchDirPrev   = TRUE;
flagType fSrchRePrev    = FALSE;
flagType fSrchWrapSwit  = FALSE;
flagType fSrchWrapPrev  = FALSE;
flagType fUseMouse      = FALSE;

flagType fCtrlc;
flagType fDebugMode;
flagType fMetaRecord;
flagType fDefaults;
flagType fMessUp;
flagType fMeta;
flagType fRetVal;
flagType fTextarg;
flagType fSrchCasePrev;
flagType fRplRePrev;
buffer   srchbuf;
buffer   srcbuf;
buffer   rplbuf;

unsigned kbdHandle;

int                backupType  = B_BAK;
int         cUndelCount = 32767;        /* essentially, infinite        */
int         cCmdTab     = 1;
LINE        cNoise      = 50;
int         cUndo       = 10;
int         EnTab       = 1;
char *      eolText     = "\r\n";       /* our definition of end of line*/
int             fileTab = 8;
int     CursorSize=0;
int         hike        = 4;
int         hscroll     = 10;
unsigned    kindpick    = LINEARG;
char        tabDisp     = ' ';
int         tabstops    = 4;
int         tmpsav      = 20;
char        trailDisp   = 0;
int         vscroll     = 1;
COL         xMargin     = 72;

PCMD *  rgMac       = NULL;         /* macro array                  */

int      cMac;

int      ballevel;
char     *balopen, *balclose;
unsigned getlsize         = 0xFE00;

char     Name[];
char     Version[];
char     CopyRight[];

EDITOR_KEY keyCmd;

int     ColorTab[16];

int      cArgs;
char     **pArgs;

char     * pNameEditor;
char     * pNameTmp;
char     * pNameInit;
char     * pNameHome;
char    *pComSpec;

int cMacUse;
struct macroInstanceType mi[MAXUSE];

PCMD     cmdSet[MAXEXT];
PSWI     swiSet[MAXEXT];
char    *pExtName[MAXEXT];




PSCREEN OriginalScreen;
PSCREEN MepScreen;
KBDMODE OriginalScreenMode;











/*
 * Compile and print threads
 */
BTD    *pBTDComp  = NULL;
BTD    *pBTDPrint = NULL;

unsigned    LVBlength   = 0;            /* We use this to know if we're detached */

/*
 * String values.
 */
char rgchPrint [] = "<print>";
char rgchComp  [] = "<compile>";
char rgchAssign[] = "<assign>";
char rgchEmpty[]  = "";
char rgchInfFile[]= "<information-file>";
char rgchUntitled[]="<untitled>";
char rgchWSpace[] = "\t ";        /* our definition of white space*/
char Shell[]      = SHELL;
char User[]       = "USER";
/*
 * autoload extension paterns.
 */
char rgchAutoLoad[]="m*.pxt";

sl                      slSize;
PFILE    pFilePick = NULL;
PFILE    pFileFileList = NULL;
PFILE    pFileAssign = NULL;
PFILE    pFileIni = NULL;
struct   windowType WinList[MAXWIN+1];
int      iCurWin = 0;
PINS        pInsCur     = NULL;
PWND        pWinCur     = NULL;
int                     cWin    = 0;
PFILE           pFileHead=NULL;
COMP     *pCompHead = NULL;
MARK     *pMarkHead = NULL;
char     *pMarkFile = NULL;
char     *pPrintCmd = NULL;
PFILE    pPrintFile = NULL;
buffer  scanbuf;
buffer  scanreal;
int     scanlen;
fl              flScan;
rn              rnScan;

#ifdef DEBUG
int      debug, indent;
FILEHANDLE debfh;
#endif

fl               flArg;
int      argcount;

flagType fInSelection = FALSE;

fl               flLow;
fl               flHigh;
LINE     lSwitches;
int      cRepl;
char     *ronlypgm = NULL;
buffer   buf;
buffer   textbuf;
int      Zvideo;
int      DOSvideo;

flagType *fChange = NULL;
unsigned fInit;
flagType fSpawned = FALSE;





flagType    fDisplay    = RCURSOR | RTEXT | RSTATUS;

flagType    fReDraw     = TRUE;
HANDLE      semIdle     = 0;

char        IdleStack[TSTACK*2];        /* Idle thread stack            */

int         argcount    =  0;
CRITICAL_SECTION    IOCriticalSection;
CRITICAL_SECTION    UndoCriticalSection;
CRITICAL_SECTION        ScreenCriticalSection;

/*
 * predefined args. Handy for invoking some set functions ourselves
 */
ARG     NoArg           = {NOARG, 0};


/*
 *  The format of these strings is identical to that of the assignments in
 *  TOOLS.INI
 */
char * initTab[] = {
/*  Default compilers */
             "extmake:c    cl /c /Zp %|F",
             "extmake:asm  masm -Mx %|F;",
             "extmake:pas  pl /c -Zz %|F",
             "extmake:for  fl /c %|F",
             "extmake:bas  bc /Z %|F;",
             "extmake:text nmake %s",

/*  Default macros */
//
// the F1 key is assigned to this message by default, so that in the case
// that on-line help is NOT loaded, we respond with this message. Once the
// help extension IS loaded, it automatically makes new assignments to these
// keystrokes, and all is well with the world.
//
             "helpnl:=cancel arg \"OnLine Help Not Loaded\" message",
             "helpnl:f1",
             "helpnl:shift+f1",
             "helpnl:ctrl+f1",
             "helpnl:alt+f1",
    NULL
    };

/*
 * exttab is a table used to keep track of cached extension-specific TOOLS.INI
 * sections.
 */
#define MAXEXTS 10                      /* max number of unique extensions*/

struct EXTINI {
    LINE    linSrc;                     /* TOOLS.INI line of the text   */
    char    ext[5];                     /* the file extension (w/ ".")  */
    } exttab[10]        = {0};


flagType         fInCleanExit = FALSE;

char    ConsoleTitle[256];



/*** InitNames - Initialize names used by editor
*
*  Initializes various names used by the editor which are based on the name it
*  was invoked with. Called immediately on entry.
*
* Input:
*  name         = Pointer to name editor invoked as
*
* Output:
*  Returns nothing
*
*  pNameHome    = environment variable to use as "home" directory
*  pNameEditor  = name editor invoked as
*  pNameTmp     = name of state preservation file (M.TMP)
*  pNameInit    = name of tools initialization file (TOOLS.INI)
*  pComSpec     = name of command processor
*
*************************************************************************/
void
InitNames (
    char * name
    )
{
    char *pname = name;
    char *tmp;

    //
    //  Just in case name has blanks after it, we will patch it
    //
    while ( *pname != '\0' &&
            *pname != ' ' ) {
        pname++;
    }
    *pname = '\0';


    if (!getenv(pNameHome = "INIT")) {
        pNameHome = User;
    }

    filename (name, buf);
    pNameEditor = ZMakeStr (buf);

    sprintf (buf, "$%s:%s.TMP", pNameHome, pNameEditor);
    pNameTmp = ZMakeStr (buf);

    sprintf (buf, "$%s:tools.ini", pNameHome);
    pNameInit = ZMakeStr (buf);

    pComSpec = NULL;
    if (!(tmp = (char *)getenvOem("COMSPEC"))) {
        pComSpec = Shell;
    } else {
        //
        //  We cannot keep a pointer to the environment table, so we
        //  point to a copy of the command interpreter path
        //
        char *p = MALLOC(strlen(tmp)+1);
        strcpy(p,tmp);
        pComSpec = p;
        free( tmp );
    }


#if 0
    if (!(pComSpec = getenv("COMSPEC"))) {
        pComSpec = Shell;
    } else {
        //
        //  We cannot keep a pointer to the environment table, so we
        //  point to a copy of the command interpreter path
        //
        char *p = MALLOC(strlen(pComSpec)+1);
        strcpy(p,pComSpec);
        pComSpec = p;
    }
#endif
}





/*** init - one-time editor start-up initialization
*
*  One-time editor initialzation code. This code is executed (only) at
*  start-up, after the command line switches have been parsed.
*
* Input:
*  none
*
* Output:
*  Returns TRUE if valid initialization
*
*************************************************************************/
int
init (
    void
    )
{

    DWORD   TPID;                      /* Thread Id                     */
    KBDMODE Mode;                      /* console mode                  */

    /*
     * Set up the base switch and command sets.
     */
    swiSet[0] = swiTable;
    cmdSet[0] = cmdTable;
    pExtName[0] = ZMakeStr (pNameEditor);

    /*
     * Initialize VM, and bomb off if that didn't work.
     */
        asserte( getlbuf = MALLOC( getlsize ));

    //    fSaveScreen = FALSE;
    //    CleanExit (1, FALSE);
    rgMac = (PCMD *)MALLOC ((long)(MAXMAC * sizeof(PCMD)));
    // assert (_heapchk() == _HEAPOK);


    /*
     * Attempt to get the *current* video state. If it's not one that we
     * understand, bomb off. Else, get the x and y sizes, for possible use later
     * as our editting mode, use postspawn to complete some initialization, and
     * set up our default colors.
         */

    //
    //  Create a new screen buffer and make it the active one.
    //
    InitializeCriticalSection(&ScreenCriticalSection);
    MepScreen          = consoleNewScreen();
    OriginalScreen = consoleGetCurrentScreen();
    if ( !MepScreen || !OriginalScreen ) {
        fprintf(stderr, "MEP Error: Could not allocate console buffer\n");
        exit(1);
    }
    consoleGetMode(&OriginalScreenMode);
        asserte(consoleSetCurrentScreen(MepScreen));
    //
    //  Put the console in raw mode
    //
    Mode = (OriginalScreenMode & ~(CONS_ENABLE_LINE_INPUT | CONS_ENABLE_PROCESSED_INPUT | CONS_ENABLE_ECHO_INPUT )) | CONS_ENABLE_MOUSE_INPUT ;
    consoleSetMode(Mode);
    SetConsoleCtrlHandler( CtrlC, TRUE );

    consoleFlushInput();

    postspawn (FALSE);

    hgColor     = GREEN;
    errColor    = RED;
    fgColor     = WHITE;
    infColor    = YELLOW;
    staColor    = CYAN;
    selColor    = WHITE << 4;
    wdColor     = WHITE;

    //
    //  Remember console title
    //
    ConsoleTitle[0] = '\0';
    GetConsoleTitle( ConsoleTitle, sizeof(ConsoleTitle) );

    /*
     * Create the clipboard
     */
    pFilePick = AddFile ("<clipboard>");
    pFilePick->refCount++;
    SETFLAG (FLAGS(pFilePick), REAL | FAKE | DOSFILE | VALMARKS);

    mepInitKeyboard( );          // Init the keyboard

    //
    //  Initialize the critical section that we use for thread
    //  synchronization
    //
    InitializeCriticalSection(&IOCriticalSection);
    InitializeCriticalSection(&UndoCriticalSection);

    //
    //  Create the semIdle event
    //

    asserte(semIdle = CreateEvent(NULL, FALSE, FALSE, NULL));



    /*
     * Create list of fully qualified paths for files on argument line, then
     * if files were specified, ensure that we are in initial state
     */
    SetFileList ();


    /*
     * Try to read the TMP file
     */
    ReadTMPFile ();


    /*
     * Update the screen data to reflect whatever resulted from reading the .TMP
     * file.
     */
    SetScreen ();


    /*
     * read tools.ini for 1st time
     */
    loadini (TRUE);

        SetScreen ();

        //
        //      Set the cursor size
        //
        SetCursorSize( CursorSize );

    //
    //  Make sure that hscroll is smaller than the window's width
    //
    if ( hscroll >= XSIZE ) {
        hscroll = XSIZE-1;
    }

    AutoLoadExt ();

    /*
     * Create the Idle time thread
     */

    if (!CreateThread(NULL, TSTACK * 2, (LPTHREAD_START_ROUTINE)IdleThread, NULL, 0, &TPID)) {
        disperr(MSGERR_ITHREAD);
    }


    /*
     * Create background threads for <compile> and <print>,
     */
    pBTDComp  = BTCreate (rgchComp);
    pBTDPrint = BTCreate (rgchPrint);

        assert(_pfilechk());
    return TRUE;
}





/*** DoInit - Load init file section
*
*  load from tools.ini, the tag name-tag into the editor configuration
*  table. set ffound to true if we find the appropriate file
*
* Input:
*  tag          = the name of the subsection to be read, or NULL for base
*                 section
*  pfFound      = Pointer to flag to be set TRUE if any assignment is actually
*                 made. May also be NULL.
*  linStart     = line number to start processing from if we already have
*                 a tools.ini. This make re-reading a previously read
*                 section faster.
*
* Output:
*  Returns TOOLS.INI line number of matching section. Assignments may be made,
*  and pfFound updated accordingly.
*
*************************************************************************/
LINE
DoInit (
    char *tag,
    flagType *pfFound,
    LINE    linStart
    )
{
    pathbuf  buf;                           /* full filename for TOOLS.INI  */
    buffer   bufTag;                        /* full tag to look for         */
    LINE     cLine;                         /* line in TOOLS.INI            */
    REGISTER char *pTag;                    /* pointer to tag, if found     */

    /*
     * if Tools.Ini hasn't already been found, attempt to locate it, and read in
     * it's contents.
     */
    if (pFileIni == NULL) {
        linStart = 0;
        pFileIni = (PFILE)-1;
        assert (pNameInit);
        if (findpath (pNameInit, buf, TRUE)) {
            pFileIni = FileNameToHandle (buf, NULL);
            if (pFileIni == NULL) {
                pFileIni = AddFile (buf);
                assert (pFileIni);
                pFileIni->refCount++;
                SETFLAG (FLAGS(pFileIni), DOSFILE);
            }
            if (!TESTFLAG (FLAGS(pFileIni), REAL)) {
                FileRead (buf, pFileIni, FALSE);
            }
        }
    }

    if (pFileIni != (PFILE)-1) {
        /*
         * If there is no starting line number, form the full tag name to be looked
         * for, and scan the file for it.
         */
        if (!(cLine = linStart)) {
            strcpy( bufTag, pNameEditor );
            // strcpy (bufTag, "mepnt"); //pNameEditor);
            if (tag != NULL && *tag != '\0') {
                strcat (strcat (bufTag, "-"), tag);
                }
            _strlwr (bufTag);
            linStart = cLine = LocateTag(pFileIni, bufTag);
        }

        /*
         * if the section was found, scan that section, until a new tag line
         * is found, and process the contents of that section
         */
        if (cLine) {
            pTag = NULL;
            while (pTag = GetTagLine (&cLine, pTag, pFileIni)) {
                DoAssign (pTag);
                if (pfFound) {
                    *pfFound = TRUE;
                }
                //assert (_heapchk() == _HEAPOK);
            }
        }
    }
    return linStart;
}





/*** IsTag - returns pointer to tag if line is marker; NULL otherwise
*
*  Identify tag lines in TOOLS.INI
*
* Input:
*  buf          = pointer to string to check
*
* Output:
*  Returns pointer to tag if line is marker; NULL otherwise
*
*************************************************************************/
char *
IsTag (
    REGISTER char *buf
    )
{
    REGISTER char *p;

    assert (buf);
    buf = whiteskip (buf);
    if (*buf++ == '[') {
        if (*(p = strbscan (buf, "]")) != '\0') {
            *p = 0;
            return buf;
        }
    }
    return NULL;
}





/*** LocateTag - Find TAG in TOOLS.INI formatted file
*
*  Locates a specific tag
*
* Input:
*  pFile        = pFile of file to be searched
*  pText        = text of the tag (no brackets)
*
* Output:
*  Returns line number +1 of tag line
*
*************************************************************************/
LINE
LocateTag (
    PFILE   pFile,
    char    *pText
    )
{
    buffer  buf;                            /* working buffer               */
    char    c;                              /* temp char                    */
    LINE    lCur;                           /* current line number          */
    char    *pTag;                          /* pointer to tag               */
    char    *pTagEnd;                       /* pointer to end of            */

    for (lCur = 0; lCur < pFile->cLines; lCur++) {
        GetLine (lCur, buf, pFile);
        if (pTagEnd = pTag = IsTag (buf)) {
            while (*pTagEnd) {
                pTagEnd = whitescan (pTag = whiteskip (pTagEnd));
                c = *pTagEnd;
                *pTagEnd = 0;
                if (!_stricmp (pText, pTag)) {
                    return lCur+1;
                }
                *pTagEnd = c;
            }
        }
    }
    return 0L;
}

/*** InitExt - execute extension-dependant TOOLS.INI assignments
*
*  Executes the assignments in the user's TOOLS.INI that are specific to a
*  particular file extension.
*
*  We cache the text of the tools.ini section in VM the first time it is read,
*  such that TOOLS.INI need not be read on every file change. This cache is
*  invalidated (and freed) on execution of the initialize command.
*
* Input:
*  szExt        = Pointer to string containing extension. MAX 4 CHARACTERS!
*
* Output:
*  Returns TRUE if section found & executed.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
flagType
InitExt (
    char    *szExt
    )
{
    flagType f;                             /* random flag                  */
    static int iDiscard         = 0;        /* roving discard index         */
    struct EXTINI *pIni;                    /* pointer to found entry       */
    struct EXTINI *pIniNew      = NULL;     /* pointer to new entry */

    /*
     * Only do this if we actually have a valid tools.ini. Before the initial
     * TOOLS.INI read, pFileIni will be zero, and we should not do this, because
     * we might cause it to be read (and then loadini will destroy some of what
     * happened, but not all). In cases where there simply is not TOOLS.INI
     * pFileIni may be -1, but that's caught later.
     */
    if (pFileIni == NULL) {
        return FALSE;
    }

    /*
     * Search init table for the line number of cached init section, and as soon
     * as found, re-read that section. ALSO, as we're walking, keep track of any
     * free table entries we find, so that we can create a cache if it's not.
     */
    for (pIni = &exttab[0]; pIni <= &exttab[9]; pIni++) {
        if (!strcmp (szExt, pIni->ext)) {
            pIni->linSrc = DoInit (szExt, &f, pIni->linSrc);
            return TRUE;
        }
        if (!(pIni->ext[0])) {
            pIniNew = pIni;
        }
    }

    /*
     * we did not find the table entry for the extension, then attempt to create
     * one. This means get rid of one, if there is no room.
     */
    if (!pIniNew) {
        pIni = &exttab[iDiscard];
        iDiscard = (iDiscard + 1) % 10;
    } else {
        pIni = pIniNew;
    }
    strcpy (pIni->ext, szExt);

    /*
     * read the section once to get the size. If the section does not exist, then
     * discard the table entry, and look for the default section "[M-..]"
     */
    if (pIni->linSrc = DoInit (szExt, &f, 0L)) {
        return TRUE;
    }
    pIni->ext[0] = 0;
    DoInit ("..", &f, 0L);
    return FALSE;
}




/*** loadini - load tools.ini data
*
*  Reads TOOLS.INI at startup, and when the initialize function is used.
*
* Input:
*  fFirst       = true if call at startup
*
* Output:
*  Returns
*
*************************************************************************/
int
loadini (
    flagType fFirst
    )
{
    buffer   buf;
    flagType fFound = FALSE;
    int i;

    /*
     * Clear current keyboard assignments
     */
    if (!fFirst) {
        FreeMacs ();
        for (i = 0; i < cMac; i++) {
            FREE ((char *)rgMac[i]->arg);
            FREE (rgMac[i]);
        }
        cMac = 0;
        // assert (_heapchk() == _HEAPOK);
    }
    FmtAssign ("curFileNam:=");
    FmtAssign ("curFile:=");
    FmtAssign ("curFileExt:=");

    /*
     * Load up the default settings for Z. These are stored as a simple
     * table of strings to be handed to DoAssign. Their format is identical
     * to that in the TOOLS.INI file.
     */
    for (i = 0; initTab[i]; i++) {
        DoAssign (strcpy((char *)buf, initTab[i]));
    }

    /*
     * if /D was not specified on startup, read tools.ini sections.
     */
    if (!fDefaults) {
        /*
         * Global editor section
         */
        DoInit (NULL, &fFound, 0L);

        /*
         * OS version dependent section
         */
        //sprintf (buf, "%d.%d", _osmajor, _osminor);
        //if (_osmajor >= 10 && !_osmode) {
        //    strcat (buf, "R");
        //}
        //DoInit (buf, &fFound, 0L);

        /*
         * screen mode dependant section
         */
        DoInit (VideoTag(), &fFound, 0L);
    }

    /*
     * if we have a current file, set filename macros, and read filename
     * extension specific TOOLS.INI section
     */
    if (pFileHead) {
        fInitFileMac (pFileHead);
    }

    newscreen ();

    /*
     * initialize variables whose initial values are dependant on tools.ini
     * values. These are generally "last setting" switches used in menu displays
     */
    fSrchCasePrev = fSrchCaseSwit;
    fSrchWrapPrev = fSrchWrapSwit;

    // assert (_heapchk() == _HEAPOK);
    assert (_pfilechk());

    return fFound;
}




/*** zinit - <initialize> editor function
*
* Input:
*  Standard Editor Function
*
* Output:
*  Returns TRUE if successful
*
*************************************************************************/
flagType
zinit (
    CMDDATA argData,
    ARG *pArg,
    flagType fMeta
    )
{
    flagType    f;
    buffer      ibuf;

    /*
     * clear old version of tools.ini, and clear any cached extension-specific
     * tools.ini stuff
     */
    if (pFileIni != NULL && (pFileIni != (PFILE)-1)) {
        RemoveFile (pFileIni);
        pFileIni = NULL;
        memset ((char *)exttab, '\0', sizeof (exttab));
    }

    ibuf[0] = 0;

    switch (pArg->argType) {

    case NOARG:
        f = (flagType)loadini (FALSE);
        break;

    case TEXTARG:
        strcpy (ibuf, pArg->arg.textarg.pText);
        DoInit (ibuf, &f, 0L);
        break;
    }

    if (!f) {
        disperr (MSGERR_TOOLS, ibuf);
    }
    return f;

    argData;  fMeta;
}




/*** fVideoAdjust - set screen modes
*
*  understand what the screen capabilities are and adjust screen desires to
*  match up with screen capabilities.
*
*  The routine GetVideoState does the following:
*
*       Set up the fnMove/fnStore routine based upon screen capabilities
*       Return a handle encoding the possible and current display modes.
*
*  Once this is complete, the user will request a particular size. The
*  request comes from either tools.ini or from the Z.TMP file. Tools.ini
*  gives the first-approximation of what the screen really should be. Z.TMP
*  gives the final determination.
*
*  Given the type returned by GetVideoState, we will adjust xSize/ySize,
*  Zvideo and the window layout. If the screen can support a particular
*  xSize/ySize, then we set them up and return an indicator that
*  SetVideoState should be called.
*
*  If a particular xSize/ySize cannot be supported, the screen is left
*
*  Multiple windows present presents a problem. The best that we can do is
*  to toss all stored window information. We will return a failure
*  indication so that Z.TMP read-in can be suitably modified.
*
* Input:
*  xSizeNew     = new size for xSize
*  ySizeNew    = new size for ySize
*
* OutPut:
*  Returns TRUE if sizes are allowed
*
*************************************************************************/
flagType
fVideoAdjust (
    int xSizeNew,
    int ySizeNew
    )
{
    //int                 newState;
        SCREEN_INFORMATION      ScrInfo;

    if ( xSizeNew <= hscroll ) {
        return FALSE;
    }
        if ( !SetScreenSize ( ySizeNew+2, xSizeNew ) ) {
        return FALSE;
    }

        consoleGetScreenInformation( MepScreen, &ScrInfo );

    //Zvideo = newState;

        XSIZE = ScrInfo.NumberOfCols;
        YSIZE = ScrInfo.NumberOfRows-2;

    SetScreen ();
    return TRUE;
}



//
//  BUGBUG should be in console header
//
BOOL
consoleIsBusyReadingKeyboard (
    );

BOOL
consoleEnterCancelEvent (
    );


/*** CtrlC - Handler for Control-C signal.
*
*   Invalidate any type ahead and leave flag around.  If the user presses
*       Ctrl-C or Ctrl-Break five times without getting the tfCtrlc flag
*   cleared, assume that the editor is hung and exit.
*
* Input:
*  none
*
* Output:
*  Returns nothing
*  Sets fCtrlc
*
*************************************************************************/
int
CtrlC (
        ULONG   CtrlType
    )
{

    if ( !fSpawned ) {
        CleanExit(4, FALSE );
    }
    return TRUE;

    //if ( (CtrlType == CTRL_BREAK_EVENT) ||
    //     (CtrlType == CTRL_C_EVENT) )  {
    //    if ( !fSpawned ) {
    //        CleanExit(4, FALSE);
    //    }
    //    return TRUE;
    //
    //} else {
    //    return FALSE;
    //}



#if 0
    static int cCtrlC;

    CtrlType;

    FlushInput ();

    if (fCtrlc) {

        /*
        //
        //  BUGBUG The original MEP would coung the number of cTrlC and
        //  ask the user if he/she wanted to exit. How do we do that?
        //

        if (++cCtrlC > 10 ) {
            COL     oldx;
            LINE    oldy;
            int     x;
            char    c = 'x';

            GetTextCursor( &oldx, &oldy );
            bell();
                consoleMoveTo( YSIZE, x = domessage ("**PANIC EXIT** Really exit and lose edits?", NULL));
            while ( c != 'Y' && c != 'N'  ) {
                c = toupper(getch());
            }
            domessage ("                                            ", NULL);
            consoleMoveTo( oldy, oldx );

            if ( c == 'Y' ) {
                CleanExit( 4, FALSE );
            } else {
                fCtrlc = FALSE;
                cCtrlC = 0;
            }
        }
        */
    } else {
                fCtrlc = TRUE;
                cCtrlC = 1;
        if ( consoleIsBusyReadingKeyboard() ) {
             consoleEnterCancelEvent();
        }
    }
    return TRUE;
#endif
}




/*** postspawn - Do state restore/re-init after to a spawn.
*
*  This routine is nominally intended to restore editor state after a spawn
*  operation. However, we also use this during initialization to set it as
*  well.
*
* Input:
*  None
*
* Output:
*  Returns .....
*
*************************************************************************/
void
postspawn (
    flagType fAsk
    )
{
        if (!TESTFLAG(fInit, INIT_VIDEO)) {
                GetScreenSize ( &YSIZE, &XSIZE);
                //
                //      We need at lesast 3 lines:
                //              -       Status Line
                //              -       Message Line
                //              -       Edit line
                //
                if ( YSIZE < 3 ) {
                        YSIZE = 3;
                        SetScreenSize( YSIZE, XSIZE );
                }
                YSIZE -= 2;
        }
        SETFLAG (fInit, INIT_VIDEO);


    if (fAsk) {
                printf ("Please strike any key to continue");
                _getch();
                FlushInput ();
                printf ("\n");
        }

    //if (fSaveScreen) {
    SaveScreen();
    //}

    SetScreen ();

    dispmsg (0);
        newscreen ();

    fSpawned = FALSE;

    SETFLAG (fDisplay, RTEXT | RSTATUS | RCURSOR);
}





/*** VideoTag - return video tag string
*
* Purpose:
*
* Input:
*
* Output:
*
*   Returns
*
*
* Exceptions:
*
* Notes:
*
*************************************************************************/

char *
VideoTag (
    void
    )
{
        return "vga";
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mep\src\zthread.c ===
/*** zthread.c - Contains background processing threads code
*
*   Purpose - Description
*
*     This is a general purpose background threads manager, which allows to
*     create background threads of execution (BTCreate) to which "jobs" are
*     sent for being executed one at a time (BTAdd).
*
*     A "Job" can either be:
*
*     - An external command that will be executed by spawning a
*	command interpreter (the system shell) after standard i/o
*	redirection, so its output will be collected in a "log file"
*	accessible to the user as a Z pseudo-file.
*
*     - A procedure.
*
*     Jobs sent to a background thread are guaranteed to be executed
*     synchronously one at a time in the order they have been sent.
*
*     When killing a background thread, any queued procedure will be called
*     with the fKilled flag on. This allow to have "cleanup" procedures.
*
*   Warnings:
*
*     - Take care that the data any queued procedure will eventually need
*   will be available by the time it will be called.
*
*     - Procedures are called at idle-time (relatively to Z), that means
*   that they can use any Z functionality in them EXCEPT keyboard input.
*
*   How it works:
*
*   while (some work is left to be done) {
*	dequeue an action from the pending queue
*	if (it is an external command) {
*	enter a critical section------------+
*	create a pipe w/proper redirection  |
*	spawn (no-wait) the action	|
*	undo the redirection		|
*	leave the critical section----------+
*	while (fgetl (pipe input)) {
*	    Take semaphore for editing VM
*	    append line to file
*	    Release semaphore
*	    }
*	}
*	else
*	call the procedure
*	}
*
*     Basically, for each external command, we create a pipe, spawn the command
*     and let the child fill the pipe.	When the child exits, the pipe gets
*     broken (we already closed the _write handle on our side) and fgetl gets
*     back an EOF.
*
*
*   Revision History:
*   26-Nov-1991 mz  Strip off near/far
*
*************************************************************************/

#define INCL_DOSQUEUES
#include "mep.h"

//
//  Duplicate a handle in the current process
//
#define DupHandle(a,b) DuplicateHandle(GetCurrentProcess(),    \
				       a,		       \
				       GetCurrentProcess(),    \
				       b,		       \
				       0,		       \
				       TRUE,		       \
				       DUPLICATE_SAME_ACCESS)




#define BTSTACKSIZE 2048

static BTD  *pBTList = NULL;	   /* Background Threads List	    */


#define READ_BUFFER_SIZE    1024

typedef struct _READ_BUFFER {

    PVOID   UserBuffer;
    DWORD   UserBufferSize;
    HANDLE  Handle;
    DWORD   BytesLeftInBuffer;
    PBYTE   NextByte;
    BYTE    Buffer[READ_BUFFER_SIZE];

} READ_BUFFER, *PREAD_BUFFER;

VOID
InitReadBuffer(
    PVOID	    UserBuffer,
    DWORD	    UserBufferSize,
    HANDLE	    Handle,
    PREAD_BUFFER    Buf
    );

BOOL
ReadOneLine (
    PREAD_BUFFER    Buf
    );



/*** BTCreate - Creates a background thread
*
* Purpose:
*  To create a background thread, all we need to do is set up its
*  associated data structure.
*
* Input:
*
*  pName  = A symbolic name for the log file, just as <compile> or <print>.
*	This is the name under wich the user will get acces to the log
*	file.
*
* Output:
*  Returns a pointer to the allocated Background Thread Data structure
*
*************************************************************************/
BTD *
BTCreate (
    char * pName
    )
{
    BTD     *pBTD;	/* pointer to the created background	*/
		/* thread's data structure              */

    /*
     * Allocate the thread's data structure and its log file name
     */
    pBTD = (BTD *) ZEROMALLOC (sizeof (BTD));

    /*
     * Initialize the thread's data structure fields
     */
    pBTD->pBTName   = ZMakeStr (pName);
    pBTD->pBTFile   = NULL;
    pBTD->flags     = BT_UPDATE;
    pBTD->cBTQ	    = pBTD->iBTQPut = pBTD->iBTQGet = 0;

    pBTD->ThreadHandle	= INVALID_HANDLE_VALUE;
    pBTD->ProcAlive	= FALSE;
    InitializeCriticalSection(&(pBTD->CriticalSection));

    /*
     * We maintain a list of background threads data structures. This is used
     * by BTKillAll, BTWorking and BTIdle.
     */
    pBTD->pBTNext = pBTList;
    pBTList = pBTD;

    return (pBTD);
}





/*** BTAdd - Send procedure to be called or external command to be extecuted
*	 by background thread
*
* Input:
*  pBTD  - pointer to thread data structure
*  pProc - pointer to the procedure to be called (NULL if external command)
*  pStr  - pointer to the procedure parameter (or external command to execute
*      if  pBTProc is NULL)
*
* Output:
*
*  Returns TRUE if procedure successfully queued
*
*************************************************************************/
flagType
BTAdd (
    BTD       *pBTD,
    PFUNCTION pProc,
    char      *pStr
    )
{

    HANDLE	Handle;     /*	Thread handle	*/
    DWORD	tid;	    /*	Thread id	*/

    /*
     * We will access the thread's critical data
     */
    EnterCriticalSection(&(pBTD->CriticalSection));


    /*
     * If the queue is full, we cannot insert the request
     */
    if (pBTD->cBTQ == MAXBTQ) {
	LeaveCriticalSection(&(pBTD->CriticalSection));
    return FALSE;
    }


    /*
     * If the queue is empty AND there is no thread running,
     * we have to start the thread...
     */
    if (pBTD->cBTQ == 0 && !fBusy(pBTD)) {
    /*
     * Create the log file if it doesn't exist yet
     */
    if (!(pBTD->pBTFile = FileNameToHandle (pBTD->pBTName, pBTD->pBTName))) {
	pBTD->pBTFile = AddFile (pBTD->pBTName);
	FileRead (pBTD->pBTName, pBTD->pBTFile, FALSE);
	SETFLAG (FLAGS (pBTD->pBTFile), READONLY);

	}

    /*
     * Start the thread
	 */
    if (!(Handle = CreateThread( NULL,
		     BTSTACKSIZE,
		     (LPTHREAD_START_ROUTINE)BThread,
		     (LPVOID)pBTD,
		     0,
		     &tid))) {
	    LeaveCriticalSection(&(pBTD->CriticalSection));
	    return FALSE;
	}
	pBTD->ThreadHandle = Handle;

    }


    /*
     * Since there IS room, we just put the job at the PUT pointer.
     */
    pBTD->BTQJob[pBTD->iBTQPut].pBTJProc = pProc;
    pBTD->BTQJob[pBTD->iBTQPut].pBTJStr  = pStr ? ZMakeStr (pStr) : NULL;

    pBTD->cBTQ++;
    pBTD->iBTQPut = (pBTD->iBTQPut >= (MAXBTQ - 1)) ?
		0 :
		pBTD->iBTQPut + 1;

    /*
     * We're finished with critical data
     */
    LeaveCriticalSection(&(pBTD->CriticalSection));

    return TRUE;
}





/*** BTKill - Kill background job, if in progress
*
* Purpose:
*  Kills the background job and flushes the thread's associated queue
*
* Input:
*  pBTD - pointer to thread data structure
*
* Output:
*  Returns TRUE if background thread ends up idling, else false.
*
* Notes:
*  We'll call the queued procedures with fKilled flag on, and we'll free
*  the allocated strings.
*  We won't free the thread's stack (the thread has to finish).
*
*************************************************************************/
flagType
BTKill (
    BTD     *pBTD
    )
{
    REGISTER ULONG iBTQ;	     /* just an index to the queue elements  */

    assert (pBTD);

    /*
     * We'll work if somthing's running and the user confirms
     */
    if ((fBusy(pBTD))
     && confirm ("Kill background %s ?", pBTD->pBTName)
       ) {


    /*
     * We will access critical data
	 */
	EnterCriticalSection(&(pBTD->CriticalSection));

    /*
     * Kill any child process
	 */

	if (pBTD->ProcAlive) {
	    TerminateProcess(pBTD->ProcessInfo.hProcess, 0);
	    pBTD->ProcAlive = FALSE;
	}

    /*
     * Flush the queue:
     *	 - Call the queued procedures with fKilled flag on
     *	 - Free the strings
     */
    for (iBTQ = pBTD->iBTQGet;
	 iBTQ != pBTD->iBTQPut;
	 iBTQ = (iBTQ >= MAXBTQ - 1) ? 0 : iBTQ + 1
	) {
	    if (pBTD->BTQJob[iBTQ].pBTJProc != NULL) {
		(*pBTD->BTQJob[iBTQ].pBTJProc) (pBTD->BTQJob[iBTQ].pBTJStr, TRUE);
	    }
	    if (pBTD->BTQJob[iBTQ].pBTJStr != NULL) {
		FREE (pBTD->BTQJob[iBTQ].pBTJStr);
	    }
	}

    pBTD->cBTQ = pBTD->iBTQPut = pBTD->iBTQGet = 0;

    /*
     * We're done with critical data
	 */
	LeaveCriticalSection(&(pBTD->CriticalSection));

    /*
     * We know the background thread didn't finish its job yet (It needs
     * at least to get the semaphore before exiting), but we pretend...
     */
    return TRUE;
    }

    return (flagType) (!fBusy(pBTD));
}




/*** BTKillAll - Kill all background jobs, for editor termination
*
* Purpose:
*  Kills all background jobs and flush all threads' associated queues
*
* Input:
*  none
*
* Output:
*  Returns TRUE if all background jobs have been killed, else false.
*
*************************************************************************/
flagType
BTKillAll (
    void
    )
{
    REGISTER BTD *pBTD;     /* pointer for scanning the threads list	*/

    for (pBTD = pBTList; pBTD != NULL; pBTD = pBTD->pBTNext) {
	if (!BTKill (pBTD)) {
	    return FALSE;
	}
    }
    return TRUE;
}



/*** BTWorking - Checks if any background processing is underway...
*
* Input:
*  None
*
* Output:
*  Returns TRUE if some background processing is active, FALSE otherwise
*
* Notes:
*  We are just scanning each thread queue status using the global list.
*
*************************************************************************/
flagType
BTWorking (
    void
    )
{
    REGISTER BTD *pBTD;     /* pointer for scanning the threads list	*/

    for (pBTD = pBTList; pBTD != NULL; pBTD = pBTD->pBTNext) {
	if (fBusy(pBTD)) {
	    break;
	}
    }
    return (flagType) (pBTD != NULL);
}





/*** BThread - Separate thread that starts up jobs as they are put in the queue
*
* Input:
*   Nothing
*
* Output:
*   Nothing
*
* Notes:
*   - We won't send any message nor have any user interaction neither
*     call any non-reentrant procedure, except at idle time.
*
*
*************************************************************************/

//  #pragma check_stack (off)
void
BThread (
    BTD *pBTD
    )
{
					    /* and for reading the pipe       */
    PFUNCTION	pProc;			    /* procedure to be called	      */
    char    *pStr;			    /* External command or parameter  */


    while (TRUE) {

	//
	//  We will access critical data
	//

	EnterCriticalSection(&(pBTD->CriticalSection));

	//
	//  If there's nothing in the queue, we end the thread.
	//

	if (pBTD->cBTQ == 0) {
	    pBTD->flags &= ~BT_BUSY;
	    SETFLAG (fDisplay, RSTATUS);
	    LeaveCriticalSection(&(pBTD->CriticalSection));
	    ExitThread( 0 );
	    }

	//
	//  Set the status as busy
	//

	pBTD->flags |= BT_BUSY;
	SETFLAG (fDisplay, RSTATUS);

	//
	//  Copy out the Job
	//

	pProc = pBTD->BTQJob[pBTD->iBTQGet].pBTJProc;
	pStr  = pBTD->BTQJob[pBTD->iBTQGet].pBTJStr;

	pBTD->cBTQ--;
	pBTD->iBTQGet = (pBTD->iBTQGet >= (MAXBTQ - 1)) ?
			0 :
			pBTD->iBTQGet + 1;

	//
	//  We're done with the critical data
	//

	LeaveCriticalSection(&(pBTD->CriticalSection));

	if (pProc != NULL) {

	    //
	    //	Procedure to call: we'll do it at idle time and we'll free any
	    //	stored parameter
	    //

        WaitForSingleObject( semIdle, INFINITE);
	    (*pProc) (pStr, FALSE);
	    if (pStr)
		FREE (pStr);
	    SetEvent( semIdle );
	    }
	else {

	    //
	    //	External command to spawn: First we build the command line
	    //

	    //
	    //	Here we spawn processes under the Win32 subsystem of
	    //	NT.
	    //

	    char    CommandLine[MAX_PATH];	//  Command line
	    BOOL    StatusOk;			//  status value
	    HANDLE  SavedStdIn; 		//  Original Standard Input
	    HANDLE  SavedStdOut;		//  Original Standard Output
	    HANDLE  SavedStdErr;		//  Original Standard Error
	    HANDLE  PipeRead;			//  Pipe - read end
            HANDLE  PipeWrite;                  //  Pipe - write end
            HANDLE  OutHandle, ErrHandle;
	    STARTUPINFO 	StartupInfo;	//  Startup information
	    linebuf LineBuf;			//  Buffer for 1 line
	    READ_BUFFER  ReadBuffer;
	    BOOL    MoreToRead = TRUE;		//  There is more to read
	    SECURITY_ATTRIBUTES PipeAttributes; //  Pipe Security attributes


	    strcpy(CommandLine, pComSpec);	//  Call command interpreter
	    strcat(CommandLine," /c "); 	//  and execute
	    strcat(CommandLine, pStr);		//  the specified command

	    //
	    //	First we save the standard handles
	    //

	    SavedStdIn	= GetStdHandle(STD_INPUT_HANDLE);
	    SavedStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	    SavedStdErr = GetStdHandle(STD_ERROR_HANDLE);

	    //
	    //	Create a pipe
	    //

	    PipeAttributes.nLength		=   sizeof(SECURITY_ATTRIBUTES);
	    PipeAttributes.lpSecurityDescriptor =   NULL,
	    PipeAttributes.bInheritHandle	=   TRUE;
	    StatusOk = CreatePipe( &PipeRead,
				   &PipeWrite,
				   &PipeAttributes,
				   0 );

	    if (!StatusOk) {
		domessage("Cannot create pipe - did not create process.");
		continue;
		}

	    //
	    //	We will mess with standard handles, so do it
	    //	in the IO critical section.
	    //

	    EnterCriticalSection(&IOCriticalSection);

	    //
	    //	Redirect standard handles
	    //

            SetStdHandle(STD_INPUT_HANDLE,  INVALID_HANDLE_VALUE);
	    SetStdHandle(STD_OUTPUT_HANDLE, PipeWrite);
	    SetStdHandle(STD_ERROR_HANDLE,  PipeWrite);

	    //
	    //	Start the process
	    //

	    memset(&StartupInfo, '\0', sizeof(STARTUPINFO));
	    StartupInfo.cb = sizeof(STARTUPINFO);

	    StatusOk = CreateProcess( NULL,
				      CommandLine,
				      NULL,
				      NULL,
				      TRUE,
				      0,
				      NULL,
				      NULL,
				      &StartupInfo,
				      &(pBTD->ProcessInfo) );

	    //
	    //	Now restore the original handles
	    //
            OutHandle = GetStdHandle(STD_OUTPUT_HANDLE);
            CloseHandle(OutHandle);

            ErrHandle = GetStdHandle(STD_ERROR_HANDLE);

            if (ErrHandle != OutHandle && ErrHandle != INVALID_HANDLE_VALUE)
                CloseHandle(ErrHandle);


	    SetStdHandle(STD_INPUT_HANDLE,  SavedStdIn);
	    SetStdHandle(STD_OUTPUT_HANDLE, SavedStdOut);
	    SetStdHandle(STD_ERROR_HANDLE,  SavedStdErr);

	    LeaveCriticalSection(&IOCriticalSection);


	    if (StatusOk) {

		//
		//  Copy all the output to the log file
		//

		InitReadBuffer( LineBuf, sizeof(linebuf), PipeRead, &ReadBuffer );

		while (MoreToRead) {

		    if (ReadOneLine( &ReadBuffer ) ) {

			//
			//  Append the new line
			//

                        WaitForSingleObject( semIdle, INFINITE);
                            AppFile (LineBuf, pBTD->pBTFile);

			//
			//  If the update flag is on, then we must update
			//  instances of the file so the last line we read
			//  will be displayed
			//
			if (pBTD->flags & BT_UPDATE)
			    UpdateIf (pBTD->pBTFile, pBTD->pBTFile->cLines - 1, FALSE);

			SetEvent( semIdle );

			}
		    else {
			//
			//  We only stop trying if the process has terminated
			//
			if (WaitForSingleObject((pBTD->ProcessInfo.hProcess), 0 ) == 0)
			    MoreToRead = FALSE;
			}
		    }

		//
                //  Close the pipe handles (Note that the PipeWrite handle
                //  was closed above)

                WaitForSingleObject( semIdle, INFINITE);
                CloseHandle(PipeRead);
                SetEvent( semIdle );

		//
		// Wait for the spawned process to terminate
		//
		}

        WaitForSingleObject( semIdle, INFINITE);
	    if (pStr)
		FREE (pStr);
	    bell ();
	    SetEvent( semIdle );

	    }

	}
}
// #pragma check_stack ()


VOID
InitReadBuffer(
    PVOID	    UserBuffer,
    DWORD	    UserBufferSize,
    HANDLE	    Handle,
    PREAD_BUFFER    Buf
    )
{
    Buf->UserBuffer	    = UserBuffer;
    Buf->UserBufferSize     = UserBufferSize;
    Buf->Handle 	    = Handle;
    Buf->BytesLeftInBuffer  = 0;
    Buf->NextByte	    = Buf->Buffer;
}


int
ReadOneChar (
    PREAD_BUFFER    pbuf
    )
{
    //
    //	Check to see if buffer is empty
    //

    if (pbuf->BytesLeftInBuffer == 0) {

	//
	//  Check to see if a fill of the buffer fails
	//

	if (!ReadFile (pbuf->Handle, pbuf->Buffer, READ_BUFFER_SIZE, &pbuf->BytesLeftInBuffer, NULL)) {

	    //
	    //	Fill failed, indicate buffer is empty and return EOF
	    //

	    pbuf->BytesLeftInBuffer = 0;
	    return -1;
	    }

	//
	//  Check to see if nothing read
	//
	if (pbuf->BytesLeftInBuffer == 0)
	    return -1;

	pbuf->NextByte = pbuf->Buffer;
	}

    //
    //	Buffer has pbuf->BytesLeftInBuffer chars left starting at
    //	pbuf->NextByte
    //

    pbuf->BytesLeftInBuffer--;
    return *pbuf->NextByte++;
}

//
//  Assumes tabs are 8 spaces wide on input
//


BOOL
ReadOneLine (
    PREAD_BUFFER    pbuf
    )
{
    PBYTE p;
    PBYTE pEnd;
    int c;
    int cchTab;

    //
    //	Set pointer to beginning of output buffer
    //

    p = (PBYTE)pbuf->UserBuffer;
    pEnd = p + pbuf->UserBufferSize - 1;

    //
    //	read in chars, ignoring \r until buffer is full, \n, or \0
    //	expands tabs
    //

    while (p < pEnd) {
	c = ReadOneChar (pbuf);

	//
	//  CR is noise in line (we ignore it)
	//

	if (c == '\r')
	    continue;

	//
	//  EOF or NL is end-of-line indicator
	//

	if (c == -1 || c == '\n')
	    break;

	//
	//  tabs are expanded to 8 column boundaries, but not to
	//  overflow the line
	//

	if (c == '\t') {
	    cchTab = 8 - (ULONG)(p - (PBYTE)pbuf->UserBuffer) % 8;
	    cchTab = min (cchTab, (int)(pEnd - p));
	    while (cchTab--)
		*p++ = (BYTE) ' ';
	    }
	else
	    *p++ = (BYTE) c;
	}

    *p = 0;

    return c != -1 || strlen (pbuf->UserBuffer) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mrc\mrc.c ===
/*
 *		mrc.c
 *
 *		Makes RCDATA, #defines, and a table of keywords from a set of of tokens
 *		given as input.
 *
 *		Usage:
 *			mrc <tokens> <header> <resource> <C table>
 *
 *		<tokens> is the filename of the tokens file (.TOK) which lists out the
 *		tokens and optionally, lines to put in the other files. The internal
 *		format of the file is:
 *
 *		goal:		( <BOL> sections <EOL> )*
 *		sections:	comment | seed | token | imbed
 *		comment:	'#' <text>
 *		seed:		'TOKENS' short_int
 *		token:		C_string value <text>*
 *		value:		token_symbol | short_int | C_char_constant
 *		imbed:		'IMBED_IN' dest <EOL> imbed_text <BOL> 'END_IMBED'
 *		dest:		'.H' | '.RC' | '.C'
 *		imbed_text:	( <BOL> <text>* <EOL> )*
 *		<BOL>:		Beginning of line
 *		<EOL>:		End of line
 *
 *		The seed, lets you specify the seed value for the values to be assigned
 *		to each new token_symbol that is found. As a new token_symbol is found
 *		it is written out directly to the .H file as a #define line.
 *
 *		The imbedded text is written out the the corresponding .H, .RC, or .C
 *		file. This makes it possible to maintain just one source file for all
 *		the generated files. As each imbed is encountered, it is written out
 *		to the appropriate file.
 *
 *		When the end of the token file is reached, the set of tokens are sorted
 *		by their corresponding string and then written out to the C file and RC
 *		file.
 *
 *		<header> is the filename of the header file (.H) which will hold
 *		generated #defines which correspond to token_symbols and their assigned
 *		values.
 *
 *		<resource> is the filename of the resource file (.RC) which will hold
 *		a relocatable binary image of the the token lookup table in a RCDATA
 *		field. After any imbedded text, it will be written out as:
 *
 *		KEYWORDS RCDATA
 *		BEGIN
 *			<binary image of a C long>, <binary image of a C short>, // 1
 *				:
 *			<binary image of a C long>, <binary image of a C short>, // n
 *			<binary image of a long 0>, <binary image of a short 0>,
 *			<null terminated string>,								 // 1
 *				:
 *			<null terminated string>								 // n
 *		END
 *
 *		The C shorts hold the token values. The longs hold offsets from the
 *		beginning of the image, to the string for that token value. The long 0
 *		and short 0 denote the end of the look up table and allows the code
 *		that loads the image to find out how many entries there are in the
 *		table.
 *		
 *		<C table> is the filename of the C file (.C) which will hold the
 *		declaration a token lookup table. After any imbedded text, it will be
 *		written out as:
 *
 *		static KEYWORD rgKeyword[] =
 *		{
 *			{ <C_string>, <token_value> },							// 1
 *				:
 *			{ <C_string>, <token_value> },							// n
 *			{ NULL, 0 }
 *		};
 *
 *		Owner: Anthony Xavier V. Francisco
 *
 *		CAVEAT: If the KEYWORD structure in _rtfpars.h is changed, this program
 *				will be utterly useless and will have to updated accordingly.
 */
#include <windows.h>
// #include <ourtypes.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

enum
{
	eTOK,
	eH,
	eRC,
	eC
};

typedef SHORT	TOKEN;

typedef	struct	_keyword
{
	CHAR	*szKeyword;
	TOKEN	token;
} KEYWORD;

FILE *	file[4];								// Streams for input and output
CHAR *	szOpenMode[] = { "r", "w", "w", "w" };	// Stream opening modes
TOKEN	sNextToken = 0;							// Value for next token

// Table of token strings and their values
KEYWORD	rgToken[256];
INT		cToken = 0;

// Table of strings and their token values
KEYWORD	rgKeyword[256];
INT		cKeyword = 0;

// Buffer and pointer used to support MyMalloc()
CHAR	rgchBuffer[4096];
CHAR *	pchAvail = rgchBuffer;

// A scratch pad string used to store temporary C constant string versions of
// a C string.
CHAR szScratch[128];

/*
 *		Error
 *
 *		Purpose:
 *			Print out error messages to stderr with free formatting capabilites
 *
 *		Arguments:
 *			szFmt				printf format string
 *			...					parameter corresponding to format string
 *
 *		Returns:
 *			None.
 */
void __cdecl Error( char * szFmt, ... )
{
	va_list	marker;

	va_start( marker, szFmt );
	vfprintf( stderr, szFmt, marker );
	va_end(marker);

	exit(-1);
}


/*
 *		TrimCRLF
 *
 *		Purpose:
 *			Take away the trailing '\n' and '\r' from a string
 *
 *		Arguments:
 *			sz					string to be trimmed
 *
 *		Returns:
 *			None.
 */
void TrimCRLF( CHAR * sz )
{
	INT		nLen = strlen(sz);
	CHAR *	pch = &sz[ nLen - 1 ];

	while ( nLen && *pch == '\n' || *pch == '\r' )
	{
		*pch-- = '\0';
		--nLen;
	}
}


/*
 *		NSzACmp
 *
 *		Purpose:
 *			Compares two ASCII strings based on ASCII values
 *
 *		Arguments:
 *			szA1	Strings to be compared
 *			szA2
 *
 *		Returns:
 *			< 0		szA1 < szA2
 *			0		szA1 = szA2
 *			> 0		szA1 > szA2
 */
INT NSzACmp( CHAR * szA1, CHAR * szA2 )
{
	while ( *szA1 && ( *szA1 == *szA2 ) )
	{
		++szA1;
		++szA2;
	}
	return *szA1 - *szA2;
}


/*
 *		PchGetNextWord
 *
 *		Purpose:
 *			Collects the group of characters delimitted by whitespace in a
 *			string.
 *
 *		Arguments:
 *			szLine			Pointer to the string where to look for a word
 *			szString		Where to put the word
 *
 *		Returns:
 *			Pointer to the character delimiting the end of the word found. If
 *			none is found, szString will have a length of zero.
 *
 */
CHAR * PchGetNextWord( CHAR * szLine, CHAR *szString )
{
	while ( *szLine && isspace(*szLine) )
		szLine++;

	while ( *szLine && !isspace(*szLine) )
		*szString++ = *szLine++;

	*szString = '\0';

	return szLine;
}


/*
 *		HandleImbed
 *
 *		Purpose:
 *			Takes care of copying lines to be imbedded into a generated file
 *
 *		Arguments:
 *			sz				String containing the destination for the imbedded
 *							lines.
 *
 *		Returns:
 *			None.
 */
void HandleImbed( CHAR * sz )
{
	CHAR	szLine[128];
	CHAR	szString[128];
	FILE *	fileDest;

	if ( !NSzACmp( sz, ".H" ) )
		fileDest = file[eH];
	else if ( !NSzACmp( sz, ".RC" ) )
		fileDest = file[eRC];
	else if ( !NSzACmp( sz, ".C" ) )
		fileDest = file[eC];
	else
		Error( "Can't imbed into %s\n", sz );

	while ( fgets( szLine, sizeof(szLine), file[eTOK] ) )
	{
		TrimCRLF(szLine);

		PchGetNextWord( szLine, szString );
		if ( !NSzACmp( szString, "END_IMBED" ) )
			break;
		fprintf( fileDest, "%s\n", szLine );
	}
}


/*
 *		TranslateQuoted
 *
 *		Purpose:
 *			Takes as C string constant declaration and makes it into a C string
 *			with out the escape characters.
 *
 *		Arguments:
 *			szDest				C string constant declaration to converted
 *
 *		Returns:
 *			None.
 */
void TranslateQuoted( CHAR * szDest )
{
	CHAR	szSrc[128];
	CHAR *	pch = &szSrc[1];

	// Go through the string until the end of string or matching quote
	strcpy( szSrc, szDest );
	while ( *pch && *pch != szSrc[0] )
	{
		switch (*pch)
		{
		case '\\':
			++pch;
			switch(*pch)
			{
			case '\\':
				*szDest++ = '\\';
				break;

			case 'n':
				*szDest++ = '\n';
				break;

			case 'r':
				*szDest++ = '\r';
				break;

			case 't':
				*szDest++ = '\t';
				break;

			default:
				*szDest++ = *pch;
				break;
			}
			break;

		default:
			*szDest++ = *pch;
			break;
		}
		pch++;
	}
	*szDest = '\0';
}


/*
 *		CompareKeywords
 *
 *		Purpose:
 *			Compares to KEYWORD structures to see if their keyword strings
 *			match.
 *
 *		Arguments:
 *			pv1					Pointer to a keyword structure
 *			pv2					Pointer to another keyword structure
 *
 *		Returns:
 *			0	strings are the same
 *			< 0	pv1's string is less than pv2's string
 *			> 0	pv1's string is greater than pv2's string
 */
int __cdecl CompareKeywords( void const * pv1, void const * pv2 )
{
	KEYWORD *	pk1 = ( KEYWORD * ) pv1;
	KEYWORD *	pk2 = ( KEYWORD * ) pv2;

	return NSzACmp( pk1->szKeyword, pk2->szKeyword );
}


/*
 *		MyMalloc
 *
 *		Purpose:
 *			Simulates malloc() by using a staticly allocated buffer.
 *
 *		Arguments:
 *			cb					Number of bytes to allocate
 *
 *		Returns:
 *			Pointer to a set of allocated bytes.
 */
CHAR * MyMalloc( INT cb )
{
	CHAR *	pch;

	pch = pchAvail;
	pchAvail += cb;
	if ( pchAvail - rgchBuffer > sizeof(rgchBuffer) )
		Error( "Not enough memory to satisfy %d byte request\n", cb );
	return pch;
}


/*
 *		AddKeyword
 *
 *		Purpose:
 *			Stores a keyword string and it's corresponding value into a
 *			KEYWORD structure. Space for the string is allocated.
 *
 *		Arguments:
 *			pkeyword			Pointer to a keyword structure
 *			szKeyword			The string to be stored.
 *			token				The token value for this string
 *
 *		Returns:
 *			None.
 */
void AddKeyword( KEYWORD * pk, CHAR * szKeyword, TOKEN token )
{
	pk->token = token;
	pk->szKeyword = ( CHAR * ) MyMalloc( strlen(szKeyword) + 1 );
	if ( pk->szKeyword == NULL )
		Error( "Not enough memory to store %s\n", szKeyword );
	strcpy( pk->szKeyword, szKeyword );
}


/*
 *		TokenLookup
 *
 *		Purpose:
 *			Lookup a token symbol in the rgToken table and return the value
 *			of the token for it. If the token symbol can't be found, add it
 *			to the table and assign the next available token value.
 *
 *		Arguments:
 *			sz				The symbol to lookup
 *
 *		Returns:
 *			The token value for the symbol.
 */
TOKEN TokenLookup( CHAR * sz )
{
	KEYWORD *	pk = rgToken;

	while ( pk->szKeyword && NSzACmp( pk->szKeyword, sz ) )
		pk++;

	if ( pk->szKeyword == NULL )
	{
		pk = &rgToken[cToken++];
		AddKeyword( pk, sz, sNextToken++ );
		fprintf( file[eH], "#define %s\t%d\n", sz, pk->token );
	}

	return pk->token;
}


/*
 *		MakeByte
 *
 *		Purpose:
 *			Write out the representation of a byte for an RCDATA statement into
 *			the RC file.
 *
 *		Arguments:
 *			b					The byte value to be written out.
 *
 *		Returns:
 *			None.
 */
void MakeByte( BYTE b )
{
	fprintf( file[eRC], "\"\\%03o\"", b );
}


/*
 *		MakeShort
 *
 *		Purpose:
 *			Write out the binary image of a short as a RCDATA statement into
 *			the RC file.
 *
 *		Arguments:
 *			s					The short value to be written out.
 *
 *		Returns:
 *			None.
 */
void MakeShort( SHORT s )
{
	BYTE *	pb = ( BYTE * ) &s;
	INT i;

	for ( i = 0; i < sizeof(SHORT); i++ )
	{
		MakeByte(*pb++);
		if ( i + 1 < sizeof(SHORT) )
			fprintf( file[eRC], ", " );
	}
}


/*
 *		MakeLong
 *
 *		Purpose:
 *			Write out the binary image of a long as a RCDATA statement into
 *			the RC file.
 *
 *		Arguments:
 *			l					The long value to be written out.
 *
 *		Returns:
 *			None.
 */
void MakeLong( LONG l )
{
	BYTE *	pb = ( BYTE * ) &l;
	INT i;

	for ( i = 0; i < sizeof(LONG); i++ )
	{
		MakeByte(*pb++);
		if ( i + 1 < sizeof(LONG) )
			fprintf( file[eRC], ", " );
	}
}


/*
 *		SzMakeQuoted
 *
 *		Purpose:
 *			Create the C constant string declaration version of a string and
 *			return a pointer to it.
 *			The created string is kept in a scratchpad which will be
 *			overwritten each time this function is called.
 *
 *		Arguments:
 *			sz				String to make a C constant string version of
 *
 *		Returns:
 *			Pointer to a scratchpad containing C constant string version of
 *			sz
 */
CHAR * SzMakeQuoted( CHAR * sz )
{
	CHAR *	pch = szScratch;

	*pch++ = '"';
	while (*sz)
	{
		switch (*sz)
		{
		case '\n':
			*pch++ = '\\';
			*pch++ = 'n';
			break;

		case '\r':
			*pch++ = '\\';
			*pch++ = 'r';
			break;

		case '\t':
			*pch++ = '\\';
			*pch++ = 't';
			break;

		case '\\':
			*pch++ = '\\';
			*pch++ = '\\';
			break;

		case '"':
			*pch++ = '\\';
			*pch++ = '"';
			break;

		default:
			if (isprint(*sz))
				*pch++ = *sz;
			else
				Error( "Don't know how to deal with ASCII %d\n", *sz );
			break;
		}
		sz++;
	}
	*pch++ = '"';
	*pch = '\0';
	return szScratch;
}

/*
 *		GenerateTable
 *
 *		Purpose:
 *			Generates the C table and RCDATA tables
 *
 *		Arguments:
 *			None.
 *
 *		Returns:
 *			None.
 */
void GenerateTable(void)
{
	KEYWORD *	pk;
	INT			nOffset;

	// Sort the keywords
	qsort( rgKeyword, cKeyword, sizeof(KEYWORD), CompareKeywords );

	// Put the header for the C table
	fprintf( file[eC], "static KEYWORD rgKeyword[] =\n{\n" );

	// Put the header for the RCDATA
	fprintf( file[eRC], "TOKENS RCDATA\nBEGIN\n" );

	// Output our keyword table
	pk = rgKeyword;
	nOffset = sizeof(rgKeyword);
	while ( pk->szKeyword != NULL )
	{
		// Add the string and token to the C file
		fprintf( file[eC], "\t{ %s, %d },\n", SzMakeQuoted(pk->szKeyword),
																pk->token );

		// Add the table entry into the RC file
		MakeLong(nOffset);
		fprintf( file[eRC], ", " );
		MakeShort(pk->token);
		fprintf( file[eRC], ", /* %d, %d */\n", nOffset, pk->token );
		nOffset += strlen(pk->szKeyword) + 1;

		pk++;
	}

	// Put the NULL entry for the RCDATA
	MakeLong(0);
	fprintf( file[eRC], ", " );
	MakeShort(pk->token);
	fprintf( file[eRC], ", /* %d, %d */\n", 0, pk->token );

	// Put the NULL entry for the C table and end the table
	fprintf( file[eC], "\t{ NULL, 0 }\n};\n" );

	// Output our keyword strings
	pk = rgKeyword;
	while ( pk->szKeyword != NULL )
	{
		if ( isprint(*pk->szKeyword) )
			fprintf( file[eRC], "\"%s\\0\"", pk->szKeyword );
		else
		{
			MakeByte( *pk->szKeyword );
			fprintf( file[eRC], ", " );
			MakeByte(0);
		}
		pk++;
		if ( pk->szKeyword != NULL )
			fprintf( file[eRC],",");
		fprintf( file[eRC],"\n");
	}
	fprintf( file[eRC], "END\n\n" );
}


int __cdecl main( int argc, char * argv[] )
{
	INT		i;
	CHAR	szLine[128];
	CHAR	szString[128];
	CHAR	szToken[128];
	CHAR	*pchCurr;
	TOKEN	token;

	// Verify we have enough parameters
	if ( argc != 5 )
		Error( "usage: %s tokens.TOK header.H resource.RC table.C\n", argv[0] );

	// Blank out our buffers
	memset( rgToken, 0, sizeof(rgToken) );
	memset( rgKeyword, 0, sizeof(rgKeyword) );
	memset( rgchBuffer, 0, sizeof(rgchBuffer) );

	// Open the files
	for ( i = eTOK; i <= eC; i++ )
		if ( ( file[i] = fopen( argv[ i + 1 ], szOpenMode[i] ) ) == NULL )
		{
			perror( argv[ i + 1 ] );
			return -1;
		}

	// Go through every line in the tokens file
	while ( fgets( szLine, sizeof(szLine), file[eTOK] ) )
	{
		TrimCRLF(szLine);

		// Skip blank lines
		if ( strlen(szLine) == 0 )
			continue;

		// Skip comments
		if ( szLine[0] == '#' )
			continue;

		// Get the first word
		pchCurr = PchGetNextWord( szLine, szString );

		// Do we want to imbed some text someplace ?
		if ( !NSzACmp( szString, "IMBED_IN" ) )
		{
			PchGetNextWord( pchCurr, szString );
			HandleImbed(szString);
			continue;
		}

		// Do we want to reset the lowest token value ?
		if ( !NSzACmp( szString, "TOKENS" ) )
		{
			PchGetNextWord( pchCurr, szString );
			sNextToken = (TOKEN)atoi(szString);
			continue;
		}

		// Are we specifying a string on this line ?
		if ( szString[0] == '"' )
		{
			// Remove the quotes from the string
			TranslateQuoted(szString);

			// Get the next word to find out what token value should go with
			// this string
			PchGetNextWord( pchCurr, szToken );

			if ( szToken[0] == '\'' )
			{
				// We have a single character equivalent for this token.
				TranslateQuoted(szToken);
				token = *szToken;
			}
			else if ( isdigit(szToken[0]) )
				token = (TOKEN)atoi(szToken);
			else
				token = TokenLookup(szToken);

			// Add the token and string pair to our table
			AddKeyword( &rgKeyword[cKeyword++], szString, token );
		}
	}

	// Generate the RC data for the RC file
	GenerateTable();

	// Close the files
	for ( i = eTOK; i <= eC; i++ )
		fclose(file[i]);
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mkmsg\mkmsg.c ===
/*** MkMsg.c - Microsoft Make Messages Utility *******************************
*
*       Copyright (c) 1986-1992, Microsoft Corporation. All Rights Reserved.
*
* Purpose:
*  MkMsg.Exe is a utility that helps localize messages emitted by a utility by
*  padding them and placing them in message segments.
*      MkMsg also allows a programmer to associate symbols and Message Id to a
*  message text. It does this by producing a C style header file with #defines
*  or a Masm style include file with symbol definitions.
*
* Revision History:
*  02-Oct-1996 DS Remove special '\\' handling in RC output.
*  02-Feb-1994 HV Handle lines with only blansk.
*  25-Jan-1994 HV Add -err to generate external error file in the format:
*                 NUMBER\tMESSAGE
*  24-Jan-1994 HV Allow quoted message
*  21-Jan-1994 HV Nuke Lead Byte Table [[ ... ]], add !codepage directive
*  21-Jan-1994 HV Field separated by white spaces
*  19-Aug-1993 BW Add Lead Byte Table support
*  07-Apr-1993 BW Add -hex, -c options
*  13-Jul-1992 SB Add -msg option
*  16-Apr-1990 SB Add header
*  13-Apr-1990 SB Collated 6 different versions seperately SLM'ed on \\ODIN
*  19-Apr-1989 LN add "\xhh" recognition
*  ??-Apr-1986 RN Created by Randy Nevin
*
* Syntax:
*       MKMSG [-h cfile] [-x xcfile] [-inc afile] [-msg cfile] [-c cfile]
*               [-asm srcfile [-def str] [-min|-max]] [-386] [-hex] txtfile
*
* Notes:
*  The Utility takes as input a message file (a .txt file by convention) and
*  produces an assembler source file. The lines in the message file have one
*  of the formats which are instructions to MkMsg as follows -
*
*       1) "<<NMSG>>"  -- use near message segment
*       2) "<<FMSG>>"  -- use far message segment
* ----- Obsolete, see 8)
*       3) "[[XX, YY, ZZ]] - Use hex bytes XX, YY, ZZ as lead byte table.
*                            Lists are cumulative, empty list clears table.
* -----
*       4) "#Anything" -- comment line (ignored by mkmsg)
*       5) ""          -- blank line (ignored by mkmsg)
*       6) "Handle<White space>Number<White space>MessageText" -- associate MessageText with
*               message Id Number and the symbol Handle
*       7) "Number<White space>MessageText" -- associate MessageText with Id
*               Id Number
*   8) "!codepage xxx"  -- use this instead of [[ ... ]]
*
* Options:
*       The options can be specified in any order. When no options are specified
*       then the input is checked for syntactic validity.
*
*
*       -h cfile:          create a C style header file cfile with
*                                       #define Handle IdNumber
*                                       If -c is also defined, a declaration for __NMSG_TEXT
*                                       and a mcros defining GET_MSG as __NMSG_TEXT is added.
*  -msg cfile:          create a C style header file cfile with
*                                       array of struct having fields id and str
*       -c cfile:               create a file like -msg and add a definition
*                                       of a retrieval function
*       -x xcfile:              create a C style header file xcfile with
*                                       #define Handle MessageText
*       -inc afile:             create a MASM style include file afile with
*                                       Handle = IdNumber
*  -asm srcfile:        create a MASM source file srcfile with standard segment
*                                       definitions and messages in near segment (MSG) or far
*                                       segment (FAR_MSG) depending on whether <<NMSG>> or
*                                       <<FMSG>> is specified. The default is <<NMSG>>.
*
*                                       If -min(-max) is specified then the minimum(maximum)
*                                       0-padding is calculated and placed in srcfile. This
*                                       depends on the total length of the individual messages.
*
*                                       If -def is specified the public symbol str gets declared.
*                                       This is useful if the the object file produced from the
*                                       MASM source produced is part of a library. The linker
*                                       will link in that module from the library only if it
*                                       resolves some external references.
*
*                                       If -hex is specified and no Lead Byte Table is
*                                       present, all MessageText is rendered in printf-style
*                                       hexidecimal (e.g. "error" becomes
*                                       x65\x72\x72\x6f\x72").
*
*                                       if -hex is specified and a Lead Byte Table is present
*                                       even if it is empty), then all Double Byte characters
*                                       are rendering in hexidecimal.
*
* Future Directions:
*  1> Break up main() into smaller routines
*  2> Use mkmsg for handling messages
*  2> Allow use of spaces as separators, -- done. HV.
*  3> Allow specification of the separator
*  4> Provide -? and -help options.
*
*****************************************************************************/

// DEFINEs


// Standard INCLUDEs

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <locale.h>
#include <mbctype.h>

// Project INCLUDEs
// MACROs
// External PROTOTYPEs


// TYPEDEFs

typedef enum { FALSE = 0, TRUE = !0 } BOOL;

typedef struct status {
        char *txt;
        char *h;
        char *rc;
        char *x;
        char *inc;
        char *msg;
        char *c;
        char *asm;
        char *def;
        char *err;
        int min;
        int max;
        int use32;
        int hex;
} STATUS;


// Global PROTOTYPEs

void __cdecl Error(char *fmt, ...);
int __cdecl main(int argc, char **argv);
void parseCommandLine(unsigned argc, char **argv, STATUS *opt);
void msg_fputs (unsigned char * pch, int, FILE * fp);
int  ReadLine (FILE * fp);
BOOL ParseLine(char **ppSymbol, char **ppNumber, char **ppMessage);
BOOL HandleDirectives(void);
void SetCodePage (const char *pszCodePage);
BOOL IsLeadByte(unsigned by);

// WARNING:     the following CRT function is undocumented.  This call can only
//                      be used in our internal product (like this one) only.  Please
//                      contact CRT people for more information.
//void __cdecl __setmbctable(unsigned int);

//
//  Lead Byte support
//
unsigned char                           bUseLeadByteTable = FALSE;

typedef struct
{
        unsigned        uCodePage;              // Codepage number
        unsigned        byLead[12];             // Leadbyte ranges
} CPTABLE;

CPTABLE cpTable[] =
{
        {932, {0x81, 0x9f, 0xe0, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},
        {0,   {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}} // trailing to end
};

CPTABLE * pCP = NULL;

// Local PROTOTYPEs
// External VARIABLEs


// Initialized VARIABLEs

int cError = 0;

char didnear = 0;
char didfar = 0;

char dir32[] = ".386\n";

char ex[] = "expected escape sequence: %s\n";

char f1[] = "FAR_HDR segment byte public \'FAR_MSG\'\nFAR_HDR ends\n";
char f2[] = "FAR_MSG segment byte public \'FAR_MSG\'\nFAR_MSG ends\n";
char f3[] = "FAR_PAD segment byte public \'FAR_MSG\'\nFAR_PAD ends\n";
char f4[] = "FAR_EPAD segment byte common \'FAR_MSG\'\nFAR_EPAD ends\n";
char f5[] = "FMGROUP group FAR_HDR,FAR_MSG,FAR_PAD,FAR_EPAD\n\n";

char n1[] = "HDR segment byte public \'MSG\'\nHDR ends\n";
char n2[] = "MSG segment byte public \'MSG\'\nMSG ends\n";
char n3[] = "PAD segment byte public \'MSG\'\nPAD ends\n";
char n4[] = "EPAD segment byte common \'MSG\'\nEPAD ends\n";
char n5[] = "DGROUP group HDR,MSG,PAD,EPAD\n\n";
char usage[] = "\nMicrosoft (R) Message Creation Utility         Version %s"
        "\nCopyright (c) Microsoft Corp %s. All rights reserved.\n"
        "\nusage: MKMSG [-h cfile] [-rc rcfile] [-x xcfile] [-msg cfile]\n"
        "\t[-c cfile] [-err errfile] [-inc afile]\n"
        "\t[-asm srcfile [-def str] [-min|-max]] [-386] [-hex] txtfile\n";
char szVersionNo[] = "1.00.0011";
char szCopyRightYrs[] = "1986-1996";


// Local VARIABLEs

#define MSGSTYLE_COPY       0
#define MSGSTYLE_C_HEX      1
#define MSGSTYLE_ASM_BYTE   2
#define MSGSTYLE_ASM_TEXT   3

#define FALSE 0
#define TRUE  (!FALSE)

#define INBUFSIZE   1024

//static char buf[INBUFSIZE];   // line buffer
char *buf;                                      // The real buffer is in ReadLine()

//--------------------------------------------------------------------------

int  __cdecl
main(int argc, char **argv)
{
        FILE *f;                        // the input file
        FILE *fh = NULL;            // -h stream
        FILE *frc = NULL;              // -rc stream
        FILE *fx = NULL;            // -x stream
        FILE *fc = NULL;            // -c stream
        FILE *finc = NULL;          // -inc stream
        FILE *fmsg = NULL;          // -msg stream
        FILE *fasm = NULL;          // -asm stream
        FILE *ferr = NULL;              // -err stream
        int asmstate = 0;           // 0=nothing, 1=doing nmsg, 2=doing fmsg
        int instring;           // db "...
        unsigned int nLineCur = 0;      // Current line
        unsigned int cchLine;           // Chars in current line
        char *p;
        int npad = 0;           // cumulative amount of near padding
        int fpad = 0;           // cumulative amount of far padding
        int length;
        double factor;
        double result;

        static STATUS opt;              // Command line options

        parseCommandLine(argc, argv, &opt);

        if ((opt.def || opt.min || opt.max ) && !opt.asm) {
                Error( "-def/-min/-max ignored; no -asm file\n" );
                opt.min = opt.max = 0;
        }

        if (opt.min && opt.max) {
                Error( "-min and -max are mutually exclusive; -min chosen\n" );
                opt.max = 0;
        }

        if (!(f = fopen( opt.txt, "rb" ))) {
                Error( "can't open txtfile %s for binary reading\n", opt.txt );
                return( -1 );
        }

        if (opt.asm && !(fasm = fopen( opt.asm, "w" ))) {
                Error( "can't open -asm file %s for writing\n", opt.asm );
                return( -1 );
        }

        if (opt.h && !(fh = fopen( opt.h, "w" ))) {
                Error( "can't open -h file %s for writing\n", opt.h );
                return( -1 );
        }

        if (fh && opt.c) {
                fprintf (fh, "char * __NMSG_TEXT (unsigned);\n\n");
        }

        if (opt.rc && !(frc = fopen(opt.rc, "w")))
        {
                Error("Can't open -rc file %s for writing\n", opt.rc);
                return -1;
        }

        if (opt.rc) {
                fprintf(frc, "STRINGTABLE\nBEGIN\n");
        }

        if (opt.x && !(fx = fopen( opt.x, "w" ))) {
                Error( "can't open -x file %s for writing\n", opt.x );
                return( -1 );
        }

        if (opt.inc && !(finc = fopen( opt.inc, "w" ))) {
                Error( "can't open -inc file %s for writing\n", opt.inc );
                return( -1 );
        }

        if (opt.msg && !(fmsg = fopen( opt.msg, "w" ))) {
                Error( "can't open -msg file %s for writing\n", opt.msg );
                return( -1 );
        }

        if (opt.err && !(ferr = fopen(opt.err, "w")))
        {
                Error("Can't open -err file %s for writing\n", opt.err);
                return -1;
        }

        if (fmsg) {
                fprintf(fmsg, "typedef struct _message {\n"
                                  "\tunsigned\tid;\n"
                                  "\tchar *str;\n"
                                  "} MESSAGE;\n\n");
                fprintf(fmsg, "MESSAGE __MSGTAB[] = {\n");
        }

        if (opt.c && !(fc = fopen( opt.c, "w" ))) {
                Error( "can't open -c file %s for writing\n", opt.c );
                return( -1 );
        }

        if (fc) {
                fprintf(fc, "#include <stdio.h>\n\n");
                fprintf(fc, "typedef struct _message {\n"
                                "\tunsigned int\tid;\n"
                                "\tchar *str;\n"
                                "} MESSAGE;\n\n");
                fprintf(fc, "MESSAGE __MSGTAB[] = {\n");
        }

        while ((cchLine = ReadLine ( f )) != EOF)       // process lines
        {
                nLineCur++;
                if (buf[0] == '\0' || buf[0] == '#')
                {
                        continue;
                }
                else if (HandleDirectives())                    // Directive
                {
                        continue;
                }
                else if (buf[0] == '[' && buf[1] == '[')        // Old style leadbyte tbl
                {
                        fprintf(stderr,
                                "WARNING: Ignore leadbyte table, use !codepage instead: %s\n",
                                buf);
                        continue;
                }
                else if (buf[0] == '<')                                 // <<NMSG>> or <<FMSG>>
                {
                        if (!strcmp( "<<NMSG>>", buf ))         // near msgs follow
                        {
                                if (asmstate == 0)
                                {
                                        if (fasm)
                                        {
                                                if (!didnear) {
                                                        didnear++;
                                                        if (opt.use32)
                                                                fprintf( fasm, dir32);
                                                        fprintf( fasm, n1 );
                                                        fprintf( fasm, n2 );
                                                        fprintf( fasm, n3 );
                                                        fprintf( fasm, n4 );
                                                        fprintf( fasm, n5 );
                                                }
                                                fprintf( fasm,
                                                        "MSG segment\n" );
                                                if (opt.def)
                                                {
                                                        fprintf( fasm, "\tpublic\t%s\n", opt.def );
                                                        fprintf( fasm, "%s\tequ\t$\n", opt.def );
                                                }
                                                asmstate = 1;
                                        } // if (fasm)
                                } // if (asmstate == 0)
                                else if (asmstate == 1)
                                {
                                        Error( "already in nmsg\n" );
                                }
                                else if (asmstate == 2 && !opt.use32)
                                {
                                        if (fasm)
                                        {
                                                fprintf( fasm, "FAR_MSG ends\n\n" );
                                                if (!didnear)
                                                {
                                                        didnear++;
                                                        fprintf( fasm, n1 );
                                                        fprintf( fasm, n2 );
                                                        fprintf( fasm, n3 );
                                                        fprintf( fasm, n4 );
                                                        fprintf( fasm, n5 );
                                                }
                                                fprintf( fasm, "MSG segment\n" );
                                                asmstate = 1;
                                        } // if (fasm)
                                } // else if (asmstate == 2 ...)
                                else
                                {
                                        Error( "internal error\n" );
                                        return( -1 );
                                }
                        } // if near msg
                        else if (!strcmp( "<<FMSG>>", buf ))//far msgs follow
                        {
                                if (asmstate == 0)
                                {
                                        if (fasm)
                                        {
                                                if (!didfar)
                                                {
                                                        didfar++;
                                                        if (opt.use32)
                                                        {
                                                                fprintf( fasm, dir32);
                                                                fprintf( fasm, n1 );
                                                                fprintf( fasm, n2 );
                                                                fprintf( fasm, n3 );
                                                                fprintf( fasm, n4 );
                                                                fprintf( fasm, n5 );
                                                                fprintf( fasm, "MSG segment\n" );
                                                        }
                                                        else
                                                        {
                                                                fprintf( fasm, f1 );
                                                                fprintf( fasm, f2 );
                                                                fprintf( fasm, f3 );
                                                                fprintf( fasm, f4 );
                                                                fprintf( fasm, f5 );
                                                                fprintf( fasm, "FAR_MSG segment\n" );
                                                        }
                                                } // if (!didfar)
                                                if (opt.def)
                                                {
                                                        fprintf( fasm, "\tpublic\t%s\n", opt.def );
                                                        fprintf( fasm, "%s\tequ\t$\n", opt.def );
                                                }
                                                asmstate = 2;
                                        } // if (fasm)
                                } // if (asmstate == 0)
                                else if (asmstate == 1 && !opt.use32)
                                {
                                        if (fasm)
                                        {
                                                fprintf( fasm, "MSG ends\n\n" );
                                                if (!didfar)
                                                {
                                                        didfar++;
                                                        fprintf( fasm, f1 );
                                                        fprintf( fasm, f2 );
                                                        fprintf( fasm, f3 );
                                                        fprintf( fasm, f4 );
                                                        fprintf( fasm, f5 );
                                                }
                                                fprintf( fasm, "FAR_MSG segment\n" );
                                                asmstate = 2;
                                        }
                                } // else if (asmstate == 1 ...)
                                else if (asmstate == 2)
                                {
                                        Error( "already in far_msg\n" );
                                }
                                else
                                {
                                        Error( "internal error\n" );
                                        return( -1 );
                                }
                        } // far message
                        else    // Not near, not far
                        {
                                Error( "ignoring bad line: %s\n", buf );
                        }
                } // if (.. < ) near/far message
                else if (buf[0] != '\r' && buf[0] != '\n')              // something to do
                {
                        char *pSymbol;
                        char *pNumber;
                        char *pMessage;

                        if (!ParseLine(&pSymbol, &pNumber, &pMessage))
                        {
                                fprintf( stderr, "%s(%d): error in line: \"%s\"\n", opt.txt, nLineCur, buf);
                                continue;
                        }

                        if (pSymbol && opt.h)
                        {
                                fprintf( fh, "#define\t%s\t%s\n", pSymbol, pNumber );
                        }

                        if (opt.rc)
                        {
                                fprintf(frc, "\t%s, \"%s\"\n", pNumber, pMessage);
                        }

                        if (pSymbol && opt.x)
                        {
                                fprintf( fx, "#define\t%s\t\"", pSymbol );
                                msg_fputs( pMessage
                                , opt.hex ? MSGSTYLE_C_HEX : MSGSTYLE_COPY
                                , fx );
                                putc( '\"', fx );
                                putc( '\n', fx );
                        }

                        if (pSymbol && opt.inc)
                        {
                                fprintf( finc, "%s\t=\t%s\n", pSymbol, pNumber);
                        }

                        if (opt.msg)
                        {
                                fprintf( fmsg, "{%s, \"", pNumber );
                                msg_fputs( pMessage, opt.hex ? MSGSTYLE_C_HEX : MSGSTYLE_COPY, fmsg );
                                fprintf( fmsg, "\"}," );
                                if (opt.hex)
                                        fprintf( fmsg, " // \"%s\"", pMessage );
                                putc ( '\n', fmsg );
                        }

                        if (opt.c)
                        {
                                fprintf( fc, "{%s, \"", pNumber );
                                msg_fputs( pMessage, opt.hex ? MSGSTYLE_C_HEX : MSGSTYLE_COPY, fc );
                                fprintf( fc, "\"}," );
                                if (opt.hex)
                                        fprintf( fc, " // \"%s\"", pMessage );
                                putc ( '\n', fc );
                        }

                        if (opt.err)
                        {
                                fprintf(ferr, "%s\t\"%s\"\n", pNumber, pMessage);
                        } // opt.err

                        if (fasm)       // write asmfile
                        {
                                if (asmstate == 0)
                                {
                                        if (!didnear)
                                        {
                                                didnear++;
                                                if (opt.use32)
                                                        fprintf( fasm, dir32);
                                                fprintf( fasm, n1 );
                                                fprintf( fasm, n2 );
                                                fprintf( fasm, n3 );
                                                fprintf( fasm, n4 );
                                                fprintf( fasm, n5 );
                                        }
                                        fprintf( fasm, "MSG segment\n" );
                                        if (opt.def)
                                        {
                                                fprintf( fasm, "\tpublic\t%s\n", opt.def );
                                                fprintf( fasm, "%s\tequ\t$\n", opt.def );
                                        }
                                        asmstate = 1;
                                } // if (asmstate == 0)
                                fprintf( fasm, "\tdw\t%s\n\tdb\t", pNumber );
                                instring = 0;

                                for (p = pMessage, length = 0; *p; p++, length++)
                                {
                                        // allocate message
                                        if (*p == '\\')
                                        {
                                                // C escape sequence
                                                switch (*++p)
                                                {
                                                        case 'r':
                                                        case 'n':
                                                        case 't':
                                                        case 'f':
                                                        case 'v':
                                                        case 'b':
                                                        case '\'':
                                                        case '"':
                                                        case '\\':
                                                        case 'x':
                                                                if (instring) {
                                                                        putc( '"', fasm );
                                                                        putc( ',', fasm );
                                                                        instring = 0;
                                                                }
                                                                if (*p == 'x') {
                                                                        p++;
                                                                        if (*p && *(p+1))
                                                                                fprintf ( fasm, "0%c%ch", *p, *(p+1));
                                                                        else
                                                                                puts ("Error in Hex Constant");
                                                                        p++;
                                                                }
                                                                else if (*p == 'r')
                                                                        fprintf( fasm, "13" );
                                                                else if (*p == 'n')
                                                                        fprintf( fasm, "10" );
                                                                else if (*p == 't')
                                                                        fprintf( fasm, "9" );
                                                                else if (*p == 'f')
                                                                        fprintf( fasm, "12" );
                                                                else if (*p == 'v')
                                                                        fprintf( fasm, "11" );
                                                                else if (*p == 'b')
                                                                        fprintf( fasm, "8" );
                                                                else if (*p == '\'')
                                                                        fprintf( fasm, "39" );
                                                                else if (*p == '"')
                                                                        fprintf( fasm, "34" );
                                                                else if (*p == '\\')
                                                                        fprintf( fasm, "92" );

                                                                putc( ',', fasm );
                                                                break;

                                                        case '\0':
                                                                //not an error, warning ...
                                                                fprintf(stderr, ex, buf);
                                                                p--;
                                                                break;

                                                        default:
                                                                if (!instring) {
                                                                        putc( '"', fasm );
                                                                        instring = 1;
                                                                }

                                                                putc( *p, fasm );
                                                                break;
                                                } // switch
                                        } //if (*p == '\\')
                                        else if (instring)      // keep building string
                                        {
                                                putc( *p, fasm );
                                                if (IsLeadByte(*p))
                                                        putc( *++p, fasm );
                                        }
                                        else   // start building string
                                        {
                                                putc( '"', fasm );
                                                instring = 1;
                                                putc( *p, fasm );
                                                if (IsLeadByte(*p))
                                                        putc( *++p, fasm );
                                        }
                                } // for
                                if (instring)   // close string
                                {
                                        putc( '"', fasm );
                                        putc( ',', fasm );
                                }

                                putc( '0', fasm );
                                putc( '\n', fasm );

                                // calculate padding
                                // depends on msg length
                                if (opt.min || opt.max)
                                {
                                        if (opt.min)
                                                if (length <= 10)
                                                        factor = 1.01;
                                                else if (length <= 20)
                                                        factor = 0.81;
                                                else if (length <= 30)
                                                        factor = 0.61;
                                                else if (length <= 50)
                                                        factor = 0.41;
                                                else if (length <= 70)
                                                        factor = 0.31;
                                                else
                                                        factor = 0.30;
                                        else if (length <= 10)
                                                factor = 2.00;
                                        else if (length <= 20)
                                                factor = 1.00;
                                        else if (length <= 30)
                                                factor = 0.80;
                                        else if (length <= 50)
                                                factor = 0.60;
                                        else if (length <= 70)
                                                factor = 0.40;
                                        else
                                                factor = 0.30;

                                        result = (double)length * factor;

                                        if (asmstate == 1 || opt.use32)
                                        {
                                                npad += (int)result;
                                                if (result > (float)((int)result))
                                                        npad++;
                                        }
                                        else if (asmstate == 2)
                                        {
                                                fpad += (int)result;
                                                if (result > (float)((int)result))
                                                        fpad++;
                                        }
                                } // if (opt.min || opt.max)
                        } // if (fasm)...
                } // Something to do
        } // while read line

        if (fmsg) { // finish up -msg stuff
                fprintf(fmsg, "{0, NULL}\n};\n");
        }

        if (fc) // finish up -c stuff
        {
                fprintf(fc, "{0, NULL}\n};\n\n");

                fprintf(fc, "char * __NMSG_TEXT(\n" );
                fprintf(fc, "unsigned msgId\n" );
                fprintf(fc, ") {\n" );
                fprintf(fc, "        MESSAGE *pMsg = __MSGTAB;\n" );
                fprintf(fc, "\n" );
                fprintf(fc, "        for (;pMsg->id; pMsg++) {\n" );
                fprintf(fc, "                if (pMsg->id == msgId)\n" );
                fprintf(fc, "                        break;\n" );
                fprintf(fc, "        }\n" );
                fprintf(fc, "        return pMsg->str;\n" );
                fprintf(fc, "}\n" );
        } // if (fc)

        if (fasm)  // finish up asm file
        {
                if (asmstate == 1 || opt.use32)
                        fprintf( fasm, "MSG ends\n\n");
                else if (asmstate == 2)
                        fprintf( fasm, "FAR_MSG ends\n\n");

                if (npad) {  // add near padding
                        fprintf( fasm, "PAD segment\n\tdb\t%d dup(0)\n", npad );
                        fprintf( fasm, "PAD ends\n\n" );
                }

                if (fpad) {  // add far padding
                        fprintf( fasm, "FAR_PAD segment\n\tdb\t%d dup(0)\n", fpad );
                        fprintf( fasm, "FAR_PAD ends\n\n" );
                }

                fprintf( fasm, "\tend\n" );
                fclose( fasm );
        } // if (fasm)

        if (fh)
        {
                if (opt.c)
                        fprintf (fh, "\n#define GET_MSG(x) __NMSG_TEXT(x)\n");
                fclose( fh );
        }

        if (frc) {
                fprintf(frc, "END\n");
                fclose( frc );
        }

        if (fx)         fclose( fx );
        if (finc)       fclose( finc );
        if (fmsg)       fclose( fmsg );
        if (fc)         fclose( fc );
        if (ferr)       fclose( ferr );
        fclose( f );

        return(cError ? 1 : 0);
} // main()


void
parseCommandLine(
unsigned argc,
char **argv,
STATUS *opt
)
{
        // skip argv[0]
        argc--; argv++;

        while (argc && **argv == '-')  // process options
        {
                if  (!strcmp("-err", *argv))            // Create .err file
                {
                        argc--; argv++;
                        if (!argc)
                                Error("no -err file given\n");
                        else if (opt->err)
                                Error("extra -err for %s ignored\n", *argv);
                        else
                        {
                                opt->err = *argv;
                                argc--; argv++;
                        }
                } // -err
                else if (!strcmp( "-h", *argv )) {  // create .h file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -h file given\n" );
                        else if (opt->h) {
                        Error( "extra -h file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -h file
                        opt->h = *argv;
                        argc--; argv++;
                        }
                }
                else if  (!strcmp("-rc", *argv)) { // Create .rc file
                        argc--; argv++;
                        if (!argc)
                            Error("no -rc file given\n");
                        else if (opt->rc)
                            Error("extra -rc for %s ignored\n", *argv);
                        else
                        {
                            opt->rc = *argv;
                            argc--; argv++;
                        }
                }
                else if (!strcmp( "-x", *argv )) {  // create .h file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -x file given\n" );
                        else if (opt->x) {
                        Error( "extra -x file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -x file
                        opt->x = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-inc", *argv )) {  // create .inc file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -inc file given\n" );
                        else if (opt->inc) {
                        Error( "extra -inc file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -inc file
                        opt->inc = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-msg", *argv )) {    // create .h file with struct
                        argc--; argv++;
                        if (!argc)
                        Error( "no -msg file given\n" );
                        else if (opt->msg) {
                        Error( "extra -msg file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -msg file
                        opt->msg = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-c", *argv )) {    // create .c file with struct and function
                        argc--; argv++;
                        if (!argc)
                        Error( "no -c file given\n" );
                        else if (opt->c) {
                        Error( "extra -c file %s ignored\n", *argv );
                        argc--; argv++;
                        }
                        else    {  // remember -c file
                        opt->c = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-asm", *argv )) {  // create .asm file
                        argc--; argv++;
                        if (!argc)
                        Error( "no -asm file given\n" );
                        else if (opt->asm) {
                        Error( "extra -asm file %s ignored\n", *argv );
                        argc--;
                        argv++;
                        }
                        else    {  // remember -asm file
                        opt->asm = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-def", *argv )) {
                        argc--; argv++;
                        if (!argc)
                        Error( "no -def string given\n" );
                        else {
                        opt->def = *argv;
                        argc--; argv++;
                        }
                }
                else if (!strcmp( "-min", *argv )) {  // minimum padding
                        argc--; argv++;
                        if (opt->min)
                        Error( "redundant -min\n" );
                        opt->min = 1;
                }
                else if (!strcmp( "-max", *argv )) {  // maximum padding
                        argc--; argv++;
                        if (opt->max)
                        Error( "redundant -max\n" );
                        opt->max = 1;
                }
                else if (!strcmp( "-386", *argv))  {  // 32-bit segments
                        argc--; argv++;
                        if (opt->use32)
                        Error( "redundant -386\n" );
                        opt->use32 = 1;
                }
                else if (!strcmp( "-hex", *argv))  {  // hex rendering of text
                        argc--; argv++;
                        if (opt->hex)
                        Error( "redundant -hex\n" );
                        opt->hex = 1;
                }
                else {
                        Error( "unknown option %s ignored\n", *argv );
                        argc--;
                        argv++;
                }
        } // while
        if (!argc) {  // no arguments
                Error( usage, szVersionNo, szCopyRightYrs );
                exit( -1 );
        }

        if (argc != 1)  // extra arguments
                Error( "ignoring extra arguments\n" );

        opt->txt = *argv;
} // ParseCommandLine()


//
// Read One line into global buf
//
int
ReadLine (FILE * fp)
{
        int i = 0;
        int ch;
        static char szBuffer[INBUFSIZE];

        while ((ch = getc( fp )) != EOF && ch != '\r' && ch != '\n' && ch != '\x1A')
        if (i < INBUFSIZE-1)
                szBuffer[i++] = (char)ch;

        if (ch == EOF && i == 0)
        return EOF;

        if (ch == '\r')
        getc ( fp );    // Flush line feed

        szBuffer[i] = '\0';

        // Skip initial space
        for (buf = szBuffer; *buf && isspace(*buf); buf++)
                i--;

        return i;
}

void
__cdecl
Error(
char *fmt,
...
) {
        va_list args;

        va_start (args, fmt);

        vfprintf(stderr, fmt, args);
        ++cError;
}


///// msg_fputs
//
//  Purpose:
//
//      Send string to file in the given format.
//
//////////////////////////////////////////////////////////////////////////

void msg_fputs(
unsigned char * pch,
int  style,
FILE * fp
) {
char          chbuf[8];
unsigned char bInDBCS = FALSE;
static    int bPrevWasHex = FALSE;

        switch (style)
        {
        case MSGSTYLE_COPY:
                fputs (pch, fp);
                break;

        case MSGSTYLE_C_HEX:
                for (;*pch; pch++) {
                // If a lead byte table was specified, we use hex
                // only for double-byte characters, and for hex
                // digits after hex output.  This later is because
                // hex constants terminate only when a non-hex digit
                // (like a \) is encountered.
                //
                if (!bUseLeadByteTable
                        || bInDBCS || IsLeadByte(*pch)
                        || (bPrevWasHex && isxdigit(*pch))) {

                        sprintf (chbuf, "\\x%2.2x", *pch);
                        fputs (chbuf, fp);
                        bInDBCS = bInDBCS ? FALSE : IsLeadByte(*pch);
                        bPrevWasHex = TRUE;
                        }
                else {
                        fputc(*pch, fp);
                        bPrevWasHex = FALSE;
                        }
                }
                break;

        case MSGSTYLE_ASM_TEXT: // UNDONE
        case MSGSTYLE_ASM_BYTE: // UNDONE
                break;
        }
}


///// SetCodePage
//
//  Purpose:
//
//              Switch to the specified codepage so that we can recognize a lead
//              byte using IsLeadByte().
//
//      Parameters:
//              const char *pszCodePage:        Points to a buffer containing the codepage
//                                                      in the the format of ".xxx" where xxx is
//                                                      the codepage number.
//
//      Note:
//              This function replaces the old SetLeadByteTable(), which fills
//              the global lead byte table with values the user supplied in the
//              message file.
//
///////////////////////////////////////////////////////////////////////////

void
SetCodePage(const char *pszCodePage)
{
        unsigned i;
        unsigned uCodePage;

        if (!setlocale(LC_ALL, pszCodePage))                    // Switch to new locale
        {
                //__setmbctable(atoi(pszCodePage+1));           // Failed, use undoc'ed call
                // Failed, use internal codepage table
                uCodePage = atoi(pszCodePage+1);
                for (i = 0; cpTable[i].uCodePage; i++)
                {
                        if (cpTable[i].uCodePage == uCodePage)  // Found
                        {
                                pCP = &cpTable[i];
                                break;
                        }
                } // for
                if (0 == cpTable[i].uCodePage)
                        fprintf(stderr, "WARNING: unknown codepage: %s\n", pszCodePage+1);
        }
        bUseLeadByteTable = TRUE;
}

#ifdef VERBOSE
#define DB(x) x
#else
#define DB(x)
#endif
BOOL
IsLeadByte(unsigned by)
{
        unsigned byIndex;

        DB(printf("IsLeadByte(0x%02x) ==> ",by));

        if (!bUseLeadByteTable)
        {
                DB(printf("FALSE\n"));
                return FALSE;
        }

        if (!pCP)
#ifdef NT_BUILD
                puts("Codepage support not implemented");
#else
                return _ismbblead(by);
#endif

        for (byIndex = 0; pCP->byLead[byIndex]; byIndex += 2)
        {
                if (pCP->byLead[byIndex] <= by && by <= pCP->byLead[byIndex+1])
                {
                        DB(printf("TRUE\n"));
                        return TRUE;
                }
        }

        DB(printf("FALSE\n"));
        return FALSE;
}

///// ParseLine
//
//  Purpose:
//
//              Break the input line to 3 fields: symbol, number, and message.
//              The symbol field is optional: if the first non-blank char in
//              the line is a digit, then the symbol field is set to NULL.
//
//      Assumption:
//              We assume that the input line has the following formats:
//              [<White space> SYMBOL] <White space> NUMBER <White space> MESSAGE
//              where as the text between the square brackets ([]) is optional.
//
//      Parameters:
//              char **ppSymbol:        Points to the buffer containing the symbol.
//                                                      *ppSymbol == NULL if there is no symbol.
//              char **ppNumber:        Points to the buffer containing the number.
//              char **ppMessage:       Points to the buffer containing the message.
//
//      Use Global:
//              buf             Contains the line to examine.
//
//      Return Value:
//              TRUE:   The line is a valid line.
//              FALSE:  The line is not a valid line.
//
///////////////////////////////////////////////////////////////////////////

BOOL
ParseLine(char **ppSymbol, char **ppNumber, char **ppMessage)
{
        unsigned char *pBuf = buf;

        #define SKIP_BLANKS()   for ( ; *pBuf && isspace(*pBuf); pBuf++)
        #define SKIP_TO_BLANKS()        for ( ; *pBuf && !isspace(*pBuf); pBuf++)
        #define CHECK_NULL()    if (!*pBuf) return FALSE;

        SKIP_BLANKS();                  // Skip initial blanks
        CHECK_NULL();                   // Blank line?

        if (!isdigit(*pBuf))    // Symbol?
        {
                *ppSymbol = pBuf;
                SKIP_TO_BLANKS();
                CHECK_NULL();
                *pBuf++ = '\0';
                SKIP_BLANKS();
                CHECK_NULL();
        }
        else
                *ppSymbol = NULL;

        *ppNumber = pBuf;
        SKIP_TO_BLANKS();
        CHECK_NULL();
        *pBuf++ = '\0';

        SKIP_BLANKS();
        CHECK_NULL();
        *ppMessage = pBuf;

        // Handle quoted message:  if the message does not begin with quote, it is
        // extended to end of line.  If it begins with a double quote character,
        // then it is extended to the closing quote, or end of line, whichever
        // comes first.  While scanning for closing quote, we ignore the '\"',
        // which is the literal quote character.

        if ('\"' == *pBuf)                                      // quoted message
        {
                *ppMessage = ++pBuf;
                while (*pBuf && '\"' != *pBuf)
                {
                        if ('\\' == *pBuf || IsLeadByte(*pBuf))
                                pBuf++;
                        if (*pBuf)
                                pBuf++;
                } // while
                *pBuf = '\0';
        } // if ... quoted message

        return TRUE;
}

///// HandleDirectives
//
//  Purpose:
//
//              Determine if a line contains a directive, then carry out the
//              directive's command.
//
//      Use Global:
//              buf             Contains the line to examine.
//
//      Return Value:
//              TRUE:   The line is a directive.
//              FALSE:  The line is not a directive
//
///////////////////////////////////////////////////////////////////////////

BOOL
HandleDirectives(void)
{
        register unsigned char *pBuf = buf;
        unsigned char *pEnd;

        for ( ; *pBuf && isspace(*pBuf); pBuf++)        // Skip leading spaces
                ;

        if (!_strnicmp("!codepage", pBuf, 9))           // Change the codepage
        {
                for (pBuf += 9; *pBuf && isspace(*pBuf); pBuf++)        // Skip spaces
                        ;
                *--pBuf = '.';
                for (pEnd = pBuf + 1; *pEnd && isdigit(*pEnd); pEnd++)
                        ;
                *pEnd = '\0';
                SetCodePage(pBuf);
                return TRUE;
        }
        else if ('!' == *pBuf)
        {
                Error("Unrecognized directive: '%s'\n", pBuf);
                return TRUE;
        }

        return FALSE;
} // HandleDirectives
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mkupdate\mkupdate.h ===
/*++

Copyright Microsoft Corporation, 1996-7, All Rights Reserved.      

Module Name:

    mkupdate.h

Abstract:

    Defines for application to create the update database from
    appropriately structured input update file and to maintain driver
    revisions

Author:

     Shivnandan Kaushik

Environment:

    User mode

Revision History:


--*/

#ifndef MKUPDATE_H
#define MKUPDATE_H

//
// Signature field returned by CPUID
//

#include "pshpack1.h"

typedef struct _CPU_SIGNATURE {
    union {
        ULONG LongPart;
        struct {
            ULONG   Stepping:4;
            ULONG   Model:4;
            ULONG   Family:4;
            ULONG   ProcessorType:2;
            ULONG   Reserved:18;
        } hw;
    } u;
} CPU_SIGNATURE, *PCPU_SIGNATURE;

typedef struct _PROCESSOR_FLAGS {
    union {
        ULONG LongPart;
        struct {
            ULONG   Slot1:1;
            ULONG   Mobile:1;
            ULONG   Slot2:1;
            ULONG   MobileModule:1;
            ULONG   Reserved1:1;
            ULONG   Reserved2:1;
            ULONG   Reserved3:1;
            ULONG   Reserved4:1;
            ULONG   Reserved:24;
        } hw;
    } u;
} PROCESSOR_FLAGS, *PPROCESSOR_FLAGS;

#define FLAG_SLOT1      0x1
#define FLAG_MOBILE     0x2
#define FLAG_SLOT2      0x4
#define FLAG_MODULE     0x8
#define FLAG_RESERVED1  0x10
#define FLAG_RESERVED2  0x20
#define FLAG_RESERVED3  0x40
#define FLAG_RESERVED4  0x80

#define MASK_SLOT1      ~(FLAG_SLOT1)
#define MASK_MOBILE     ~(FLAG_MOBILE)
#define MASK_SLOT2      ~(FLAG_SLOT2)
#define MASK_MODULE     ~(FLAG_MODULE)
#define MASK_RESERVED1  ~(FLAG_RESERVED1)
#define MASK_RESERVED2  ~(FLAG_RESERVED2)
#define MASK_RESERVED3  ~(FLAG_RESERVED3)
#define MASK_RESERVED4  ~(FLAG_RESERVED4)

// Structure defining a Pentium (R) Pro Processor Update
// This structure is also defined in nt\private\ntos\dd\update\update.h

#define UPDATE_VER_1_HEADER_SIZE 0x30
#define UPDATE_VER_1_DATA_SIZE   500

typedef struct _UPDATE {
    ULONG HeaderVersion;                    // Update Header Version
    ULONG UpdateRevision;                   // Revision number
    ULONG Date;                             // Date of update release
    CPU_SIGNATURE Processor;                // Target processor signature
    ULONG Checksum;                         // Checksum of entire update
                                            // including header
    ULONG LoaderRevision;                   // Loader revision for loading 
                                            // update to processor
    PROCESSOR_FLAGS ProcessorFlags;         // Processor Slot Information
    ULONG Reserved[5];                      // Reserved by Intel Corp. 
    ULONG Data[UPDATE_VER_1_DATA_SIZE];     // Update data
} UPDATE, *PUPDATE;

#include "poppack.h"

typedef struct _UPDATE_ENTRY{
    ULONG CpuSignature;
    ULONG UpdateRevision;
    ULONG ProcessorFlags;
    CHAR  CpuSigStr[32];
    CHAR  UpdateRevStr[32];
    CHAR  FlagsStr[32];
} UPDATE_ENTRY, *PUPDATE_ENTRY;

#define MAX_LINE                512
#define UPDATE_VER_SIZE          13         // Max. characters per patch version
#define UPDATE_DATA_FILE        "updtdata.c"

#define UPDATE_VERSION_FILE     "update.ver"

#endif //MKUPDATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\common.inc ===
CHECKED_ALT_DIR=1

MSC_WARNING_LEVEL = /W4 /WX

C_DEFINES = $(C_DEFINES) \
    /D_WCTYPE_INLINE_DEFINED \
    /DSTRICT \
    /DUNICODE \
    /D_UNICODE \
    /DOLEDBVER=0x0200 \
    /DWIN32

!ifdef MTSCRIPT_DROP
C_DEFINES=$(C_DEFINES) /DMTSCRIPT_DROP /DMTSCRIPT_BUILDNUMBER=$(MTSCRIPT_BUILDNUMBER) /DMTSCRIPT_QFENUMBER=$(MTSCRIPT_QFENUMBER)
!endif

!if !$(FREEBUILD)
USE_RTTI=1
MSC_OPTIMIZATION=/Od
LINKER_NOICF=1      # ICF is s-l-o-w
USE_DEBUGLIB=1
!if $(386)
USE_STACK_SPEW=1
!endif
!else
MSC_OPTIMIZATION=/Oxs
!endif


USE_MSVCRT=1

# Use Win2000 functionality

WIN32_IE_VERSION=0x0500
WIN32_WINNT_VERSION=0x0500
WIN32_WIN95_VERSION=0x0500
SUBSYSTEM_VERSION=5.00

INCLUDES=

CONDITIONAL_INCLUDES= \
    winwlm.h \
    rpcerr.h \
    rpcmac.h \
    macname1.h \
    macpub.h \
    macapi.h \
    macname2.h \
    macocidl.h \
    mainwin.h \
    w16toff.hxx \
    print.h \
    regmsg16.h \
    urlmki.h \
    help.h \
    pgstup16.hxx \
    page.h \
    icapexp.h \
    stdole2.tlb \
    mshtml.tlb

!ifdef BOUNDSCHECKER
BOUNDSCHECKER=1
NO_PRECOMPILED_HEADERS=1
SUBSTITUTE_386_CC=nmcl
LINK_NAME=nmlink
BCHECK_LIBS=c:\progra~1\numega\boundschecker\bcinterf.lib
!else
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Ob1 /Oi
BCHECK_LIBS=
!endif

!ifdef PREFIX
NO_PRECOMPILED_HEADERS=1
SUBSTITUTE_386_CC=prefix.exe
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mkupdate\mkupdate.c ===
/*++

Copyright Microsoft Corporation, 1996-7, All Rights Reserved.      

Module Name:

    mkupdate.c

Abstract:

    Application for creating the update database file from an
    appropriately structured input update file and maintaining
    the driver version in the resource file.

Author:

     Shivnandan Kaushik

Environment:

    User mode

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <winbase.h>
#include <winioctl.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "mkupdate.h"

//
// Globals
//

PUPDATE_ENTRY UpdateTable;

VOID
GenMSHeader(
    FILE *file,
    CHAR *Filename,
    CHAR *Abstract
    )
/*++
Routine Description:

    Generates the Microsoft recommended header for code files.

Arguments:

  File: Output file pointer
  FileName: Output file name
  Abstract: Description of file

Return Value:
    
   None

--*/
{   
    fprintf(file,"/*++ \n\nCopyright (c) 1996-7  Microsoft Corporation, ");
    fprintf(file,"All Rights Reserved.\n\n");
    fprintf(file,"Copyright (c) 1995-2000 Intel Corporation. This update binary code\n");
    fprintf(file,"is distributed for the sole purpose of being loaded into Intel\n");
    fprintf(file,"Pentium(R) Pro Processor Family  and Pentium(R) 4 Family microprocessors.\n");
    fprintf(file,"All Rights on the binary code are reserved.\n\n");
    fprintf(file,"Module Name:\n\n    %s\n\n",Filename);
    fprintf(file,"Abstract:\n\n    %s\n\n",Abstract);
    fprintf(file,"Author:\n\n    !!!THIS IS A GENERATED FILE. DO NOT DIRECTLY EDIT!!!\n\n");
    fprintf(file,"Revision History:\n\n--*/\n\n");
}
    
BOOL
GetVerifyPutUpdate(
    FILE *OutputFile,
    ULONG UpdateNum,
    ULONG TotalUpdates
    )
/*++
Routine Description:

    Read in an update, verify it and write to data file.

Arguments:

    OutputFile: output file pointer
    UpdateNum: Update number in update list
    TotalUpdates: Total number of updates in update list.

Return Value:
    
    TRUE if writes succeeded else FALSE.

--*/
{
    FILE *UpdateFile;
    CHAR Line[MAX_LINE],UpdateString[MAX_LINE];
    CHAR Filename[MAX_PATH];
    BOOL BeginFound,EndFound;
    ULONG CurrentDword,i,Checksum;
    ULONG UpdateBuffer[sizeof(UPDATE)];
    PUPDATE CurrentUpdate;

    // create the string name of the file to open

    strcpy(Filename,UpdateTable[UpdateNum].CpuSigStr);
    strcat(Filename,"_");
    strcat(Filename,UpdateTable[UpdateNum].UpdateRevStr);
    strcat(Filename,".");
    strcat(Filename,UpdateTable[UpdateNum].FlagsStr);

    UpdateFile = fopen(Filename,"r");

    if (UpdateFile == NULL) {
        fprintf(stdout,"mkupdate:Unable to open update input file %s\n",Filename);
        return(FALSE);
    }

    //
    // Read in each update - scan till beginning of update
    // marked by keyword BEGIN_UPDATE
    //

    BeginFound = FALSE;
    while (fgets(Line,MAX_LINE,UpdateFile) != NULL) {
        if (sscanf(Line,"%s",&UpdateString)) {
            if (strcmp(UpdateString,"BEGIN_UPDATE") == 0) {
                BeginFound = TRUE;
                break;
            }
        }
    }

    if (!BeginFound) {
        fprintf(stdout,"mkupdate:BEGIN_UPDATE not found in update file %s\n",Filename);
        fclose(UpdateFile);
        return(FALSE);
    }

    //
    // scan "update size" forward.
    //

    EndFound = FALSE;
    for (i = 0; i < sizeof(UPDATE)/sizeof(ULONG); i++) {
        if (fgets(Line,MAX_LINE,UpdateFile) != NULL) {
            if (sscanf(Line,"%lx",&CurrentDword)) 
                UpdateBuffer[i] = CurrentDword;
        } else {
            EndFound = TRUE;
            break;
        }
    }

    if (EndFound) {
        fprintf(stdout,"mkupdate:Abnormal termination of update file %s\n",Filename);
        fclose(UpdateFile);
        return(FALSE);
    } else {
        if (fgets(Line,MAX_LINE,UpdateFile) != NULL) {
            if (sscanf(Line,"%s",&UpdateString)) {
                if (strcmp(UpdateString,"END_UPDATE") != 0) {
                    fprintf(stdout,"mkupdate:Update data size in %s incorrect\n",Filename);
                    fclose(UpdateFile);
                    return(FALSE);
                }
            }
        } else {
            fprintf(stdout,"mkupdate:Abnormal termination of update file %s\n",Filename);
            fclose(UpdateFile);
            return(FALSE);
        }
    }
    
    fclose (UpdateFile);

    // Verify Update - Checksum Buffer

    Checksum = 0;
    for (i = 0; i < sizeof(UPDATE)/sizeof(ULONG); i++) {
        Checksum += UpdateBuffer[i];
    }

    if (Checksum){
        fprintf(stdout,"mkupdate:Incorrect update checksum in %s\n",Filename);
        return(FALSE);
    } 

    //
    // Verify update - check if processor signature, update revision
    // and processor flags match that specified in listing file and 
    // update data file name
    //

    CurrentUpdate = (PUPDATE) UpdateBuffer;

    if ((CurrentUpdate->Processor.u.LongPart != 
            UpdateTable[UpdateNum].CpuSignature)){
        fprintf(stdout,"mkupdate:incorrect processor signature in %s: ",Filename); 
        fprintf(stdout,"expected 0x%lx got 0x%lx\n",
                        UpdateTable[UpdateNum].CpuSignature,
                        CurrentUpdate->Processor.u.LongPart); 
        return(FALSE);
    }

    if (CurrentUpdate->UpdateRevision != 
            UpdateTable[UpdateNum].UpdateRevision){
        fprintf(stdout,"mkupdate:incorrect update revision in %s: ",Filename); 
        fprintf(stdout,"expected 0x%lx got 0x%lx\n",
                        UpdateTable[UpdateNum].UpdateRevision,
                        CurrentUpdate->UpdateRevision); 
        return(FALSE);
    }

    if ((CurrentUpdate->ProcessorFlags.u.LongPart != 
            UpdateTable[UpdateNum].ProcessorFlags)){
        fprintf(stdout,"mkupdate:incorrect processor flags in %s: ",Filename); 
        fprintf(stdout,"expected 0x%lx got 0x%lx\n",
                        UpdateTable[UpdateNum].ProcessorFlags,
                        CurrentUpdate->ProcessorFlags.u.LongPart); 
        return(FALSE);
    }

    //
    // Input update validated. Write out validated update
    //

    fprintf(OutputFile,"    {\n");
    for (i = 0; i < sizeof(UPDATE)/sizeof(ULONG); i++) {
        fprintf(OutputFile,"        0x%.8x",UpdateBuffer[i]);
        if (i == sizeof(UPDATE)/sizeof(ULONG) - 1) {
            fprintf(OutputFile,"\n");
        } else {
            fprintf(OutputFile,",\n");
        }
    }
    fprintf(OutputFile,"    }");
    if (UpdateNum != TotalUpdates-1) {
        fprintf(OutputFile,",\n");
    }
    
    return(TRUE);
}

VOID
BuildUpdateInfoTable(
    FILE *OutputFile,
    ULONG TotalUpdates
    )
/*++
Routine Description:

    Write the CPU Signature and Processor Flags into the 
    Build Table and adds NULL for the MDL Item.

Arguments:

    OutputFile   :  output file pointer
    TotalUpdates :  Total number of updates in update list.

Return Value:
    
   None:

--*/
{   
    ULONG CpuSignature, ProcessorFlags, i;

    fprintf(OutputFile, "//\n// Update Info Table containing the CPU Signatures,\n");
    fprintf(OutputFile, "// Processor Flags, and MDL Pointers.  The MDL Pointers\n");
    fprintf(OutputFile, "// are initialized to NULL.  They get populated as pages\n");
    fprintf(OutputFile, "// corresponding to specific updates are locked in memory.\n");
    fprintf(OutputFile, "// This table contains the CPU Signatures and Processor Flags.\n");
    fprintf(OutputFile, "// in the same order as in the update database.  Therefore,\n");
    fprintf(OutputFile, "// the Update Info Table self-indexes to the right update.\n//\n\n");
    fprintf(OutputFile, "UPDATE_INFO UpdateInfo[] = {\n");

    //
    // Add each entry for the info
    //

    for (i = 0; i < TotalUpdates; i++) {
        CpuSignature = strtoul(UpdateTable[i].CpuSigStr, NULL, 16);
        ProcessorFlags = strtoul(UpdateTable[i].FlagsStr, NULL, 16);
        if (i < (TotalUpdates - 1)) {
            fprintf(OutputFile, "        {0x%x, 0x%x, NULL},\n", CpuSignature, ProcessorFlags);
        } else {
            fprintf(OutputFile, "        {0x%x, 0x%x, NULL}\n", CpuSignature, ProcessorFlags);
        }
    }
    
    //
    // generate closing code for the update info definition
    //

    fprintf(OutputFile, "};\n");

    return;
}

ULONG
PopulateUpdateList(
    CHAR *ListingFile
    )
/*++
Routine Description:

    Populates the update list with (processor signature, update revision)
    pairs included in the update listing file and returns the number of 
    updates found.

Arguments:

    ListingFile

Return Value:
    
   Number of updates in the update list. 0 if no updates found or any
   error encountered.

--*/
{
    CHAR Line[MAX_LINE],UpdateString[MAX_LINE];
    CHAR CpuSigStr[MAX_LINE],UpdateRevStr[MAX_LINE];
    CHAR FlagsStr[MAX_LINE];
    BOOL BeginFound,EndFound,Error;
    FILE *TmpFilePtr;
    ULONG NumUpdates,i;
    ULONG CpuSignature,UpdateRevision,ProcessorFlags;

#ifdef DEBUG
    fprintf(stderr,"listing file %s\n",ListingFile);
#endif
    // Open the update listing file

    TmpFilePtr = fopen(ListingFile,"r");

    if (TmpFilePtr == NULL) {
        fprintf(stdout,"mkupdate:Unable to open update listing file %s\n",ListingFile);
        return(0);
    };

    //
    // Scan for beginning of the update list marked by
    // BEGIN_UPDATE_LIST keyword
    //
    
    BeginFound = FALSE;
    while ((!BeginFound) && (fgets(Line,MAX_LINE,TmpFilePtr) != NULL)) {
        if (sscanf(Line,"%s",&UpdateString)) {
            if (strcmp(UpdateString,"BEGIN_UPDATE_LIST") == 0) {
                BeginFound = TRUE;
            }
        }
    }

    if (!BeginFound) {
        fprintf(stdout,"mkupdate:BEGIN_UPDATE_LIST not found in update listing file %s\n",ListingFile);
        fclose(TmpFilePtr);
        return(0);
    };

    //
    // Scan for end of the update list marked by
    // END_UPDATE_LIST keyword and count # updates.
    //
    
    NumUpdates = 0;
    EndFound = FALSE;   
    while ((!EndFound) && (fgets(Line,MAX_LINE,TmpFilePtr) != NULL)) {
        if (sscanf(Line,"%s",&UpdateString)) {
            if (strcmp(UpdateString,"END_UPDATE_LIST") == 0) {
                EndFound = TRUE;
            } else {
                NumUpdates++;
            }
        }
    }
    fclose(TmpFilePtr);
    if (!EndFound) {
        fprintf(stdout,"mkupdate:END_UPDATE_LIST not found in update listing file %s\n",ListingFile);
        return(0);
    }
    
    //
    // If legal file format and non-zero number of updates are found
    // then read the processor signatures and update revisions into
    // the update list.
    //
    
    if (NumUpdates) {

        // allocate memory for storing cpu signatures 

        UpdateTable = (UPDATE_ENTRY *) malloc(NumUpdates*sizeof(UPDATE_ENTRY));
        if (UpdateTable == NULL){
            fprintf(stdout,"mkupdate:Error: Memory Allocation Error\n");
            return(0);  
        }

        TmpFilePtr = fopen(ListingFile,"r");
        if (TmpFilePtr == NULL) {
            fprintf(stdout,"mkupdate:Unable to open update listing file %s\n",ListingFile);
            return(0);
        };

        while ((fgets(Line,MAX_LINE,TmpFilePtr) != NULL)) {
            if (sscanf(Line,"%s",&UpdateString)) {
                if (strcmp(UpdateString,"BEGIN_UPDATE_LIST") == 0) {
                    break;
                }
            }
        }

        // Scan the listing file and populate the update table

        Error = FALSE;
        for (i = 0; i < NumUpdates; i++) {
            if (fgets(Line,MAX_LINE,TmpFilePtr) == NULL) {
                fprintf(stdout,"mkupdate: Abnormal termination in update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }

            if (sscanf(Line,"%s %s %s",&CpuSigStr,&UpdateRevStr,&FlagsStr) != 3) {
                fprintf(stdout,"mkupdate: Incorrect format of update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }
#ifdef DEBUG
            fprintf(stderr,"CpuSig %s Update Rev %s Processor Flags %s,\n",CpuSigStr,
                    UpdateRevStr,FlagsStr);
#endif
            if (sscanf(CpuSigStr,"%lx",&CpuSignature) != 1) {
                fprintf(stdout,"mkupdate: Incorrect Processor Signature in update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }
            if (sscanf(UpdateRevStr,"%lx",&UpdateRevision)!= 1) {
                fprintf(stdout,"mkupdate: Incorrect Update Revision of update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }
            if (sscanf(FlagsStr,"%lx",&ProcessorFlags)!= 1) {
                fprintf(stdout,"mkupdate: Incorrect Processor Flags in update listing file %s\n",
                    ListingFile);
                Error = TRUE;
                break;
            }

#ifdef DEBUG
            fprintf(stderr,"CpuSig 0x%lx Update Rev 0x%lx Flags 0x%lx,\n",
                    CpuSignature,UpdateRevision,ProcessorFlags);
#endif
            strcpy(UpdateTable[i].CpuSigStr,CpuSigStr);
            UpdateTable[i].CpuSignature = CpuSignature;
            strcpy(UpdateTable[i].UpdateRevStr,UpdateRevStr);
            UpdateTable[i].UpdateRevision = UpdateRevision;
            strcpy(UpdateTable[i].FlagsStr,FlagsStr);
            UpdateTable[i].ProcessorFlags = ProcessorFlags;
        }

        fclose(TmpFilePtr);
        if (Error) {
            NumUpdates = 0;
            free(UpdateTable);
        }
    }

    return(NumUpdates);
}

VOID
CleanupDataFile(
    VOID
    )
/*++
Routine Description:

    If any operation during the creation of the new Data file fails, 
    then delete it so that the build for the driver will fail.

Arguments:

    None

Return Value:
    
    None

--*/
{
    DeleteFile(UPDATE_DATA_FILE);            
}

BOOL
SanitizeUpdateList(
    ULONG NumUpdates
    )
/*++
Routine Description:

    Sanitizes the update list. Checking for duplicate processor 
    signatures.

Arguments:

  NumUpdates: Number of updates in the update list.

Return Value:
    
    TRUE is list clean else FALSE.

--*/
{
    ULONG i,j;
    PROCESSOR_FLAGS ProcessorFlags;

    //
    // Check for garbage values in the update table
    //

    for (i = 0; i < NumUpdates-1; i++) {
        if (UpdateTable[i].CpuSignature == 0) {
            fprintf(stdout,"mkupdate: Error: incorrect processor signature in update list.\n");
            return(FALSE);    
        }
        if (UpdateTable[i].UpdateRevision == 0) {
            fprintf(stdout,"mkupdate: Error: incorrect update revision in update list.\n");
            return(FALSE);    
        }

        if (UpdateTable[i].ProcessorFlags != 0) {

            // Only a single bit must be set

            ProcessorFlags.u.LongPart = UpdateTable[i].ProcessorFlags;

            if (((ProcessorFlags.u.hw.Slot1) && 
                    (ProcessorFlags.u.LongPart & MASK_SLOT1)) ||
                ((ProcessorFlags.u.hw.Mobile) && 
                    (ProcessorFlags.u.LongPart & MASK_MOBILE)) ||
                ((ProcessorFlags.u.hw.Slot2) && 
                    (ProcessorFlags.u.LongPart & MASK_SLOT2)) ||
                ((ProcessorFlags.u.hw.MobileModule) && 
                    (ProcessorFlags.u.LongPart & MASK_MODULE)) ||
                ((ProcessorFlags.u.hw.Reserved1) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED1)) ||
                ((ProcessorFlags.u.hw.Reserved2) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED2)) ||
                ((ProcessorFlags.u.hw.Reserved3) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED3)) ||
                ((ProcessorFlags.u.hw.Reserved4) && 
                    (ProcessorFlags.u.LongPart & MASK_RESERVED4))) {
                fprintf(stdout,"mkupdate: Error: incorrect processor flags in update list.\n");
                return(FALSE);    
            }
        }
    }
     
    for (i = 0; i < NumUpdates-1; i++) {
        for (j = i+1; j < NumUpdates; j++) {
            if ((UpdateTable[i].CpuSignature == UpdateTable[j].CpuSignature) 
                && (UpdateTable[i].ProcessorFlags == UpdateTable[j].ProcessorFlags)){
                fprintf(stdout,"mkupdate:Error: Duplicate processor entry 0x%lx:0x%lx in update list\n",
                        UpdateTable[i].CpuSignature,UpdateTable[i].ProcessorFlags);
                return(FALSE);
            }
        }
    }
    return(TRUE);
}

int
__cdecl main(
    int argc,
    LPSTR argv[]
    )
/*++
Routine Description:
    Scans the processor update listing file, pick up the specified 
    processor updates, verify the updates and generate the update 
    data file to be used by the update driver. Generates the 
    version numbers and strings to be included in the 
    resource definition file.

Arguments:
    
      listing file: list of the processor updates to be included in 
                    the driver.

Return Value:

--*/
{
    FILE    *DataOut, *RCFile,*VerFile;
    ULONG   NumUpdates,i;
    CHAR    Line[MAX_LINE];
    CHAR    *CurrentDataVersionString;
    BOOL    VerFileFound;
    CHAR    VersionFile[MAX_LINE];
    CHAR    *VersionDirectory;

    VersionFile[0] = 0;

    if (argc < 2) {
        fprintf(stdout,"%s: Usage: %s <patch listing file>\n",argv[0],argv[0]);
        exit(0);
    }
    
#ifdef DEBUG
    fprintf(stderr,"listing file %s\n",argv[1]);
#endif
    
    // Open generated file UPDATE_DATA_FILE. Delete previous file if any.

    DataOut=fopen(UPDATE_DATA_FILE,"w");

    if (DataOut == NULL) {
        fprintf(stdout,"mkupdate:Unable to open update data file %s\n",UPDATE_DATA_FILE);
        exit(0);
    }

    // Scan listing file and store all the CPU signatures in update table

    NumUpdates = PopulateUpdateList(argv[1]);
    if (NumUpdates == 0) {
        fprintf(stdout,"mkupdate:Listing file %s: Incorrect format or no updates specified.\n",
                argv[1]);
        fclose(DataOut);
        exit(0);
    }

    //
    // Dynamically allocate the size for CurrentDataVersionString
    //

    CurrentDataVersionString = (CHAR*)malloc(NumUpdates * UPDATE_VER_SIZE);

    if (CurrentDataVersionString == NULL) {
        fprintf(stdout,"mkupdate:Listing file %s: Failed to allocate memory.\n",
                argv[1]);
        fclose(DataOut);
        exit(0);
    }

    // Sanitize the update list

    if (!SanitizeUpdateList(NumUpdates)) {
        fclose(DataOut);
        DeleteFile(UPDATE_DATA_FILE);
        free(CurrentDataVersionString);
        exit(0);
    }

    // Generate the data file. First generate all headers

    GenMSHeader(DataOut,UPDATE_DATA_FILE,"Processor updates.");

    // generate the data segment alloc pragmas

    fprintf(DataOut,"\n#ifdef ALLOC_DATA_PRAGMA\n");
    fprintf(DataOut,"#pragma data_seg(\"PAGELK\")\n");
    fprintf(DataOut,"#endif\n\n");

    // generate the update table definition

    fprintf(DataOut,"//\n// Updates data\n//\n\n");
    fprintf(DataOut,"UPDATE UpdateData[] = {\n");
    
    // include each update

    for (i=0; i < NumUpdates; i++) {
        if (!GetVerifyPutUpdate(DataOut,i,NumUpdates)) {
            fprintf(stdout,"mkupdate:Error: processing update data file %s_%s.%s\n",
                UpdateTable[i].CpuSigStr,UpdateTable[i].UpdateRevStr,
                UpdateTable[i].FlagsStr);
            fclose(DataOut);
            CleanupDataFile();
            free(CurrentDataVersionString);
            exit(0);
        }
    }
    
    // generate closing code for the update table definition

    fprintf(DataOut,"\n};\n");

    // generate the closing data segment alloc pragmas

    fprintf(DataOut,"\n#ifdef ALLOC_DATA_PRAGMA\n");
    fprintf(DataOut,"#pragma data_seg()\n");
    fprintf(DataOut,"#endif\n\n");

    //
    // Generate the Update Info Table containing the
    // processor signatures, processor flags, and 
    // pointers to MDLs (initialized to NULL)
    //

    BuildUpdateInfoTable(DataOut, NumUpdates);
    
    fclose(DataOut);

    // Generate the version file. Delete previous file if any.

    RCFile = fopen(UPDATE_VERSION_FILE,"w");

    if (RCFile == NULL) {
        fprintf(stdout,"%s: Unable to open version file %s\n",
                argv[0],UPDATE_VERSION_FILE);
        free(CurrentDataVersionString);
        exit(0);
    }
    
    // Generate header

    GenMSHeader(RCFile,UPDATE_VERSION_FILE,"Version information for update device driver.");

    //
    // Open common.ver. If found generate the dataversion string and 
    // copy everything to our RC file and insert our
    // string definitions in the StringFileInfo resource section. We need
    // to do this because inclusion of common.ver prevents the addition 
    // of new string defines in the stringfileinfo block. If common.ver
    // is not found in the expected place we only include it expecting the 
    // appropriate settings in the build environment to locate the file.
    // 

    //
    // Generate the common.ver path name
    //
    
    //
    // Obtain the Drive Name
    //

    VersionDirectory = getenv( "_NTDRIVE" );

    if (VersionDirectory == NULL) {
        fprintf(stdout,"%s: Unable to obtain _NTDRIVE ENV variable\n",argv[0]);
        fclose(RCFile);
        free(CurrentDataVersionString);
        exit(0);
    }
 
    strcpy(VersionFile, VersionDirectory);

    //
    // Obtain the Base Directory
    //

    VersionDirectory = getenv( "_NTROOT" );

    if (VersionDirectory == NULL) {
        fprintf(stdout,"%s: Unable to obtain _NTROOT ENV variable\n",argv[0]);
        fclose(RCFile);
        free(CurrentDataVersionString);
        exit(0);
    }

    strcat(VersionFile, VersionDirectory);
    strcat(VersionFile, "\\public\\sdk\\inc\\common.ver");

    VerFile = fopen(VersionFile,"r");

    if (VerFile == NULL) {
        fprintf(stdout,"%s: Unable to open version file common.ver\n",argv[0]);
        VerFileFound = FALSE;
    } else {
        VerFileFound = TRUE;
    }

    if (VerFileFound) {

        // Construct data version string from update listing table

        strcpy(CurrentDataVersionString,"\"");
        for (i=0; i < NumUpdates; i++) {
            strcat(CurrentDataVersionString,UpdateTable[i].CpuSigStr);
            strcat(CurrentDataVersionString,"-");
            strcat(CurrentDataVersionString,UpdateTable[i].FlagsStr);
            strcat(CurrentDataVersionString,",");
            strcat(CurrentDataVersionString,UpdateTable[i].UpdateRevStr);
            if (i != NumUpdates-1)
                strcat(CurrentDataVersionString,",");
        }
        strcat(CurrentDataVersionString,"\"");

#ifdef DEBUG
        fprintf(stderr,"DataVersionString %s\n",CurrentDataVersionString);
#endif
        
        fprintf(RCFile,"#define VER_DATAVERSION_STR    %s\n",
                CurrentDataVersionString);

        // Scan till string info block into version file, add our 
        // definition and scan till end

        while (fgets(Line,MAX_LINE,VerFile) != NULL) {
            fputs(Line,RCFile);
            if (strstr(Line,"VALUE") && strstr(Line,"ProductVersion") 
                && strstr(Line,"VER_PRODUCTVERSION_STR")){
                fprintf(RCFile,"            VALUE \"DataVersion\",     VER_DATAVERSION_STR\n");
            }
        }
    } else {
        
        // version file not found. Cannot define the dataversion
        // and codeversion strings. Only include common.ver

        fprintf(RCFile,"\n\n#include \"common.ver\"\n");
    }
    
    fclose(RCFile);
    fclose(VerFile);
    free(CurrentDataVersionString);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\dialogs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       dialogs.cxx
//
//  Contents:   Implementation of dialog classes
//
//----------------------------------------------------------------------------

#include "headers.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   ConfigDlgProc
//
//  Synopsis:   Handles the Config dialog
//
//----------------------------------------------------------------------------

BOOL CALLBACK
ConfigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CConfig * pConfig;

    pConfig = (CConfig *)GetWindowLong(hwnd, DWL_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
        pConfig = (CConfig*)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);

        pConfig->InitializeConfigDialog(hwnd);

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            if (pConfig->CommitConfigChanges(hwnd))
                EndDialog(hwnd, 0);
            break;

        case IDCANCEL:
            EndDialog(hwnd, 1);
            break;
        }

        return TRUE;
    }

    return FALSE;
}

HRESULT
CConfig::QueryInterface(REFIID iid, void **ppvObj)
{
    VERIFY_THREAD();

    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

DWORD
CConfig::ThreadMain()
{
    AddRef();

    SetName("Config");

    ThreadStarted(S_OK);  // Must be after the AddRef() call!

    int ret = DialogBoxParam(g_hInstance,
                             MAKEINTRESOURCE(IDD_CONFIGPATHS),
                             NULL,
                             (DLGPROC)ConfigDlgProc,
                             (LPARAM)this);
    if (ret == -1)
    {
        ErrorPopup(L"Could not bring up config dialog");
    }

    Release();

    return 0;
}

void
CConfig::InitializeConfigDialog(HWND hwnd)
{
    CStr cstr;
    CStr cstrInit;

    _hwnd = hwnd;

    _pMT->_options.GetScriptPath(&cstr);
    _pMT->_options.GetInitScript(&cstrInit);

    SetDlgItemText(hwnd, IDD_SCRIPTPATH, cstr);
    SetDlgItemText(hwnd, IDD_INITSCRIPT, cstrInit);
}

BOOL
CConfig::CommitConfigChanges(HWND hwnd)
{
    LOCK_LOCALS(_pMT);

    CStr cstr;

    TCHAR achBufPath[MAX_PATH];
    TCHAR achBufScript[MAX_PATH];

    // Read in the options from the dialog and store them.  Need to have a
    // way to revert to defaults. Right now the user can revert to the
    // defaults by clearing the textbox(s) and clicking OK.

    GetDlgItemText(hwnd, IDD_SCRIPTPATH, achBufPath, sizeof(achBufPath));
    GetDlgItemText(hwnd, IDD_INITSCRIPT, achBufScript, sizeof(achBufScript));
    EnableWindow(_hwnd, FALSE);
    BOOL retval = _pMT->SetScriptPath(achBufPath, achBufScript);
    EnableWindow(_hwnd, TRUE);
    return retval;
}

//+---------------------------------------------------------------------------
//
//  Function:   MBTimeoutDlgProc
//
//  Synopsis:   Handles the MessageBoxTimeout dialog
//
//----------------------------------------------------------------------------

BOOL CALLBACK
MBTimeoutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMessageBoxTimeout * pDialog;

    pDialog = (CMessageBoxTimeout *)GetWindowLong(hwnd, DWL_USER);

    switch (msg)
    {
    case WM_INITDIALOG:
        pDialog = (CMessageBoxTimeout*)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);

        pDialog->InitializeDialog(hwnd);

        return TRUE;

    case WM_COMMAND:
        pDialog->OnCommand(LOWORD(wParam), HIWORD(wParam));
        return TRUE;

    case WM_TIMER:
        pDialog->OnTimer();
        return TRUE;

    case WM_CLOSE:
        return TRUE;

    case WM_DESTROY:
        pDialog->_hwnd = NULL;
        break;
    }

    return FALSE;
}

HRESULT
CMessageBoxTimeout::QueryInterface(REFIID iid, void **ppvObj)
{
    VERIFY_THREAD();

    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

DWORD
CMessageBoxTimeout::ThreadMain()
{
    AddRef();

    Assert(_pmbt != NULL);

    SetName("MsgBoxTO");

    ThreadStarted(S_OK);  // Must be after the AddRef() call!

    int ret = DialogBoxParam(g_hInstance,
                             MAKEINTRESOURCE(IDD_MESSAGEBOX),
                             NULL,
                             (DLGPROC)MBTimeoutDlgProc,
                             (LPARAM)this);
    if (ret == -1)
    {
        _pmbt->mbts = MBTS_ERROR;
    }
    else
    {
        _pmbt->mbts = (MBT_SELECT)ret;
    }

    SetEvent(_pmbt->hEvent);

    Release();

    return 0;
}

void
CMessageBoxTimeout::InitializeDialog(HWND hwnd)
{
    CStr   cstrButtons;
    TCHAR *pch = NULL;
    int    i;

    _hwnd = hwnd;

    SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

    cstrButtons.Set(_pmbt->bstrButtonText);

    SetDlgItemText(hwnd, IDD_MESSAGE, _pmbt->bstrMessage);

    for (i = 5; i > 0; i--)
    {
        pch = (i == 1) ? cstrButtons : _tcsrchr(cstrButtons, L',');

        if (pch && i != 1)  // Skip the comma
            pch++;

        if (_pmbt->cButtons >= i && pch)
        {
            SetDlgItemText(hwnd, IDD_BUTTON1+i-1, pch);

            if (i > 1)
                *(pch-1) = L'\0';
        }
        else
        {
            ShowWindow(GetDlgItem(hwnd, IDD_BUTTON1+i-1), SW_HIDE);
        }
    }

    if (_pmbt->lTimeout == 0)
    {
        ShowWindow(GetDlgItem(hwnd, IDD_TIMEMSG), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDD_TIME), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDD_CANCELCOUNT), SW_HIDE);
    }
    else
    {
        TCHAR achBuf[30];

        if (!_pmbt->fCanCancel)
            EnableWindow(GetDlgItem(hwnd, IDD_CANCELCOUNT), FALSE);

        _lSecondsTilCancel    = _pmbt->lTimeout * 60;
        _lSecondsTilNextEvent = _pmbt->lEventInterval * 60;

        wsprintf(achBuf, L"%01d:%02d", _lSecondsTilCancel / 60,
                                       _lSecondsTilCancel % 60);

        SetDlgItemText(hwnd, IDD_TIME, achBuf);

        // Setup a 1 second timer
        SetTimer(hwnd, 1, 1000, NULL);
    }
}

void
CMessageBoxTimeout::OnCommand(USHORT id, USHORT wNotify)
{
    switch (id)
    {
    case IDD_BUTTON1:
    case IDD_BUTTON2:
    case IDD_BUTTON3:
    case IDD_BUTTON4:
    case IDD_BUTTON5:
        if (_pmbt->fConfirm)
        {
            TCHAR achBuf[100];
            TCHAR achText[100];

            GetDlgItemText(_hwnd, id, achText, 100);

            wsprintf(achBuf,
                     L"Click OK to confirm your choice of '%s'",
                     achText);

            if (MessageBox(_hwnd,
                           achBuf,
                           L"Gauntlet",
                           MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
            {
                break;
            }
        }
        KillTimer(_hwnd, 1);
        EndDialog(_hwnd, id-IDD_BUTTON1+MBTS_BUTTON1);
        break;

    case IDD_CANCELCOUNT:
        KillTimer(_hwnd, 1);
        SetDlgItemText(_hwnd, IDD_TIME, L"");
        SetDlgItemText(_hwnd, IDD_TIMEMSG, L"The countdown has been canceled.");
        EnableWindow(GetDlgItem(_hwnd, IDD_CANCELCOUNT), FALSE);
        break;
    }
}

void
CMessageBoxTimeout::OnTimer()
{
    TCHAR achBuf[30];

    _lSecondsTilCancel--;
    _lSecondsTilNextEvent--;

    wsprintf(achBuf, L"%01d:%02d", _lSecondsTilCancel / 60,
                                   _lSecondsTilCancel % 60);

    SetDlgItemText(_hwnd, IDD_TIME, achBuf);

    if (_lSecondsTilCancel <= 0)
    {
        KillTimer(_hwnd, 1);

        EndDialog(_hwnd, MBTS_TIMEOUT);

        return;
    }

    if (_lSecondsTilNextEvent <= 0 && _pmbt->lEventInterval != 0)
    {
        _pmbt->mbts = MBTS_INTERVAL;

        SetEvent(_pmbt->hEvent);

        _lSecondsTilNextEvent = _pmbt->lEventInterval * 60;

        // If we're minimized, unminimize to remind that we're still there.
        ShowWindow(_hwnd, SW_SHOWNORMAL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\makefile.inc ===
$(O)\selfreg_mtscript.inf : selfreg.inx
    cleaninf.exe -w selfreg.inx $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\machine.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       machine.cxx
//
//  Contents:   Implementation of the CMachine class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

DeclareTag(tagMachine, "MTScript", "Monitor IConnectedMachine");

// ***********************************************************************
//
// CMachConnectPoint
//
// ***********************************************************************

CMachConnectPoint::CMachConnectPoint(CMachine *pMach)
{
    _ulRefs = 1;
    _pMachine = pMach;
    _pMachine->AddRef();
}

CMachConnectPoint::~CMachConnectPoint()
{
    _pMachine->Release();
}

HRESULT
CMachConnectPoint::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CMachConnectPoint::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_DRemoteMTScriptEvents;
    return S_OK;
}

HRESULT
CMachConnectPoint::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pMachine;
    (*ppCPC)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachConnectPoint::Advise, public
//
//  Synopsis:   Remembers interface pointers that we want to fire events
//              through.
//
//  Arguments:  [pUnkSink]  -- Pointer to remember
//              [pdwCookie] -- Place to put cookie for Unadvise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMachConnectPoint::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    IDispatch *pDisp;
    HRESULT    hr;

    TraceTag((tagMachine, "Advising new machine sink: %p", pUnkSink));

    hr = pUnkSink->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp);
    if (hr)
    {
        TraceTag((tagMachine, "Could not get IDispatch pointer on sink! (%x)", hr));
        return hr;
    }

    CMachine::LOCK_MACH_LOCALS(_pMachine);

    hr = _pMachine->_aryDispSink.Append(pDisp);
    if (hr)
    {
        TraceTag((tagMachine, "Error appending sink to array!"));
        RRETURN(hr);
    }

    *pdwCookie = (DWORD)pDisp;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachConnectPoint::Unadvise, public
//
//  Synopsis:   Forgets a pointer we remembered during Advise.
//
//  Arguments:  [dwCookie] -- Cookie returned from Advise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMachConnectPoint::Unadvise(DWORD dwCookie)
{
    int i;

    TraceTag((tagMachine, "Unadvising machine sink: %p", dwCookie));

    CMachine::LOCK_MACH_LOCALS(_pMachine);

    i = _pMachine->_aryDispSink.Find((IDispatch*)dwCookie);

    if (i != -1)
    {
        _pMachine->_aryDispSink.ReleaseAndDelete(i);
    }
    else
        return E_INVALIDARG;

    return S_OK;
}

HRESULT
CMachConnectPoint::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

// ***********************************************************************
//
// CMachine
//
// ***********************************************************************

CMachine::CMachine(CMTScript *pMT, ITypeInfo *pTIMachine)
{
    _ulRefs = 1;
    _pMT    = pMT;

    TraceTag((tagMachine, "%p: CMachine object being constructed", this));

    Assert(pTIMachine);

    _pTypeInfoIMachine = pTIMachine;

    _pTypeInfoIMachine->AddRef();

    InitializeCriticalSection(&_cs);
}

CMachine::~CMachine()
{
    ReleaseInterface(_pTypeInfoIMachine);

    DeleteCriticalSection(&_cs);
}

HRESULT
CMachine::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IConnectedMachine || iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppvObj = (IConnectedMachine *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::Init, public
//
//  Synopsis:   Used to do initialization that may fail
//
//----------------------------------------------------------------------------

BOOL
CMachine::Init()
{
    return CThreadComm::Init();
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::ThreadMain, public
//
//  Synopsis:   Main loop for this thread. Handles messages coming from other
//              threads.
//
//----------------------------------------------------------------------------

DWORD
CMachine::ThreadMain()
{
    DWORD dwRet;
    BOOL  fExit = FALSE;

    SetName("CMachine");

    ThreadStarted(S_OK);

    TraceTag((tagMachine, "CMachine thread started"));

    while (!fExit)
    {
        dwRet = WaitForSingleObject(_hCommEvent, INFINITE);

        if (dwRet == WAIT_OBJECT_0)
        {
            fExit = HandleThreadMessage();
        }
        else
        {
            AssertSz(FALSE, "FATAL: WaitForSingleObject failed!");
            fExit = TRUE;
        }
    }

    TraceTag((tagMachine, "CMachine thread exiting"));

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::HandleThreadMessage, public
//
//  Synopsis:   Handles messages from other threads.
//
//----------------------------------------------------------------------------

BOOL
CMachine::HandleThreadMessage()
{
    VERIFY_THREAD();

    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;
    BOOL      fRet = FALSE;

    while (GetNextMsg(&tm, (void *)bData, &cbData))
    {
        switch (tm)
        {
        case MD_NOTIFYSCRIPT:
            {
                VARIANT *pvar = *(VARIANT**)bData;

                Assert(V_VT(&pvar[0]) == VT_BSTR);

                FireScriptNotify(V_BSTR(&pvar[0]), pvar[1]);

                VariantClear(&pvar[0]);
                VariantClear(&pvar[1]);

                delete [] pvar;
            }
            break;

        case MD_PLEASEEXIT:
            fRet = TRUE;
            break;

        default:
            AssertSz(FALSE, "CMachine got a message it couldn't handle!");
            break;
        }
    }

    return fRet;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CMachine::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CMachine::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    if (iid == DIID_DRemoteMTScriptEvents || iid == IID_IDispatch)
    {
        *ppCpOut = new CMachConnectPoint(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    *pptinfo = _pTypeInfoIMachine;
    (*pptinfo)->AddRef();

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    return _pTypeInfoIMachine->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

//---------------------------------------------------------------------------
//
//  Member: CMachine::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMachine::Invoke(DISPID dispidMember,
                 REFIID riid,
                 LCID lcid,
                 WORD wFlags,
                 DISPPARAMS * pdispparams,
                 VARIANT * pvarResult,
                 EXCEPINFO * pexcepinfo,
                 UINT * puArgErr)
{
    return _pTypeInfoIMachine->Invoke((IConnectedMachine *)this, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

// *************************************************************************

//+---------------------------------------------------------------------------
//
//  Member:     CMachine::FireScriptNotify, public
//
//  Synopsis:   Fires the script notify event on all objects connected to
//              our IConnectedMachine object that have requested to receive
//              events (through IConnectionPoint::Advise).
//
//  Arguments:  [bstrIdent] -- Parameter of event
//              [vInfo]     -- Parameter of event
//
//  Returns:    HRESULT
//
//  Notes:      This method is thread-safe and can be called from any thread.
//
//----------------------------------------------------------------------------

HRESULT
CMachine::FireScriptNotify(BSTR bstrIdent, VARIANT vInfo)
{
    HRESULT     hr;
    IDispatch **ppDisp;
    int         i;
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr = 0;
    VARIANT     varg[2];

    CStackPtrAry<IDispatch*, 5> arySinks;

    // Since it may take some time to fire the events, and we don't want
    // to keep the array locked that whole time, we make a copy of the array.
    // This will also allow a sink to unadvise itself while handling the event
    // without deadlocking.

    {
        LOCK_MACH_LOCALS(this);

        // Check for no sinks. No use going to all this work if there's no one
        // listening.

        if (_aryDispSink.Size() == 0)
            return S_OK;

        hr = arySinks.Copy(_aryDispSink, TRUE);
        if (hr)
            RRETURN(hr);
    }

    // Set up the event parameters

    VariantInit(&varg[0]);
    VariantInit(&varg[1]);

    // Params are in order from last to first
    hr = VariantCopy(&varg[0], &vInfo);
    if (hr)
        return hr;

    V_VT(&varg[1]) = VT_BSTR;
    V_BSTR(&varg[1]) = bstrIdent;

    dp.rgvarg            = varg;
    dp.cArgs             = 2;
    dp.rgdispidNamedArgs = NULL;
    dp.cNamedArgs        = 0;

    // We don't use the same critical section here so _aryDispSink can be
    // manipulated while we're firing events. However, we still don't want
    // more than one thread firing events at the same time.

    TraceTag((tagMachine, "About to fire OnScriptNotify(%ls) on %d sinks...", bstrIdent, arySinks.Size()));

    for (i = arySinks.Size(), ppDisp = arySinks;
         i > 0;
         i--, ppDisp++)
    {
        hr = (*ppDisp)->Invoke(
                           DISPID_RemoteMTScript_OnScriptNotify,
                           IID_NULL,
                           0,
                           DISPATCH_METHOD,
                           &dp,
                           NULL,
                           &ei,
                           &uArgErr);
        if (hr)
        {
            // If the call failed, unadvise so we don't keep trying.

            TraceTag((tagError, "OnScriptNotify event call returned %x! Unadvising...", hr));

            // If the connection went down temporarily, don't unadvise.

            if (hr != HRESULT_FROM_WIN32(RPC_X_BAD_STUB_DATA) &&
                hr != HRESULT_FROM_WIN32(RPC_S_COMM_FAILURE))
            {
                LOCK_MACH_LOCALS(this);

                int index = _aryDispSink.Find(*ppDisp);

                Assert(index != -1);

                _aryDispSink.ReleaseAndDelete(index);
            }
        }
    }

    TraceTag((tagMachine, "Done firing OnScriptNotify(%ls).", bstrIdent));

    return S_OK;
}

// *************************************************************************

STDMETHODIMP
CMachine::Exec(BSTR bstrCmd, BSTR bstrParams, VARIANT *pvData)
{
    // We create an event object for each call on this method. While this
    // may have a cost, it makes this method thread-safe. If we cached an
    // event object then we would have to synchronize access to that event
    // object which could be even more expensive.
    MACHPROC_EVENT_DATA   med;
    MACHPROC_EVENT_DATA * pmed;
    HRESULT           hr = S_OK;

    if (!pvData)
    {
        return E_INVALIDARG;
    }

    TraceTag((tagMachine, "Exec call received: (%ls, %ls)", bstrCmd, bstrParams));

    VariantInit(pvData);

    med.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (med.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    med.bstrCmd     = bstrCmd;
    med.bstrParams  = bstrParams;
    med.dwProcId    = 0;
    med.pvReturn    = pvData;
    med.dwGITCookie = 0;
    med.hrReturn    = S_OK;

    pmed = &med;

    HANDLE ahEvents[2];
    ahEvents[0] = med.hEvent;

    CScriptHost *pScript = _pMT->GetPrimaryScript();
    if (!pScript)
    {
        med.hrReturn = E_FAIL;
        goto Cleanup;
    }
    ahEvents[1] = pScript->hThread();
    _pMT->PostToThread(pScript,
                       MD_MACHEVENTCALL,
                       (LPVOID)&pmed,
                       sizeof(MACHPROC_EVENT_DATA*));

    // We can do WaitForSingleObject because we are in OLE's multi-threaded
    // apartment and don't need to handle messages from our event loop.
    DWORD dwWait;
    dwWait = WaitForMultipleObjects(2, ahEvents, FALSE, INFINITE);

    if (dwWait != WAIT_OBJECT_0) // Thread exit
    {
        med.hrReturn = E_FAIL;
        goto Cleanup;
    }
    if (med.hrReturn != S_OK)
    {
        hr = med.hrReturn;
        goto Cleanup;
    }

    // See if the return value was an IDispatch ptr. If so, grab the pointer
    // out of the GlobalInterfaceTable.
    if (V_VT(pvData) == VT_DISPATCH)
    {
        IDispatch *pDisp;

        AssertSz(med.dwGITCookie != 0, "FATAL: Itf pointer improperly marshalled");

        hr = _pMT->_pGIT->GetInterfaceFromGlobal(med.dwGITCookie,
                                                 IID_IDispatch,
                                                 (LPVOID*)&pDisp);
        if (!hr)
        {
            V_VT(pvData)       = VT_DISPATCH;
            V_DISPATCH(pvData) = pDisp;
        }

        _pMT->_pGIT->RevokeInterfaceFromGlobal(med.dwGITCookie);
    }

Cleanup:
    CloseHandle(med.hEvent);

    TraceTag((tagMachine, "Exec call returning %x", hr));

    return hr;
}


STDMETHODIMP
CMachine::get_PublicData(VARIANT *pvData)
{
    HRESULT hr = S_OK;

    VariantInit(pvData);

    TraceTag((tagMachine, "Remote machine asking for PublicData"));

    LOCK_LOCALS(_pMT);

    if (V_VT(&_pMT->_vPublicData) == VT_DISPATCH)
    {
        IDispatch *pDisp;

        Assert(_pMT->_dwPublicDataCookie != 0);

        hr = _pMT->_pGIT->GetInterfaceFromGlobal(_pMT->_dwPublicDataCookie,
                                                 IID_IDispatch,
                                                 (LPVOID*)&pDisp);
        if (!hr)
        {
            V_VT(pvData)       = VT_DISPATCH;
            V_DISPATCH(pvData) = pDisp;
        }
    }
    else
    {
        hr = VariantCopy(pvData, &_pMT->_vPublicData);
    }

    return hr;
}

STDMETHODIMP
CMachine::get_Name(BSTR *pbstrName)
{
    TCHAR achBuf[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwLength = ARRAY_SIZE(achBuf);

    GetComputerName(achBuf, &dwLength);

    *pbstrName = SysAllocString(achBuf);

    return (pbstrName) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP
CMachine::get_Platform(BSTR *pbstrPlatform)
{
    SYSTEM_INFO si;

    GetSystemInfo(&si);

    TCHAR *pchPlatform;

    if (!pbstrPlatform)
        return E_POINTER;

    switch (si.wProcessorArchitecture)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        pchPlatform = L"x86";
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        pchPlatform = L"alpha";
        break;

    case PROCESSOR_ARCHITECTURE_MIPS:
        pchPlatform = L"mips";
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        pchPlatform = L"ia64";
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA64:
        pchPlatform = L"alpha64";
        break;

    case PROCESSOR_ARCHITECTURE_PPC:
        pchPlatform = L"powerpc";
        break;

    case PROCESSOR_ARCHITECTURE_UNKNOWN:
    default:
        pchPlatform = L"unknown";
        break;
    }

    *pbstrPlatform = SysAllocString(pchPlatform);
    if (!*pbstrPlatform)
        return E_OUTOFMEMORY;

    return S_OK;
}

STDMETHODIMP
CMachine::get_OS(BSTR *pbstrOS)
{
    OSVERSIONINFO os;
    WCHAR *       pchOS = L"Unknown";

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!pbstrOS)
        return E_POINTER;

    GetVersionEx(&os);

    switch (os.dwPlatformId)
    {
    case VER_PLATFORM_WIN32_WINDOWS:
        if (   os.dwMajorVersion > 4
            || (   os.dwMajorVersion == 4
                && os.dwMinorVersion > 0))
        {
            pchOS = L"Win98";
        }
        else
        {
            pchOS = L"Win95";
        }
        break;

    case VER_PLATFORM_WIN32_NT:
        if (os.dwMajorVersion == 4)
        {
            pchOS = L"NT4";
        }
        else
        {
            pchOS = L"Win2000";
        }
        break;
    }

    *pbstrOS = SysAllocString(pchOS);
    if (!*pbstrOS)
        return E_OUTOFMEMORY;

    return S_OK;
}

STDMETHODIMP
CMachine::get_MajorVer(long *plMajorVer)
{
    if (!plMajorVer)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *plMajorVer = os.dwMajorVersion;

    return S_OK;
}

STDMETHODIMP
CMachine::get_MinorVer(long *plMinorVer)
{
    if (!plMinorVer)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *plMinorVer = os.dwMinorVersion;

    return S_OK;
}

STDMETHODIMP
CMachine::get_BuildNum(long *plBuildNum)
{
    if (!plBuildNum)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *plBuildNum = os.dwBuildNumber;

    return S_OK;
}

STDMETHODIMP
CMachine::get_PlatformIsNT(VARIANT_BOOL *pfIsNT)
{
    if (!pfIsNT)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *pfIsNT = (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
                    ? VB_TRUE
                    : VB_FALSE;

    return S_OK;
}

STDMETHODIMP
CMachine::get_ServicePack(BSTR *pbstrServicePack)
{
    if (!pbstrServicePack)
        return E_POINTER;

    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&os);

    *pbstrServicePack = SysAllocString(os.szCSDVersion);

    return (pbstrServicePack) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP
CMachine::get_HostMajorVer(long *plMajorVer)
{
    if (!plMajorVer)
        return E_POINTER;

    *plMajorVer = IConnectedMachine_lVersionMajor;

    return S_OK;
}

STDMETHODIMP
CMachine::get_HostMinorVer(long *plMinorVer)
{
    if (!plMinorVer)
        return E_POINTER;

    *plMinorVer = IConnectedMachine_lVersionMinor;

    return S_OK;
}

STDMETHODIMP
CMachine::get_StatusValue(long nIndex, long *pnStatus)
{
    if (!pnStatus)
        return E_POINTER;

    return _pMT->get_StatusValue(nIndex, pnStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\factory.cxx ===
#include "headers.hxx"

DeclareTag(tagFactory, "MTScript", "Monitor Class Factories");

HRESULT CreateConnectedMachine(CMTScript *pMT, IUnknown **ppUnk);
HRESULT CreateScriptedProcess(CMTScript *pMT, IUnknown **ppUnk);

REGCLASSDATA g_regData[] =
{
    {
        &CLSID_RemoteMTScript,
        CreateConnectedMachine,
        CLSCTX_SERVER,
        0
    },
    {
        &CLSID_LocalScriptedProcess,
        CreateScriptedProcess,
        CLSCTX_LOCAL_SERVER,
        0
    }
};

// ***************************************************************
//
//

HRESULT
RegisterClassObjects(CMTScript *pMT)
{
    HRESULT       hr = S_OK;
    REGCLASSDATA *prcd;
    int           i;
    CStdFactory  *pFact;

    TraceTag((tagFactory, "Registering Class Factories..."));

    for (i = 0, prcd = g_regData;
         i < ARRAY_SIZE(g_regData);
         i++, prcd++)
    {
        pFact = new CStdFactory(pMT, prcd->pfnCreate);

        if (!pFact)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = CoRegisterClassObject(*prcd->pclsid,
                                       pFact,
                                       prcd->ctxCreate,
                                       REGCLS_MULTIPLEUSE,
                                       &prcd->dwCookie);

            pFact->Release();
        }

        if (hr)
        {
            // BUGBUG -- how do we handle errors here?
            WCHAR achBuf[100];

            wsprintf(achBuf, L"CoRegisterClassObject failed with (%x)", hr);

            MessageBox(NULL, achBuf, L"MTScript", MB_OK | MB_SETFOREGROUND);

            break;
        }
    }

    return hr;
}

void
UnregisterClassObjects()
{
    REGCLASSDATA *prcd;
    int           i;

    TraceTag((tagFactory, "Unregistering Class Factories..."));

    for (i = 0, prcd = g_regData;
         i < ARRAY_SIZE(g_regData);
         i++, prcd++)
    {
        if (prcd->dwCookie != 0)
        {
            CoRevokeClassObject(prcd->dwCookie);
        }
    }
}

// ***************************************************************

CStdFactory::CStdFactory(CMTScript *pMT, FNCREATE *pfnCreate)
{
    _ulRefs    = 1;
    _pMT       = pMT;
    _pfnCreate = pfnCreate;
}

STDMETHODIMP
CStdFactory::QueryInterface(REFIID iid, void ** ppvObject)
{
    if (iid == IID_IClassFactory || iid == IID_IUnknown)
    {
        *ppvObject = (IClassFactory*)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObject)->AddRef();
    return S_OK;
}

STDMETHODIMP
CStdFactory::CreateInstance(IUnknown * pUnkOuter,
                            REFIID     riid,
                            void **    ppvObject)
{
    IUnknown *pUnk;
    HRESULT   hr = E_FAIL;

    *ppvObject = NULL;

    TraceTag((tagFactory, "%p: CreateInstance called...", this));

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }

    hr = (*_pfnCreate)(_pMT, &pUnk);

    if (!hr)
    {
        hr = pUnk->QueryInterface(riid, ppvObject);
    }

    pUnk->Release();

    if (hr)
    {
        // BUGBUG -- Fix this

        WCHAR achBuf[100];

        wsprintf(achBuf, L"CreateInstance failed with (%x)", hr);

        MessageBox(NULL, achBuf, L"MTScript", MB_OK | MB_SETFOREGROUND);
    }

    return hr;
}

STDMETHODIMP
CStdFactory::LockServer(BOOL fLock)
{
    // BUGBUG -- Increment a count on the CMTScript object and don't go
    // away if it's not zero.

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateConnectedMachine
//
//  Synopsis:   Creates the object which implements IConnectedMachine
//
//  Arguments:  [pMT]   -- Pointer to CMTScript object
//              [ppUnk] -- Created object is returned here
//
//  Notes:      This function creates only one object and returns it for
//              all CreateInstance calls. There is no per-connection state
//              so it is unnecessary to create a separate object for each
//              connection.
//
//----------------------------------------------------------------------------

HRESULT
CreateConnectedMachine(CMTScript *pMT, IUnknown **ppUnk)
{
    HRESULT   hr = S_OK;
    CMachine *pMach;

    TraceTag((tagFactory, "Creating a CMachine object"));

    pMT->PostToThread(pMT, MD_MACHINECONNECT);

    LOCK_LOCALS(pMT);

    if (!pMT->_pMachine)
    {
        TraceTag((tagFactory, "Creating a CMachine object"));

        pMach = new CMachine(pMT, pMT->_pTIMachine);

        if (!pMach)
        {
            return E_OUTOFMEMORY;
        }

        hr = pMach->StartThread(NULL);
        if (FAILED(hr))
        {
            return hr;
        }

        pMT->_pMachine = pMach;
    }
    else
    {
        TraceTag((tagFactory, "Connecting to the existing CMachine object"));

        pMach = pMT->_pMachine;
    }

    // We are in the free-threaded apartment so we don't have to marshal this.
    return pMach->QueryInterface(IID_IUnknown, (LPVOID*)ppUnk);
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateScriptedProcess
//
//  Synopsis:   Creates the object which implement IScriptedProcess
//
//  Arguments:  [pMT]   -- Pointer to CMTScript object
//              [ppUnk] -- Created object is returned here
//
//  Notes:      Creates a new object for each connection.
//
//----------------------------------------------------------------------------

HRESULT
CreateScriptedProcess(CMTScript *pMT, IUnknown **ppUnk)
{
    HRESULT       hr = S_OK;
    CProcessComm *pPC;

    TraceTag((tagFactory, "Creating a CProcessComm object"));

    LOCK_LOCALS(pMT);

    pPC = new CProcessComm(pMT);

    if (!pPC)
    {
        return E_OUTOFMEMORY;
    }

    hr = pPC->QueryInterface(IID_IUnknown, (LPVOID*)ppUnk);

    pPC->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\statusdialog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       StatusDialog.cxx
//
//  Contents:   Implementation of the StatusDialog class
//
//              Written by Joe Porkka
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#include "StatusDialog.h"
#include "RegSettingsIO.h"
#include <stdio.h>
#include <time.h>
#define REFRESH_DELAY 500
#define MAX_DBMSG_LENGTH 256
#define MAX_SCRIPT_NAME_LENGTH 512
DeclareTag(tagStat, "Stat", "status events");

CCustomListBox::CCustomListBox()
{
    _hwnd = 0;
}

CCustomListBox::~CCustomListBox()
{
    _hwnd = 0;
    ResetContent();
}

void CCustomListBox::Init(HWND dlg, UINT idCtrl)
{
    _nExtent = 0;
    _hwnd = GetDlgItem(dlg, idCtrl);
    SetWindowLong(_hwnd, GWL_USERDATA, (LONG) this);
    SendMessage(LB_SETCOUNT, _Messages.Size(), 0);
}

const TCHAR *CCustomListBox::GetString(int index)
{
    if (index >= 0 && index < _Messages.Size())
    {
        return _Messages[index];
    }
    return 0;
}

void CCustomListBox::ResetContent()
{
    SetEnd(0);
}

void CCustomListBox::SetEnd(int nItems)
{
    if (nItems < _Messages.Size())
    {
        for(int i = nItems; i < _Messages.Size(); ++i)
        {
            delete [] _Messages[i];
            _Messages[i] = 0;
        }

        _Messages.SetSize(nItems);
    }
    if (_hwnd)
    {
        int cTopIndex = SendMessage(LB_GETTOPINDEX, 0, 0);
        int nSelCount = SendMessage(LB_GETSELCOUNT, 0, 0);
        if (nItems != SendMessage(LB_GETCOUNT, 0, 0) )
        {
            SendMessage(WM_SETREDRAW, FALSE, 0);

            long *pSelItems = 0;
            if (nSelCount > 0)
            {
                pSelItems = new long[nSelCount];
                if (pSelItems)
                    SendMessage(LB_GETSELITEMS, nSelCount, (LPARAM) pSelItems);

                MemSetName(pSelItems, "StatusDialog selcount: %d", nSelCount);
            }

            SendMessage(LB_SETCOUNT, _Messages.Size(), 0);
            if (nSelCount != 0)
            {
                // If there is a selection  (or LB_ERR in the single select listbox case), maintain current scroll position
                SendMessage(LB_SETTOPINDEX, cTopIndex, 0);
            }
            else if (nItems > 0)
                SendMessage(LB_SETTOPINDEX, nItems - 1, 0);

            if (pSelItems)
            {
                for(int i = 0; i < nSelCount; ++i)
                {
                    SendMessage( LB_SELITEMRANGE,
                        TRUE,
                        MAKELONG(pSelItems[i], pSelItems[i]));
                }
                delete [] pSelItems;
            }

            SendMessage( WM_SETREDRAW, TRUE, 0);
        }
    }
}

void CCustomListBox::AppendString(const TCHAR *sz)
{
    SetString(_Messages.Size(), sz);
    SetEnd(_Messages.Size());
}

void CCustomListBox::SetString(int nItem, const TCHAR *sz)
{
    if (nItem >= _Messages.Size())
    { // CImplAry oughta do this for us!
        if (nItem >= _nAllocatedMessageLength)
        { // Grow allocation by power of 2
            int newsize = _Messages.Size() * 2;
            if (newsize == 0)
                newsize = 1;
            while (newsize < nItem + 1)
                newsize *= 2;

            if (_Messages.EnsureSize(newsize) == S_OK)
            {
                _nAllocatedMessageLength = newsize;
                for(int i = _Messages.Size(); i < newsize; ++i)
                    _Messages[i] = NULL;

                _Messages.SetSize(nItem + 1);
            }
        }
        else
        {
            _Messages.SetSize(nItem + 1);
            _Messages[nItem] = NULL;
        }
    }

    if (nItem < _Messages.Size())
    {
        delete [] _Messages[nItem];
        int len = _tcslen(sz);
        _Messages[nItem] = new TCHAR[len + 1];
        if (_Messages[nItem])
        {
            MemSetName(_Messages[nItem], "StatusDialog line #%d", nItem);
            _tcscpy(_Messages[nItem], sz);
        }
    }

    // Limit the maximum number of messages so we don't eat up memory.  We
    // let it grow to 10 messages over our limit, then we delete down to 10
    // under.

    if (_Messages.Size() > MAX_STATUS_MESSAGES + 10)
    {
        int cPurge = _Messages.Size() - (MAX_STATUS_MESSAGES - 10);
        int i;

        for (i = 0; i < cPurge; i++)
        {
            delete [] _Messages[i];
        }

        // if cPurge is 1, then we will delete only the first element. Using
        // DeleteMultiple is dramatically more efficient than deleting
        // one element at a time.

        _Messages.DeleteMultiple(0, cPurge - 1);

        Refresh();
    }
}

void CCustomListBox::MeasureItem(MEASUREITEMSTRUCT *pmis)
{
    if (_hwnd)
    {
        HDC hdc = GetDC(_hwnd);
        TEXTMETRIC tm;
        GetTextMetrics(hdc, &tm);
        ReleaseDC(_hwnd, hdc);
        pmis->itemHeight = tm.tmHeight;
    }
    else
        pmis->itemHeight = 20;
}

void CCustomListBox::DrawItem(DRAWITEMSTRUCT *pdis)
{
    TCHAR *szText = 0;
    if (pdis->itemID < unsigned(_Messages.Size()))
        szText = _Messages[pdis->itemID];

    if (!szText)
        szText = L"";

    switch (pdis->itemAction)
    {
        case ODA_SELECT:
        case ODA_DRAWENTIRE:
            // Display the text associated with the item.
            {
                COLORREF savetext = 0;
                COLORREF savebk = 0;
                if (pdis->itemState & ODS_SELECTED)
                {
                    savetext = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                    savebk = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
                }
                DrawTextEx(pdis->hDC,
                    szText,
                    -1,
                    &pdis->rcItem,
                    DT_EXPANDTABS | DT_NOPREFIX | DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_EXTERNALLEADING,
                    0);

                RECT extRect = pdis->rcItem;
                DrawTextEx(pdis->hDC,
                    szText,
                    -1,
                    &extRect,
                    DT_CALCRECT | DT_EXPANDTABS | DT_NOPREFIX | DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_EXTERNALLEADING,
                    0);

                if (pdis->itemState & ODS_SELECTED)
                {
                    SetTextColor(pdis->hDC, savetext );
                    SetBkColor(pdis->hDC, savebk);
                }
                if (extRect.right > _nExtent)
                {
                    _nExtent = extRect.right ;
                    SendMessage( LB_SETHORIZONTALEXTENT, _nExtent, 0);
                }
            }
            break;

        case ODA_FOCUS:

            // Do not process focus changes. The focus caret
            // (outline rectangle) indicates the selection.
            // The IDOK button indicates the final
            // selection.

            break;
    }
}

CStatusDialog::CStatusDialog(HWND parent, CMTScript *pMTScript)
: _parent(parent), _pMTScript(pMTScript), _fLogToFile(FALSE)
{
    _hwnd = 0;
    Assert(pMTScript);

//    _cstrLogFileName.Set(L"\\\\jporkka10\\log\\MT%COMPUTERNAME%.log");
    _cstrLogFileName.Set(L"%TEMP%\\%COMPUTERNAME%_MTDbg.log");
    UpdateOptionSettings(false);
    if (_fStatusOpen)
        Show();
}

CStatusDialog::~CStatusDialog()
{
    if (_hwnd)
        DestroyWindow(_hwnd);
    ClearOutput();
}

CCustomListBox *CStatusDialog::CtrlIDToListBox(UINT CtrlID)
{
    switch(CtrlID)
    {
        case IDC_SCRIPTLIST:
            return &_CScriptListBox;
        case IDC_PROCESSLIST:
            return &_CProcessListBox;
        case IDC_SIGNALLIST:
            return &_CSignalListBox;
        case IDC_DEBUGOUTPUT:
            return &_COutputListBox;
        default:
            Assert(0);
            break;
    }
    return 0;
}

bool CStatusDialog::Show()
{
    if (!_hwnd)
    {
        _hwnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_STATUSDIALOG), _parent, DlgProc, (LONG)this);
        if (!_hwnd)
            return false;
        _fStatusOpen = true;

        WINDOWPLACEMENT wp = { sizeof(WINDOWPLACEMENT) };
        GetWindowPlacement(_hwnd, &wp);
        if (!IsRectEmpty(&_WindowPlacement.rcNormalPosition))
            wp.rcNormalPosition = _WindowPlacement.rcNormalPosition;
        wp.ptMaxPosition = _WindowPlacement.ptMaxPosition;
        wp.flags = 0;
        if (_fMaximized)
            wp.showCmd = SW_SHOWMAXIMIZED;

        SetWindowPlacement(_hwnd, &wp);
        UpdateOptionSettings(true);
    }

    return true;
}

void CStatusDialog::InitDialog()
{
    _CScriptListBox.Init(_hwnd, IDC_SCRIPTLIST);
    _CProcessListBox.Init(_hwnd, IDC_PROCESSLIST);
    _CSignalListBox.Init(_hwnd, IDC_SIGNALLIST);
    _COutputListBox.Init(_hwnd, IDC_DEBUGOUTPUT);
    SendDlgItemMessage(_hwnd, IDC_LOGGING, BM_SETCHECK, _fLogToFile ? BST_CHECKED : BST_UNCHECKED, 0);

    Refresh();

    RECT rect;
    GetWindowRect(_hwnd, &rect);
    _InitialSize.x = rect.right - rect.left;
    _InitialSize.y = rect.bottom - rect.top;

    static struct CResizeInfo rgResizeInfo[] =
    {
        { IDC_OUTPUTTEXT,  CResizer::sf_HalfLeftWidth },
        { IDC_DEBUGOUTPUT, CResizer::sf_HalfLeftWidth |  CResizer::sf_Height    },
        { IDOK,            CResizer::sf_Top           |  CResizer::sf_Left      },
        { IDC_CLEAR,       CResizer::sf_Top           |  CResizer::sf_Left      },
        { IDC_EXIT,        CResizer::sf_Top           |  CResizer::sf_Left      },
        { IDC_SCRIPTLIST,  CResizer::sf_HalfWidth     },
        { IDC_PROCESSLIST, CResizer::sf_HalfWidth     |  CResizer::sf_Height    },
        { IDC_SIGNALLIST,  CResizer::sf_Top           |  CResizer::sf_HalfWidth },
        { IDC_SIGNALTEXT,  CResizer::sf_Top           },
        { IDC_LOGGING,     CResizer::sf_Top           },
        {0}
    };
    _Resizer.Init(_hwnd, rgResizeInfo);
}

void CStatusDialog::Destroy()
{
    UpdateOptionSettings(true);
    _hwnd = 0;
    _CScriptListBox.Destroy();
    _CProcessListBox.Destroy();
    _CSignalListBox.Destroy();
    _COutputListBox.Destroy();
#if DBG != 1
        _COutputListBox.ResetContent();
#endif
}

BOOL CALLBACK CStatusDialog::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CStatusDialog *stats = (CStatusDialog *)GetWindowLong(hwnd, GWL_USERDATA);
    switch(uMsg)
    {
        case WM_INITDIALOG:
        {
            SetWindowLong(hwnd, GWL_USERDATA, lParam);
            stats = (CStatusDialog *)lParam;
            stats->_hwnd = hwnd;
            stats->InitDialog();
            if (!stats->_fPaused)
                SetTimer(hwnd, 1, REFRESH_DELAY, 0);
            break;
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (stats)
                        stats->_fStatusOpen = false;
                    DestroyWindow(hwnd);
                    break;

                case IDC_EXIT:
                    DestroyWindow(hwnd);
                    PostQuitMessage(0);
                    break;
                case IDC_CLEAR:
                    if (stats)
                        stats->ClearOutput();
                    break;
                case IDC_SIGNALLIST:
                    if (stats && HIWORD(wParam) == LBN_DBLCLK)
                    {
                        CCustomListBox *pListBox = stats->CtrlIDToListBox(LOWORD(wParam));
                        if (pListBox == &stats->_CSignalListBox)
                        {
                            stats->ToggleSignal();
                        }
                    }
                    break;
                case IDC_LOGGING:
                    if (stats)
                        stats->UpdateLogging();
                    break;
            }
            break;
        }
        case WM_TIMER:
            if (stats)
                stats->Refresh();
            break;
        case WM_DESTROY:
            KillTimer(hwnd, 1);
            SetWindowLong(hwnd, GWL_USERDATA, 0);
            if (stats)
                stats->Destroy();
            break;
        case WM_GETMINMAXINFO:
            if (stats)
                stats->GetMinMaxInfo((MINMAXINFO *)lParam);
            break;
        case WM_MOVE:
            break;
        case WM_SIZE:
            if (stats)
                stats->Resize(LOWORD(lParam), HIWORD(lParam));
            break;
        case WM_EXITSIZEMOVE:
            if (stats)
            {
                stats->UpdateOptionSettings(true);
            }
            break;
        case WM_MEASUREITEM:
            if (stats)
            {
                CCustomListBox *pListBox = stats->CtrlIDToListBox(wParam);
                if (pListBox )
                    pListBox->MeasureItem( (LPMEASUREITEMSTRUCT) lParam);
            }
            break;
        case WM_DRAWITEM:
            if (stats)
            {
                CCustomListBox *pListBox = stats->CtrlIDToListBox(wParam);
                if (pListBox )
                    pListBox->DrawItem((DRAWITEMSTRUCT *) lParam);
            }
            break;
        default:
            return 0; // did not process the message;
    }
    return true;
}

BOOL CStatusDialog::IsDialogMessage(MSG *msg)
{
    if (_hwnd)
    {
        return ::IsDialogMessage(_hwnd, msg);
    }

    return 0;
}

void CStatusDialog::PopulateScripts()
{
    int i = 0;

    if (_hwnd)
    {
        TCHAR szBuffer[MAX_SCRIPT_NAME_LENGTH];
        long cBuffer = MAX_SCRIPT_NAME_LENGTH;
        _pMTScript->GetScriptNames(szBuffer, &cBuffer); // We don't really care if we do not get all of them..,
        TCHAR *ptr = szBuffer;
        while (*ptr && ptr < szBuffer + MAX_SCRIPT_NAME_LENGTH)
        {
            _CScriptListBox.SetString(i, ptr);
            ptr += _tcslen(ptr) + 1;
            ++i;
        }
        _CScriptListBox.SetEnd(i);
        _CScriptListBox.Refresh();
    }
}

void CStatusDialog::PopulateSignals()
{
    int i = 0;
    HANDLE hEvent;
    CStr cstr;

    if (_hwnd)
    {
        for(i = 0; CScriptHost::GetSyncEventName(i, &cstr, &hEvent) == S_OK; ++i)
        {
            wchar_t szSignalText[256];
            bool signalled = (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0);
            wsprintf(szSignalText, L"%s:\t%.32s", signalled ? L"Set" : L"Clr", (LPTSTR)cstr);
            szSignalText[ARRAY_SIZE(szSignalText) - 1] = 0;

            _CSignalListBox.SetString(i, szSignalText);
        }
        _CSignalListBox.SetEnd(i);
        _CSignalListBox.Refresh();
    }
}

wchar_t *FormatFileTime(_int64 t, wchar_t szBuf[16])
{
    wchar_t *szPrefix = L"";
    if (t < 0)
    {
        t = -t;
        szPrefix = L"-";
    }
    t /= 1000;
    long Sec   = t % 60;
    long Min   = (t / 60) % 60;
    long Hours = t / 3600;
    wsprintf(szBuf, L"%s%02.2d:%02.2d:%02.2d", szPrefix, Hours, Min, Sec);
    return szBuf;
}

void CStatusDialog::PopulateProcesses()
{
    if (!_hwnd)
        return;
    int cProcesses = 0;
    for(int pass = 0; pass < 2; ++pass)
    {
        CProcessThread *pProcess;
        for(int i = 0; (pProcess = _pMTScript->GetProcess(i)) != 0; ++i)
        {
            const PROCESS_PARAMS *params = pProcess->GetParams();
            const TCHAR *ptr = _T("<invalid>");
            if (params->pszCommand)
                ptr = (LPTSTR)params->pszCommand;

            wchar_t szText[256];
            wchar_t szTimeBuf[16];
            DWORD dwExitCode = pProcess->GetExitCode();
            if (pass == 0 && dwExitCode == STILL_ACTIVE)
            {
                HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION,
                    false,
                    pProcess->ProcId());

                if (hProc)
                {
                    _int64 i64CreationTime;
                    _int64 i64ExitTime;
                    _int64 i64KernelTime;
                    _int64 i64UserTime;
                    GetProcessTimes(hProc,
                        (FILETIME*) &i64CreationTime,
                        (FILETIME*) &i64ExitTime,
                        (FILETIME*) &i64KernelTime,
                        (FILETIME*) &i64UserTime);

                    GetSystemTimeAsFileTime((FILETIME*)&i64ExitTime);
                    CloseHandle(hProc);
                    wsprintf(szText, L"%04d (R):\t%.128s (%s)",
                        pProcess->ProcId(),
                        ptr,
                        FormatFileTime((i64ExitTime - i64CreationTime) / 10000, szTimeBuf));
                }
                else
                    wsprintf(szText, L"%04d (R):\t%.128s", pProcess->ProcId(), ptr);
                szText[ARRAY_SIZE(szText) - 1] = 0;
                _CProcessListBox.SetString(cProcesses, szText);
                ++cProcesses;
            }
            else if (pass == 1 && dwExitCode != STILL_ACTIVE)
            {
                wsprintf(szText, L"%04d (%u):\t%.128s\t (-%s)",
                    pProcess->ProcId(),
                    dwExitCode,
                    ptr, FormatFileTime(pProcess->GetDeadTime() , szTimeBuf));

                szText[ARRAY_SIZE(szText) - 1] = 0;
                _CProcessListBox.SetString(cProcesses, szText);
                ++cProcesses;
            }
        }
    }
    _CProcessListBox.SetEnd(cProcesses);
    _CProcessListBox.Refresh();
}

void CStatusDialog::Refresh()
{
    PopulateScripts();
    PopulateProcesses();
    PopulateSignals();
}

bool Exists(const TCHAR *pszLogFileName)
{
    WIN32_FIND_DATA fd;

    HANDLE hFind = FindFirstFile(pszLogFileName, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        FindClose(hFind);
        return true;
    }
    return false;
}

void RenumberFile(const TCHAR *pszLogFileName)
{
    if (Exists(pszLogFileName))
    {
        TCHAR achFileName[MAX_PATH + 32];
        const TCHAR *dot   = wcsrchr(pszLogFileName, L'.');
        const TCHAR *slash = wcsrchr(pszLogFileName, L'\\');
        const TCHAR *colon = wcsrchr(pszLogFileName, L':');

        if (dot && dot > pszLogFileName && dot > slash && dot > colon)
        {
            for(int i = 1; i < 999; ++i)
            {
                swprintf(achFileName, L"%.*s_%.03d.%s", dot - pszLogFileName, pszLogFileName, i, dot + 1);
                if (!Exists(achFileName))
                {
                    MoveFile(pszLogFileName, achFileName);
                    break;
                }
            }
        }
    }
}

void CStatusDialog::OUTPUTDEBUGSTRING(LPWSTR pszMsg)
{
#if DBG != 1
    if (_hwnd)
#endif
    {
        _COutputListBox.AppendString(pszMsg);
        _COutputListBox.Refresh();
    }

    if (_fLogToFile )
    {
        if (!_fCreatedLogFileName)
        {
            if (ExpandEnvironmentStrings(_cstrLogFileName, _achLogFileName, ARRAY_SIZE(_achLogFileName)))
                _fCreatedLogFileName = true;

            RenumberFile(_achLogFileName);
            _fAddedHeaderToFile = false;
        }
        FILE *f = _wfopen(_achLogFileName, L"a+");
        if (f)
        {
            if (!_fAddedHeaderToFile)
            {
                _fAddedHeaderToFile = true;
                time_t t = time(0);
                fprintf(f, "============================\nMTScript started %s", ctime(&t));
            }
            fputws(pszMsg, f);
            fputws(L"\n", f);
            fclose(f);
        }
    }
}

void CStatusDialog::ClearOutput()
{
    _COutputListBox.ResetContent();
    _COutputListBox.Refresh();
}

void CStatusDialog::Resize(int width, int height)
{
    _Resizer.NewSize();
}

void CStatusDialog::GetMinMaxInfo(MINMAXINFO *mmi)
{
    mmi->ptMinTrackSize = _InitialSize;
}

void CStatusDialog::Pause()
{
    if (_hwnd)
    {
        KillTimer(_hwnd, 1);
    }
    _fPaused = TRUE;
}

void CStatusDialog::Restart()
{
    if (_hwnd && _fPaused)
    {
        SetTimer(_hwnd, 1, REFRESH_DELAY, 0);
    }
    _fPaused = FALSE;

    _fAddedHeaderToFile = false;
}

HRESULT CStatusDialog::UpdateOptionSettings(BOOL fSave)
{
    static REGKEYINFORMATION aKeyValuesOptions[] =
    {
        { _T("Options"),          RKI_KEY, 0 },
        { _T("StatusDialogOpen"), RKI_BOOL,   offsetof(CStatusDialog, _fStatusOpen) },
        { _T("LogToFile"),        RKI_BOOL,   offsetof(CStatusDialog, _fLogToFile) } ,
        { _T("LogFileName"),      RKI_STRING, offsetof(CStatusDialog, _cstrLogFileName) } ,
        { _T("StatusLeft"),       RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.left) },
        { _T("StatusTop"),        RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.top) },
        { _T("StatusRight"),      RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.right) },
        { _T("StatusBottom"),     RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.rcNormalPosition.bottom) },
        { _T("StatusMaxLeft"),    RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.ptMaxPosition.x) },
        { _T("StatusMaxTop"),     RKI_DWORD,  offsetof(CStatusDialog, _WindowPlacement.ptMaxPosition.y) },
        { _T("StatusMax"),        RKI_BOOL,   offsetof(CStatusDialog, _fMaximized) } ,
    };

    HRESULT hr;
    if (fSave)
    {
        if (_hwnd)
        {
            _WindowPlacement.length = sizeof(WINDOWPLACEMENT);
            GetWindowPlacement(_hwnd, &_WindowPlacement);
            if (_WindowPlacement.showCmd == SW_MAXIMIZE)
                _fMaximized = TRUE;
            else
                _fMaximized = FALSE;
        }
    }
    hr = RegSettingsIO(g_szRegistry, fSave, aKeyValuesOptions, ARRAY_SIZE(aKeyValuesOptions), (BYTE *)this);

    return hr;
}

void CStatusDialog::ToggleSignal()
{
    int index = _CSignalListBox.SendMessage(LB_GETCARETINDEX, 0, 0);
    LPCTSTR pszName = _CSignalListBox.GetString(index);
    if (pszName)
        pszName = wcschr(pszName, L'\t');
    HANDLE hEvent;
    if (pszName && CScriptHost::GetSyncEvent(pszName + 1, &hEvent) == S_OK)
    {
        bool signalled = (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0);
        if (signalled)
            ResetEvent(hEvent);
        else
            SetEvent(hEvent);
    }
}

void CStatusDialog::UpdateLogging()
{
    _fLogToFile = (SendDlgItemMessage(_hwnd, IDC_LOGGING, BM_GETCHECK, 0, 0) == BST_CHECKED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\resizer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       Resizer.cxx
//
//  Contents:   Implementation of the CResizer class
//
//              Written by Joe Porkka
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "Resizer.h"


CResizer::CResizer()
:    _hWnd(0), _pResizeInfo(0)
{
    memset(&_winRect, 0, sizeof(_winRect));
}

void CResizer::Init(HWND win, CResizeInfo *pResizeInfo)
{
    _hWnd = win;
    _pResizeInfo = pResizeInfo;
    GetClientRect(_hWnd, &_winRect);
    for(CResizeInfo *p = _pResizeInfo; p->_id; ++p)
    {
        InitCtrl(p);
    }
}

CResizer::~CResizer()
{
}

void CResizer::NewSize() const
{
    RECT newDlgSize;
    GetClientRect(_hWnd, &newDlgSize);
    for(CResizeInfo *p = _pResizeInfo; p->_id; ++p)
    {
        RECT newpos = p->_Rect;
        if (p->_Flags & sf_Width)
        { // Adjust the width
            int w = (p->_Rect.right - p->_Rect.left) + (newDlgSize.right - _winRect.right);
            newpos.right = newpos.left + w;
        }
        if (p->_Flags & sf_Height)
        { // Adjust the height
            int h = (p->_Rect.bottom - p->_Rect.top) + (newDlgSize.bottom - _winRect.bottom);
            newpos.bottom = newpos.top + h;
        }
        if (p->_Flags & sf_Left)
        { // adjust left edge
            int w = p->_Rect.right - p->_Rect.left;
            newpos.left = newDlgSize.right - (_winRect.right - p->_Rect.left);
            newpos.right = newpos.left + w;
        }
        if (p->_Flags & sf_Top)
        { // adjust top edge
            int h = p->_Rect.bottom - p->_Rect.top;
            newpos.top = newDlgSize.bottom - (_winRect.bottom - p->_Rect.top);
            newpos.bottom = newpos.top + h;
        }

        if (p->_Flags & sf_HalfLeftWidth)
        { // adjust left edge & width by half width delta
//            int w = p->_Rect.right - p->_Rect.left;
            int widthdelta = newDlgSize.right - _winRect.right;
            newpos.left = p->_Rect.left + widthdelta / 2;
            newpos.right = p->_Rect.right + widthdelta;
        }
        if (p->_Flags & sf_HalfTopHeight)
        { // adjust left edge & width by half width delta
            int heightdelta = newDlgSize.bottom - _winRect.bottom;
            newpos.top = p->_Rect.top + heightdelta / 2;
            newpos.bottom = p->_Rect.bottom + heightdelta;
        }

        if (p->_Flags & sf_HalfWidth)
        { // adjust left edge & width by half width delta
            int widthdelta = newDlgSize.right - _winRect.right;
            newpos.right = p->_Rect.right + widthdelta  - widthdelta / 2;
        }
        if (p->_Flags & sf_HalfHeight)
        { // adjust left edge & width by half width delta
            int heightdelta = newDlgSize.bottom - _winRect.bottom;
            newpos.bottom = p->_Rect.bottom + heightdelta - heightdelta / 2;
        }

        SetWindowPos(GetDlgItem(_hWnd, p->_id), 0, newpos.left, newpos.top, newpos.right - newpos.left, newpos.bottom - newpos.top, SWP_NOZORDER);
    }
}

void CResizer::InitCtrl(CResizeInfo *p)
{
    GetWindowRect(GetDlgItem(_hWnd, p->_id), &p->_Rect);
    MapWindowPoints(0, _hWnd, (POINT *)&p->_Rect, 2); // Map abs coordinates of control to dialog relative.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\config.h ===
#define IDD_CONFIGPATHS             100
#define IDD_SCRIPTPATH              103
#define IDD_INITSCRIPT              107
#define IDD_STATUSDIALOG            108
#define IDC_SCRIPTLIST              109
#define IDC_STATUSOUTPUT            112
#define IDC_DEBUGOUTPUT             114
#define IDC_PROCESSLIST             111
#define IDC_CLEAR                   117
#define IDC_SIGNALLIST              118
#define IDC_OUTPUTTEXT              113
#define IDC_PROCESSTEXT             115
#define IDC_SIGNALTEXT              116
#define IDC_LOGGING                 119
#define IDC_EXIT                    120
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\proccomm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       proccomm.cxx
//
//  Contents:   Implementation of the CProcessComm class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

DeclareTag(tagProcComm, "MTScript", "IScriptedProcess communication");

CProcessComm::CProcessComm(CMTScript *pMT)
{
    _ulRefs = 1;

    _pMT = pMT;

    Assert(_pSink == NULL);
    Assert(_pSH == NULL);
    Assert(_pProc == NULL);
    TraceTag((tagProcComm, "CProcessComm this(%x)", this));
}

CProcessComm::~CProcessComm()
{
    TraceTag((tagProcComm, "%p: Destroyed this(%x)", _pProc, this));

    if (_pProc)
    {
        _pProc->SetProcComm(NULL);
    }

    ReleaseInterface(_pSink);
    ReleaseInterface(_pSH);
    ReleaseInterface(_pProc);
}

HRESULT
CProcessComm::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IScriptedProcess)
    {
        *ppv = (IScriptedProcess *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SetProcessID, public
//
//  Synopsis:   Called by the remote process to tell us who it is.  We use
//              the information to match it with the CProcessThread and
//              CScriptHost object that created it.
//
//  Arguments:  [lProcessID] -- Process ID of the calling process
//              [pszEnvID]   -- Value of the __MTSCRIPT_ENV_ID environment
//                              variable.
//
//  Returns:    S_OK, E_INVALIDARG if a match could not be made.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SetProcessID(long lProcessID, wchar_t *pszEnvID)
{
    CProcessThread **ppProc;
    int              cProcs;
    long             lEnvID;
    wchar_t         *pch;

    if (!pszEnvID)
    {
        return E_INVALIDARG;
    }

    if (_pProc)
    {
        TraceTag((tagProcComm, "%p: Got duplicate call to SetProcessID! (id=%d)", _pProc, lProcessID));
        return E_UNEXPECTED;
    }

    lEnvID = wcstol(pszEnvID, &pch, 10);

    LOCK_LOCALS(_pMT);

    for (ppProc = _pMT->_aryProcesses, cProcs = _pMT->_aryProcesses.Size();
         cProcs;
         ppProc++, cProcs--)
    {
        if ((*ppProc)->IsOwner(lProcessID, lEnvID))
        {
            break;
        }
    }

    if (cProcs == 0)
    {
        return E_INVALIDARG;
    }

    // We don't allow more than one process to connect to a single
    // CProcessThread. This could happen if more than one child process of
    // the one we launched with RunLocalCommand tries to connect. All but the
    // first one will get an error back.

    if ((*ppProc)->GetProcComm())
    {
        TraceTag((tagProcComm, "%p: Got duplicate call to SetProcessID! (id=%d)", *ppProc, lProcessID));
        return E_UNEXPECTED;
    }

    _pProc = *ppProc;
    _pProc->AddRef();

    _pSH = _pProc->ScriptHost();
    _pSH->AddRef();

    _pProc->SetProcComm(this);

    TraceTag((tagProcComm, "Proc:%p, this:%p: Received SetProcessID call: %d, %ls", _pProc, this, lProcessID, pszEnvID));

    _pMT->PostToThread(_pSH, MD_PROCESSCONNECTED, &_pProc, sizeof(CProcessComm*));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SendData, public
//
//  Synopsis:   Called by the remote process when it wants to fire an event
//              into the script.
//
//  Arguments:  [pszType]  -- String giving name of data
//              [pszData]  -- String giving data
//              [plReturn] -- Return value from event handler
//
//  Returns:    HRESULT
//
//  Notes:      This uses the same data structures as CMachine::Exec and is
//              basically the same code.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SendData(wchar_t * pszType,
                       wchar_t * pszData,
                       long    * plReturn)
{
    // We create an event object for each call on this method. While this
    // may have a cost, it makes this method thread-safe. If we cached an
    // event object then we would have to synchronize access to that event
    // object which could be even more expensive.
    MACHPROC_EVENT_DATA   med;
    MACHPROC_EVENT_DATA * pmed;
    VARIANT           vRet;
    VARIANT           vLong;
    HRESULT           hr = S_OK;

    TraceTag((tagProcComm, "%p: SendData call received: (%ls, %ls)", _pProc, pszType, pszData));

    VariantInit(&vRet);
    VariantInit(&vLong);

    if (!_pSH)
    {
        return E_UNEXPECTED;
    }

    if (!plReturn)
    {
        return E_INVALIDARG;
    }

    med.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (med.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    med.bstrCmd     = SysAllocString(pszType);
    med.bstrParams  = SysAllocString(pszData);
    med.dwProcId    = _pProc->ProcId();
    med.pvReturn    = &vRet;
    med.dwGITCookie = 0;
    med.hrReturn    = S_OK;

    pmed = &med;

    _pMT->PostToThread(_pSH,
                       MD_PROCESSDATA,
                       (LPVOID)&pmed,
                       sizeof(MACHPROC_EVENT_DATA*));

    // We can do WaitForSingleObject because we are in OLE's multi-threaded
    // apartment and don't need to handle messages from our event loop.
    WaitForSingleObject(med.hEvent, INFINITE);

    if (med.hrReturn != S_OK)
    {
        hr = med.hrReturn;
        goto Cleanup;
    }

    if (VariantChangeType(&vLong, &vRet, 0, VT_I4) != S_OK)
    {
        *plReturn = -1;
    }
    else
    {
        *plReturn = V_I4(&vLong);
    }

Cleanup:
    VariantClear(&vRet);
    VariantClear(&vLong);

    SysFreeString(med.bstrCmd);
    SysFreeString(med.bstrParams);

    CloseHandle(med.hEvent);

    TraceTag((tagProcComm, "%p: SendData is returning %x", _pProc, hr));

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SetExitCode, public
//
//  Synopsis:   Sets the exit code which will be given to the script for
//              this process. This will override the actual exit code of
//              the process.
//
//  Arguments:  [lExitCode] -- New exit code.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SetExitCode(long lExitCode)
{
    if (!_pProc)
    {
        return E_UNEXPECTED;
    }

    TraceTag((tagProcComm, "%p: Process set exit code of %d", _pProc, lExitCode));

    _pProc->SetExitCode((DWORD)lExitCode);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SetProcessSink, public
//
//  Synopsis:   Sets the sink interface so the script can call back into
//              the remote process.
//
//  Arguments:  [pSink] -- Sink interface
//
//  Returns:    HRESULT
//
//  Notes:      Clear the sink by calling SetProcessSink with NULL before
//              shutting down.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CProcessComm::SetProcessSink(IScriptedProcessSink *pSink)
{
    ReleaseInterface(_pSink);

    _pSink = pSink;

    TraceTag((tagProcComm, "%p: Received new process sink (%p)", _pProc, pSink));

    if (pSink)
    {
        pSink->AddRef();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessComm::SendToProcess, public
//
//  Synopsis:   Sends a command to the remote process as requested by the
//              script engine.
//
//  Arguments:  [pmed] -- Pointer to cross-thread data structure.
//
//----------------------------------------------------------------------------

void
CProcessComm::SendToProcess(MACHPROC_EVENT_DATA *pmed)
{
    long    lReturn     = 0;
    HRESULT hr          = S_OK;

    TraceTag((tagProcComm, "%p: Making call to ReceiveData. Params=(%ls, %ls)",
              _pProc, pmed->bstrCmd, pmed->bstrParams));

    if (_pSink)
    {
        hr = _pSink->ReceiveData(pmed->bstrCmd, pmed->bstrParams, &lReturn);
    }

    V_VT(pmed->pvReturn) = VT_I4;
    V_I4(pmed->pvReturn) = lReturn;

    TraceTag((tagProcComm, "%p: Call to ReceiveData returned %x", _pProc, hr));

    pmed->hrReturn = hr;

    SetEvent(pmed->hEvent);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\dialogs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       hostobj.h
//
//  Contents:   Contains the main application object
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CConfig (cdd)
//
//  Purpose:    Class which runs the configuration dialog. We run it in a
//              separate thread because we cannot afford to block the main
//              thread on UI stuff.
//
//----------------------------------------------------------------------------

class CConfig : public CThreadComm
{

    friend BOOL CALLBACK
           ConfigDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

public:
    DECLARE_STANDARD_IUNKNOWN(CConfig);

    CConfig(CMTScript *pMT) : _pMT(pMT) { _ulRefs = 1; }

    CMTScript * _pMT;

protected:
    virtual DWORD ThreadMain();

    void InitializeConfigDialog(HWND hwnd);
    BOOL CommitConfigChanges(HWND hwnd);

private:
    HWND   _hwnd;
};


//+---------------------------------------------------------------------------
//
//  Class:      CMessageBoxTimeout (cdd)
//
//  Purpose:    Class which runs the configuration dialog. We run it in a
//              separate thread because we cannot afford to block the main
//              thread on UI stuff.
//
//----------------------------------------------------------------------------

class CMessageBoxTimeout : public CThreadComm
{

    friend BOOL CALLBACK
           MBTimeoutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

public:
    DECLARE_STANDARD_IUNKNOWN(CMessageBoxTimeout);

    CMessageBoxTimeout(MBTIMEOUT *pmbt) : _pmbt(pmbt) { _ulRefs = 1; }

    MBTIMEOUT *_pmbt;
    long       _lSecondsTilCancel;
    long       _lSecondsTilNextEvent;
    HWND       _hwnd;

protected:
    virtual DWORD ThreadMain();

    void InitializeDialog(HWND hwnd);
    void OnCommand(USHORT id, USHORT wNotify);
    void OnTimer();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\exe\mtscript.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mtscript.cxx
//
//  Contents:   Implementation of the MTScript class
//
//              Written by Lyle Corbin
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include <shellapi.h>
#include <advpub.h>     // for RegInstall

#include "StatusDialog.h"
#include "RegSettingsIO.h"

HINSTANCE   g_hInstDll;
HINSTANCE   g_hinstAdvPack = NULL;
REGINSTALL  g_pfnRegInstall = NULL;

const TCHAR *g_szWindowName = _T("MTScript");

LRESULT CALLBACK MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//
// Global variables
//

HINSTANCE g_hInstance  = NULL;

EXTERN_C  HANDLE    g_hProcessHeap = NULL;
DWORD     g_dwFALSE   = 0;

DeclareTagOther(tagDebugger, "MTScript", "Register with script debugger (MUST RESTART)");
DeclareTagOther(tagIMSpy, "!Memory", "Register IMallocSpy (MUST RESTART)");

//+---------------------------------------------------------------------------
//
//  Function:   ErrorPopup
//
//  Synopsis:   Displays a message to the user.
//
//----------------------------------------------------------------------------

#define ERRPOPUP_BUFSIZE 300

void
ErrorPopup(LPWSTR szMessage)
{
    WCHAR achBuf[ERRPOPUP_BUFSIZE];

    _snwprintf(achBuf, ERRPOPUP_BUFSIZE, L"%s: (%d)", szMessage, GetLastError());

    achBuf[ERRPOPUP_BUFSIZE - 1] = L'\0';

    MessageBox(NULL, achBuf, L"MTScript", MB_OK | MB_SETFOREGROUND);
}

int PrintfMessageBox(HWND hwnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType, ...)
{
    TCHAR chBuffer[256];
    va_list args;
    va_start(args, uType);
    _vsnwprintf(chBuffer, 256, lpText, args);
    va_end(args);
    return MessageBox(hwnd, chBuffer, lpCaption, uType);
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadAdvPack
//
//  Synopsis:   Loads AdvPack.dll for DLL registration.
//
//----------------------------------------------------------------------------

HRESULT
LoadAdvPack()
{
    HRESULT hr = S_OK;

    g_hinstAdvPack = LoadLibrary(_T("ADVPACK.DLL"));

    if (!g_hinstAdvPack)
        goto Error;

    g_pfnRegInstall = (REGINSTALL)GetProcAddress(g_hinstAdvPack, achREGINSTALL);

    if (!g_pfnRegInstall)
        goto Error;

Cleanup:
    return hr;

Error:
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (g_hinstAdvPack)
    {
        FreeLibrary(g_hinstAdvPack);
    }

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   Register
//
//  Synopsis:   Register the various important information needed by this
//              executable.
//
//  Notes:      Uses AdvPack.dll and an INF file to do the registration
//
//----------------------------------------------------------------------------

HRESULT
Register()
{
    HRESULT   hr;
    OLECHAR   strClsid[40];
    TCHAR     keyName [256];
    STRTABLE  stReg = { 0, NULL };

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    hr = g_pfnRegInstall(GetModuleHandle(NULL), "Register", &stReg);

    if (!hr)
    {
        DWORD dwRet;
        HKEY  hKey;
        BOOL  fSetACL = FALSE;

        // If the access key already exists, then don't modify it in case
        // someone changed it from the defaults.

        StringFromGUID2(CLSID_RemoteMTScript, strClsid, 40);

        wsprintf (keyName, TEXT("APPID\\%s"), strClsid);

        dwRet = RegOpenKeyEx (HKEY_CLASSES_ROOT,
                              keyName,
                              0,
                              KEY_ALL_ACCESS,
                              &hKey);

        if (dwRet == ERROR_SUCCESS)
        {
            dwRet = RegQueryValueEx (hKey,
                                     TEXT("AccessPermission"),
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);

            if (dwRet != ERROR_SUCCESS)
            {
                fSetACL = TRUE;
            }

            RegCloseKey (hKey);
        }
        else
        {
            fSetACL = TRUE;
        }

        if (fSetACL)
        {
            // Give everyone access rights
            hr = ChangeAppIDACL(CLSID_RemoteMTScript, _T("EVERYONE"), TRUE, TRUE, TRUE);

            if (!hr)
            {
                // Deny everyone launch rights
                hr = ChangeAppIDACL(CLSID_RemoteMTScript, _T("EVERYONE"), FALSE, TRUE, TRUE);
            }
        }
    }

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+------------------------------------------------------------------------
//
// Function:    Unregister
//
// Synopsis:    Undo the actions of Register.
//
//-------------------------------------------------------------------------

HRESULT
Unregister()
{
    HRESULT  hr;
    HKEY     hKey;
    DWORD    dwRet;
    OLECHAR  strClsid[40];
    TCHAR    keyName [256];

    STRTABLE stReg = { 0, NULL };

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    //
    // Remove the security keys that we created while registering
    //

    StringFromGUID2(CLSID_RemoteMTScript, strClsid, 40);

    wsprintf (keyName, TEXT("APPID\\%s"), strClsid);

    dwRet = RegOpenKeyEx (HKEY_CLASSES_ROOT,
                          keyName,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey);

    if (dwRet == ERROR_SUCCESS)
    {
        RegDeleteValue (hKey, TEXT("AccessPermission"));
        RegDeleteValue (hKey, TEXT("LaunchPermission"));

        RegCloseKey (hKey);
    }

    hr = g_pfnRegInstall(GetModuleHandle(NULL), "Unregister", &stReg);

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   IAmTheOnlyMTScript, private
//
//  Synopsis:   Guarantees that only 1 MTScript gets to run
//
//  Arguments:
//
//  Returns:    True is there is not already a running MTScript.
//
//  Note:       This function "leaks" a Mutex handle intentionally.
//              The system frees this handle on exit - so we know
//              for sure that we have finished all other cleanup
//              before it OK for another instance of MTScript to run.
//
//-------------------------------------------------------------------------

static bool IAmTheOnlyMTScript()
{
    HANDLE hMutex = CreateMutex(0, FALSE, g_szWindowName);
    if (!hMutex)
    {
        ErrorPopup(_T("Cannot create MTScript mutex!"));
        return false;
    }
    if( GetLastError() == ERROR_ALREADY_EXISTS)
    {
        ErrorPopup(_T("Cannot run more than one mtscript.exe!"));
        return false;
    }
    return true;
}

//+------------------------------------------------------------------------
//
//  Function:   WinMain, public
//
//  Synopsis:   Entry routine called by Windows upon startup.
//
//  Arguments:  [hInstance]     -- handle to the program's instance
//              [hPrevInstance] -- Always NULL
//              [lpCmdLine]     -- Command line arguments
//              [nCmdShow]      -- Value to be passed to ShowWindow when the
//                                   main window is initialized.
//
//  Returns:    FALSE on error or the value passed from PostQuitMessage on exit
//
//-------------------------------------------------------------------------

EXTERN_C int PASCAL
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    OSVERSIONINFO  ovi;
    CMTScript *    pMT = NULL;
    int            iRet = 0;
#if DBG == 1
    IMallocSpy *   pSpy = NULL;
#endif

#ifdef USE_STACK_SPEW
    InitChkStk(0xCCCCCCCC);
#endif

    //
    // Initialize data structures.
    //
    g_hProcessHeap = GetProcessHeap();
    g_hInstance    = hInstance;

#if DBG == 1
    DbgExRestoreDefaultDebugState();
#endif

    //
    // Get system information
    //
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&ovi);

    if (ovi.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        // Win95 doesn't implement MessageBoxW
        MessageBoxA(NULL,
                    "MTScript",
                    "This program can only be run on Windows NT",
                    MB_OK | MB_SETFOREGROUND);

        goto Error;
    }

    if (lpCmdLine && _stricmp(&lpCmdLine[1], "register") == 0)
    {
        HRESULT hr;

        hr = Register();
        if (FAILED(hr))
            goto Error;

        return 0;
    }
    else if (lpCmdLine && _stricmp(&lpCmdLine[1], "unregister") == 0)
    {
        HRESULT hr;

        hr = Unregister();
        if (FAILED(hr))
            goto Error;

        return 0;
    }

    if (!IAmTheOnlyMTScript() )
    {
        return 1;
    }

#if DBG == 1
    if (DbgExIsTagEnabled(tagIMSpy))
    {
        pSpy = (IMallocSpy *)DbgExGetMallocSpy();

        if (pSpy)
        {
            CoRegisterMallocSpy(pSpy);
        }
    }
#endif

    //
    // Can't put it on the stack because it depends on having zero'd memory
    //
    pMT = new CMTScript();
    if (!pMT)
        goto Error;

    if (!pMT->Init())
        goto Error;

    //
    // Start doing real stuff
    //
    iRet = pMT->ThreadMain();

Cleanup:
    if (pMT)
        pMT->Release();

#if DBG == 1
    if (pSpy)
    {
        // Note, due to the fact that we do not have control over DLL unload
        // ordering, the IMallocSpy implementation may report false leaks.
        // (lylec) The only way to fix this is to explicitely load all
        // dependent DLLs and unload them in their proper order (mshtmdbg.dll
        // last).
        CoRevokeMallocSpy();
    }
#endif

    return iRet;

Error:
    iRet = 1;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  CMTScript::OPTIONSETTINGS class
//
//  Handles user-configurable options
//
//----------------------------------------------------------------------------

CMTScript::OPTIONSETTINGS::OPTIONSETTINGS()
    : cstrScriptPath(CSTR_NOINIT),
      cstrInitScript(CSTR_NOINIT)
{

}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::OPTIONSETTINGS::GetModulePath, public
//
//  Synopsis:   Returns the path of this executable. Used for finding other
//              related files.
//
//  Arguments:  [pstr] -- Place to put path.
//
//  Notes:      Any existing string in pstr will be cleared.
//
//----------------------------------------------------------------------------

void
CMTScript::OPTIONSETTINGS::GetModulePath(CStr *pstr)
{
    WCHAR *pch;
    WCHAR  achBuf[MAX_PATH];

    pstr->Free();

    if (!GetModuleFileName(NULL, achBuf, sizeof(achBuf)))
        return;

    pch = wcsrchr(achBuf, L'\\');
    if (!pch)
        return;

    *pch = L'\0';

    pstr->Set(achBuf);
}

void
CMTScript::OPTIONSETTINGS::GetScriptPath(CStr *cstrScript)
{
    LOCK_LOCALS(this);
    if (cstrScriptPath.Length() == 0)
    {
        // TCHAR  achBuf[MAX_PATH];
        // TCHAR *psz;

        GetModulePath(cstrScript);

/*
        cstrScript->Append(L"\\..\\..\\scripts");

        GetFullPathName(*cstrScript, MAX_PATH, achBuf, &psz);

        cstrScript->Set(achBuf);
*/
    }
    else
    {
        cstrScript->Set(cstrScriptPath);
    }
}

void
CMTScript::OPTIONSETTINGS::GetInitScript(CStr *cstr)
{
    static WCHAR * pszInitScript = L"mtscript.js";

    LOCK_LOCALS(this);
    if (cstrInitScript.Length() == 0)
    {
        cstr->Set(pszInitScript);
    }
    else
    {
        cstr->Set(cstrInitScript);
    }
}

//+---------------------------------------------------------------------------
//
//  CMTScript class
//
//  Handles the main UI thread
//
//----------------------------------------------------------------------------

CMTScript::CMTScript()
{
    Assert(_fInDestructor == FALSE);
    Assert(_pGIT == NULL);
    Assert(_dwPublicDataCookie == 0);
    Assert(_dwPrivateDataCookie == 0);
    Assert(_dwPublicSerialNum == 0);
    Assert(_dwPrivateSerialNum == 0);

    VariantInit(&_vPublicData);
    VariantInit(&_vPrivateData);

    _ulRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::~CMTScript, public
//
//  Synopsis:   destructor
//
//  Notes:      Anything done in the Init() call must be undone here. This
//              method must also be able to handle a partial initialization,
//              in case something inside Init() failed halfway through.
//
//----------------------------------------------------------------------------

CMTScript::~CMTScript()
{
    int       i;

    VERIFY_THREAD();

    // Anything done in the Init() call must be undone here

    UnregisterClassObjects();

    _fInDestructor = TRUE;

    //
    // Process any pending messages such as PROCESSTHREADTERMINATE now.
    //
    HandleThreadMessage();

    // Cleanup any running processes.

    for (i = 0; i < _aryProcesses.Size(); i++)
    {
        Shutdown(_aryProcesses[i]);
    }
    _aryProcesses.ReleaseAll();

    //
    // This must be done in reverse order because the primary script (element 0)
    // must be shutdown last.
    //
    for (i = _aryScripts.Size() - 1; i >= 0; i--)
    {
        Shutdown(_aryScripts[i]);
    }
    _aryScripts.ReleaseAll();

    if (_pMachine)
    {
        Shutdown(_pMachine);
        ReleaseInterface(_pMachine);
    }

    if (_dwPublicDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPublicDataCookie);
    }

    if (_dwPrivateDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPrivateDataCookie);
    }

    ReleaseInterface(_pTIMachine);
    ReleaseInterface(_pTypeLibEXE);
    ReleaseInterface(_pGIT);

    ReleaseInterface(_pJScriptFactory);

    VariantClear(&_vPublicData);
    VariantClear(&_vPrivateData);

    DeInitScriptDebugger();

    CoUninitialize();

    CleanupUI();

    // This delete call must be done after we've destroyed our window, which
    // in turn will destroy the status window.
    delete _pStatusDialog;
    _pStatusDialog = NULL;
}

HRESULT
CMTScript::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::Init, public
//
//  Synopsis:   Initialization method that can fail.
//
//----------------------------------------------------------------------------

BOOL
CMTScript::Init()
{
    HRESULT hr;

    _dwThreadId = GetCurrentThreadId();

    if (!CThreadComm::Init())
        return FALSE;

    //
    // Load our default configuration
    //
    UpdateOptionSettings(FALSE);

    if (FAILED(CoInitializeEx(NULL,
                              COINIT_MULTITHREADED |
                              COINIT_DISABLE_OLE1DDE   |
                              COINIT_SPEED_OVER_MEMORY)))
    {
        goto Error;
    }

    // This code may be needed if we want to do our own custom security.
    // However, it is easier to let DCOM do it for us.

    // The following code removes all security always. It cannot be overridden
    // using the registry.

    if (FAILED(CoInitializeSecurity(NULL,
                                    -1,
                                    NULL,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_NONE,
                                    RPC_C_IMP_LEVEL_IMPERSONATE,
                                    NULL,
                                    EOAC_NONE,
                                    NULL)))
    {
        goto Error;
    }

    hr = LoadTypeLibraries();
    if (hr)
        goto Error;

    InitScriptDebugger();

    if (FAILED(CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IGlobalInterfaceTable,
                                (void **)&_pGIT)))
    {
        goto Error;
    }

     //
    // Create our hidden window and put an icon on the taskbar
    //
    if (!ConfigureUI())
        goto Error;

    //
    // Run the initial script
    //
    if (FAILED(RunScript(NULL, NULL)))
        goto Error;

    if (RegisterClassObjects(this) != S_OK)
        goto Error;

    #if DBG == 1
        OpenStatusDialog();
    #endif
    return TRUE;

Error:
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::ThreadMain, public
//
//  Synopsis:   Main UI message loop.
//
//  Arguments:  [hWnd] -- Modeless Dialog HWND
//
//----------------------------------------------------------------------------

DWORD
CMTScript::ThreadMain()
{
    DWORD            dwRet;
    HANDLE           ahEvents[3];
    int              cEvents = 2;
    DWORD            dwReturn = 0;

    VERIFY_THREAD();

    SetName("CMTScript");

    // Don't need to call ThreadStarted() because StartThread() was not used
    // to start the main thread!

    ahEvents[0] = _hCommEvent;
    ahEvents[1] = GetPrimaryScript()->hThread();

    while (TRUE)
    {
        MSG msg;

        //
        // Purge out all window messages.
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                goto Cleanup;
            }

            if (_pStatusDialog)
            {
                if (_pStatusDialog->IsDialogMessage(&msg))
                    continue;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        //
        // Wait for anything we need to deal with.
        //
        dwRet = MsgWaitForMultipleObjects(cEvents,
                                          ahEvents,
                                          FALSE,
                                          INFINITE,
                                          QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
        {
            //
            // Another thread is sending us a message.
            //
            HandleThreadMessage();
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            // The Primary Script Thread terminated due to a problem loading
            // the initial script. Bring up the configuration dialog.

            {
                LOCK_LOCALS(this);
                _aryScripts.ReleaseAll();
            }

            if (!_fRestarting)
            {
                int iRet = MessageBox(_hwnd, _T("An error occurred loading the default script.\n\nDo you wish to edit the default configuration?"),
                                      _T("MTScript Error"),
                                      MB_YESNO | MB_SETFOREGROUND | MB_ICONERROR);

                if (iRet == IDNO)
                {
                    goto Cleanup;
                }

                _fRestarting = TRUE; // Preventthe config dialog from doing a restart in this case.
                CConfig * pConfig = new CConfig(this);

                if (pConfig)
                {
                    pConfig->StartThread(NULL);

                    WaitForSingleObject(pConfig->hThread(), INFINITE);

                    pConfig->Release();
                }
                _fRestarting = FALSE;
            }
            else
            {
                _fRestarting = FALSE;
            }

            //
            // Try re-loading the initial script
            //
            if (FAILED(RunScript(NULL, NULL)))
                goto Error;

            ahEvents[1] = GetPrimaryScript()->hThread();

            if (_pStatusDialog)
                _pStatusDialog->Restart();

        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            // Make sure our message queue is empty first.
            HandleThreadMessage();

            // Right now we never fall in this loop.
        }
        else if (dwRet == WAIT_FAILED)
        {
            TraceTag((tagError, "MsgWaitForMultipleObjects failure (%d)", GetLastError()));

            AssertSz(FALSE, "MsgWaitForMultipleObjects failure");

            goto Cleanup;
        }
    }


Cleanup:
    return dwReturn;

Error:
    dwReturn = 1;
    goto Cleanup;
}

void
CMTScript::InitScriptDebugger()
{
    HRESULT hr;

    if (!IsTagEnabled(tagDebugger))
    {
        return;
    }

    hr = CoCreateInstance(CLSID_ProcessDebugManager,
                          NULL,
                          CLSCTX_INPROC_SERVER |
                            CLSCTX_INPROC_HANDLER |
                            CLSCTX_LOCAL_SERVER,
                          IID_IProcessDebugManager,
                          (LPVOID*)&_pPDM);
    if (hr)
    {
        TraceTag((tagError, "Could not create ProcessDebugManager: %x", hr));
        return;
    }

    hr = THR(_pPDM->CreateApplication(&_pDA));
    if (hr)
        goto Error;

    _pDA->SetName(L"MTScript");

    hr = THR(_pPDM->AddApplication(_pDA, &_dwAppCookie));
    if (hr)
        goto Error;

    return;

Error:
    ClearInterface(&_pDA);
    ClearInterface(&_pPDM);

    return;
}

void
CMTScript::DeInitScriptDebugger()
{
    _try
    {
        if (_pPDM)
        {
            _pPDM->RemoveApplication(_dwAppCookie);

            _pDA->Close();

            ReleaseInterface(_pPDM);
            ReleaseInterface(_pDA);
        }
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
        //$ BUGBUG -- Figure out what's wrong here!

        // Ignore the crash caused by the Script Debugger
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::HackCreateInstance, public
//
//  Synopsis:   Loads a private jscript.dll since the one that shipped with
//              Win2K is broken for what we need it for.
//
//  Arguments:  [clsid]  -- Same parameters as CoCreateInstance.
//              [pUnk]   --
//              [clsctx] --
//              [riid]   --
//              [ppv]    --
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMTScript::HackCreateInstance(REFCLSID clsid,
                              IUnknown *pUnk,
                              DWORD clsctx,
                              REFIID riid,
                              LPVOID *ppv)
{
    TCHAR              achDllPath[MAX_PATH];
    HINSTANCE          hInstDll;
    DWORD              iRet;
    TCHAR             *pch;
    LPFNGETCLASSOBJECT pfnGCO = NULL;
    HRESULT            hr;
    DWORD              dwJunk;
    BYTE              *pBuf = NULL;
    VS_FIXEDFILEINFO  *pFI = NULL;
    UINT               iLen;

    if (!_pJScriptFactory && _fHackVersionChecked)
    {
        return S_FALSE;
    }

    if (!_pJScriptFactory)
    {
        LOCK_LOCALS(this);

        // Make sure another thread didn't take care of this while we were
        // waiting for the lock.

        if (!_fHackVersionChecked)
        {
            // Remember we've done this check so we won't do it again.
            _fHackVersionChecked = TRUE;

            // First, check the version number on the system DLL

            iRet = GetSystemDirectory(achDllPath, MAX_PATH);
            if (iRet == 0)
                goto Win32Error;

            _tcscat(achDllPath, _T("\\jscript.dll"));

            iRet = GetFileVersionInfoSize(achDllPath, &dwJunk);
            if (iRet == 0)
                goto Win32Error;

            pBuf = new BYTE[iRet];

            iRet = GetFileVersionInfo(achDllPath, NULL, iRet, pBuf);
            if (iRet == 0)
                goto Win32Error;

            if (!VerQueryValue(pBuf, _T("\\"), (LPVOID*)&pFI, &iLen))
                goto Win32Error;

            //
            // Is the system DLL a version that has our needed fix?
            //
            // Version 5.1.0.4702 has the fix but isn't approved for Win2K.
            // The first official version that has the fix is 5.5.0.4703.
            //
            if (   (pFI->dwProductVersionMS == 0x00050001 && pFI->dwProductVersionLS >= 4702)
                || (pFI->dwProductVersionMS >= 0x00050005 && pFI->dwProductVersionLS >= 4703))
            {
                hr = S_FALSE;

                goto Cleanup;
            }

            iRet = GetModuleFileName(NULL, achDllPath, MAX_PATH);
            if (iRet == 0)
                goto Win32Error;

            pch = _tcsrchr(achDllPath, _T('\\'));
            if (pch)
            {
                *pch = _T('\0');
            }

            _tcscat(achDllPath, _T("\\jscript.dll"));

            hInstDll = CoLoadLibrary(achDllPath, TRUE);
            if (!hInstDll)
            {

                hr = HRESULT_FROM_WIN32(GetLastError());

                ErrorPopup(_T("Your copy of JSCRIPT.DLL contains a problem which may prevent you from using this tool.\n")
                           _T("Please update that DLL to version 5.1.0.4702 or later.\n")
                           _T("You may put the new DLL in the same directory as mtscript.exe to avoid upgrading the system DLL."));

                // ErrorPopup clears the GetLastError() status.
                goto Cleanup;
            }

            pfnGCO = (LPFNGETCLASSOBJECT)GetProcAddress(hInstDll, "DllGetClassObject");
            if (!pfnGCO)
                goto Win32Error;

            hr = (*pfnGCO)(clsid, IID_IClassFactory, (LPVOID*)&_pJScriptFactory);
            if (hr)
                goto Cleanup;
        }
    }

    if (_pJScriptFactory)
        hr = _pJScriptFactory->CreateInstance(pUnk, riid, ppv);
    else
        hr = S_FALSE;

Cleanup:
    delete [] pBuf;

    return hr;

Win32Error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::ConfigureUI, public
//
//  Synopsis:   Creates our hidden window and puts an icon on the taskbar
//
//----------------------------------------------------------------------------

BOOL
CMTScript::ConfigureUI()
{
    VERIFY_THREAD();

    WNDCLASS       wc = { 0 };
    NOTIFYICONDATA ni = { 0 };
    ATOM           aWin;
    BOOL           fRet;

    // The window will be a hidden window so we don't set many of the attributes

    wc.lpfnWndProc   = MainWndProc;
    wc.hInstance     = g_hInstance;
    wc.lpszClassName = SZ_WNDCLASS;

    aWin = RegisterClass(&wc);
    if (aWin == 0)
    {
        return FALSE;
    }

    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                           (LPTSTR)aWin,
                           g_szWindowName,
                           WS_OVERLAPPED,
                           10,  // Coordinates don't matter - it will never
                           10,  //   be visible.
                           10,
                           10,
                           NULL,
                           NULL,
                           g_hInstance,
                           (LPVOID)this);
    if (_hwnd == NULL)
    {
        return FALSE;
    }

    ni.cbSize = sizeof(NOTIFYICONDATA);
    ni.hWnd   = _hwnd;
    ni.uID    = 1;
    ni.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    ni.uCallbackMessage = WM_USER;
    ni.hIcon  = LoadIcon(g_hInstance, L"myicon_small");
    wcscpy(ni.szTip, L"Remote Script Engine");

    fRet = Shell_NotifyIcon(NIM_ADD, &ni);

    DestroyIcon(ni.hIcon);

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::CleanupUI, public
//
//  Synopsis:   Cleans up UI related things.
//
//----------------------------------------------------------------------------

void
CMTScript::CleanupUI()
{
    VERIFY_THREAD();

    NOTIFYICONDATA ni = { 0 };

    if (_hwnd != NULL)
    {
        ni.cbSize = sizeof(NOTIFYICONDATA);
        ni.hWnd   = _hwnd;
        ni.uID    = 1;

        Shell_NotifyIcon(NIM_DELETE, &ni);

        DestroyWindow(_hwnd);
    }
}

HRESULT
CMTScript::LoadTypeLibraries()
{
    VERIFY_THREAD();
    HRESULT hr = S_OK;

    _pTIMachine = NULL;

    if (!_pTypeLibEXE)
    {
        hr = THR(LoadRegTypeLib(LIBID_MTScriptEngine, 1, 0, 0, &_pTypeLibEXE));

        if (hr)
            goto Cleanup;
    }

    if (!_pTIMachine)
    {
        TYPEATTR *pTypeAttr;
        UINT mb = IDYES;

        hr = THR(_pTypeLibEXE->GetTypeInfoOfGuid(IID_IConnectedMachine, &_pTIMachine));
        if (hr)
            goto Cleanup;

        hr = THR(_pTIMachine->GetTypeAttr(&pTypeAttr));
        if (hr)
            goto Cleanup;

        if (pTypeAttr->wMajorVerNum != IConnectedMachine_lVersionMajor || pTypeAttr->wMinorVerNum != IConnectedMachine_lVersionMinor)
        {
            mb = PrintfMessageBox(NULL,
                                       L"Mtscript.exe version (%d.%d) does not match mtlocal.dll (%d.%d).\n"
                                       L"You may experience undefined behavior if you continue.\n"
                                       L"Do you wish to ignore this error and continue?",
                                       L"Version mismatch error",
                                       MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND | MB_DEFBUTTON2,
                                       IConnectedMachine_lVersionMajor, IConnectedMachine_lVersionMinor,
                                       pTypeAttr->wMajorVerNum, pTypeAttr->wMinorVerNum);
        }
        _pTIMachine->ReleaseTypeAttr(pTypeAttr);
        if (mb != IDYES)
            return E_FAIL;
    }
Cleanup:

    if (hr)
    {
        PrintfMessageBox(NULL,
                         _T("FATAL: Could not load type library (%x).\nIs mtlocal.dll registered?"),
                         _T("MTScript"),
                         MB_OK | MB_ICONERROR | MB_SETFOREGROUND,
                         hr);
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::ShowMenu, public
//
//  Synopsis:   Displays a menu when the user right-clicks on the tray icon.
//
//  Arguments:  [x] -- x location
//              [y] -- y location
//
//----------------------------------------------------------------------------

void
CMTScript::ShowMenu(int x, int y)
{
    VERIFY_THREAD();

    ULONG ulItem;

    HMENU hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU));

    if (x == -1 && y == -1)
    {
        POINT pt;

        GetCursorPos(&pt);

        x = pt.x;
        y = pt.y;
    }

    SetForegroundWindow(_hwnd);

    ulItem = TrackPopupMenuEx(GetSubMenu(hMenu, 0),
                              TPM_RETURNCMD |
                              TPM_NONOTIFY  |
                              TPM_RIGHTBUTTON |
                              TPM_LEFTALIGN,
                              x, y,
                              _hwnd,
                              NULL);
    switch (ulItem)
    {
    case IDM_EXIT:
        UpdateOptionSettings(true);
        PostQuitMessage(0);
        break;

    case IDM_CONFIGURE:
        {
            CConfig * pConfig = new CConfig(this);

            if (pConfig)
            {
                pConfig->StartThread(NULL);

                pConfig->Release();
            }
        }
        break;

    case IDM_RESTART:
        Restart();

        break;

    case IDM_STATUS:
        if (!_pStatusDialog)
            OpenStatusDialog();
        if (_pStatusDialog)
            _pStatusDialog->Show();
        break;

#if DBG == 1
    case IDM_TRACETAG:
        DbgExDoTracePointsDialog(FALSE);
        break;

    case IDM_MEMORYMON:
        DbgExOpenMemoryMonitor();
        break;
#endif
    }

    DestroyMenu(hMenu);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::HandleThreadMessage, public
//
//  Synopsis:   Another thread has sent us a cross-thread message that we need
//              to handle.
//
//----------------------------------------------------------------------------

void
CMTScript::HandleThreadMessage()
{
    VERIFY_THREAD();

    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;

    while (GetNextMsg(&tm, (void *)bData, &cbData))
    {
        switch (tm)
        {
        case MD_SECONDARYSCRIPTTERMINATE:
            {
                //
                // A secondary script ended.  Find it in our list, remove it,
                // and delete it.
                //
                CScriptHost *pbs = *(CScriptHost**)bData;

                LOCK_LOCALS(this);
                Verify(_aryScripts.DeleteByValue(pbs));

                pbs->Release();
            }
            break;

        case MD_MACHINECONNECT:
            PostToThread(GetPrimaryScript(), MD_MACHINECONNECT);
            break;

        case MD_SENDTOPROCESS:
            {
                MACHPROC_EVENT_DATA *pmed = *(MACHPROC_EVENT_DATA**)bData;

                CProcessThread *pProc = FindProcess(pmed->dwProcId);

                if (pProc && pProc->GetProcComm())
                {
                    pProc->GetProcComm()->SendToProcess(pmed);
                }
                else
                {
                    V_VT(pmed->pvReturn) = VT_I4;
                    V_I4(pmed->pvReturn) = -1;
                    SetEvent(pmed->hEvent);
                }
            }
            break;

        case MD_REBOOT:
            Reboot();
            break;

        case MD_RESTART:
            Restart();
            break;

        case MD_PLEASEEXIT:
            PostQuitMessage(0);
            break;
        case MD_OUTPUTDEBUGSTRING:
            if (_pStatusDialog)
            {
                _pStatusDialog->OUTPUTDEBUGSTRING( (LPWSTR) bData);
            }
            break;
        default:
            AssertSz(FALSE, "CMTScript got a message it couldn't handle!");
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::RunScript, public
//
//  Synopsis:   Creates a scripting thread and runs a given script
//              Can be called from any thread.
//
//  Arguments:  [pszPath] -- If NULL, we're starting the primary thread.
//                           Otherwise, it's the name of a file in the
//                           scripts directory.
//
//----------------------------------------------------------------------------

HRESULT
CMTScript::RunScript(LPWSTR pszPath, VARIANT *pvarParam)
{
    HRESULT hr;
    CScriptHost * pScript = NULL;
    CStr             cstrScript;
    SCRIPT_PARAMS    scrParams;

    if (!pszPath)
        _options.GetInitScript(&cstrScript);
    else
        cstrScript.Set(pszPath);

    AssertSz(cstrScript.Length() > 0, "CRASH: Bogus script path");

    pScript = new CScriptHost(this,
                              (pszPath) ? FALSE : TRUE,
                              FALSE);
    if (!pScript)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    scrParams.pszPath    = cstrScript;
    scrParams.pvarParams = pvarParam;

    // Race: We can successfully start a thread.
    //       That thread can run to completion, and exit.
    //       CScriptHost would then post MD_SECONDARYSCRIPTTERMINATE
    //       in an attempt to remove the script from the list and free
    //       it.
    //       Thus, we must add it to the list first, then remove it
    //       if the script fails to start.
    {
        LOCK_LOCALS(this);
        _aryScripts.Append(pScript);
    }
    hr = pScript->StartThread(&scrParams);
    if (FAILED(hr) && pszPath) // DO NOT REMOVE THE PRIMARY SCRIPT! Instead, return SUCCESS.
    {                          // The main thread makes a special check for the primary script
        LOCK_LOCALS(this);
        Verify(_aryScripts.DeleteByValue(pScript));
        pScript->Release();
        goto Error;
    }
    Assert(pszPath || _aryScripts.Size() == 1);

    return S_OK;

Error:
    ReleaseInterface(pScript);
    if (pszPath == 0)
        ErrorPopup(L"An error occurred running the initial script");

    return hr;
}

HRESULT
CMTScript::UpdateOptionSettings(BOOL fSave)
{
    LOCK_LOCALS(&_options);   // Makes this method thread safe

    static REGKEYINFORMATION aKeyValuesOptions[] =
    {
        { _T("File Paths"),     RKI_KEY, 0 },
        { _T("Script Path"),    RKI_EXPANDSZ, offsetof(OPTIONSETTINGS, cstrScriptPath) },
        { _T("Initial Script"), RKI_STRING, offsetof(OPTIONSETTINGS, cstrInitScript) },
    };

    HRESULT hr;
    hr = RegSettingsIO(g_szRegistry, fSave, aKeyValuesOptions, ARRAY_SIZE(aKeyValuesOptions), (BYTE *)&_options);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::Restart, public
//
//  Synopsis:   Restarts like we were just starting
//
//  Notes:      All currently running scripts are stopped and destroyed.
//              Public information is freed and then everything is restarted.
//
//----------------------------------------------------------------------------

void
CMTScript::Restart()
{
    int i;

    // Make sure the status dialog doesn't try to do anything while we're
    // restarting.

    if (_pStatusDialog)
        _pStatusDialog->Pause();

    // Kill all running scripts and start over.
    for (i = _aryScripts.Size() - 1; i >= 0; i--)
    {
        Shutdown(_aryScripts[i]);

        // Scripts will be released when they notify us of their being
        // shutdown.
    }

    // Kill all running processes
    for (i = _aryProcesses.Size() - 1; i >= 0; i--)
    {
        Shutdown(_aryProcesses[i]);
    }
    _aryProcesses.ReleaseAll();

    if (_dwPublicDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPublicDataCookie);
        _dwPublicDataCookie = 0;
    }

    if (_dwPrivateDataCookie != 0)
    {
        _pGIT->RevokeInterfaceFromGlobal(_dwPrivateDataCookie);
        _dwPrivateDataCookie = 0;
    }

    VariantClear(&_vPublicData);
    VariantClear(&_vPrivateData);

    // Reset the statusvalues to 0
    memset(_rgnStatusValues, 0, sizeof(_rgnStatusValues));

    // The above call to shutdown will terminate the primary script thread,
    // which will trigger the restart code in ThreadMain().

    _fRestarting = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::OpenStatusDialog, public
//
//  Synopsis:   Opens the status modeless dialog
//
//----------------------------------------------------------------------------
void
CMTScript::OpenStatusDialog()
{
    if (!_pStatusDialog)
        _pStatusDialog = new CStatusDialog(_hwnd, this);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::Reboot, public
//
//  Synopsis:   Reboots the local machine. The user must have appropriate
//              rights to do so.
//
//----------------------------------------------------------------------------

void
CMTScript::Reboot()
{
    TOKEN_PRIVILEGES tp;
    LUID             luid;
    HANDLE           hToken;

    //
    // Try to make sure we get shutdown last
    //
    SetProcessShutdownParameters(0x101, 0);

    //
    // Setup shutdown priviledges
    //

    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES,
                          &hToken))
    {
        goto Error;
    }

    if (!LookupPrivilegeValue(NULL,
                              SE_SHUTDOWN_NAME,
                              &luid))
    {
        goto Error;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken,
                          FALSE,
                          &tp,
                          sizeof(TOKEN_PRIVILEGES),
                          (PTOKEN_PRIVILEGES) NULL,
                          (PDWORD) NULL);

    if (GetLastError() != ERROR_SUCCESS)
        goto Error;

    PostQuitMessage(0);

    // BUGBUG -- This call is Windows2000 specific.

    ExitWindowsEx(EWX_REBOOT | EWX_FORCEIFHUNG, 0xFFFF);

    return;

Error:
    TraceTag((tagError, "Failed to get security to reboot."));
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::AddProcess, public
//
//  Synopsis:   Adds a process to our process thread list. Any old ones
//              hanging around are cleaned up in the meantime.
//
//  Arguments:  [pProc] -- New process object to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CMTScript::AddProcess(CProcessThread *pProc)
{
    LOCK_LOCALS(this);

    CleanupOldProcesses();

    return _aryProcesses.Append(pProc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::FindProcess, public
//
//  Synopsis:   Returns a process object for the given process ID.
//
//  Arguments:  [dwProcID] -- Process ID to find
//
//----------------------------------------------------------------------------

CProcessThread *
CMTScript::FindProcess(DWORD dwProcID)
{
    CProcessThread **ppProc;
    int              cProcs;

    LOCK_LOCALS(this);

    CleanupOldProcesses();

    for (ppProc = _aryProcesses, cProcs = _aryProcesses.Size();
         cProcs;
         ppProc++, cProcs--)
    {
        if ((*ppProc)->ProcId() == dwProcID)
        {
            break;
        }
    }

    if (cProcs == 0)
    {
        return NULL;
    }

    return *ppProc;
}

BOOL CMTScript::SetScriptPath(const TCHAR *pszScriptPath, const TCHAR *pszInitScript)
{
    LOCK_LOCALS(&_options);

    // If there is any change then prompt the user, then force a restart.
    //
    // NOTE: The CStr "class" does not protect itself, so we must test it
    //       first before using it!
    //
    if ( (_options.cstrScriptPath == 0 || _tcscmp(pszScriptPath, _options.cstrScriptPath) != 0) ||
        (_options.cstrInitScript == 0 || _tcscmp(pszInitScript, _options.cstrInitScript) != 0))
    {
        if (!_fRestarting)
        {
            UINT mb = MessageBox(NULL, L"This will require a restart. Continue?", L"Changing script path or starting script", MB_OKCANCEL | MB_ICONWARNING | MB_SETFOREGROUND);
            if (mb == IDCANCEL)
                return FALSE;
        }
        _options.cstrScriptPath.Set(pszScriptPath);
        _options.cstrInitScript.Set(pszInitScript);
        // Write it out to the registry.
        UpdateOptionSettings(TRUE);
        if (!_fRestarting)
            PostToThread(this, MD_RESTART);
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::CleanupOldProcesses, public
//
//  Synopsis:   Walks the array of process objects and looks for ones that
//              have been dead for more than a specified amount of time. For
//              those that are, the objects are freed.
//
//  Notes:      Assumes that the caller has already locked the process array.
//
//----------------------------------------------------------------------------

const ULONG MAX_PROCESS_DEADTIME = 5 * 60 * 1000; // Cleanup after 5 minutes

void
CMTScript::CleanupOldProcesses()
{
    int i;

    //$ CONSIDER: Adding a max number of dead processes as well.

    // We assume that the process array is already locked (via LOCK_LOCALS)!

    // Iterate in reverse order since we'll be removing elements as we go.

    for (i = _aryProcesses.Size() - 1; i >= 0; i--)
    {
        if (_aryProcesses[i]->GetDeadTime() > MAX_PROCESS_DEADTIME)
        {
            _aryProcesses.ReleaseAndDelete(i);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::GetScriptNames, public
//
//  Synopsis:   Walks the array of scripts, copying the script names
//              into the supplied buffer.
//              Each name is null terminated. The list is double null terminated.
//              If the buffer is not large enough, then *pcBuffer
//              is set the the required size and FALSE is returned.
//
//  Notes:      Returns 0 if index is past end of array of scripts.
//
//----------------------------------------------------------------------------
BOOL
CMTScript::GetScriptNames(TCHAR *pchBuffer, long *pcBuffer)
{
    VERIFY_THREAD();
    LOCK_LOCALS(this);
    long nChars = 0;
    int i;
    TCHAR *pch = pchBuffer;
    for(i = 0; i < _aryScripts.Size(); ++i)
    {
        TCHAR *ptr = _T("<invalid>");
        CScriptSite *site = _aryScripts[i]->GetSite();
        if (site)
        {
            ptr = _tcsrchr((LPTSTR)site->_cstrName, _T('\\'));
            if (!ptr)
                ptr = (LPTSTR)site->_cstrName;
        }
        int n = _tcslen(ptr) + 1;
        nChars += n;
        if ( nChars + 1 < *pcBuffer)
        {
            _tcscpy(pch, ptr);
            pch += n;
        }
        *pch = 0; // double null terminator.
    }
    BOOL retval = nChars + 1 < *pcBuffer;
    *pcBuffer = nChars + 1; // double null termination
    return retval;
}


//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::GetPrimaryScript, public
//
//  Synopsis:   Returns the first script in the array
//
//----------------------------------------------------------------------------
CScriptHost *CMTScript::GetPrimaryScript()
{
    LOCK_LOCALS(this);
    return _aryScripts[0];
}
//+---------------------------------------------------------------------------
//
//  Member:     CMTScript::GetProcess, public
//
//  Synopsis:   Walks the array of processes
//
//  Notes:      Returns 0 if index is past end of array of processes.
//
//----------------------------------------------------------------------------
CProcessThread *
CMTScript::GetProcess(int index)
{
    VERIFY_THREAD();

    LOCK_LOCALS(this);

    if (index < 0 || index >= _aryProcesses.Size())
        return 0;

    return _aryProcesses[index];
}



//+---------------------------------------------------------------------------
//
//  Function:   MainWndProc
//
//  Synopsis:   Main window procedure for our hidden window. Used mainly to
//              handle context menu events on our tray icon.
//
//----------------------------------------------------------------------------

LRESULT CALLBACK
MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static CMTScript *s_pMT = NULL;

    switch (msg)
    {
    case WM_CREATE:
        {
            CREATESTRUCT UNALIGNED *pcs = (CREATESTRUCT *)lParam;

            s_pMT = (CMTScript *)pcs->lpCreateParams;
        }
        return 0;

    case WM_USER:
        switch (lParam)
        {
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_CONTEXTMENU:
            if (s_pMT)
            {
                s_pMT->ShowMenu(-1, -1);
            }
            return 0;
        }
        return 0;

    case WM_COMMAND:
        return 0;
        break;

    case WM_LBUTTONDOWN:
        return 0;
        break;

    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------------------
//
//  Function:   get_StatusValue
//
//  Synopsis:   Return the value at [nIndex] in the StatusValues array
//              Currently the implementation of this property has a small
//              limit to the range of "nIndex".
//              This allows us to avoid any dynamic memory allocation
//              and also allows us to dispense with the usual thread locking.
//
//----------------------------------------------------------------------------
HRESULT
CMTScript::get_StatusValue(long nIndex, long *pnStatus)
{
    if (!pnStatus)
        return E_POINTER;

    if (nIndex < 0 || nIndex >= ARRAY_SIZE(_rgnStatusValues))
        return E_INVALIDARG;

    *pnStatus = _rgnStatusValues[nIndex];

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   put_StatusValue
//
//  Synopsis:   Set the value at [nIndex] in the StatusValues array
//
//----------------------------------------------------------------------------
HRESULT
CMTScript::put_StatusValue(long nIndex, long nStatus)
{
    if (nIndex < 0 || nIndex >= ARRAY_SIZE(_rgnStatusValues))
        return E_INVALIDARG;

    _rgnStatusValues[nIndex] = nStatus;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\cstr.h ===
//-----------------------------------------------------------------------------
//
// Microsoft Forms
// Copyright: (c) 1994-1995, Microsoft Corporation
// All rights Reserved.
// Information contained herein is Proprietary and Confidential.
//
// File         CSTR.HXX
//
// Contents     Class definition for length prefix string class
//
// Classes      CStr
//
// Stolen from Trident
//
//-----------------------------------------------------------------------------

class ANSIString
{
public:
    ANSIString(WCHAR *pchWide);
   ~ANSIString() { delete _pch; }

    void Set(WCHAR *pchWide);

    operator LPSTR () const { return _pch; }

private:
    char *_pch;
};

/*
    Use this macro to avoid initialization of embedded
    objects when parent object zeros out the memory
*/

#define CSTR_NOINIT ((float)0.0)

/*
    This class defines a length prefix 0 terminated string object. It points
    to the beginning of the characters so the pointer returned can be used in
    normal string operations taking into account that of course that it can
    contain any binary value.
*/

class CStr
{
public:

    DECLARE_MEMALLOC_NEW_DELETE()

    /*
        Default constructor
    */
    CStr()
    {
        _pch = 0;
    }

    /*
        Special constructor to AVOID construction for embedded
        objects...
    */
    CStr(float num)
    {
        Assert(_pch == 0);
    }
    /*
        Destructor will free data
    */
    ~CStr()
    {
        _Free();
    }

    operator LPTSTR () const { return _pch; }
    HRESULT Set(LPCTSTR pch);
    HRESULT Set(LPCTSTR pch, UINT uc);

    HRESULT SetMultiByte(LPCSTR pch);
    HRESULT GetMultiByte(LPSTR pch, UINT cch);

    HRESULT SetBSTR(const BSTR bstr);

    HRESULT Set(const CStr &cstr);

    void    TakeOwnership(CStr &cstr);
    UINT    Length() const;

    // Update the internal length indication without changing any allocation.

    HRESULT SetLengthNoAlloc( UINT uc );

    // Reallocate the string to a larger size, length unchanged.

    HRESULT ReAlloc( UINT uc );

    HRESULT Append(LPCTSTR pch);
    HRESULT Append(LPCTSTR pch, UINT uc);
    HRESULT AppendMultiByte(LPCSTR pch);

    void Free()
    {
        _Free();
        _pch = 0;
    }

    TCHAR * TakePch() { TCHAR * pch = _pch; _pch = NULL; return(pch); }

    HRESULT AllocBSTR(BSTR *pBSTR) const;

    HRESULT TrimTrailingWhitespace();

private:
    void    _Free();
    LPTSTR  _pch;
    NO_COPY(CStr);

public:
    HRESULT Clone(CStr **ppCStr) const;
    BOOL    Compare (const CStr *pCStr) const;
    WORD    ComputeCrc() const;
    BOOL    IsNull(void) const { return _pch == NULL ? TRUE : FALSE; }
    HRESULT Save(IStream * pstm) const;
    HRESULT Load(IStream * pstm);
    ULONG   GetSaveSize() const;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\dispid.h ===
#define DISPID_MTScript_ScriptMain           100
#define DISPID_MTScript_OnMachineConnect     101
#define DISPID_MTScript_OnMachineDisconnect  102
#define DISPID_MTScript_OnRemoteExec         103
#define DISPID_MTScript_OnScriptError        104

#define DISPID_MTScript_OnProcessEvent       200
#define DISPID_MTScript_OnEventSourceEvent   201

#define DISPID_MTScript_OnMessageBoxInterval 300

#define DISPID_RemoteMTScript_OnScriptNotify 400
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\empty.cxx ===
#include "comhdr.hxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\f3debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
// File:      F3DEBUG.H
//
// Contains:  Debugging stuff -- uses MSHTML's mshtmdbg.dll for debugging
//            utilities.
//
//            Stolen from Trident
//
//--------------------------------------------------------------------------

#include <mshtmdbg.h>

//--------------------------------------------------------------------------
// Assert, Verify && WHEN_DBG
//--------------------------------------------------------------------------

#if defined(_M_IX86)
    #define F3DebugBreak() _asm { int 3 }
#else
    #define F3DebugBreak() DebugBreak()
#endif

#if DBG != 1

#define Verify(x)   x
#define Assert(x)
#define AssertSz(x, sz)
#define IF_DBG(x)
#define WHEN_DBG(x)
#define IF_NOT_DBG(x) x
#define WHEN_NOT_DBG(x) x
#define StartupAssert(x)
#define AssertThreadDisable(fb)


#else // #if DBG != 1

#define AssertThreadDisable(fDisable)   DbgExAssertThreadDisable(fDisable)

extern DWORD g_dwFALSE;

#define Verify(x)       Assert(x)
#define Assert(x)       do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, #x))\
                               F3DebugBreak(); } while (g_dwFALSE)

#define AssertSz(x, sz) do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(__FILE__, __LINE__, sz))\
                               F3DebugBreak(); } while (g_dwFALSE)

#define AssertLocSz(x, File, Line, sz)   do { if (!((DWORD_PTR)(x)|g_dwFALSE) && DbgExAssertImpl(File, Line, sz))\
                               F3DebugBreak(); } while (g_dwFALSE)
#define IF_DBG(x) x
#define WHEN_DBG(x) x
#define IF_NOT_DBG(x)
#define WHEN_NOT_DBG(x)


#define concat_name(x, y) x##y
#define concat_line_impl(x, y) concat_name(x, y)
#define concat_LINE(x) concat_line_impl(x, __LINE__)

//
// Startup assertion:
// The assertion is called by initializing a global variable with
// a function that performs the assertion and returns 1. The name
// of the global variable and function name are suffixed with the
// line number to make them unique. Unfortunatly, one cannot just
// write StartupAssert_##__LINE__, because __LINE__ is not an
// argument to the macro and so the expansion is, e.g. StartupAssert__##53.
// So we indirect through another macro which concatenates its
// two arguments.
//

#define StartupAssert(x)                                                    \
static int                                                                  \
concat_LINE(StartupAssert_) ()                                              \
{                                                                           \
    Assert(x);                                                              \
    return 1;                                                               \
}                                                                           \
                                                                            \
static int concat_LINE(g_StartupAssert_) = concat_LINE(StartupAssert_)()    \

#endif // #if DBG != 1

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

#if DBG != 1
    #define TraceTag(x)
    #define TraceTagEx(x)
    #define TaggedTraceListEx(tag, usFlags, szFmt, valMarker)
    #define TraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescription)
    #define DeclareTagOther(tag, szOwner, szDescription)
    #define ExternTag(tag)
    #define IsTagEnabled(tag) FALSE
    #define EnableTag(tag, fEnable)
    #define SetDiskFlag(tag, fSendToDisk)
    #define SetBreakFlag(tag, fBreak)
    #define FindTag(szTagDesc) NULL
    #define PerfDbgTag(tag, szOwner, szDescrip) \
            PerfTag(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) \
            PerfExtern(tag)
    #define PerfDbgLog(tag,pv,f) PerfLog(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfLog1(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfLog2(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfLog3(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfLog4(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfLogFn x
    #define IsPerfDbgEnabled(tag) IsPerfEnabled(tag)

#else
    #define TraceTag(x)                         \
        do                                      \
        {                                       \
            if (TaggedTrace x)                  \
                F3DebugBreak();                 \
        } while  (g_dwFALSE)

    #define TraceTagEx(x)                       \
        do                                      \
        {                                       \
            if (TaggedTraceEx x)                \
                F3DebugBreak();                 \
        } while  (g_dwFALSE)

    #define TraceCallers(tag, iStart, cTotal)   \
        TaggedTraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterTrace(szOwner, szDescrip, FALSE));
    #define DeclareTagOther(tag, szOwner, szDescrip) \
        TRACETAG tag(DbgExTagRegisterOther(szOwner, szDescrip, FALSE));
    #define ExternTag(tag) extern TRACETAG tag;
    #define PerfDbgTag(tag, szOwner, szDescrip) DeclareTag(tag, szOwner, szDescrip)
    #define PerfDbgExtern(tag) ExternTag(tag)
    #define PerfDbgLog(tag,pv,f) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) if (IsPerfDbgEnabled(tag)) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfDbgLogFn x
    #define IsPerfDbgEnabled(tag) IsTagEnabled(tag)

    int __cdecl PerfDbgLogFn(int tag, void * pvObj, char * pchFmt, ...);

    // Tag trace functions

    #define TaggedTrace         DbgExTaggedTrace
    #define TaggedTraceEx       DbgExTaggedTraceEx
    #define TaggedTraceListEx   DbgExTaggedTraceListEx
    #define TaggedTraceCallers  DbgExTaggedTraceCallers

    // TaggedTraceEx usFlags parameter defines

    #define TAG_NONAME      0x01
    #define TAG_NONEWLINE   0x02
    #define TAG_USECONSOLE  0x04
    #define TAG_INDENT      0x08
    #define TAG_OUTDENT     0x10

    // Register a new tag.

    // Standard tags
    #define tagError                DbgExTagError()
    #define tagWarning              DbgExTagWarning()
    #define tagThread               DbgExTagThread()
    #define tagAssertExit           DbgExTagAssertExit()
    #define tagAssertStacks         DbgExTagAssertStacks()
    #define tagMemoryStrict         DbgExTagMemoryStrict()
    #define tagCoMemoryStrict       DbgExTagCoMemoryStrict()
    #define tagMemoryStrictTail     DbgExTagMemoryStrictTail()
    #define tagMemoryStrictAlign    DbgExTagMemoryStrictAlign()
    #define tagOLEWatch             DbgExTagOLEWatch()
    #define tagPerf                 DbgExTagPerf()

    // Get/Set tag enabled status.

    #define IsTagEnabled            DbgExIsTagEnabled
    #define EnableTag               DbgExEnableTag
    #define SetDiskFlag             DbgExSetDiskFlag
    #define SetBreakFlag            DbgExSetBreakFlag
    #define FindTag                 DbgExFindTag

#endif

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#if DBG != 1

    #define DbgPreAlloc(cb)             cb
    #define DbgPostAlloc(pv)            pv
    #define DbgPreFree(pv)              pv
    #define DbgPostFree()
    #define DbgPreRealloc(pv, cb, ppv)  cb
    #define DbgPostRealloc(pv)          pv
    #define DbgPreGetSize(pv)           pv
    #define DbgPostGetSize(cb)          cb
    #define DbgPreDidAlloc(pv)          pv
    #define DbgPostDidAlloc(pv, fAct)   fAct

    #define DbgMemoryTrackDisable(fb)
    #define DbgCoMemoryTrackDisable(fb)
    #define DbgMemoryBlockTrackDisable(pv)

    #define CHECK_HEAP()

#else

    #define DbgPreAlloc                 DbgExPreAlloc
    #define DbgPostAlloc                DbgExPostAlloc
    #define DbgPreFree                  DbgExPreFree
    #define DbgPostFree                 DbgExPostFree
    #define DbgPreRealloc               DbgExPreRealloc
    #define DbgPostRealloc              DbgExPostRealloc
    #define DbgPreGetSize               DbgExPreGetSize
    #define DbgPostGetSize              DbgExPostGetSize
    #define DbgPreDidAlloc              DbgExPreDidAlloc
    #define DbgPostDidAlloc             DbgExPostDidAlloc

    #define DbgMemoryTrackDisable       DbgExMemoryTrackDisable
    #define DbgCoMemoryTrackDisable     DbgExCoMemoryTrackDisable
    #define DbgMemoryBlockTrackDisable  DbgExMemoryBlockTrackDisable

    //
    // Use the CHECK_HEAP macro to do thorough heap validation.
    //
    BOOL CheckSmallBlockHeap();
    #define CHECK_HEAP()    Assert(DbgExValidateInternalHeap() && CheckSmallBlockHeap() && "Corrupted heap!")

#endif


//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#if DBG == 1 && !defined(WIN16)
    #define DbgTrackItf     DbgExTrackItf
#else
    #define DbgTrackItf(iid, pch, fTrackOnQi, ppv)
#endif

//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#if DBG == 1 && defined(__cplusplus)

#define SetSimFailCounts    DbgExSetSimFailCounts
#define GetFailCount        DbgExGetFailCount
#define TraceFailL          DbgExTraceFailL
#define TraceWin32L         DbgExTraceWin32L
#define TraceHR             DbgExTraceHR
#define TraceOLE            DbgExTraceOLE
#define TraceEnter          DbgExTraceEnter
#define TraceExit           DbgExTraceExit

template <class t> inline t
TraceFail(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceFailL((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

template <class t> inline t
TraceWin32(t errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) DbgExTraceWin32L((LONG_PTR) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

// disabled TraceEnter, we don't need it at this time
#undef TraceEnter
#define TraceEnter(x, y, z) NULL

#define TFAIL(e, x)             (TraceEnter(#x, __FILE__, __LINE__), TraceFail( (x), (e), FALSE, #x, __FILE__, __LINE__))
#define TW32(e, x)              (TraceEnter(#x, __FILE__, __LINE__), TraceWin32((x), (e), FALSE, #x, __FILE__, __LINE__))
#define THR(x)                  (TraceEnter(#x, __FILE__, __LINE__), TraceHR((x), FALSE, #x, __FILE__, __LINE__))

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (TraceEnter(#x, __FILE__, __LINE__), (void) TraceFail((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_W32(e,x)         (TraceEnter(#x, __FILE__, __LINE__), (void) TraceWin32((x), (e), TRUE, #x, __FILE__, __LINE__))
#define IGNORE_HR(x)            (TraceEnter(#x, __FILE__, __LINE__), (void) TraceHR((x), TRUE, #x, __FILE__, __LINE__))

#else // #if DBG == 1

#define SetSimFailCounts(firstFailure, cInterval)

#define TFAIL(e, x)             (x)
#define TW32(e, x)              (x)
#define THR(x)                  (x)

#define TFAIL_NOTRACE(e, x)     (x)
#define TW32_NOTRACE(e, x)      (x)
#define THR_NOTRACE(x)          (x)

#define IGNORE_FAIL(e, x)       (x)
#define IGNORE_W32(e,x)         (x)
#define IGNORE_HR(x)            (x)

#endif // #if DBG == 1

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#if DBG == 1

    #define SRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, -1)
    #define RRETURN(hr) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 0)
    #define RRETURN1(hr, s1) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

    #define SRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, -1)
    #define RRETURN_NOTRACE(hr) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 0)
    #define RRETURN1_NOTRACE(hr, s1) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2_NOTRACE(hr, s1, s2) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3_NOTRACE(hr, s1, s2, s3) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 3, (s1), (s2), (s3))
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4) \
        return DbgExCheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 4, (s1), (s2), (s3), (s4))

#else   // DBG == 0

    #define SRETURN(hr)                 return (hr)
    #define RRETURN(hr)                 return (hr)
    #define RRETURN1(hr, s1)            return (hr)
    #define RRETURN2(hr, s1, s2)        return (hr)
    #define RRETURN3(hr, s1, s2, s3)    return (hr)
    #define RRETURN4(hr, s1, s2, s3, s4)return (hr)

    #define SRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN1_NOTRACE(hr, s1)            return (hr)
    #define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
    #define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)
    #define RRETURN4_NOTRACE(hr, s1, s2, s3, s4)return (hr)

#endif  // DBG

//+-------------------------------------------------------------------------
//  Stack Spew
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
EXTERN_C void InitChkStk(DWORD);
#pragma check_stack(on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\localobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       localobj.h
//
//  Contents:   Contains class definitions of objects used in the remoteable
//              object proxy object.
//
//----------------------------------------------------------------------------

class CLocalMTProxy;

//+---------------------------------------------------------------------------
//
//  Class:      CMTLocalFactory
//
//  Purpose:    Standard implementation of a class factory.  This is meant
//              to be created as a global object and therefore does not
//              destroy itself when its refcount goes to zero.
//
//----------------------------------------------------------------------------

class CMTLocalFactory : public IClassFactory
{
public:
    CMTLocalFactory();
   ~CMTLocalFactory() {};

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void)
        {
            return InterlockedIncrement((long*)&_ulRefs);
        }
    STDMETHOD_(ULONG, Release) (void)
        {
            if (InterlockedDecrement((long*)&_ulRefs) == 0)
            {
                return 0;
            }
            return _ulRefs;
        }

    // IClassFactory methods

    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    ULONG  _ulRefs;
};

//+---------------------------------------------------------------------------
//
//  Class:      CMTEventSink (ces)
//
//  Purpose:    Class which sinks events from the remote object
//
//----------------------------------------------------------------------------

class CMTEventSink : public IDispatch
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CMTEventSink() { }
   ~CMTEventSink() { }

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

private:
    CLocalMTProxy* Proxy();
};

//+---------------------------------------------------------------------------
//
//  Class:      CLocalMTProxy (cm)
//
//  Purpose:    Contains all useful info about a machine and what it's
//              doing.
//
//  Notes:      This class is manipulated from multiple threads. All
//              member functions must be thread safe!
//
//              This is the class that is created by the class factory and
//              handed out as a remote object to other machines. It has no
//              real code in itself but merely provides a way to talk to the
//              already running script engines.
//
//----------------------------------------------------------------------------

class CLocalMTProxy : public IRemoteMTScriptProxy,
                      public IConnectionPointContainer,
                      public IProvideClassInfo
{
    friend class CLocalProxyCP;
    friend class CMTEventSink;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CLocalMTProxy();
   ~CLocalMTProxy();

    // IUnknown methods. Because we have a refcounted sub-object (our event
    // sink) we must do more complicated object lifetime stuff here.

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);
    STDMETHOD_(ULONG, AddRef) (void);
    STDMETHOD_(ULONG, Release) (void);
    ULONG SubAddRef (void);
    ULONG SubRelease (void);

    void Passivate(void);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    // IConnectionPointContainer methods

    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS*);
    STDMETHOD(FindConnectionPoint)(REFIID, LPCONNECTIONPOINT*);

    // IProvideClassInfo methods

    STDMETHOD(GetClassInfo)(ITypeInfo **pTI);

    // IRemoteMTScriptProxy interface

    STDMETHOD(Connect)(BSTR bstrMachine);
    STDMETHOD(Disconnect)();
    STDMETHOD(DownloadFile)(BSTR bstrURL, BSTR *bstrFile);

    HRESULT LoadTypeLibs();

private:
    DWORD _ulAllRefs;
    DWORD _ulRefs;

    ITypeLib *   _pTypeLibDLL;
    ITypeInfo *  _pTypeInfoInterface;
    ITypeInfo *  _pTypeInfoCM;

    IDispatch *  _pDispRemote;
    DWORD        _dwSinkCookie;
    CMTEventSink _cesSink;

    IDispatch*   _pDispSink;
};

inline CLocalMTProxy * CMTEventSink::Proxy()
{
    return CONTAINING_RECORD(this, CLocalMTProxy, _cesSink);
}

inline STDMETHODIMP_(ULONG)
CMTEventSink::AddRef(void)
{
    return Proxy()->SubAddRef();
}

inline STDMETHODIMP_(ULONG)
CMTEventSink::Release(void)
{
    return Proxy()->SubRelease();
}

//+---------------------------------------------------------------------------
//
//  Class:      CLocalProxyCP (mcp)
//
//  Purpose:    Implements IConnectionPoint for CLocalMTProxy
//
//----------------------------------------------------------------------------

class CLocalProxyCP : public IConnectionPoint
{
public:

    CLocalProxyCP(CLocalMTProxy *pMTP);
   ~CLocalProxyCP();

    DECLARE_STANDARD_IUNKNOWN(CLocalProxyCP);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CLocalMTProxy *_pMTProxy;
};

extern HINSTANCE g_hInstDll;
extern long g_lObjectCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\machine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       machine.h
//
//  Contents:   IConnectedMachine class definition
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Forward declarations
//
//****************************************************************************

class CMTScript;
class CScriptHost;

//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CMachine (cm)
//
//  Purpose:    Contains all useful info about a machine and what it's
//              doing.
//
//  Notes:      This class is manipulated from multiple threads. All
//              member functions must be thread safe!
//
//              This is the class that is created by the class factory and
//              handed out as a remote object to other machines. It has no
//              real code in itself but merely provides a way to talk to the
//              already running script engines.
//
//----------------------------------------------------------------------------

class CMachine : public CThreadComm,
                 public IConnectedMachine,
                 public IConnectionPointContainer
{
    friend class CMachConnectPoint;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CMachine(CMTScript *pMT, ITypeInfo *pTIMachine);
   ~CMachine();

    DECLARE_STANDARD_IUNKNOWN(CMachine);

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    // IConnectionPointContainer methods

    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS*);
    STDMETHOD(FindConnectionPoint)(REFIID, LPCONNECTIONPOINT*);

    // IConnectedMachine interface

    STDMETHOD(Exec)(BSTR bstrCmd, BSTR bstrParams, VARIANT *pvData);

    STDMETHOD(get_PublicData)(VARIANT *pvData);
    STDMETHOD(get_Name)(BSTR *pbstrName);
    STDMETHOD(get_Platform)(BSTR *pbstrPlat);
    STDMETHOD(get_OS)(BSTR *pbstrOS);
    STDMETHOD(get_MajorVer)(long *plMajorVer);
    STDMETHOD(get_MinorVer)(long *plMinorVer);
    STDMETHOD(get_BuildNum)(long *plBuildNum);
    STDMETHOD(get_PlatformIsNT)(VARIANT_BOOL *pfIsNT);
    STDMETHOD(get_ServicePack)(BSTR *pbstrSP);
    STDMETHOD(get_HostMajorVer)(long *plMajorVer);
    STDMETHOD(get_HostMinorVer)(long *plMajorVer);
    STDMETHOD(get_StatusValue)(long nIndex, long *pnStatus);

    HRESULT FireScriptNotify(BSTR bstrIdent, VARIANT vInfoF);

    #define LOCK_MACH_LOCALS(pObj)  CMachLock local_lock(pObj);

protected:
    virtual BOOL  Init();
    virtual DWORD ThreadMain();

    BOOL HandleThreadMessage();

private:
    class CMachLock
    {
    public:
        CMachLock(CMachine *pThis);
       ~CMachLock();

    private:
        CMachine *_pThis;
    };
    friend class CMachLock;

    CMTScript *                 _pMT;
    ITypeInfo *                 _pTypeInfoIMachine;

    CRITICAL_SECTION            _cs;
    CStackPtrAry<IDispatch*, 5> _aryDispSink;
};

inline
CMachine::CMachLock::CMachLock(CMachine *pThis)
    : _pThis(pThis)
{
    EnterCriticalSection(&_pThis->_cs);
}

inline
CMachine::CMachLock::~CMachLock()
{
    LeaveCriticalSection(&_pThis->_cs);
}


//+---------------------------------------------------------------------------
//
//  Class:      CMachConnectPoint (mcp)
//
//  Purpose:    Implements IConnectionPoint for CMachine
//
//----------------------------------------------------------------------------

class CMachConnectPoint : public IConnectionPoint
{
public:

    CMachConnectPoint(CMachine *pMach);
   ~CMachConnectPoint();

    DECLARE_STANDARD_IUNKNOWN(CMachConnectPoint);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CMachine *_pMachine;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\hostobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       hostobj.h
//
//  Contents:   Contains the main application object
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Forward declarations
//
//****************************************************************************

class CScriptHost;
class CMachine;
class CProcessThread;
class CStatusDialog;

//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CMTScript (cmt)
//
//  Purpose:    Class which runs the main thread for the process.
//
//----------------------------------------------------------------------------

#define MAX_STATUS_VALUES 16 // Maximum allowed StatusValue values.
class CMTScript : public CThreadComm
{
    friend int PASCAL WinMain(HINSTANCE hInstance,
                              HINSTANCE hPrevInstance,
                              LPSTR     lpCmdLine,
                              int       nCmdShow);

    friend LRESULT CALLBACK
           MainWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    friend class CConfig;

public:
    CMTScript();
   ~CMTScript();

    DECLARE_STANDARD_IUNKNOWN(CMTScript);

    // Script Debugging helpers
    IProcessDebugManager * _pPDM;
    IDebugApplication    * _pDA;
    DWORD                  _dwAppCookie;

    CScriptHost *GetPrimaryScript();
    CProcessThread *GetProcess(int index);
    BOOL GetScriptNames(TCHAR *pchBuffer, long *pcBuffer);

    // These methods are thread safe.

    HRESULT          AddProcess(CProcessThread *pProc);
    CProcessThread * FindProcess(DWORD dwProcId);
    HRESULT          get_StatusValue(long nIndex, long *pnStatus);
    HRESULT          put_StatusValue(long nIndex, long nStatus);

    // Hack function to work around JSCRIPT.DLL bug
    HRESULT          HackCreateInstance(REFCLSID, IUnknown *, DWORD, REFIID, LPVOID*);

    BOOL SetScriptPath(const TCHAR *pszScriptPath, const TCHAR *pszInitScript);

    BOOL            _fHackVersionChecked;
    IClassFactory * _pJScriptFactory;

    HRESULT RunScript(LPWSTR bstrPath, VARIANT *pvarParams);
protected:
    virtual BOOL  Init();
    virtual DWORD ThreadMain();

    void    InitScriptDebugger();
    void    DeInitScriptDebugger();
    BOOL    ConfigureUI();
    void    CleanupUI();
    HRESULT LoadTypeLibraries();

    void ShowMenu(int x, int y);
    void Reboot();
    void Restart();
    void OpenStatusDialog();
    void HandleThreadMessage();

    HRESULT UpdateOptionSettings(BOOL fSave);

    void CleanupOldProcesses();

private:
    BOOL _fInDestructor;
    BOOL _fRestarting;
    HWND _hwnd;
    CStatusDialog *_pStatusDialog;

public:
    struct OPTIONSETTINGS : public CThreadLock
    {
        OPTIONSETTINGS();

        static void GetModulePath(CStr *pstr);

        void GetScriptPath(CStr *cstrPage); // internally does a LOCK_LOCALS

        void GetInitScript(CStr *cstr); // internally does a LOCK_LOCALS

        CStr  cstrScriptPath;
        CStr  cstrInitScript;
    };

    ITypeLib              * _pTypeLibEXE;
    ITypeInfo             * _pTIMachine;
    IGlobalInterfaceTable * _pGIT;

    // _rgnStatusValues: Simple array of status values -- Multithreaded access, but no locking necessary
    long                    _rgnStatusValues[MAX_STATUS_VALUES];

    // ***************************
    //   THREAD-SAFE MEMBER DATA
    //   All access to the following members must be protected by LOCK_LOCALS()
    //   or InterlockedXXX.
    //
    OPTIONSETTINGS  _options;
    CMachine*       _pMachine;

    VARIANT         _vPublicData;
    VARIANT         _vPrivateData;

    DWORD           _dwPublicDataCookie;
    DWORD           _dwPrivateDataCookie;

    DWORD           _dwPublicSerialNum;
    DWORD           _dwPrivateSerialNum;

    CStackPtrAry<CScriptHost*, 10> _aryScripts;

    CStackPtrAry<CProcessThread*, 10> _aryProcesses;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\factory.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       factory.h
//
//  Contents:   Definition of the standard class factory class
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Class:      CStdFactory (csf)
//
//  Purpose:    Standard implementation of a class factory.
//
//----------------------------------------------------------------------------

class CStdFactory : public IClassFactory
{
public:
    typedef HRESULT (FNCREATE)(CMTScript *pMT, IUnknown **ppUnkObj);

    CStdFactory(CMTScript *pMT, FNCREATE *pfnCreate);
   ~CStdFactory() {};

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN(CStdFactory);

    // IClassFactory methods

    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    CMTScript * _pMT;
    FNCREATE  * _pfnCreate;
};

//+---------------------------------------------------------------------------
//
//  Struct:     REGCLASSDATA
//
//  Purpose:    Used to declare the classes we want to register with OLE.
//              A class factory that will create the class will be registered
//              for each entry.
//
//----------------------------------------------------------------------------

struct REGCLASSDATA
{
    const CLSID           *pclsid;    // CLSID to register
    CStdFactory::FNCREATE *pfnCreate; // Pointer to creation function
    DWORD                  ctxCreate; // CLSCTX to register this class with
    DWORD                  dwCookie;  // Cookie returned from CoRegister...
};


HRESULT RegisterClassObjects(CMTScript *pMT);
void    UnregisterClassObjects();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\dynary.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       formsary.hxx
//
//  Contents:   CImplAry* classes
//
//              Stolen from Trident
//
//----------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
// This is the implementation of the generic resizeable array classes. There
// are four array classes:
//
// CPtrAry<ELEM> --
//
//       Dynamic array class which is optimized for sizeof(ELEM) equal
//       to 4. The array is initially empty with no space or memory allocated
//       for data.
//
// CDataAry<ELEM> --
//
//       Same as CPtrAry but where sizeof(ELEM) is != 4 and less than 128.
//
// CStackPtrAry<ELEM, N> --
//
//       Dynamic array class optimized for sizeof(ELEM) equal to 4.
//       Space for N elements is allocated as member data of the class. If
//       this class is created on the stack, then space for N elements will
//       be created on the stack. The class can grow beyond N elements, at
//       which point memory will be allocated for the array data.
//
// CStackDataAry<ELEM, N> --
//
//       Same as CStackPtrAry, but where sizeof(ELEM) is != 4 and less than 128.
//
//
// All four classes have virtually the same methods, and are used the same.
// The only difference is that the DataAry classes have AppendIndirect and
// InsertIndirect, while the PtrAry classes use Append and Insert. The reason
// for the difference is that the Indirect methods take a pointer to the data,
// while the non-indirect methods take the actual data as an argument.
//
// The Stack arrays (CStackPtrAry and CStackDataAry) are used to pre-allocate
// space for elements in the array. This is useful if you create the array on
// the stack and you know that most of the time the array will be less than
// a certain number of elements. Creating one of these arrays on the stack
// allocates the array on the stack as well, preventing a separate memory
// allocation. Only if the array grows beyond the initial size will any
// additional memory be allocated.
//
// The fastest and most efficient way of looping through all elements in
// the array is as follows:
//
//            ELEM * pElem;
//            int    i;
//
//            for (i = aryElems.Size(), pElem = aryElems;
//                 i > 0;
//                 i--, pElem++)
//            {
//                (*pElem)->DoSomething();
//            }
//
// This loop syntax has been shown to be the fastest and produce the smallest
// code. Here's an example using a real data type:
//
//            CStackPtrAry<CSite*, 16> arySites;
//            CSite **ppSite;
//            int     i;
//
//            // Populate the array.
//            ...
//
//            // Now loop through every element in the array.
//            for (i = arySites.Size(), ppSite = arySites;
//                 i > 0;
//                 i--, ppSite++)
//            {
//                (*ppSite)->DoSomething();
//            }
//
// METHOD DESCRIPTIONS:
//
// Commonly used methods:
//
//        Size()             Returns the number of elements currently stored
//                           in the array.
//
//        operator []        Returns the given element in the array.
//
//        Item(int i)        Returns the given element in the array.
//
//        operator ELEM*     Allows the array class to be cast to a pointer
//                           to ELEM. Returns a pointer to the first element
//                           in the array. (Same as a Base() method).
//
//        Append(ELEM e)     Adds a new pointer to the end of the array,
//                           growing the array if necessary.  Only valid
//                           for arrays of pointers (CPtrAry, CStackPtrAry).
//
//        AppendIndirect(ELEM *pe, ELEM** ppePlaced)
//                           As Append, for non-pointer arrays
//                           (CDataAry, CStackDataAry).
//                           pe [in] - Pointer to element to add to array. The
//                                     data is copied into the array. Can be
//                                     NULL, in which case the new element is
//                                     initialized to all zeroes.
//                           ppePlaced [out] - Returns pointer to the new
//                                     element. Can be NULL.
//
//        Insert(int i, ELEM e)
//                           Inserts a new element (e) at the given index (i)
//                           in the array, growing the array if necessary. Any
//                           elements at or following the index are moved
//                           out of the way.
//
//        InsertIndirect(int i, ELEM *pe)
//                           As Insert, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        Find(ELEM e)       Returns the index at which a given element (e)
//                           is found (CPtrAry, CStackPtrAry).
//
//        FindIndirect(ELEM *pe)
//                           As Find, for non-pointer arrays
//                                 (CDataAry, CStackDataAry).
//
//        DeleteAll()        Empties the array and de-allocates associated
//                           memory.
//
//        Delete(int i)      Deletes an element of the array, moving any
//                           elements that follow it to fill
//
//        DeleteMultiple(int start, int end)
//                           Deletes a range of elements from the array,
//                           moving to fill. [start] and [end] are the indices
//                           of the start and end elements (inclusive).
//
//        DeleteByValue(ELEM e)
//                           Delete the element matching the given value.
//
//        DeleteByValueIndirect(ELEM *pe)
//                           As DeleteByValue, for non-pointer arrays.
//                                    (CDataAry, CStackDataAry).
//
//
// Less commonly used methods:
//
//        EnsureSize(long c) If you know how many elements you are going to put
//                          in the array before you actually do it, you can use
//                          EnsureSize to allocate the memory all at once instead
//                          of relying on Append(Indirect) to grow the array. This
//                          can be much more efficient (by causing only a single
//                          memory allocation instead of many) than just using
//                          Append(Indirect). You pass in the number of elements
//                          that memory should be allocated for. Note that this
//                          does not affect the "Size" of the array, which is
//                          the number of elements currently stored in it.
//
//        SetSize(int c)    Sets the "Size" of the array, which is the number
//                          of elements currently stored in it. SetSize will not
//                          allocate memory if you're growing the array.
//                          EnsureSize must be called first to reserve space if
//                          the array is growing. Setting the size smaller does
//                          not de-allocate memory, it just chops off the
//                          elements at the end of the array.
//
//        Grow(int c)       Equivalent to calling EnsureSize(c) followed by
//                          SetSize(c).
//
//        ReleaseAll()      (CPtrAry and CStackPtrAry only) Calls Release()
//                          on each element in the array and empties the array.
//
//        ReleaseAndDelete(int idx)
//                          (CPtrAry and CStackPtrAry only) Calls Release() on
//                          the given element and removes it from the array.
//
//           (See the class definitions below for signatures of the following
//            methods and src\core\cdutil\formsary.cxx for argument
//            descriptions)
//
//        CopyAppend        Appends data from another array (of the same type)
//                          to the end.
//
//        Copy              Copies data from another array (of the same type)
//                          into this array, replacing any existing data.
//
//        CopyAppendIndirect  Appends data from a C-style array of element data
//                          to the end of this array.
//
//        CopyIndirect      Copies elements from a C-style array into this array
//                          replacing any existing data.
//
//        EnumElements      Create an enumerator which supports the given
//                          interface ID for the contents of the array
//
//        EnumVARIANT       Create an IEnumVARIANT enumerator.
//
//        operator void *   Allow the CImplAry class to be cast
//                          to a (void *). Avoid using if possible - use
//                          the type-safe operator ELEM * instead.
//
//        ClearAndReset     Obsolete. Do not use.
//
//
//----------------------------------------------------------------------------





//----------------------------------------------------------------------------
//
// Class:     CImplAry
//
// Purpose:   Base implementation of all the dynamic array classes.
//
// Interface:
//
//        Deref       Returns a pointer to an element of the array;
//                    should only be used by derived classes. Use the
//                    type-safe methods operator[] or Item() instead.
//
//        GetAlloced  Get number of elements allocated
//
//  Members:    _c          Current size of the array
//              _pv         Buffer storing the elements
//
//  Note:       The CImplAry class only supports arrays of elements
//              whose size is less than 128.
//
//-------------------------------------------------------------------------


class CImplAry
{
    friend class CImplPtrAry;

private:
                DECLARE_MEMALLOC_NEW_DELETE();
public:
                ~CImplAry();
    inline int         Size() const    { return _c; } // UNIX: long->int for min() macro
    inline void        SetSize(int c)  { _c = c; }
    inline operator void *()           { return PData(); }
    void        DeleteAll();

    // BUGBUG -- This method should be protected, but I don't want to convert
    // existing code that uses it. (lylec)
    void *      Deref(size_t cb, int i);

#if DBG == 1
    BOOL _fCheckLock ; // If set with TraceTag CImplAryLock then any change
                       // (addition or deletion to the DataAry will generate an assert.

    void        LockCheck(BOOL fState)
      { _fCheckLock = fState; }
#else
    void        LockCheck(BOOL)
      {  }
#endif

    NO_COPY(CImplAry);

protected:

    //  Methods which are wrapped by inline subclass methods

                CImplAry();

    HRESULT     EnsureSize(size_t cb, long c);
    HRESULT     Grow(size_t cb, int c);
    HRESULT     AppendIndirect(size_t cb, void * pv, void ** ppvPlaced=NULL);
    HRESULT     InsertIndirect(size_t cb, int i, void * pv);
    int         FindIndirect(size_t cb, void *);

    void        Delete(size_t cb, int i);
    BOOL        DeleteByValueIndirect(size_t cb, void *pv);
    void        DeleteMultiple(size_t cb, int start, int end);

    HRESULT     CopyAppend(size_t cb, const CImplAry& ary, BOOL fAddRef);
    HRESULT     Copy(size_t cb, const CImplAry& ary, BOOL fAddRef);
    HRESULT     CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef);

    ULONG       GetAlloced(size_t cb);

    HRESULT     EnumElements(
                        size_t  cb,
                        REFIID  iid,
                        void ** ppv,
                        BOOL    fAddRef,
                        BOOL    fCopy = TRUE,
                        BOOL    fDelete = TRUE);

    HRESULT     EnumVARIANT(
                        size_t  cb,
                        VARTYPE         vt,
                        IEnumVARIANT ** ppenum,
                        BOOL            fCopy = TRUE,
                        BOOL            fDelete = TRUE);

    inline BOOL        UsingStackArray()
                    { return _fDontFree; }

    UINT        GetStackSize()
                    { Assert(_fStack);
                      return *(UINT*)((BYTE*)this + sizeof(CImplAry)); }
    void *      GetStackPtr()
                    { Assert(_fStack);
                      return (void*)((BYTE*)this + sizeof(CImplAry) + sizeof(int)); }

    unsigned long   _fStack     :1  ;  // Set if we're a stack-based array.
    unsigned long   _fDontFree  :1  ;  // Cleared if _pv points to alloced memory.
    unsigned long   _c          :30 ; // Count of elements

    void *      _pv;

    inline void * & PData()    { return _pv; }
};

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::CImplAry
//
//+------------------------------------------------------------------------
inline
CImplAry::CImplAry()
{
    memset(this, 0, sizeof(CImplAry));
}

//+------------------------------------------------------------------------
//
//  Member:     CImplAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  i
//
//  Returns:    void *
//
//-------------------------------------------------------------------------

inline void *
CImplAry::Deref(size_t cb, int i)
{
    Assert(i >= 0);
    Assert(ULONG( i ) < GetAlloced(cb));
    return ((BYTE *) PData()) + i * cb;
}

//+------------------------------------------------------------------------
//
//  Class:      CImplPtrAry (ary)
//
//  Purpose:    Subclass used for arrays of pointers.  In this case, the
//              element size is known to be sizeof(void *).  Normally, the
//              CPtrAry template is used to define a specific concrete
//              implementation of this class, to hold a specific type of
//              pointer.
//
//              See documentation above for use.
//
//-------------------------------------------------------------------------

class CImplPtrAry : public CImplAry
{
protected:
    DECLARE_MEMALLOC_NEW_DELETE();

    CImplPtrAry() : CImplAry() {};

    HRESULT     Append(void * pv);
    HRESULT     Insert(int i, void * pv);
    int         Find(void * pv);
    BOOL        DeleteByValue(void *pv);

    HRESULT     CopyAppend(const CImplAry& ary, BOOL fAddRef);
    HRESULT     Copy(const CImplAry& ary, BOOL fAddRef);
    HRESULT     CopyIndirect(int c, void * pv, BOOL fAddRef);


public:

    HRESULT     ClearAndReset();

    HRESULT     EnsureSize(long c);

    HRESULT     Grow(int c);

    void        Delete(int i);
    void        DeleteMultiple(int start, int end);

    void        ReleaseAll();
    void        ReleaseAndDelete(int idx);
};


//+---------------------------------------------------------------------------
//
//  Class:      CDataAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplAry.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM>
class CDataAry : public CImplAry
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CDataAry() : CImplAry() { }
    operator ELEM *() { return (ELEM *)PData(); }
    CDataAry(const CDataAry &);

    ELEM & Item(int i) { return *(ELEM*)Deref(sizeof(ELEM), i); }

    HRESULT     EnsureSize(long c)
                    { return CImplAry::EnsureSize(sizeof(ELEM), c); }
    HRESULT     Grow(int c)
                    { return CImplAry::Grow(sizeof(ELEM), c); }
    HRESULT     AppendIndirect(ELEM * pe, ELEM ** ppePlaced=NULL)
                    { return CImplAry::AppendIndirect(sizeof(ELEM), (void*)pe, (void**)ppePlaced); }
    ELEM *      Append()
                    { ELEM * pElem; return AppendIndirect( NULL, & pElem ) ? NULL : pElem; }
    HRESULT     InsertIndirect(int i, ELEM * pe)
                    { return CImplAry::InsertIndirect(sizeof(ELEM), i, (void*)pe); }
    int         FindIndirect(ELEM * pe)
                    { return CImplAry::FindIndirect(sizeof(ELEM), (void*)pe); }

    void        Delete(int i)
                    { CImplAry::Delete(sizeof(ELEM), i); }
    BOOL        DeleteByValueIndirect(ELEM *pe)
                    { return CImplAry::DeleteByValueIndirect(sizeof(ELEM), (void*)pe); }
    void        DeleteMultiple(int start, int end)
                    { CImplAry::DeleteMultiple(sizeof(ELEM), start, end); }

    HRESULT     CopyAppend(const CDataAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplAry::Copy(sizeof(ELEM), ary, fAddRef); }
    HRESULT     Copy(const CDataAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplAry::Copy(sizeof(ELEM), ary, fAddRef); }
    HRESULT     CopyIndirect(int c, ELEM * pv, BOOL fAddRef)
                    { return CImplAry::CopyIndirect(sizeof(ELEM), c, (void*)pv, fAddRef); }
};

//+---------------------------------------------------------------------------
//
//  Class:      CPtrAry
//
//  Purpose:    This template class declares a concrete derived class
//              of CImplPtrAry.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM>
class CPtrAry : public CImplPtrAry
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CPtrAry() : CImplPtrAry() { Assert(sizeof(ELEM) == sizeof(void*)); }
    operator ELEM *() { return (ELEM *)PData(); }
    CPtrAry(const CPtrAry &);

    ELEM & Item(int i) { return *(ELEM*)Deref(sizeof(ELEM), i); }

    HRESULT     Append(ELEM e)
                    { return CImplPtrAry::Append((void*)e); }
    HRESULT     Insert(int i, ELEM e)
                    { return CImplPtrAry::Insert(i, (void*)e); }
    BOOL        DeleteByValue(ELEM e)
                    { return CImplPtrAry::DeleteByValue((void*)e); }
    int         Find(ELEM e)
                    { return CImplPtrAry::Find((void*)e); }

    HRESULT     CopyAppend(const CPtrAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplPtrAry::Copy(ary, fAddRef); }
    HRESULT     Copy(const CPtrAry<ELEM>& ary, BOOL fAddRef)
                    { return CImplPtrAry::Copy(ary, fAddRef); }
    HRESULT     CopyIndirect(int c, ELEM *pe, BOOL fAddRef)
                    { return CImplPtrAry::CopyIndirect(c, (void*)pe, fAddRef); }

};

//+---------------------------------------------------------------------------
//
//  Class:      CStackDataAry
//
//  Purpose:    Declares a CDataAry that has initial storage on the stack.
//              N elements are declared on the stack, and the array will
//              grow dynamically beyond that if necessary.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM, int N>
class CStackDataAry : public CDataAry<ELEM>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CStackDataAry() : CDataAry<ELEM>()
    {
        _cStack     = N;
        _fStack     = TRUE;
        _fDontFree  = TRUE;
        PData()     = (void *) & _achTInit;
    }

protected:
    int   _cStack;                     // Must be first data member.
    char  _achTInit[N*sizeof(ELEM)];
};

//+---------------------------------------------------------------------------
//
//  Class:      CStackPtrAry
//
//  Purpose:    Same as CStackDataAry except for pointer types.
//
//              See documentation above for use.
//
//----------------------------------------------------------------------------

template <class ELEM, int N>
class CStackPtrAry : public CPtrAry<ELEM>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE();

    CStackPtrAry() : CPtrAry<ELEM>()
    {
        _cStack     = N;
        _fStack     = TRUE;
        _fDontFree  = TRUE;
        PData()     = (void *) & _achTInit;
    }

protected:
    int   _cStack;                     // Must be first data member.
    char  _achTInit[N*sizeof(ELEM)];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\msgbox.h ===
#define IDD_MESSAGEBOX              200
#define IDD_BUTTON1                 101
#define IDD_BUTTON2                 102
#define IDD_BUTTON3                 103
#define IDD_BUTTON4                 104
#define IDD_BUTTON5                 105
#define IDD_TIMEMSG                 107
#define IDD_TIME                    108
#define IDD_CANCELCOUNT             109
#define IDD_MESSAGE                 111
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\mtverp.h ===
// DO NOT Edit this file w/o consulting with the PTT Build tools team!

// Change VER_PRODUCTBUILD and VER_PRODUCTBUILD_QFE as appropriate.
#ifndef MTSCRIPT_BUILDNUMBER
#error MTSCRIPT_BUILDNUMBER must be defined for official builds!
#endif

#ifndef MTSCRIPT_QFENUMBER
#error MTSCRIPT_QFENUMBER must be defined for official builds!
#endif

#define VER_MAJOR_PRODUCTVER            1
#define VER_MINOR_PRODUCTVER            00
#define VER_PRODUCTBUILD                MTSCRIPT_BUILDNUMBER
#define VER_PRODUCTBUILD_QFE            MTSCRIPT_QFENUMBER

#define VER_PRODUCTVERSION              VER_MAJOR_PRODUCTVER,VER_MINOR_PRODUCTVER,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W            (0x0100)
#define VER_PRODUCTVERSION_DW           (0x01000000 | VER_PRODUCTBUILD)

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Microsoft(R) MultiThreaded Script Engine"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows (R) is a registered trademark of Microsoft Corporation."

// READ THIS

// Do not change VER_PRODUCTVERSION_STRING.
//
// The code below will take VER_PRODUCTVERSION_STRING and create a version
// string that includes the QFE number & etc.
//

#define VER_PRODUCTBETA_STR             ""
#define VER_PRODUCTVERSION_STRING       "1.00"

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\regsettingsio.h ===
#ifndef REGSETTINGSIO_H
#define REGSETTINGSIO_H

#define MAX_REG_VALUE_LENGTH   50
extern const WCHAR *g_szRegistry;

enum RKI_TYPE
{
    RKI_KEY,
    RKI_BOOL,
    RKI_DWORD,
    RKI_STRING,
    RKI_EXPANDSZ
};

struct REGKEYINFORMATION
{
    TCHAR *   pszName;            // Name of the value or key
    BYTE      rkiType;            // Type of entry
    size_t    cbOffset;           // Offset of member to store data in
};

HRESULT RegSettingsIO(const WCHAR *szRegistry, BOOL fSave, const REGKEYINFORMATION *aKeyValues, int cKeyValues, BYTE *pBase);

HRESULT ChangeAppIDACL(REFGUID AppID, LPTSTR Principal, BOOL fAccess, BOOL SetPrincipal, BOOL Permit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\proccomm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       proccomm.h
//
//  Contents:   Contains the definition of CProcessComm
//
//----------------------------------------------------------------------------

class CProcessComm : public IScriptedProcess
{
public:

    CProcessComm(CMTScript *pMT);
   ~CProcessComm();

    DECLARE_MEMCLEAR_NEW_DELETE();

    DECLARE_STANDARD_IUNKNOWN(CProcessComm);

    // IScriptedProcess methods

    STDMETHOD(SetProcessID)(long lProcessID, wchar_t *pszEnvID);
    STDMETHOD(SendData)(wchar_t * pszType,
                        wchar_t * pszData,
                        long *plReturn);
    STDMETHOD(SetExitCode)(long lExitCode);
    STDMETHOD(SetProcessSink)(IScriptedProcessSink * pSPS);


    void SendToProcess(MACHPROC_EVENT_DATA *pmed);

private:

    CMTScript            *_pMT;
    IScriptedProcessSink *_pSink;
    CScriptHost          *_pSH;
    CProcessThread       *_pProc;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\mem.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       mem.h
//
//  Contents:   Memory utility functions (has leak tracking in debug)
//
//----------------------------------------------------------------------------


EXTERN_C void *  _MemAlloc(ULONG cb);
EXTERN_C void *  _MemAllocClear(ULONG cb);
EXTERN_C HRESULT _MemRealloc(void ** ppv, ULONG cb);
EXTERN_C ULONG   _MemGetSize(void * pv);
EXTERN_C void    _MemFree(void * pv);
HRESULT          _MemAllocString(LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemAllocString(ULONG cch, LPCTSTR pchSrc, LPTSTR * ppchDst);
HRESULT          _MemReplaceString(LPCTSTR pchSrc, LPTSTR * ppchDest);
void __cdecl     _MemSetName(void * pv, char * szFmt, ...);
#define          _MemFreeString(pch) _MemFree(pch)

#if defined(MEMGUARD)

#define MemAlloc(cb)                            _MgMemAlloc(cb)
#define MemAllocClear(cb)                       _MgMemAllocClear(cb)
#define MemRealloc(ppv, cb)                     _MgMemRealloc(ppv, cb)
#define MemGetSize(pv)                          _MgMemGetSize(pv)
#define MemFree(pv)                             _MgMemFree(pv)
#define MemAllocString(pch, ppch)               _MgMemAllocString(pch, ppch)
#define MemAllocStringBuffer(cch, pch, ppch)    _MgMemAllocString(cch, pch, ppch)
#define MemReplaceString(pch, ppch)             _MgMemReplaceString(pch, ppch)
#define MemFreeString(pch)                      _MgMemFreeString(pch)

#else

#define MemAlloc(cb)                            _MemAlloc(cb)
#define MemAllocClear(cb)                       _MemAllocClear(cb)
#define MemRealloc(ppv, cb)                     _MemRealloc(ppv, cb)
#define MemGetSize(pv)                          _MemGetSize(pv)
#define MemFree(pv)                             _MemFree(pv)
#define MemAllocString(pch, ppch)               _MemAllocString(pch, ppch)
#define MemAllocStringBuffer(cch, pch, ppch)    _MemAllocString(cch, pch, ppch)
#define MemReplaceString(pch, ppch)             _MemReplaceString(pch, ppch)
#define MemFreeString(pch)                      _MemFreeString(pch)

#endif

#if DBG == 1
#define MemSetName                              DbgExMemSetName
#else
#define MemSetName                              0&&
#endif

inline void * __cdecl operator new(size_t cb)           { return MemAlloc(cb); }
inline void * __cdecl operator new[](size_t cb)         { return MemAlloc(cb); }
inline void * __cdecl operator new(size_t cb, int mt)   { return MemAlloc(cb); }
inline void * __cdecl operator new[](size_t cb, int mt) { return MemAlloc(cb); }
inline void * __cdecl operator new(size_t cb, void * pv){ return pv; }
inline void   __cdecl operator delete(void *pv)         { MemFree(pv); }
inline void   __cdecl operator delete[](void *pv)       { MemFree(pv); }

#define DECLARE_MEMALLOC_NEW_DELETE() \
    inline void * __cdecl operator new(size_t cb) { return(MemAlloc(cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAlloc(cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }

#define DECLARE_MEMCLEAR_NEW_DELETE() \
    inline void * __cdecl operator new(size_t cb) { return(MemAllocClear(cb)); } \
    inline void * __cdecl operator new[](size_t cb) { return(MemAllocClear(cb)); } \
    inline void __cdecl operator delete(void * pv) { MemFree(pv); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\resizer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       resizer.h
//
//  Contents:   Dialog resizer class
//
//----------------------------------------------------------------------------

#ifndef RESIZER_H
#define RESIZER_H
struct CResizeInfo
{
    UINT _id;
    int  _Flags;
    RECT _Rect;
};

class CResizer
{
public:
    enum sizeflags
    {
        sf_Width         = 0x01,
        sf_Height        = 0x02,
        sf_Left          = 0x04,
        sf_Top           = 0x08,
        sf_HalfLeftWidth = 0x10,
        sf_HalfTopHeight = 0x20,
        sf_HalfWidth     = 0x40,
        sf_HalfHeight    = 0x80
    };
    CResizer();
    ~CResizer();

    void Init(HWND win, CResizeInfo *pResizeInfo);
    void NewSize() const;
private:
    HWND _hWnd;
    RECT _winRect;
    CResizeInfo *_pResizeInfo;

    void InitCtrl(CResizeInfo *p);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\process.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       process.h
//
//  Contents:   CProcessThread class definition
//
//----------------------------------------------------------------------------

#define PIPE_BUFFER_SIZE 1024

class CProcessComm;

//+---------------------------------------------------------------------------
//
//  Class:      CProcessParams
//
//  Purpose:    Provide simple free store management for PROCESS_PARAMS
//
//----------------------------------------------------------------------------
class CProcessParams : public PROCESS_PARAMS
{
public:
        CProcessParams();
        ~CProcessParams();

//      CProcessParams &operator =(const PROCESS_PARAMS &params);
        bool Copy(const PROCESS_PARAMS *params);

private:
        void Free();
        bool Assign(const PROCESS_PARAMS &params);
};

//+---------------------------------------------------------------------------
//
//  Class:      CProcessThread (cpt)
//
//  Purpose:    Class which spawns a process, monitors its success, talks to
//              it during execution if necessary, and returns its completion
//              status. (each CProcessThread is in its own thread)
//
//----------------------------------------------------------------------------

class CProcessThread  : public CThreadComm
{
public:
    CProcessThread(CScriptHost *pSH);
   ~CProcessThread();

    DECLARE_STANDARD_IUNKNOWN(CProcessThread);

    DWORD  ProcId()    { return _piProc.dwProcessId; }

    // Thread-Safe member functions. These can be called by any thread to
    // get the appropriate information without having to go through
    // PostToThread. These are only safe AFTER the process has been started.

    HRESULT GetProcessOutput(BSTR *pbstrOutput);
    DWORD   GetExitCode();
    void    SetExitCode(DWORD dwExitCode)
               {
                   _dwExitCode = dwExitCode;
                   _fUseExitCode = TRUE;
               }
    void    Terminate();

    ULONG   GetDeadTime();
    BOOL    IsOwner(DWORD dwProcID, long lID)
                 { return (lID == _lEnvID); }

    CScriptHost * ScriptHost()
                 { return _pSH; }

    void SetProcComm(CProcessComm *pPC)
                 { Assert(!_pPC || !pPC); _pPC = pPC; }
    CProcessComm * GetProcComm()
                 { return _pPC; }

        const PROCESS_PARAMS *GetParams() const { return &_ProcParams; }
protected:

    virtual DWORD ThreadMain();
    virtual BOOL  Init();

    void HandleThreadMessage();
    void HandleProcessExit();
    BOOL IsDataInPipe();
    void ReadPipeData();
    void CheckIoPort();

    HRESULT LaunchProcess(const PROCESS_PARAMS *pProcParams);
    void    GetProcessEnvironment(CStr *pcstr, BOOL fNoEnviron);

private:
    CScriptHost        *_pSH;
    CProcessComm       *_pPC;          // Not AddRef'd

    PROCESS_INFORMATION _piProc;
    long                _lEnvID;

    DWORD               _dwExitCode;   // Value set explicitely by the process
    BOOL                _fUseExitCode; // TRUE if _dwExitCode is the code we want

    HANDLE              _hPipe;
    BYTE                _abBuffer[PIPE_BUFFER_SIZE];

    HANDLE              _hJob;
    HANDLE              _hIoPort;

    CStackPtrAry<DWORD, 10> _aryProcIds;

    CProcessParams      _ProcParams;

    _int64              _i64ExitTime;

    // Access to the following members must be thread-safe (by calling
    // LOCK_LOCALS).
    CStr                _cstrOutput;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\mshtmdbg.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       mshtmdbg.h
//
//  Contents:   External include file for mshtmdbg.dll
//
// ----------------------------------------------------------------------------

#ifndef _MSHTMDBG_H_
#define _MSHTMDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MSHTMDBG_API_VERSION    (4)     // Increment whenever API changes

typedef INT     TRACETAG;
typedef INT_PTR PERFTAG;
typedef INT_PTR PERFMETERTAG;

DWORD       WINAPI  DbgExGetVersion();
BOOL        WINAPI  DbgExIsFullDebug();
void        WINAPI  DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

void        WINAPI  DbgExDoTracePointsDialog(BOOL fWait);
void        WINAPI  DbgExRestoreDefaultDebugState();

BOOL        WINAPI  DbgExEnableTag(TRACETAG tag, BOOL fEnable);
BOOL        WINAPI  DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk);
BOOL        WINAPI  DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak);
BOOL        WINAPI  DbgExIsTagEnabled(TRACETAG tag);
TRACETAG    WINAPI  DbgExFindTag(char * szTagDesc);

TRACETAG    WINAPI  DbgExTagError();
TRACETAG    WINAPI  DbgExTagWarning();
TRACETAG    WINAPI  DbgExTagThread();
TRACETAG    WINAPI  DbgExTagAssertExit();
TRACETAG    WINAPI  DbgExTagAssertStacks();
TRACETAG    WINAPI  DbgExTagMemoryStrict();
TRACETAG    WINAPI  DbgExTagCoMemoryStrict();
TRACETAG    WINAPI  DbgExTagMemoryStrictTail();
TRACETAG    WINAPI  DbgExTagMemoryStrictAlign();
TRACETAG    WINAPI  DbgExTagOLEWatch();
TRACETAG    WINAPI  DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagPerf();

BOOL        __cdecl DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...);
BOOL        __cdecl DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...);
BOOL        WINAPI  DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
void        WINAPI  DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal);

BOOL        WINAPI  DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage);
void        WINAPI  DbgExAssertThreadDisable(BOOL fDisable);
HRESULT     __cdecl DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...);
HRESULT     WINAPI  DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker);

size_t      WINAPI  DbgExPreAlloc(size_t cbRequest);
void *      WINAPI  DbgExPostAlloc(void *pv);
void *      WINAPI  DbgExPreFree(void *pv);
void        WINAPI  DbgExPostFree();
size_t      WINAPI  DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv);
void *      WINAPI  DbgExPostRealloc(void *pv);
void *      WINAPI  DbgExPreGetSize(void *pvRequest);
size_t      WINAPI  DbgExPostGetSize(size_t cb);
void *      WINAPI  DbgExPreDidAlloc(void *pvRequest);
BOOL        WINAPI  DbgExPostDidAlloc(void *pvRequest, BOOL fActual);

void        WINAPI  DbgExMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExCoMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExMemoryBlockTrackDisable(void * pv);
void        WINAPI  DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt);
void *      WINAPI  DbgExGetMallocSpy();
void        WINAPI  DbgExTraceMemoryLeaks();
BOOL        WINAPI  DbgExValidateInternalHeap();

LONG_PTR    WINAPI  DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
LONG_PTR    WINAPI  DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite);
void        WINAPI  DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExSetSimFailCounts(int firstFailure, int cInterval);
void        WINAPI  DbgExShowSimFailDlg();
BOOL        WINAPI  DbgExFFail();
int         WINAPI  DbgExGetFailCount();
void        WINAPI  DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv);

void        WINAPI  DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize);
void        WINAPI  DbgExOpenMemoryMonitor();
void        WINAPI  DbgExOpenLogFile(LPCSTR szFName);

void *      __cdecl DbgExMemSetName(void *pvRequest, char * szFmt, ...);
void *      WINAPI  DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker);
char *      WINAPI  DbgExMemGetName(void *pvRequest);

HRESULT     WINAPI  DbgExWsClear(HANDLE hProcess);
HRESULT     WINAPI  DbgExWsTakeSnapshot(HANDLE hProcess);
BSTR        WINAPI  DbgExWsGetModule(long row);
BSTR        WINAPI  DbgExWsGetSection(long row);
long        WINAPI  DbgExWsSize(long row);
long        WINAPI  DbgExWsCount();
long        WINAPI  DbgExWsTotal();
HRESULT     WINAPI  DbgExWsStartDelta(HANDLE hProcess);
long        WINAPI  DbgExWsEndDelta(HANDLE hProcess);

void        WINAPI  DbgExDumpProcessHeaps();

PERFTAG     WINAPI  DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip);
void        __cdecl DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...);
void        WINAPI  DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker);
void        WINAPI  DbgExPerfDump();
void        WINAPI  DbgExPerfClear();
void        WINAPI  DbgExPerfTags();

char *      WINAPI  DbgExDecodeMessage(UINT msg);

PERFMETERTAG WINAPI  DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip);
void        WINAPI  DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG lVal);
void        WINAPI  DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG lVal);
char *      WINAPI  DbgExMtGetName(PERFMETERTAG mt);
char *      WINAPI  DbgExMtGetDesc(PERFMETERTAG mt);
BOOL        WINAPI  DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG lNewValue);
void        WINAPI  DbgExMtOpenMonitor();
void        WINAPI  DbgExMtLogDump(LPSTR pchFile);

void        WINAPI  DbgExSetTopUrl(LPWSTR pstrUrl);
void        WINAPI  DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf);

BOOL        WINAPI  DbgExGetChkStkFill(DWORD * pdwFill);

#ifdef __cplusplus
}
#endif

// Performance Logging --------------------------------------------------------

#ifdef PERFTAGS

#define     IsPerfEnabled(tag) (*(BOOL *)tag)
#define     PerfTag(tag, szOwner, szDescrip) PERFTAG tag(DbgExPerfRegister(#tag, szOwner, szDescrip));
#define     PerfExtern(tag) extern PERFTAG tag;
#define     PerfLog(tag,pv,f) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f) : 0
#define     PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1) : 0
#define     PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2) : 0
#define     PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0
#define     PerfDump()  DbgExPerfDump()
#define     PerfClear() DbgExPerfClear()
#define     PerfTags()  DbgExPerfTags()

#else

#define     IsPerfEnabled(tag) (FALSE)
#define     PerfTag(tag, szOwner, szDescrip)
#define     PerfExtern(tag)
#define     PerfLog(tag,pv,f)
#define     PerfLog1(tag,pv,f,a1)
#define     PerfLog2(tag,pv,f,a1,a2)
#define     PerfLog3(tag,pv,f,a1,a2,a3)
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define     PerfDump()
#define     PerfClear()
#define     PerfTags()

#endif

// Performance Metering -------------------------------------------------------

#ifdef PERFMETER

#define     Mt(x)                               g_mt##x
#define     MtExtern(tag)                       extern PERFMETERTAG g_mt##tag;
#define     MtDefine(tag, tagOwner, szDescrip)  PERFMETERTAG g_mt##tag(DbgExMtRegister("mt" #tag, "mt" #tagOwner, szDescrip));
#define     MtAdd(mt, lCnt, lVal)               DbgExMtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)               DbgExMtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewVal)  DbgExMtSimulateOutOfMemory(mt, lNewVal)
#define     MtOpenMonitor()                     DbgExMtOpenMonitor()

#else

#define     Mt(x)                               0
#define     MtExtern(tag)
#define     MtDefine(tag, szOwner, szDescrip)
#define     MtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewValue)
#define     MtOpenMonitor()

#endif

// MSHTML perf control --------------------------------------------------------

#define HTMPERFCTL_NAME     "#MSHTML#PERF#"

enum
{
    HTMPF_CALLBACK_ONLOAD   = 0x00000001,   // callback when topdoc loaded
    HTMPF_ENABLE_PROFILE    = 0x00000002,   // enable profiling
    HTMPF_ENABLE_MEMWATCH   = 0x00000004,   // enable memwatch sampling
    HTMPF_DISABLE_PADEVENTS = 0x00000008,   // disable firing of events from mshtmpad.exe
    HTMPF_DISABLE_IMGCACHE  = 0x00000010,   // disable image cache in mshtml
    HTMPF_DISABLE_OFFSCREEN = 0x00000020,   // disable offscreen buffering
};

typedef void (WINAPI *HTMPFCBFN)(DWORD dwArg1, void * pvArg2);

typedef struct HTMPERFCTL
{
    DWORD       dwSize;     // set to sizeof(MSHTMLPERF)
    DWORD       dwFlags;    // see HTMPF_*
    HTMPFCBFN   pfnCall;    // Callback function
    void *      pvHost;     // Private data for host
} HTMPERFCTL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\threadlock.h ===
#ifndef THREADLOCK_H
#define THREADLOCK_H
class CThreadLock
{
public:
    CThreadLock()
    {
        InitializeCriticalSection(&_csAccess);
    }
    ~CThreadLock()
    {
        DeleteCriticalSection(&_csAccess);
    }
    void ThreadLock()
    {
        EnterCriticalSection(&_csAccess);
    }
    void ThreadUnLock()
    {
        LeaveCriticalSection(&_csAccess);
    }
private:
    CRITICAL_SECTION _csAccess;   // Used to control access to member data

    // Do not allow this object to be copied.
    CThreadLock(const CThreadLock &that);
    operator=(const CThreadLock &that);
};
class CAutoLock
{
public:
    CAutoLock(CThreadLock *pThis) : _pThis(pThis)
    {
        _pThis->ThreadLock();
    }
   ~CAutoLock()
   {
       _pThis->ThreadUnLock();
   }

private:
    CThreadLock *_pThis;
};

//
//
// LOCK_LOCALS() should be used whenever access to thread-safe member data
// is needed.
//
#define LOCK_LOCALS(pObj)  CAutoLock local_lock(pObj);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\script.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       bsscript.h
//
//  Contents:   Script engine classes
//
//----------------------------------------------------------------------------

class CScriptHost;
class CProcessThread;

// Helper class to make initialization
// and freeing of VARIANTARGs foolproof.
// Can be used anywhere a VARIANTARG
// would be used.
class AutoVariant : public VARIANTARG
{
public:
    AutoVariant()
    {
        VariantInit( (VARIANTARG *) this);
    }
    BOOL Set(long value)
    {
        V_VT(this) = VT_I4;
        V_I4(this) = value;
        return TRUE;
    }
    BOOL Set(TCHAR *value)
    {
        V_VT(this) = VT_BSTR;
        V_BSTR(this) = SysAllocString(value); // NULL is a valid value for BSTR
        if (value && !V_BSTR(this))
            return FALSE;
        return TRUE;
    }
    ~AutoVariant()
    {
        VariantClear( (VARIANTARG *) this);
    }
};

//+------------------------------------------------------------------------
//
//  Class:      CScriptSite
//
//  Purpose:    Active scripting site
//
//-------------------------------------------------------------------------

class CScriptSite :
    public IActiveScriptSite,
    public IActiveScriptSiteWindow,
    public IActiveScriptSiteDebug,
    public IProvideMultipleClassInfo,
    public IConnectionPointContainer,
    public IGlobalMTScript
{
public:

    DECLARE_MEMCLEAR_NEW_DELETE();

    CScriptSite(CScriptHost * pSH);
   ~CScriptSite();

    HRESULT Init(LPWSTR pszName);
    void    Close();
    void    Abort();

    // IUnknown methods

    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID, void **);

    // IActiveScriptSite methods

    STDMETHOD(GetLCID)(LCID *plcid);
    STDMETHOD(GetItemInfo)(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppiunkItem, ITypeInfo **ppti);
    STDMETHOD(GetDocVersionString)(BSTR *pszVersion);
    STDMETHOD(RequestItems)(void);
    STDMETHOD(RequestTypeLibs)(void);
    STDMETHOD(OnScriptTerminate)(const VARIANT *pvarResult, const EXCEPINFO *pexcepinfo);
    STDMETHOD(OnStateChange)(SCRIPTSTATE ssScriptState);
    STDMETHOD(OnScriptError)(IActiveScriptError *pscripterror);
    STDMETHOD(OnEnterScript)(void);
    STDMETHOD(OnLeaveScript)(void);

    // IActiveScriptSiteWindow methods

    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IActiveScriptSiteDebug methods

    STDMETHOD(GetDocumentContextFromPosition)(DWORD dwSourceContext,
                                              ULONG uCharacterOffset,
                                              ULONG uNumChars,
                                              IDebugDocumentContext **ppsc);

    STDMETHOD(GetApplication)(IDebugApplication **ppda);
    STDMETHOD(GetRootApplicationNode)(IDebugApplicationNode **ppdanRoot);
    STDMETHOD(OnScriptErrorDebug)(IActiveScriptErrorDebug *pErrorDebug,
                                  BOOL *pfEnterDebugger,
                                  BOOL *pfCallOnScriptErrorWhenContinuing);

    // IProvideClassInfo methods

    STDMETHOD(GetClassInfo)(ITypeInfo **);
    STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID * pGUID);

    // IProvideMultipleClassInfo methods

    STDMETHOD(GetMultiTypeInfoCount)(ULONG *pcti);
    STDMETHOD(GetInfoOfIndex)(ULONG iti, DWORD dwFlags, ITypeInfo** pptiCoClass, DWORD* pdwTIFlags, ULONG* pcdispidReserved, IID* piidPrimary, IID* piidSource);

    // IConnectionPointContainer methods

    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS*);
    STDMETHOD(FindConnectionPoint)(REFIID, LPCONNECTIONPOINT*);

    // IBServer methods
    // We need to implement these on a separate identity from
    // the main pad object in order to prevent ref count loops
    // with the script engine.

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    STDMETHOD(get_PublicData)(VARIANT *);
    STDMETHOD(put_PublicData)(VARIANT);
    STDMETHOD(get_PrivateData)(VARIANT *);
    STDMETHOD(put_PrivateData)(VARIANT);
    STDMETHOD(ExitProcess)();
    STDMETHOD(Restart)();
    STDMETHOD(get_LocalMachine)(BSTR *);
    STDMETHOD(Include)(BSTR);
    STDMETHOD(CallScript)(BSTR, VARIANT *);
    STDMETHOD(SpawnScript)(BSTR, VARIANT *);
    STDMETHOD(get_ScriptParam)(VARIANT *);
    STDMETHOD(get_ScriptPath)(BSTR *);
    STDMETHOD(CallExternal)(BSTR, BSTR, VARIANT *, long *);
    STDMETHOD(ResetSync)(const BSTR);
    STDMETHOD(WaitForSync)(BSTR, long, VARIANT_BOOL *);
    STDMETHOD(WaitForMultipleSyncs)(const BSTR, VARIANT_BOOL, long, long *);
    STDMETHOD(SignalThreadSync)(BSTR);
    STDMETHOD(TakeThreadLock)(BSTR);
    STDMETHOD(ReleaseThreadLock)(BSTR);
    STDMETHOD(DoEvents)();
    STDMETHOD(MessageBoxTimeout)(BSTR, long, BSTR, long, long, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(RunLocalCommand)(BSTR, BSTR, BSTR, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(GetLastRunLocalError)(long *);
    STDMETHOD(GetProcessOutput)(long, BSTR *);
    STDMETHOD(GetProcessExitCode)(long, long *);
    STDMETHOD(TerminateProcess)(long);
    STDMETHOD(SendToProcess)(long, BSTR, BSTR, long *);
    STDMETHOD(SendMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(SendSMTPMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(ASSERT)(VARIANT_BOOL, BSTR);
    STDMETHOD(OUTPUTDEBUGSTRING)(BSTR);
    STDMETHOD(UnevalString)(BSTR, BSTR*);
    STDMETHOD(CopyOrAppendFile)(BSTR bstrSrc,BSTR bstrDst,long nSrcOffset,long nSrcLength,VARIANT_BOOL  fAppend,long *nSrcFilePosition);
    STDMETHOD(Sleep)(int);
    STDMETHOD(Reboot)();
    STDMETHOD(NotifyScript)(BSTR, VARIANT);
    STDMETHOD(RegisterEventSource)(IDispatch *pDisp, BSTR bstrProgID);
    STDMETHOD(UnregisterEventSource)(IDispatch *pDisp);
    STDMETHOD(get_HostMajorVer)(long *pVer);
    STDMETHOD(get_HostMinorVer)(long *pVer);
    STDMETHOD(get_StatusValue)(long nIndex, long *pnStatus);
    STDMETHOD(put_StatusValue)(long nIndex, long nStatus);

    // Other methods

    HRESULT ExecuteScriptStr(TCHAR * pchScript);
    HRESULT ExecuteScriptFile(TCHAR *pchPath);
    HRESULT SetScriptState(SCRIPTSTATE ss);

    CScriptHost * ScriptHost() { return _pSH; }

    // Member variables
    CStr                        _cstrName;
    ULONG                       _ulRefs;
    CScriptSite *               _pScriptSitePrev;
    IActiveScript *             _pScript;
    CScriptHost*                _pSH;
    TCHAR                       _achPath[MAX_PATH];
    VARIANT                     _varParam;
    IDispatch *                 _pDispSink;
    IDebugDocumentHelper      * _pDDH;  // Script Debugging helper
    DWORD                       _dwSourceContext;
    BOOL                        _fInDebugError;

private:
    BOOL                        _fInScriptError;
};

class AutoCriticalSection : public CRITICAL_SECTION
{
public:
    AutoCriticalSection()
    {
        InitializeCriticalSection(this);
    }
    ~AutoCriticalSection()
    {
        DeleteCriticalSection(this);
    }
};

class CScriptHost :
        public CThreadComm,
        public IGlobalMTScript
{
    friend class CScriptEventSink;

public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CScriptHost(CMTScript *  pBS,
                BOOL         fPrimary,
                BOOL         fDispatchOnly);

   ~CScriptHost();

    DECLARE_STANDARD_IUNKNOWN(CScriptHost);

    // Script management

    HRESULT LoadTypeLibrary();
    HRESULT PushScript(TCHAR *pchType);
    HRESULT PopScript();
    HRESULT CloseScripts();
    HRESULT AbortScripts();
    HRESULT ExecuteTopLevelScript(TCHAR *pchPath, VARIANT *pvarParams);
    HRESULT ExecuteTopLevelScriptlet(TCHAR *pchScript);

    long    FireScriptErrorEvent(
                                TCHAR *bstrFile,
                                long nLine,
                                long nChar,
                                TCHAR *bstrText,
                                long sCode,
                                TCHAR *bstrSource,
                                TCHAR *bstrDescription);
    long    FireScriptErrorEvent(TCHAR *szMsg);
    void    FireProcessEvent(THREADMSG mt, CProcessThread *pProc);
    void    FireMachineEvent(MACHPROC_EVENT_DATA *pmed, BOOL fExec);
    void    FireEvent(DISPID, UINT cArg, VARIANTARG *pvararg, VARIANTARG *pvarResult);
    void    FireEvent(DISPID, UINT cArg, VARIANTARG *pvararg);
    void    FireEvent(DISPID, LPCTSTR);
    void    FireEvent(DISPID, BOOL);
    void    FireEvent(DISPID, IDispatch *pDisp);

    BOOL    GetMachineDispatch(LPSTR achName,
                               IConnectedMachine **ppMach);

    static HRESULT GetSyncEventName(int nEvent, CStr *pCStr, HANDLE *phEvent);
    static HRESULT GetSyncEvent(LPCTSTR pszName, HANDLE *phEvent);
    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    // IGlobalMTScript interface

    STDMETHOD(get_PublicData)(VARIANT *);
    STDMETHOD(put_PublicData)(VARIANT);
    STDMETHOD(get_PrivateData)(VARIANT *);
    STDMETHOD(put_PrivateData)(VARIANT);
    STDMETHOD(ExitProcess)();
    STDMETHOD(Restart)();
    STDMETHOD(get_LocalMachine)(BSTR *);
    STDMETHOD(Include)(BSTR);
    STDMETHOD(CallScript)(BSTR, VARIANT *);
    STDMETHOD(SpawnScript)(BSTR, VARIANT *);
    STDMETHOD(get_ScriptParam)(VARIANT *);
    STDMETHOD(get_ScriptPath)(BSTR *);
    STDMETHOD(CallExternal)(BSTR, BSTR, VARIANT *, long *);
    STDMETHOD(ResetSync)(const BSTR);
    STDMETHOD(WaitForSync)(BSTR, long, VARIANT_BOOL *);
    STDMETHOD(WaitForMultipleSyncs)(const BSTR, VARIANT_BOOL, long, long *);
    STDMETHOD(SignalThreadSync)(BSTR);
    STDMETHOD(TakeThreadLock)(BSTR);
    STDMETHOD(ReleaseThreadLock)(BSTR);
    STDMETHOD(DoEvents)();
    STDMETHOD(MessageBoxTimeout)(BSTR, long, BSTR, long, long, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(RunLocalCommand)(BSTR, BSTR, BSTR, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, VARIANT_BOOL, long *);
    STDMETHOD(GetLastRunLocalError)(long *);
    STDMETHOD(GetProcessOutput)(long, BSTR *);
    STDMETHOD(GetProcessExitCode)(long, long *);
    STDMETHOD(TerminateProcess)(long);
    STDMETHOD(SendToProcess)(long, BSTR, BSTR, long *);
    STDMETHOD(SendMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(SendSMTPMail)(BSTR, BSTR, BSTR, BSTR, BSTR, BSTR, long *);
    STDMETHOD(ASSERT)(VARIANT_BOOL, BSTR);
    STDMETHOD(OUTPUTDEBUGSTRING)(BSTR);
    STDMETHOD(UnevalString)(BSTR, BSTR*);
    STDMETHOD(CopyOrAppendFile)(BSTR bstrSrc,BSTR bstrDst,long nSrcOffset,long nSrcLength,VARIANT_BOOL  fAppend,long *nSrcFilePosition);
    STDMETHOD(Sleep)(int);
    STDMETHOD(Reboot)();
    STDMETHOD(NotifyScript)(BSTR, VARIANT);
    STDMETHOD(RegisterEventSource)(IDispatch *pDisp, BSTR bstrProgID);
    STDMETHOD(UnregisterEventSource)(IDispatch *pDisp);
    STDMETHOD(get_HostMajorVer)(long *pVer);
    STDMETHOD(get_HostMinorVer)(long *pVer);
    STDMETHOD(get_StatusValue)(long nIndex, long *pnStatus);
    STDMETHOD(put_StatusValue)(long nIndex, long nStatus);

    CScriptSite *  GetSite() { return _pScriptSite; }
    void GetScriptPath(CStr *pcstrPath);

    CMTScript *                 _pMT;
    CScriptSite *               _pScriptSite;

    BOOL                        _fIsPrimaryScript;
    BOOL                        _fMustExitThread;
    BOOL                        _fDontHandleEvents;
    ITypeInfo *                 _pTypeInfoIGlobalMTScript;
    ITypeInfo *                 _pTypeInfoCMTScript;
    ITypeLib *                  _pTypeLibEXE;

    VARIANT                     _vPubCache;
    VARIANT                     _vPrivCache;
    DWORD                       _dwPublicSN;
    DWORD                       _dwPrivateSN;

    long                        _lTimerInterval;

    HRESULT                     _hrLastRunLocalError;

    CStackPtrAry<CScriptEventSink*, 5> _aryEvtSinks;

protected:
    virtual DWORD ThreadMain();
    void HandleThreadMessage();

    enum MEP_RETURN
    {
        MEP_TIMEOUT,       // Timeout period expired
        MEP_EXIT,          // Thread is terminating
        MEP_FALLTHROUGH,   // No event occurred (fWait==FALSE only)
        MEP_EVENT_0,       // The given event(s) are signaled
    };

    DWORD MessageEventPump(BOOL     fWait,
                           UINT     cEvents   = 0,
                           HANDLE * pEvents   = NULL,
                           BOOL     fAll      = FALSE,
                           DWORD    dwTimeout = INFINITE,
                           BOOL     fNoEvents = FALSE);


    HRESULT StringToEventArray(const wchar_t *pszNameList, CStackPtrAry<HANDLE, 5> *aryEvents);
    HRESULT GetLockCritSec(LPTSTR             pszName,
                           CRITICAL_SECTION **ppcs,
                           DWORD            **ppdwOwner);

    struct SYNCEVENT
    {
        CStr   _cstrName;
        HANDLE _hEvent;
    };

    struct THREADLOCK
    {
        CStr             _cstrName;
        CRITICAL_SECTION _csLock;
        DWORD            _dwOwner;
    };

    // MAX_LOCKS is used because you can't move critical section objects
    // in memory once you've initialized them, thus making it impossible to
    // use the dynamic array class.
    #define MAX_LOCKS 10

    // The primary thread owns initialization and cleanup of these objects.
    static CStackDataAry<SYNCEVENT, 5> s_arySyncEvents;
    static THREADLOCK                  s_aThreadLocks[MAX_LOCKS];
    static UINT                        s_cThreadLocks;
    static AutoCriticalSection         s_csSync;
};

//+---------------------------------------------------------------------------
//
//  Class:      CConnectionPoint (ccp)
//
//  Purpose:    Implements IConnectionPoint for the script site
//
//----------------------------------------------------------------------------

class CConnectionPoint : public IConnectionPoint
{
public:

    CConnectionPoint(CScriptSite *pSite);
   ~CConnectionPoint();

    DECLARE_STANDARD_IUNKNOWN(CConnectionPoint);

    STDMETHOD(GetConnectionInterface)(IID * pIID);
    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer ** ppCPC);
    STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    STDMETHOD(Unadvise)(DWORD dwCookie);
    STDMETHOD(EnumConnections)(LPENUMCONNECTIONS * ppEnum);

    CScriptSite *_pSite;
};


//+---------------------------------------------------------------------------
//
//  Class:      CMTEventSink (ces)
//
//  Purpose:    Class which sinks events from objects registered with
//              RegisterEventSource().
//
//----------------------------------------------------------------------------

class CScriptEventSink : public IDispatch
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CScriptEventSink(CScriptHost *pSH);
   ~CScriptEventSink();

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN(CScriptEventSink);

    HRESULT Connect(IDispatch *pSource, BSTR bstrProgID);
    void    Disconnect();

    BOOL    IsThisYourSource(IDispatch * pSource)
                { return pSource == _pDispSource; }

    // IDispatch interface

    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

private:

    CScriptHost * _pSH;
    IDispatch   * _pDispSource;
    DWORD         _dwSinkCookie;
    IID           _clsidEvents;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4115) /* named type definition in parentheses                                  */
#pragma warning(disable:4127) /* conditional expression is constant                                    */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4552) /* operator has no effect; expected operator with side-effect            */
#pragma warning(disable:4553) /* operator has no effect; did you intend '='?                           */
#pragma warning(disable:4705) /* statement has no effect                                               */
#pragma warning(disable:4710) /* function call not expanded                                            */
#pragma warning(disable:4711) /* function 'function' selected for inline expansion                     */
#pragma warning(disable:4068) /* unknown pragma */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */

/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */
#pragma warning(error:4259) /* pure virtual function not defined                                       */

#pragma warning(error:4102) /* 'label' : unreferenced label                                            */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */

// #pragma warning(3:4127) /* conditional expression is constant                                          */
#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#pragma warning(disable:4798) /* pcode: constructors and destructors have native code generated        */
#endif

#ifdef _M_PPC
#pragma warning(disable:4701) /* local variable  may be used without having been initialized           */
#endif

#ifdef _M_IA64
#pragma warning(disable:4268) /* 'variable' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\statusdialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       statusdialog.h
//
//  Contents:   Contains the CStatusDialog class
//
//----------------------------------------------------------------------------
#ifndef STATUSDIALOG_H
#define STATUSDIALOG_H

#include "Resizer.h"

#define MAX_STATUS_MESSAGES 300

class CMTScript;

class CCustomListBox
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();
    CCustomListBox();
    ~CCustomListBox();

    void Refresh() const
    {
        if (_hwnd)
            InvalidateRect(_hwnd, 0, 0);
    }
    // Add another string
    void AppendString(const TCHAR *sz);

    // Change or add a string at a given position.
    void SetString(int nItem, const TCHAR *sz);

    // Shorten the list of strings.
    void SetEnd(int nItems);

    // Clear the contents of the listbox
    void ResetContent();

    // Handle windows messages for this control.
    void Init(HWND dlg, UINT idCtrl);
    void Destroy()
    {
        _hwnd = 0;
    }
    void DrawItem(DRAWITEMSTRUCT *pdis) ;
    void MeasureItem(MEASUREITEMSTRUCT *pmis);
    const TCHAR *GetString(int nItem);
    LRESULT SendMessage(UINT Msg, WPARAM wParam, LPARAM lParam)
    {
        return ::SendMessage(_hwnd, Msg, wParam, lParam);
    }
private:
    HWND _hwnd;                  // The handle to this list

    CPtrAry<TCHAR *> _Messages;
    int _nAllocatedMessageLength;
    int _nExtent;                 // the width of the listbox
};

class CStatusDialog
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    CStatusDialog(HWND parent, CMTScript *pMTScript);
    ~CStatusDialog();
    bool Show();

    BOOL IsDialogMessage(MSG *msg);
    void OUTPUTDEBUGSTRING(LPWSTR pszMsg);
    void Refresh();
    void Pause();
    void Restart();

private:

    HWND _parent;                 // Parent window
    HWND _hwnd;                   // me
    WINDOWPLACEMENT _WindowPlacement; // my current size & position
    BOOL _fMaximized;
    RECT _rect;                   // my current size & position
    BOOL _fStatusOpen;            // Used for registry IO
    BOOL _fLogToFile;             // if logging to a file is enabled
    CStr _cstrLogFileName;        // The name of the log file
    BOOL _fPaused;                // Used by Pause/Restart
    CMTScript *_pMTScript;        // Used to retrieve status info
    TCHAR _achLogFileName[MAX_PATH];
    bool _fCreatedLogFileName;    // Have we created the filename for the logfile yet?
    bool _fAddedHeaderToFile;     // Have we put a timestamp line into the logfile yet?

    CCustomListBox _CScriptListBox;
    CCustomListBox _CProcessListBox;
    CCustomListBox _CSignalListBox;
    CCustomListBox _COutputListBox;

    POINT _InitialSize;
    CResizer _Resizer;

    // message handlers
    void InitDialog();
    void Destroy();
    void Resize(int width, int height);
    void GetMinMaxInfo(MINMAXINFO *mmi);
    CCustomListBox *CtrlIDToListBox(UINT CtrlID);
    HRESULT UpdateOptionSettings(BOOL fSave);

    static BOOL CALLBACK DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void PopulateScripts();
    void PopulateSignals();
    void PopulateProcesses();
    void ClearOutput();

    void ToggleSignal();
    void UpdateLogging();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\thrdcomm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       thrdcomm.h
//
//  Contents:   Contains the inter-thread communication class
//
//----------------------------------------------------------------------------


//****************************************************************************
//
// Forward declarations
//
//****************************************************************************

class CThreadComm;


//****************************************************************************
//
// Classes
//
//****************************************************************************

//+---------------------------------------------------------------------------
//
//  Class:      CThreadComm (ctc)
//
//  Purpose:    Base class which handles cross-thread communication. This
//              is the only class with methods that can safely be called
//              by any thread. All other classes must have their methods
//              called by their owning thread (except the ctor/dtor and Init
//              which are called by the creating thread).
//
//----------------------------------------------------------------------------

class CThreadComm : public IUnknown, public CThreadLock
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE();

    // Thread-unsafe member functions - can only be called by owning (or
    // creating) thread.

    CThreadComm();
   ~CThreadComm();

    HRESULT      StartThread(void * pvParams);
    BOOL         Shutdown(CThreadComm * pTarget);

    static DWORD  TempThreadRoutine(LPVOID pvParam);
    virtual DWORD ThreadMain() = 0;
    // Used to tell StartThread that the new thread is going and has picked
    // up all of its parameters.
    // If fSuccess is false, then the thread will be terminating
    // immediatly, and StartThread() will wait for it to do so.
    void         ThreadStarted(HRESULT hrThread) {
                                   _hrThread = hrThread;
                                   SetEvent(_hThreadReady); // Signal the other thread
                                   ::Sleep(100);          // Yield to the other thread
                                 }

    BOOL GetNextMsg(THREADMSG *tm, void * pData, DWORD *cbData);
    void Reply(DWORD dwReply);

    void SetName(LPCSTR szName);

    // -----------------------------------------------------------------
    //
    // Thread-safe member functions - can be called by any thread.

    HANDLE hThread() { return _hThread; }

    void  PostToThread(CThreadComm *pTarget, THREADMSG tm, void * pData = NULL, DWORD cbData = 0);
    DWORD SendToThread(CThreadComm *pTarget, THREADMSG tm, void * pData = NULL, DWORD cbData = 0);

    // End of thread-safe member list
    //
    // -----------------------------------------------------------------

protected:
    virtual BOOL Init();

    //
    // Every method on objects that derive from CThreadComm should have
    // VERIFY_THREAD at the beginning. VERIFY_THREAD ensures that the proper
    // thread is calling the method (i.e. it ensure that proper apartment rules
    // are being followed.)
    //
    inline void VERIFY_THREAD() { Assert(GetCurrentThreadId() == _dwThreadId); }

    HANDLE           _hThreadReady; // Event signaled when the new thread has set its return value
    HANDLE           _hCommEvent; // Event signaled when there is a message
    DWORD            _dwThreadId;
    HANDLE           _hThread;
    void *           _pvParams;
    HRESULT          _hrThread;   // The new thread sets this for initial success/failure.
private:

    //
    // MSGDATABUFSIZE: Max size of a thread message. The -40 is to keep the
    // MESSAGEDATA struct below 1K.
    //
    #define MSGDATABUFSIZE  (1024 - 40)

    //
    // MESSAGEDATA: All the data associated with a thread message.
    //
    struct MESSAGEDATA
    {
        MESSAGEDATA *pNext;
        THREADMSG    tmMessage;
        DWORD        dwResult;
        HANDLE       hResultEvt;
        DWORD        cbData;
        BYTE         bData[MSGDATABUFSIZE];
    };

#if DBG == 1
    typedef struct tagTHREADNAME_INFO
    {
            DWORD    dwType; // == 0x1000
            LPCSTR   szName;
            DWORD    dwThreadID;
            DWORD    dwFlags;
    } THREADNAME_INFO;
#endif

    DWORD SendHelper(THREADMSG tm,
                     void *    pData,
                     DWORD     cbData,
                     BOOL      fSend,
                     HANDLE    hResultEvt);

    // ***************************
    //   THREAD-SAFE MEMBER DATA
    //   All access to the following members must be protected by LOCK_LOCALS()
    //
    MESSAGEDATA     *_pMsgData;   // Linked list of messages
    BOOL             _fInSend;    // True if we're inside SendToThread -
                                  //   needed to catch deadlock situations.
    MESSAGEDATA    * _pMsgReply;  // Place where we need to put our reply
    HANDLE           _hResultEvt; // Event used to indicate that the result
                                  //   is ready.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\inc\types.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       types.h
//
//  Contents:   Various type definitions
//
//----------------------------------------------------------------------------

#include "config.h"
#include "msgbox.h"
#include "dispid.h"

//****************************************************************************
//
// Defines
//
//****************************************************************************

#define IDR_MAINMENU   100

#define IDM_EXIT       300
#define IDM_CONFIGURE  301
#define IDM_ABOUT      302
#define IDM_TRACETAG   303
#define IDM_MEMORYMON  304
#define IDM_RESTART    305
#define IDM_STATUS     306

#define VB_TRUE     ((VARIANT_BOOL)-1)           // TRUE for VARIANT_BOOL
#define VB_FALSE    ((VARIANT_BOOL)0)            // FALSE for VARIANT_BOOL

#define SZ_APPLICATION_NAME TEXT("MTScript")
#define SZ_WNDCLASS SZ_APPLICATION_NAME TEXT("_HiddenWindow")

#ifndef RC_INVOKED

//****************************************************************************
//
// Globals
//
//****************************************************************************

extern HANDLE    g_hProcHeap;  // Handle to process heap.
extern HINSTANCE g_hInstance;  // Instance handle of this EXE


//****************************************************************************
//
// Function prototypes
//
//****************************************************************************

void ErrorPopup(LPWSTR pszMsg);

#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

void ClearInterfaceFn(IUnknown **ppUnk);

template <class PI>
inline void
ClearInterface(PI * ppI)
{
    ClearInterfaceFn((IUnknown **) ppI);
}

#define ReleaseInterface(x) if (x) { (x)->Release(); }

#define ULREF_IN_DESTRUCTOR 256

#define DECLARE_STANDARD_IUNKNOWN(cls)                              \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppv);          \
    ULONG _ulRefs;                                                  \
    STDMETHOD_(ULONG, AddRef) (void)                                \
        {                                                           \
            return InterlockedIncrement((long*)&_ulRefs);           \
        }                                                           \
    STDMETHOD_(ULONG, Release) (void)                               \
        {                                                           \
            if (InterlockedDecrement((long*)&_ulRefs) == 0)         \
            {                                                       \
                _ulRefs = ULREF_IN_DESTRUCTOR;                      \
                delete this;                                        \
                return 0;                                           \
            }                                                       \
            return _ulRefs;                                         \
        }                                                           \
    ULONG GetRefs(void)                                             \
        { return _ulRefs; }

//****************************************************************************
//
// Enums and Structs
//
//****************************************************************************

//
// THREADMSG -- messages that can be sent between threads.
//
enum THREADMSG
{
    MD_SECONDARYSCRIPTTERMINATE,
    MD_MACHINECONNECT,
    MD_MACHEVENTCALL,
    MD_NOTIFYSCRIPT,
    MD_REBOOT,
    MD_RESTART,
    MD_PROCESSEXITED,
    MD_PROCESSTERMINATED,
    MD_PROCESSCRASHED,
    MD_PROCESSCONNECTED,
    MD_PROCESSDATA,
    MD_SENDTOPROCESS,
    MD_OUTPUTDEBUGSTRING,
    MD_PLEASEEXIT
};

enum MBT_SELECT
{
    MBTS_TIMEOUT = 0,
    MBTS_BUTTON1 = 1,
    MBTS_BUTTON2 = 2,
    MBTS_BUTTON3 = 3,
    MBTS_BUTTON4 = 4,
    MBTS_BUTTON5 = 5,
    MBTS_INTERVAL,
    MBTS_ERROR
};

struct MBTIMEOUT
{
    BSTR   bstrMessage;
    long   cButtons;
    BSTR   bstrButtonText;
    long   lTimeout;
    long   lEventInterval;
    BOOL   fCanCancel;
    BOOL   fConfirm;

    HANDLE     hEvent;
    MBT_SELECT mbts;
};

struct SCRIPT_PARAMS
{
    LPTSTR   pszPath;
    VARIANT *pvarParams;
};

struct PROCESS_PARAMS
{
    LPTSTR   pszCommand;
    LPTSTR   pszDir;
    LPTSTR   pszTitle;
    BOOL     fMinimize;
    BOOL     fGetOutput;
    BOOL     fNoEnviron;
    BOOL     fNoCrashPopup;
};

struct MACHPROC_EVENT_DATA
{
    HANDLE    hEvent;
    DWORD     dwProcId;
    BSTR      bstrCmd;
    BSTR      bstrParams;
    VARIANT * pvReturn;
    DWORD     dwGITCookie;
    HRESULT   hrReturn;
};

#endif // RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\localobj\makefile.inc ===
$(O)\selfreg_mtlocal.inf : selfreg.inx
    cleaninf.exe -w selfreg.inx $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\localobj\factory.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       factory.cxx
//
//  Contents:   Contains the class factory implementation and other DLL
//              functions for the mtlocal DLL.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "mtscript.h"    // MIDL generated file
#include "localobj.h"

#include <advpub.h>     // for RegInstall

HINSTANCE   g_hInstDll;
HINSTANCE   g_hinstAdvPack = NULL;
REGINSTALL  g_pfnRegInstall = NULL;

// Globals used by our utilities.

DWORD           g_dwFALSE      = 0;
EXTERN_C HANDLE g_hProcessHeap = NULL;

// Global class factory

CMTLocalFactory g_LocalFactory;

// ***************************************************************

CMTLocalFactory::CMTLocalFactory()
{
    _ulRefs = 0;
}

STDMETHODIMP
CMTLocalFactory::QueryInterface(REFIID iid, void ** ppvObject)
{
    if (iid == IID_IClassFactory || iid == IID_IUnknown)
    {
        *ppvObject = (IClassFactory*)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObject)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTLocalFactory::CreateInstance, public
//
//  Synopsis:   Creates the CLocalMTProxy object
//
//----------------------------------------------------------------------------

STDMETHODIMP
CMTLocalFactory::CreateInstance(IUnknown * pUnkOuter,
                                REFIID     riid,
                                void **    ppvObject)
{
    HRESULT        hr = E_FAIL;
    CLocalMTProxy *pMTP;

    *ppvObject = NULL;

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }

    pMTP = new CLocalMTProxy();
    if (!pMTP)
    {
        return E_OUTOFMEMORY;
    }

    hr = pMTP->QueryInterface(riid, ppvObject);

    pMTP->Release();

#if DBG == 1
    if (hr)
        TraceTag((tagError, "CreateInstance failed with %x", hr));
#endif

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMTLocalFactory::LockServer, public
//
//  Synopsis:   Keeps the DLL from being unloaded
//
//----------------------------------------------------------------------------

STDMETHODIMP
CMTLocalFactory::LockServer(BOOL fLock)
{
    // Because we implement our class factory as a global object, we don't
    // need to worry about keeping it in memory if LockServer is called.

    if (fLock)
    {
        InterlockedIncrement(&g_lObjectCount);
    }
    else
    {
        InterlockedDecrement(&g_lObjectCount);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Main DLL entrypoint.
//
//  Returns:    Doesn't do much except unload advpack.dll if we loaded it.
//
//----------------------------------------------------------------------------

BOOL
WINAPI
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fOk = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstDll = (HINSTANCE)hDll;

        Assert(g_hInstDll != NULL);

        DisableThreadLibraryCalls(g_hInstDll);

        // Set the variable used by our memory allocator.
        g_hProcessHeap = GetProcessHeap();
        break;

    case DLL_PROCESS_DETACH:
        if (g_hinstAdvPack)
        {
            FreeLibrary(g_hinstAdvPack);
        }
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadAdvPack
//
//  Synopsis:   Loads AdvPack.dll for DLL registration.
//
//----------------------------------------------------------------------------

HRESULT
LoadAdvPack()
{
    HRESULT hr = S_OK;

    g_hinstAdvPack = LoadLibrary(_T("ADVPACK.DLL"));

    if (!g_hinstAdvPack)
        goto Error;

    g_pfnRegInstall = (REGINSTALL)GetProcAddress(g_hinstAdvPack, achREGINSTALL);

    if (!g_pfnRegInstall)
        goto Error;

Cleanup:
    return hr;

Error:
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (g_hinstAdvPack)
    {
        FreeLibrary(g_hinstAdvPack);
    }

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Register the various important information needed by our
//              class.
//
//  Notes:      Uses AdvPack.dll and an INF file to do the registration
//
//----------------------------------------------------------------------------

STDAPI
DllRegisterServer()
{
    HRESULT   hr;
    STRTABLE  stReg = { 0, NULL };
    ITypeLib *pTypeLibDLL = NULL;
    TCHAR     achDll[MAX_PATH];

    Assert(g_hInstDll != NULL);

    // Make sure the type library is registered

    GetModuleFileName(g_hInstDll, achDll, MAX_PATH);

    hr = THR(LoadTypeLib(achDll, &pTypeLibDLL));

    if (hr)
        goto Cleanup;

    // This may fail if the user is not an administrator on this machine.
    // It's not a big deal unless they try to run mtscript.exe, but the UI
    // will still work.
    (void) RegisterTypeLib(pTypeLibDLL, achDll, NULL);

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    hr = g_pfnRegInstall(g_hInstDll, "Register", &stReg);

Cleanup:
    if (pTypeLibDLL)
    {
        pTypeLibDLL->Release();
    }

    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+------------------------------------------------------------------------
//
// Function:    DllUnregisterServer
//
// Synopsis:    Undo the actions of DllRegisterServer.
//
//-------------------------------------------------------------------------

STDAPI
DllUnregisterServer()
{
    HRESULT hr;

    STRTABLE stReg = { 0, NULL };

    Assert(g_hInstDll != NULL);

    if (!g_hinstAdvPack)
    {
        hr = LoadAdvPack();
        if (hr)
            goto Cleanup;
    }

    hr = g_pfnRegInstall(g_hInstDll, "Unregister", &stReg);

    // Unregister the type library

    if (!hr)
    {
        (void) UnRegisterTypeLib(LIBID_MTScriptEngine, 1, 0, 0, SYS_WIN32);
    }

Cleanup:
    RegFlushKey(HKEY_CLASSES_ROOT);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Returns the class factory for a particular object
//
//----------------------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppv)
{
    HRESULT hr;

    if (clsid == CLSID_RemoteMTScriptProxy)
    {
        hr = g_LocalFactory.QueryInterface(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates if we can be unloaded.
//
//  Notes:      Returns OK if we currently have no objects running.
//
//----------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    if (g_lObjectCount == 0)
    {
        return S_OK;
    }

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\localobj\object.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       object.cxx
//
//  Contents:   Implementation of the CLocalMTProxy class and
//              associated objects.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "mtscript.h"    // MIDL generated file
#include "localobj.h"

long g_lObjectCount = 0;

// ***********************************************************************
//
// CLocalProxyCP
//
// ConnectionPoint for CLocalMTProxy
//
// ***********************************************************************

CLocalProxyCP::CLocalProxyCP(CLocalMTProxy *pMach)
{
    _ulRefs = 1;
    _pMTProxy = pMach;
    _pMTProxy->AddRef();
}

CLocalProxyCP::~CLocalProxyCP()
{
    _pMTProxy->Release();
}

HRESULT
CLocalProxyCP::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IConnectionPoint)
    {
        *ppv = (IConnectionPoint *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CLocalProxyCP::GetConnectionInterface(IID * pIID)
{
    *pIID = DIID_DRemoteMTScriptEvents;
    return S_OK;
}

HRESULT
CLocalProxyCP::GetConnectionPointContainer(IConnectionPointContainer ** ppCPC)
{
    *ppCPC = _pMTProxy;
    (*ppCPC)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalProxyCP::Advise, public
//
//  Synopsis:   Remembers interface pointers that we want to fire events
//              through.
//
//  Arguments:  [pUnkSink]  -- Pointer to remember
//              [pdwCookie] -- Place to put cookie for Unadvise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CLocalProxyCP::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)
{
    IDispatch *pDisp;
    HRESULT    hr;

    TraceTag((tagError, "CLocalProxyCP::Advise: Advising %p", pUnkSink));

    hr = pUnkSink->QueryInterface(IID_IDispatch, (LPVOID*)&pDisp);
    if (hr)
    {
        return hr;
    }

    // We can only keep one sink at a time.

    ReleaseInterface(_pMTProxy->_pDispSink);

    _pMTProxy->_pDispSink = pDisp;

    *pdwCookie = (DWORD)pDisp;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalProxyCP::Unadvise, public
//
//  Synopsis:   Forgets a pointer we remembered during Advise.
//
//  Arguments:  [dwCookie] -- Cookie returned from Advise
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CLocalProxyCP::Unadvise(DWORD dwCookie)
{
    TraceTag((tagError, "CLocalProxyCP::Unadvise: Unadvising %p", dwCookie));

    if (dwCookie == (DWORD)_pMTProxy->_pDispSink)
    {
        ClearInterface(&_pMTProxy->_pDispSink);
    }
    else
        return E_INVALIDARG;

    return S_OK;
}

HRESULT
CLocalProxyCP::EnumConnections(LPENUMCONNECTIONS * ppEnum)
{
    *ppEnum = NULL;
    RRETURN(E_NOTIMPL);
}

// ***********************************************************************
//
// CLocalMTProxy
//
// ***********************************************************************

CLocalMTProxy::CLocalMTProxy()
{
    _ulRefs = 1;
    _ulAllRefs = 1;

    InterlockedIncrement(&g_lObjectCount);

    Assert(_pTypeInfoInterface == NULL);
    Assert(_pTypeLibDLL == NULL);
}

CLocalMTProxy::~CLocalMTProxy()
{
    ReleaseInterface(_pTypeInfoInterface);
    ReleaseInterface(_pTypeInfoCM);
    ReleaseInterface(_pTypeLibDLL);

    InterlockedDecrement(&g_lObjectCount);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Passivate, public
//
//  Synopsis:   Called when the refcount for CLocalMTProxy goes to zero. This
//              will cause us to let go of all the objects we hold onto, which
//              in turn should cause everyone else to let go of our subobjects.
//              When that happens we can finally delete ourselves.
//
//----------------------------------------------------------------------------

void
CLocalMTProxy::Passivate()
{
    Disconnect();

    ClearInterface(&_pDispSink);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::QueryInterface, public
//
//  Synopsis:   Standard IUnknown::QueryInterface
//
//----------------------------------------------------------------------------

HRESULT
CLocalMTProxy::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IRemoteMTScriptProxy || iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppvObj = (IRemoteMTScriptProxy *)this;
    }
    else if (iid == IID_IConnectionPointContainer)
    {
        *ppvObj = (IConnectionPointContainer *)this;
    }
    else if (iid == IID_IProvideClassInfo)
    {
        *ppvObj = (IProvideClassInfo *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::AddRef, public
//
//  Synopsis:   Standard IUnknown::AddRef. Increments the refcount on the
//              CLocalMTProxy object.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::AddRef()
{
    return ++_ulRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Release, public
//
//  Synopsis:   IUnknown::Release.
//
//  Notes:      If the refcount on CLocalMTProxy goes to zero, we know our
//              owner is done with us and we can clean up. So, we release
//              all our interface pointers and etc. However, someone may still
//              be holding on to our event sink subobject, so we can't
//              delete ourselves yet.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::Release()
{
    ULONG ulRefs = --_ulRefs;

    if (ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;

        Passivate();

        AssertSz(_ulRefs == ULREF_IN_DESTRUCTOR,
                 "NONFATAL: Invalid refcount during passivate!");

        _ulRefs = 0;

        SubRelease();
    }

    return ulRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::SubAddRef, public
//
//  Synopsis:   Called when the event sink gets addref'd. Increments an overall
//              refcount.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::SubAddRef()
{
    return ++_ulAllRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::SubRelease, public
//
//  Synopsis:   Called when the event sink gets released and when
//              CLocalMTProxy passivates.  If the overall refcount is zero,
//              we know no-one is using us and we can go away.
//
//----------------------------------------------------------------------------

ULONG
CLocalMTProxy::SubRelease()
{
    if (--_ulAllRefs == 0)
    {
        _ulAllRefs = ULREF_IN_DESTRUCTOR;
        _ulRefs = ULREF_IN_DESTRUCTOR;
        delete this;
    }

    return 0;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::EnumConnectionPoints, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::EnumConnectionPoints(LPENUMCONNECTIONPOINTS *)
{
    return E_NOTIMPL;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::FindConnectionPoint, IConnectionPointContainer
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT* ppCpOut)
{
    HRESULT hr;

    TraceTag((tagError, "CLocalMTProxy::FindConnectionPoint called."));

    if (iid == DIID_DRemoteMTScriptEvents || iid == IID_IDispatch)
    {
        TraceTag((tagError, "CLocalMTProxy::FindConnectionPoint: Returning event source."));

        *ppCpOut = new CLocalProxyCP(this);
        hr = *ppCpOut ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::GetClassInfo, public
//
//  Synopsis:   Implementation of IProvideClassInfo
//
//  Arguments:  [pTI] -- Return type info interface here
//
//  Notes:      This returns the typeinfo for the RemoteMTScriptProxy coclass
//
//----------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetClassInfo(ITypeInfo **pTI)
{
    HRESULT hr;

    TraceTag((tagError, "CLocalMTProxy::GetClassInfo called"));

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    hr = _pTypeLibDLL->GetTypeInfoOfGuid(CLSID_RemoteMTScriptProxy, pTI);

    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::GetTypeInfo, IDispatch
//
//  Notes:  This returns the typeinfo for the IRemoteMTScriptProxy dual
//          interface.
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    HRESULT hr;

    TraceTag((tagError, "CLocalMTProxy::GetTypeInfo called"));

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    *pptinfo = _pTypeInfoInterface;
    (*pptinfo)->AddRef();

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    HRESULT hr;

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    hr = _pTypeInfoInterface->GetIDsOfNames(rgszNames, cNames, rgdispid);

    if (hr && _pDispRemote)
    {
        hr = _pTypeInfoCM->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }

    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CLocalMTProxy::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CLocalMTProxy::Invoke(DISPID dispidMember,
                      REFIID riid,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      UINT * puArgErr)
{
    HRESULT hr;

    hr = LoadTypeLibs();
    if (hr)
        return hr;

    hr = _pTypeInfoInterface->Invoke((IRemoteMTScriptProxy *)this,
                                     dispidMember,
                                     wFlags,
                                     pdispparams,
                                     pvarResult,
                                     pexcepinfo,
                                     puArgErr);
    //
    // If we're connected to the remote object, then we forward any calls
    // we don't know how to handle on to that object. This is not aggregation,
    // since we have not set up object identity in this relationship.
    //
    if (hr && _pDispRemote)
    {
        hr = _pDispRemote->Invoke(dispidMember,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  puArgErr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::LoadTypeLibs, public
//
//  Synopsis:   Ensures that we have loaded our typelibrary
//
//----------------------------------------------------------------------------

HRESULT
CLocalMTProxy::LoadTypeLibs()
{
    HRESULT hr = S_OK;
    TCHAR   achDll[MAX_PATH];

    if (!_pTypeLibDLL)
    {
        GetModuleFileName(g_hInstDll, achDll, MAX_PATH);

        hr = THR(LoadTypeLib(achDll, &_pTypeLibDLL));

        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoInterface)
    {
        hr = THR(_pTypeLibDLL->GetTypeInfoOfGuid(IID_IRemoteMTScriptProxy,
                                                 &_pTypeInfoInterface));
        if (hr)
            goto Cleanup;
    }

    if (!_pTypeInfoCM)
    {
        hr = THR(_pTypeLibDLL->GetTypeInfoOfGuid(IID_IConnectedMachine,
                                                 &_pTypeInfoCM));
        if (hr)
            goto Cleanup;
    }

Cleanup:

    if (hr)
    {
        TraceTag((tagError, "CLocalMTProxy::LoadTypeLibs returning %x", hr));
    }

    return hr;
}

// *************************************************************************

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Connect, public
//
//  Synopsis:   Connects to the RemoteMTScript object on the given remote
//              (or local) machine.
//
//  Arguments:  [bstrMachine] -- Machine to connect to. If NULL or empty,
//                               use the local machine.
//
//  Returns:    HRESULT
//
//  Notes:      This also sets up the event sink for handling events.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CLocalMTProxy::Connect(BSTR bstrMachine)
{
    HRESULT      hr = S_OK;
    COSERVERINFO csi = { 0 };
    MULTI_QI     mqi[2] = { 0 };
    BOOL         fRemote = TRUE;

    // IConnectionPointContainer *pCPC;
    // IConnectionPoint          *pCP;

    if (!bstrMachine || SysStringLen(bstrMachine) == 0)
    {
        fRemote = FALSE;
    }

    TraceTag((tagError, "CLocalMTProxy::Connect called. Machine=%ls", (fRemote) ? bstrMachine : L"<local>"));

    // The following code will remove all security from the connection. This
    // will need to be enabled if the corresponding call to CoInitializeSecurity
    // is turned on in mtscript.exe.

    // Remove security for the connection.

    csi.pAuthInfo = NULL;

    csi.pwszName = bstrMachine;

    mqi[0].pIID = &IID_IDispatch;
    // mqi[1].pIID = &IID_IConnectionPointContainer;

    hr = CoCreateInstanceEx(CLSID_RemoteMTScript,
                            NULL,
                            CLSCTX_SERVER,
                            (fRemote) ? &csi : NULL,
                            1,
                            mqi);
    if (FAILED(hr))
    {
        TraceTag((tagError, "CLocalMTProxy::Connect: CoCreateInstanceEx returned=%x", hr));
        return hr;
    }

    if (mqi[0].hr)
        return mqi[0].hr;

    _pDispRemote = (IDispatch *)mqi[0].pItf;

/*
    // Security problems make it difficult to impossible to make a
    // reverse COM event interface connect successfully.

    if (!mqi[1].hr)
    {
        pCPC = (IConnectionPointContainer *)mqi[1].pItf;


        hr = pCPC->FindConnectionPoint(DIID_DRemoteMTScriptEvents, &pCP);
        if (!hr)
        {
            hr = pCP->Advise(&_cesSink, &_dwSinkCookie);

            ReleaseInterface(pCP);
        }

        ReleaseInterface(pCPC);

#if DBG == 1
        if (hr)
            TraceTag((tagError, "Hookup to event sink returned %x", hr));
#endif

        // If the advise failed for some reason, just don't sink events.
    }
    else
    {
        TraceTag((tagError, "CLocalMTProxy::Connect: ICPC QI returned=%x", mqi[1].hr));
    }
*/

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::Disconnect, public
//
//  Synopsis:   Disconnects from a machine we connected to via Connect().
//
//  Arguments:  (none)
//
//----------------------------------------------------------------------------

STDMETHODIMP
CLocalMTProxy::Disconnect()
{
    HRESULT hr = S_OK;

    TraceTag((tagError, "CLocalMTProxy::Disconnect called"));

    if (_dwSinkCookie)
    {
        IConnectionPointContainer *pCPC;
        IConnectionPoint          *pCP;

        hr = _pDispRemote->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pCPC);
        if (!hr)
        {
            hr = pCPC->FindConnectionPoint(DIID_DRemoteMTScriptEvents,
                                           &pCP);
            if (!hr)
            {
                pCP->Unadvise(_dwSinkCookie);

                ReleaseInterface(pCP);
            }

            ReleaseInterface(pCPC);

#if DBG == 1
            if (hr)
                TraceTag((tagError, "Unadvise from event sink returned %x", hr));
#endif
        }

        _dwSinkCookie = 0;
    }

    ClearInterface(&_pDispRemote);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLocalMTProxy::DownloadFile, public
//
//  Synopsis:   Downloads a file from the given URL and stores it locally.
//
//  Arguments:  [bstrURL]  -- URL to download
//              [bstrFile] -- Path of where the file was saved by urlmon
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

STDMETHODIMP
CLocalMTProxy::DownloadFile(BSTR bstrURL, BSTR *bstrFile)
{
    HRESULT hr;
    TCHAR   achBuf[MAX_PATH * 2];


    hr = URLDownloadToCacheFile((IRemoteMTScriptProxy*)this,
                                bstrURL,
                                achBuf,
                                MAX_PATH * 2,
                                0,
                                NULL);
    if (hr)
    {
        int       cChar;
        HINSTANCE hModURLMON = LoadLibraryA("urlmon.dll");

        cChar = wsprintf(achBuf, L"Error: (%x) ", hr);

        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                      FORMAT_MESSAGE_FROM_HMODULE |
                      FORMAT_MESSAGE_IGNORE_INSERTS,
                      hModURLMON,
                      hr,
                      0,
                      achBuf + cChar,
                      MAX_PATH * 2 - cChar,
                      NULL);

        FreeLibrary(hModURLMON);
    }

    *bstrFile = SysAllocString(achBuf);

    return S_OK;
}

// *************************************************************************
//
// CMTEventSink
//
// Class which implements the event sink for the remote object. This just
// forwards all calls to the event sink registered with us by the web page,
// if any.
//
// *************************************************************************

HRESULT
CMTEventSink::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppv = (IDispatch *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    if (Proxy()->_pDispSink)
    {
        return Proxy()->_pDispSink->GetTypeInfo(itinfo, lcid, pptinfo);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::GetTypeInfoCount(UINT * pctinfo)
{
    if (Proxy()->_pDispSink)
    {
        return Proxy()->_pDispSink->GetTypeInfoCount(pctinfo);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::GetIDsOfNames(REFIID riid,
                            LPOLESTR * rgszNames,
                            UINT cNames,
                            LCID lcid,
                            DISPID * rgdispid)
{
    if (Proxy()->_pDispSink)
    {
        return Proxy()->_pDispSink->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }

    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CMTEventSink::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CMTEventSink::Invoke(DISPID dispidMember,
                      REFIID riid,
                      LCID lcid,
                      WORD wFlags,
                      DISPPARAMS * pdispparams,
                      VARIANT * pvarResult,
                      EXCEPINFO * pexcepinfo,
                      UINT * puArgErr)
{
    TraceTag((tagError, "CMTEventSink::Invoke called"));

    if (Proxy()->_pDispSink)
    {
        HRESULT hr;

        hr = Proxy()->_pDispSink->Invoke(dispidMember,
                                  riid,
                                  lcid,
                                  wFlags,
                                  pdispparams,
                                  pvarResult,
                                  pexcepinfo,
                                  puArgErr);
        if (hr)
        {
            TraceTag((tagError, "CMTEventSink::Invoke: Sink call returned %x!", hr));
        }
    }

    TraceTag((tagError, "CMTEventSink::Invoke returning"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\scrhost\automation.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       bsauto.cxx
//
//-------------------------------------------------------------------------

#include "headers.hxx"
#include <mapi.h>

#undef ASSERT

DeclareTag(tagSync, "MTScript", "Trace Thread Sync events");
DeclareTag(tagLock, "MTScript", "Trace Thread Lock events");
ExternTag(tagProcess);

AutoCriticalSection CScriptHost::s_csSync;
CStackDataAry<CScriptHost::SYNCEVENT, 5> CScriptHost::s_arySyncEvents;

CScriptHost::THREADLOCK CScriptHost::s_aThreadLocks[MAX_LOCKS];
UINT CScriptHost::s_cThreadLocks = 0;

static const wchar_t *g_pszListDeliminator = L";,";
static wchar_t *g_pszAtomicSyncLock = L"g_pszAtomicSyncLock";
//---------------------------------------------------------------------------
//
//  Member: CScriptHost::GetTypeInfo, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::GetTypeInfo(UINT itinfo, ULONG lcid, ITypeInfo ** pptinfo)
{
    VERIFY_THREAD();

    HRESULT hr;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    *pptinfo = _pTypeInfoIGlobalMTScript;
    (*pptinfo)->AddRef();

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::GetTypeInfoCount, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::GetTypeInfoCount(UINT * pctinfo)
{
    VERIFY_THREAD();

    *pctinfo = 1;
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::GetIDsOfNames, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::GetIDsOfNames(REFIID riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid)
{
    VERIFY_THREAD();

    HRESULT hr;

    hr = THR(LoadTypeLibrary());
    if (hr)
        goto Cleanup;

    hr = _pTypeInfoIGlobalMTScript->GetIDsOfNames(rgszNames, cNames, rgdispid);

Cleanup:
    return hr;
}

//---------------------------------------------------------------------------
//
//  Member: CScriptHost::Invoke, IDispatch
//
//---------------------------------------------------------------------------

HRESULT
CScriptHost::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,DISPPARAMS * pdispparams, VARIANT * pvarResult,EXCEPINFO * pexcepinfo, UINT * puArgErr)
{
    VERIFY_THREAD();

    HRESULT hr;

    hr = LoadTypeLibrary();
    if (hr)
        goto Cleanup;

    hr = _pTypeInfoIGlobalMTScript->Invoke((IGlobalMTScript *)this, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

Cleanup:
    return hr;
}

//***************************************************************************
//
//  IGlobalMTScript implementation
//
//***************************************************************************

HRESULT
CScriptHost::get_PublicData(VARIANT * pvData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // NOTE: We assume that the output parameter pvData is an empty or
    // uninitialized VARIANT. This should be safe because it is defined as
    // the return value for this method to the scripting engines and is
    // a pure [out] parameter.

    VariantInit(pvData);

    // Check to see if the data has changed since we last got it.
    // _dwPublicSerialNum is a DWORD so we are guaranteed an atomic read.

    if (_pMT->_dwPublicSerialNum != _dwPublicSN)
    {
        LOCK_LOCALS(_pMT);

        VariantClear(&_vPubCache);

        // If the data is an IDispatch pointer (how the scripting engines
        // implement most objects) we must get a marshalled copy to this thread.
        // Otherwise we can just copy the data into the return value.

        if (V_VT(&_pMT->_vPublicData) == VT_DISPATCH)
        {
            IDispatch *pDisp;

            Assert(_pMT->_dwPublicDataCookie != 0);

            hr = _pMT->_pGIT->GetInterfaceFromGlobal(_pMT->_dwPublicDataCookie,
                                                     IID_IDispatch,
                                                     (LPVOID*)&pDisp);
            if (!hr)
            {
                V_VT(&_vPubCache)       = VT_DISPATCH;
                V_DISPATCH(&_vPubCache) = pDisp;
            }
        }
        else
        {
            hr = VariantCopy(&_vPubCache, &_pMT->_vPublicData);
        }

        _dwPublicSN = _pMT->_dwPublicSerialNum;
    }

    if (!hr)
    {
        hr = VariantCopy(pvData, &_vPubCache);
    }

    return hr;
}

HRESULT
CScriptHost::put_PublicData(VARIANT vData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // Check for data types which we don't support.
    if (   V_ISBYREF(&vData)
        || V_ISARRAY(&vData)
        || V_ISVECTOR(&vData)
        || V_VT(&vData) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    LOCK_LOCALS(_pMT);

    // If the previous data is an IDispatch pointer revoke it from the
    // GlobalInterfaceTable.

    if (V_VT(&_pMT->_vPublicData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPublicDataCookie != 0);

        hr = _pMT->_pGIT->RevokeInterfaceFromGlobal(_pMT->_dwPublicDataCookie);

        AssertSz(!hr, "Unexpected failure revoking itf from GIT");

        _pMT->_dwPublicDataCookie = 0;
    }

    // If the new data is an IDispatch pointer then we must register it.

    if (V_VT(&vData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPublicDataCookie == 0);

        hr = _pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(&vData),
                                                    IID_IDispatch,
                                                    &_pMT->_dwPublicDataCookie);

        AssertSz(!hr, "Unexpected failure registering itf in GIT");
    }

    //  Update the global copy of the data.

    //$ FUTURE: This can be optimized to reduce memory usage (by not making
    //  a copy of a string in every thread, for example).

    _pMT->_dwPublicSerialNum++;
    hr = VariantCopy(&_pMT->_vPublicData, &vData);

    if (!hr)
    {
        // Even if it's an IDispatch, we don't need to marshal it for
        // ourselves because we're running in the same thread as the script
        // engine that gave it to us.
        hr = VariantCopy(&_vPubCache, &vData);

        _dwPublicSN = _pMT->_dwPublicSerialNum;
    }

    return S_OK;
}

HRESULT
CScriptHost::get_PrivateData(VARIANT * pvData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // NOTE: We assume that the output parameter pvData is an empty or
    // uninitialized VARIANT. This should be safe because it is defined as
    // the return value for this method to the scripting engines and is
    // a pure [out] parameter.

    VariantInit(pvData);

    // Check to see if the data has changed since we last got it.
    // _dwPrivateSerialNum is a DWORD so we are guaranteed an atomic read.

    if (_pMT->_dwPrivateSerialNum != _dwPrivateSN)
    {
        LOCK_LOCALS(_pMT);

        VariantClear(&_vPrivCache);

        // If the data is an IDispatch pointer (how the scripting engines
        // implement most objects) we must get a marshalled copy to this thread.
        // Otherwise we can just copy the data into the return value.

        if (V_VT(&_pMT->_vPrivateData) == VT_DISPATCH)
        {
            IDispatch *pDisp;

            Assert(_pMT->_dwPrivateDataCookie != 0);

            hr = _pMT->_pGIT->GetInterfaceFromGlobal(_pMT->_dwPrivateDataCookie,
                                                     IID_IDispatch,
                                                     (LPVOID*)&pDisp);
            if (!hr)
            {
                V_VT(&_vPrivCache)       = VT_DISPATCH;
                V_DISPATCH(&_vPrivCache) = pDisp;
            }
        }
        else
        {
            hr = VariantCopy(&_vPrivCache, &_pMT->_vPrivateData);
        }

        _dwPrivateSN = _pMT->_dwPrivateSerialNum;
    }

    if (!hr)
    {
        hr = VariantCopy(pvData, &_vPrivCache);
    }

    return hr;
}

HRESULT
CScriptHost::put_PrivateData(VARIANT vData)
{
    VERIFY_THREAD();

    HRESULT hr = S_OK;

    // Check for data types which we don't support.
    if (   V_ISBYREF(&vData)
        || V_ISARRAY(&vData)
        || V_ISVECTOR(&vData)
        || V_VT(&vData) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    LOCK_LOCALS(_pMT);

    // If the previous data is an IDispatch pointer revoke it from the
    // GlobalInterfaceTable.

    if (V_VT(&_pMT->_vPrivateData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPrivateDataCookie != 0);

        hr = _pMT->_pGIT->RevokeInterfaceFromGlobal(_pMT->_dwPrivateDataCookie);

        AssertSz(!hr, "Unexpected failure revoking itf from GIT");

        _pMT->_dwPrivateDataCookie = 0;
    }

    // If the new data is an IDispatch pointer then we must register it.

    if (V_VT(&vData) == VT_DISPATCH)
    {
        Assert(_pMT->_dwPrivateDataCookie == 0);

        hr = _pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(&vData),
                                                    IID_IDispatch,
                                                    &_pMT->_dwPrivateDataCookie);

        AssertSz(!hr, "Unexpected failure registering itf in GIT");
    }

    //  Update the global copy of the data.

    //$ FUTURE: This can be optimized to reduce memory usage (by not making
    //  a copy of a string in every thread, for example).

    _pMT->_dwPrivateSerialNum++;
    hr = VariantCopy(&_pMT->_vPrivateData, &vData);

    if (!hr)
    {
        // Even if it's an IDispatch, we don't need to marshal it for
        // ourselves because we're running in the same thread as the script
        // engine that gave it to us.
        hr = VariantCopy(&_vPrivCache, &vData);

        _dwPrivateSN = _pMT->_dwPrivateSerialNum;
    }

    return S_OK;
}

HRESULT
CScriptHost::ExitProcess()
{
    VERIFY_THREAD();

    PostToThread(_pMT, MD_PLEASEEXIT);

    return S_OK;
}

HRESULT
CScriptHost::Restart()
{
    VERIFY_THREAD();

    PostToThread(_pMT, MD_RESTART);

    return S_OK;
}

HRESULT
CScriptHost::get_LocalMachine(BSTR *pbstrName)
{
    TCHAR achCompName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwLen = MAX_COMPUTERNAME_LENGTH+1;

    VERIFY_THREAD();

    if (!pbstrName)
        return E_POINTER;

    GetComputerName(achCompName, &dwLen);

    achCompName[dwLen] = '\0';

    *pbstrName = SysAllocString(achCompName);
    if (!*pbstrName)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CScriptHost::Include(BSTR bstrPath)
{
    VERIFY_THREAD();

    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    //$ TODO: Define a new named item context for the included file for better
    // debugging.
    hr = THR(GetSite()->ExecuteScriptFile(bstrPath));

    return hr;
}

HRESULT
CScriptHost::CallScript(BSTR bstrPath, VARIANT *pvarScriptParam)
{
    VERIFY_THREAD();

    HRESULT hr;

    if(!bstrPath)
        return E_INVALIDARG;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    hr = THR(PushScript(_tcsrchr(bstrPath, _T('.'))));
    if(hr)
        goto Cleanup;

     if (pvarScriptParam && pvarScriptParam->vt != VT_ERROR)
    {
        hr = THR(VariantCopy(&GetSite()->_varParam, pvarScriptParam));
        if (hr)
            goto Cleanup;
    }

    hr = THR(GetSite()->ExecuteScriptFile(bstrPath));

    hr = THR(GetSite()->SetScriptState(SCRIPTSTATE_CONNECTED));
    if (hr)
        goto Cleanup;

    FireEvent(DISPID_MTScript_ScriptMain, 0, NULL);

    PopScript();

Cleanup:
    return hr;
}

HRESULT
CScriptHost::SpawnScript(BSTR bstrPath, VARIANT *pvarScriptParam)
{
    VERIFY_THREAD();

    HRESULT  hr = S_OK;
    VARIANT *pvarParam = NULL;
    DWORD dwCookie = 0;
    BOOL  fRegistered = false;

    // Check for data types which we don't support.
    if (   !bstrPath
        || SysStringLen(bstrPath) == 0
        || V_ISBYREF(pvarScriptParam)
        || V_ISARRAY(pvarScriptParam)
        || V_ISVECTOR(pvarScriptParam)
        || V_VT(pvarScriptParam) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (pvarScriptParam && pvarScriptParam->vt != VT_ERROR)
    {
        pvarParam = new VARIANT;

        if (!pvarParam)
            return E_OUTOFMEMORY;

        VariantInit(pvarParam);

        if (V_VT(pvarScriptParam) == VT_DISPATCH)
        {
            // Stick the pointer in the GlobalInterfaceTable, so the other
            // thread can pull it out safely.

            hr = _pMT->_pGIT->RegisterInterfaceInGlobal(V_DISPATCH(pvarScriptParam),
                                                        IID_IDispatch,
                                                        &dwCookie);
            if (hr)
                goto Cleanup;

            // Stick the cookie in the variant we hand to the other thread.

            V_VT(pvarParam) = VT_DISPATCH;
            V_I4(pvarParam) = dwCookie;
            fRegistered = true;
        }
        else
        {
            hr = THR(VariantCopy(pvarParam, pvarScriptParam));
            if (hr)
                goto Cleanup;
        }
    }
    hr = _pMT->RunScript(bstrPath, pvarParam);

Cleanup:
    if (pvarParam)
    {
        if (fRegistered)
        {
            Verify(_pMT->_pGIT->RevokeInterfaceFromGlobal(dwCookie) == S_OK);
        }
        if (V_VT(pvarParam) != VT_DISPATCH)
            VariantClear(pvarParam);
        delete pvarParam;
    }
    return hr;
}

HRESULT
CScriptHost::get_ScriptParam(VARIANT *pvarScriptParam)
{
    VERIFY_THREAD();

    HRESULT hr;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (GetSite())
    {
        hr = THR(VariantCopy(pvarScriptParam, &GetSite()->_varParam));
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CScriptHost::get_ScriptPath(BSTR *pbstrPath)
{
    CStr cstrPath;

    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    _pMT->_options.GetScriptPath(&cstrPath);

    return cstrPath.AllocBSTR(pbstrPath);
}

typedef HRESULT (TestExternal_Func)(VARIANT *pParam, long *plRetVal);

HRESULT
CScriptHost::CallExternal(BSTR     bstrDLLName,
                             BSTR     bstrFunctionName,
                             VARIANT *pParam,
                             long *   plRetVal)
{
    VERIFY_THREAD();

    HRESULT            hr       = S_OK;
    HINSTANCE          hInstDLL = NULL;
    TestExternal_Func *pfn      = NULL;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (!plRetVal || !bstrDLLName || !bstrFunctionName)
        return E_POINTER;

    *plRetVal = -1;

    hInstDLL = LoadLibrary(bstrDLLName);

    if (NULL == hInstDLL)
    {
        return S_FALSE;     // Can't return error codes or the script will abort
    }

    int   cchLen = SysStringLen(bstrFunctionName);
    char *pchBuf = new char[cchLen+1];

    if (pchBuf)
    {
        WideCharToMultiByte(CP_ACP, 0, bstrFunctionName, cchLen, pchBuf, cchLen+1, NULL, NULL);
        pchBuf[cchLen] = '\0';

        pfn = (TestExternal_Func *)GetProcAddress(hInstDLL, pchBuf);

        delete pchBuf;
    }

    if (NULL == pfn)
    {
        hr = S_FALSE;
    }
    else
    {
        *plRetVal = 0;
        hr = (*pfn)(pParam, plRetVal);
    }

    FreeLibrary(hInstDLL);

    return hr;
}

HRESULT
CScriptHost::GetSyncEventName(int nEvent, CStr *pCStr, HANDLE *phEvent)
{
    HRESULT    hr = S_OK;

    *phEvent = NULL;

    if (nEvent < 0)
        return E_INVALIDARG;

    EnterCriticalSection(&s_csSync);

    if (nEvent >= s_arySyncEvents.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pCStr->Set(s_arySyncEvents[nEvent]._cstrName);
    *phEvent = s_arySyncEvents[nEvent]._hEvent;

Cleanup:
    LeaveCriticalSection(&s_csSync);

    RRETURN(hr);
}

HRESULT
CScriptHost::GetSyncEvent(LPCTSTR pszName, HANDLE *phEvent)
{
    int        i;
    SYNCEVENT *pse;
    HRESULT    hr = S_OK;

    *phEvent = NULL;

    if (_tcslen(pszName) < 1)
        return E_INVALIDARG;

    EnterCriticalSection(&s_csSync);

    for (i = s_arySyncEvents.Size(), pse = s_arySyncEvents;
         i > 0;
         i--, pse++)
    {
        if (_tcsicmp(pszName, pse->_cstrName) == 0)
        {
            *phEvent = pse->_hEvent;
            break;
        }
    }

    if (i == 0)
    {
        //
        // The event doesn't exist yet. Create one. The primary script thread
        // owns cleaning all this stuff up.
        //
        SYNCEVENT se;

        se._hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!se._hEvent)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        else
        {
            se._cstrName.Set(pszName);

            s_arySyncEvents.AppendIndirect(&se);

            //
            // The cstr in 'se' will destroy its memory unless we take it away.
            // It's now owned by the cstrName member of the array.
            //
            (void)se._cstrName.TakePch();

            *phEvent = se._hEvent;
        }
    }

Cleanup:
    LeaveCriticalSection(&s_csSync);

    RRETURN(hr);
}

HRESULT
CScriptHost::StringToEventArray(const wchar_t *pszNameList, CStackPtrAry<HANDLE, 5> *pAryEvents)
{
    HRESULT hr = S_OK;
    if (wcspbrk(pszNameList, g_pszListDeliminator))
    {
        CStr cstrNameList;
        HRESULT hr = cstrNameList.Set(pszNameList);
        wchar_t *pch = NULL;

        if (hr == S_OK)
            pch = wcstok(cstrNameList, g_pszListDeliminator);

        while (hr == S_OK && pch)
        {
            HANDLE  hEvent;
            hr = THR(GetSyncEvent(pch, &hEvent));
            if (hr != S_OK)
                break;

            // Don't allow duplicates. MsgWaitForMultipleObjects will barf.
            if (pAryEvents->Find(hEvent) != -1)
            {
                hr = E_INVALIDARG;
                break;
            }

            hr = pAryEvents->Append(hEvent);

            pch = wcstok(NULL, g_pszListDeliminator);
        }
    }
    else
    {
        HANDLE  hEvent;
        hr = THR(GetSyncEvent(pszNameList, &hEvent));
        if (hr == S_OK)
            hr = pAryEvents->Append(hEvent);
    }
    RRETURN(hr);
}

HRESULT
CScriptHost::ResetSync(const BSTR bstrName)
{
    VERIFY_THREAD();

    HRESULT hr;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    CStackPtrAry<HANDLE, 5> aryEvents;
    hr = StringToEventArray(bstrName, &aryEvents);
    if (hr == S_OK)
    {
        for(int i = aryEvents.Size() - 1; i>= 0; --i)
            ResetEvent(aryEvents[i]);
    }
    return hr;
}

HRESULT
CScriptHost::WaitForSync(BSTR bstrName, long nTimeout, VARIANT_BOOL *pfSignaled)
{
    VERIFY_THREAD();

    HANDLE  hEvent;
    HRESULT hr;

    if (!pfSignaled)
        return E_POINTER;

    *pfSignaled = VB_TRUE;

    hr = THR(GetSyncEvent(bstrName, &hEvent));
    if (hr)
        RRETURN(hr);

    TraceTag((tagSync, "Thread 0x%x is starting a wait for sync %ls",
              _dwThreadId, bstrName));

    if (MessageEventPump(TRUE,
                         1,
                         &hEvent,
                         FALSE,
                         (nTimeout > 0) ? nTimeout : INFINITE) != MEP_EVENT_0)
    {
        *pfSignaled = VB_FALSE;
    }

    // Now make sure that SignalThreadSync() and ResetSync()
    // are atomic when manipulating multiple syncs.
    TakeThreadLock(g_pszAtomicSyncLock);
    ReleaseThreadLock(g_pszAtomicSyncLock);
    TraceTag((tagSync, "Thread 0x%x has returned from a wait for sync %ls (signaled=%s)",
              _dwThreadId,
              bstrName,
              (*pfSignaled==VB_FALSE) ? "false" : "true"));

    return S_OK;
}

HRESULT
CScriptHost::WaitForMultipleSyncs(const BSTR         bstrNameList,
                                  VARIANT_BOOL fWaitForAll,
                                  long         nTimeout,
                                  long        *plSignal)
{
    VERIFY_THREAD();

    HRESULT hr;
    DWORD   dwRet;

    *plSignal = 0;

    CStackPtrAry<HANDLE, 5> aryEvents;
    hr = StringToEventArray(bstrNameList, &aryEvents);

    if (hr == S_OK)
    {
        TraceTag((tagSync, "Thread 0x%x is starting a multiwait for sync %ls",
                  _dwThreadId, bstrNameList));
        dwRet = MessageEventPump(TRUE,
                                 aryEvents.Size(),
                                 aryEvents,
                                 (fWaitForAll == VB_TRUE) ? TRUE : FALSE,
                                 (nTimeout > 0) ? nTimeout : INFINITE);
        if (dwRet >= MEP_EVENT_0)
        {
            *plSignal = dwRet - MEP_EVENT_0 + 1; // result is 1-based, not zero-based
            // Now make sure that SignalThreadSync() and ResetSync()
            // are atomic when manipulating multiple syncs.
            TakeThreadLock(g_pszAtomicSyncLock);
            ReleaseThreadLock(g_pszAtomicSyncLock);
        }
        TraceTag((tagSync, "Thread 0x%x has returned from a multiwait for sync %ls (signaled=%d)",
                  _dwThreadId,
                  bstrNameList,
                  *plSignal));
    }
    return hr;
}

HRESULT
CScriptHost::SignalThreadSync(BSTR bstrName)
{
    HRESULT hr;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    TraceTag((tagSync, "Thread 0x%x is signalling sync %ls",
              _dwThreadId, bstrName));

    CStackPtrAry<HANDLE, 5> aryEvents;
    hr = StringToEventArray(bstrName, &aryEvents);
    if (hr == S_OK)
    {
        if (aryEvents.Size() > 1)
            TakeThreadLock(g_pszAtomicSyncLock);

        for(int i = aryEvents.Size() - 1; i>= 0; --i)
            SetEvent(aryEvents[i]);

        if (aryEvents.Size() > 1)
            ReleaseThreadLock(g_pszAtomicSyncLock);
    }

    return S_OK;
}

HRESULT
CScriptHost::GetLockCritSec(LPTSTR             pszName,
                            CRITICAL_SECTION **ppcs,
                            DWORD            **ppdwOwner)
{
    int         i;
    THREADLOCK *ptl;
    HRESULT     hr = S_OK;

    if (_tcslen(pszName) < 1)
        return E_INVALIDARG;

    *ppcs = NULL;

    EnterCriticalSection(&s_csSync);

    for (i = s_cThreadLocks, ptl = s_aThreadLocks;
         i > 0;
         i--, ptl++)
    {
        if (_tcsicmp(pszName, ptl->_cstrName) == 0)
        {
            *ppcs      = &ptl->_csLock;
            *ppdwOwner = &ptl->_dwOwner;

            break;
        }
    }

    if (i == 0)
    {
        //
        // The critical section doesn't exist yet.  Create one.  The primary
        // script thread owns cleaning all this stuff up.
        //

        if (s_cThreadLocks == MAX_LOCKS)
        {
            // BUGBUG -- SetErrorInfo
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        ptl = &s_aThreadLocks[s_cThreadLocks++];

        InitializeCriticalSection(&ptl->_csLock);

        ptl->_cstrName.Set(pszName);
        ptl->_dwOwner = 0;

        *ppcs      = &ptl->_csLock;
        *ppdwOwner = &ptl->_dwOwner;
    }

Cleanup:
    LeaveCriticalSection(&s_csSync);

    RRETURN(hr);
}

HRESULT
CScriptHost::TakeThreadLock(BSTR bstrName)
{
    HRESULT           hr;
    CRITICAL_SECTION *pcs;
    DWORD            *pdwOwner;

    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    hr = THR(GetLockCritSec(bstrName, &pcs, &pdwOwner));
    if (hr)
        RRETURN(hr);

    TraceTag((tagLock, "Thread 0x%x is trying to obtain lock %ls",
              _dwThreadId, bstrName));

    while (!TryEnterCriticalSection(pcs))
    {
        // Make sure we don't get hung here if the thread's trying to exit

        if (MessageEventPump(TRUE, 0, NULL, FALSE, 100, TRUE) == MEP_EXIT)
            return E_FAIL;
    }

    TraceTag((tagLock, "Thread 0x%x has obtained lock %ls",
              _dwThreadId, bstrName));

    *pdwOwner = GetCurrentThreadId();

    return S_OK;
}

HRESULT
CScriptHost::ReleaseThreadLock(BSTR bstrName)
{
    HRESULT            hr;
    CRITICAL_SECTION  *pcs;
    DWORD             *pdwOwner;

    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    hr = THR(GetLockCritSec(bstrName, &pcs, &pdwOwner));
    if (hr)
        RRETURN(hr);

    // LeaveCriticalSection can cause other threads to lock indefinitely on
    // the critical section if we don't actually own it.

    if (*pdwOwner != GetCurrentThreadId())
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_OWNER);
    }

    LeaveCriticalSection(pcs);

    TraceTag((tagLock, "Thread 0x%x has released lock %ls",
              _dwThreadId, bstrName));

    return S_OK;
}

HRESULT
CScriptHost::DoEvents()
{
    VERIFY_THREAD();

    MessageEventPump(FALSE);

    return S_OK;
}

HRESULT
CScriptHost::MessageBoxTimeout(BSTR bstrMessage,        // Message Text
                                  long cButtons,           // Number of buttons (max 5)
                                  BSTR bstrButtonText,     // Comma separated list of button text. Number must match cButtons
                                  long lTimeout,           // Timeout in minutes. If zero then no timeout.
                                  long lEventInterval,     // Fire a OnMessageBoxInterval event every lEventInterval minutes
                                  VARIANT_BOOL fCanCancel, // If TRUE then timeout can be canceled.
                                  VARIANT_BOOL fConfirm,   // If TRUE then confirm the button pushed before returning.
                                  long *plSelected)        // Returns button pushed. 0=timeout, 1=Button1, 2=Button2, etc.
{
    VERIFY_THREAD();

    HANDLE     hEvent;
    MBTIMEOUT  mbt = { 0 };
    BOOL       fExit = FALSE;
    HRESULT    hr = S_OK;


    if (!plSelected)
        return E_POINTER;

    *plSelected = -1;

    if (cButtons < 1 || cButtons > 5)
        return E_INVALIDARG;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!hEvent)
        return HRESULT_FROM_WIN32(GetLastError());

    mbt.bstrMessage    = bstrMessage;
    mbt.cButtons       = cButtons;
    mbt.bstrButtonText = bstrButtonText;
    mbt.lTimeout       = lTimeout;
    mbt.lEventInterval = lEventInterval;
    mbt.fCanCancel     = (fCanCancel == VB_TRUE) ? TRUE : FALSE;
    mbt.fConfirm       = (fConfirm == VB_TRUE) ? TRUE : FALSE;
    mbt.hEvent         = hEvent;

    CMessageBoxTimeout *pmbt = new CMessageBoxTimeout(&mbt);
    if (!pmbt)
        return E_OUTOFMEMORY;

    pmbt->StartThread(NULL);

    while (!fExit)
    {
        // Make sure it was our event being signaled that caused the loop to end
        if (MessageEventPump(TRUE, 1, &hEvent) != MEP_EVENT_0)
        {
            hr = S_FALSE;
            fExit = TRUE;
            break;
        }

        switch (mbt.mbts)
        {
        case MBTS_BUTTON1:
        case MBTS_BUTTON2:
        case MBTS_BUTTON3:
        case MBTS_BUTTON4:
        case MBTS_BUTTON5:
        case MBTS_TIMEOUT:
            *plSelected = (long)mbt.mbts;
            fExit = TRUE;
            break;

        case MBTS_INTERVAL:
            FireEvent(DISPID_MTScript_OnMessageBoxInterval, 0, NULL);
            ResetEvent(hEvent);
            break;

        case MBTS_ERROR:
            hr = E_FAIL;
            fExit = TRUE;
            break;

        default:
            AssertSz(FALSE, "FATAL: Invalid value for mbts!");
            fExit = TRUE;
            break;
        }
    }

    if (pmbt->_hwnd != NULL)
    {
        EndDialog(pmbt->_hwnd, 0);
    }

    pmbt->Release();

    CloseHandle(hEvent);

    return hr;
}

HRESULT
CScriptHost::RunLocalCommand(BSTR         bstrCommand,
                             BSTR         bstrDir,
                             BSTR         bstrTitle,
                             VARIANT_BOOL fMinimize,
                             VARIANT_BOOL fGetOutput,
                             VARIANT_BOOL fWait,
                             VARIANT_BOOL fNoCrashPopup,
                             VARIANT_BOOL fNoEnviron,
                             long *       plErrorCode)
{
    VERIFY_THREAD();

    CProcessThread *pProc;
    PROCESS_PARAMS  pp;

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (!plErrorCode)
        return E_POINTER;

    pp.pszCommand    = bstrCommand;
    pp.pszDir        = bstrDir;
    pp.pszTitle      = bstrTitle;
    pp.fMinimize     = (fMinimize     == VB_TRUE) ? TRUE : FALSE;
    pp.fGetOutput    = (fGetOutput    == VB_TRUE) ? TRUE : FALSE;
    pp.fNoCrashPopup = (fNoCrashPopup == VB_TRUE) ? TRUE : FALSE;
    pp.fNoEnviron    = (fNoEnviron    == VB_TRUE) ? TRUE : FALSE;

    _hrLastRunLocalError = S_OK;

    pProc = new CProcessThread(this);
    if (!pProc)
    {
        _hrLastRunLocalError = E_OUTOFMEMORY;

        *plErrorCode = 0;

        return S_FALSE;
    }
    _hrLastRunLocalError = pProc->StartThread(&pp);
    if (FAILED(_hrLastRunLocalError))
    {
        *plErrorCode = 0;

        pProc->Release();

        // Don't cause a script error by returning a failure code.
        return S_FALSE;
    }

    _pMT->AddProcess(pProc);

    if (fWait == VB_TRUE)
    {
        HANDLE hEvent = pProc->hThread();

        // The actual return code here doesn't matter. We'll do the same thing
        // no matter what causes MessageEventPump to exit.
        MessageEventPump(TRUE, 1, &hEvent);
    }


    TraceTag((tagProcess, "RunLocalCommand PID=%d, %s", pProc->ProcId(), bstrCommand));
    *plErrorCode = pProc->ProcId();

    return S_OK;
}

HRESULT
CScriptHost::GetLastRunLocalError(long *plErrorCode)
{
    VERIFY_THREAD();

    *plErrorCode = _hrLastRunLocalError;

    return S_OK;
}

HRESULT
CScriptHost::GetProcessOutput(long lProcessID, BSTR *pbstrData)
{
    VERIFY_THREAD();

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    if (!pProc)
    {
        return E_INVALIDARG;
    }

    return pProc->GetProcessOutput(pbstrData);
}

HRESULT
CScriptHost::GetProcessExitCode(long lProcessID, long *plExitCode)
{
    VERIFY_THREAD();

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    if (!pProc)
    {
        return E_INVALIDARG;
    }

    *plExitCode = pProc->GetExitCode();

    return S_OK;
}

HRESULT
CScriptHost::TerminateProcess(long lProcessID)
{
    VERIFY_THREAD();

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    if (!pProc)
    {
        return E_INVALIDARG;
    }

    PostToThread(pProc, MD_PLEASEEXIT);

    return S_OK;
}

HRESULT
CScriptHost::SendToProcess(long  lProcessID,
                           BSTR  bstrType,
                           BSTR  bstrData,
                           long *plReturn)
{
    VERIFY_THREAD();
    MACHPROC_EVENT_DATA  med;
    MACHPROC_EVENT_DATA *pmed;
    VARIANT              vRet;
    HRESULT              hr = S_OK;

    CProcessThread *pProc;

    pProc = _pMT->FindProcess((DWORD)lProcessID);

    //$ TODO -- Fix these error return codes to not cause script errors.
    if (!pProc || !plReturn)
    {
        return E_INVALIDARG;
    }
    else if (pProc->GetExitCode() != STILL_ACTIVE)
    {
        *plReturn = -1;
        return S_FALSE;
    }

    VariantInit(&vRet);

    med.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (med.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    med.bstrCmd     = bstrType;
    med.bstrParams  = bstrData;
    med.dwProcId    = (DWORD)lProcessID;
    med.pvReturn    = &vRet;
    med.dwGITCookie = 0;
    med.hrReturn    = S_OK;

    pmed = &med;

    PostToThread(_pMT, MD_SENDTOPROCESS, &pmed, sizeof(MACHPROC_EVENT_DATA*));

    // BUGBUG - we could get a crash if something causes us to exit before
    // the CMTScript thread handles the MD_SENDTOPROCESS message.
    MessageEventPump(TRUE, 1, &med.hEvent);

    hr = med.hrReturn;

    *plReturn = V_I4(&vRet);

    VariantClear(&vRet);

    CloseHandle(med.hEvent);

    return hr;
}


#define USERPROFILESTRING_SZ (256 * sizeof(TCHAR))
TCHAR   UserProfileString[USERPROFILESTRING_SZ];

HRESULT
CScriptHost::SendMail(BSTR   bstrTo,
                         BSTR   bstrCC,
                         BSTR   bstrBCC,
                         BSTR   bstrSubject,
                         BSTR   bstrMessage,
                         BSTR   bstrAttachmentPath,
                         BSTR   bstrUsername,
                         BSTR   bstrPassword,
                         long * plErrorCode)
{
    // This implementation was stolen from the execmail.exe source code.

    // Handles to MAPI32.DLL library, host name registry key, email session.
    //$ FUTURE -- Cache this stuff instead of reloading the library every
    // time.
    HINSTANCE       hLibrary;
    LHANDLE         hSession;

    // Function pointers for MAPI calls we use.
    LPMAPILOGON     fnMAPILogon;
    LPMAPISENDMAIL  fnMAPISendMail;
    LPMAPILOGOFF    fnMAPILogoff;

    // MAPI structures and counters.
    MapiRecipDesc   rgRecipDescStruct[30];
    MapiMessage     MessageStruct = {0, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, 0, NULL};
    MapiFileDesc    MAPIFileDesc = {0, 0, 0, NULL, NULL, NULL};
    FLAGS           MAPIFlags = MAPI_NEW_SESSION;

    // Pointers to email parameter strings.
    char            *pszToList      = NULL;
    char            *pszCCList      = NULL;
    char            *pszBCCList     = NULL;

    ULONG            ulErrorCode;

    if (!plErrorCode)
        return E_POINTER;

    ///////////////////////////////////////////////////////////////////////////
    // No point going any farther if MAPI32.DLL isn't available.
    hLibrary = LoadLibrary(L"MAPI32.DLL");
    if (hLibrary == NULL)
    {
        DWORD dwError = GetLastError();

        TraceTag((tagError, "Error: MAPI32.DLL not found on this machine!"));

        *plErrorCode = HRESULT_FROM_WIN32(dwError);

        return S_FALSE;
    }

    // Must convert all parameters to ANSI
    ANSIString szTo(bstrTo);
    ANSIString szCC(bstrCC);
    ANSIString szBCC(bstrBCC);
    ANSIString szSubject(bstrSubject);
    ANSIString szMessage(bstrMessage);
    ANSIString szAttachment(bstrAttachmentPath);
    ANSIString szUsername(bstrUsername);
    ANSIString szPassword(bstrPassword);


    // Set up MAPI function pointers.
    fnMAPILogon    = (LPMAPILOGON)GetProcAddress(hLibrary, "MAPILogon");
    fnMAPISendMail = (LPMAPISENDMAIL)GetProcAddress(hLibrary, "MAPISendMail");
    fnMAPILogoff   = (LPMAPILOGOFF)GetProcAddress(hLibrary, "MAPILogoff");

    // Hook the recipient structure array into the message structure.
    MessageStruct.lpRecips = rgRecipDescStruct;

    // Get the default user parameters if none were specified.
    if (SysStringLen(bstrUsername) == 0)
    {
        HKEY    hkey;
        WCHAR   KeyPath[] = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles";
        WCHAR   Value[] = L"DefaultProfile";
        DWORD   buf_sz = USERPROFILESTRING_SZ;
        DWORD   val_type;

        if( RegOpenKeyEx( HKEY_CURRENT_USER, KeyPath, 0, KEY_READ, &hkey ) == ERROR_SUCCESS )
        {
            if ( RegQueryValueEx( hkey, Value, NULL, &val_type, (BYTE*)UserProfileString, &buf_sz ) == ERROR_SUCCESS )
            {
                if ( val_type == REG_SZ )
                {
                    szUsername.Set(UserProfileString);
                }
            }

            RegCloseKey( hkey );
        }
    }

    pszToList = szTo;

    // Parse ToList into rgRecipDescStruct.
    while (*pszToList && (MessageStruct.nRecipCount < 30))
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pszToList))
        {
            *pszToList=0;
            pszToList++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            rgRecipDescStruct[MessageStruct.nRecipCount].ulReserved = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulRecipClass = MAPI_TO;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszName = pszToList;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszAddress = NULL;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulEIDSize = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpEntryID = NULL;
            MessageStruct.nRecipCount++;
            // Move beginning of string to next name in ToList.
            do
            {
                pszToList++;
            } while (isgraph(*pszToList));
        }
    }

    pszCCList = szCC;

    // Parse CCList into rgRecipDescStruct.
    while (*pszCCList && (MessageStruct.nRecipCount < 30))
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pszCCList))
        {
            *pszCCList=0;
            pszCCList++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            rgRecipDescStruct[MessageStruct.nRecipCount].ulReserved = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulRecipClass = MAPI_CC;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszName = pszCCList;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszAddress = NULL;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulEIDSize = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpEntryID = NULL;
            MessageStruct.nRecipCount++;
            // Move beginning of string to next name in CCList.
            do
            {
                pszCCList++;
            } while (isgraph(*pszCCList));
        }
    }

    pszBCCList = szBCC;

    // Parse BCCList into rgRecipDescStruct.
    while (*pszBCCList && (MessageStruct.nRecipCount < 30))
    {
        // Strip leading spaces from recipient name and terminate preceding
        // name string.
        if (isspace(*pszBCCList))
        {
            *pszBCCList=0;
            pszBCCList++;
        }
        // Add a name to the array and increment the number of recipients.
        else
        {
            rgRecipDescStruct[MessageStruct.nRecipCount].ulReserved = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulRecipClass = MAPI_BCC;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszName = pszBCCList;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpszAddress = NULL;
            rgRecipDescStruct[MessageStruct.nRecipCount].ulEIDSize = 0;
            rgRecipDescStruct[MessageStruct.nRecipCount].lpEntryID = NULL;
            MessageStruct.nRecipCount++;
            // Move beginning of string to next name in BCCList.
            do
            {
                pszBCCList++;
            } while (isgraph(*pszBCCList));
        }
    }

    if (strlen(szAttachment) > 0)
    {
        MAPIFileDesc.ulReserved = 0;
        MAPIFileDesc.flFlags = 0;
        MAPIFileDesc.nPosition = 0;
        MAPIFileDesc.lpszPathName = szAttachment;
        MAPIFileDesc.lpszFileName = NULL;
        MAPIFileDesc.lpFileType = NULL;

        MessageStruct.nFileCount = 1;
        MessageStruct.lpFiles = &MAPIFileDesc;

        // muck around with the message text (The attachment
        // will be attached at the beginning of the mail message
        // but it replaces the character at that position)

        // BUGBUG -- Do we need to do this? (lylec)
        //strcpy(szMessageText," \n");
    }

    MessageStruct.lpszSubject = szSubject;
    MessageStruct.lpszNoteText = szMessage;

    *plErrorCode = 0;

    // Send the message!

    ulErrorCode = fnMAPILogon(0L, szUsername, szPassword, MAPIFlags, 0L, &hSession);

    if (ulErrorCode != SUCCESS_SUCCESS)
    {
        *plErrorCode = (long)ulErrorCode;
    }
    else
    {
        ulErrorCode = fnMAPISendMail(hSession, 0L, &MessageStruct, 0L, 0L);

        if (ulErrorCode != SUCCESS_SUCCESS)
        {
            *plErrorCode = (long)ulErrorCode;
        }

        fnMAPILogoff(hSession, 0L, 0L, 0L);
    }

    FreeLibrary(hLibrary);

    return S_OK;
}

HRESULT
CScriptHost::OUTPUTDEBUGSTRING(BSTR bstrMessage)
{
    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    TCHAR szText[ (MSGDATABUFSIZE-1) / sizeof(TCHAR) ];

    CScriptSite *site = GetSite();
    const TCHAR *pszScriptName = L"";
    if (site)
    {
        pszScriptName = _tcsrchr((LPTSTR)site->_cstrName, _T('\\'));
        if (!pszScriptName)
            pszScriptName = (LPTSTR)site->_cstrName;
    }
    int cChars = _snwprintf(szText, ARRAY_SIZE(szText), L"%.12s \t%s", pszScriptName, bstrMessage);

    szText[ARRAY_SIZE(szText) - 1] = 0;

    if (cChars < 0)
        cChars = ARRAY_SIZE(szText);
    else
        cChars++;

    PostToThread(_pMT,
                             MD_OUTPUTDEBUGSTRING,
                             szText,
                             cChars * sizeof(TCHAR));
    return S_OK;
}

HRESULT
CScriptHost::UnevalString(BSTR bstrInput, BSTR *pbstrOutput)
{
    int nInputLength = SysStringLen(bstrInput);
    OLECHAR tmpBuf[512];
    OLECHAR *pTmp = 0;
    OLECHAR *pOutputBuffer;

    *pbstrOutput = 0;
    if (sizeof(OLECHAR) * (nInputLength * 2 + 2) > sizeof(tmpBuf))
    {
        pTmp = (OLECHAR *)MemAlloc(sizeof(OLECHAR) * (nInputLength * 2 + 2));
        if (!pTmp)
            return E_OUTOFMEMORY;
        pOutputBuffer = pTmp;
    }
    else
    {
        pOutputBuffer = tmpBuf;
    }
    int j = 0;
    pOutputBuffer[j++] = L'"';
    for(OLECHAR *pInputEnd = bstrInput + nInputLength; bstrInput < pInputEnd; ++bstrInput)
    {
        switch(*bstrInput)
        {
        case L'\\':
        case L'"':
        case L'\'':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = *bstrInput;
            j += 2;
            break;
        case L'\n':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = L'n';
            j += 2;
            break;
        case L'\r':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = L'r';
            j += 2;
            break;
        case L'\t':
            pOutputBuffer[j] = L'\\';
            pOutputBuffer[j+1] = L't';
            j += 2;
            break;
        default:
            pOutputBuffer[j++] = *bstrInput;
            break;
        }
    }
    pOutputBuffer[j++] = L'"';
    *pbstrOutput = SysAllocStringLen(pOutputBuffer, j);

    if (pTmp)
        MemFree(pTmp);

    if (!*pbstrOutput)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CScriptHost::CopyOrAppendFile(BSTR bstrSrc,
                 BSTR bstrDst,
                 long nSrcOffset,
                 long nSrcLength,
                 VARIANT_BOOL fAppend,
                 long *pnSrcFilePosition)
{
    HRESULT hr   = S_OK;
    HANDLE hDst  = INVALID_HANDLE_VALUE;
    HANDLE hSrcFile = INVALID_HANDLE_VALUE;
    BY_HANDLE_FILE_INFORMATION  fi = {0};
    long nEndPos;
    long nLen;
    DWORD nBytesRead;
    DWORD nBytesWritten;
    char rgBuffer[4096];

    hDst = CreateFile(
                bstrDst,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                0,
                (fAppend ? OPEN_ALWAYS : CREATE_ALWAYS),
                FILE_ATTRIBUTE_NORMAL,
                0);

    if (hDst == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    hSrcFile = CreateFile(bstrSrc,
                GENERIC_READ,
                FILE_SHARE_WRITE,
                0,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                0);

    if (hSrcFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    GetFileInformationByHandle(hSrcFile, &fi);
    if (fi.nFileSizeHigh != 0 || (fi.nFileSizeLow & 0x80000000) != 0)
    {
        hr = E_FAIL;//HRESULT_FROM_WIN32(?????);
        goto Cleanup;
    }
    if (nSrcLength == -1)
        nEndPos = (long)fi.nFileSizeLow;
    else
    {
        if ( ((_int64)nSrcOffset + nSrcLength) > 0x7f000000)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        nEndPos = nSrcOffset + nSrcLength;
    }
    if (nEndPos > (long)fi.nFileSizeLow)
        nEndPos = (long)fi.nFileSizeLow;

    if (SetFilePointer(hSrcFile, nSrcOffset, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    if (SetFilePointer(hDst, 0, 0, FILE_END) == INVALID_SET_FILE_POINTER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    while (nSrcOffset < nEndPos)
    {
        nLen = nEndPos - nSrcOffset;
        if (nLen > sizeof(rgBuffer))
            nLen = sizeof(rgBuffer);

        if (!ReadFile(hSrcFile, rgBuffer, nLen, &nBytesRead, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        if (!WriteFile(hDst, rgBuffer, nBytesRead, &nBytesWritten, 0))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        nSrcOffset += nBytesRead;
    }
    if (pnSrcFilePosition)
        *pnSrcFilePosition = nSrcOffset;
Cleanup:
    if (hDst != INVALID_HANDLE_VALUE)
        CloseHandle(hDst);
    if (hSrcFile != INVALID_HANDLE_VALUE)
        CloseHandle(hSrcFile);
    return hr;
}

HRESULT
CScriptHost::ASSERT(VARIANT_BOOL fAssert, BSTR bstrMessage)
{
    VERIFY_THREAD();

    if (!_fIsPrimaryScript)
        MessageEventPump(FALSE);

    if (!fAssert)
    {
        CHAR ach[1024];

        // Add name of currently executing script to the assert message.

        if (!GetSite() || !GetSite()->_achPath[0])
        {
            ach[0] = 0;
        }
        else
        {
            // Try to chop off directory name.

            TCHAR * pchName = wcsrchr(GetSite()->_achPath, _T('\\'));
            if (pchName)
                pchName += 1;
            else
                pchName = GetSite()->_achPath;

            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    pchName,
                    -1,
                    ach,
                    MAX_PATH,
                    NULL,
                    NULL);

            strcat(ach, ": ");
        }

        // Add message to the assert.

        if (!bstrMessage || !*bstrMessage)
        {
            strcat(ach, "MTScript Script Assert");
        }
        else
        {
            WideCharToMultiByte(
                    CP_ACP,
                    0,
                    bstrMessage,
                    -1,
                    &ach[strlen(ach)],
                    ARRAY_SIZE(ach) - MAX_PATH - 3,
                    NULL,
                    NULL);
        }

#if DBG == 1
        AssertSz(FALSE, ach);
#else
        if (MessageBoxA(NULL, ach, "MTScript Script Assert", MB_OKCANCEL | MB_SETFOREGROUND) == IDCANCEL)
            return E_FAIL;
#endif
    }

    return S_OK;
}

HRESULT
CScriptHost::Sleep (int nTimeout)
{
    VERIFY_THREAD();

    MessageEventPump(TRUE, 0, NULL, FALSE, (DWORD)nTimeout);

    return S_OK;
}

HRESULT
CScriptHost::Reboot()
{
    VERIFY_THREAD();

    PostToThread(_pMT, MD_REBOOT);

    return S_OK;
}

HRESULT
CScriptHost::NotifyScript(BSTR bstrEvent, VARIANT vData)
{
    HRESULT hr = S_OK;
    VARIANT *pvar;

    VERIFY_THREAD();

    // Check for data types which we don't support.
    if (   V_ISBYREF(&vData)
        || V_ISARRAY(&vData)
        || V_ISVECTOR(&vData)
        || V_VT(&vData) == VT_DISPATCH  //$ FUTURE: Support this later
        || V_VT(&vData) == VT_UNKNOWN)
    {
        return E_INVALIDARG;
    }

    if (!_pMT->_pMachine)
    {
        return S_OK;
    }

    pvar = new VARIANT[2];

    VariantInit(&pvar[0]);
    VariantInit(&pvar[1]);

    V_VT(&pvar[0]) = VT_BSTR;
    V_BSTR(&pvar[0]) = SysAllocString(bstrEvent);

    VariantCopy(&pvar[1], &vData);

    PostToThread(_pMT->_pMachine, MD_NOTIFYSCRIPT, &pvar, sizeof(VARIANT*));

    return hr;
}

HRESULT
CScriptHost::RegisterEventSource(IDispatch *pDisp, BSTR bstrProgID)
{
    HRESULT           hr;
    CScriptEventSink *pSink = NULL;

    pSink = new CScriptEventSink(this);
    if (!pSink)
        return E_OUTOFMEMORY;

    hr = pSink->Connect(pDisp, bstrProgID);
    if (!hr)
    {
        _aryEvtSinks.Append(pSink);
    }
    else
        pSink->Release();

    return hr;
}

HRESULT
CScriptHost::UnregisterEventSource(IDispatch *pDisp)
{
    int  i;
    BOOL fFound = FALSE;

    for (i = 0; i < _aryEvtSinks.Size(); i++)
    {
        if (_aryEvtSinks[i]->IsThisYourSource(pDisp))
        {
            _aryEvtSinks[i]->Disconnect();

            _aryEvtSinks.ReleaseAndDelete(i);

            fFound = TRUE;
            break;
        }
    }

    return (fFound) ? S_OK : E_INVALIDARG;
}

HRESULT
CScriptHost::get_HostMajorVer(long *plMajorVer)
{
    if (!plMajorVer)
        return E_POINTER;

    *plMajorVer = IConnectedMachine_lVersionMajor;

    return S_OK;
}

HRESULT
CScriptHost::get_HostMinorVer(long *plMinorVer)
{
    if (!plMinorVer)
        return E_POINTER;

    *plMinorVer = IConnectedMachine_lVersionMinor;

    return S_OK;
}

HRESULT CScriptHost::get_StatusValue(long nIndex, long *pnStatus)
{
    return _pMT->get_StatusValue(nIndex, pnStatus);
}

HRESULT CScriptHost::put_StatusValue(long nIndex, long nStatus)
{
    return _pMT->put_StatusValue(nIndex, nStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\scrhost\process.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       process.cxx
//
//  Contents:   Implementation of the CProcessThread class
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#include "stdlib.h"

DeclareTag(tagProcess, "MTScript", "Monitor Process Creation");

char *g_pszExitCodeStr = "PROCESS_EXIT_CODE=";

#define PIPEREAD_TIMEOUT 2

CProcessParams::CProcessParams()
{
        pszCommand = 0;
        pszDir = 0;
        pszTitle = 0;
}

CProcessParams::~CProcessParams()
{
        Free();
}

bool CProcessParams::Copy(const PROCESS_PARAMS *params)
{
        return Assign(*params);
}

void CProcessParams::Free()
{
        SysFreeString(pszCommand);
        SysFreeString(pszDir);
        SysFreeString(pszTitle);

        pszCommand = 0;
        pszDir     = 0;
        pszTitle   = 0;
}

bool CProcessParams::Assign(const PROCESS_PARAMS &params)
{
        pszCommand    = SysAllocString(params.pszCommand);
        pszDir        = SysAllocString(params.pszDir);
        pszTitle      = SysAllocString(params.pszTitle);
        fMinimize     = params.fMinimize;
        fGetOutput    = params.fGetOutput;
        fNoEnviron    = params.fNoEnviron;
        fNoCrashPopup = params.fNoCrashPopup;

        if (params.pszCommand && !pszCommand ||
                        params.pszDir && !pszDir ||
                        params.pszTitle && !pszTitle)
        {
                return false;
        }
        return true;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::CProcessThread, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CProcessThread::CProcessThread(CScriptHost *pSH)
    : _cstrOutput(CSTR_NOINIT)
{
    _ulRefs = 1;

    _pSH = pSH;
    _pSH->AddRef();

    // This object should be initialized to all zero.

    Assert(_hPipe == NULL);
    Assert(_hJob == NULL);
    Assert(_hIoPort == NULL);
    Assert(_dwExitCode == 0);
    Assert(_piProc.hProcess == NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::~CProcessThread, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CProcessThread::~CProcessThread()
{
    AssertSz(!_hJob, "NONFATAL: Job handle should be NULL!");
    AssertSz(!_hIoPort, "NONFATAL: Port handle should be NULL!");

    TraceTag((tagProcess, "Closing process PID=%d", ProcId()));
    if (_hPipe)
        CloseHandle(_hPipe);

    if (_piProc.hProcess)
        CloseHandle(_piProc.hProcess);

    ReleaseInterface(_pSH);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::QueryInterface, public
//
//  Synopsis:   Standard implementation. This class implements no meaningful
//              interfaces.
//
//----------------------------------------------------------------------------

HRESULT
CProcessThread::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::Init, public
//
//  Synopsis:   Initializes the class
//
//----------------------------------------------------------------------------

BOOL
CProcessThread::Init()
{
    //$ FUTURE: For NT4 and Win9x support we will need to dynamically use the
    // job APIs since those platforms do not support them.

    _hJob = CreateJobObject(NULL, NULL);
    if (!_hJob)
    {
        TraceTag((tagError, "CreateJobObject failed with %d", GetLastError()));
        return FALSE;
    }

    return CThreadComm::Init();
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetProcessOutput, public
//
//  Synopsis:   Returns the collected STDOUT/STDERR data from the process
//              up to this point.
//
//  Arguments:  [pbstrOutput] -- Pointer to BSTR where the string should be
//                               copied. The BSTR will be allocated.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CProcessThread::GetProcessOutput(BSTR *pbstrOutput)
{
    LOCK_LOCALS(this);

    return _cstrOutput.AllocBSTR(pbstrOutput);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetExitCode, public
//
//  Synopsis:   Returns the exit code of the process. If the process is still
//              running, it returns STILL_ACTIVE (0x103, dec 259)
//
//----------------------------------------------------------------------------

DWORD
CProcessThread::GetExitCode()
{
    DWORD dwExit;

    AssertSz(_piProc.hProcess, "FATAL: Bad process handle");

    GetExitCodeProcess(_piProc.hProcess, &dwExit);

    if (dwExit == STILL_ACTIVE || !_fUseExitCode)
    {
        return STILL_ACTIVE;
    }

    return _dwExitCode;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetDeadTime, public
//
//  Synopsis:   Returns the number of ms since the process exited. If it
//              hasn't exited yet, it returns 0.
//
//----------------------------------------------------------------------------

ULONG
CProcessThread::GetDeadTime()
{
    _int64 i64CurrentTime;
    DWORD  dwExit;

    AssertSz(_piProc.hProcess, "FATAL: Bad process handle");

    GetExitCodeProcess(_piProc.hProcess, &dwExit);

    // If the process is still running return 0.
    if (dwExit == STILL_ACTIVE || !_i64ExitTime)
    {
        return 0;
    }

    GetSystemTimeAsFileTime((FILETIME*)&i64CurrentTime);

    // Calculate the difference in milli-seconds.  There are 10,000
    // FILETIME intervals in one second (each increment of 1 represents 100
    // nano-seconds)

    return (i64CurrentTime - _i64ExitTime) / 10000;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::Terminate, public
//
//  Synopsis:   Exits this thread. The process we own is terminated if it's
//              still running.
//
//----------------------------------------------------------------------------

void
CProcessThread::Terminate()
{
    DWORD            dwCode;
    CProcessThread * pThis = this;
    BOOL             fTerminated = FALSE;
    BOOL             fFireEvent = FALSE;

    VERIFY_THREAD();

    TraceTag((tagProcess, "Entering Terminate"));

    //
    // Flush out any data the process may have written to the pipe.
    //
    ReadPipeData();

    //
    // Make sure we've received all messages from our completion port
    //
    CheckIoPort();

    if (_piProc.hProcess)
    {
        //
        // Terminate the process(es) if still running.
        //

        fFireEvent = TRUE;

        GetExitCodeProcess(_piProc.hProcess, &dwCode);

        if (dwCode == STILL_ACTIVE)
        {
            TraceTag((tagProcess, "Root process still active!"));

            if (_hJob)
            {
                TerminateJobObject(_hJob, ERROR_PROCESS_ABORTED);
            }
            else
            {
                TraceTag((tagProcess, "Terminating process, not job!"));

                TerminateProcess(_piProc.hProcess, ERROR_PROCESS_ABORTED);
            }

            dwCode = ERROR_PROCESS_ABORTED;

            //
            // Flush out any data the process may have written to the pipe.
            //
            ReadPipeData();

            //
            // Make sure we've received all messages from our completion port
            //
            CheckIoPort();

            fTerminated = TRUE;
        }

        if (!_fUseExitCode)
        {
            _dwExitCode = dwCode;
            _fUseExitCode = TRUE;
        }
    }

    if (_hIoPort)
        CloseHandle(_hIoPort);

    if (_hJob)
        CloseHandle(_hJob);

    _hIoPort = NULL;
    _hJob    = NULL;

    // We need to hold onto _piProc.hProcess so the system doesn't reuse the
    // process ID.

    if (fFireEvent)
    {
        if (fTerminated)
        {
            PostToThread(_pSH, MD_PROCESSTERMINATED, &pThis, sizeof(CProcessThread*));
        }
        else
        {
            PostToThread(_pSH, MD_PROCESSEXITED, &pThis, sizeof(CProcessThread*));
        }
    }

    GetSystemTimeAsFileTime((FILETIME*)&_i64ExitTime);

    TraceTag((tagProcess, "Exiting process thread!"));

    Release();

    ExitThread(0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::RealThreadRoutine, public
//
//  Synopsis:   Main loop which runs this thread while it is active. The thread
//              will terminate if this method returns. Termination normally
//              happens when the client disconnects by calling Terminate().
//
//----------------------------------------------------------------------------

DWORD
CProcessThread::ThreadMain()
{
    DWORD   dwRet;
    HANDLE  ahEvents[3];
    int     cEvents = 2;
    HRESULT hr;

    PROCESS_PARAMS *pParams = (PROCESS_PARAMS *)_pvParams;

    _ProcParams.Copy(pParams);

#if DBG == 1
    {
        char achBuf[10];
        CStr cstrCmd;

        cstrCmd.Set(pParams->pszCommand);
        cstrCmd.GetMultiByte(achBuf, 10);
        SetName(achBuf);
    }
#endif

    AddRef();

    hr = LaunchProcess(pParams);

    ThreadStarted(hr);   // Release our calling thread

    if (hr)
    {
        Terminate();
        return 1;       // Just in case
    }

    ahEvents[0] = _hCommEvent;
    ahEvents[1] = _piProc.hProcess;

    while (TRUE)
    {
        //
        // Anonymous pipes don't support asynchronous I/O, and we can't wait
        // on a handle to see if there's data on the completion port.  So,
        // what we do is poll for those every 2 seconds instead.
        //
        dwRet = WaitForMultipleObjects(cEvents,
                                       ahEvents,
                                       FALSE,
                                       (_hPipe || _hIoPort)
                                          ? PIPEREAD_TIMEOUT * 1000
                                          : INFINITE);
        if (dwRet == WAIT_OBJECT_0)
        {
            //
            // Another thread is sending us a message.
            //
            HandleThreadMessage();
        }
        else if (dwRet == WAIT_OBJECT_0 + 1)
        {
            //
            // The process terminated.
            //
            HandleProcessExit();
        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            ReadPipeData();

            CheckIoPort();
        }
        else if (dwRet == WAIT_FAILED)
        {
            AssertSz(FALSE, "NONFATAL: WaitForMultipleObjectsFailure");

            break;
        }
    }

    // Make sure we clean everything up OK
    Terminate();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::HandleThreadMessage, public
//
//  Synopsis:   Handles any messages other threads send us.
//
//----------------------------------------------------------------------------

void
CProcessThread::HandleThreadMessage()
{
    THREADMSG tm;
    BYTE      bData[MSGDATABUFSIZE];
    DWORD     cbData;

    while (GetNextMsg(&tm, (void **)bData, &cbData))
    {
        switch (tm)
        {
        case MD_PLEASEEXIT:
            //
            // We're being asked to terminate.
            //
            Terminate();
            break;

        default:
            AssertSz(FALSE, "FATAL: CProcessThread got a message it couldn't handle!");
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::HandleProcessExit, public
//
//  Synopsis:   The process we started has exited. Send out the status and
//              exit.
//
//----------------------------------------------------------------------------

void
CProcessThread::HandleProcessExit()
{
    //
    // Flush out any data the process may have written to the pipe.
    //
    ReadPipeData();

    // Save the exit code
    if (!_fUseExitCode)
    {
        GetExitCodeProcess(_piProc.hProcess, &_dwExitCode);

        _fUseExitCode = TRUE;

        AssertSz(_dwExitCode != STILL_ACTIVE, "LEAK: Exited process still active!");
    }

    Terminate();
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::IsDataInPipe, public
//
//  Synopsis:   Is there any data waiting to be read from the anonymous pipe?
//
//----------------------------------------------------------------------------

BOOL
CProcessThread::IsDataInPipe()
{
    DWORD dwBytesAvail = 0;
    BOOL  fSuccess;

    if (!_hPipe)
        return FALSE;

    fSuccess = PeekNamedPipe(_hPipe,
                             NULL,
                             NULL,
                             NULL,
                             &dwBytesAvail,
                             NULL);

    if (!fSuccess)
    {
        //
        // Stop trying to read from the pipe
        //
        CloseHandle(_hPipe);
        _hPipe = NULL;
    }

    return (dwBytesAvail != 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::ReadPipeData, public
//
//  Synopsis:   Read any and all data which is waiting on the pipe. This will
//              be anything that the process writes to STDOUT.
//
//----------------------------------------------------------------------------

void
CProcessThread::ReadPipeData()
{
    BOOL         fSuccess = TRUE;
    DWORD        cbRead;
    char        *pch;

    while (IsDataInPipe())
    {
        CStr cstrTemp;

        fSuccess = ReadFile(_hPipe,
                            _abBuffer,
                            PIPE_BUFFER_SIZE - 1,
                            &cbRead,
                            NULL);

        if (!fSuccess || cbRead == 0)
        {
            Terminate();

            return; // just in case
        }

        _abBuffer[cbRead] = '\0';

        //
        // Is the process letting us know that we should pretend the exit code
        // is some value other than the actual exit code?
        // (using PROCESS_EXIT_CODE=x in its STDOUT stream)
        //
        pch = strstr((const char*)_abBuffer, g_pszExitCodeStr);
        if (pch)
        {
            _dwExitCode = atol(pch + strlen(g_pszExitCodeStr));
            _fUseExitCode = TRUE;
        }

        // The string is now in _abBuffer. Add it to our buffer.
        //
        // Assume the data coming across is MultiByte string data.
        //
        LOCK_LOCALS(this);

        _cstrOutput.AppendMultiByte((const char *)_abBuffer);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::CheckIoPort, public
//
//  Synopsis:   Check the CompletionPort that we are using to receive messages
//              from the job object. This will tell us if any process we
//              created or that is a child of the one we created crashed.
//
//----------------------------------------------------------------------------

void
CProcessThread::CheckIoPort()
{
    DWORD dwCode  = 0;
    DWORD dwKey   = 0;
    DWORD dwParam = 0;;

    if (!_hIoPort)
    {
        return;
    }

    while (GetQueuedCompletionStatus(_hIoPort,
                                     &dwCode,
                                     &dwKey,
                                     (LPOVERLAPPED*)&dwParam,
                                     0))
    {
        AssertSz(dwKey == (DWORD)this, "NONFATAL: Bogus port value from GetQueuedCompletionStatus");

        switch (dwCode)
        {
        case JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS:

            {
                CProcessThread *pThis = this;

                // There is no reliable way to get the actual exit code, since
                // the process is already gone and we don't have a handle to it.

                TraceTag((tagProcess, "Process %d crashed!", dwParam));

                PostToThread(_pSH, MD_PROCESSCRASHED, &pThis, sizeof(CProcessThread*));
            }

            break;

        case JOB_OBJECT_MSG_EXIT_PROCESS:
            TraceTag((tagProcess, "Process %d exited.", dwParam));
            break;

        case JOB_OBJECT_MSG_NEW_PROCESS:

            TraceTag((tagProcess, "Process %d started.", dwParam));
            // Remember the process id so we can use it later
            _aryProcIds.Append(dwParam);
            break;

        default:
            break;
        }
    }

    DWORD dwError = GetLastError();

    if (dwError != WAIT_TIMEOUT)
    {
        TraceTag((tagProcess, "GetQueuedCompletionStatus returned %d", dwError));
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::LaunchProcess, public
//
//  Synopsis:   Start the child process for the given command.
//
//----------------------------------------------------------------------------

HRESULT
CProcessThread::LaunchProcess(const PROCESS_PARAMS *pProcParams)
{
    BOOL        fSuccess;
    TCHAR       achCommand[MAX_PATH * 2];
    TCHAR       achDir[MAX_PATH];
    BOOL        fUseDir;
    HRESULT     hr = S_OK;
    CStr        cstrEnvironment;

    STARTUPINFO si         = { 0 };
    HANDLE      hPipeStdout = NULL;
    HANDLE      hPipeStderr = NULL;

    if (pProcParams->fGetOutput)
    {
        //
        // Setup the anonymous pipe which we will use to get status from the
        // process.  Anytime it writes to STDOUT or STDERR it will come across
        // this pipe to us.
        //
        SECURITY_ATTRIBUTES sa;

        sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = NULL;
        sa.bInheritHandle       = TRUE;

        fSuccess = CreatePipe(&_hPipe, &hPipeStdout, &sa, 0);
        if (!fSuccess)
        {
            AssertSz(FALSE, "FATAL: Could not create anonymous pipe");

            goto Win32Error;
        }

        //
        // Change our end of the pipe to non-inheritable so the new process
        // doesn't pick it up.
        //
        fSuccess = DuplicateHandle(GetCurrentProcess(),
                                   _hPipe,
                                   GetCurrentProcess(),
                                   NULL,
                                   0,
                                   FALSE,
                                   DUPLICATE_SAME_ACCESS);
        if (!fSuccess)
        {
            AssertSz(FALSE, "FATAL: Error removing inheritance from handle!");

            goto Win32Error;
        }

        //
        // Now duplicate the stdout handle for stderr
        //
        fSuccess = DuplicateHandle(GetCurrentProcess(),
                                   hPipeStdout,
                                   GetCurrentProcess(),
                                   &hPipeStderr,
                                   0,
                                   TRUE,
                                   DUPLICATE_SAME_ACCESS);
        if (!fSuccess)
        {
            AssertSz(FALSE, "Error duplicating stdout handle!");

            goto Win32Error;
        }
    }
    else
    {
        hPipeStdout = GetStdHandle(STD_OUTPUT_HANDLE);
        hPipeStderr = GetStdHandle(STD_ERROR_HANDLE);
    }

    if (_hJob)
    {
        JOBOBJECT_EXTENDED_LIMIT_INFORMATION joLimit = { 0 };
        JOBOBJECT_ASSOCIATE_COMPLETION_PORT  joPort = { 0 };

        if (pProcParams->fNoCrashPopup)
        {
            // Force crashes to terminate the job (and all processes in it).

            joLimit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION;

            fSuccess = SetInformationJobObject(_hJob,
                                       JobObjectExtendedLimitInformation,
                                       &joLimit,
                                       sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));
            if (!fSuccess)  // Ignore failures except to report them.
            {
                TraceTag((tagError,
                          "SetInformationJobObject failed with %d",
                          GetLastError()));
            }
        }

        // Now we need to setup a completion port so we can find out if one
        // of the processes crashed.

        _hIoPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, (DWORD)this, 0);

        if (_hIoPort)
        {
            joPort.CompletionKey  = this;
            joPort.CompletionPort = _hIoPort;

            fSuccess = SetInformationJobObject(_hJob,
                                       JobObjectAssociateCompletionPortInformation,
                                       &joPort,
                                       sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT));

            if (!fSuccess)  // Ignore failures except to report them.
            {
                TraceTag((tagError,
                          "Failed to set completion port on job: %d",
                          GetLastError()));
            }
        }
        else
        {
            TraceTag((tagError,
                      "CreateIoCompletionPort failed with %d!",
                      GetLastError()));
        }
    }

    si.cb = sizeof(STARTUPINFO);

    if (pProcParams->fMinimize)
    {
        si.wShowWindow =  SW_SHOWMINNOACTIVE;
    }
    else
    {
        si.wShowWindow =  SW_SHOWNORMAL;
    }

    if (pProcParams->pszTitle != NULL && _tcslen(pProcParams->pszTitle) > 0)
    {
        si.lpTitle = pProcParams->pszTitle;
    }

    //
    // Setup our inherited standard handles.
    //
    si.hStdInput   = GetStdHandle(STD_INPUT_HANDLE);
    si.hStdOutput  = hPipeStdout;
    si.hStdError   = hPipeStderr;

    si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;

    if (!pProcParams->fGetOutput)
    {
        si.dwFlags &= ~STARTF_USESTDHANDLES;
    }

    //
    // Expand environment strings in the command name as well as the working
    // dir.
    //

    ExpandEnvironmentStrings(pProcParams->pszCommand,
                             achCommand,
                             MAX_PATH * 2);

    fUseDir = pProcParams->pszDir && _tcslen(pProcParams->pszDir) > 0;

    if (fUseDir)
    {
        WCHAR *psz;
        WCHAR achDir2[MAX_PATH];

        ExpandEnvironmentStrings(pProcParams->pszDir, achDir2, MAX_PATH);
        GetFullPathName(achDir2, MAX_PATH, achDir, &psz);
    }

    GetProcessEnvironment(&cstrEnvironment, pProcParams->fNoEnviron);

    TraceTag((tagProcess, "Launching Process: %ls in %ls", achCommand, achDir));

    //
    // Let's do it!
    //
    fSuccess = CreateProcess(NULL,
                             achCommand,
                             NULL,
                             NULL,
                             TRUE,
                             BELOW_NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT,
                             cstrEnvironment,
                             (fUseDir) ? achDir : NULL,
                             &si,
                             &_piProc);
    if (!fSuccess)
        goto Win32Error;

    if (_hJob)
    {
        if (!AssignProcessToJobObject(_hJob, _piProc.hProcess))
        {
            TraceTag((tagError, "AssignProcessToJobObject failed with %d", GetLastError()));
            CloseHandle(_hJob);
            _hJob = NULL;
        }
    }

    TraceTag((tagProcess, "Created process PID=%d %ls", _piProc.dwProcessId, achCommand));
    CloseHandle(_piProc.hThread);

Cleanup:
    if (pProcParams->fGetOutput)
    {
        //
        // The write handles have been inherited by the child process, so we
        // let go of them.
        //
        CloseHandle(hPipeStdout);
        CloseHandle(hPipeStderr);
    }

    return hr;

Win32Error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    TraceTag((tagProcess, "Error creating process: %x", hr));

    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CProcessThread::GetProcessEnvironment, public
//
//  Synopsis:   Builds an environment block for the new process that has
//              our custom id so we can identify them.
//
//  Arguments:  [pcstr]      -- Place to put environment block
//              [fNoEnviron] -- If TRUE, don't inherit the environment block
//
//----------------------------------------------------------------------------

void
CProcessThread::GetProcessEnvironment(CStr *pcstr, BOOL fNoEnviron)
{
    TCHAR *pszEnviron;
    TCHAR  achNewVar[50];
    int    cch = 1;
    TCHAR *pch;

    static long s_lProcID = 0;

    _lEnvID = InterlockedIncrement(&s_lProcID);

    wsprintf(achNewVar, _T("__MTSCRIPT_ENV_ID=%d\0"), _lEnvID);

    if (!fNoEnviron)
    {
        pszEnviron = GetEnvironmentStrings();

        pch = pszEnviron;
        cch = 2;          // Always have two terminating nulls at least

        while (*pch || *(pch+1))
        {
            pch++;
            cch++;
        }

        pcstr->Set(NULL, cch + _tcslen(achNewVar));

        memcpy((LPTSTR)*pcstr, pszEnviron, cch * sizeof(TCHAR));

        FreeEnvironmentStrings(pszEnviron);
    }
    else
    {
        pcstr->Set(NULL, _tcslen(achNewVar) + 1);
    }

    memcpy((LPTSTR)*pcstr + cch - 1,
           achNewVar,
           (_tcslen(achNewVar)+1) * sizeof(TCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\mtscript\scrhost\script.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       bscript.cxx
//
//  Contents:   Implementation of CBServerScript
//
//----------------------------------------------------------------------------

#include "headers.hxx"
CScriptHost::CScriptHost(CMTScript *   pMT,
                         BOOL         fPrimary,
                         BOOL         fDispatchOnly)
      : _pMT(pMT),
        _fIsPrimaryScript(fPrimary)
{
    _ulRefs     = 1;

    VariantInit(&_vPubCache);
    VariantInit(&_vPrivCache);

    Assert(_dwPublicSN == 0);
    Assert(_dwPrivateSN == 0);
}

CScriptHost::~CScriptHost()
{
    int i;

    // Any thread can call the dtor.
    WHEN_DBG(_dwThreadId = GetCurrentThreadId());
    AssertSz(PopScript() == S_FALSE,
             "Script object not closed properly!");

    VariantClear(&_vPubCache);
    VariantClear(&_vPrivCache);

    for (i = 0; i < _aryEvtSinks.Size(); i++)
    {
        _aryEvtSinks[i]->Disconnect();
    }

    _aryEvtSinks.ReleaseAll();

    ReleaseInterface(_pTypeInfoIGlobalMTScript);
    ReleaseInterface(_pTypeInfoCMTScript);
}

HRESULT
CScriptHost::QueryInterface(REFIID iid, void **ppvObj)
{
    if (iid == IID_IGlobalMTScript || iid == IID_IUnknown || iid == IID_IDispatch)
    {
        *ppvObj = (IGlobalMTScript *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppvObj)->AddRef();
    return S_OK;
}

DWORD
CScriptHost::ThreadMain()
{
    HRESULT        hr;
    CStr           cstrScript;
    VARIANT        varParam;
    SCRIPT_PARAMS *pscrParams;

    VariantInit(&varParam);

    VERIFY_THREAD();

    pscrParams = (SCRIPT_PARAMS*)_pvParams;


    cstrScript.Set(pscrParams->pszPath);

#if DBG == 1
    char achBuf[10];
    cstrScript.GetMultiByte(achBuf, 10);
    SetName(achBuf);
#endif

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED |
                              COINIT_DISABLE_OLE1DDE   |
                              COINIT_SPEED_OVER_MEMORY);
    if (!SUCCEEDED(hr))
    {
        ThreadStarted(hr);  // Free our creating thread
        goto Cleanup;
    }

    if (pscrParams->pvarParams)
    {
        if (V_VT(pscrParams->pvarParams) == VT_DISPATCH)
        {
            // Unmarshal the IDispatch pointer being handed to us from the
            // other thread.

            IDispatch *pDisp;
            DWORD      dwCookie = V_I4(pscrParams->pvarParams);

            hr = _pMT->_pGIT->GetInterfaceFromGlobal(dwCookie,
                                                     IID_IDispatch,
                                                     (LPVOID*)&pDisp);
            if (!hr)
            {
                V_VT(&varParam) = VT_DISPATCH;
                V_DISPATCH(&varParam) = pDisp;
            }
        }
        else
        {
            VariantCopy(&varParam, pscrParams->pvarParams);
        }
    }

    // Hold a reference on ourself while the script is running
    AddRef();

    if (_fIsPrimaryScript)
    {

        hr = THR(LoadTypeLibrary());

        // Ensure that ScriptMain() completes before we fire any other events.
        _fDontHandleEvents = TRUE;
    }

    if (hr)
    {
        ThreadStarted(hr);
        goto Cleanup;
    }
    hr = ExecuteTopLevelScript(cstrScript, &varParam);
    if (hr)
    {
        ThreadStarted(hr);
        TraceTag((tagError, "Failed to execute script: %x", hr));
        AssertSz(!_fIsPrimaryScript, "Failed to execute script");

        PostQuitMessage(0);
        goto Cleanup;
    }
    ThreadStarted(hr);
    FireEvent(DISPID_MTScript_ScriptMain, 0, NULL);
    //
    // Secondary scripts go away as soon as they're done.
    //
    if (_fIsPrimaryScript)
    {
        DWORD dwRet;

        _fDontHandleEvents = FALSE;

        dwRet = MessageEventPump(TRUE);

        AssertSz(dwRet == MEP_EXIT, "NONFATAL: Invalid return value from MessageEventPump!");
    }
    else
    {
        CScriptHost *pThis = this;

        PostToThread(_pMT,
                     MD_SECONDARYSCRIPTTERMINATE,
                     (LPVOID)&pThis,
                     sizeof(CScriptHost*));
    }

Cleanup:
    CloseScripts();

    VariantClear(&varParam);

    if (_fIsPrimaryScript)
    {
        int i;

        for (i = 0; i < s_arySyncEvents.Size(); i++)
        {
            CloseHandle(s_arySyncEvents[i]._hEvent);
            s_arySyncEvents[i]._cstrName.Free();
        }

        s_arySyncEvents.DeleteAll();

        for (i = 0; i < (int)s_cThreadLocks; i++)
        {
            DeleteCriticalSection(&s_aThreadLocks[i]._csLock);
            s_aThreadLocks[i]._cstrName.Free();
        }

        memset(&s_aThreadLocks, 0, sizeof(s_aThreadLocks));
        s_cThreadLocks = 0;
    }

    Release();
    CoUninitialize();
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptHost::MessageEventPump, public
//
//  Synopsis:   Empties our message queues (both windows' and our private
//              threadcomm queue)
//
//  Arguments:  [fWait]     -- If TRUE, will not return until an event occurs
//              [cEvents]   -- Count of events to monitor
//              [pEvents]   -- Pointer to list of event handles
//              [fAll]      -- If TRUE, don't return until all handles in
//                               pEvents are signaled.
//              [dwTimeout] -- Timeout after this many ms if nothing signals
//              [fNoEvents] -- If TRUE, don't fire events while waiting
//
//  Returns:    MEP_TIMEOUT: The given timeout period expired without any
//                           event objects becoming signaled. Returned only
//                           if dwTimeout != INFINITE
//              MEP_EXIT: An event occurred which is causing this thread to
//                        terminate. The caller should clean up and finish
//                        what it's doing.
//              MEP_FALLTHROUGH: Indicates that no objects signaled.
//                               Returned only if fWait==FALSE.
//              MEP_EVENT_0: If one (or all if fAll==TRUE) of the passed-in
//                           event handles became signaled. The index of the
//                           signaled handle is added to MEP_EVENT_0. Returned
//                           only if 